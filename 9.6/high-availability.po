# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-05-10 10:49+0300\n"
"PO-Revision-Date: 2017-07-12 08:38+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"

#: high-availability.xml:5(title)
msgid "High Availability, Load Balancing, and Replication"
msgstr "Отказоустойчивость, балансировка нагрузки и репликация"

#: high-availability.xml:7(indexterm)
msgid "<primary>high availability</primary>"
msgstr "<primary>отказоустойчивость</primary>"

#: high-availability.xml:8(indexterm)
msgid "<primary>failover</primary>"
msgstr "<primary>отработка отказа</primary>"

#: high-availability.xml:9(indexterm)
msgid "<primary>replication</primary>"
msgstr "<primary>репликация</primary>"

#: high-availability.xml:10(indexterm)
msgid "<primary>load balancing</primary>"
msgstr "<primary>балансировка нагрузки</primary>"

#: high-availability.xml:11(indexterm)
msgid "<primary>clustering</primary>"
msgstr "<primary>кластеризация</primary>"

#: high-availability.xml:12(indexterm)
msgid "<primary>data partitioning</primary>"
msgstr "<primary>секционирование данных</primary>"

#: high-availability.xml:14(para)
msgid ""
"Database servers can work together to allow a second server to take over "
"quickly if the primary server fails (high availability), or to allow several "
"computers to serve the same data (load balancing). Ideally, database servers "
"could work together seamlessly. Web servers serving static web pages can be "
"combined quite easily by merely load-balancing web requests to multiple "
"machines. In fact, read-only database servers can be combined relatively "
"easily too. Unfortunately, most database servers have a read/write mix of "
"requests, and read/write servers are much harder to combine. This is because "
"though read-only data needs to be placed on each server only once, a write "
"to any server has to be propagated to all servers so that future read "
"requests to those servers return consistent results."
msgstr ""
"Серверы базы данных могут работать совместно для обеспечения возможности "
"быстрого переключения на другой сервер в случае отказа первого "
"(отказоустойчивость) или для обеспечения возможности нескольким серверам БД "
"обрабатывать один набор данных (балансировка нагрузки). В идеале, серверы БД "
"могут работать вместе прозрачно для клиента. Веб-серверы, обрабатывающие "
"статические страницы, можно совместить достаточно легко посредством простого "
"распределения запросов на несколько машин. Фактически серверы баз данных "
"только для чтения тоже могут быть совмещены достаточно легко. К сожалению, "
"большинство серверов баз данных получают смешанные запросы на чтение/запись, "
"а серверы с доступом на чтение/запись совместить гораздо сложнее. Это "
"объясняется тем, что данные только для чтения достаточно единожды разместить "
"на каждом сервере, а запись на любой из серверов должна распространиться на "
"все остальные серверы, чтобы будущие запросы на чтение возвращали "
"согласованные результаты."

#: high-availability.xml:30(para)
msgid ""
"This synchronization problem is the fundamental difficulty for servers "
"working together. Because there is no single solution that eliminates the "
"impact of the sync problem for all use cases, there are multiple solutions. "
"Each solution addresses this problem in a different way, and minimizes its "
"impact for a specific workload."
msgstr ""
"Проблема синхронизации является главным препятствием для совместной работы "
"серверов. Так как единственного решения, устраняющего проблему синхронизации "
"во всех случаях, не существует, предлагается несколько решений. Разные "
"решения подходят к проблеме по-разному и минимизируют её влияние в разных "
"рабочих условиях."

#: high-availability.xml:39(para)
msgid ""
"Some solutions deal with synchronization by allowing only one server to "
"modify the data. Servers that can modify data are called read/write, "
"<firstterm>master</firstterm> or <firstterm>primary</firstterm> servers. "
"Servers that track changes in the master are called <firstterm>standby</"
"firstterm> or <firstterm>slave</firstterm> servers. A standby server that "
"cannot be connected to until it is promoted to a master server is called a "
"<firstterm>warm standby</firstterm> server, and one that can accept "
"connections and serves read-only queries is called a <firstterm>hot standby</"
"firstterm> server."
msgstr ""
"Некоторые решения применяют синхронизацию, позволяя только одному серверу "
"изменять данные. Сервер, который может изменять данные, называется сервером "
"чтения/записи, <firstterm>главным</firstterm> или <firstterm>ведущим</"
"firstterm> сервером. Сервер, который отслеживает изменения на главном, "
"называется <firstterm>резервным</firstterm> или <firstterm>ведомым</"
"firstterm> сервером. Резервный сервер, к которому нельзя подключаться до тех "
"пор, пока он не будет повышен до главного, называется сервером "
"<firstterm>тёплого резерва</firstterm>, а тот, который может принимать "
"соединения и обрабатывать запросы только на чтение, называется сервером "
"<firstterm>горячего резерва</firstterm>."

#: high-availability.xml:50(para)
msgid ""
"Some solutions are synchronous, meaning that a data-modifying transaction is "
"not considered committed until all servers have committed the transaction. "
"This guarantees that a failover will not lose any data and that all load-"
"balanced servers will return consistent results no matter which server is "
"queried. In contrast, asynchronous solutions allow some delay between the "
"time of a commit and its propagation to the other servers, opening the "
"possibility that some transactions might be lost in the switch to a backup "
"server, and that load balanced servers might return slightly stale results. "
"Asynchronous communication is used when synchronous would be too slow."
msgstr ""
"Некоторые решения являются синхронными, при которых транзакция, "
"модифицирующая данные, не считается подтверждённой, пока все серверы не "
"подтвердят транзакцию. Это гарантирует, что при отработке отказа не "
"произойдёт потеря данных и что все балансирующие серверы возвращают "
"целостные данные вне зависимости от того, к какому серверу был запрос. "
"Асинхронное решение, напротив, допускает некоторую задержку между временем "
"подтверждения транзакции и её передачей на другие серверы, допуская "
"возможность, что некоторые транзакции могут быть потеряны в момент "
"переключения на резервный сервер и что балансирующие серверы могут вернуть "
"слегка устаревшие данные. Асинхронная передача используется, когда "
"синхронная будет слишком медленной."

#: high-availability.xml:64(para)
msgid ""
"Solutions can also be categorized by their granularity. Some solutions can "
"deal only with an entire database server, while others allow control at the "
"per-table or per-database level."
msgstr ""
"Решения могут так же разделяться по степени детализации. Некоторые решения "
"работают только на уровне всего сервера БД целиком, в то время как другие "
"позволяют работать на уровне таблиц или уровне БД."

#: high-availability.xml:70(para)
msgid ""
"Performance must be considered in any choice. There is usually a trade-off "
"between functionality and performance. For example, a fully synchronous "
"solution over a slow network might cut performance by more than half, while "
"an asynchronous one might have a minimal performance impact."
msgstr ""
"В любом случае необходимо принимать во внимание быстродействие. Обычно "
"выбирается компромисс между функциональностью и производительностью. "
"Например, полностью синхронное решение в медленной сети может снизить "
"производительность больше чем наполовину, в то время как асинхронное решение "
"будет оказывать минимальное воздействие."

#: high-availability.xml:78(para)
msgid ""
"The remainder of this section outlines various failover, replication, and "
"load balancing solutions."
msgstr ""
"В продолжении этого раздела рассматриваются различные решения по организации "
"отказоустойчивости, репликации и балансировки нагрузки."

#: high-availability.xml:84(title)
msgid "Comparison of Different Solutions"
msgstr "Сравнение различных решений"

#: high-availability.xml:89(term)
msgctxt "term"
msgid "Shared Disk Failover"
msgstr "Отказоустойчивость на разделяемых дисках"

#: high-availability.xml:92(para)
msgid ""
"Shared disk failover avoids synchronization overhead by having only one copy "
"of the database. It uses a single disk array that is shared by multiple "
"servers. If the main database server fails, the standby server is able to "
"mount and start the database as though it were recovering from a database "
"crash. This allows rapid failover with no data loss."
msgstr ""
"Отказоустойчивость на разделяемых дисках позволяет избежать избыточности "
"синхронизации путём задействования только одной копии базы данных. Она "
"использует единственный дисковый массив, который разделяется между "
"несколькими серверами. Если основной сервер БД откажет, резервный сервер "
"может подключиться и запустить базу данных, что позволит восстановить БД "
"после аварии. Это обеспечивает быстрое переключение без потери данных."

#: high-availability.xml:100(para)
msgid ""
"Shared hardware functionality is common in network storage devices. Using a "
"network file system is also possible, though care must be taken that the "
"file system has full <acronym>POSIX</acronym> behavior (see <xref linkend="
"\"creating-cluster-nfs\"/>). One significant limitation of this method is "
"that if the shared disk array fails or becomes corrupt, the primary and "
"standby servers are both nonfunctional. Another issue is that the standby "
"server should never access the shared storage while the primary server is "
"running."
msgstr ""
"Функциональность разделяемого оборудования обычно реализована в сетевых "
"устройствах хранения. Так же возможно применение сетевой файловой системы, "
"особое внимание следует уделить тому, чтобы поведение системы полностью "
"соответствовало <acronym>POSIX</acronym> (см. <xref remap=\"4\" linkend="
"\"creating-cluster-nfs\"/>). Существенное ограничение этого метода состоит в "
"том, что в случае отказа или порчи разделяемого дискового массива оба "
"сервера: ведущий и резервный — станут нерабочими. Другая особенность — "
"резервный сервер никогда не получает доступ к разделяемым дискам во время "
"работы ведущего."

#: high-availability.xml:115(term)
msgid "File System (Block-Device) Replication"
msgstr "Репликация на уровне файловой системы (блочного устройства)"

#: high-availability.xml:118(para)
msgid ""
"A modified version of shared hardware functionality is file system "
"replication, where all changes to a file system are mirrored to a file "
"system residing on another computer. The only restriction is that the "
"mirroring must be done in a way that ensures the standby server has a "
"consistent copy of the file system &mdash; specifically, writes to the "
"standby must be done in the same order as those on the master. "
"<productname>DRBD</productname> is a popular file system replication "
"solution for Linux."
msgstr ""
"Видоизменённая версия функциональности разделяемого оборудования "
"представлена в виде репликации на уровне файловой системы, когда все "
"изменения в файловой системе отражаются в файловой системе другого "
"компьютера. Единственное ограничение: синхронизация должна выполняться "
"методом, гарантирующим целостность копии файловой системы на резервном "
"сервере &mdash; в частности, запись на резервном сервере должна происходить "
"в том же порядке, что и на главном. <productname>DRBD</productname> является "
"популярным решением на основе репликации файловой системы для Linux."

#: high-availability.xml:142(term)
msgctxt "term"
msgid "Transaction Log Shipping"
msgstr "Трансляция журнала транзакций"

#: high-availability.xml:145(para)
msgid ""
"Warm and hot standby servers can be kept current by reading a stream of "
"write-ahead log (<acronym>WAL</acronym>) records. If the main server fails, "
"the standby contains almost all of the data of the main server, and can be "
"quickly made the new master database server. This can be synchronous or "
"asynchronous and can only be done for the entire database server."
msgstr ""
"Серверы тёплого и горячего резерва могут так же поддерживаться актуальными "
"путём чтения потока записей из журнала изменений (<acronym>WAL</acronym>). "
"Если основной сервер отказывает, резервный содержит почти все данные с него "
"и может быть быстро преобразован в новый главный сервер БД. Это можно "
"сделать синхронно или асинхронно, но может быть выполнено только на уровне "
"сервера БД целиком."

#: high-availability.xml:153(para)
msgid ""
"A standby server can be implemented using file-based log shipping (<xref "
"linkend=\"warm-standby\"/>) or streaming replication (see <xref linkend="
"\"streaming-replication\"/>), or a combination of both. For information on "
"hot standby, see <xref linkend=\"hot-standby\"/>."
msgstr ""
"Резервный сервер может быть реализован с применением трансляции файлов "
"журналов (см. <xref remap=\"4\" linkend=\"warm-standby\"/>), или потоковой "
"репликации (см. <xref remap=\"4\" linkend=\"streaming-replication\"/>), или "
"их комбинацией. За информацией о горячем резерве обратитесь к <xref remap="
"\"3\" linkend=\"hot-standby\"/>."

#: high-availability.xml:163(term)
msgctxt "term"
msgid "Trigger-Based Master-Standby Replication"
msgstr "Репликация главный-резервный на основе триггеров"

#: high-availability.xml:166(para)
msgid ""
"A master-standby replication setup sends all data modification queries to "
"the master server. The master server asynchronously sends data changes to "
"the standby server. The standby can answer read-only queries while the "
"master server is running. The standby server is ideal for data warehouse "
"queries."
msgstr ""
"При репликации главный-резервный все запросы, изменяющие данные, "
"пересылаются главному серверу. Главный сервер, в свою очередь, асинхронно "
"пересылает изменённые данные резервному. Резервный сервер может обрабатывать "
"запросы только на чтение при работающем главном. Такой резервный сервер "
"идеален для обработки запросов к хранилищам данных."

#: high-availability.xml:174(para)
msgid ""
"<productname>Slony-I</productname> is an example of this type of "
"replication, with per-table granularity, and support for multiple standby "
"servers. Because it updates the standby server asynchronously (in batches), "
"there is possible data loss during fail over."
msgstr ""
"<productname>Slony-I</productname> является примером подобного типа "
"репликации, действующей на уровне таблиц, и поддерживает множество резервных "
"серверов. Так как обновления на резервных серверах происходят асинхронно (в "
"пакетах), возможна потеря данных во время отказа."

#: high-availability.xml:184(term)
msgctxt "term"
msgid "Statement-Based Replication Middleware"
msgstr "Репликация запросов в среднем слое"

#: high-availability.xml:187(para)
msgid ""
"With statement-based replication middleware, a program intercepts every SQL "
"query and sends it to one or all servers. Each server operates "
"independently. Read-write queries must be sent to all servers, so that every "
"server receives any changes. But read-only queries can be sent to just one "
"server, allowing the read workload to be distributed among them."
msgstr ""
"В схеме с репликацией запросов в среднем слое, средний слой перехватывает "
"каждый SQL-запрос и пересылает его на один или все серверы. Каждый сервер "
"работает независимо. Модифицирующие запросы должны быть направлены всем "
"серверам, чтобы каждый из них получал все изменения. Но читающие запросы "
"могут быть посланы только на один сервер, что позволяет перераспределить "
"читающую нагрузку между всеми серверами."

#: high-availability.xml:196(para)
msgid ""
"If queries are simply broadcast unmodified, functions like "
"<function>random()</function>, <function>CURRENT_TIMESTAMP</function>, and "
"sequences can have different values on different servers. This is because "
"each server operates independently, and because SQL queries are broadcast "
"(and not actual modified rows). If this is unacceptable, either the "
"middleware or the application must query such values from a single server "
"and then use those values in write queries. Another option is to use this "
"replication option with a traditional master-standby setup, i.e. data "
"modification queries are sent only to the master and are propagated to the "
"standby servers via master-standby replication, not by the replication "
"middleware. Care must also be taken that all transactions either commit or "
"abort on all servers, perhaps using two-phase commit (<xref linkend=\"sql-"
"prepare-transaction\"/> and <xref linkend=\"sql-commit-prepared\"/>). "
"<productname>Pgpool-II</productname> and <productname>Continuent Tungsten</"
"productname> are examples of this type of replication."
msgstr ""
"Если запросы просто перенаправлять без изменений, функции подобные "
"<function>random()</function>, <function>CURRENT_TIMESTAMP</function> и "
"последовательности могут получить различные значения на разных серверах. Это "
"происходит потому что каждый сервер работает независимо, а эти запросы "
"неизбирательные (и действительно не изменяют строки). Если такая ситуация "
"недопустима, или средний слой, или приложение должно запросить подобные "
"значения с одного сервера, затем использовать его в других пишущих запросах. "
"Другим способом является применения этого вида репликации совместно с другим "
"традиционным набором репликации главный-резервный, то есть изменяющие данные "
"запросы посылаются только на главный сервер, а затем применяются на "
"резервном в процессе этой репликации, но не с помощью реплицирующего "
"среднего слоя. Следует иметь в виду, что все транзакции фиксируются или "
"прерываются на всех серверах, возможно с применением двухфазной фиксации "
"(см. <xref remap=\"4\" linkend=\"sql-prepare-transaction\"/> и <xref remap="
"\"4\" linkend=\"sql-commit-prepared\"/>). Репликацию такого типа реализуют, "
"например <productname>Pgpool-II</productname> и <productname>Continuent "
"Tungsten</productname>."

#: high-availability.xml:219(term)
msgctxt "term"
msgid "Asynchronous Multimaster Replication"
msgstr "Асинхронная репликация с несколькими главными серверами"

#: high-availability.xml:222(para)
msgid ""
"For servers that are not regularly connected, like laptops or remote "
"servers, keeping data consistent among servers is a challenge. Using "
"asynchronous multimaster replication, each server works independently, and "
"periodically communicates with the other servers to identify conflicting "
"transactions. The conflicts can be resolved by users or conflict resolution "
"rules. Bucardo is an example of this type of replication."
msgstr ""
"Если серверы не находятся постоянно в единой сети, как например, ноутбуки "
"или удалённые серверы, обеспечение согласованности данных между ними "
"представляет проблему. Когда используется асинхронная репликация с "
"несколькими главными серверами, каждый из них работает независимо и "
"периодически связывается с другими серверами для определения конфликтующих "
"транзакций. Конфликты могут урегулироваться пользователем или по правилам их "
"разрешения. Примером такого типа репликации является Bucardo."

#: high-availability.xml:235(term)
msgctxt "term"
msgid "Synchronous Multimaster Replication"
msgstr "Синхронная репликация с несколькими главными серверами"

#: high-availability.xml:238(para)
msgid ""
"In synchronous multimaster replication, each server can accept write "
"requests, and modified data is transmitted from the original server to every "
"other server before each transaction commits. Heavy write activity can cause "
"excessive locking, leading to poor performance. In fact, write performance "
"is often worse than that of a single server. Read requests can be sent to "
"any server. Some implementations use shared disk to reduce the communication "
"overhead. Synchronous multimaster replication is best for mostly read "
"workloads, though its big advantage is that any server can accept write "
"requests &mdash; there is no need to partition workloads between master and "
"standby servers, and because the data changes are sent from one server to "
"another, there is no problem with non-deterministic functions like "
"<function>random()</function>."
msgstr ""
"При синхронной репликации с несколькими главными серверами каждый сервер "
"может принимать запросы на запись, а изменённые данные передаются с "
"начального сервера всем остальным, прежде чем транзакция будет подтверждена. "
"Если запись производится интенсивно, это может провоцировать избыточные "
"блокировки, что приводит к снижению производительности. На самом деле "
"производительность при записи часто бывает хуже, чем с одним сервером. "
"Запросы на чтение также могут быть обработаны любым сервером. В некоторых "
"конфигурациях для более эффективного взаимодействия серверов применяются "
"разделяемые диски. Синхронная репликация с несколькими главными серверами "
"лучше всего работает, когда преобладают операции чтения, хотя её большой "
"плюс в том, что любой сервер может принимать запросы на запись &mdash; нет "
"необходимости искусственно разделять нагрузку между главным и резервными "
"серверами, а так как изменения передаются от одного сервера другим, не "
"возникает проблем с недетерминированными функциями вроде <function>random()</"
"function>."

#: high-availability.xml:255(para)
msgid ""
"<productname>PostgreSQL</productname> does not offer this type of "
"replication, though <productname>PostgreSQL</productname> two-phase commit "
"(<xref linkend=\"sql-prepare-transaction\"/> and <xref linkend=\"sql-commit-"
"prepared\"/>) can be used to implement this in application code or "
"middleware."
msgstr ""
"<productname>PostgreSQL</productname> не предоставляет данный тип "
"репликации, но так как <productname>PostgreSQL</productname> поддерживает "
"двухфазное подтверждение транзакции (<xref linkend=\"sql-prepare-transaction"
"\"/> и <xref linkend=\"sql-commit-prepared\"/>) такое поведение может быть "
"реализовано в коде приложения или среднего слоя."

#: high-availability.xml:266(term)
msgid "Commercial Solutions"
msgstr "Коммерческие решения"

#: high-availability.xml:269(para)
msgid ""
"Because <productname>PostgreSQL</productname> is open source and easily "
"extended, a number of companies have taken <productname>PostgreSQL</"
"productname> and created commercial closed-source solutions with unique "
"failover, replication, and load balancing capabilities."
msgstr ""
"Так как <productname>PostgreSQL</productname> обладает открытым кодом и "
"легко расширяется, некоторые компании взяли за основу "
"<productname>PostgreSQL</productname> и создали коммерческие решения с "
"закрытым кодом со своими реализациями свойств отказоустойчивости, репликации "
"и балансировки нагрузки."

#: high-availability.xml:280(para)
msgid ""
"<xref linkend=\"high-availability-matrix\"/> summarizes the capabilities of "
"the various solutions listed above."
msgstr ""
"<xref linkend=\"high-availability-matrix\"/> итоговая таблица возможностей "
"различных решений приведена ниже."

#: high-availability.xml:286(title)
msgid "High Availability, Load Balancing, and Replication Feature Matrix"
msgstr "Таблица свойств отказоустойчивости, балансировки нагрузки и репликации"

#: high-availability.xml:290(entry)
msgid "Feature"
msgstr "Тип"

#: high-availability.xml:291(entry)
msgctxt "entry"
msgid "Shared Disk Failover"
msgstr "Отказоустойчивость через разделяемые диски"

#: high-availability.xml:292(entry)
msgid "File System Replication"
msgstr "Репликация файловой системы"

#: high-availability.xml:293(entry)
msgctxt "entry"
msgid "Transaction Log Shipping"
msgstr "Трансляция журнала транзакций"

#: high-availability.xml:294(entry)
msgctxt "entry"
msgid "Trigger-Based Master-Standby Replication"
msgstr "Репликация главный-резервный на основе триггеров"

#: high-availability.xml:295(entry)
msgctxt "entry"
msgid "Statement-Based Replication Middleware"
msgstr "Репликация запросов в среднем слое"

#: high-availability.xml:296(entry)
msgctxt "entry"
msgid "Asynchronous Multimaster Replication"
msgstr "Асинхронная репликация с несколькими главными серверами"

#: high-availability.xml:297(entry)
msgctxt "entry"
msgid "Synchronous Multimaster Replication"
msgstr "Синхронная репликация с несколькими главными серверами"

#: high-availability.xml:304(entry)
msgid "Most Common Implementation"
msgstr "Наиболее типичная реализация"

#: high-availability.xml:305(entry)
msgid "NAS"
msgstr "NAS"

#: high-availability.xml:306(entry)
msgid "DRBD"
msgstr "DRBD"

#: high-availability.xml:307(entry)
msgid "Streaming Repl."
msgstr "Потоковая репликация"

#: high-availability.xml:308(entry)
msgid "Slony"
msgstr "Slony"

#: high-availability.xml:309(entry)
msgid "pgpool-II"
msgstr "pgpool-II"

#: high-availability.xml:310(entry)
msgid "Bucardo"
msgstr "Bucardo"

#: high-availability.xml:315(entry)
msgid "Communication Method"
msgstr "Метод взаимодействия"

#: high-availability.xml:316(entry)
msgid "shared disk"
msgstr "разделяемые диски"

#: high-availability.xml:317(entry)
msgid "disk blocks"
msgstr "дисковые блоки"

#: high-availability.xml:318(entry)
msgid "WAL"
msgstr "WAL"

#: high-availability.xml:319(entry) high-availability.xml:321(entry)
msgid "table rows"
msgstr "Строки таблицы"

#: high-availability.xml:320(entry)
msgid "SQL"
msgstr "SQL"

#: high-availability.xml:322(entry)
msgid "table rows and row locks"
msgstr "Строки таблицы и блокировки строк"

#: high-availability.xml:326(entry)
msgid "No special hardware required"
msgstr "Не требуется специального оборудования"

#: high-availability.xml:337(entry)
msgid "Allows multiple master servers"
msgstr "Допускается несколько главных серверов"

#: high-availability.xml:348(entry)
msgid "No master server overhead"
msgstr "Нет избыточности главного сервера"

#: high-availability.xml:359(entry)
msgid "No waiting for multiple servers"
msgstr "Нет задержки при нескольких серверах"

#: high-availability.xml:362(entry)
msgid "with sync off"
msgstr "без синхр."

#: high-availability.xml:370(entry)
msgid "Master failure will never lose data"
msgstr "Отказ главного сервера не может привести к потере данных"

#: high-availability.xml:373(entry)
msgid "with sync on"
msgstr "с синхр."

#: high-availability.xml:381(entry)
msgid "Standby accept read-only queries"
msgstr "Резервный сервер принимает читающие запросы"

#: high-availability.xml:384(entry)
msgid "with hot"
msgstr "с горячим резервом"

#: high-availability.xml:392(entry)
msgid "Per-table granularity"
msgstr "Репликация на уровне таблиц"

#: high-availability.xml:403(entry)
msgid "No conflict resolution necessary"
msgstr "Не требуется разрешение конфликтов"

#: high-availability.xml:417(para)
msgid "There are a few solutions that do not fit into the above categories:"
msgstr "Несколько решений, которые не подпадают под указанные выше категории:"

#: high-availability.xml:424(term)
msgid "Data Partitioning"
msgstr "Секционирование данных"

#: high-availability.xml:427(para)
msgid ""
"Data partitioning splits tables into data sets. Each set can be modified by "
"only one server. For example, data can be partitioned by offices, e.g., "
"London and Paris, with a server in each office. If queries combining London "
"and Paris data are necessary, an application can query both servers, or "
"master/standby replication can be used to keep a read-only copy of the other "
"office's data on each server."
msgstr ""
"При секционировании таблицы расщепляются на наборы данных. Каждый из наборов "
"может быть изменён только на одном сервере. Например, данные могут быть "
"секционированы по офисам, например, Лондон и Париж, с сервером в каждом "
"офисе. В случае необходимости обращения одновременно к данным Лондона и "
"Парижа, приложение может запросить оба сервера, или может быть применена "
"репликация главный-резервный для предоставления копии только для чтения в "
"другом офисе для каждого из серверов."

#: high-availability.xml:440(term)
msgid "Multiple-Server Parallel Query Execution"
msgstr "Выполнение параллельных запросов на нескольких серверах"

#: high-availability.xml:443(para)
msgid ""
"Many of the above solutions allow multiple servers to handle multiple "
"queries, but none allow a single query to use multiple servers to complete "
"faster. This solution allows multiple servers to work concurrently on a "
"single query. It is usually accomplished by splitting the data among servers "
"and having each server execute its part of the query and return results to a "
"central server where they are combined and returned to the user. "
"<productname>Pgpool-II</productname> has this capability. Also, this can be "
"implemented using the <productname>PL/Proxy</productname> tool set."
msgstr ""
"Многие из указанных выше решений позволяют обрабатывать несколько запросов "
"на нескольких серверах, но ни один из них не может обрабатывать один запрос "
"с применением нескольких серверов для уменьшения общего времени выполнения. "
"Подобное решение позволяет нескольким серверам обрабатывать один запрос "
"одновременно. Такое обычно достигается путём разделения данных между "
"серверами, обработкой на сервере своей части запроса с возвратом результата "
"на центральный сервер. Там данные проходят окончательную обработку и "
"возвращаются пользователю. <productname>Pgpool-II</productname> "
"предоставляет такую возможность. Так же это может быть реализовано с "
"применением набора средств <productname>PL/Proxy</productname>."

#: high-availability.xml:464(title)
msgid "Log-Shipping Standby Servers"
msgstr "Трансляция журналов на резервные серверы"

#: high-availability.xml:467(para)
msgid ""
"Continuous archiving can be used to create a <firstterm>high availability</"
"firstterm> (HA) cluster configuration with one or more <firstterm>standby "
"servers</firstterm> ready to take over operations if the primary server "
"fails. This capability is widely referred to as <firstterm>warm standby</"
"firstterm> or <firstterm>log shipping</firstterm>."
msgstr ""
"Постоянная архивация может использоваться для создания кластерной "
"конфигурации <firstterm>высокой степени доступности</firstterm> (HA) с одним "
"или несколькими <firstterm>резервными серверами</firstterm>, способными "
"заменить ведущий сервер в случае выхода его из строя. Такую реализацию "
"отказоустойчивости часто называют <firstterm>тёплый резерв</firstterm> или "
"<firstterm>трансляция журналов</firstterm>."

#: high-availability.xml:475(para)
msgid ""
"The primary and standby server work together to provide this capability, "
"though the servers are only loosely coupled. The primary server operates in "
"continuous archiving mode, while each standby server operates in continuous "
"recovery mode, reading the WAL files from the primary. No changes to the "
"database tables are required to enable this capability, so it offers low "
"administration overhead compared to some other replication solutions. This "
"configuration also has relatively low performance impact on the primary "
"server."
msgstr ""
"Ведущий и резервный серверы работают совместно для обеспечения этой "
"возможности, при этом они связаны опосредованно. Ведущий сервер работает в "
"режиме постоянной архивации изменений, в то время как каждый резервный "
"сервер работает в режиме постоянного приема архивных изменений, зачитывая "
"WAL-файлы с ведущего. Для обеспечения этой возможности не требуется вносить "
"изменения в таблицы БД, что требует существенно меньших административных "
"издержек в сравнении с некоторыми другими решениями репликации. Так же такая "
"конфигурация относительно слабо влияет на производительность ведущего "
"сервера."

#: high-availability.xml:486(para)
msgid ""
"Directly moving WAL records from one database server to another is typically "
"described as log shipping. <productname>PostgreSQL</productname> implements "
"file-based log shipping by transferring WAL records one file (WAL segment) "
"at a time. WAL files (16MB) can be shipped easily and cheaply over any "
"distance, whether it be to an adjacent system, another system at the same "
"site, or another system on the far side of the globe. The bandwidth required "
"for this technique varies according to the transaction rate of the primary "
"server. Record-based log shipping is more granular and streams WAL changes "
"incrementally over a network connection (see <xref linkend=\"streaming-"
"replication\"/>)."
msgstr ""
"Непосредственную передачу записей WAL с одного сервера БД на другой обычно "
"называют трансляцией журналов (или доставкой журналов). "
"<productname>PostgreSQL</productname> реализует трансляцию журналов на "
"уровне файлов, передавая записи WAL по одному файлу (сегменту WAL) "
"единовременно. Файлы WAL (размером 16 МБ) можно легко и эффективно передать "
"на любое расстояние, будь то соседний сервер, другая система в местной сети "
"или сервер на другом краю света. Требуемая пропускная способность при таком "
"подходе определяется скоростью записи транзакций на ведущем сервере. "
"Трансляция журналов на уровне записей более фрагментарная операция, при "
"которой изменения WAL передаются последовательно через сетевое соединение "
"(см. <xref remap=\"4\" linkend=\"streaming-replication\"/>)."

#: high-availability.xml:500(para)
msgid ""
"It should be noted that log shipping is asynchronous, i.e., the WAL records "
"are shipped after transaction commit. As a result, there is a window for "
"data loss should the primary server suffer a catastrophic failure; "
"transactions not yet shipped will be lost. The size of the data loss window "
"in file-based log shipping can be limited by use of the "
"<varname>archive_timeout</varname> parameter, which can be set as low as a "
"few seconds. However such a low setting will substantially increase the "
"bandwidth required for file shipping. Streaming replication (see <xref "
"linkend=\"streaming-replication\"/>) allows a much smaller window of data "
"loss."
msgstr ""
"Следует отметить, что трансляция журналов асинхронна, то есть записи WAL "
"доставляются после завершения транзакции. В результате образуется окно, "
"когда возможна потеря данных при отказе сервера: будут утеряны ещё не "
"переданные транзакции. Размер этого окна при трансляции файлов журналов "
"может быть ограничен параметром <varname>archive_timeout</varname>, который "
"может принимать значение меньше нескольких секунд. Тем не менее подобные "
"заниженные значения могут потребовать существенного увеличения пропускной "
"способности, необходимой для трансляции файлов. При потоковой репликации "
"(см. <xref remap=\"4\" linkend=\"streaming-replication\"/>) окно возможности "
"потери данных гораздо меньше."

#: high-availability.xml:513(para)
msgid ""
"Recovery performance is sufficiently good that the standby will typically be "
"only moments away from full availability once it has been activated. As a "
"result, this is called a warm standby configuration which offers high "
"availability. Restoring a server from an archived base backup and "
"rollforward will take considerably longer, so that technique only offers a "
"solution for disaster recovery, not high availability. A standby server can "
"also be used for read-only queries, in which case it is called a Hot Standby "
"server. See <xref linkend=\"hot-standby\"/> for more information."
msgstr ""
"Скорость восстановления достаточно высока, обычно резервный сервер "
"становится полностью доступным через мгновение после активации. В результате "
"такое решение называется тёплым резервом, что обеспечивает отличную "
"отказоустойчивость. Восстановление сервера из архивной копии базы и "
"применение изменений обычно происходит существенно дольше. Поэтому такие "
"действия обычно требуются при восстановлении после аварии, не для "
"отказоустойчивости. Так же резервный сервер может обрабатывать читающие "
"запросы. В этом случае он называется сервером горячего резерва. См. <xref "
"remap=\"4\" linkend=\"hot-standby\"/> для подробной информации."

#: high-availability.xml:526(indexterm)
msgid "<primary>warm standby</primary>"
msgstr "<primary>тёплый резерв</primary>"

#: high-availability.xml:530(indexterm)
msgid "<primary>PITR standby</primary>"
msgstr "<primary>PITR резерв</primary>"

#: high-availability.xml:534(indexterm)
msgid "<primary>standby server</primary>"
msgstr "<primary>резервный сервер</primary>"

#: high-availability.xml:538(indexterm)
msgid "<primary>log shipping</primary>"
msgstr "<primary>трансляция журналов</primary>"

#: high-availability.xml:542(indexterm)
msgid "<primary>witness server</primary>"
msgstr "<primary>следящий сервер</primary>"

#: high-availability.xml:546(indexterm)
msgid "<primary>STONITH</primary>"
msgstr "<primary>STONITH</primary>"

#: high-availability.xml:551(title)
msgid "Planning"
msgstr "Планирование"

#: high-availability.xml:553(para)
msgid ""
"It is usually wise to create the primary and standby servers so that they "
"are as similar as possible, at least from the perspective of the database "
"server. In particular, the path names associated with tablespaces will be "
"passed across unmodified, so both primary and standby servers must have the "
"same mount paths for tablespaces if that feature is used. Keep in mind that "
"if <xref linkend=\"sql-createtablespace\"/> is executed on the primary, any "
"new mount point needed for it must be created on the primary and all standby "
"servers before the command is executed. Hardware need not be exactly the "
"same, but experience shows that maintaining two identical systems is easier "
"than maintaining two dissimilar ones over the lifetime of the application "
"and system. In any case the hardware architecture must be the same &mdash; "
"shipping from, say, a 32-bit to a 64-bit system will not work."
msgstr ""
"Обычно разумно подбирать ведущий и резервный серверы так, чтобы они были "
"максимально похожи, как минимум с точки зрения базы данных. Тогда в "
"частности, пути, связанные с табличными пространствами, могут передаваться "
"без изменений. Таким образом, как на ведущем, так и на резервных серверах "
"должны быть одинаковые пути монтирования для табличных пространств при "
"использовании этой возможности БД. Учитывайте, что если <xref linkend=\"sql-"
"createtablespace\"/> выполнена на ведущем сервере, новая точка монтирования "
"для этой команды уже должна существовать на резервных серверах до её "
"выполнения. Аппаратная часть не должна быть в точности одинаковой, но опыт "
"показывает, что сопровождать идентичные системы легче, чем две различные на "
"протяжении жизненного цикла приложения и системы. В любом случае архитектура "
"оборудования должна быть одинаковой &mdash; например, трансляция журналов с "
"32-битной на 64-битную систему не будет работать."

#: high-availability.xml:570(para)
msgid ""
"In general, log shipping between servers running different major "
"<productname>PostgreSQL</productname> release levels is not possible. It is "
"the policy of the PostgreSQL Global Development Group not to make changes to "
"disk formats during minor release upgrades, so it is likely that running "
"different minor release levels on primary and standby servers will work "
"successfully. However, no formal support for that is offered and you are "
"advised to keep primary and standby servers at the same release level as "
"much as possible. When updating to a new minor release, the safest policy is "
"to update the standby servers first &mdash; a new minor release is more "
"likely to be able to read WAL files from a previous minor release than vice "
"versa."
msgstr ""
"В общем случае трансляция журналов между серверами с различными основными "
"версиями <productname>PostgreSQL</productname> невозможна. Политика главной "
"группы разработки PostgreSQL состоит в том, чтобы не вносить изменения в "
"дисковые форматы при обновлениях корректирующей версии, таким образом, "
"ведущий и резервный серверы, имеющие разные корректирующие версии, могут "
"работать успешно. Тем не менее, формально такая возможность не "
"поддерживается и рекомендуется поддерживать одинаковую версию ведущего и "
"резервных серверов, насколько это возможно. При обновлении корректирующей "
"версии безопаснее будет в первую очередь обновить резервные серверы &mdash; "
"новая корректирующая версия с большей вероятностью прочитает файл WAL "
"предыдущей корректирующей версии, чем наоборот."

#: high-availability.xml:588(title)
msgid "Standby Server Operation"
msgstr "Работа резервного сервера"

#: high-availability.xml:590(para)
msgid ""
"In standby mode, the server continuously applies WAL received from the "
"master server. The standby server can read WAL from a WAL archive (see <xref "
"linkend=\"restore-command\"/>) or directly from the master over a TCP "
"connection (streaming replication). The standby server will also attempt to "
"restore any WAL found in the standby cluster's <filename>pg_xlog</filename> "
"directory. That typically happens after a server restart, when the standby "
"replays again WAL that was streamed from the master before the restart, but "
"you can also manually copy files to <filename>pg_xlog</filename> at any time "
"to have them replayed."
msgstr ""
"Сервер, работающий в режиме резервного, последовательно применяет файлы WAL, "
"полученные от главного. Резервный сервер может читать файлы WAL из архива "
"WAL (см. <xref remap=\"4\" linkend=\"restore-command\"/>) или напрямую с "
"главного сервера по соединению TCP (потоковая репликация). Резервный сервер "
"так же будет пытаться восстановить любой файл WAL, найденный в кластере "
"резервного в каталоге <filename>pg_xlog</filename>. Это обычно происходит "
"после перезапуска сервера, когда он применяет заново файлы WAL, полученные "
"от главного сервера перед перезапуском. Но можно и вручную скопировать файлы "
"в каталог <filename>pg_xlog</filename>, чтобы применить их в любой момент "
"времени."

#: high-availability.xml:602(para)
msgid ""
"At startup, the standby begins by restoring all WAL available in the archive "
"location, calling <varname>restore_command</varname>. Once it reaches the "
"end of WAL available there and <varname>restore_command</varname> fails, it "
"tries to restore any WAL available in the <filename>pg_xlog</filename> "
"directory. If that fails, and streaming replication has been configured, the "
"standby tries to connect to the primary server and start streaming WAL from "
"the last valid record found in archive or <filename>pg_xlog</filename>. If "
"that fails or streaming replication is not configured, or if the connection "
"is later disconnected, the standby goes back to step 1 and tries to restore "
"the file from the archive again. This loop of retries from the archive, "
"<filename>pg_xlog</filename>, and via streaming replication goes on until "
"the server is stopped or failover is triggered by a trigger file."
msgstr ""
"В момент запуска резервный сервер начинает восстанавливать все доступные "
"файлы WAL, размещённые в архивном каталоге, указанном в команде "
"<varname>restore_command</varname>. По достижении конца доступных файлов WAL "
"или при сбое команды <varname>restore_command</varname> сервер пытается "
"восстановить все файлы WAL, доступные в каталоге <filename>pg_xlog</"
"filename>. Если это не удаётся и потоковая репликация настроена, резервный "
"сервер пытается присоединиться к ведущему и начать закачивать поток WAL с "
"последней подтверждённой записи, найденной в архиве или <filename>pg_xlog</"
"filename>. Если это действие закончилось неудачей, или потоковая репликация "
"не настроена, или соединение позднее разорвалось, резервный сервер "
"возвращается к шагу 1 и пытается восстановить файлы из архива вновь. Цикл "
"обращения за файлами WAL к архиву, <filename>pg_xlog</filename>, и через "
"потоковую репликацию продолжается до остановки сервера или переключения его "
"роли, вызванного файлом-триггером."

#: high-availability.xml:617(para)
msgid ""
"Standby mode is exited and the server switches to normal operation when "
"<command>pg_ctl promote</command> is run or a trigger file is found "
"(<varname>trigger_file</varname>). Before failover, any WAL immediately "
"available in the archive or in <filename>pg_xlog</filename> will be "
"restored, but no attempt is made to connect to the master."
msgstr ""
"Режим резерва завершается и сервер переключается в обычный рабочий режим при "
"получении команды <command>pg_ctl promote</command> или при обнаружении "
"файла-триггера (<varname>trigger_file</varname>). Перед переключением сервер "
"восстановит все файлы WAL, непосредственно доступные из архива или "
"<filename>pg_xlog</filename>, но пытаться подключиться к главному серверу он "
"больше не будет."

#: high-availability.xml:627(title)
msgid "Preparing the Master for Standby Servers"
msgstr "Подготовка главного сервера для работы с резервными"

#: high-availability.xml:629(para)
msgid ""
"Set up continuous archiving on the primary to an archive directory "
"accessible from the standby, as described in <xref linkend=\"continuous-"
"archiving\"/>. The archive location should be accessible from the standby "
"even when the master is down, i.e. it should reside on the standby server "
"itself or another trusted server, not on the master server."
msgstr ""
"Настройка постоянного архивирования на ведущем сервере в архивный каталог, "
"доступный с резервного, описана в <xref remap=\"6\" linkend=\"continuous-"
"archiving\"/>. Расположение архива должно быть доступно с резервного сервера "
"даже при отключении главного, то есть его следует разместить на резервном "
"или другом доверенном, но не на главном сервере."

#: high-availability.xml:638(para)
msgid ""
"If you want to use streaming replication, set up authentication on the "
"primary server to allow replication connections from the standby server(s); "
"that is, create a role and provide a suitable entry or entries in "
"<filename>pg_hba.conf</filename> with the database field set to "
"<literal>replication</literal>. Also ensure <varname>max_wal_senders</"
"varname> is set to a sufficiently large value in the configuration file of "
"the primary server. If replication slots will be used, ensure that "
"<varname>max_replication_slots</varname> is set sufficiently high as well."
msgstr ""
"При использовании потоковой репликации следует настроить режим "
"аутентификации на ведущем сервере, чтобы разрешить соединения с резервных. "
"Для этого создать роль и обеспечить подходящую запись в файле "
"<filename>pg_hba.conf</filename> в разделе доступа к БД "
"<literal>replication</literal>. Так же следует убедиться, что для параметра "
"<varname>max_wal_senders</varname> задаётся достаточно большое значение в "
"конфигурационном файле ведущего сервера. При использовании слотов для "
"репликации также достаточно большое значение нужно задать для "
"<varname>max_replication_slots</varname>."

#: high-availability.xml:650(para)
msgid ""
"Take a base backup as described in <xref linkend=\"backup-base-backup\"/> to "
"bootstrap the standby server."
msgstr ""
"Создание базовой резервной копии, необходимой для запуска резервного "
"сервера, описано в <xref remap=\"6\" linkend=\"backup-base-backup\"/>."

#: high-availability.xml:657(title)
msgid "Setting Up a Standby Server"
msgstr "Настройка резервного сервера"

#: high-availability.xml:659(para)
msgid ""
"To set up the standby server, restore the base backup taken from primary "
"server (see <xref linkend=\"backup-pitr-recovery\"/>). Create a recovery "
"command file <filename>recovery.conf</filename> in the standby's cluster "
"data directory, and turn on <varname>standby_mode</varname>. Set "
"<varname>restore_command</varname> to a simple command to copy files from "
"the WAL archive. If you plan to have multiple standby servers for high "
"availability purposes, set <varname>recovery_target_timeline</varname> to "
"<literal>latest</literal>, to make the standby server follow the timeline "
"change that occurs at failover to another standby."
msgstr ""
"Для запуска резервного сервера нужно восстановить резервную копию, снятую с "
"ведущего (см. <xref remap=\"4\" linkend=\"backup-pitr-recovery\"/>). Затем "
"нужно создать файл команд восстановления <filename>recovery.conf</filename> "
"в каталоге данных кластера резервного сервера и включить режим "
"<varname>standby_mode</varname>. Задайте в <varname>restore_command</"
"varname> обычную команду копирования файлов из архива WAL. Если планируется "
"несколько резервных серверов в целях отказоустойчивости, установите для "
"<varname>recovery_target_timeline</varname> значение <literal>latest</"
"literal>, чтобы резервный сервер переходил на новую линию времени, "
"образуемую при отработке отказа и переключении на другой сервер."

#: high-availability.xml:672(para)
msgid ""
"Do not use pg_standby or similar tools with the built-in standby mode "
"described here. <varname>restore_command</varname> should return immediately "
"if the file does not exist; the server will retry the command again if "
"necessary. See <xref linkend=\"log-shipping-alternative\"/> for using tools "
"like pg_standby."
msgstr ""
"Не используйте pg_standby или подобные средства со встроенным режимом "
"резервного сервера, описанным здесь. <varname>restore_command</varname> "
"должна немедленно прекратиться при отсутствии файла; сервер повторит команду "
"вновь при необходимости. Использование средств, подобных pg_standby, описано "
"в <xref remap=\"6\" linkend=\"log-shipping-alternative\"/>."

#: high-availability.xml:681(para)
msgid ""
"If you want to use streaming replication, fill in <varname>primary_conninfo</"
"varname> with a libpq connection string, including the host name (or IP "
"address) and any additional details needed to connect to the primary server. "
"If the primary needs a password for authentication, the password needs to be "
"specified in <varname>primary_conninfo</varname> as well."
msgstr ""
"При необходимости потоковой репликации заполните <varname>primary_conninfo</"
"varname> параметрами строки соединения для libpq, включая имя (или IP-адрес) "
"сервера и все остальные необходимые данные для соединения с ведущим "
"сервером. Если ведущий требует пароль для аутентификации, пароль может быть "
"так же передан в <varname>primary_conninfo</varname>."

#: high-availability.xml:690(para)
msgid ""
"If you're setting up the standby server for high availability purposes, set "
"up WAL archiving, connections and authentication like the primary server, "
"because the standby server will work as a primary server after failover."
msgstr ""
"Если резервный сервер настраивается в целях отказоустойчивости, на нём "
"следует настроить архивацию WAL, соединения и аутентификацию, как на ведущем "
"сервере, потому что резервный сервер станет ведущим после отработки отказа."

#: high-availability.xml:697(para)
msgid ""
"If you're using a WAL archive, its size can be minimized using the <xref "
"linkend=\"archive-cleanup-command\"/> parameter to remove files that are no "
"longer required by the standby server. The <application>pg_archivecleanup</"
"application> utility is designed specifically to be used with "
"<varname>archive_cleanup_command</varname> in typical single-standby "
"configurations, see <xref linkend=\"pgarchivecleanup\"/>. Note however, that "
"if you're using the archive for backup purposes, you need to retain files "
"needed to recover from at least the latest base backup, even if they're no "
"longer needed by the standby."
msgstr ""
"При использовании архива WAL его размер может быть уменьшен с помощью "
"команды в параметре <xref linkend=\"archive-cleanup-command\"/>, которая "
"удаляет файлы уже не нужные для дальнейшей работы резервного сервера. "
"Утилита <application>pg_archivecleanup</application> разработана специально "
"для использования в <varname>archive_cleanup_command</varname> при типичной "
"конфигурации с одним резервным сервером (см. <xref remap=\"4\" linkend="
"\"pgarchivecleanup\"/>). Следует отметить, что если архив используется в "
"целях резервирования, следует сохранять все файлы необходимые для "
"восстановления как минимум с последней базовой резервной копии, даже если "
"они не нужны для резервного сервера."

#: high-availability.xml:711(programlisting)
#, no-wrap
msgid ""
"standby_mode = 'on'\n"
"primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'\n"
"restore_command = 'cp /path/to/archive/%f %p'\n"
"archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'"
msgstr ""
"standby_mode = 'on'\n"
"primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'\n"
"restore_command = 'cp /path/to/archive/%f %p'\n"
"archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'"

#: high-availability.xml:709(para)
msgid ""
"A simple example of a <filename>recovery.conf</filename> is: <placeholder-1/>"
msgstr "Простой пример <filename>recovery.conf</filename>: <placeholder-1/>"

#: high-availability.xml:719(para)
msgid ""
"You can have any number of standby servers, but if you use streaming "
"replication, make sure you set <varname>max_wal_senders</varname> high "
"enough in the primary to allow them to be connected simultaneously."
msgstr ""
"Можно поддерживать любое количество резервных серверов, но при применении "
"потоковой репликации необходимо убедиться, что значение "
"<varname>max_wal_senders</varname> на ведущем достаточно большое, чтобы все "
"они могли подключиться одновременно."

#: high-availability.xml:728(title)
msgid "Streaming Replication"
msgstr "Потоковая репликация"

#: high-availability.xml:730(indexterm)
msgid "<primary>Streaming Replication</primary>"
msgstr "<primary>Потоковая репликация</primary>"

#: high-availability.xml:734(para)
msgid ""
"Streaming replication allows a standby server to stay more up-to-date than "
"is possible with file-based log shipping. The standby connects to the "
"primary, which streams WAL records to the standby as they're generated, "
"without waiting for the WAL file to be filled."
msgstr ""
"При потоковой репликации резервный сервер может работать с меньшей "
"задержкой, чем при трансляции файлов. Резервный сервер подключается к "
"ведущему, который передаёт поток записей WAL резервному в момент их "
"добавления, не дожидаясь окончания заполнения файла WAL."

#: high-availability.xml:741(para)
msgid ""
"Streaming replication is asynchronous by default (see <xref linkend="
"\"synchronous-replication\"/>), in which case there is a small delay between "
"committing a transaction in the primary and the changes becoming visible in "
"the standby. This delay is however much smaller than with file-based log "
"shipping, typically under one second assuming the standby is powerful enough "
"to keep up with the load. With streaming replication, "
"<varname>archive_timeout</varname> is not required to reduce the data loss "
"window."
msgstr ""
"Потоковая репликация асинхронна по умолчанию (см. <xref remap=\"4\" linkend="
"\"synchronous-replication\"/>), то есть имеется небольшая задержка между "
"подтверждением транзакции на ведущем сервере и появлением этих изменений на "
"резервном. Тем не менее, эта задержка гораздо меньше, чем при трансляции "
"файлов журналов, обычно в пределах одной секунды, если резервный сервер "
"достаточно мощный и справляется с нагрузкой. При потоковой репликации "
"настраивать <varname>archive_timeout</varname> для уменьшения окна "
"потенциальной потери данных не требуется."

#: high-availability.xml:752(para)
msgid ""
"If you use streaming replication without file-based continuous archiving, "
"the server might recycle old WAL segments before the standby has received "
"them. If this occurs, the standby will need to be reinitialized from a new "
"base backup. You can avoid this by setting <varname>wal_keep_segments</"
"varname> to a value large enough to ensure that WAL segments are not "
"recycled too early, or by configuring a replication slot for the standby. If "
"you set up a WAL archive that's accessible from the standby, these solutions "
"are not required, since the standby can always use the archive to catch up "
"provided it retains enough segments."
msgstr ""
"При потоковой репликации без постоянной архивации на уровне файлов, сервер "
"может избавиться от старых сегментов WAL до того, как резервный получит их. "
"В этом случае резервный сервер потребует повторной инициализации из новой "
"базовой резервной копии. Этого можно избежать, установив для "
"<varname>wal_keep_segments</varname> достаточно большое значение, при "
"котором сегменты WAL будут защищены от ранней очистки, либо настроив слот "
"репликации для резервного сервера. Если с резервного сервера доступен архив "
"WAL, этого не требуется, так как резервный может всегда обратиться к архиву "
"для восполнения пропущенных сегментов."

#: high-availability.xml:764(para)
msgid ""
"To use streaming replication, set up a file-based log-shipping standby "
"server as described in <xref linkend=\"warm-standby\"/>. The step that turns "
"a file-based log-shipping standby into streaming replication standby is "
"setting <varname>primary_conninfo</varname> setting in the "
"<filename>recovery.conf</filename> file to point to the primary server. Set "
"<xref linkend=\"guc-listen-addresses\"/> and authentication options (see "
"<filename>pg_hba.conf</filename>) on the primary so that the standby server "
"can connect to the <literal>replication</literal> pseudo-database on the "
"primary server (see <xref linkend=\"streaming-replication-authentication\"/"
">)."
msgstr ""
"Чтобы включить потоковую репликацию, сначала настройте резервный сервер на "
"приём трансляции журналов, как описано в <xref remap=\"6\" linkend=\"warm-"
"standby\"/>. Затем сделайте следующий шаг — переключите резервный сервер в "
"режим репликации, установив в <varname>primary_conninfo</varname> в файле "
"<filename>recovery.conf</filename> строку подключения, указывающую на "
"ведущий. Настройте <xref linkend=\"guc-listen-addresses\"/> и параметры "
"аутентификации (см. <filename>pg_hba.conf</filename>) на ведущем сервере "
"таким образом, чтобы резервный смог подключиться к псевдобазе "
"<literal>replication</literal> на ведущем (см. <xref remap=\"4\" linkend="
"\"streaming-replication-authentication\"/>)."

#: high-availability.xml:776(para)
msgid ""
"On systems that support the keepalive socket option, setting <xref linkend="
"\"guc-tcp-keepalives-idle\"/>, <xref linkend=\"guc-tcp-keepalives-interval\"/"
"> and <xref linkend=\"guc-tcp-keepalives-count\"/> helps the primary "
"promptly notice a broken connection."
msgstr ""
"В системах, поддерживающих параметр сокета keepalive, подходящие значения "
"<xref linkend=\"guc-tcp-keepalives-idle\"/>, <xref linkend=\"guc-tcp-"
"keepalives-interval\"/> и <xref linkend=\"guc-tcp-keepalives-count\"/> "
"помогут ведущему вовремя заметить разрыв соединения."

#: high-availability.xml:784(para)
msgid ""
"Set the maximum number of concurrent connections from the standby servers "
"(see <xref linkend=\"guc-max-wal-senders\"/> for details)."
msgstr ""
"Установите максимальное количество одновременных соединений с резервных "
"серверов (см. описание <xref linkend=\"guc-max-wal-senders\"/>."

#: high-availability.xml:789(para)
msgid ""
"When the standby is started and <varname>primary_conninfo</varname> is set "
"correctly, the standby will connect to the primary after replaying all WAL "
"files available in the archive. If the connection is established "
"successfully, you will see a walreceiver process in the standby, and a "
"corresponding walsender process in the primary."
msgstr ""
"При запуске резервного сервера с правильно установленным "
"<varname>primary_conninfo</varname> резервный подключится к ведущему после "
"воспроизведения всех файлов WAL, доступных из архива. При успешном "
"установлении соединения можно увидеть процесс walreceiver на резервном "
"сервере и соответствующий процесс walsender на ведущем."

#: high-availability.xml:798(title)
msgid "Authentication"
msgstr "Аутентификация"

#: high-availability.xml:799(para)
msgid ""
"It is very important that the access privileges for replication be set up so "
"that only trusted users can read the WAL stream, because it is easy to "
"extract privileged information from it. Standby servers must authenticate to "
"the primary as a superuser or an account that has the <literal>REPLICATION</"
"literal> privilege. It is recommended to create a dedicated user account "
"with <literal>REPLICATION</literal> and <literal>LOGIN</literal> privileges "
"for replication. While <literal>REPLICATION</literal> privilege gives very "
"high permissions, it does not allow the user to modify any data on the "
"primary system, which the <literal>SUPERUSER</literal> privilege does."
msgstr ""
"Право использования репликации очень важно ограничить так, чтобы только "
"доверенные пользователи могли читать поток WAL, так как из него можно "
"извлечь конфиденциальную информацию. Резервный сервер должен "
"аутентифицироваться на ведущем от имени суперпользователя или пользователя с "
"правом <literal>REPLICATION</literal>. Настоятельно рекомендуется создавать "
"выделенного пользователя с правами <literal>REPLICATION</literal> и "
"<literal>LOGIN</literal> специально для репликации. Хотя право "
"<literal>REPLICATION</literal> даёт очень широкие полномочия, оно не "
"позволяет модифицировать данные в ведущей системе, тогда как с правом "
"<literal>SUPERUSER</literal> это можно делать."

#: high-availability.xml:819(programlisting)
#, no-wrap
msgid ""
"# Allow the user \"foo\" from host 192.168.1.100 to connect to the primary\n"
"# as a replication standby if the user's password is correctly supplied.\n"
"#\n"
"# TYPE  DATABASE        USER            ADDRESS                 METHOD\n"
"host    replication     foo             192.168.1.100/32        md5"
msgstr ""
"# Разрешить пользователю \"foo\" с компьютера 192.168.1.100 подключаться к этому\n"
"# серверу в качестве партнёра репликации, если был передан правильный пароль.\n"
"#\n"
"# TYPE  DATABASE        USER            ADDRESS                 METHOD\n"
"host    replication     foo             192.168.1.100/32        md5"

#: high-availability.xml:811(para)
msgid ""
"Client authentication for replication is controlled by a <filename>pg_hba."
"conf</filename> record specifying <literal>replication</literal> in the "
"<replaceable>database</replaceable> field. For example, if the standby is "
"running on host IP <literal>192.168.1.100</literal> and the account name for "
"replication is <literal>foo</literal>, the administrator can add the "
"following line to the <filename>pg_hba.conf</filename> file on the primary: "
"<placeholder-1/>"
msgstr ""
"Список аутентификации клиентов для репликации содержится в <filename>pg_hba."
"conf</filename> в записях с установленным значением <literal>replication</"
"literal> в поле <replaceable>database</replaceable>. Например, если "
"резервный сервер запущен на компьютере с IP-адресом <literal>192.168.1.100</"
"literal> и учётная запись для репликации <literal>foo</literal>, "
"администратор может добавить следующую строку в файл <filename>pg_hba.conf</"
"filename> ведущего: <placeholder-1/>"

#: high-availability.xml:839(programlisting)
#, no-wrap
msgid ""
"# The standby connects to the primary that is running on host 192.168.1.50\n"
"# and port 5432 as the user \"foo\" whose password is \"foopass\".\n"
"primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'"
msgstr ""
"# Резервный сервер подключается к ведущему, работающему на компьютере 192.168.1.50\n"
"# (порт 5432), от имени пользователя \"foo\" с паролем \"foopass\".\n"
"primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'"

#: high-availability.xml:827(para)
msgid ""
"The host name and port number of the primary, connection user name, and "
"password are specified in the <filename>recovery.conf</filename> file. The "
"password can also be set in the <filename>~/.pgpass</filename> file on the "
"standby (specify <literal>replication</literal> in the "
"<replaceable>database</replaceable> field). For example, if the primary is "
"running on host IP <literal>192.168.1.50</literal>, port <literal>5432</"
"literal>, the account name for replication is <literal>foo</literal>, and "
"the password is <literal>foopass</literal>, the administrator can add the "
"following line to the <filename>recovery.conf</filename> file on the "
"standby: <placeholder-1/>"
msgstr ""
"Имя компьютера и номер порта для ведущего, имя пользователя для соединения и "
"пароль указываются в файле <filename>recovery.conf</filename>. Пароль так же "
"может быть задан через файл <filename>~/.pgpass</filename> на резервном "
"сервере (указанном в определении с <literal>replication</literal> в поле "
"<replaceable>database</replaceable>). Например, если ведущий принимает "
"подключения по IP-адресу <literal>192.168.1.50</literal>, в порту "
"<literal>5432</literal>, пользователя для репликации <literal>foo</literal> "
"с паролем <literal>foopass</literal>, то администратор может добавить "
"следующую строку в файл <filename>recovery.conf</filename> на резервном "
"сервере: <placeholder-1/>"

#: high-availability.xml:848(title)
msgid "Monitoring"
msgstr "Наблюдение"

#: high-availability.xml:849(para)
msgid ""
"An important health indicator of streaming replication is the amount of WAL "
"records generated in the primary, but not yet applied in the standby. You "
"can calculate this lag by comparing the current WAL write location on the "
"primary with the last WAL location received by the standby. They can be "
"retrieved using <function>pg_current_xlog_location</function> on the primary "
"and the <function>pg_last_xlog_receive_location</function> on the standby, "
"respectively (see <xref linkend=\"functions-admin-backup-table\"/> and <xref "
"linkend=\"functions-recovery-info-table\"/> for details). The last WAL "
"receive location in the standby is also displayed in the process status of "
"the WAL receiver process, displayed using the <command>ps</command> command "
"(see <xref linkend=\"monitoring-ps\"/> for details)."
msgstr ""
"Важным индикатором стабильности работы потоковой репликации является "
"количество записей WAL, созданных на ведущем, но ещё не применённых на "
"резервном сервере. Можно подсчитать задержку, сравнив текущий WAL, "
"записанный на ведущем, с последним WAL, полученным на резервном. Эти "
"показатели могут быть получены с помощью функций "
"<function>pg_current_xlog_location</function> на ведущем и "
"<function>pg_last_xlog_receive_location</function> на резервном "
"соответственно (более подробно см. <xref remap=\"4\" linkend=\"functions-"
"admin-backup-table\"/> и <xref remap=\"4\" linkend=\"functions-recovery-info-"
"table\"/>). Местоположение последнего полученного WAL на резервном сервере "
"так же показывается в статусе процесса получателя WAL, отображаемого по "
"команде <command>ps</command> (более подробно см. <xref remap=\"4\" linkend="
"\"monitoring-ps\"/>)."

#: high-availability.xml:863(para)
msgid ""
"You can retrieve a list of WAL sender processes via the <link linkend="
"\"monitoring-stats-views-table\"><literal>pg_stat_replication</literal></"
"link> view. Large differences between <function>pg_current_xlog_location</"
"function> and <literal>sent_location</literal> field might indicate that the "
"master server is under heavy load, while differences between "
"<literal>sent_location</literal> and "
"<function>pg_last_xlog_receive_location</function> on the standby might "
"indicate network delay, or that the standby is under heavy load."
msgstr ""
"Можно запросить список процессов отправителей WAL через представление <link "
"linkend=\"monitoring-stats-views-table\"><literal>pg_stat_replication</"
"literal></link>. Большая разница между <function>pg_current_xlog_location</"
"function> и полем <literal>sent_location</literal> указывает на то, что "
"главный сервер работает с большой нагрузкой, в то время как разница между "
"<literal>sent_location</literal> и <function>pg_last_xlog_receive_location</"
"function> на резервном указывает на задержки в сети или на то, что с большой "
"нагрузкой работает резервный."

#: high-availability.xml:877(title)
msgid "Replication Slots"
msgstr "Слоты репликации"

#: high-availability.xml:878(indexterm)
msgid ""
"<primary>replication slot</primary> <secondary>streaming replication</"
"secondary>"
msgstr ""
"<primary>Слоты репликации</primary> <secondary>Потоковая репликация</"
"secondary>"

#: high-availability.xml:882(para)
msgid ""
"Replication slots provide an automated way to ensure that the master does "
"not remove WAL segments until they have been received by all standbys, and "
"that the master does not remove rows which could cause a <link linkend=\"hot-"
"standby-conflict\">recovery conflict</link> even when the standby is "
"disconnected."
msgstr ""
"Слоты репликации автоматически обеспечивают механизм сохранения сегментов "
"WAL, пока они не будут получены всеми резервными и главный сервер не будет "
"удалять строки, находящиеся в статусе <link linkend=\"hot-standby-conflict"
"\">recovery conflict</link> даже при отключении резервного."

#: high-availability.xml:889(para)
msgid ""
"In lieu of using replication slots, it is possible to prevent the removal of "
"old WAL segments using <xref linkend=\"guc-wal-keep-segments\"/>, or by "
"storing the segments in an archive using <xref linkend=\"guc-archive-command"
"\"/>. However, these methods often result in retaining more WAL segments "
"than required, whereas replication slots retain only the number of segments "
"known to be needed. An advantage of these methods is that they bound the "
"space requirement for <literal>pg_xlog</literal>; there is currently no way "
"to do this using replication slots."
msgstr ""
"Вместо использования слотов репликации для предотвращения удаления старых "
"сегментов WAL можно применять <xref linkend=\"guc-wal-keep-segments\"/>, или "
"сохранять сегменты в архиве с помощью команды <xref linkend=\"guc-archive-"
"command\"/>. Тем не менее, эти методы часто приводят к тому, что хранится "
"больше сегментов WAL, чем необходимо, в то время как слоты репликации "
"оставляют только то количество сегментов, которое необходимо. Преимущество "
"этих методов состоит в том, что они чётко задают объёмы места, необходимого "
"для <literal>pg_xlog</literal>; в то время как текущая реализация "
"репликационных слотов не представляет такой возможности."

#: high-availability.xml:900(para)
msgid ""
"Similarly, <xref linkend=\"guc-hot-standby-feedback\"/> and <xref linkend="
"\"guc-vacuum-defer-cleanup-age\"/> provide protection against relevant rows "
"being removed by vacuum, but the former provides no protection during any "
"time period when the standby is not connected, and the latter often needs to "
"be set to a high value to provide adequate protection. Replication slots "
"overcome these disadvantages."
msgstr ""
"Подобным образом, параметры <xref linkend=\"guc-hot-standby-feedback\"/> и "
"<xref linkend=\"guc-vacuum-defer-cleanup-age\"/> позволяют защитить "
"востребованные строки от удаления при очистке, но первый параметр не "
"защищает в тот промежуток времени, когда резервный сервер не подключён, а "
"для последнего часто нужно задавать большое значение, чтобы обеспечить "
"должную защиту. Слоты репликации решают эти проблемы."

#: high-availability.xml:909(title)
msgid "Querying and manipulating replication slots"
msgstr "Запросы и действия слотов репликации"

#: high-availability.xml:910(para)
msgid ""
"Each replication slot has a name, which can contain lower-case letters, "
"numbers, and the underscore character."
msgstr ""
"Каждый слот репликации обладает именем, состоящим из строчных букв, цифр и "
"символов подчёркивания."

#: high-availability.xml:914(para)
msgid ""
"Existing replication slots and their state can be seen in the <link linkend="
"\"view-pg-replication-slots\"><structname>pg_replication_slots</structname></"
"link> view."
msgstr ""
"Имеющиеся слоты репликации и их статус можно просмотреть в представлении "
"<link linkend=\"view-pg-replication-slots"
"\"><structname>pg_replication_slots</structname></link>."

#: high-availability.xml:919(para)
msgid ""
"Slots can be created and dropped either via the streaming replication "
"protocol (see <xref linkend=\"protocol-replication\"/>) or via SQL functions "
"(see <xref linkend=\"functions-replication\"/>)."
msgstr ""
"Слоты могут быть созданы и удалены как с помощью протокола потоковой "
"репликации (см. <xref remap=\"4\" linkend=\"protocol-replication\"/>), так и "
"посредством функций SQL (см. <xref remap=\"4\" linkend=\"functions-"
"replication\"/>)."

#: high-availability.xml:926(title)
msgid "Configuration Example"
msgstr "Пример конфигурации"

#: high-availability.xml:929(programlisting)
#, no-wrap
msgid ""
"postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');\n"
"  slot_name  | xlog_position\n"
"-------------+---------------\n"
" node_a_slot |\n"
"\n"
"postgres=# SELECT * FROM pg_replication_slots;\n"
"  slot_name  | slot_type | datoid | database | active | xmin | restart_lsn | confirmed_flush_lsn\n"
"-------------+-----------+--------+----------+--------+------+-------------+---------------------\n"
" node_a_slot | physical  |        |          | f      |      |             |\n"
"(1 row)"
msgstr ""
"postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');\n"
"  slot_name  | xlog_position\n"
"-------------+---------------\n"
" node_a_slot |\n"
"\n"
"postgres=# SELECT * FROM pg_replication_slots;\n"
"  slot_name  | slot_type | datoid | database | active | xmin | restart_lsn | confirmed_flush_lsn\n"
"-------------+-----------+--------+----------+--------+------+-------------+---------------------\n"
" node_a_slot | physical  |        |          | f      |      |             |\n"
"(1 row)"

#: high-availability.xml:944(programlisting)
#, no-wrap
msgid ""
"standby_mode = 'on'\n"
"primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'\n"
"primary_slot_name = 'node_a_slot'"
msgstr ""
"standby_mode = 'on'\n"
"primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'\n"
"primary_slot_name = 'node_a_slot'"

#: high-availability.xml:927(para)
msgid ""
"You can create a replication slot like this: <placeholder-1/> To configure "
"the standby to use this slot, <varname>primary_slot_name</varname> should be "
"configured in the standby's <filename>recovery.conf</filename>. Here is a "
"simple example: <placeholder-2/>"
msgstr ""
"Для создания слота репликации выполните: <placeholder-1/> Для настройки "
"резервного сервера на использование этого слота <varname>primary_slot_name</"
"varname> должно быть настроено в конфигурации <filename>recovery.conf</"
"filename> резервного. Вот простейший пример: <placeholder-2/>"

#: high-availability.xml:954(title)
msgid "Cascading Replication"
msgstr "Каскадная репликация"

#: high-availability.xml:956(indexterm)
msgid "<primary>Cascading Replication</primary>"
msgstr "<primary>Каскадная репликация</primary>"

#: high-availability.xml:960(para)
msgid ""
"The cascading replication feature allows a standby server to accept "
"replication connections and stream WAL records to other standbys, acting as "
"a relay. This can be used to reduce the number of direct connections to the "
"master and also to minimize inter-site bandwidth overheads."
msgstr ""
"Свойство каскадной репликации позволяет резервному серверу принимать "
"соединения репликации и потоки WAL от других резервных, выступающих "
"посредниками. Это может быть полезно для уменьшения числа непосредственных "
"подключений к главному серверу, а также для уменьшения накладных расходов "
"при передаче данных в интрасети."

#: high-availability.xml:967(para)
msgid ""
"A standby acting as both a receiver and a sender is known as a cascading "
"standby. Standbys that are more directly connected to the master are known "
"as upstream servers, while those standby servers further away are downstream "
"servers. Cascading replication does not place limits on the number or "
"arrangement of downstream servers, though each standby connects to only one "
"upstream server which eventually links to a single master/primary server."
msgstr ""
"Резервный сервер, выступающий как получатель и отправитель, называется "
"каскадным резервным сервером. Резервные серверы, стоящие ближе к главному, "
"называются серверами верхнего уровня, а более отдалённые — серверами нижнего "
"уровня. Каскадная репликация не накладывает ограничений на количество или "
"организацию последующих уровней, а каждый резервный соединяется только с "
"одним сервером вышестоящего уровня, который в конце концов соединяется с "
"единственным главным/ведущим сервером."

#: high-availability.xml:977(para)
msgid ""
"A cascading standby sends not only WAL records received from the master but "
"also those restored from the archive. So even if the replication connection "
"in some upstream connection is terminated, streaming replication continues "
"downstream for as long as new WAL records are available."
msgstr ""
"Резервный сервер каскадной репликации не только получает записи WAL от "
"главного, но так же восстанавливает их из архива. Таким образом, даже если "
"соединение с сервером более высокого уровня разорвётся, потоковая репликация "
"для последующих уровней будет продолжаться до исчерпания доступных записей "
"WAL."

#: high-availability.xml:984(para)
msgid ""
"Cascading replication is currently asynchronous. Synchronous replication "
"(see <xref linkend=\"synchronous-replication\"/>) settings have no effect on "
"cascading replication at present."
msgstr ""
"Каскадная репликация в текущей реализации асинхронна. Параметры синхронной "
"репликации (см. <xref remap=\"4\" linkend=\"synchronous-replication\"/>) в "
"настоящее время не оказывают влияние на каскадную репликацию."

#: high-availability.xml:990(para)
msgid ""
"Hot Standby feedback propagates upstream, whatever the cascaded arrangement."
msgstr ""
"Распространение обратной связи горячего резерва работает от нижестоящего "
"уровня к вышестоящему уровню вне зависимости от способа организации связи."

#: high-availability.xml:994(para)
msgid ""
"If an upstream standby server is promoted to become new master, downstream "
"servers will continue to stream from the new master if "
"<varname>recovery_target_timeline</varname> is set to <literal>'latest'</"
"literal>."
msgstr ""
"Если резервный сервер вышестоящего уровня будет преобразован в новый "
"главный, серверы нижестоящего уровня продолжат получать поток с нового "
"главного при условии, что <varname>recovery_target_timeline</varname> "
"установлен в значение <literal>'latest'</literal>."

#: high-availability.xml:1000(para)
msgid ""
"To use cascading replication, set up the cascading standby so that it can "
"accept replication connections (that is, set <xref linkend=\"guc-max-wal-"
"senders\"/> and <xref linkend=\"guc-hot-standby\"/>, and configure <link "
"linkend=\"auth-pg-hba-conf\">host-based authentication</link>). You will "
"also need to set <varname>primary_conninfo</varname> in the downstream "
"standby to point to the cascading standby."
msgstr ""
"Для использования каскадной репликации необходимо настроить резервный "
"каскадный сервер на прием соединений репликации (то есть установить <xref "
"linkend=\"guc-max-wal-senders\"/> и <xref linkend=\"guc-hot-standby\"/>, "
"настроить <link linkend=\"auth-pg-hba-conf\">host-based authentication</"
"link>). Так же может быть необходимо настроить на нижестоящем резервном "
"значение <varname>primary_conninfo</varname> на каскадный резервный сервер."

#: high-availability.xml:1012(title)
msgid "Synchronous Replication"
msgstr "Синхронная репликация"

#: high-availability.xml:1014(indexterm)
msgid "<primary>Synchronous Replication</primary>"
msgstr "<primary>Синхронная репликация</primary>"

#: high-availability.xml:1018(para)
msgid ""
"<productname>PostgreSQL</productname> streaming replication is asynchronous "
"by default. If the primary server crashes then some transactions that were "
"committed may not have been replicated to the standby server, causing data "
"loss. The amount of data loss is proportional to the replication delay at "
"the time of failover."
msgstr ""
"По умолчанию в <productname>PostgreSQL</productname> потоковая репликация "
"асинхронна. Если ведущий сервер выходит из строя, некоторые транзакции, "
"которые были подтверждены, но не переданы на резервный, могут быть потеряны. "
"Объём потерянных данных пропорционален задержке репликации на момент "
"отработки отказа."

#: high-availability.xml:1027(para)
msgid ""
"Synchronous replication offers the ability to confirm that all changes made "
"by a transaction have been transferred to one or more synchronous standby "
"servers. This extends that standard level of durability offered by a "
"transaction commit. This level of protection is referred to as 2-safe "
"replication in computer science theory, and group-1-safe (group-safe and 1-"
"safe) when <varname>synchronous_commit</varname> is set to "
"<literal>remote_write</literal>."
msgstr ""
"Синхронная репликация предоставляет возможность гарантировать, что все "
"изменения, внесённые в транзакции, были переданы одному или нескольким "
"синхронным резервным серверам. Это увеличивает стандартный уровень "
"надёжности, гарантируемый при фиксации транзакции. Этот уровень защиты "
"соответствует второму уровню безопасности репликации из теории "
"вычислительной техники, или групповой безопасности первого уровня "
"(безопасности групповой и уровня 1), когда выбран режим "
"<varname>synchronous_commit</varname> <literal>remote_write</literal>."

#: high-availability.xml:1037(para)
msgid ""
"When requesting synchronous replication, each commit of a write transaction "
"will wait until confirmation is received that the commit has been written to "
"the transaction log on disk of both the primary and standby server. The only "
"possibility that data can be lost is if both the primary and the standby "
"suffer crashes at the same time. This can provide a much higher level of "
"durability, though only if the sysadmin is cautious about the placement and "
"management of the two servers. Waiting for confirmation increases the user's "
"confidence that the changes will not be lost in the event of server crashes "
"but it also necessarily increases the response time for the requesting "
"transaction. The minimum wait time is the round-trip time between primary to "
"standby."
msgstr ""
"При синхронной репликации каждая фиксация пишущей транзакции ожидает "
"подтверждения того, что транзакция записана в журнал транзакций на диске на "
"обоих серверах: ведущем и резервном. При таком варианте потеря данных может "
"произойти только в случае одновременного выхода из строя ведущего и "
"резервного серверов. Это обеспечивает более высокий уровень надёжности, при "
"условии продуманного подхода системного администратора к вопросам размещения "
"и управления этими серверами. Ожидание подтверждения увеличивает уверенность "
"в том, что данные не будут потеряны во время сбоя сервера, но при этом "
"увеличивает время отклика для обработки транзакции. Минимальное время "
"ожидания равно времени передачи данных от ведущего к резервному и обратно."

#: high-availability.xml:1051(para)
msgid ""
"Read only transactions and transaction rollbacks need not wait for replies "
"from standby servers. Subtransaction commits do not wait for responses from "
"standby servers, only top-level commits. Long running actions such as data "
"loading or index building do not wait until the very final commit message. "
"All two-phase commit actions require commit waits, including both prepare "
"and commit."
msgstr ""
"Транзакции только для чтения и откат транзакции не требуют ожидания для "
"ответа с резервного сервера. Промежуточные подтверждения не ожидают ответа "
"от резервного сервера, только подтверждение верхнего уровня. Долгие операции "
"вида загрузки данных или построения индекса не ожидают финального "
"подтверждения. Но все двухфазные подтверждения требуют ожидания, включая "
"подготовку и непосредственно подтверждение."

#: high-availability.xml:1061(title)
msgid "Basic Configuration"
msgstr "Базовая настройка"

#: high-availability.xml:1063(para)
msgid ""
"Once streaming replication has been configured, configuring synchronous "
"replication requires only one additional configuration step: <xref linkend="
"\"guc-synchronous-standby-names\"/> must be set to a non-empty value. "
"<varname>synchronous_commit</varname> must also be set to <literal>on</"
"literal>, but since this is the default value, typically no change is "
"required. (See <xref linkend=\"runtime-config-wal-settings\"/> and <xref "
"linkend=\"runtime-config-replication-master\"/>.) This configuration will "
"cause each commit to wait for confirmation that the standby has written the "
"commit record to durable storage. <varname>synchronous_commit</varname> can "
"be set by individual users, so it can be configured in the configuration "
"file, for particular users or databases, or dynamically by applications, in "
"order to control the durability guarantee on a per-transaction basis."
msgstr ""
"При настроенной потоковой репликации установка синхронной репликации требует "
"только дополнительной настройки: необходимо выставить <xref linkend=\"guc-"
"synchronous-standby-names\"/> в непустое значение. Так же необходимо "
"установить <varname>synchronous_commit</varname> в значение <literal>on</"
"literal>, но так как это значение по умолчанию, обычно действий не "
"требуется. (См. <xref remap=\"4\" linkend=\"runtime-config-wal-settings\"/> "
"и <xref remap=\"4\" linkend=\"runtime-config-replication-master\"/>.) В "
"такой конфигурации каждая транзакция будет ожидать подтверждение того, что "
"на резервном сервере произошла запись транзакции в надёжное хранилище. "
"Значение <varname>synchronous_commit</varname> может быть выставлено для "
"отдельного пользователя, может быть прописано в файле конфигурации, для "
"конкретного пользователя или БД или динамически изменено приложением для "
"управления степенью надёжности на уровне отдельных транзакций."

#: high-availability.xml:1080(para)
msgid ""
"After a commit record has been written to disk on the primary, the WAL "
"record is then sent to the standby. The standby sends reply messages each "
"time a new batch of WAL data is written to disk, unless "
"<varname>wal_receiver_status_interval</varname> is set to zero on the "
"standby. In the case that <varname>synchronous_commit</varname> is set to "
"<literal>remote_apply</literal>, the standby sends reply messages when the "
"commit record is replayed, making the transaction visible. If the standby is "
"chosen as a synchronous standby, from a priority list of "
"<varname>synchronous_standby_names</varname> on the primary, the reply "
"messages from that standby will be considered along with those from other "
"synchronous standbys to decide when to release transactions waiting for "
"confirmation that the commit record has been received. These parameters "
"allow the administrator to specify which standby servers should be "
"synchronous standbys. Note that the configuration of synchronous replication "
"is mainly on the master. Named standbys must be directly connected to the "
"master; the master knows nothing about downstream standby servers using "
"cascaded replication."
msgstr ""
"После сохранения записи о фиксации транзакции на диске ведущего сервера эта "
"запись WAL передаётся резервному серверу. Резервный сервер отвечает "
"подтверждающим сообщением после сохранения каждого нового блока данных WAL "
"на диске, если только <varname>wal_receiver_status_interval</varname> на нём "
"не равен нулю. В случае, когда выбран режим <varname>synchronous_commit</"
"varname> <literal>remote_apply</literal>, резервный сервер передаёт "
"подтверждение после воспроизведения записи фиксации, когда транзакция "
"становится видимой. Если резервный сервер выбран на роль синхронного "
"резервного, из упорядоченного списка <varname>synchronous_standby_names</"
"varname> на ведущем, подтверждающие сообщения с этого сервера, в "
"совокупности с сообщениями с других синхронных серверов, будут сигналом к "
"завершению ожидания при фиксировании транзакций, требующих подтверждения "
"сохранения записи фиксации. Эти параметры позволяют администратору "
"определить, какие резервные серверы будут синхронными резервными. Заметьте, "
"что настройка синхронной репликации в основном осуществляется на главном "
"сервере. Перечисленные в списке резервных серверы должны быть подключены к "
"нему непосредственно; он ничего не знает о резервных серверах, подключённых "
"каскадно, через промежуточные серверы."

#: high-availability.xml:1100(para)
msgid ""
"Setting <varname>synchronous_commit</varname> to <literal>remote_write</"
"literal> will cause each commit to wait for confirmation that the standby "
"has received the commit record and written it out to its own operating "
"system, but not for the data to be flushed to disk on the standby. This "
"setting provides a weaker guarantee of durability than <literal>on</literal> "
"does: the standby could lose the data in the event of an operating system "
"crash, though not a <productname>PostgreSQL</productname> crash. However, "
"it's a useful setting in practice because it can decrease the response time "
"for the transaction. Data loss could only occur if both the primary and the "
"standby crash and the database of the primary gets corrupted at the same "
"time."
msgstr ""
"Если <varname>synchronous_commit</varname> имеет значение "
"<literal>remote_write</literal>, то в случае подтверждения транзакции ответ "
"от резервного сервера об успешном подтверждении будет передан, когда данные "
"запишутся в операционной системе, но не когда данные будет реально сохранены "
"на диске. При таком значении уровень надёжности снижается по сравнению со "
"значением <literal>on</literal>. Резервный сервер может потерять данные в "
"случае падения операционной системы, но не в случае падения "
"<productname>PostgreSQL</productname>. Тем не менее, этот вариант полезен на "
"практике, так как позволяет сократить время отклика для транзакции. Потеря "
"данных может произойти только в случае одновременного сбоя ведущего и "
"резервного, осложнённого повреждением БД на ведущем."

#: high-availability.xml:1114(para)
msgid ""
"Setting <varname>synchronous_commit</varname> to <literal>remote_apply</"
"literal> will cause each commit to wait until the current synchronous "
"standbys report that they have replayed the transaction, making it visible "
"to user queries. In simple cases, this allows for load balancing with causal "
"consistency."
msgstr ""
"Если <varname>synchronous_commit</varname> имеет значение "
"<literal>remote_apply</literal>, то для завершения фиксирования транзакции "
"потребуется дождаться, чтобы текущие синхронные резервные серверы сообщили, "
"что они воспроизвели транзакцию и её могут видеть запросы пользователей. В "
"простых случаях это позволяет обеспечить обычный уровень согласованности и "
"распределение нагрузки."

#: high-availability.xml:1122(para)
msgid ""
"Users will stop waiting if a fast shutdown is requested. However, as when "
"using asynchronous replication, the server will not fully shutdown until all "
"outstanding WAL records are transferred to the currently connected standby "
"servers."
msgstr ""
"Пользователи прекратят ожидание в случае запроса на быструю остановку "
"сервера. В то время как при использовании асинхронной репликации сервер не "
"будет полностью остановлен, пока все исходящие записи WAL не переместятся на "
"текущий присоединённый резервный сервер."

#: high-availability.xml:1132(title)
msgid "Multiple Synchronous Standbys"
msgstr "Несколько синхронных резервных серверов"

#: high-availability.xml:1134(para)
msgid ""
"Synchronous replication supports one or more synchronous standby servers; "
"transactions will wait until all the standby servers which are considered as "
"synchronous confirm receipt of their data. The number of synchronous "
"standbys that transactions must wait for replies from is specified in "
"<varname>synchronous_standby_names</varname>. This parameter also specifies "
"a list of standby names, which determines the priority of each standby for "
"being chosen as a synchronous standby. The standbys whose names appear "
"earlier in the list are given higher priority and will be considered as "
"synchronous. Other standby servers appearing later in this list represent "
"potential synchronous standbys. If any of the current synchronous standbys "
"disconnects for whatever reason, it will be replaced immediately with the "
"next-highest-priority standby."
msgstr ""
"Синхронная репликация поддерживает применение одного или нескольких "
"синхронных резервных серверов; транзакции будут ждать, пока все резервные "
"серверы, считающиеся синхронными, не подтвердят получение своих данных. "
"Число синхронных резервных серверов, от которых транзакции должны ждать "
"подтверждения, задаётся в параметре <varname>synchronous_standby_names</"
"varname>. В этом параметре также задаётся список имён резервных серверов, "
"определяющий и приоритет каждого сервера при выборе на роль синхронного "
"резервного. Серверы, имена которых идут в начале списка, имеют больший "
"приоритет и выбираются на роль синхронных. Другие резервные серверы, идущие "
"в этом списке за ними, считаются потенциальными синхронными. Если один из "
"текущих синхронных резервных серверов по какой-либо причине отключается, он "
"будет немедленно заменён следующим по порядку резервным сервером."

#: high-availability.xml:1151(programlisting)
#, no-wrap
msgid "synchronous_standby_names = '2 (s1, s2, s3)'"
msgstr "synchronous_standby_names = '2 (s1, s2, s3)'"

#: high-availability.xml:1148(para)
msgid ""
"An example of <varname>synchronous_standby_names</varname> for multiple "
"synchronous standbys is: <placeholder-1/> In this example, if four standby "
"servers <literal>s1</literal>, <literal>s2</literal>, <literal>s3</literal> "
"and <literal>s4</literal> are running, the two standbys <literal>s1</"
"literal> and <literal>s2</literal> will be chosen as synchronous standbys "
"because their names appear early in the list of standby names. <literal>s3</"
"literal> is a potential synchronous standby and will take over the role of "
"synchronous standby when either of <literal>s1</literal> or <literal>s2</"
"literal> fails. <literal>s4</literal> is an asynchronous standby since its "
"name is not in the list."
msgstr ""
"Пример значения <varname>synchronous_standby_names</varname> для нескольких "
"синхронных резервных серверов: <placeholder-1/> В данном примере, если "
"работают четыре резервных сервера <literal>s1</literal>, <literal>s2</"
"literal>, <literal>s3</literal> и <literal>s4</literal>, два сервера "
"<literal>s1</literal> и <literal>s2</literal> будут выбраны на роль "
"синхронных резервных, так как их имена идут в начале этого списка. Сервер "
"<literal>s3</literal> будет потенциальным резервным, и возьмёт на себя роль "
"синхронного резервного при отказе <literal>s1</literal> или <literal>s2</"
"literal>. Сервер <literal>s4</literal> будет асинхронным резервным, так как "
"его имя в этом списке отсутствует."

#: high-availability.xml:1166(title)
msgid "Planning for Performance"
msgstr "Планирование производительности"

#: high-availability.xml:1168(para)
msgid ""
"Synchronous replication usually requires carefully planned and placed "
"standby servers to ensure applications perform acceptably. Waiting doesn't "
"utilize system resources, but transaction locks continue to be held until "
"the transfer is confirmed. As a result, incautious use of synchronous "
"replication will reduce performance for database applications because of "
"increased response times and higher contention."
msgstr ""
"Организуя синхронную репликацию, обычно нужно обстоятельно обдумать "
"конфигурацию и размещение резервных серверов, чтобы обеспечить приемлемую "
"производительность приложений. Ожидание не потребляет системные ресурсы, но "
"блокировки транзакций будут сохраняться до подтверждения передачи. Как "
"следствие, непродуманное использование синхронной репликации приведёт к "
"снижению производительности БД из-за увеличения времени отклика и числа "
"конфликтов."

#: high-availability.xml:1177(para)
msgid ""
"<productname>PostgreSQL</productname> allows the application developer to "
"specify the durability level required via replication. This can be specified "
"for the system overall, though it can also be specified for specific users "
"or connections, or even individual transactions."
msgstr ""
"<productname>PostgreSQL</productname> позволяет разработчикам выбрать "
"требуемый уровень надёжности, обеспечиваемый при репликации. Он может быть "
"установлен для системы в целом, для отдельного пользователя или соединения "
"или даже для отдельной транзакции."

#: high-availability.xml:1184(para)
msgid ""
"For example, an application workload might consist of: 10% of changes are "
"important customer details, while 90% of changes are less important data "
"that the business can more easily survive if it is lost, such as chat "
"messages between users."
msgstr ""
"Например, в рабочей нагрузке приложения 10% изменений могут относиться к "
"важным данным клиентов, а 90% — к менее критичным данным, потеряв которые, "
"бизнес вполне сможет выжить (например, это могут быть текущие разговоры "
"пользователей между собой)."

#: high-availability.xml:1191(para)
msgid ""
"With synchronous replication options specified at the application level (on "
"the primary) we can offer synchronous replication for the most important "
"changes, without slowing down the bulk of the total workload. Application "
"level options are an important and practical tool for allowing the benefits "
"of synchronous replication for high performance applications."
msgstr ""
"При настройке уровня синхронности репликации на уровне приложения (на "
"ведущем) можно задать синхронную репликацию для большинства важных изменений "
"без замедления общего рабочего ритма. Возможность настройки на уровне "
"приложения является важным и практичным средством для получения выгод "
"синхронной репликации при высоком быстродействии."

#: high-availability.xml:1199(para)
msgid ""
"You should consider that the network bandwidth must be higher than the rate "
"of generation of WAL data."
msgstr ""
"Следует иметь в виду, что пропускная способность сети должна быть больше "
"скорости генерирования данных WAL."

#: high-availability.xml:1207(title)
msgid "Planning for High Availability"
msgstr "Планирование отказоустойчивости"

#: high-availability.xml:1209(para)
msgid ""
"<varname>synchronous_standby_names</varname> specifies the number and names "
"of synchronous standbys that transaction commits made when "
"<varname>synchronous_commit</varname> is set to <literal>on</literal>, "
"<literal>remote_apply</literal> or <literal>remote_write</literal> will wait "
"for responses from. Such transaction commits may never be completed if any "
"one of synchronous standbys should crash."
msgstr ""
"В <varname>synchronous_standby_names</varname> задаётся количество и имена "
"синхронных резервных серверов, от которых будет ожидаться подтверждение при "
"фиксировании транзакции, когда параметру <varname>synchronous_commit</"
"varname> присвоено значение <literal>on</literal>, <literal>remote_apply</"
"literal> или <literal>remote_write</literal>. Фиксирование транзакции в "
"таком режиме может не завершиться никогда, если один из синхронных резервных "
"серверов выйдет из строя."

#: high-availability.xml:1218(para)
msgid ""
"The best solution for high availability is to ensure you keep as many "
"synchronous standbys as requested. This can be achieved by naming multiple "
"potential synchronous standbys using <varname>synchronous_standby_names</"
"varname>. The standbys whose names appear earlier in the list will be used "
"as synchronous standbys. Standbys listed after these will take over the role "
"of synchronous standby if one of current ones should fail."
msgstr ""
"Поэтому для высокой степени доступности лучше всего обеспечить наличие "
"синхронных резервных серверов в должном количестве. Для этого можно "
"перечислить несколько потенциальных резервных серверов в строке "
"<varname>synchronous_standby_names</varname>. Фактически синхронными "
"резервными серверами станут серверы, имена которых стоят в этом списке "
"первыми. Следующие за ними серверы будут становиться синхронными резервными "
"при отказе одного из текущих."

#: high-availability.xml:1227(para)
msgid ""
"When a standby first attaches to the primary, it will not yet be properly "
"synchronized. This is described as <literal>catchup</literal> mode. Once the "
"lag between standby and primary reaches zero for the first time we move to "
"real-time <literal>streaming</literal> state. The catch-up duration may be "
"long immediately after the standby has been created. If the standby is shut "
"down, then the catch-up period will increase according to the length of time "
"the standby has been down. The standby is only able to become a synchronous "
"standby once it has reached <literal>streaming</literal> state."
msgstr ""
"Когда к ведущему серверу впервые присоединяется резервный, он ещё не будет "
"полностью синхронизированным. Это называется состоянием "
"<literal>навёрстывания</literal>. Как только отставание резервного от "
"ведущего сервера сократится до нуля в первый раз, система перейдет в "
"состояние <literal>потоковой передачи</literal> в реальном времени. Сразу "
"после создания резервного сервера навёрстывание может быть длительным. В "
"случае выключения резервного сервера длительность этого процесса увеличится "
"соответственно продолжительности простоя. Резервный сервер может стать "
"синхронным только по достижении состояния <literal>потоковой передачи</"
"literal>."

#: high-availability.xml:1239(para)
msgid ""
"If primary restarts while commits are waiting for acknowledgement, those "
"waiting transactions will be marked fully committed once the primary "
"database recovers. There is no way to be certain that all standbys have "
"received all outstanding WAL data at time of the crash of the primary. Some "
"transactions may not show as committed on the standby, even though they show "
"as committed on the primary. The guarantee we offer is that the application "
"will not receive explicit acknowledgement of the successful commit of a "
"transaction until the WAL data is known to be safely received by all the "
"synchronous standbys."
msgstr ""
"Если ведущий сервер перезапускается при наличии зафиксированных транзакций, "
"ожидающих подтверждения, эти транзакции будут помечены как полностью "
"зафиксированные после восстановления ведущего. При этом нельзя "
"гарантировать, что все резервные серверы успели получить все текущие данные "
"WAL к моменту падения ведущего. Таким образом, некоторые транзакции могут "
"считаться незафиксированными на резервном сервере, даже если они считаются "
"зафиксированными на ведущем. Гарантия, которую мы можем дать, состоит в том, "
"что приложение не получит явного подтверждения успешной фиксации, пока не "
"будет уверенности, что данные WAL получены всеми синхронными резервными "
"серверами."

#: high-availability.xml:1252(para)
msgid ""
"If you really cannot keep as many synchronous standbys as requested then you "
"should decrease the number of synchronous standbys that transaction commits "
"must wait for responses from in <varname>synchronous_standby_names</varname> "
"(or disable it) and reload the configuration file on the primary server."
msgstr ""
"Если запустить синхронные резервные серверы в указанном количестве не "
"удаётся, вам следует уменьшить число синхронных серверов, подтверждения "
"которых требуются для завершения фиксации транзакций, в параметре "
"<varname>synchronous_standby_names</varname> (или вовсе отключить его) и "
"перезагрузить файл конфигурации на ведущем сервере."

#: high-availability.xml:1260(para)
msgid ""
"If the primary is isolated from remaining standby servers you should fail "
"over to the best candidate of those other remaining standby servers."
msgstr ""
"В случае если ведущий сервер стал недоступным для оставшихся резервных, "
"следует переключиться на наиболее подходящий из имеющихся резервных серверов."

#: high-availability.xml:1265(para)
msgid ""
"If you need to re-create a standby server while transactions are waiting, "
"make sure that the commands pg_start_backup() and pg_stop_backup() are run "
"in a session with <varname>synchronous_commit</varname> = <literal>off</"
"literal>, otherwise those requests will wait forever for the standby to "
"appear."
msgstr ""
"Если необходимо пересоздать резервный сервер при наличии ожидающей "
"подтверждения транзакции необходимо убедиться, что команды pg_start_backup() "
"и pg_stop_backup() запускаются в сессии с установленным "
"<varname>synchronous_commit</varname> = <literal>off</literal>, в противном "
"случае эти запросы на подтверждение будут бесконечными для вновь возникшего "
"резервного сервера."

#: high-availability.xml:1277(title)
msgid "Continuous archiving in standby"
msgstr "Непрерывное архивирование на резервном сервере"

#: high-availability.xml:1279(indexterm)
msgid ""
"<primary>continuous archiving</primary> <secondary>in standby</secondary>"
msgstr ""
"<primary>непрерывное архивирование</primary> <secondary>на резервном "
"сервере</secondary>"

#: high-availability.xml:1284(para)
msgid ""
"When continuous WAL archiving is used in a standby, there are two different "
"scenarios: the WAL archive can be shared between the primary and the "
"standby, or the standby can have its own WAL archive. When the standby has "
"its own WAL archive, set <varname>archive_mode</varname> to <literal>always</"
"literal>, and the standby will call the archive command for every WAL "
"segment it receives, whether it's by restoring from the archive or by "
"streaming replication. The shared archive can be handled similarly, but the "
"<varname>archive_command</varname> must test if the file being archived "
"exists already, and if the existing file has identical contents. This "
"requires more care in the <varname>archive_command</varname>, as it must be "
"careful to not overwrite an existing file with different contents, but "
"return success if the exactly same file is archived twice. And all that must "
"be done free of race conditions, if two servers attempt to archive the same "
"file at the same time."
msgstr ""
"Когда на резервном сервере применяется последовательное архивирование WAL, "
"возможны два различных сценария: архив WAL может быть общим для ведущего и "
"резервного сервера, либо резервный сервер может иметь собственный архив WAL. "
"Когда резервный работает с собственным архивом WAL, установите в "
"<varname>archive_mode</varname> значение <literal>always</literal>, и он "
"будет вызывать команду архивации для каждого сегмента WAL, который он "
"получает при восстановлении из архива или потоковой репликации. В случае с "
"общим архивом можно поступить аналогично, но <varname>archive_command</"
"varname> должна проверять, нет ли в архиве файла, идентичного архивируемому. "
"Таким образом, команда <varname>archive_command</varname> должна "
"позаботиться о том, чтобы существующий файл не был заменён файлом с другим "
"содержимым, а в случае попытки повторного архивирования должна сообщать об "
"успешном выполнении. При этом все эти действия должны быть рассчитаны на "
"условия гонки, возможные, если два сервера попытаются архивировать один и "
"тот же файл одновременно."

#: high-availability.xml:1302(para)
msgid ""
"If <varname>archive_mode</varname> is set to <literal>on</literal>, the "
"archiver is not enabled during recovery or standby mode. If the standby "
"server is promoted, it will start archiving after the promotion, but will "
"not archive any WAL it did not generate itself. To get a complete series of "
"WAL files in the archive, you must ensure that all WAL is archived, before "
"it reaches the standby. This is inherently true with file-based log "
"shipping, as the standby can only restore files that are found in the "
"archive, but not if streaming replication is enabled. When a server is not "
"in recovery mode, there is no difference between <literal>on</literal> and "
"<literal>always</literal> modes."
msgstr ""
"Если в <varname>archive_mode</varname> установлено значение <literal>on</"
"literal>, архивация в режиме восстановления или резерва не производится. В "
"случае повышения резервного сервера, он начнёт архивацию после повышения, но "
"в архив не попадут те файлы WAL, которые генерировал не он сам. Поэтому, "
"чтобы в архиве оказался полный набор файлов WAL, необходимо обеспечить "
"архивацию всех файлов WAL до того, как они попадут на резервный сервер. Это "
"естественным образом происходит при трансляции файлов журналов, так как "
"резервный сервер может восстановить только файлы, которые находятся в "
"архиве, однако при потоковой репликации это не так. Когда сервер работает не "
"в режиме резерва, различий между режимами <literal>on</literal> и "
"<literal>always</literal> нет."

#: high-availability.xml:1318(title)
msgid "Failover"
msgstr "Отработка отказа"

#: high-availability.xml:1320(para)
msgid ""
"If the primary server fails then the standby server should begin failover "
"procedures."
msgstr ""
"Если ведущий сервер отказывает, резервный должен начать процедуры отработки "
"отказа."

#: high-availability.xml:1325(para)
msgid ""
"If the standby server fails then no failover need take place. If the standby "
"server can be restarted, even some time later, then the recovery process can "
"also be restarted immediately, taking advantage of restartable recovery. If "
"the standby server cannot be restarted, then a full new standby server "
"instance should be created."
msgstr ""
"Если отказывает резервный сервер, никакие действия по отработке отказа не "
"требуются. Если резервный сервер будет перезапущен, даже через некоторое "
"время, немедленно начнётся операция восстановления, благодаря возможности "
"возобновляемого восстановления. Если вернуть резервный сервер в строй "
"невозможно, необходимо создать полностью новый экземпляр резервного сервера."

#: high-availability.xml:1333(para)
msgid ""
"If the primary server fails and the standby server becomes the new primary, "
"and then the old primary restarts, you must have a mechanism for informing "
"the old primary that it is no longer the primary. This is sometimes known as "
"<acronym>STONITH</acronym> (Shoot The Other Node In The Head), which is "
"necessary to avoid situations where both systems think they are the primary, "
"which will lead to confusion and ultimately data loss."
msgstr ""
"Когда ведущий сервер отказывает и резервный сервер становится новым ведущим, "
"а затем старый ведущий включается снова, необходим механизм для "
"предотвращения возврата старого к роли ведущего. Иногда его называют "
"<acronym>STONITH</acronym> (Shoot The Other Node In The Head, &laquo;"
"Выстрелите в голову другому узлу&raquo;), что позволяет избежать ситуации, "
"когда обе системы считают себя ведущими, и в результате возникают конфликты "
"и потеря данных."

#: high-availability.xml:1342(para)
msgid ""
"Many failover systems use just two systems, the primary and the standby, "
"connected by some kind of heartbeat mechanism to continually verify the "
"connectivity between the two and the viability of the primary. It is also "
"possible to use a third system (called a witness server) to prevent some "
"cases of inappropriate failover, but the additional complexity might not be "
"worthwhile unless it is set up with sufficient care and rigorous testing."
msgstr ""
"Во многих отказоустойчивых конструкциях используются всего две системы: "
"ведущая и резервная, с некоторым контрольным механизмом, который постоянно "
"проверяет соединение между ними и работоспособность ведущей. Также возможно "
"применение третьей системы (называемой следящим сервером) для исключения "
"некоторых вариантов нежелательной отработки отказа, но эта дополнительная "
"сложность оправдана, только если вся схема достаточно хорошо продумана и "
"тщательно протестирована."

#: high-availability.xml:1352(para)
msgid ""
"<productname>PostgreSQL</productname> does not provide the system software "
"required to identify a failure on the primary and notify the standby "
"database server. Many such tools exist and are well integrated with the "
"operating system facilities required for successful failover, such as IP "
"address migration."
msgstr ""
"<productname>PostgreSQL</productname> не предоставляет системного "
"программного обеспечения, необходимого для определения сбоя на ведущем и "
"уведомления резервного сервера баз данных. Имеется множество подобных "
"инструментов, которые хорошо интегрируются со средствами операционной "
"системы, требуемыми для успешной отработки отказа, например, для миграции IP-"
"адреса."

#: high-availability.xml:1360(para)
msgid ""
"Once failover to the standby occurs, there is only a single server in "
"operation. This is known as a degenerate state. The former standby is now "
"the primary, but the former primary is down and might stay down. To return "
"to normal operation, a standby server must be recreated, either on the "
"former primary system when it comes up, or on a third, possibly new, system. "
"The <xref linkend=\"app-pgrewind\"/> utility can be used to speed up this "
"process on large clusters. Once complete, the primary and standby can be "
"considered to have switched roles. Some people choose to use a third server "
"to provide backup for the new primary until the new standby server is "
"recreated, though clearly this complicates the system configuration and "
"operational processes."
msgstr ""
"Когда происходит переключение на резервный сервер, только один сервер "
"продолжает работу. Это состояние называется ущербным. Бывший резервный "
"сервер теперь является ведущим, а бывший ведущий отключён и может оставаться "
"отключённым. Для возвращения к нормальному состоянию необходимо запустить "
"новый резервный сервер, либо на бывшем ведущем, либо в третьей, возможно, "
"новой системе. Ускорить этот процесс в больших кластерах позволяет утилита "
"<xref linkend=\"app-pgrewind\"/>. По завершении этого процесса можно "
"считать, что ведущий и резервный сервер поменялись ролями. Некоторые "
"используют третий сервер в качестве запасного для нового ведущего, пока не "
"будет воссоздан новый резервный сервер, хотя это, очевидно, усложняет "
"конфигурацию системы и рабочие процедуры."

#: high-availability.xml:1377(para)
msgid ""
"So, switching from primary to standby server can be fast but requires some "
"time to re-prepare the failover cluster. Regular switching from primary to "
"standby is useful, since it allows regular downtime on each system for "
"maintenance. This also serves as a test of the failover mechanism to ensure "
"that it will really work when you need it. Written administration procedures "
"are advised."
msgstr ""
"Таким образом, переключение с ведущего сервера на резервный может быть "
"быстрым, но требует некоторого времени для повторной подготовки "
"отказоустойчивого кластера. Регулярные переключения с ведущего сервера на "
"резервный полезны, так как при этом появляется плановое время для отключения "
"и проведения обслуживания. Это также позволяет убедиться в работоспособности "
"механизма отработки отказа и гарантировать, что он действительно будет "
"работать, когда потребуется. Эти административные процедуры рекомендуется "
"документировать письменно."

#: high-availability.xml:1386(para)
msgid ""
"To trigger failover of a log-shipping standby server, run <command>pg_ctl "
"promote</command> or create a trigger file with the file name and path "
"specified by the <varname>trigger_file</varname> setting in "
"<filename>recovery.conf</filename>. If you're planning to use "
"<command>pg_ctl promote</command> to fail over, <varname>trigger_file</"
"varname> is not required. If you're setting up the reporting servers that "
"are only used to offload read-only queries from the primary, not for high "
"availability purposes, you don't need to promote it."
msgstr ""
"Чтобы сделать ведущим резервный сервер, принимающий журналы, выполните "
"команду <command>pg_ctl promote</command> или создайте файл-триггер с именем "
"и путём, заданным в параметре <varname>trigger_file</varname> в файле "
"<filename>recovery.conf</filename>. Если для переключения планируется "
"использовать команду <command>pg_ctl promote</command>, указывать "
"<varname>trigger_file</varname> не требуется. Если резервный сервер "
"применяется для анализа данных, чтобы только разгрузить ведущий, выполняя "
"запросы на чтение, а не обеспечивать отказоустойчивость, повышать его до "
"ведущего не понадобится."

#: high-availability.xml:1399(title)
msgid "Alternative Method for Log Shipping"
msgstr "Другие методы трансляции журнала"

#: high-availability.xml:1401(para)
msgid ""
"An alternative to the built-in standby mode described in the previous "
"sections is to use a <varname>restore_command</varname> that polls the "
"archive location. This was the only option available in versions 8.4 and "
"below. In this setup, set <varname>standby_mode</varname> off, because you "
"are implementing the polling required for standby operation yourself. See "
"the <xref linkend=\"pgstandby\"/> module for a reference implementation of "
"this."
msgstr ""
"Встроенному режиму резерва, описанному в предыдущем разделе, есть "
"альтернатива — задать в <varname>restore_command</varname> команду, следящую "
"за содержимым архива. Эта возможность доступна только для версии 8.4 и выше. "
"В такой конфигурации режим <varname>standby_mode</varname> выключается, так "
"как реализуется отдельный механизм слежения за данными, требующихся для "
"резервного сервера. См. модуль <xref linkend=\"pgstandby\"/> для примера "
"реализации такой возможности."

#: high-availability.xml:1411(para)
msgid ""
"Note that in this mode, the server will apply WAL one file at a time, so if "
"you use the standby server for queries (see Hot Standby), there is a delay "
"between an action in the master and when the action becomes visible in the "
"standby, corresponding the time it takes to fill up the WAL file. "
"<varname>archive_timeout</varname> can be used to make that delay shorter. "
"Also note that you can't combine streaming replication with this method."
msgstr ""
"Необходимо отметить, что в этом режиме сервер будет применять только один "
"файл WAL одновременно, то есть если использовать резервный сервер для "
"запросов (см. сервер горячего резерва), будет задержка между операциями на "
"главном и моментом видимости этой операции резервным, соответствующей "
"времени заполнения файла WAL. <varname>archive_timeout</varname> можно "
"использовать для снижения этой задержки. Так же необходимо отметить, что "
"нельзя совмещать этот метод с потоковой репликацией."

#: high-availability.xml:1421(para)
msgid ""
"The operations that occur on both primary and standby servers are normal "
"continuous archiving and recovery tasks. The only point of contact between "
"the two database servers is the archive of WAL files that both share: "
"primary writing to the archive, standby reading from the archive. Care must "
"be taken to ensure that WAL archives from separate primary servers do not "
"become mixed together or confused. The archive need not be large if it is "
"only required for standby operation."
msgstr ""
"В процессе работы на ведущем сервере и резервном будет происходить обычное "
"формирование архивов и их восстановление. Единственной точкой "
"соприкосновения двух серверов будут только архивы файлов WAL на обеих "
"сторонах: на ведущем архивы формируются, на резервном происходит чтение "
"данных из архивов. Следует внимательно следить за тем, чтобы архивы WAL от "
"разных ведущих серверов не смешивались или не перепутывались. Архив не "
"должен быть больше, чем это необходимо для работы резерва."

#: high-availability.xml:1431(para)
msgid ""
"The magic that makes the two loosely coupled servers work together is simply "
"a <varname>restore_command</varname> used on the standby that, when asked "
"for the next WAL file, waits for it to become available from the primary. "
"The <varname>restore_command</varname> is specified in the "
"<filename>recovery.conf</filename> file on the standby server. Normal "
"recovery processing would request a file from the WAL archive, reporting "
"failure if the file was unavailable. For standby processing it is normal for "
"the next WAL file to be unavailable, so the standby must wait for it to "
"appear. For files ending in <literal>.backup</literal> or <literal>.history</"
"literal> there is no need to wait, and a non-zero return code must be "
"returned. A waiting <varname>restore_command</varname> can be written as a "
"custom script that loops after polling for the existence of the next WAL "
"file. There must also be some way to trigger failover, which should "
"interrupt the <varname>restore_command</varname>, break the loop and return "
"a file-not-found error to the standby server. This ends recovery and the "
"standby will then come up as a normal server."
msgstr ""
"Магия, заставляющая работать вместе два плотно связанных сервера, проста: "
"<varname>restore_command</varname> выполняется на резервном для запроса "
"следующего файла WAL, ожидает его доступности на ведущем. Команда "
"<varname>restore_command</varname> задаётся в файле <filename>recovery.conf</"
"filename> на резервном сервере. Обычно процесс восстановления запрашивает "
"файл из архива WAL, сообщая об ошибке в случае его недоступности. Для работы "
"резервного сервера недоступность очередного файла WAL является обычной "
"ситуацией, резервный просто ожидает его появления. Для файлов, "
"оканчивающихся на <literal>.backup</literal> или <literal>.history</literal> "
"не требуется ожидания, поэтому возвращается ненулевой код. Ожидающая "
"<varname>restore_command</varname> может быть написана как пользовательский "
"скрипт, который в цикле опрашивает, не появился ли очередной файл WAL. Так "
"же должен быть способ инициировать переключение роли, при котором цикл в "
"<varname>restore_command</varname> должен прерваться, а резервный сервер "
"должен получить ошибку &laquo;файл не найден&raquo;. При этом восстановление "
"завершится и резервный сервер сможет станет обычным."

#: high-availability.xml:1452(programlisting)
#, no-wrap
msgid ""
"triggered = false;\n"
"while (!NextWALFileReady() &amp;&amp; !triggered)\n"
"{\n"
"    sleep(100000L);         /* wait for ~0.1 sec */\n"
"    if (CheckForExternalTrigger())\n"
"        triggered = true;\n"
"}\n"
"if (!triggered)\n"
"        CopyWALFileForRecovery();"
msgstr ""
"triggered = false;\n"
"while (!NextWALFileReady() &amp;&amp; !triggered)\n"
"{\n"
"    sleep(100000L);         /* ждать ~0.1 сек*/\n"
"    if (CheckForExternalTrigger())\n"
"        triggered = true;\n"
"}\n"
"if (!triggered)\n"
"        CopyWALFileForRecovery();"

#: high-availability.xml:1450(para)
msgid ""
"Pseudocode for a suitable <varname>restore_command</varname> is: "
"<placeholder-1/>"
msgstr ""
"Псевдокод для подходящей <varname>restore_command</varname>: <placeholder-1/>"

#: high-availability.xml:1465(para)
msgid ""
"A working example of a waiting <varname>restore_command</varname> is "
"provided in the <xref linkend=\"pgstandby\"/> module. It should be used as a "
"reference on how to correctly implement the logic described above. It can "
"also be extended as needed to support specific configurations and "
"environments."
msgstr ""
"Рабочий пример ожидающей <varname>restore_command</varname> представлен в "
"модуле <xref linkend=\"pgstandby\"/>. К нему следует обратится за примером "
"правильной реализации логики, описанной выше. Он так же может быть расширен "
"для поддержки особых конфигураций и окружений."

#: high-availability.xml:1473(para)
msgid ""
"The method for triggering failover is an important part of planning and "
"design. One potential option is the <varname>restore_command</varname> "
"command. It is executed once for each WAL file, but the process running the "
"<varname>restore_command</varname> is created and dies for each file, so "
"there is no daemon or server process, and signals or a signal handler cannot "
"be used. Therefore, the <varname>restore_command</varname> is not suitable "
"to trigger failover. It is possible to use a simple timeout facility, "
"especially if used in conjunction with a known <varname>archive_timeout</"
"varname> setting on the primary. However, this is somewhat error prone since "
"a network problem or busy primary server might be sufficient to initiate "
"failover. A notification mechanism such as the explicit creation of a "
"trigger file is ideal, if this can be arranged."
msgstr ""
"Метод вызова переключения является важной частью планирования и архитектуры. "
"Один из возможных вариантов — команда <varname>restore_command</varname>. "
"Она исполняется единожды для каждого файла WAL, но процесс, запускаемый "
"<varname>restore_command</varname>, создаётся и завершается для каждого "
"файла, так что это не служба и не серверный процесс, и применить сигналы и "
"реализовать их обработчик в нём нельзя. Поэтому <varname>restore_command</"
"varname> не подходит для отработки отказа. Можно организовать переключение "
"по тайм-ауту, в частности, связав его с известным значением "
"<varname>archive_timeout</varname> на ведущем. Однако это не очень надёжно, "
"так как переключение может произойти и из-за проблем в сети или "
"загруженности ведущего сервера. В идеале для этого следует использовать "
"механизм уведомлений, например явно создавать файл-триггер, если это "
"возможно."

#: high-availability.xml:1490(title)
msgid "Implementation"
msgstr "Реализация"

#: high-availability.xml:1498(para)
msgid ""
"Set up primary and standby systems as nearly identical as possible, "
"including two identical copies of <productname>PostgreSQL</productname> at "
"the same release level."
msgstr ""
"Разверните ведущую и резервную системы, сделав их максимально одинаковыми, "
"включая две одинаковые копии <productname>PostgreSQL</productname> одного "
"выпуска."

#: high-availability.xml:1505(para)
msgid ""
"Set up continuous archiving from the primary to a WAL archive directory on "
"the standby server. Ensure that <xref linkend=\"guc-archive-mode\"/>, <xref "
"linkend=\"guc-archive-command\"/> and <xref linkend=\"guc-archive-timeout\"/"
"> are set appropriately on the primary (see <xref linkend=\"backup-archiving-"
"wal\"/>)."
msgstr ""
"Настройте постоянную архивацию с ведущего сервера в каталог архивов WAL на "
"резервном. Убедитесь, что <xref linkend=\"guc-archive-mode\"/>, <xref "
"linkend=\"guc-archive-command\"/> и <xref linkend=\"guc-archive-timeout\"/> "
"установлены в соответствующие значения на ведущем (см. <xref remap=\"4\" "
"linkend=\"backup-archiving-wal\"/>)."

#: high-availability.xml:1516(para)
msgid ""
"Make a base backup of the primary server (see <xref linkend=\"backup-base-"
"backup\"/>), and load this data onto the standby."
msgstr ""
"Создайте базовую копию данных ведущего сервера (см. <xref remap=\"4\" "
"linkend=\"backup-base-backup\"/>) и восстановите её на резервном."

#: high-availability.xml:1522(para)
msgid ""
"Begin recovery on the standby server from the local WAL archive, using a "
"<filename>recovery.conf</filename> that specifies a "
"<varname>restore_command</varname> that waits as described previously (see "
"<xref linkend=\"backup-pitr-recovery\"/>)."
msgstr ""
"Запустите восстановление на резервном сервере из локального архива WAL с "
"помощью команды <varname>restore_command</varname> из файла "
"<filename>recovery.conf</filename> как описано выше (см. <xref remap=\"4\" "
"linkend=\"backup-pitr-recovery\"/>)."

#: high-availability.xml:1492(para)
msgid ""
"The short procedure for configuring a standby server using this alternative "
"method is as follows. For full details of each step, refer to previous "
"sections as noted. <placeholder-1/>"
msgstr ""
"Сокращённая процедура настройки для резервного сервера с применением "
"альтернативного метода указана ниже. Для подробностей по каждому шагу "
"следует обратиться к указанному разделу. <placeholder-1/>"

#: high-availability.xml:1532(para)
msgid ""
"Recovery treats the WAL archive as read-only, so once a WAL file has been "
"copied to the standby system it can be copied to tape at the same time as it "
"is being read by the standby database server. Thus, running a standby server "
"for high availability can be performed at the same time as files are stored "
"for longer term disaster recovery purposes."
msgstr ""
"Поток восстановления только читает архив WAL, поэтому, как только файл WAL "
"скопирован на резервную систему, его можно копировать на ленту в то время, "
"как его читает резервный сервер. Таким образом, работа резервного сервера в "
"целях отказоустойчивости может быть совмещена с долговременным сохранением "
"файлов для восстановления после катастрофических сбоев."

#: high-availability.xml:1541(para)
msgid ""
"For testing purposes, it is possible to run both primary and standby servers "
"on the same system. This does not provide any worthwhile improvement in "
"server robustness, nor would it be described as HA."
msgstr ""
"Для целей тестирования возможен запуск ведущего и резервного сервера в одной "
"системе. Это не обеспечивает надёжность серверов, так же как и не подходит "
"под описание высокой доступности."

#: high-availability.xml:1549(title)
msgid "Record-based Log Shipping"
msgstr "Построчная трансляция журнала"

#: high-availability.xml:1551(para)
msgid ""
"It is also possible to implement record-based log shipping using this "
"alternative method, though this requires custom development, and changes "
"will still only become visible to hot standby queries after a full WAL file "
"has been shipped."
msgstr ""
"Так же возможна реализация построчной трансляции журналов с применением "
"альтернативного метода, хотя это требует дополнительных доработок, а "
"изменения будут видны для запросов на сервере горячего резерва только после "
"передачи полного файла WAL."

#: high-availability.xml:1558(para)
msgid ""
"An external program can call the <function>pg_xlogfile_name_offset()</"
"function> function (see <xref linkend=\"functions-admin\"/>) to find out the "
"file name and the exact byte offset within it of the current end of WAL. It "
"can then access the WAL file directly and copy the data from the last known "
"end of WAL through the current end over to the standby servers. With this "
"approach, the window for data loss is the polling cycle time of the copying "
"program, which can be very small, and there is no wasted bandwidth from "
"forcing partially-used segment files to be archived. Note that the standby "
"servers' <varname>restore_command</varname> scripts can only deal with whole "
"WAL files, so the incrementally copied data is not ordinarily made available "
"to the standby servers. It is of use only when the primary dies &mdash; then "
"the last partial WAL file is fed to the standby before allowing it to come "
"up. The correct implementation of this process requires cooperation of the "
"<varname>restore_command</varname> script with the data copying program."
msgstr ""
"Внешняя программа может вызвать функцию <function>pg_xlogfile_name_offset()</"
"function> (см. <xref remap=\"4\" linkend=\"functions-admin\"/>) для поиска "
"имени файла и точного смещения в нём от текущего конца WAL. Можно получить "
"доступ к файлу WAL напрямую и скопировать данные из последнего известного "
"окончания WAL до текущего окончания на резервном сервере. При таком подходе "
"интервал возможной потери данных определяется временем цикла работы "
"программы копирования, что может составлять очень малую величину. Так же не "
"потребуется напрасно использовать широкую полосу пропускания для "
"принудительного архивирования частично заполненного файла сегмента. Следует "
"отметить, что на резервном сервере скрипт команды <varname>restore_command</"
"varname> работает только с файлом WAL целиком, таким образом, копирование "
"данных нарастающим итогом не может быть выполнено на резервном обычными "
"средствами. Это используется только в случае отказа ведущего &mdash; когда "
"последний частично сформированный файл WAL предоставляется резервному "
"непосредственно перед переключением. Корректная реализация этого процесса "
"требует взаимодействия скрипта команды <varname>restore_command</varname> с "
"данными из программы копирования."

#: high-availability.xml:1577(para)
msgid ""
"Starting with <productname>PostgreSQL</productname> version 9.0, you can use "
"streaming replication (see <xref linkend=\"streaming-replication\"/>) to "
"achieve the same benefits with less effort."
msgstr ""
"Начиная с <productname>PostgreSQL</productname> версии 9.0 можно "
"использовать потоковую репликацию (см. <xref remap=\"4\" linkend=\"streaming-"
"replication\"/>) для получения этих же преимуществ меньшими усилиями."

#: high-availability.xml:1586(title)
msgid "Hot Standby"
msgstr "Горячий резерв"

#: high-availability.xml:1588(indexterm)
msgid "<primary>Hot Standby</primary>"
msgstr "<primary>горячий резерв</primary>"

#: high-availability.xml:1592(para)
msgid ""
"Hot Standby is the term used to describe the ability to connect to the "
"server and run read-only queries while the server is in archive recovery or "
"standby mode. This is useful both for replication purposes and for restoring "
"a backup to a desired state with great precision. The term Hot Standby also "
"refers to the ability of the server to move from recovery through to normal "
"operation while users continue running queries and/or keep their connections "
"open."
msgstr ""
"Термин &laquo;горячий резерв&raquo; используется для описания возможности "
"подключаться к серверу и выполнять запросы на чтение, в то время как сервер "
"находится в режиме резерва или восстановления архива. Это полезно и для "
"целей репликации, и для восстановления желаемого состояния из резервной "
"копии с высокой точностью. Так же термин «горячий резерв» описывает "
"способность сервера переходить из режима восстановления к обычной работе, в "
"то время как пользователи продолжают выполнять запросы и/или их соединения "
"остаются открытыми."

#: high-availability.xml:1603(para)
msgid ""
"Running queries in hot standby mode is similar to normal query operation, "
"though there are several usage and administrative differences explained "
"below."
msgstr ""
"В режиме горячего резерва запросы выполняются примерно так же, как и в "
"обычном режиме, с некоторыми отличиями в использовании и администрировании, "
"описанными ниже."

#: high-availability.xml:1610(title)
msgid "User's Overview"
msgstr "Обзор на уровне пользователя"

#: high-availability.xml:1612(para)
msgid ""
"When the <xref linkend=\"guc-hot-standby\"/> parameter is set to true on a "
"standby server, it will begin accepting connections once the recovery has "
"brought the system to a consistent state. All such connections are strictly "
"read-only; not even temporary tables may be written."
msgstr ""
"Когда параметр <xref linkend=\"guc-hot-standby\"/> на резервном сервере "
"установлен в true, то он начинает принимать соединения сразу как только "
"система придёт в согласованное состояние в процессе восстановления. Для "
"таких соединений будет разрешено только чтение, запись невозможна даже во "
"временные таблицы."

#: high-availability.xml:1619(para)
msgid ""
"The data on the standby takes some time to arrive from the primary server so "
"there will be a measurable delay between primary and standby. Running the "
"same query nearly simultaneously on both primary and standby might therefore "
"return differing results. We say that data on the standby is "
"<firstterm>eventually consistent</firstterm> with the primary. Once the "
"commit record for a transaction is replayed on the standby, the changes made "
"by that transaction will be visible to any new snapshots taken on the "
"standby. Snapshots may be taken at the start of each query or at the start "
"of each transaction, depending on the current transaction isolation level. "
"For more details, see <xref linkend=\"transaction-iso\"/>."
msgstr ""
"Для того, чтобы данные с ведущего сервера были получены на резервном, "
"требуется некоторое время. Таким образом, имеется измеряемая задержка между "
"ведущим и резервным серверами. Поэтому запуск одинаковых запросов примерно в "
"одно время на ведущем и резервном серверах может вернуть разный результат. "
"Можно сказать, что данные на резервном сервере <firstterm>в конечном счёте "
"согласуются</firstterm> с ведущим. После того, как запись о зафиксированной "
"транзакции воспроизводится на резервном сервере, изменения, совершённые в "
"этой транзакции, становится видны в любых последующих снимках данных на "
"резервном сервере. Снимок может быть сделан в начале каждого запроса или в "
"начале каждой транзакции в зависимости от уровня изоляции транзакции. Более "
"подробно см. <xref remap=\"4\" linkend=\"transaction-iso\"/>."

#: high-availability.xml:1637(para)
msgid "Query access - <command>SELECT</command>, <command>COPY TO</command>"
msgstr ""
"Доступ к данным — <command>SELECT</command>, <command>COPY TO</command>"

#: high-availability.xml:1642(para)
msgid ""
"Cursor commands - <command>DECLARE</command>, <command>FETCH</command>, "
"<command>CLOSE</command>"
msgstr ""
"Команды для работы с курсором — <command>DECLARE</command>, <command>FETCH</"
"command>, <command>CLOSE</command>"

#: high-availability.xml:1647(para)
msgid ""
"Parameters - <command>SHOW</command>, <command>SET</command>, "
"<command>RESET</command>"
msgstr ""
"Параметры — <command>SHOW</command>, <command>SET</command>, <command>RESET</"
"command>"

#: high-availability.xml:1656(para)
msgid ""
"<command>BEGIN</command>, <command>END</command>, <command>ABORT</command>, "
"<command>START TRANSACTION</command>"
msgstr ""
"<command>BEGIN</command>, <command>END</command>, <command>ABORT</command>, "
"<command>START TRANSACTION</command>"

#: high-availability.xml:1661(para)
msgid ""
"<command>SAVEPOINT</command>, <command>RELEASE</command>, <command>ROLLBACK "
"TO SAVEPOINT</command>"
msgstr ""
"<command>SAVEPOINT</command>, <command>RELEASE</command>, <command>ROLLBACK "
"TO SAVEPOINT</command>"

#: high-availability.xml:1666(para)
msgid "<command>EXCEPTION</command> blocks and other internal subtransactions"
msgstr ""
"Блок <command>EXCEPTION</command> и другие внутренние подчиненные транзакции"

#: high-availability.xml:1652(para)
msgid "Transaction management commands <placeholder-1/>"
msgstr "Команды явного управления транзакциями <placeholder-1/>"

#: high-availability.xml:1674(para)
msgid ""
"<command>LOCK TABLE</command>, though only when explicitly in one of these "
"modes: <literal>ACCESS SHARE</literal>, <literal>ROW SHARE</literal> or "
"<literal>ROW EXCLUSIVE</literal>."
msgstr ""
"<command>LOCK TABLE</command>, только когда исполняется в явном виде в "
"следующем режиме: <literal>ACCESS SHARE</literal>, <literal>ROW SHARE</"
"literal> или <literal>ROW EXCLUSIVE</literal>."

#: high-availability.xml:1680(para)
msgid ""
"Plans and resources - <command>PREPARE</command>, <command>EXECUTE</"
"command>, <command>DEALLOCATE</command>, <command>DISCARD</command>"
msgstr ""
"Планы и ресурсы — <command>PREPARE</command>, <command>EXECUTE</command>, "
"<command>DEALLOCATE</command>, <command>DISCARD</command>"

#: high-availability.xml:1686(para)
msgid "Plugins and extensions - <command>LOAD</command>"
msgstr "Дополнения и расширения — <command>LOAD</command>"

#: high-availability.xml:1632(para)
msgid ""
"Transactions started during hot standby may issue the following commands: "
"<placeholder-1/>"
msgstr ""
"Транзакции, запущенные в режиме горячего резерва, могут выполнять следующие "
"команды: <placeholder-1/>"

#: high-availability.xml:1700(para)
msgid ""
"Data Manipulation Language (DML) - <command>INSERT</command>, "
"<command>UPDATE</command>, <command>DELETE</command>, <command>COPY FROM</"
"command>, <command>TRUNCATE</command>. Note that there are no allowed "
"actions that result in a trigger being executed during recovery. This "
"restriction applies even to temporary tables, because table rows cannot be "
"read or written without assigning a transaction ID, which is currently not "
"possible in a Hot Standby environment."
msgstr ""
"Команды манипуляции данными (DML) — <command>INSERT</command>, "
"<command>UPDATE</command>, <command>DELETE</command>, <command>COPY FROM</"
"command>, <command>TRUNCATE</command>. Следует отметить, что нет разрешённых "
"действий, которые приводили бы к срабатыванию триггера во время исполнения "
"на резервном сервере. Это ограничение так же касается и временных таблиц, "
"так как строки таблицы не могут быть прочитаны или записаны без обращения к "
"ID транзакции, что в настоящее время не возможно в среде горячего резерва."

#: high-availability.xml:1712(para)
msgid ""
"Data Definition Language (DDL) - <command>CREATE</command>, <command>DROP</"
"command>, <command>ALTER</command>, <command>COMMENT</command>. This "
"restriction applies even to temporary tables, because carrying out these "
"operations would require updating the system catalog tables."
msgstr ""
"Команды определения данных (DDL) — <command>CREATE</command>, <command>DROP</"
"command>, <command>ALTER</command>, <command>COMMENT</command>. Эти "
"ограничения так же относятся и к временным таблицам, так как операции могут "
"потребовать обновления таблиц системных каталогов."

#: high-availability.xml:1720(para)
msgid ""
"<command>SELECT ... FOR SHARE | UPDATE</command>, because row locks cannot "
"be taken without updating the underlying data files."
msgstr ""
"<command>SELECT ... FOR SHARE | UPDATE</command>, так как блокировка строки "
"не может быть проведена без обновления соответствующих файлов данных."

#: high-availability.xml:1726(para)
msgid ""
"Rules on <command>SELECT</command> statements that generate DML commands."
msgstr ""
"Правила для выражений <command>SELECT</command>, которые приводят к "
"выполнению команд DML."

#: high-availability.xml:1731(para)
msgid ""
"<command>LOCK</command> that explicitly requests a mode higher than "
"<literal>ROW EXCLUSIVE MODE</literal>."
msgstr ""
"<command>LOCK</command> которая явно требует режим более строгий чем "
"<literal>ROW EXCLUSIVE MODE</literal>."

#: high-availability.xml:1736(para)
msgid ""
"<command>LOCK</command> in short default form, since it requests "
"<literal>ACCESS EXCLUSIVE MODE</literal>."
msgstr ""
"<command>LOCK</command> в короткой форме с умолчаниями, так как требует "
"<literal>ACCESS EXCLUSIVE MODE</literal>."

#: high-availability.xml:1745(para)
msgid ""
"<command>BEGIN READ WRITE</command>, <command>START TRANSACTION READ WRITE</"
"command>"
msgstr ""
"<command>BEGIN READ WRITE</command>, <command>START TRANSACTION READ WRITE</"
"command>"

#: high-availability.xml:1751(para)
msgid ""
"<command>SET TRANSACTION READ WRITE</command>, <command>SET SESSION "
"CHARACTERISTICS AS TRANSACTION READ WRITE</command>"
msgstr ""
"<command>SET TRANSACTION READ WRITE</command>, <command>SET SESSION "
"CHARACTERISTICS AS TRANSACTION READ WRITE</command>"

#: high-availability.xml:1758(command)
msgid "SET transaction_read_only = off"
msgstr "SET transaction_read_only = off"

#: high-availability.xml:1741(para)
msgid ""
"Transaction management commands that explicitly set non-read-only state: "
"<placeholder-1/>"
msgstr ""
"Команды управления транзакциями, которые в явном виде требуют режим не "
"только для чтения <placeholder-1/>"

#: high-availability.xml:1765(para)
msgid ""
"Two-phase commit commands - <command>PREPARE TRANSACTION</command>, "
"<command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command> "
"because even read-only transactions need to write WAL in the prepare phase "
"(the first phase of two phase commit)."
msgstr ""
"Команды двухфазной фиксации — <command>PREPARE TRANSACTION</command>, "
"<command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command>, "
"так как даже транзакции только для чтения нуждаются в записи в WAL на "
"подготовительной фазе (первая фаза двухфазной фиксации)."

#: high-availability.xml:1773(para)
msgid ""
"Sequence updates - <function>nextval()</function>, <function>setval()</"
"function>"
msgstr ""
"Обновление последовательностей — <function>nextval()</function>, "
"<function>setval()</function>"

#: high-availability.xml:1778(para)
msgid ""
"<command>LISTEN</command>, <command>UNLISTEN</command>, <command>NOTIFY</"
"command>"
msgstr ""
"<command>LISTEN</command>, <command>UNLISTEN</command>, <command>NOTIFY</"
"command>"

#: high-availability.xml:1693(para)
msgid ""
"Transactions started during hot standby will never be assigned a transaction "
"ID and cannot write to the system write-ahead log. Therefore, the following "
"actions will produce error messages: <placeholder-1/>"
msgstr ""
"Транзакции, запущенные в режиме горячего резерва, никогда не получают ID "
"транзакции и не могут быть записаны в журнал транзакций. Поэтому при попытке "
"выполнить следующие действия возникнут ошибки: <placeholder-1/>"

#: high-availability.xml:1785(para)
msgid ""
"In normal operation, <quote>read-only</quote> transactions are allowed to "
"update sequences and to use <command>LISTEN</command>, <command>UNLISTEN</"
"command>, and <command>NOTIFY</command>, so Hot Standby sessions operate "
"under slightly tighter restrictions than ordinary read-only sessions. It is "
"possible that some of these restrictions might be loosened in a future "
"release."
msgstr ""
"При обычной работе транзакции <quote>только для чтения</quote> могут "
"обновлять последовательности и использовать команды <command>LISTEN</"
"command>, <command>UNLISTEN</command> и <command>NOTIFY</command>, таким "
"образом сессии горячего резерва работают с несколько большими ограничениями, "
"чем обычные только читающие сессии. Возможно, что некоторые из этих "
"ограничений будут ослаблены в следующих выпусках."

#: high-availability.xml:1793(para)
msgid ""
"During hot standby, the parameter <varname>transaction_read_only</varname> "
"is always true and may not be changed. But as long as no attempt is made to "
"modify the database, connections during hot standby will act much like any "
"other database connection. If failover or switchover occurs, the database "
"will switch to normal processing mode. Sessions will remain connected while "
"the server changes mode. Once hot standby finishes, it will be possible to "
"initiate read-write transactions (even from a session begun during hot "
"standby)."
msgstr ""
"В режиме горячего резерва параметр <varname>transaction_read_only</varname> "
"всегда имеет значение true и изменить его нельзя. Но если не пытаться "
"модифицировать содержимое БД, подключение к серверу в этом режиме не "
"отличается от подключений к обычным базам данных. При отработке отказа или "
"переключении ролей база данных переходит в обычный режим работы. Когда "
"сервер меняет режим работы, установленные сеансы остаются подключёнными. "
"После выхода из режима горячего резерва становится возможным запускать "
"пишущие транзакции (даже в сеансах, начатых ещё в режиме горячего резерва)."

#: high-availability.xml:1804(para)
msgid ""
"Users will be able to tell whether their session is read-only by issuing "
"<command>SHOW transaction_read_only</command>. In addition, a set of "
"functions (<xref linkend=\"functions-recovery-info-table\"/>) allow users to "
"access information about the standby server. These allow you to write "
"programs that are aware of the current state of the database. These can be "
"used to monitor the progress of recovery, or to allow you to write complex "
"programs that restore the database to particular states."
msgstr ""
"Пользователи могут узнать о нахождении сессии в режиме только для чтения с "
"помощью команды <command>SHOW transaction_read_only</command>. Кроме того, "
"набор функций (<xref linkend=\"functions-recovery-info-table\"/>) позволяет "
"пользователям получить доступ к информации о резервном сервере. Это "
"позволяет создавать программы, учитывающие текущий статус базы данных. Такой "
"режим может быть полезен для мониторинга процесса восстановления или для "
"написания комплексного восстановления для особенных случаев."

#: high-availability.xml:1816(title)
msgid "Handling Query Conflicts"
msgstr "Обработка конфликтов запросов"

#: high-availability.xml:1818(para)
msgid ""
"The primary and standby servers are in many ways loosely connected. Actions "
"on the primary will have an effect on the standby. As a result, there is "
"potential for negative interactions or conflicts between them. The easiest "
"conflict to understand is performance: if a huge data load is taking place "
"on the primary then this will generate a similar stream of WAL records on "
"the standby, so standby queries may contend for system resources, such as I/"
"O."
msgstr ""
"Ведущий и резервный серверы связаны между собой многими слабыми связями. "
"События на ведущем сервере оказывают влияние на резервный. В результате "
"имеется потенциальная возможность отрицательного влияния или конфликта между "
"ними. Наиболее простой для понимания конфликт — быстродействие: если на "
"ведущем происходит загрузка очень большого объёма данных, то происходит "
"создание соответствующего потока записей WAL на резервный сервер. Таким "
"образом, запросы на резервном конкурируют за системные ресурсы, например, "
"ввод-вывод."

#: high-availability.xml:1836(para)
msgid ""
"Access Exclusive locks taken on the primary server, including both explicit "
"<command>LOCK</command> commands and various <acronym>DDL</acronym> actions, "
"conflict with table accesses in standby queries."
msgstr ""
"Установка эксклюзивной блокировки на ведущем сервере, как с помощью явной "
"команды <command>LOCK</command>, так и при различных <acronym>DDL</acronym>, "
"что приводит к конфликту доступа к таблицам на резервном."

#: high-availability.xml:1843(para)
msgid ""
"Dropping a tablespace on the primary conflicts with standby queries using "
"that tablespace for temporary work files."
msgstr ""
"Удаление табличного пространства на ведущем сервере приводит к конфликту на "
"резервном когда запросы используют это пространство для хранения временных "
"рабочих файлов."

#: high-availability.xml:1849(para)
msgid ""
"Dropping a database on the primary conflicts with sessions connected to that "
"database on the standby."
msgstr ""
"Удаление базы данных на ведущем сервере конфликтует с сессиями, "
"подключёнными к этой БД на резервном."

#: high-availability.xml:1855(para)
msgid ""
"Application of a vacuum cleanup record from WAL conflicts with standby "
"transactions whose snapshots can still <quote>see</quote> any of the rows to "
"be removed."
msgstr ""
"Приложение очистки устаревших транзакций из WAL конфликтует с транзакциями "
"на резервном сервере, которые используют снимок данных, который всё ещё "
"видит какие-то из очищенных на ведущем строк."

#: high-availability.xml:1862(para)
msgid ""
"Application of a vacuum cleanup record from WAL conflicts with queries "
"accessing the target page on the standby, whether or not the data to be "
"removed is visible."
msgstr ""
"Приложение очистки устаревших транзакций из WAL конфликтует с запросами к "
"целевой странице на резервном сервере вне зависимости от того, являются ли "
"данные удалёнными или видимыми."

#: high-availability.xml:1827(para)
msgid ""
"There are also additional types of conflict that can occur with Hot Standby. "
"These conflicts are <emphasis>hard conflicts</emphasis> in the sense that "
"queries might need to be canceled and, in some cases, sessions disconnected "
"to resolve them. The user is provided with several ways to handle these "
"conflicts. Conflict cases include: <placeholder-1/>"
msgstr ""
"Так же может возникнуть дополнительный тип конфликта на сервере горячего "
"резерва. Этот конфликт называется <emphasis>жёстким конфликтом</emphasis>, "
"оказывает влияние на запросы, приводя к их отмене, а в некоторых случаях и к "
"обрыву сессии для разрешения конфликтов. Пользователям предоставлен набор "
"средств для обработки подобных конфликтов. Случаи конфликтов включают: "
"<placeholder-1/>"

#: high-availability.xml:1871(para)
msgid ""
"On the primary server, these cases simply result in waiting; and the user "
"might choose to cancel either of the conflicting actions. However, on the "
"standby there is no choice: the WAL-logged action already occurred on the "
"primary so the standby must not fail to apply it. Furthermore, allowing WAL "
"application to wait indefinitely may be very undesirable, because the "
"standby's state will become increasingly far behind the primary's. "
"Therefore, a mechanism is provided to forcibly cancel standby queries that "
"conflict with to-be-applied WAL records."
msgstr ""
"В этих случаях на ведущем сервере просто происходит ожидание; пользователю "
"следует выбрать какую их конфликтующих сторон отменить. Тем не менее, на "
"резервном нет выбора: действия из WAL уже произошли на ведущем, поэтому "
"резервный обязан применить их. Более того, позволять обработчику WAL ожидать "
"неограниченно долго может быть крайне нежелательно, так как отставание "
"резервного сервера от ведущего может всё возрастать. Таким образом, механизм "
"обеспечивает принудительную отмену запросов на резервном сервере, которые "
"конфликтуют с применяемыми записями WAL."

#: high-availability.xml:1882(para)
msgid ""
"An example of the problem situation is an administrator on the primary "
"server running <command>DROP TABLE</command> on a table that is currently "
"being queried on the standby server. Clearly the standby query cannot "
"continue if the <command>DROP TABLE</command> is applied on the standby. If "
"this situation occurred on the primary, the <command>DROP TABLE</command> "
"would wait until the other query had finished. But when <command>DROP TABLE</"
"command> is run on the primary, the primary doesn't have information about "
"what queries are running on the standby, so it will not wait for any such "
"standby queries. The WAL change records come through to the standby while "
"the standby query is still running, causing a conflict. The standby server "
"must either delay application of the WAL records (and everything after them, "
"too) or else cancel the conflicting query so that the <command>DROP TABLE</"
"command> can be applied."
msgstr ""
"Примером такой проблемы может быть ситуация: администратор на ведущем "
"сервере выполнил команду <command>DROP TABLE</command> для таблицы, которая "
"сейчас участвует в запросе на резервном. Понятно, что этот запрос нельзя "
"будет выполнять дальше, если команда <command>DROP TABLE</command> "
"применится на резервном. Если бы этот запрос выполнялся на ведущем, команда "
"<command>DROP TABLE</command> ждала бы его окончания. Но когда на ведущем "
"выполняется только команда <command>DROP TABLE</command>, ведущий сервер не "
"знает, какие запросы выполняются на резервном, поэтому он не может ждать "
"завершения подобных запросов. Поэтому если записи WAL с изменением прибудут "
"на резервный сервер, когда запрос будет продолжать выполняться, возникнет "
"конфликт. В этом случае резервный сервер должен либо задержать применение "
"этих записей WAL (и всех остальных, следующих за ними), либо отменить "
"конфликтующий запрос, чтобы можно было применить <command>DROP TABLE</"
"command>."

#: high-availability.xml:1898(para)
msgid ""
"When a conflicting query is short, it's typically desirable to allow it to "
"complete by delaying WAL application for a little bit; but a long delay in "
"WAL application is usually not desirable. So the cancel mechanism has "
"parameters, <xref linkend=\"guc-max-standby-archive-delay\"/> and <xref "
"linkend=\"guc-max-standby-streaming-delay\"/>, that define the maximum "
"allowed delay in WAL application. Conflicting queries will be canceled once "
"it has taken longer than the relevant delay setting to apply any newly-"
"received WAL data. There are two parameters so that different delay values "
"can be specified for the case of reading WAL data from an archive (i.e., "
"initial recovery from a base backup or <quote>catching up</quote> a standby "
"server that has fallen far behind) versus reading WAL data via streaming "
"replication."
msgstr ""
"Если конфликтный запрос короткий, обычно желательно разрешить ему "
"завершиться, ненадолго задержав применение записей WAL, но слишком большая "
"задержка в применении WAL обычно нежелательна. Поэтому механизм отмены имеет "
"параметры <xref linkend=\"guc-max-standby-archive-delay\"/> и <xref linkend="
"\"guc-max-standby-streaming-delay\"/>, которые определяют максимально "
"допустимое время задержки применения WAL. Конфликтующие запросы будут "
"отменены, если они длятся дольше допустимого времени задержки применения "
"очередных записей WAL. Два параметра существуют для того, чтобы можно было "
"задать разные значения для чтения записей WAL из архива (то есть при "
"начальном восстановлении из базовой копии либо при <quote>навёрстывании</"
"quote> ведущего сервера в случае большого отставания) и для получения "
"записей WAL при потоковой репликации."

#: high-availability.xml:1913(para)
msgid ""
"In a standby server that exists primarily for high availability, it's best "
"to set the delay parameters relatively short, so that the server cannot fall "
"far behind the primary due to delays caused by standby queries. However, if "
"the standby server is meant for executing long-running queries, then a high "
"or even infinite delay value may be preferable. Keep in mind however that a "
"long-running query could cause other sessions on the standby server to not "
"see recent changes on the primary, if it delays application of WAL records."
msgstr ""
"На резервном сервере, созданном преимущественно для отказоустойчивости, "
"лучше выставлять параметры задержек относительно небольшими, чтобы он не мог "
"сильно отстать от ведущего из-за задержек, связанных с ожиданием запросов "
"горячего резерва. Однако если резервный сервер предназначен для выполнения "
"длительных запросов, то высокое значение или даже бесконечное ожидание могут "
"быть предпочтительнее. Тем не менее, следует иметь в виду, что длительные "
"запросы могут оказать влияние на другие сессии на резервном сервере в виде "
"отсутствия последних изменений от ведущего из-за задержки применения записей "
"WAL."

#: high-availability.xml:1924(para)
msgid ""
"Once the delay specified by <varname>max_standby_archive_delay</varname> or "
"<varname>max_standby_streaming_delay</varname> has been exceeded, "
"conflicting queries will be canceled. This usually results just in a "
"cancellation error, although in the case of replaying a <command>DROP "
"DATABASE</command> the entire conflicting session will be terminated. Also, "
"if the conflict is over a lock held by an idle transaction, the conflicting "
"session is terminated (this behavior might change in the future)."
msgstr ""
"В случае, если задержка, определённая <varname>max_standby_archive_delay</"
"varname> или <varname>max_standby_streaming_delay</varname> будет превышена, "
"конфликтующий запрос будет отменён. Обычно это выражается в виде ошибки "
"отмены, но в случае проигрывания команды <command>DROP DATABASE</command> "
"обрывается вся конфликтная сессия. Так же, если конфликт произошел при "
"блокировке, вызванной транзакцией в состоянии IDLE, конфликтная сессия "
"разрывается (это поведение может изменить в будущем)."

#: high-availability.xml:1934(para)
msgid ""
"Canceled queries may be retried immediately (after beginning a new "
"transaction, of course). Since query cancellation depends on the nature of "
"the WAL records being replayed, a query that was canceled may well succeed "
"if it is executed again."
msgstr ""
"Отменённые запросы могут быть немедленно повторены (конечно после старта "
"новой транзакции). Так как причина отмены зависит от природы проигрываемых "
"записей WAL, запрос, который был отменён, может быть успешно выполнен вновь."

#: high-availability.xml:1941(para)
msgid ""
"Keep in mind that the delay parameters are compared to the elapsed time "
"since the WAL data was received by the standby server. Thus, the grace "
"period allowed to any one query on the standby is never more than the delay "
"parameter, and could be considerably less if the standby has already fallen "
"behind as a result of waiting for previous queries to complete, or as a "
"result of being unable to keep up with a heavy update load."
msgstr ""
"Следует учесть, что параметры задержки отсчитываются от времени получения "
"резервным сервером данных WAL. Таким образом, период дозволенной работы для "
"запроса на резервном сервере никогда не может быть длиннее параметра "
"задержки и может быть существенно короче, если резервный уже находится в "
"режиме задержки в результате ожидания предыдущего запроса или результат не "
"доступен из-за высокой нагрузки обновлений."

#: high-availability.xml:1950(para)
msgid ""
"The most common reason for conflict between standby queries and WAL replay "
"is <quote>early cleanup</quote>. Normally, <productname>PostgreSQL</"
"productname> allows cleanup of old row versions when there are no "
"transactions that need to see them to ensure correct visibility of data "
"according to MVCC rules. However, this rule can only be applied for "
"transactions executing on the master. So it is possible that cleanup on the "
"master will remove row versions that are still visible to a transaction on "
"the standby."
msgstr ""
"Наиболее частой причиной конфликтов между запросами на резервном сервере и "
"проигрыванием WAL является преждевременная очистка. Обычно "
"<productname>PostgreSQL</productname> допускает очистку старых версий "
"записей при условии что ни одна из транзакций их не видит согласно правилам "
"видимости данных для MVCC. Тем не менее, эти правила применяются только для "
"транзакций, выполняемых на главном сервере. Таким образом, допустима "
"ситуация, когда на главном запись уже очищена, но эта же запись всё ещё "
"видна для транзакций на резервном сервере."

#: high-availability.xml:1960(para)
msgid ""
"Experienced users should note that both row version cleanup and row version "
"freezing will potentially conflict with standby queries. Running a manual "
"<command>VACUUM FREEZE</command> is likely to cause conflicts even on tables "
"with no updated or deleted rows."
msgstr ""
"Для опытных пользователей следует отметить, что как очистка старых версий "
"строк, так и заморозка версии строки могут потенциально вызвать конфликт с "
"запросами на резервном сервере. Ручной запуск команды <command>VACUUM "
"FREEZE</command> может привести к конфликту, даже в таблице без обновленных "
"и удалённых строк."

#: high-availability.xml:1967(para)
msgid ""
"Users should be clear that tables that are regularly and heavily updated on "
"the primary server will quickly cause cancellation of longer running queries "
"on the standby. In such cases the setting of a finite value for "
"<varname>max_standby_archive_delay</varname> or "
"<varname>max_standby_streaming_delay</varname> can be considered similar to "
"setting <varname>statement_timeout</varname>."
msgstr ""
"Пользователи должны понимать, что регулярное и активное изменение данных в "
"таблицах на ведущем сервере чревато отменой длительных запросов на "
"резервном. В таком случае установка конечного значения для "
"<varname>max_standby_archive_delay</varname> или "
"<varname>max_standby_streaming_delay</varname> действует подобно ограничению "
"<varname>statement_timeout</varname>."

#: high-availability.xml:1976(para)
msgid ""
"Remedial possibilities exist if the number of standby-query cancellations is "
"found to be unacceptable. The first option is to set the parameter "
"<varname>hot_standby_feedback</varname>, which prevents <command>VACUUM</"
"command> from removing recently-dead rows and so cleanup conflicts do not "
"occur. If you do this, you should note that this will delay cleanup of dead "
"rows on the primary, which may result in undesirable table bloat. However, "
"the cleanup situation will be no worse than if the standby queries were "
"running directly on the primary server, and you are still getting the "
"benefit of off-loading execution onto the standby. If standby servers "
"connect and disconnect frequently, you might want to make adjustments to "
"handle the period when <varname>hot_standby_feedback</varname> feedback is "
"not being provided. For example, consider increasing "
"<varname>max_standby_archive_delay</varname> so that queries are not rapidly "
"canceled by conflicts in WAL archive files during disconnected periods. You "
"should also consider increasing <varname>max_standby_streaming_delay</"
"varname> to avoid rapid cancellations by newly-arrived streaming WAL entries "
"after reconnection."
msgstr ""
"В случае, если количество отменённых запросов на резервном сервере "
"получается неприемлемым, существует ряд дополнительных возможностей. Первая "
"возможность — установить параметр <varname>hot_standby_feedback</varname>, "
"который не даёт команде <command>VACUUM</command> удалять записи, ставшие "
"недействительными недавно, что предотвращает конфликты очистки. При этом "
"следует учесть, что это вызывает задержку очистки мёртвых строк на ведущем, "
"что может привести к нежелательному распуханию таблицы. Тем не менее, в "
"итоге ситуация будет не хуже, чем если бы запросы к резервному серверу "
"исполнялись непосредственно на ведущем, но при этом сохранится положительный "
"эффект от разделения нагрузки. В случае, когда соединение резервных серверов "
"с ведущим часто разрывается, следует скорректировать период, в течение "
"которого обратная связь через <varname>hot_standby_feedback</varname> не "
"обеспечивается. Например, следует подумать об увеличении "
"<varname>max_standby_archive_delay</varname>, чтобы запросы отменялись не "
"сразу при конфликтах с архивом WAL в период разъединения. Также может иметь "
"смысл увеличить <varname>max_standby_streaming_delay</varname> для "
"предотвращения быстрой отмены запросов из-за полученных записей WAL после "
"восстановления соединения."

#: high-availability.xml:1997(para)
msgid ""
"Another option is to increase <xref linkend=\"guc-vacuum-defer-cleanup-age\"/"
"> on the primary server, so that dead rows will not be cleaned up as quickly "
"as they normally would be. This will allow more time for queries to execute "
"before they are canceled on the standby, without having to set a high "
"<varname>max_standby_streaming_delay</varname>. However it is difficult to "
"guarantee any specific execution-time window with this approach, since "
"<varname>vacuum_defer_cleanup_age</varname> is measured in transactions "
"executed on the primary server."
msgstr ""
"Другая возможность — увеличение <xref linkend=\"guc-vacuum-defer-cleanup-age"
"\"/> на ведущем сервере таким образом, чтобы мёртвые записи не очищались бы "
"так быстро, как при обычном режиме работы. Это даёт запросам на резервном "
"сервере больше времени на выполнение, прежде чем они могут быть отменены, "
"без увеличения задержки <varname>max_standby_streaming_delay</varname>. Тем "
"не менее при таком подходе очень трудно обеспечить какое-то определённое "
"окно по времени, так как <varname>vacuum_defer_cleanup_age</varname> "
"измеряется в количестве транзакций, выполняемых на ведущем сервере."

#: high-availability.xml:2008(para)
msgid ""
"The number of query cancels and the reason for them can be viewed using the "
"<structname>pg_stat_database_conflicts</structname> system view on the "
"standby server. The <structname>pg_stat_database</structname> system view "
"also contains summary information."
msgstr ""
"Количество отменённых запросов и причины отмены можно просмотреть через "
"системное представление <structname>pg_stat_database_conflicts</structname> "
"на резервном сервере. Системное представление <structname>pg_stat_database</"
"structname> так же содержит итоговую информацию."

#: high-availability.xml:2017(title)
msgid "Administrator's Overview"
msgstr "Обзор административной части"

#: high-availability.xml:2031(programlisting)
#, no-wrap
msgid ""
"LOG:  entering standby mode\n"
"\n"
"... then some time later ...\n"
"\n"
"LOG:  consistent recovery state reached\n"
"LOG:  database system is ready to accept read only connections"
msgstr ""
"LOG:  entering standby mode\n"
"\n"
"... then some time later ...\n"
"\n"
"LOG:  consistent recovery state reached\n"
"LOG:  database system is ready to accept read only connections"

#: high-availability.xml:2049(para)
msgid "A write transaction has more than 64 subtransactions"
msgstr "Пишущая транзакция имеет более 64 подтранзакций"

#: high-availability.xml:2054(para)
msgid "Very long-lived write transactions"
msgstr "Очень длительные пишущие транзакции"

#: high-availability.xml:2019(para)
msgid ""
"If <varname>hot_standby</varname> is turned <literal>on</literal> in "
"<filename>postgresql.conf</filename> and there is a <filename>recovery.conf</"
"filename> file present, the server will run in Hot Standby mode. However, it "
"may take some time for Hot Standby connections to be allowed, because the "
"server will not accept connections until it has completed sufficient "
"recovery to provide a consistent state against which queries can run. During "
"this period, clients that attempt to connect will be refused with an error "
"message. To confirm the server has come up, either loop trying to connect "
"from the application, or look for these messages in the server logs: "
"<placeholder-1/> Consistency information is recorded once per checkpoint on "
"the primary. It is not possible to enable hot standby when reading WAL "
"written during a period when <varname>wal_level</varname> was not set to "
"<literal>replica</literal> or <literal>logical</literal> on the primary. "
"Reaching a consistent state can also be delayed in the presence of both of "
"these conditions: <placeholder-2/> If you are running file-based log "
"shipping (\"warm standby\"), you might need to wait until the next WAL file "
"arrives, which could be as long as the <varname>archive_timeout</varname> "
"setting on the primary."
msgstr ""
"Если в файле <filename>postgresql.conf</filename> для параметра "
"<varname>hot_standby</varname> задано значение <literal>on</literal> и "
"существует файл <filename>recovery.conf</filename>, сервер запустится в "
"режиме горячего резерва. Однако может пройти некоторое время, прежде чем к "
"нему можно будет подключиться, так как он не будет принимать подключения, "
"пока не произведёт восстановление до согласованного состояния, подходящего "
"для выполнения запросов. (Информация о согласованности состояния "
"записывается на ведущем сервере в контрольной точке.) В течение этого "
"периода клиенты при попытке подключения будут получать сообщение об ошибке. "
"Убедиться, что сервер включился в работу, можно либо повторяя попытки "
"подключения из приложения до успешного подключения, либо дождавшись "
"появления в журналах сервера этих сообщений: <placeholder-1/> Включить "
"горячий резерв нельзя, если WAL был записан в период, когда на ведущем "
"сервере параметр <varname>wal_level</varname> имел значение не "
"<literal>replica</literal> и не <literal>logical</literal>. Достижение "
"согласованного состояния также может быть отсрочено, если имеют место оба "
"этих условия: <placeholder-2/> Если вы применяете файловую репликацию "
"журналов (&laquo;тёплый резерв&raquo;), возможно, придётся ожидать прибытия "
"следующего файла WAL (максимальное время ожидания задаётся параметром "
"<varname>archive_timeout</varname> на ведущем сервере)."

#: high-availability.xml:2077(varname)
msgid "max_connections"
msgstr "max_connections"

#: high-availability.xml:2082(varname)
msgid "max_prepared_transactions"
msgstr "max_prepared_transactions"

#: high-availability.xml:2087(varname)
msgid "max_locks_per_transaction"
msgstr "max_locks_per_transaction"

#: high-availability.xml:2092(varname)
msgid "max_worker_processes"
msgstr "max_worker_processes"

#: high-availability.xml:2065(para)
msgid ""
"The setting of some parameters on the standby will need reconfiguration if "
"they have been changed on the primary. For these parameters, the value on "
"the standby must be equal to or greater than the value on the primary. If "
"these parameters are not set high enough then the standby will refuse to "
"start. Higher values can then be supplied and the server restarted to begin "
"recovery again. These parameters are: <placeholder-1/>"
msgstr ""
"Значения некоторых параметров на резервном сервере необходимо изменить при "
"модификации их на ведущем. Для таких параметров значения на резервном "
"сервере должны быть равны или больше значений на ведущем. Если параметр "
"имеет недостаточно большое значение, резервный сервер не сможет начать "
"работу. Следует увеличить значение и повторить попытку восстановления ещё "
"раз. Это касается следующих параметров: <placeholder-1/>"

#: high-availability.xml:2098(para)
msgid ""
"It is important that the administrator select appropriate settings for <xref "
"linkend=\"guc-max-standby-archive-delay\"/> and <xref linkend=\"guc-max-"
"standby-streaming-delay\"/>. The best choices vary depending on business "
"priorities. For example if the server is primarily tasked as a High "
"Availability server, then you will want low delay settings, perhaps even "
"zero, though that is a very aggressive setting. If the standby server is "
"tasked as an additional server for decision support queries then it might be "
"acceptable to set the maximum delay values to many hours, or even -1 which "
"means wait forever for queries to complete."
msgstr ""
"Очень важно для администратора выбрать подходящие значения для <xref linkend="
"\"guc-max-standby-archive-delay\"/> и <xref linkend=\"guc-max-standby-"
"streaming-delay\"/>. Оптимальное значение зависит от приоритетов. Например, "
"если основное назначение сервера — обеспечение высокой степени доступности, "
"то следует установить короткий период, возможно даже нулевой, хотя это очень "
"жёсткий вариант. Если резервный сервер планируется как дополнительный сервер "
"для аналитических запросов, то приемлемой будет максимальная задержка в "
"несколько часов или даже -1, что означает бесконечное ожидание окончания "
"запроса."

#: high-availability.xml:2110(para)
msgid ""
"Transaction status \"hint bits\" written on the primary are not WAL-logged, "
"so data on the standby will likely re-write the hints again on the standby. "
"Thus, the standby server will still perform disk writes even though all "
"users are read-only; no changes occur to the data values themselves. Users "
"will still write large sort temporary files and re-generate relcache info "
"files, so no part of the database is truly read-only during hot standby "
"mode. Note also that writes to remote databases using <application>dblink</"
"application> module, and other operations outside the database using PL "
"functions will still be possible, even though the transaction is read-only "
"locally."
msgstr ""
"Вспомогательные биты статуса транзакций, записанные на ведущем, не попадают "
"в WAL, так что они, скорее всего, будут перезаписаны на нём при работе с "
"данными. Таким образом, резервный сервер будет производить запись на диск, "
"даже если все пользователи только читают данные, ничего не меняя. Кроме "
"того, пользователи будут записывать временные файлы при сортировке больших "
"объёмов и обновлять файлы кеша. Поэтому в режиме горячего резерва ни одна "
"часть базы данных фактически не работает в режиме &laquo;только "
"чтение&raquo;. Следует отметить, что также возможно выполнить запись в "
"удалённую базу данных с помощью модуля <application>dblink</application> и "
"другие операции вне базы данных с применением PL-функций, несмотря на то, "
"что транзакции по-прежнему смогут только читать данные."

#: high-availability.xml:2130(para)
msgid "Data Definition Language (DDL) - e.g. <command>CREATE INDEX</command>"
msgstr ""
"Команды определения данных (DDL) — например: <command>CREATE INDEX</command>"

#: high-availability.xml:2135(para)
msgid ""
"Privilege and Ownership - <command>GRANT</command>, <command>REVOKE</"
"command>, <command>REASSIGN</command>"
msgstr ""
"Команды выдачи привилегий и назначения владельца — <command>GRANT</command>, "
"<command>REVOKE</command>, <command>REASSIGN</command>"

#: high-availability.xml:2141(para)
msgid ""
"Maintenance commands - <command>ANALYZE</command>, <command>VACUUM</"
"command>, <command>CLUSTER</command>, <command>REINDEX</command>"
msgstr ""
"Команды обслуживания — <command>ANALYZE</command>, <command>VACUUM</"
"command>, <command>CLUSTER</command>, <command>REINDEX</command>"

#: high-availability.xml:2124(para)
msgid ""
"The following types of administration commands are not accepted during "
"recovery mode: <placeholder-1/>"
msgstr ""
"Следующие типы административных команд недоступны в течение режима "
"восстановления: <placeholder-1/>"

#: high-availability.xml:2149(para)
msgid ""
"Again, note that some of these commands are actually allowed during \"read "
"only\" mode transactions on the primary."
msgstr ""
"Ещё раз следует отметить, что некоторые из этих команд фактически доступны "
"на ведущем сервере для транзакций в режиме только для чтения."

#: high-availability.xml:2154(para)
msgid ""
"As a result, you cannot create additional indexes that exist solely on the "
"standby, nor statistics that exist solely on the standby. If these "
"administration commands are needed, they should be executed on the primary, "
"and eventually those changes will propagate to the standby."
msgstr ""
"В результате нельзя создать дополнительные индексы или статистику, чтобы они "
"существовали только на резервном. Если подобные административные команды "
"нужны, то их следует выполнить на ведущем сервере, затем эти изменения будут "
"распространены на резервные серверы."

#: high-availability.xml:2162(para)
msgid ""
"<function>pg_cancel_backend()</function> and "
"<function>pg_terminate_backend()</function> will work on user backends, but "
"not the Startup process, which performs recovery. "
"<structname>pg_stat_activity</structname> does not show an entry for the "
"Startup process, nor do recovering transactions show as active. As a result, "
"<structname>pg_prepared_xacts</structname> is always empty during recovery. "
"If you wish to resolve in-doubt prepared transactions, view "
"<literal>pg_prepared_xacts</literal> on the primary and issue commands to "
"resolve transactions there."
msgstr ""
"Функции <function>pg_cancel_backend()</function> и "
"<function>pg_terminate_backend()</function> работают на стороне "
"пользователя, но не для процесса запуска, который обеспечивает "
"восстановление. Представление <structname>pg_stat_activity</structname> не "
"показывает ни вхождение для процесса запуска, ни восстановление транзакций в "
"активном состоянии. В результате <structname>pg_prepared_xacts</structname> "
"всегда пусто в ходе восстановления. Если требуется разрешить сомнительные "
"подготовленные транзакции, следует обратиться к <literal>pg_prepared_xacts</"
"literal> на ведущем и выполнить команду для разрешения транзакции там."

#: high-availability.xml:2174(para)
msgid ""
"<structname>pg_locks</structname> will show locks held by backends, as "
"normal. <structname>pg_locks</structname> also shows a virtual transaction "
"managed by the Startup process that owns all <literal>AccessExclusiveLocks</"
"literal> held by transactions being replayed by recovery. Note that the "
"Startup process does not acquire locks to make database changes, and thus "
"locks other than <literal>AccessExclusiveLocks</literal> do not show in "
"<structname>pg_locks</structname> for the Startup process; they are just "
"presumed to exist."
msgstr ""
"<structname>pg_locks</structname> отображает блокировки, происходящие в "
"процессе работы сервера как обычно. <structname>pg_locks</structname> так же "
"показывает виртуальные транзакции, обработанные процессом запуска, которому "
"принадлежат все <literal>AccessExclusiveLocks</literal>, наложенные "
"транзакциями в режиме восстановления. Следует отметить, что процесс запуска "
"не запрашивает блокировки, чтобы внести изменения в базу данных, поэтому "
"блокировки, отличные от <literal>AccessExclusiveLocks</literal> не "
"показываются в <structname>pg_locks</structname> для процесса запуска, "
"подразумевается их существование."

#: high-availability.xml:2185(para)
msgid ""
"The <productname>Nagios</productname> plugin <productname>check_pgsql</"
"productname> will work, because the simple information it checks for exists. "
"The <productname>check_postgres</productname> monitoring script will also "
"work, though some reported values could give different or confusing results. "
"For example, last vacuum time will not be maintained, since no vacuum occurs "
"on the standby. Vacuums running on the primary do still send their changes "
"to the standby."
msgstr ""
"Модуль <productname>check_pgsql</productname> для <productname>Nagios</"
"productname> будет работать, так как сервер выдаёт простую информацию, "
"наличие которой он проверяет. Скрипт мониторинга "
"<productname>check_postgres</productname> так же работает, хотя для "
"некоторых выдаваемых показателей результаты могут различаться или вводить в "
"заблуждение. Например, нельзя отследить время последней очистки, так как "
"очистка не производится на резервном сервере. Очистка запускается на ведущем "
"сервере и результаты её работы передаются резервному."

#: high-availability.xml:2195(para)
msgid ""
"WAL file control commands will not work during recovery, e.g. "
"<function>pg_start_backup</function>, <function>pg_switch_xlog</function> "
"etc."
msgstr ""
"Команды контроля файлов WAL так же не будут работать во время "
"восстановления, например: <function>pg_start_backup</function>, "
"<function>pg_switch_xlog</function> и т. п."

#: high-availability.xml:2200(para)
msgid ""
"Dynamically loadable modules work, including <structname>pg_stat_statements</"
"structname>."
msgstr ""
"Динамически загружаемые модули работать будут, включая "
"<structname>pg_stat_statements</structname>."

#: high-availability.xml:2204(para)
msgid ""
"Advisory locks work normally in recovery, including deadlock detection. Note "
"that advisory locks are never WAL logged, so it is impossible for an "
"advisory lock on either the primary or the standby to conflict with WAL "
"replay. Nor is it possible to acquire an advisory lock on the primary and "
"have it initiate a similar advisory lock on the standby. Advisory locks "
"relate only to the server on which they are acquired."
msgstr ""
"Рекомендательная блокировка работает обычно при восстановлении, включая "
"обнаружение взаимных блокировок. Следует отметить, что рекомендательная "
"блокировка никогда не попадает в WAL, таким образом для рекомендательной "
"блокировки как на ведущем сервере, так и на резервном, невозможен конфликт с "
"проигрыванием WAL. Но возможно получение рекомендательной блокировки на "
"ведущем сервере, а затем получение подобной рекомендательной блокировки на "
"резервном. Рекомендательная блокировка относится только к серверу, на "
"котором она получена."

#: high-availability.xml:2213(para)
msgid ""
"Trigger-based replication systems such as <productname>Slony</productname>, "
"<productname>Londiste</productname> and <productname>Bucardo</productname> "
"won't run on the standby at all, though they will run happily on the primary "
"server as long as the changes are not sent to standby servers to be applied. "
"WAL replay is not trigger-based so you cannot relay from the standby to any "
"system that requires additional database writes or relies on the use of "
"triggers."
msgstr ""
"Системы репликации на базе триггеров, подобные <productname>Slony</"
"productname>, <productname>Londiste</productname> и <productname>Bucardo</"
"productname> не могут запускаться на резервном сервере вовсе, хотя они "
"превосходно работают на ведущем до тех пор, пока не будет подана команда не "
"пересылать изменения на резервный. Проигрывание WAL не основано на "
"триггерах, поэтому поток WAL нельзя транслировать с резервного сервера в "
"другую систему, которая требует дополнительной записи в БД или работает на "
"основе триггеров."

#: high-availability.xml:2223(para)
msgid ""
"New OIDs cannot be assigned, though some <acronym>UUID</acronym> generators "
"may still work as long as they do not rely on writing new status to the "
"database."
msgstr ""
"Новые OID не могут быть выданы, хотя, например генераторы <acronym>UUID</"
"acronym> смогут работать, если они не пытаются записывать новое состояние в "
"базу данных."

#: high-availability.xml:2228(para)
msgid ""
"Currently, temporary table creation is not allowed during read only "
"transactions, so in some cases existing scripts will not run correctly. This "
"restriction might be relaxed in a later release. This is both a SQL Standard "
"compliance issue and a technical issue."
msgstr ""
"В настоящий момент создание временных таблиц недопустимо при транзакции "
"только для чтения, в некоторых случаях существующий скрипт будет работать "
"неверно. Это ограничение может быть ослаблено в следующих выпусках. Это "
"одновременно требование SQL стандарта и техническое требование."

#: high-availability.xml:2235(para)
msgid ""
"<command>DROP TABLESPACE</command> can only succeed if the tablespace is "
"empty. Some standby users may be actively using the tablespace via their "
"<varname>temp_tablespaces</varname> parameter. If there are temporary files "
"in the tablespace, all active queries are canceled to ensure that temporary "
"files are removed, so the tablespace can be removed and WAL replay can "
"continue."
msgstr ""
"Команда <command>DROP TABLESPACE</command> может быть выполнена только если "
"табличное пространство пусто. Некоторые пользователи резервного сервера "
"могут активно использовать табличное пространство через параметр "
"<varname>temp_tablespaces</varname>. Если имеются временные файлы в "
"табличных пространствах, все активные запросы отменяются для обеспечения "
"удаления временных файлов, затем табличное пространство может быть удалено и "
"продолжено проигрывание WAL."

#: high-availability.xml:2244(para)
msgid ""
"Running <command>DROP DATABASE</command> or <command>ALTER DATABASE ... SET "
"TABLESPACE</command> on the primary will generate a WAL entry that will "
"cause all users connected to that database on the standby to be forcibly "
"disconnected. This action occurs immediately, whatever the setting of "
"<varname>max_standby_streaming_delay</varname>. Note that <command>ALTER "
"DATABASE ... RENAME</command> does not disconnect users, which in most cases "
"will go unnoticed, though might in some cases cause a program confusion if "
"it depends in some way upon database name."
msgstr ""
"Выполнение команды <command>DROP DATABASE</command> или <command>ALTER "
"DATABASE ... SET TABLESPACE</command> на ведущем сервере приводит к созданию "
"записи в WAL, которая вызывает принудительное отключение всех пользователей, "
"подключённых к этой базе данных на резервном. Это происходит немедленно, вне "
"зависимости от значения <varname>max_standby_streaming_delay</varname>. "
"Следует отметить, что команда <command>ALTER DATABASE ... RENAME</command> "
"не приводит к отключению пользователей, так что обычно она действует "
"незаметно, хотя в некоторых случаях возможны сбои программ, которые зависят "
"от имени базы данных."

#: high-availability.xml:2256(para)
msgid ""
"In normal (non-recovery) mode, if you issue <command>DROP USER</command> or "
"<command>DROP ROLE</command> for a role with login capability while that "
"user is still connected then nothing happens to the connected user - they "
"remain connected. The user cannot reconnect however. This behavior applies "
"in recovery also, so a <command>DROP USER</command> on the primary does not "
"disconnect that user on the standby."
msgstr ""
"Если вы в обычном режиме (не в режиме восстановления) выполните "
"<command>DROP USER</command> или <command>DROP ROLE</command> для роли с "
"возможностью подключения, в момент, когда этот пользователь подключён, на "
"данном пользователе это никак не отразится — он останется подключённым. "
"Однако переподключиться он уже не сможет. Это же поведение действует в "
"режиме восстановления — если выполнить <command>DROP USER</command> на "
"ведущем сервере, пользователь не будет отключён от резервного."

#: high-availability.xml:2264(para)
msgid ""
"The statistics collector is active during recovery. All scans, reads, "
"blocks, index usage, etc., will be recorded normally on the standby. "
"Replayed actions will not duplicate their effects on primary, so replaying "
"an insert will not increment the Inserts column of pg_stat_user_tables. The "
"stats file is deleted at the start of recovery, so stats from primary and "
"standby will differ; this is considered a feature, not a bug."
msgstr ""
"Сборщик статистики работает во время восстановления. Все операции "
"сканирования, чтения, блоки, использование индексов и т. п. будут записаны "
"обычным образом на резервном сервере. Действия, происходящие при "
"проигрывании, не будут дублировать действия на ведущем сервере, то есть "
"проигрывание команды вставки не увеличит значение столбца Inserts в "
"представлении pg_stat_user_tables. Файлы статистики удаляются с началом "
"восстановления, таким образом, статистика на ведущем сервере и резервном "
"будет разной. Это является особенностью, не ошибкой."

#: high-availability.xml:2273(para)
msgid ""
"Autovacuum is not active during recovery. It will start normally at the end "
"of recovery."
msgstr ""
"Автоматическая очистка не работает во время восстановления. Она запустится в "
"обычном режиме после завершения восстановления."

#: high-availability.xml:2278(para)
msgid ""
"The background writer is active during recovery and will perform "
"restartpoints (similar to checkpoints on the primary) and normal block "
"cleaning activities. This can include updates of the hint bit information "
"stored on the standby server. The <command>CHECKPOINT</command> command is "
"accepted during recovery, though it performs a restartpoint rather than a "
"new checkpoint."
msgstr ""
"Во время восстановления активен фоновый процесс записи, он обрабатывает "
"точки перезапуска (подобно контрольным точкам на ведущем сервере) и "
"выполняет обычную очистку блоков. В том числе он может обновлять "
"вспомогательные биты, сохранённые на резервном. Во время восстановления "
"принимается команда <command>CHECKPOINT</command>, но она производит точку "
"перезапуска, а не создаёт новую точку восстановления."

#: high-availability.xml:2289(title)
msgid "Hot Standby Parameter Reference"
msgstr "Ссылки на параметры горячего резерва"

#: high-availability.xml:2291(para)
msgid ""
"Various parameters have been mentioned above in <xref linkend=\"hot-standby-"
"conflict\"/> and <xref linkend=\"hot-standby-admin\"/>."
msgstr ""
"Различные параметры были упомянуты выше в <xref remap=\"6\" linkend=\"hot-"
"standby-conflict\"/> и <xref remap=\"6\" linkend=\"hot-standby-admin\"/>."

#: high-availability.xml:2297(para)
msgid ""
"On the primary, parameters <xref linkend=\"guc-wal-level\"/> and <xref "
"linkend=\"guc-vacuum-defer-cleanup-age\"/> can be used. <xref linkend=\"guc-"
"max-standby-archive-delay\"/> and <xref linkend=\"guc-max-standby-streaming-"
"delay\"/> have no effect if set on the primary."
msgstr ""
"На ведущем могут применяться параметры <xref linkend=\"guc-wal-level\"/> и "
"<xref linkend=\"guc-vacuum-defer-cleanup-age\"/>. Параметры <xref linkend="
"\"guc-max-standby-archive-delay\"/> и <xref linkend=\"guc-max-standby-"
"streaming-delay\"/> на ведущем не действуют."

#: high-availability.xml:2305(para)
msgid ""
"On the standby, parameters <xref linkend=\"guc-hot-standby\"/>, <xref "
"linkend=\"guc-max-standby-archive-delay\"/> and <xref linkend=\"guc-max-"
"standby-streaming-delay\"/> can be used. <xref linkend=\"guc-vacuum-defer-"
"cleanup-age\"/> has no effect as long as the server remains in standby mode, "
"though it will become relevant if the standby becomes primary."
msgstr ""
"На резервном сервере могут применяться параметры <xref linkend=\"guc-hot-"
"standby\"/>, <xref linkend=\"guc-max-standby-archive-delay\"/> и <xref "
"linkend=\"guc-max-standby-streaming-delay\"/>. Параметр <xref linkend=\"guc-"
"vacuum-defer-cleanup-age\"/> на нём не действует, пока сервер остаётся в "
"режиме резервного сервера. Но если он станет ведущим, его значение вступит в "
"силу."

#: high-availability.xml:2316(title)
msgid "Caveats"
msgstr "Ограничения"

#: high-availability.xml:2324(para)
msgid ""
"Operations on hash indexes are not presently WAL-logged, so replay will not "
"update these indexes."
msgstr ""
"Операции с хеш-индексами в настоящее время не проходят через журнал WAL, "
"таким образом, при воспроизведении WAL эти индексы не обновляются."

#: high-availability.xml:2330(para)
msgid ""
"Full knowledge of running transactions is required before snapshots can be "
"taken. Transactions that use large numbers of subtransactions (currently "
"greater than 64) will delay the start of read only connections until the "
"completion of the longest running write transaction. If this situation "
"occurs, explanatory messages will be sent to the server log."
msgstr ""
"Требуется информация о всех запущенных транзакциях перед тем как будет "
"создан снимок данных. Транзакции, использующие большое количество "
"подтранзакций (в настоящий момент больше 64), будут задерживать начало "
"соединения только для чтения до завершения самой длинной пишущей транзакции. "
"При возникновении этой ситуации поясняющее сообщение будет записано в журнал "
"сервера."

#: high-availability.xml:2339(para)
msgid ""
"Valid starting points for standby queries are generated at each checkpoint "
"on the master. If the standby is shut down while the master is in a shutdown "
"state, it might not be possible to re-enter Hot Standby until the primary is "
"started up, so that it generates further starting points in the WAL logs. "
"This situation isn't a problem in the most common situations where it might "
"happen. Generally, if the primary is shut down and not available anymore, "
"that's likely due to a serious failure that requires the standby being "
"converted to operate as the new primary anyway. And in situations where the "
"primary is being intentionally taken down, coordinating to make sure the "
"standby becomes the new primary smoothly is also standard procedure."
msgstr ""
"Подходящие стартовые точки для запросов на резервном сервере создаются при "
"каждой контрольной точке на главном. Если резервный сервер отключается, в то "
"время как главный был в отключённом состоянии, может оказаться невозможным "
"возобновить его работу в режиме горячего резерва, до того, как запустится "
"ведущий и добавит следующие стартовые точки в журналы WAL. Подобная ситуация "
"не является проблемой для большинства случаев, в которых она может "
"произойти. Обычно, если ведущий сервер выключен и больше не доступен, это "
"является следствием серьёзного сбоя и в любом случае требует преобразования "
"резервного в новый ведущий. Так же в ситуации, когда ведущий отключён "
"намеренно, проверка готовности резервного к преобразованию в ведущий тоже "
"является обычной процедурой."

#: high-availability.xml:2354(para)
msgid ""
"At the end of recovery, <literal>AccessExclusiveLocks</literal> held by "
"prepared transactions will require twice the normal number of lock table "
"entries. If you plan on running either a large number of concurrent prepared "
"transactions that normally take <literal>AccessExclusiveLocks</literal>, or "
"you plan on having one large transaction that takes many "
"<literal>AccessExclusiveLocks</literal>, you are advised to select a larger "
"value of <varname>max_locks_per_transaction</varname>, perhaps as much as "
"twice the value of the parameter on the primary server. You need not "
"consider this at all if your setting of <varname>max_prepared_transactions</"
"varname> is 0."
msgstr ""
"В конце восстановления блокировки <literal>AccessExclusiveLocks</literal>, "
"вызванные подготовленными транзакциями, требуют удвоенное, в сравнении с "
"нормальным, количество блокировок записей таблицы. Если планируется "
"использовать либо большое количество конкурирующих подготовленных "
"транзакций, обычно вызывающие <literal>AccessExclusiveLocks</literal>, либо "
"большие транзакции с применением большого количества "
"<literal>AccessExclusiveLocks</literal>, то рекомендуется выбрать большое "
"значение параметра <varname>max_locks_per_transaction</varname>, возможно в "
"два раза большее, чем значение параметра на ведущем сервере. Всё это не "
"имеет значения, когда <varname>max_prepared_transactions</varname> равно 0."

#: high-availability.xml:2367(para)
msgid ""
"The Serializable transaction isolation level is not yet available in hot "
"standby. (See <xref linkend=\"xact-serializable\"/> and <xref linkend="
"\"serializable-consistency\"/> for details.) An attempt to set a transaction "
"to the serializable isolation level in hot standby mode will generate an "
"error."
msgstr ""
"Уровень изоляции транзакции Serializable в настоящее время недоступен в "
"горячем резерве. (За подробностями обратитесь к <xref remap=\"3\" linkend="
"\"xact-serializable\"/> и <xref remap=\"3\" linkend=\"serializable-"
"consistency\"/>) Попытка выставить для транзакции такой уровень изоляции в "
"режиме горячего резерва вызовет ошибку."

#: high-availability.xml:2318(para)
msgid ""
"There are several limitations of Hot Standby. These can and probably will be "
"fixed in future releases: <placeholder-1/>"
msgstr ""
"Имеются следующие ограничения горячего резерва. Они могут и скорее всего "
"будут исправлены в следующих выпусках: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: high-availability.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
