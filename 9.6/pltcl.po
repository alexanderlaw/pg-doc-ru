# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-02-06 11:18+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: pltcl.xml:5(title)
msgid "PL/Tcl - Tcl Procedural Language"
msgstr "PL/Tcl — процедурный язык Tcl"

#: pltcl.xml:7(indexterm)
msgid "<primary>PL/Tcl</primary>"
msgstr "<primary>PL/Tcl</primary>"

#: pltcl.xml:11(indexterm)
msgid "<primary>Tcl</primary>"
msgstr "<primary>Tcl</primary>"

#: pltcl.xml:15(para)
msgid ""
"PL/Tcl is a loadable procedural language for the <productname>PostgreSQL</"
"productname> database system that enables the <ulink url=\"http://www.tcl.tk/"
"\"> Tcl language</ulink> to be used to write functions and trigger "
"procedures."
msgstr ""
"PL/Tcl — это загружаемый процедурный язык для СУБД <productname>PostgreSQL</"
"productname>, позволяющий использовать <ulink url=\"http://www.tcl.tk/"
"\">язык Tcl</ulink> для написания функций и триггерных процедур."

#: pltcl.xml:26(title)
msgid "Overview"
msgstr "Обзор"

#: pltcl.xml:28(para)
msgid ""
"PL/Tcl offers most of the capabilities a function writer has in the C "
"language, with a few restrictions, and with the addition of the powerful "
"string processing libraries that are available for Tcl."
msgstr ""
"PL/Tcl предоставляет большинство возможностей, которые имеет разработчик "
"функций на C, с небольшими ограничениями, и позволяет применять мощные "
"библиотеки обработки строк, существующие для Tcl."

#: pltcl.xml:34(para)
msgid ""
"One compelling <emphasis>good</emphasis> restriction is that everything is "
"executed from within the safety of the context of a Tcl interpreter. In "
"addition to the limited command set of safe Tcl, only a few commands are "
"available to access the database via SPI and to raise messages via "
"<function>elog()</function>. PL/Tcl provides no way to access internals of "
"the database server or to gain OS-level access under the permissions of the "
"<productname>PostgreSQL</productname> server process, as a C function can "
"do. Thus, unprivileged database users can be trusted to use this language; "
"it does not give them unlimited authority."
msgstr ""
"Одним убедительным <emphasis>хорошим</emphasis> ограничением является то, "
"что весь код выполняется в контексте безопасности интерпретатора Tcl. Помимо "
"ограниченного набора команд безопасного Tcl, разрешены только несколько "
"команд для обращения к базе данных через SPI и вызовы <function>elog()</"
"function> для выдачи сообщений. PL/Tcl не даёт возможности взаимодействовать "
"с внутренним механизмом сервера баз данных или обращаться к ОС с правами "
"серверного процесса <productname>PostgreSQL</productname>, что возможно в "
"функциях на C. Таким образом, использование этого языка можно доверить "
"непривилегированным пользователям; это не даст им неограниченные полномочия."

#: pltcl.xml:46(para)
msgid ""
"The other notable implementation restriction is that Tcl functions cannot be "
"used to create input/output functions for new data types."
msgstr ""
"Ещё одно существенное ограничение заключается в том, что функции на Tcl "
"нельзя использовать для создания функций ввода/вывода для новых типов данных."

#: pltcl.xml:51(para)
msgid ""
"Sometimes it is desirable to write Tcl functions that are not restricted to "
"safe Tcl. For example, one might want a Tcl function that sends email. To "
"handle these cases, there is a variant of <application>PL/Tcl</application> "
"called <literal>PL/TclU</literal> (for untrusted Tcl). This is exactly the "
"same language except that a full Tcl interpreter is used. <emphasis>If "
"<application>PL/TclU</application> is used, it must be installed as an "
"untrusted procedural language</emphasis> so that only database superusers "
"can create functions in it. The writer of a <application>PL/TclU</"
"application> function must take care that the function cannot be used to do "
"anything unwanted, since it will be able to do anything that could be done "
"by a user logged in as the database administrator."
msgstr ""
"Иногда возникает желание написать функцию на Tcl, которая не будут "
"ограничена безопасным Tcl. Например, может потребоваться функция, которая "
"будет посылать сообщения по почте. Для этих случаев есть вариация "
"<application>PL/Tcl</application>, названная <literal>PL/TclU</literal> "
"(название подразумевает &laquo;untrusted Tcl&raquo;, недоверенный Tcl). Это "
"тот же язык, за исключением того, что для него используется полноценный "
"интерпретатор Tcl. <emphasis>Если применяется <application>PL/TclU</"
"application>, он должен быть установлен как недоверенный процедурный язык</"
"emphasis>, чтобы только суперпользователи могли создавать функции на нём. "
"Автор функции на <application>PL/TclU</application> должен позаботиться о "
"том, чтобы эту функцию нельзя было использовать не по назначению, так как "
"она может делать всё, что может пользователь с правами администратора баз "
"данных."

#: pltcl.xml:63(para)
msgid ""
"The shared object code for the <application>PL/Tcl</application> and "
"<application>PL/TclU</application> call handlers is automatically built and "
"installed in the <productname>PostgreSQL</productname> library directory if "
"Tcl support is specified in the configuration step of the installation "
"procedure. To install <application>PL/Tcl</application> and/or "
"<application>PL/TclU</application> in a particular database, use the "
"<command>CREATE EXTENSION</command> command or the <command>createlang</"
"command> program, for example <literal>createlang pltcl <replaceable>dbname</"
"replaceable></literal> or <literal>createlang pltclu <replaceable>dbname</"
"replaceable></literal>."
msgstr ""
"Разделяемый объектный код для обработчиков вызова <application>PL/Tcl</"
"application> и <application>PL/TclU</application> собирается автоматически и "
"устанавливается в каталог библиотек <productname>PostgreSQL</productname>, "
"если поддержка Tcl включена на этапе конфигурирования процедуры установки. "
"Чтобы установить <application>PL/Tcl</application> и/или <application>PL/"
"TclU</application> в конкретную базу данных, воспользуйтесь командой "
"<command>CREATE EXTENSION</command> или программой <command>createlang</"
"command>, например, так: <literal>createlang pltcl <replaceable>имя_базы</"
"replaceable></literal> или <literal>createlang pltclu <replaceable>имя_базы</"
"replaceable></literal>."

#: pltcl.xml:80(title)
msgid "PL/Tcl Functions and Arguments"
msgstr "Функции на PL/Tcl и их аргументы"

#: pltcl.xml:86(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$\n"
"    # PL/Tcl function body\n"
"$$ LANGUAGE pltcl;"
msgstr ""
"CREATE FUNCTION <replaceable>имя_функции</replaceable> (<replaceable>типы_аргументов</replaceable>) RETURNS <replaceable>тип_результата</replaceable> AS $$\n"
"    # Тело функции на PL/Tcl\n"
"$$ LANGUAGE pltcl;"

#: pltcl.xml:82(para)
msgid ""
"To create a function in the <application>PL/Tcl</application> language, use "
"the standard <xref linkend=\"sql-createfunction\"/> syntax: <placeholder-1/> "
"<application>PL/TclU</application> is the same, except that the language has "
"to be specified as <literal>pltclu</literal>."
msgstr ""
"Чтобы создать функцию на языке <application>PL/Tcl</application>, "
"используйте стандартный синтаксис <xref linkend=\"sql-createfunction\"/>: "
"<placeholder-1/> С <application>PL/TclU</application> команда та же, но в "
"качестве языка должно быть указано <literal>pltclu</literal>."

#: pltcl.xml:96(para)
msgid ""
"The body of the function is simply a piece of Tcl script. When the function "
"is called, the argument values are passed as variables <literal>$1</"
"literal> ... <literal>$<replaceable>n</replaceable></literal> to the Tcl "
"script. The result is returned from the Tcl code in the usual way, with a "
"<literal>return</literal> statement."
msgstr ""
"Тело функции содержит просто скрипт на Tcl. Когда вызывается функция, "
"значения аргументов передаются скрипту Tcl в виде переменных <literal>$1</"
"literal> ... <literal>$<replaceable>n</replaceable></literal>. Результат из "
"кода Tcl возвращается как обычно, оператором <literal>return</literal>."

#: pltcl.xml:109(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n"
"    if {$1 &gt; $2} {return $1}\n"
"    return $2\n"
"$$ LANGUAGE pltcl STRICT;"
msgstr ""
"CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n"
"    if {$1 &gt; $2} {return $1}\n"
"    return $2\n"
"$$ LANGUAGE pltcl STRICT;"

#: pltcl.xml:105(para)
msgid ""
"For example, a function returning the greater of two integer values could be "
"defined as: <placeholder-1/> Note the clause <literal>STRICT</literal>, "
"which saves us from having to think about null input values: if a null value "
"is passed, the function will not be called at all, but will just return a "
"null result automatically."
msgstr ""
"Например, функцию, возвращающую большее из двух целых чисел, можно "
"определить так: <placeholder-1/> Обратите внимание на предложение "
"<literal>STRICT</literal>, которое избавляет нас от необходимости думать о "
"входящих значениях NULL: если при вызове передаётся значение NULL, функция "
"не будет выполняться вовсе, будет сразу возвращён результат NULL."

#: pltcl.xml:131(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n"
"    if {[argisnull 1]} {\n"
"        if {[argisnull 2]} { return_null }\n"
"        return $2\n"
"    }\n"
"    if {[argisnull 2]} { return $1 }\n"
"    if {$1 &gt; $2} {return $1}\n"
"    return $2\n"
"$$ LANGUAGE pltcl;"
msgstr ""
"CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n"
"    if {[argisnull 1]} {\n"
"        if {[argisnull 2]} { return_null }\n"
"        return $2\n"
"    }\n"
"    if {[argisnull 2]} { return $1 }\n"
"    if {$1 &gt; $2} {return $1}\n"
"    return $2\n"
"$$ LANGUAGE pltcl;"

#: pltcl.xml:122(para)
msgid ""
"In a nonstrict function, if the actual value of an argument is null, the "
"corresponding <literal>$<replaceable>n</replaceable></literal> variable will "
"be set to an empty string. To detect whether a particular argument is null, "
"use the function <literal>argisnull</literal>. For example, suppose that we "
"wanted <function>tcl_max</function> with one null and one nonnull argument "
"to return the nonnull argument, rather than null: <placeholder-1/>"
msgstr ""
"В нестрогой функции, если фактическое значение аргумента — NULL, "
"соответствующей переменной <literal>$<replaceable>n</replaceable></literal> "
"будет присвоена пустая строка. Чтобы определить, был ли передан NULL в "
"определённом аргументе, используйте функцию <literal>argisnull</literal>. "
"Например, предположим, что нам нужна функция <function>tcl_max</function>, "
"которая с одним аргументом NULL и вторым аргументом не NULL должна "
"возвращать не NULL, а второй аргумент: <placeholder-1/>"

#: pltcl.xml:144(para)
msgid ""
"As shown above, to return a null value from a PL/Tcl function, execute "
"<literal>return_null</literal>. This can be done whether the function is "
"strict or not."
msgstr ""
"Как показано выше, чтобы вернуть значение NULL из функции PL/Tcl, нужно "
"выполнить <literal>return_null</literal>. Это можно сделать и в строгой, и в "
"нестрогой функции."

#: pltcl.xml:157(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE employee (\n"
"    name text,\n"
"    salary integer,\n"
"    age integer\n"
");\n"
"\n"
"CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$\n"
"    if {200000.0 &lt; $1(salary)} {\n"
"        return \"t\"\n"
"    }\n"
"    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {\n"
"        return \"t\"\n"
"    }\n"
"    return \"f\"\n"
"$$ LANGUAGE pltcl;"
msgstr ""
"CREATE TABLE employee (\n"
"    name text,\n"
"    salary integer,\n"
"    age integer\n"
");\n"
"\n"
"CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$\n"
"    if {200000.0 &lt; $1(salary)} {\n"
"        return \"t\"\n"
"    }\n"
"    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {\n"
"        return \"t\"\n"
"    }\n"
"    return \"f\"\n"
"$$ LANGUAGE pltcl;"

#: pltcl.xml:151(para)
msgid ""
"Composite-type arguments are passed to the function as Tcl arrays. The "
"element names of the array are the attribute names of the composite type. If "
"an attribute in the passed row has the null value, it will not appear in the "
"array. Here is an example: <placeholder-1/>"
msgstr ""
"Аргументы составного типа передаются функции в виде массивов Tcl. Именами "
"элементов массива являются имена атрибутов составного типа. Если атрибут в "
"переданной строке имеет значение NULL, он будет отсутствовать в данном "
"массиве. Например: <placeholder-1/>"

#: pltcl.xml:176(para)
msgid ""
"There is currently no support for returning a composite-type result value, "
"nor for returning sets."
msgstr ""
"В настоящее время возврат результатов составного типа не поддерживается, как "
"и возврат множеств."

#: pltcl.xml:181(para)
msgid ""
"<application>PL/Tcl</application> does not currently have full support for "
"domain types: it treats a domain the same as the underlying scalar type. "
"This means that constraints associated with the domain will not be enforced. "
"This is not an issue for function arguments, but it is a hazard if you "
"declare a <application>PL/Tcl</application> function as returning a domain "
"type."
msgstr ""
"<application>PL/Tcl</application> в настоящее время не поддерживает "
"полностью доменные типы: он воспринимает домен как нижележащий скалярный "
"тип. Это означает, что ограничения, связанные с доменом, не будут "
"действовать. Это не проблема для аргументов функции, но представляет "
"опасность, когда функция <application>PL/Tcl</application> объявлена как "
"возвращающая доменный тип."

#: pltcl.xml:193(title)
msgid "Data Values in PL/Tcl"
msgstr "Значения данных в PL/Tcl"

#: pltcl.xml:195(para)
msgid ""
"The argument values supplied to a PL/Tcl function's code are simply the "
"input arguments converted to text form (just as if they had been displayed "
"by a <command>SELECT</command> statement). Conversely, the <literal>return</"
"literal> command will accept any string that is acceptable input format for "
"the function's declared return type. So, within the PL/Tcl function, all "
"values are just text strings."
msgstr ""
"Значения аргументов, передаваемые в код функции PL/Tcl, представляют собой "
"просто входные аргументы, преобразованные в текстовый вид (так же, как при "
"выводе оператором <command>SELECT</command>). И наоборот, команда "
"<literal>return</literal> может принять любую строку, соответствующую "
"формату ввода для типа результата функции. Таким образом, внутри функции PL/"
"Tcl все значения представляют собой просто текстовые строки."

#: pltcl.xml:208(title)
msgid "Global Data in PL/Tcl"
msgstr "Глобальные данные в PL/Tcl"

#: pltcl.xml:210(indexterm)
msgid "<primary>global data</primary> <secondary>in PL/Tcl</secondary>"
msgstr "<primary>глобальные данные</primary> <secondary>в PL/Tcl</secondary>"

#: pltcl.xml:215(para)
msgid ""
"Sometimes it is useful to have some global data that is held between two "
"calls to a function or is shared between different functions. This is easily "
"done in PL/Tcl, but there are some restrictions that must be understood."
msgstr ""
"Иногда полезно иметь некоторые глобальные данные, сохраняемые между двумя "
"вызовами функции или совместно используемые разными функциями. Это легко "
"сделать в PL/Tcl, но есть некоторые ограничения, которые необходимо понимать."

#: pltcl.xml:223(para)
msgid ""
"For security reasons, PL/Tcl executes functions called by any one SQL role "
"in a separate Tcl interpreter for that role. This prevents accidental or "
"malicious interference by one user with the behavior of another user's PL/"
"Tcl functions. Each such interpreter will have its own values for any "
"<quote>global</quote> Tcl variables. Thus, two PL/Tcl functions will share "
"the same global variables if and only if they are executed by the same SQL "
"role. In an application wherein a single session executes code under "
"multiple SQL roles (via <literal>SECURITY DEFINER</literal> functions, use "
"of <command>SET ROLE</command>, etc) you may need to take explicit steps to "
"ensure that PL/Tcl functions can share data. To do that, make sure that "
"functions that should communicate are owned by the same user, and mark them "
"<literal>SECURITY DEFINER</literal>. You must of course take care that such "
"functions can't be used to do anything unintended."
msgstr ""
"По соображениям безопасности, PL/Tcl выполняет функции, вызываемые некоторой "
"ролью SQL в отдельном интерпретаторе Tcl, выделенном для этой роли. Это "
"предотвращает случайное или злонамеренное влияние одного пользователя на "
"поведение функций PL/Tcl другого пользователя. В каждом интерпретаторе будут "
"свои значения всех <quote>глобальных</quote> переменных Tcl. Таким образом, "
"в двух функциях PL/Tcl будут общие глобальные переменные, только если они "
"выполняются одной ролью SQL. В приложении, выполняющем код в одном сеансе с "
"разными ролями SQL (вызывающем функции <literal>SECURITY DEFINER</literal>, "
"использующем команду <command>SET ROLE</command> и т. д.) может понадобиться "
"явно предпринять дополнительные меры, чтобы функции могли разделять свои "
"данные. Для этого сначала установите для функций, которые должны "
"взаимодействовать, одного владельца, а затем задайте для них свойство "
"<literal>SECURITY DEFINER</literal>. Разумеется, при этом нужно позаботиться "
"о том, чтобы эти функции не могли сделать ничего непредусмотренного."

#: pltcl.xml:240(para)
msgid ""
"All PL/TclU functions used in a session execute in the same Tcl interpreter, "
"which of course is distinct from the interpreter(s) used for PL/Tcl "
"functions. So global data is automatically shared between PL/TclU functions. "
"This is not considered a security risk because all PL/TclU functions execute "
"at the same trust level, namely that of a database superuser."
msgstr ""
"Все функции PL/TclU, вызываемые в одном сеансе, выполняются одним "
"интерпретатором Tcl, который, конечно, отличается от интерпретатора(ов), "
"используемого для функций PL/Tcl. Поэтому глобальные данные функций PL/TclU "
"автоматически становятся общими. Это не считается угрозой безопасности, так "
"как все функции PL/TclU выполняются на одном уровне доверия, а именно уровне "
"суперпользователя базы данных."

#: pltcl.xml:249(para)
msgid ""
"To help protect PL/Tcl functions from unintentionally interfering with each "
"other, a global array is made available to each function via the "
"<function>upvar</function> command. The global name of this variable is the "
"function's internal name, and the local name is <literal>GD</literal>. It is "
"recommended that <literal>GD</literal> be used for persistent private data "
"of a function. Use regular Tcl global variables only for values that you "
"specifically intend to be shared among multiple functions. (Note that the "
"<literal>GD</literal> arrays are only global within a particular "
"interpreter, so they do not bypass the security restrictions mentioned "
"above.)"
msgstr ""
"Чтобы защитить функции PL/Tcl от непреднамеренного влияния друг на друга, "
"каждой из них предоставляется глобальная переменная-массив через команду "
"<function>upvar</function>. Глобальным именем этой переменной является "
"внутреннее имя функции, а в качестве локального выбрано <literal>GD</"
"literal>. Переменную <literal>GD</literal> рекомендуется использовать для "
"постоянных внутренних данных функции. Обычные глобальные переменные Tcl "
"следует использовать только для значений, которые предназначены именно для "
"совместного использования несколькими функциями. (Заметьте, что массивы "
"<literal>GD</literal> являются глобальными только для конкретного "
"интерпретатора, так что они не нарушают ограничения безопасности, описанные "
"выше.)"

#: pltcl.xml:263(para)
msgid ""
"An example of using <literal>GD</literal> appears in the "
"<function>spi_execp</function> example below."
msgstr ""
"Использование <literal>GD</literal> демонстрируется в примере "
"<function>spi_execp</function>, приведённом ниже."

#: pltcl.xml:270(title)
msgid "Database Access from PL/Tcl"
msgstr "Обращение к базе данных из PL/Tcl"

#: pltcl.xml:279(function)
msgid "spi_exec"
msgstr "spi_exec"

#: pltcl.xml:279(replaceable) pltcl.xml:371(replaceable)
msgid "n"
msgstr "n"

#: pltcl.xml:279(optional) pltcl.xml:371(optional)
msgid "-count <placeholder-1/>"
msgstr "-count <placeholder-1/>"

#: pltcl.xml:279(replaceable) pltcl.xml:371(replaceable)
msgid "name"
msgstr "имя"

#: pltcl.xml:279(optional) pltcl.xml:371(optional)
msgid "-array <placeholder-1/>"
msgstr "-array <placeholder-1/>"

#: pltcl.xml:279(replaceable)
msgid "command"
msgstr "команда"

#: pltcl.xml:279(replaceable) pltcl.xml:371(replaceable)
msgid "loop-body"
msgstr "тело-цикла"

#: pltcl.xml:281(para)
msgid ""
"Executes an SQL command given as a string. An error in the command causes an "
"error to be raised. Otherwise, the return value of <function>spi_exec</"
"function> is the number of rows processed (selected, inserted, updated, or "
"deleted) by the command, or zero if the command is a utility statement. In "
"addition, if the command is a <command>SELECT</command> statement, the "
"values of the selected columns are placed in Tcl variables as described "
"below."
msgstr ""
"Выполняет команду SQL, заданную в виде строки. В случае ошибки в этой "
"команде выдаётся ошибка в Tcl. В противном случае <function>spi_exec</"
"function> возвращает число обработанных командой строк (выбранных, "
"добавленных, изменённых или удалённых), либо ноль, если эта команда — "
"служебный оператор. Кроме того, если команда — оператор <command>SELECT</"
"command>, значения выбранных столбцов помещаются в переменные Tcl, как "
"описано ниже."

#: pltcl.xml:290(para)
msgid ""
"The optional <literal>-count</literal> value tells <function>spi_exec</"
"function> the maximum number of rows to process in the command. The effect "
"of this is comparable to setting up a query as a cursor and then saying "
"<literal>FETCH <replaceable>n</replaceable></literal>."
msgstr ""
"Необязательное значение <literal>-count</literal> задаёт для "
"<function>spi_exec</function> максимальное число строк, которое должно быть "
"обработано в команде. Его действие можно представить как выполнение "
"<literal>FETCH <replaceable>n</replaceable></literal> для курсора, "
"предварительно подготовленного для команды."

#: pltcl.xml:296(para)
msgid ""
"If the command is a <command>SELECT</command> statement, the values of the "
"result columns are placed into Tcl variables named after the columns. If the "
"<literal>-array</literal> option is given, the column values are instead "
"stored into elements of the named associative array, with the column names "
"used as array indexes. In addition, the current row number within the result "
"(counting from zero) is stored into the array element named <quote><literal>."
"tupno</literal></quote>, unless that name is in use as a column name in the "
"result."
msgstr ""
"Если в качестве команды выполняется оператор <command>SELECT</command>, "
"значения результирующих столбцов помещаются в переменные Tcl, названные по "
"именам столбцов. Если передаётся <literal>-array</literal>, значения "
"столбцов вместо этого становятся элементами названного ассоциативного "
"массива, индексами в котором становятся имена столбцов. Кроме того, в "
"элементе с именем <quote><literal>.tupno</literal></quote> сохраняется номер "
"текущей строки в результирующем наборе (отсчитывая от нуля), если только это "
"имя не занято одним из столбцов результата."

#: pltcl.xml:313(programlisting)
#, no-wrap
msgid "spi_exec \"SELECT count(*) AS cnt FROM pg_proc\""
msgstr "spi_exec \"SELECT count(*) AS cnt FROM pg_proc\""

#: pltcl.xml:306(para)
msgid ""
"If the command is a <command>SELECT</command> statement and no "
"<replaceable>loop-body</replaceable> script is given, then only the first "
"row of results are stored into Tcl variables or array elements; remaining "
"rows, if any, are ignored. No storing occurs if the query returns no rows. "
"(This case can be detected by checking the result of <function>spi_exec</"
"function>.) For example: <placeholder-1/> will set the Tcl variable <literal>"
"$cnt</literal> to the number of rows in the <structname>pg_proc</structname> "
"system catalog."
msgstr ""
"Если в качестве команды выполняется <command>SELECT</command> без указания "
"скрипта <replaceable>тело-цикла</replaceable>, в переменных Tcl или "
"элементах массива сохраняется только первая строка результатов; оставшиеся "
"строки (если они есть), игнорируются. Если запрос не возвращает строки, не "
"сохраняется ничего. (Этот случай можно отследить, проверив результат "
"<function>spi_exec</function>.) Например, команда: <placeholder-1/> присвоит "
"переменной <literal>$cnt</literal> в Tcl число строк, содержащихся в "
"системном каталоге <structname>pg_proc</structname>."

#: pltcl.xml:327(programlisting)
#, no-wrap
msgid ""
"spi_exec -array C \"SELECT * FROM pg_class\" {\n"
"    elog DEBUG \"have table $C(relname)\"\n"
"}"
msgstr ""
"spi_exec -array C \"SELECT * FROM pg_class\" {\n"
"    elog DEBUG \"have table $C(relname)\"\n"
"}"

#: pltcl.xml:319(para)
msgid ""
"If the optional <replaceable>loop-body</replaceable> argument is given, it "
"is a piece of Tcl script that is executed once for each row in the query "
"result. (<replaceable>loop-body</replaceable> is ignored if the given "
"command is not a <command>SELECT</command>.) The values of the current row's "
"columns are stored into Tcl variables or array elements before each "
"iteration. For example: <placeholder-1/> will print a log message for every "
"row of <literal>pg_class</literal>. This feature works similarly to other "
"Tcl looping constructs; in particular <literal>continue</literal> and "
"<literal>break</literal> work in the usual way inside the loop body."
msgstr ""
"Если передаётся необязательный аргумент <replaceable>тело-цикла</"
"replaceable>, заданный в нём блок скрипта Tcl будет выполняться для каждой "
"строки результата запроса. (Аргумент <replaceable>тело-цикла</replaceable> "
"игнорируется, если целевая команда — не <command>SELECT</command>.) При этом "
"значения столбцов текущей строки сохраняются в переменных Tcl или элементах "
"массива перед каждой итерацией этого цикла. Например, код: <placeholder-1/> "
"будет выводить в журнал сообщение для каждой строки <literal>pg_class</"
"literal>. Это работает подобно другим конструкциям циклов в Tcl; в "
"частности, команды <literal>continue</literal> и <literal>break</literal> в "
"теле цикла будут действовать обычным образом."

#: pltcl.xml:337(para)
msgid ""
"If a column of a query result is null, the target variable for it is "
"<quote>unset</quote> rather than being set."
msgstr ""
"Если в столбце результата запроса выдаётся NULL, целевая переменная для неё "
"не устанавливается, и оказывается <quote>неустановленной</quote>."

#: pltcl.xml:345(function)
msgid "spi_prepare"
msgstr "spi_prepare"

#: pltcl.xml:345(replaceable)
msgid "query"
msgstr "запрос"

#: pltcl.xml:345(replaceable)
msgid "typelist"
msgstr "список-типов"

#: pltcl.xml:350(indexterm)
msgid "<primary>preparing a query</primary> <secondary>in PL/Tcl</secondary>"
msgstr "<primary>подготовка запроса</primary> <secondary>в PL/Tcl</secondary>"

#: pltcl.xml:347(para)
msgid ""
"Prepares and saves a query plan for later execution. The saved plan will be "
"retained for the life of the current session.<placeholder-1/>"
msgstr ""
"Подготавливает и сохраняет план запроса для последующего выполнения. "
"Сохранённый план будет продолжать существование до завершения текущего "
"сеанса.<placeholder-1/>"

#: pltcl.xml:353(para)
msgid ""
"The query can use parameters, that is, placeholders for values to be "
"supplied whenever the plan is actually executed. In the query string, refer "
"to parameters by the symbols <literal>$1</literal> ... <literal>"
"$<replaceable>n</replaceable></literal>. If the query uses parameters, the "
"names of the parameter types must be given as a Tcl list. (Write an empty "
"list for <replaceable>typelist</replaceable> if no parameters are used.)"
msgstr ""
"Запрос может принимать параметры, то есть местозаполнители для значений, "
"которые будут передаваться, когда план будет собственно выполняться. В "
"строке запроса эти параметры обозначаются как <literal>$1</literal> ... "
"<literal>$<replaceable>n</replaceable></literal>. Если в запросе "
"используются параметры, нужно задать имена типов этих параметров в виде "
"списка Tcl. (Если параметры отсутствуют, задайте пустой "
"<replaceable>список_типов</replaceable>.)"

#: pltcl.xml:362(para)
msgid ""
"The return value from <function>spi_prepare</function> is a query ID to be "
"used in subsequent calls to <function>spi_execp</function>. See "
"<function>spi_execp</function> for an example."
msgstr ""
"Функция <function>spi_prepare</function> возвращает идентификатор запроса, "
"который может использоваться в последующих вызовах <function>spi_execp</"
"function>. Пример приведён в описании <function>spi_execp</function>."

#: pltcl.xml:371(function)
msgid "spi_execp"
msgstr "spi_execp"

#: pltcl.xml:371(replaceable) pltcl.xml:442(replaceable)
msgid "string"
msgstr "строка"

#: pltcl.xml:371(optional)
msgid "-nulls <placeholder-1/>"
msgstr "-nulls <placeholder-1/>"

#: pltcl.xml:371(replaceable)
msgid "queryid"
msgstr "ид-запроса"

#: pltcl.xml:371(replaceable)
msgid "value-list"
msgstr "список-значений"

#: pltcl.xml:373(para)
msgid ""
"Executes a query previously prepared with <function>spi_prepare</function>. "
"<replaceable>queryid</replaceable> is the ID returned by "
"<function>spi_prepare</function>. If the query references parameters, a "
"<replaceable>value-list</replaceable> must be supplied. This is a Tcl list "
"of actual values for the parameters. The list must be the same length as the "
"parameter type list previously given to <function>spi_prepare</function>. "
"Omit <replaceable>value-list</replaceable> if the query has no parameters."
msgstr ""
"Выполняет запрос, ранее подготовленный функцией <function>spi_prepare</"
"function>. В качестве <replaceable>ид_запроса</replaceable> передаётся "
"идентификатор, возвращённый функцией <function>spi_prepare</function>. Если "
"в запросе задействуются параметры, необходимо указать <replaceable>список-"
"значений</replaceable>. Это должен быть принятый в Tcl список параметров. Он "
"должен иметь ту же длину, что и список типов параметров, ранее переданный "
"<function>spi_prepare</function>. Опустите <replaceable>список-значений</"
"replaceable>, если у запроса нет параметров."

#: pltcl.xml:383(para)
msgid ""
"The optional value for <literal>-nulls</literal> is a string of spaces and "
"<literal>'n'</literal> characters telling <function>spi_execp</function> "
"which of the parameters are null values. If given, it must have exactly the "
"same length as the <replaceable>value-list</replaceable>. If it is not "
"given, all the parameter values are nonnull."
msgstr ""
"Необязательный аргумент <literal>-nulls</literal> принимает строку из "
"пробелов и символов <literal>'n'</literal>, которые отмечают, в каких "
"параметрах <function>spi_execp</function> передаются значения NULL. Если "
"присутствует, эта строка должна иметь ту же длину, что и <replaceable>список-"
"значений</replaceable>. В случае её отсутствия значения всех параметров "
"считаются отличными от NULL."

#: pltcl.xml:390(para)
msgid ""
"Except for the way in which the query and its parameters are specified, "
"<function>spi_execp</function> works just like <function>spi_exec</"
"function>. The <literal>-count</literal>, <literal>-array</literal>, and "
"<replaceable>loop-body</replaceable> options are the same, and so is the "
"result value."
msgstr ""
"Не считая отличий в способе передачи запроса и параметров, "
"<function>spi_execp</function> работает так же, как <function>spi_exec</"
"function>. Параметры <literal>-count</literal>, <literal>-array</literal> и "
"<replaceable>тело-цикла</replaceable> задаются так же, и так же передаётся "
"возвращаемое значение."

#: pltcl.xml:400(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$\n"
"    if {![ info exists GD(plan) ]} {\n"
"        # prepare the saved plan on the first call\n"
"        set GD(plan) [ spi_prepare \\\n"
"                \"SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \\$1 AND num &lt;= \\$2\" \\\n"
"                [ list int4 int4 ] ]\n"
"    }\n"
"    spi_execp -count 1 $GD(plan) [ list $1 $2 ]\n"
"    return $cnt\n"
"$$ LANGUAGE pltcl;"
msgstr ""
"CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$\n"
"    if {![ info exists GD(plan) ]} {\n"
"        # подготовить сохранённый план при первом вызове\n"
"        set GD(plan) [ spi_prepare \\\n"
"                \"SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \\$1 AND num &lt;= \\$2\" \\\n"
"                [ list int4 int4 ] ]\n"
"    }\n"
"    spi_execp -count 1 $GD(plan) [ list $1 $2 ]\n"
"    return $cnt\n"
"$$ LANGUAGE pltcl;"

#: pltcl.xml:397(para)
msgid ""
"Here's an example of a PL/Tcl function using a prepared plan: <placeholder-1/"
"> We need backslashes inside the query string given to "
"<function>spi_prepare</function> to ensure that the <literal>"
"$<replaceable>n</replaceable></literal> markers will be passed through to "
"<function>spi_prepare</function> as-is, and not replaced by Tcl variable "
"substitution."
msgstr ""
"Взгляните на пример функции на PL/Tcl, использующей подготовленный план: "
"<placeholder-1/> Обратные косые черты внутри строки запроса, передаваемой "
"функции <function>spi_prepare</function>, нужны для того, чтобы маркеры "
"<literal>$<replaceable>n</replaceable></literal> передавались функции "
"<function>spi_prepare</function> как есть, а не заменялись при подстановке "
"переменных Tcl."

#: pltcl.xml:425(function)
msgid "spi_lastoid"
msgstr "spi_lastoid"

#: pltcl.xml:426(indexterm)
msgid "<primary>spi_lastoid</primary> <secondary>in PL/Tcl</secondary>"
msgstr "<primary>spi_lastoid</primary> <secondary>в PL/Tcl</secondary>"

#: pltcl.xml:432(para)
msgid ""
"Returns the OID of the row inserted by the last <function>spi_exec</"
"function> or <function>spi_execp</function>, if the command was a single-row "
"<command>INSERT</command> and the modified table contained OIDs. (If not, "
"you get zero.)"
msgstr ""
"Возвращает OID строки, вставленной последней командой <function>spi_exec</"
"function> или <function>spi_execp</function>, если этой командой был "
"оператор <command>INSERT</command> с одной строкой и изменяемая таблица "
"содержит OID. (В противном случае вы получите ноль.)"

#: pltcl.xml:442(function)
msgid "quote"
msgstr "quote"

#: pltcl.xml:452(programlisting)
#, no-wrap
msgid "\"SELECT '$val' AS ret\""
msgstr "\"SELECT '$val' AS ret\""

#: pltcl.xml:460(programlisting)
#, no-wrap
msgid "SELECT 'doesn't' AS ret"
msgstr "SELECT 'doesn't' AS ret"

#: pltcl.xml:469(programlisting)
#, no-wrap
msgid "SELECT 'doesn''t' AS ret"
msgstr "SELECT 'doesn''t' AS ret"

#: pltcl.xml:475(programlisting)
#, no-wrap
msgid "\"SELECT '[ quote $val ]' AS ret\""
msgstr "\"SELECT '[ quote $val ]' AS ret\""

#: pltcl.xml:444(para)
msgid ""
"Doubles all occurrences of single quote and backslash characters in the "
"given string. This can be used to safely quote strings that are to be "
"inserted into SQL commands given to <function>spi_exec</function> or "
"<function>spi_prepare</function>. For example, think about an SQL command "
"string like: <placeholder-1/> where the Tcl variable <literal>val</literal> "
"actually contains <literal>doesn't</literal>. This would result in the final "
"command string: <placeholder-2/> which would cause a parse error during "
"<function>spi_exec</function> or <function>spi_prepare</function>. To work "
"properly, the submitted command should contain: <placeholder-3/> which can "
"be formed in PL/Tcl using: <placeholder-4/> One advantage of "
"<function>spi_execp</function> is that you don't have to quote parameter "
"values like this, since the parameters are never parsed as part of an SQL "
"command string."
msgstr ""
"Дублирует все вхождения апострофа и обратной косой черты в заданной строке. "
"Это можно использовать для защиты строк, которые будут вставляться в команды "
"SQL, передаваемые в <function>spi_exec</function> или <function>spi_prepare</"
"function>. Например, представьте, что при выполнении такой команды SQL: "
"<placeholder-1/> переменная языка Tcl <literal>val</literal> содержит "
"<literal>doesn't</literal>. Это приведёт к формированию такой окончательной "
"строки команды: <placeholder-2/> при разборе которой в процессе "
"<function>spi_exec</function> или <function>spi_prepare</function> возникнет "
"ошибка. Чтобы этот запрос работал правильно, итоговая команда должна "
"выглядеть так: <placeholder-3/> Получить её в PL/Tcl можно так: "
"<placeholder-4/> Преимуществом <function>spi_execp</function> является то, "
"что для неё заключать значения параметров в кавычки подобным образом не "
"нужно, так как параметры никогда не разбираются в составе строки команды SQL."

#: pltcl.xml:488(function)
msgid "elog"
msgstr "elog"

#: pltcl.xml:488(replaceable)
msgid "level"
msgstr "уровень"

#: pltcl.xml:488(replaceable)
msgid "msg"
msgstr "сообщение"

#: pltcl.xml:489(indexterm)
msgid "<primary>elog</primary> <secondary>in PL/Tcl</secondary>"
msgstr "<primary>elog</primary> <secondary>в PL/Tcl</secondary>"

#: pltcl.xml:495(para)
msgid ""
"Emits a log or error message. Possible levels are <literal>DEBUG</literal>, "
"<literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, "
"<literal>WARNING</literal>, <literal>ERROR</literal>, and <literal>FATAL</"
"literal>. <literal>ERROR</literal> raises an error condition; if this is not "
"trapped by the surrounding Tcl code, the error propagates out to the calling "
"query, causing the current transaction or subtransaction to be aborted. This "
"is effectively the same as the Tcl <literal>error</literal> command. "
"<literal>FATAL</literal> aborts the transaction and causes the current "
"session to shut down. (There is probably no good reason to use this error "
"level in PL/Tcl functions, but it's provided for completeness.) The other "
"levels only generate messages of different priority levels. Whether messages "
"of a particular priority are reported to the client, written to the server "
"log, or both is controlled by the <xref linkend=\"guc-log-min-messages\"/> "
"and <xref linkend=\"guc-client-min-messages\"/> configuration variables. See "
"<xref linkend=\"runtime-config\"/> and <xref linkend=\"pltcl-error-handling"
"\"/> for more information."
msgstr ""
"Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни "
"сообщений: <literal>DEBUG</literal> (ОТЛАДКА), <literal>LOG</literal> "
"(СООБЩЕНИЕ), <literal>INFO</literal> (ИНФОРМАЦИЯ), <literal>NOTICE</literal> "
"(ЗАМЕЧАНИЕ), <literal>WARNING</literal> (ПРЕДУПРЕЖДЕНИЕ), <literal>ERROR</"
"literal> (ОШИБКА) и <literal>FATAL</literal> (ВАЖНО). С уровнем "
"<literal>ERROR</literal> выдаётся ошибка; если она не перехватывается "
"окружающим кодом Tcl, она распространяется в вызывающий запрос, что приводит "
"к прерыванию текущей транзакции или подтранзакции. По сути то же самое "
"делает команда <literal>error</literal> языка Tcl. Сообщение уровня "
"<literal>FATAL</literal> прерывает транзакцию и приводит к завершению "
"текущего сеанса. (Вероятно, нет обоснованной причины использовать этот "
"уровень ошибок в функциях PL/Tcl, но он поддерживается для полноты.) При "
"использовании других уровней происходит просто вывод сообщения с заданным "
"уровнем важности. Будут ли сообщения определённого уровня передаваться "
"клиенту и/или записываться в журнал, определяется конфигурационными "
"переменными <xref linkend=\"guc-log-min-messages\"/> и <xref linkend=\"guc-"
"client-min-messages\"/>. За дополнительными сведениями обратитесь к <xref "
"remap=\"3\" linkend=\"runtime-config\"/> и <xref remap=\"3\" linkend=\"pltcl-"
"error-handling\"/>."

#: pltcl.xml:272(para)
msgid ""
"The following commands are available to access the database from the body of "
"a PL/Tcl function: <placeholder-1/>"
msgstr ""
"Для обращения к базе данных из тела функции на PL/Tcl предназначены "
"следующие команды: <placeholder-1/>"

#: pltcl.xml:526(title)
msgid "Trigger Procedures in PL/Tcl"
msgstr "Процедуры триггеров на PL/Tcl"

#: pltcl.xml:528(indexterm)
msgid "<primary>trigger</primary> <secondary>in PL/Tcl</secondary>"
msgstr "<primary>триггер</primary> <secondary>на языке PL/Tcl</secondary>"

#: pltcl.xml:533(para)
msgid ""
"Trigger procedures can be written in PL/Tcl. <productname>PostgreSQL</"
"productname> requires that a procedure that is to be called as a trigger "
"must be declared as a function with no arguments and a return type of "
"<literal>trigger</literal>."
msgstr ""
"На PL/Tcl можно написать триггерные процедуры. <productname>PostgreSQL</"
"productname> требует, чтобы процедура, которая будет вызываться как "
"триггерная, была объявлена как функция без аргументов и возвращала тип "
"<literal>trigger</literal>."

#: pltcl.xml:546(varname)
msgid "$TG_name"
msgstr "$TG_name"

#: pltcl.xml:548(para)
msgid ""
"The name of the trigger from the <command>CREATE TRIGGER</command> statement."
msgstr "Имя триггера из оператора <command>CREATE TRIGGER</command>."

#: pltcl.xml:555(varname)
msgid "$TG_relid"
msgstr "$TG_relid"

#: pltcl.xml:557(para)
msgid ""
"The object ID of the table that caused the trigger procedure to be invoked."
msgstr ""
"Идентификатор объекта таблицы, для которой будет вызываться триггерная "
"процедура."

#: pltcl.xml:565(varname)
msgid "$TG_table_name"
msgstr "$TG_table_name"

#: pltcl.xml:567(para)
msgid "The name of the table that caused the trigger procedure to be invoked."
msgstr "Имя таблицы, для которой будет вызываться триггерная процедура."

#: pltcl.xml:575(varname)
msgid "$TG_table_schema"
msgstr "$TG_table_schema"

#: pltcl.xml:577(para)
msgid ""
"The schema of the table that caused the trigger procedure to be invoked."
msgstr "Схема таблицы, для которой будет вызываться триггерная процедура."

#: pltcl.xml:585(varname)
msgid "$TG_relatts"
msgstr "$TG_relatts"

#: pltcl.xml:587(para)
msgid ""
"A Tcl list of the table column names, prefixed with an empty list element. "
"So looking up a column name in the list with <application>Tcl</"
"application>'s <function>lsearch</function> command returns the element's "
"number starting with 1 for the first column, the same way the columns are "
"customarily numbered in <productname>PostgreSQL</productname>. (Empty list "
"elements also appear in the positions of columns that have been dropped, so "
"that the attribute numbering is correct for columns to their right.)"
msgstr ""
"Список языка Tcl, содержащий имена столбцов таблицы. В начало списка "
"добавлен пустой элемент, поэтому при поиске в этом списке имени столбца с "
"помощью стандартной в <application>Tcl</application> команды "
"<function>lsearch</function> будет возвращён номер элемента, начиная с 1, "
"так же, как нумеруются столбцы в <productname>PostgreSQL</productname>. (В "
"позициях удалённых столбцов также содержатся пустые элементы, так что "
"нумерация следующих за ними атрибутов не нарушается.)"

#: pltcl.xml:601(varname)
msgid "$TG_when"
msgstr "$TG_when"

#: pltcl.xml:603(para)
msgid ""
"The string <literal>BEFORE</literal>, <literal>AFTER</literal>, or "
"<literal>INSTEAD OF</literal>, depending on the type of trigger event."
msgstr ""
"Строка <literal>BEFORE</literal>, <literal>AFTER</literal> или "
"<literal>INSTEAD OF</literal>, в зависимости от типа события триггера."

#: pltcl.xml:611(varname)
msgid "$TG_level"
msgstr "$TG_level"

#: pltcl.xml:613(para)
msgid ""
"The string <literal>ROW</literal> or <literal>STATEMENT</literal> depending "
"on the type of trigger event."
msgstr ""
"Строка <literal>ROW</literal> или <literal>STATEMENT</literal>, в "
"зависимости от уровня события триггера."

#: pltcl.xml:621(varname)
msgid "$TG_op"
msgstr "$TG_op"

#: pltcl.xml:623(para)
msgid ""
"The string <literal>INSERT</literal>, <literal>UPDATE</literal>, "
"<literal>DELETE</literal>, or <literal>TRUNCATE</literal> depending on the "
"type of trigger event."
msgstr ""
"Строка <literal>INSERT</literal>, <literal>UPDATE</literal>, "
"<literal>DELETE</literal> или <literal>TRUNCATE</literal>, в зависимости от "
"действия события триггера."

#: pltcl.xml:632(varname)
msgid "$NEW"
msgstr "$NEW"

#: pltcl.xml:634(para)
msgid ""
"An associative array containing the values of the new table row for "
"<command>INSERT</command> or <command>UPDATE</command> actions, or empty for "
"<command>DELETE</command>. The array is indexed by column name. Columns that "
"are null will not appear in the array. This is not set for statement-level "
"triggers."
msgstr ""
"Ассоциативный массив, содержащий значения новой строки таблицы для действий "
"<command>INSERT</command> или <command>UPDATE</command>, либо пустой массив "
"для <command>DELETE</command>. Индексами в массиве являются имена столбцов. "
"Столбцы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора "
"этот массив не определяется."

#: pltcl.xml:645(varname)
msgid "$OLD"
msgstr "$OLD"

#: pltcl.xml:647(para)
msgid ""
"An associative array containing the values of the old table row for "
"<command>UPDATE</command> or <command>DELETE</command> actions, or empty for "
"<command>INSERT</command>. The array is indexed by column name. Columns that "
"are null will not appear in the array. This is not set for statement-level "
"triggers."
msgstr ""
"Ассоциативный массив, содержащий значения старой строки таблицы для действий "
"<command>UPDATE</command> или <command>DELETE</command>, либо пустой массив "
"для <command>INSERT</command>. Индексами в массиве являются имена столбцов. "
"Столбцы со значениями NULL в нём отсутствуют. Для триггеров уровня оператора "
"этот массив не определяется."

#: pltcl.xml:658(varname)
msgid "$args"
msgstr "$args"

#: pltcl.xml:660(para)
msgid ""
"A Tcl list of the arguments to the procedure as given in the <command>CREATE "
"TRIGGER</command> statement. These arguments are also accessible as <literal>"
"$1</literal> ... <literal>$<replaceable>n</replaceable></literal> in the "
"procedure body."
msgstr ""
"Список на языке Tcl аргументов процедуры, заданных в операторе "
"<command>CREATE TRIGGER</command>. Эти аргументы также доступны под "
"обозначениями <literal>$1</literal> ... <literal>$<replaceable>n</"
"replaceable></literal> в теле процедуры."

#: pltcl.xml:539(para) pltcl.xml:751(para)
msgid ""
"The information from the trigger manager is passed to the procedure body in "
"the following variables: <placeholder-1/>"
msgstr ""
"Информация от менеджера триггеров передаётся в тело процедуры в следующих "
"переменных: <placeholder-1/>"

#: pltcl.xml:671(para)
msgid ""
"The return value from a trigger procedure can be one of the strings "
"<literal>OK</literal> or <literal>SKIP</literal>, or a list of column name/"
"value pairs. If the return value is <literal>OK</literal>, the operation "
"(<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</"
"command>) that fired the trigger will proceed normally. <literal>SKIP</"
"literal> tells the trigger manager to silently suppress the operation for "
"this row. If a list is returned, it tells PL/Tcl to return a modified row to "
"the trigger manager; the contents of the modified row are specified by the "
"column names and values in the list. Any columns not mentioned in the list "
"are set to null. Returning a modified row is only meaningful for row-level "
"<literal>BEFORE</literal> <command>INSERT</command> or <command>UPDATE</"
"command> triggers, for which the modified row will be inserted instead of "
"the one given in <varname>$NEW</varname>; or for row-level <literal>INSTEAD "
"OF</literal> <command>INSERT</command> or <command>UPDATE</command> triggers "
"where the returned row is used as the source data for <command>INSERT "
"RETURNING</command> or <command>UPDATE RETURNING</command> clauses. In row-"
"level <literal>BEFORE</literal> <command>DELETE</command> or "
"<literal>INSTEAD OF</literal> <command>DELETE</command> triggers, returning "
"a modified row has the same effect as returning <literal>OK</literal>, that "
"is the operation proceeds. The trigger return value is ignored for all other "
"types of triggers."
msgstr ""
"Возвращаемым значением триггерной процедуры может быть строка <literal>OK</"
"literal> или <literal>SKIP</literal> либо список пар имя столбца/значение. "
"Если возвращается значение <literal>OK</literal>, операция (<command>INSERT</"
"command>/<command>UPDATE</command>/<command>DELETE</command>), которая "
"привела к срабатыванию триггера, выполняется нормально. Значение "
"<literal>SKIP</literal> указывает менеджеру триггеров просто пропустить эту "
"операцию с текущей строкой данных. Если возвращается список, через него PL/"
"Tcl передаёт менеджеру триггеров изменённую строку; содержимое изменённой "
"строки задаётся именами и значениями столбцов в списке. Все столбцы, не "
"перечисленные в этом списке, получают значения NULL. Возвращать изменённую "
"строку имеет смысл только для триггеров уровня строки с порядком "
"<literal>BEFORE</literal> команд <command>INSERT</command> и "
"<command>UPDATE</command>, в которых вместо заданной в <varname>$NEW</"
"varname> будет записываться изменённая строка; либо с порядком "
"<literal>INSTEAD OF</literal> команд <command>INSERT</command> и "
"<command>UPDATE</command>, в которых возвращаемая строка служит исходными "
"данными для предложений <command>INSERT RETURNING</command> или "
"<command>UPDATE RETURNING</command>. В триггерах уровня строки с порядком "
"<literal>BEFORE</literal> или <literal>INSTEAD OF</literal> команды "
"<command>DELETE</command> возврат изменённой строки воспринимается так же, "
"как и возврат значения <literal>OK</literal>, то есть операция выполняется. "
"Для всех остальных типов триггеров возвращаемое значение игнорируется."

#: pltcl.xml:696(para)
msgid ""
"The result list can be made from an array representation of the modified "
"tuple with the <literal>array get</literal> Tcl command."
msgstr ""
"Список результатов можно создать из изменённого кортежа, представленного в "
"виде массива, с помощью команды <literal>array get</literal> языка Tcl."

#: pltcl.xml:708(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$\n"
"    switch $TG_op {\n"
"        INSERT {\n"
"            set NEW($1) 0\n"
"        }\n"
"        UPDATE {\n"
"            set NEW($1) $OLD($1)\n"
"            incr NEW($1)\n"
"        }\n"
"        default {\n"
"            return OK\n"
"        }\n"
"    }\n"
"    return [array get NEW]\n"
"$$ LANGUAGE pltcl;\n"
"\n"
"CREATE TABLE mytab (num integer, description text, modcnt integer);\n"
"\n"
"CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab\n"
"    FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');"
msgstr ""
"CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$\n"
"    switch $TG_op {\n"
"        INSERT {\n"
"            set NEW($1) 0\n"
"        }\n"
"        UPDATE {\n"
"            set NEW($1) $OLD($1)\n"
"            incr NEW($1)\n"
"        }\n"
"        default {\n"
"            return OK\n"
"        }\n"
"    }\n"
"    return [array get NEW]\n"
"$$ LANGUAGE pltcl;\n"
"\n"
"CREATE TABLE mytab (num integer, description text, modcnt integer);\n"
"\n"
"CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab\n"
"    FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');"

#: pltcl.xml:702(para)
msgid ""
"Here's a little example trigger procedure that forces an integer value in a "
"table to keep track of the number of updates that are performed on the row. "
"For new rows inserted, the value is initialized to 0 and then incremented on "
"every update operation. <placeholder-1/> Notice that the trigger procedure "
"itself does not know the column name; that's supplied from the trigger "
"arguments. This lets the trigger procedure be reused with different tables."
msgstr ""
"Следующий небольшой пример показывает триггерную процедуру, которая ведёт в "
"таблице целочисленный счётчик числа изменений, выполненных в строке. Для "
"новых строк счётчик инициализируется нулевым значением, а затем "
"увеличивается на единицу при каждом изменении. <placeholder-1/> Заметьте, "
"что сама триггерная процедура не знает имени столбца; оно передаётся в "
"аргументах триггера. Это позволяет применять эту триггерную процедуру для "
"различных таблиц."

#: pltcl.xml:738(title)
msgid "Event Trigger Procedures in PL/Tcl"
msgstr "Процедуры событийных триггеров в PL/Tcl"

#: pltcl.xml:740(indexterm)
msgid "<primary>event trigger</primary> <secondary>in PL/Tcl</secondary>"
msgstr "<primary>событийный триггер</primary> <secondary>в PL/Tcl</secondary>"

#: pltcl.xml:745(para)
msgid ""
"Event trigger procedures can be written in PL/Tcl. <productname>PostgreSQL</"
"productname> requires that a procedure that is to be called as an event "
"trigger must be declared as a function with no arguments and a return type "
"of <literal>event_trigger</literal>."
msgstr ""
"На PL/Tcl можно написать процедуры событийных триггеров. "
"<productname>PostgreSQL</productname> требует, чтобы процедура, которая "
"будет вызываться как событийный триггер, была объявлена как функция без "
"аргументов и возвращала тип <literal>event_trigger</literal>."

#: pltcl.xml:758(varname)
msgid "$TG_event"
msgstr "$TG_event"

#: pltcl.xml:760(para)
msgid "The name of the event the trigger is fired for."
msgstr "Имя события, при котором срабатывает этот триггер."

#: pltcl.xml:767(varname)
msgid "$TG_tag"
msgstr "$TG_tag"

#: pltcl.xml:769(para)
msgid "The command tag for which the trigger is fired."
msgstr "Тег команды, для которой срабатывает этот триггер."

#: pltcl.xml:777(para)
msgid "The return value of the trigger procedure is ignored."
msgstr "Возвращаемое значение триггерной процедуры игнорируется."

#: pltcl.xml:786(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$\n"
"  elog NOTICE \"tclsnitch: $TG_event $TG_tag\"\n"
"$$ LANGUAGE pltcl;\n"
"\n"
"CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE PROCEDURE tclsnitch();"
msgstr ""
"CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$\n"
"  elog NOTICE \"tclsnitch: $TG_event $TG_tag\"\n"
"$$ LANGUAGE pltcl;\n"
"\n"
"CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE PROCEDURE tclsnitch();"

#: pltcl.xml:781(para)
msgid ""
"Here's a little example event trigger procedure that simply raises a "
"<literal>NOTICE</literal> message each time a supported command is executed: "
"<placeholder-1/>"
msgstr ""
"Следующий небольшой пример процедуры событийного триггера просто выдаёт "
"замечание (<literal>NOTICE</literal>) при каждом выполнении поддерживаемой "
"команды: <placeholder-1/>"

#: pltcl.xml:797(title)
msgid "Error Handling in PL/Tcl"
msgstr "Обработка ошибок в PL/Tcl"

#: pltcl.xml:799(indexterm)
msgid "<primary>exceptions</primary> <secondary>in PL/Tcl</secondary>"
msgstr "<primary>исключения</primary> <secondary>в PL/Tcl</secondary>"

#: pltcl.xml:804(para)
msgid ""
"Tcl code within or called from a PL/Tcl function can raise an error, either "
"by executing some invalid operation or by generating an error using the Tcl "
"<function>error</function> command or PL/Tcl's <function>elog</function> "
"command. Such errors can be caught within Tcl using the Tcl <function>catch</"
"function> command. If they are not caught but are allowed to propagate out "
"to the top level of execution of the PL/Tcl function, they turn into "
"database errors."
msgstr ""
"Tcl-код, содержащийся или вызываемый из функции PL/Tcl, может выдавать "
"ошибку, либо выполняя недопустимую операцию, либо генерируя ошибку с помощью "
"команды <function>error</function> языка Tcl или команды <function>elog</"
"function> языка PL/Tcl. Такие ошибки могут быть перехвачены в среде Tcl с "
"помощью команды Tcl <function>catch</function>. Если они не перехватываются, "
"а распространяются выше уровня выполнения функций PL/Tcl, они становятся "
"ошибками СУБД."

#: pltcl.xml:814(para)
msgid ""
"Conversely, database errors that occur within PL/Tcl's <function>spi_exec</"
"function>, <function>spi_prepare</function>, and <function>spi_execp</"
"function> commands are reported as Tcl errors, so they are catchable by "
"Tcl's <function>catch</function> command. Again, if they propagate out to "
"the top level without being caught, they turn back into database errors."
msgstr ""
"И напротив, ошибки СУБД, возникающие внутри команд <function>spi_exec</"
"function>, <function>spi_prepare</function> и <function>spi_execp</function> "
"в среде PL/Tcl, выдаются как ошибки Tcl, так что их можно перехватить "
"командой Tcl <function>catch</function>. Опять же, если они не "
"перехватываются и распространяются на верхний уровень, они становятся "
"ошибками СУБД."

#: pltcl.xml:823(para)
msgid ""
"Tcl provides an <varname>errorCode</varname> variable that can represent "
"additional information about an error in a form that is easy for Tcl "
"programs to interpret. The contents are in Tcl list format, and the first "
"word identifies the subsystem or library reporting the error; beyond that "
"the contents are left to the individual subsystem or library. For database "
"errors reported by PL/Tcl commands, the first word is <literal>POSTGRES</"
"literal>, the second word is the Postgres version number, and additional "
"words are field name/value pairs providing detailed information about the "
"error. Fields <varname>SQLSTATE</varname>, <varname>condition</varname>, and "
"<varname>message</varname> are always supplied (the first two represent the "
"error code and condition name as shown in <xref linkend=\"errcodes-appendix"
"\"/>). Fields that may be present include <varname>detail</varname>, "
"<varname>hint</varname>, <varname>context</varname>, <varname>schema</"
"varname>, <varname>table</varname>, <varname>column</varname>, "
"<varname>datatype</varname>, <varname>constraint</varname>, "
"<varname>statement</varname>, <varname>cursor_position</varname>, "
"<varname>filename</varname>, <varname>lineno</varname>, and "
"<varname>funcname</varname>."
msgstr ""
"В Tcl имеется переменная <varname>errorCode</varname>, представляющая "
"дополнительную информацию об ошибке в виде, удобном для обработки в "
"программах на Tcl. Эта информация передаётся в формате списка Tcl, первое "
"слово в котором указывает на подсистему или библиотеку, выдающую ошибку; "
"последующее содержимое определяется в зависимости от подсистемы или "
"библиотеки. Для ошибок СУБД, возникающих в командах PL/Tcl, первым словом "
"будет <literal>POSTGRES</literal>, вторым — номер версии Postgres, а "
"дополнительные слова представляют пары имя/значения, передающие подробную "
"информацию об ошибке. В этих парах всегда передаются поля <varname>SQLSTATE</"
"varname>, <varname>condition</varname> и <varname>message</varname> (первые "
"два представляют код ошибки и имя условия, как описано в <xref remap=\"6\" "
"linkend=\"errcodes-appendix\"/>). Также могут передаваться поля "
"<varname>detail</varname>, <varname>hint</varname>, <varname>context</"
"varname>, <varname>schema</varname>, <varname>table</varname>, "
"<varname>column</varname>, <varname>datatype</varname>, <varname>constraint</"
"varname>, <varname>statement</varname>, <varname>cursor_position</varname>, "
"<varname>filename</varname>, <varname>lineno</varname> и <varname>funcname</"
"varname>."

#: pltcl.xml:850(programlisting)
#, no-wrap
msgid ""
"if {[catch { spi_exec $sql_command }]} {\n"
"    if {[lindex $::errorCode 0] == \"POSTGRES\"} {\n"
"        array set errorArray $::errorCode\n"
"        if {$errorArray(condition) == \"undefined_table\"} {\n"
"            # deal with missing table\n"
"        } else {\n"
"            # deal with some other type of SQL error\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"if {[catch { spi_exec $sql_command }]} {\n"
"    if {[lindex $::errorCode 0] == \"POSTGRES\"} {\n"
"        array set errorArray $::errorCode\n"
"        if {$errorArray(condition) == \"undefined_table\"} {\n"
"            # разобраться с отсутствием таблицы\n"
"        } else {\n"
"            # разобраться с другими типами ошибок SQL\n"
"        }\n"
"    }\n"
"}"

#: pltcl.xml:846(para)
msgid ""
"A convenient way to work with PL/Tcl's <varname>errorCode</varname> "
"information is to load it into an array, so that the field names become "
"array subscripts. Code for doing that might look like <placeholder-1/> (The "
"double colons explicitly specify that <varname>errorCode</varname> is a "
"global variable.)"
msgstr ""
"С информацией в переменной <varname>errorCode</varname> среды PL/Tcl удобно "
"работать, загрузив переменную в массив, чтобы имена полей стали индексами в "
"массиве. Пример такого кода: <placeholder-1/> (Двойные двоеточия явно "
"указывают, что переменная <varname>errorCode</varname> является глобальной.)"

#: pltcl.xml:868(title)
msgid "Modules and the <function>unknown</function> Command"
msgstr "Модули и команда <function>unknown</function>"

#: pltcl.xml:869(para)
msgid ""
"PL/Tcl has support for autoloading Tcl code when used. It recognizes a "
"special table, <literal>pltcl_modules</literal>, which is presumed to "
"contain modules of Tcl code. If this table exists, the module "
"<literal>unknown</literal> is fetched from the table and loaded into the Tcl "
"interpreter immediately before the first execution of a PL/Tcl function in a "
"database session. (This happens separately for each Tcl interpreter, if more "
"than one is used in a session; see <xref linkend=\"pltcl-global\"/>.)"
msgstr ""
"PL/Tcl поддерживает автозагрузку кода Tcl. Для этого он задействует "
"специальную таблицу, <literal>pltcl_modules</literal>, предназначенную для "
"размещения модулей кода Tcl. Если эта таблица существует, из таблицы "
"выбирается модуль <literal>unknown</literal> и загружается в интерпретатор "
"Tcl непосредственно перед первым выполнением функции PL/Tcl в сеансе базы "
"данных. (Это происходит независимо для каждого интерпретатора Tcl, если их "
"несколько в одном сеансе; см. <xref remap=\"4\" linkend=\"pltcl-global\"/>.)"

#: pltcl.xml:879(para)
msgid ""
"While the <literal>unknown</literal> module could actually contain any "
"initialization script you need, it normally defines a Tcl <function>unknown</"
"function> procedure that is invoked whenever Tcl does not recognize an "
"invoked procedure name. <application>PL/Tcl</application>'s standard version "
"of this procedure tries to find a module in <literal>pltcl_modules</literal> "
"that will define the required procedure. If one is found, it is loaded into "
"the interpreter, and then execution is allowed to proceed with the "
"originally attempted procedure call. A secondary table "
"<literal>pltcl_modfuncs</literal> provides an index of which functions are "
"defined by which modules, so that the lookup is reasonably quick."
msgstr ""
"Хотя модуль <literal>unknown</literal> может на самом деле содержать любой "
"нужный вам скрипт инициализации, обычно в нём определяется процедура "
"<function>unknown</function> языка Tcl, которая вызывается всякий раз, когда "
"Tcl не распознаёт имя вызываемой процедуры. Принятая в <application>PL/Tcl</"
"application> версия этой процедуры пытается найти в <literal>pltcl_modules</"
"literal> модуль, в котором будет определена требуемая процедура. Если такой "
"модуль находится, он загружается в интерпретатор и затем выполнение "
"изначального вызова процедуры может быть продолжено. Дополнительная таблица "
"<literal>pltcl_modfuncs</literal> содержит индекс, связывающий функции с "
"модулями, в которых они определены, так что поиск выполняется довольно "
"быстро."

#: pltcl.xml:892(para)
msgid ""
"The <productname>PostgreSQL</productname> distribution includes support "
"scripts to maintain these tables: <command>pltcl_loadmod</command>, "
"<command>pltcl_listmod</command>, <command>pltcl_delmod</command>, as well "
"as source for the standard <literal>unknown</literal> module in "
"<filename>share/unknown.pltcl</filename>. This module must be loaded into "
"each database initially to support the autoloading mechanism."
msgstr ""
"В составе <productname>PostgreSQL</productname> поставляются вспомогательные "
"скрипты для обслуживания этих таблиц: <command>pltcl_loadmod</command>, "
"<command>pltcl_listmod</command>, <command>pltcl_delmod</command>, а также "
"исходный код стандартного модуля <literal>unknown</literal> в "
"<filename>share/unknown.pltcl</filename>. Для поддержки механизма "
"автозагрузки этот модуль должен изначально загружаться в каждую базу данных."

#: pltcl.xml:901(para)
msgid ""
"The tables <literal>pltcl_modules</literal> and <literal>pltcl_modfuncs</"
"literal> must be readable by all, but it is wise to make them owned and "
"writable only by the database administrator. As a security precaution, PL/"
"Tcl will ignore <literal>pltcl_modules</literal> (and thus, not attempt to "
"load the <literal>unknown</literal> module) unless it is owned by a "
"superuser. But update privileges on this table can be granted to other "
"users, if you trust them sufficiently."
msgstr ""
"Таблицы <literal>pltcl_modules</literal> и <literal>pltcl_modfuncs</literal> "
"должны быть доступны на чтение всем, но разрешать запись в них разумно "
"только администратору базы данных (и только он должен быть их владельцем). В "
"качестве меры предосторожности PL/Tcl будет игнорировать таблицу "
"<literal>pltcl_modules</literal> (и таким образом, не будет пытаться "
"загрузить модуль <literal>unknown</literal>), если она принадлежит не "
"суперпользователю. Но право на изменение данных в ней можно дать и другим "
"пользователям, если они заслуживают такого доверия."

#: pltcl.xml:913(title)
msgid "Tcl Procedure Names"
msgstr "Имена процедур Tcl"

#: pltcl.xml:915(para)
msgid ""
"In <productname>PostgreSQL</productname>, the same function name can be used "
"for different function definitions as long as the number of arguments or "
"their types differ. Tcl, however, requires all procedure names to be "
"distinct. PL/Tcl deals with this by making the internal Tcl procedure names "
"contain the object ID of the function from the system table "
"<structname>pg_proc</structname> as part of their name. Thus, "
"<productname>PostgreSQL</productname> functions with the same name and "
"different argument types will be different Tcl procedures, too. This is not "
"normally a concern for a PL/Tcl programmer, but it might be visible when "
"debugging."
msgstr ""
"В <productname>PostgreSQL</productname> одно имя функции может "
"использоваться разными определениями функций, если они имеют разное число и "
"типы аргументов. Tcl, однако, требует, чтобы имена всех процедур "
"различались. PL/Tcl решает эту проблему, устанавливая такие внутренние имена "
"процедур Tcl, чтобы они включали в свой состав OID функции из системной "
"таблицы <structname>pg_proc</structname>. Таким образом, функциям "
"<productname>PostgreSQL</productname> с одним именем и разными типами "
"аргументов так же будут соответствовать различные процедуры Tcl. Это обычно "
"остаётся незамеченным для программиста PL/Tcl, но может проявиться при "
"отладке."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: pltcl.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
