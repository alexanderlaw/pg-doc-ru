# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-08-29 10:53+0300\n"
"PO-Revision-Date: 2017-08-09 17:23+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: queries.xml:5(title)
msgid "Queries"
msgstr "Запросы"

#: queries.xml:7(indexterm)
msgid "<primary>query</primary>"
msgstr "<primary>запрос</primary>"

#: queries.xml:11(indexterm)
msgid "<primary>SELECT</primary>"
msgstr "<primary>SELECT</primary>"

#: queries.xml:15(para)
msgid ""
"The previous chapters explained how to create tables, how to fill them with "
"data, and how to manipulate that data. Now we finally discuss how to "
"retrieve the data from the database."
msgstr ""
"В предыдущих главах рассказывалось, как создать таблицы, как заполнить их "
"данными и как изменить эти данные. Теперь мы наконец обсудим, как получить "
"данные из базы данных."

#: queries.xml:23(title)
msgid "Overview"
msgstr "Обзор"

#: queries.xml:25(para)
msgid ""
"The process of retrieving or the command to retrieve data from a database is "
"called a <firstterm>query</firstterm>. In SQL the <xref linkend=\"sql-select"
"\"/> command is used to specify queries. The general syntax of the "
"<command>SELECT</command> command is <synopsis>\n"
"<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT "
"<replaceable>select_list</replaceable> FROM <replaceable>table_expression</"
"replaceable> <optional><replaceable>sort_specification</replaceable></"
"optional>\n"
"</synopsis> The following sections describe the details of the select list, "
"the table expression, and the sort specification. <literal>WITH</literal> "
"queries are treated last since they are an advanced feature."
msgstr ""
"Процесс или команда получения данных из базы данных называется "
"<firstterm>запросом</firstterm>. В SQL запросы формулируются с помощью "
"команды <xref linkend=\"sql-select\"/>. В общем виде команда "
"<command>SELECT</command> записывается так: <synopsis>\n"
"<optional>WITH <replaceable>запросы_with</replaceable></optional> SELECT "
"<replaceable>список_выборки</replaceable> FROM "
"<replaceable>табличное_выражение</replaceable> "
"<optional><replaceable>определение_сортировки</replaceable></optional>\n"
"</synopsis> В следующих разделах подробно описываются список выборки, "
"табличное выражение и определение сортировки. Запросы <literal>WITH</"
"literal> являются расширенной возможностью <productname>PostgreSQL</"
"productname> и будут рассмотрены в последнюю очередь."

#: queries.xml:41(programlisting)
#, no-wrap
msgid "SELECT * FROM table1;"
msgstr "SELECT * FROM table1;"

#: queries.xml:58(programlisting)
#, no-wrap
msgid "SELECT a, b + c FROM table1;"
msgstr "SELECT a, b + c FROM table1;"

#: queries.xml:39(para)
msgid ""
"A simple kind of query has the form: <placeholder-1/> Assuming that there is "
"a table called <literal>table1</literal>, this command would retrieve all "
"rows and all user-defined columns from <literal>table1</literal>. (The "
"method of retrieval depends on the client application. For example, the "
"<application>psql</application> program will display an ASCII-art table on "
"the screen, while client libraries will offer functions to extract "
"individual values from the query result.) The select list specification "
"<literal>*</literal> means all columns that the table expression happens to "
"provide. A select list can also select a subset of the available columns or "
"make calculations using the columns. For example, if <literal>table1</"
"literal> has columns named <literal>a</literal>, <literal>b</literal>, and "
"<literal>c</literal> (and perhaps others) you can make the following query: "
"<placeholder-2/> (assuming that <literal>b</literal> and <literal>c</"
"literal> are of a numerical data type). See <xref linkend=\"queries-select-"
"lists\"/> for more details."
msgstr ""
"Простой запрос выглядит так: <placeholder-1/> Если предположить, что в базе "
"данных есть таблица <literal>table1</literal>, эта команда получит все "
"строки с содержимым всех столбцов из <literal>table1</literal>. (Метод "
"выдачи результата определяет клиентское приложение. Например, программа "
"<application>psql</application> выведет на экране ASCII-таблицу, хотя "
"клиентские библиотеки позволяют извлекать отдельные значения из результата "
"запроса.) Здесь список выборки задан как <literal>*</literal>, это означает, "
"что запрос должен вернуть все столбцы табличного выражения. В списке выборки "
"можно также указать подмножество доступных столбцов или составить выражения "
"с этими столбцами. Например, если в <literal>table1</literal> есть столбцы "
"<literal>a</literal>, <literal>b</literal> и <literal>c</literal> (и "
"возможно, другие), вы можете выполнить следующий запрос: <placeholder-2/> (в "
"предположении, что столбцы <literal>b</literal> и <literal>c</literal> имеют "
"числовой тип данных). Подробнее это описано в <xref remap=\"6\" linkend="
"\"queries-select-lists\"/>."

#: queries.xml:72(programlisting)
#, no-wrap
msgid "SELECT 3 * 4;"
msgstr "SELECT 3 * 4;"

#: queries.xml:77(programlisting)
#, no-wrap
msgid "SELECT random();"
msgstr "SELECT random();"

#: queries.xml:66(para)
msgid ""
"<literal>FROM table1</literal> is a simple kind of table expression: it "
"reads just one table. In general, table expressions can be complex "
"constructs of base tables, joins, and subqueries. But you can also omit the "
"table expression entirely and use the <command>SELECT</command> command as a "
"calculator: <placeholder-1/> This is more useful if the expressions in the "
"select list return varying results. For example, you could call a function "
"this way: <placeholder-2/>"
msgstr ""
"<literal>FROM table1</literal> &mdash; это простейший тип табличного "
"выражения, в котором просто читается одна таблица. Вообще табличные "
"выражения могут быть сложными конструкциями из базовых таблиц, соединений и "
"подзапросов. А можно и вовсе опустить табличное выражение и использовать "
"команду <command>SELECT</command> как калькулятор: <placeholder-1/> В этом "
"может быть больше смысла, когда выражения в списке выборки возвращают "
"меняющиеся результаты. Например, можно вызвать функцию так: <placeholder-2/>"

#: queries.xml:85(title)
msgid "Table Expressions"
msgstr "Табличные выражения"

#: queries.xml:87(indexterm)
msgid "<primary>table expression</primary>"
msgstr "<primary>табличное выражение</primary>"

#: queries.xml:91(para)
msgid ""
"A <firstterm>table expression</firstterm> computes a table. The table "
"expression contains a <literal>FROM</literal> clause that is optionally "
"followed by <literal>WHERE</literal>, <literal>GROUP BY</literal>, and "
"<literal>HAVING</literal> clauses. Trivial table expressions simply refer to "
"a table on disk, a so-called base table, but more complex expressions can be "
"used to modify or combine base tables in various ways."
msgstr ""
"<firstterm>Табличное выражение</firstterm> вычисляет таблицу. Это выражение "
"содержит предложение <literal>FROM</literal>, за которым могут следовать "
"предложения <literal>WHERE</literal>, <literal>GROUP BY</literal> и "
"<literal>HAVING</literal>. Тривиальные табличные выражения просто ссылаются "
"на физическую таблицу, её называют также базовой, но в более сложных "
"выражениях такие таблицы можно преобразовывать и комбинировать самыми "
"разными способами."

#: queries.xml:101(para)
msgid ""
"The optional <literal>WHERE</literal>, <literal>GROUP BY</literal>, and "
"<literal>HAVING</literal> clauses in the table expression specify a pipeline "
"of successive transformations performed on the table derived in the "
"<literal>FROM</literal> clause. All these transformations produce a virtual "
"table that provides the rows that are passed to the select list to compute "
"the output rows of the query."
msgstr ""
"Необязательные предложения <literal>WHERE</literal>, <literal>GROUP BY</"
"literal> и <literal>HAVING</literal> в табличном выражении определяют "
"последовательность преобразований, осуществляемых с данными таблицы, "
"полученной в предложении <literal>FROM</literal>. В результате этих "
"преобразований образуется виртуальная таблица, строки которой передаются "
"списку выборки, вычисляющему выходные строки запроса."

#: queries.xml:111(title)
msgid "The <literal>FROM</literal> Clause"
msgstr "Предложение <literal>FROM</literal>"

#: queries.xml:113(para)
msgid ""
"The <xref linkend=\"sql-from\" endterm=\"sql-from-title\"/> derives a table "
"from one or more other tables given in a comma-separated table reference "
"list. <synopsis>\n"
"FROM <replaceable>table_reference</replaceable> <optional>, "
"<replaceable>table_reference</replaceable> <optional>, ...</optional></"
"optional>\n"
"</synopsis> A table reference can be a table name (possibly schema-"
"qualified), or a derived table such as a subquery, a <literal>JOIN</literal> "
"construct, or complex combinations of these. If more than one table "
"reference is listed in the <literal>FROM</literal> clause, the tables are "
"cross-joined (that is, the Cartesian product of their rows is formed; see "
"below). The result of the <literal>FROM</literal> list is an intermediate "
"virtual table that can then be subject to transformations by the "
"<literal>WHERE</literal>, <literal>GROUP BY</literal>, and <literal>HAVING</"
"literal> clauses and is finally the result of the overall table expression."
msgstr ""
"<xref linkend=\"sql-from\" endterm=\"sql-from-title\"/> образует таблицу из "
"одной или нескольких ссылок на таблицы, разделённых запятыми. <synopsis>\n"
"FROM <replaceable>табличная_ссылка</replaceable> <optional>, "
"<replaceable>табличная_ссылка</replaceable> <optional>, ...</optional></"
"optional>\n"
"</synopsis> Здесь табличной ссылкой может быть имя таблицы (возможно, с "
"именем схемы), производная таблица, например подзапрос, соединение таблиц "
"или сложная комбинация этих вариантов. Если в предложении <literal>FROM</"
"literal> перечисляются несколько ссылок, для них применяется перекрёстное "
"соединение (то есть декартово произведение их строк; см. ниже). Список "
"<literal>FROM</literal> преобразуется в промежуточную виртуальную таблицу, "
"которая может пройти через преобразования <literal>WHERE</literal>, "
"<literal>GROUP BY</literal> и <literal>HAVING</literal>, и в итоге определит "
"результат табличного выражения."

#: queries.xml:133(indexterm)
msgid "<primary>ONLY</primary>"
msgstr "<primary>ONLY</primary>"

#: queries.xml:137(para)
msgid ""
"When a table reference names a table that is the parent of a table "
"inheritance hierarchy, the table reference produces rows of not only that "
"table but all of its descendant tables, unless the key word <literal>ONLY</"
"literal> precedes the table name. However, the reference produces only the "
"columns that appear in the named table &mdash; any columns added in "
"subtables are ignored."
msgstr ""
"Когда в табличной ссылке указывается таблица, являющаяся родительской в "
"иерархии наследования, в результате будут получены строки не только этой "
"таблицы, но и всех её дочерних таблиц. Чтобы выбрать строки только одной "
"родительской таблицы, перед её именем нужно добавить ключевое слово "
"<literal>ONLY</literal>. Учтите, что при этом будут получены только столбцы "
"указанной таблицы &mdash; дополнительные столбцы дочерних таблиц не попадут "
"в результат."

#: queries.xml:146(para)
msgid ""
"Instead of writing <literal>ONLY</literal> before the table name, you can "
"write <literal>*</literal> after the table name to explicitly specify that "
"descendant tables are included. Writing <literal>*</literal> is not "
"necessary since that behavior is the default (unless you have changed the "
"setting of the <xref linkend=\"guc-sql-inheritance\"/> configuration "
"option). However writing <literal>*</literal> might be useful to emphasize "
"that additional tables will be searched."
msgstr ""
"Если же вы не добавляете <literal>ONLY</literal> перед именем таблицы, вы "
"можете дописать после него <literal>*</literal>, тем самым указав, что "
"должны обрабатываться и все дочерние таблицы. Добавлять <literal>*</literal> "
"не обязательно, так как теперь это поведение подразумевается по умолчанию "
"(если только вы не измените параметр конфигурации <xref linkend=\"guc-sql-"
"inheritance\"/>). Однако такая запись может быть полезна тем, что подчеркнёт "
"использование дополнительных таблиц."

#: queries.xml:157(title)
msgid "Joined Tables"
msgstr "Соединённые таблицы"

#: queries.xml:159(indexterm)
msgid "<primary>join</primary>"
msgstr "<primary>соединение</primary>"

#: queries.xml:163(para)
msgid ""
"A joined table is a table derived from two other (real or derived) tables "
"according to the rules of the particular join type. Inner, outer, and cross-"
"joins are available. The general syntax of a joined table is <synopsis>\n"
"<replaceable>T1</replaceable> <replaceable>join_type</replaceable> "
"<replaceable>T2</replaceable> <optional> <replaceable>join_condition</"
"replaceable> </optional>\n"
"</synopsis> Joins of all types can be chained together, or nested: either or "
"both <replaceable>T1</replaceable> and <replaceable>T2</replaceable> can be "
"joined tables. Parentheses can be used around <literal>JOIN</literal> "
"clauses to control the join order. In the absence of parentheses, "
"<literal>JOIN</literal> clauses nest left-to-right."
msgstr ""
"Соединённая таблица ­­­­­­&mdash; это таблица, полученная из двух других (реальных "
"или производных от них) таблиц в соответствии с правилами соединения "
"конкретного типа. Общий синтаксис описания соединённой таблицы: <synopsis>\n"
"<replaceable>T1</replaceable> <replaceable>тип_соединения</replaceable> "
"<replaceable>T2</replaceable> <optional> <replaceable>условие_соединения</"
"replaceable> </optional>\n"
"</synopsis>Соединения любых типов могут вкладываются друг в друга или "
"объединяться: и <replaceable>T1</replaceable>, и <replaceable>T2</"
"replaceable> могут быть результатами соединения. Для однозначного "
"определения порядка соединений предложения <literal>JOIN</literal> можно "
"заключать в скобки. Если скобки отсутствуют, предложения <literal>JOIN</"
"literal> обрабатываются слева направо."

#: queries.xml:180(title)
msgid "Join Types"
msgstr "Типы соединений"

#: queries.xml:184(indexterm)
msgid "<primary>join</primary> <secondary>cross</secondary>"
msgstr "<primary>соединение</primary> <secondary>перекрёстное</secondary>"

#: queries.xml:189(indexterm)
msgid "<primary>cross join</primary>"
msgstr "<primary>перекрёстное соединение</primary>"

#: queries.xml:183(term)
msgid "Cross join <placeholder-1/> <placeholder-2/>"
msgstr "Перекрёстное соединение <placeholder-1/> <placeholder-2/>"

#: queries.xml:196(replaceable) queries.xml:253(replaceable)
#: queries.xml:254(replaceable) queries.xml:255(replaceable)
msgid "T1"
msgstr "T1"

#: queries.xml:196(replaceable) queries.xml:253(replaceable)
#: queries.xml:254(replaceable) queries.xml:255(replaceable)
msgid "T2"
msgstr "T2"

#: queries.xml:195(synopsis)
#, no-wrap
msgid "<placeholder-1/> CROSS JOIN <placeholder-2/>"
msgstr "<placeholder-1/> CROSS JOIN <placeholder-2/>"

#: queries.xml:199(para)
msgid ""
"For every possible combination of rows from <replaceable>T1</replaceable> "
"and <replaceable>T2</replaceable> (i.e., a Cartesian product), the joined "
"table will contain a row consisting of all columns in <replaceable>T1</"
"replaceable> followed by all columns in <replaceable>T2</replaceable>. If "
"the tables have N and M rows respectively, the joined table will have N * M "
"rows."
msgstr ""
"Соединённую таблицу образуют все возможные сочетания строк из "
"<replaceable>T1</replaceable> и <replaceable>T2</replaceable> (т. е. их "
"декартово произведение), а набор её столбцов объединяет в себе столбцы "
"<replaceable>T1</replaceable> со следующими за ними столбцами "
"<replaceable>T2</replaceable>. Если таблицы содержат N и M строк, "
"соединённая таблица будет содержать N * M строк."

#: queries.xml:219(para)
msgid ""
"This latter equivalence does not hold exactly when more than two tables "
"appear, because <literal>JOIN</literal> binds more tightly than comma. For "
"example <literal>FROM <replaceable>T1</replaceable> CROSS JOIN "
"<replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable> ON "
"<replaceable>condition</replaceable></literal> is not the same as "
"<literal>FROM <replaceable>T1</replaceable>, <replaceable>T2</replaceable> "
"INNER JOIN <replaceable>T3</replaceable> ON <replaceable>condition</"
"replaceable></literal> because the <replaceable>condition</replaceable> can "
"reference <replaceable>T1</replaceable> in the first case but not the second."
msgstr ""
"Последняя запись не полностью эквивалентна первым при указании более чем "
"двух таблиц, так как <literal>JOIN</literal> связывает таблицы сильнее, чем "
"запятая. Например, <literal>FROM <replaceable>T1</replaceable> CROSS JOIN "
"<replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable> ON "
"<replaceable>условие</replaceable></literal> не равнозначно <literal>FROM "
"<replaceable>T1</replaceable>, <replaceable>T2</replaceable> INNER JOIN "
"<replaceable>T3</replaceable> ON <replaceable>условие</replaceable></"
"literal>, так как <replaceable>условие</replaceable> может ссылаться на "
"<replaceable>T1</replaceable> в первом случае, но не во втором."

#: queries.xml:210(para)
msgid ""
"<literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</"
"replaceable></literal> is equivalent to <literal>FROM <replaceable>T1</"
"replaceable> INNER JOIN <replaceable>T2</replaceable> ON TRUE</literal> (see "
"below). It is also equivalent to <literal>FROM <replaceable>T1</"
"replaceable>, <replaceable>T2</replaceable></literal>. <placeholder-1/>"
msgstr ""
"<literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</"
"replaceable></literal> эквивалентно <literal>FROM <replaceable>T1</"
"replaceable> INNER JOIN <replaceable>T2</replaceable> ON TRUE</literal> (см. "
"ниже). Эта запись также эквивалентна <literal>FROM <replaceable>T1</"
"replaceable>, <replaceable>T2</replaceable></literal>. <placeholder-1/>"

#: queries.xml:241(indexterm)
msgid "<primary>join</primary> <secondary>outer</secondary>"
msgstr "<primary>соединение</primary> <secondary>внешнее</secondary>"

#: queries.xml:246(indexterm)
msgid "<primary>outer join</primary>"
msgstr "<primary>внешнее соединение</primary>"

#: queries.xml:240(term)
msgid "Qualified joins <placeholder-1/> <placeholder-2/>"
msgstr "Соединения с сопоставлениями строк <placeholder-1/> <placeholder-2/>"

#: queries.xml:253(optional) queries.xml:254(optional)
#: queries.xml:255(optional)
msgid "INNER"
msgstr "INNER"

#: queries.xml:253(optional) queries.xml:254(optional)
#: queries.xml:255(optional)
msgid "OUTER"
msgstr "OUTER"

#: queries.xml:253(replaceable)
msgid "boolean_expression"
msgstr "логическое_выражение"

#: queries.xml:254(replaceable)
msgid "join column list"
msgstr "список столбцов соединения"

#: queries.xml:252(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> { <placeholder-2/> | { LEFT | RIGHT | FULL } <placeholder-3/> } JOIN <placeholder-4/> ON <placeholder-5/>\n"
"<placeholder-6/> { <placeholder-7/> | { LEFT | RIGHT | FULL } <placeholder-8/> } JOIN <placeholder-9/> USING ( <placeholder-10/> )\n"
"<placeholder-11/> NATURAL { <placeholder-12/> | { LEFT | RIGHT | FULL } <placeholder-13/> } JOIN <placeholder-14/>"
msgstr ""
"<placeholder-1/> { <placeholder-2/> | { LEFT | RIGHT | FULL } <placeholder-3/> } JOIN <placeholder-4/>\n"
"  ON <placeholder-5/>\n"
"<placeholder-6/> { <placeholder-7/> | { LEFT | RIGHT | FULL } <placeholder-8/> } JOIN <placeholder-9/>\n"
"  USING ( <placeholder-10/> )\n"
"<placeholder-11/> NATURAL { <placeholder-12/> | { LEFT | RIGHT | FULL } <placeholder-13/> } JOIN <placeholder-14/>"

#: queries.xml:258(para)
msgid ""
"The words <literal>INNER</literal> and <literal>OUTER</literal> are optional "
"in all forms. <literal>INNER</literal> is the default; <literal>LEFT</"
"literal>, <literal>RIGHT</literal>, and <literal>FULL</literal> imply an "
"outer join."
msgstr ""
"Слова <literal>INNER</literal> и <literal>OUTER</literal> необязательны во "
"всех формах. По умолчанию подразумевается <literal>INNER</literal> "
"(внутреннее соединение), а при указании <literal>LEFT</literal>, "
"<literal>RIGHT</literal> и <literal>FULL</literal> &mdash; внешнее "
"соединение."

#: queries.xml:266(para)
msgid ""
"The <firstterm>join condition</firstterm> is specified in the <literal>ON</"
"literal> or <literal>USING</literal> clause, or implicitly by the word "
"<literal>NATURAL</literal>. The join condition determines which rows from "
"the two source tables are considered to <quote>match</quote>, as explained "
"in detail below."
msgstr ""
"<firstterm>Условие соединения</firstterm> указывается в предложении "
"<literal>ON</literal> или <literal>USING</literal>, либо неявно задаётся "
"ключевым словом <literal>NATURAL</literal>. Это условие определяет, какие "
"строки двух исходных таблиц считаются <quote>соответствующими</quote> друг "
"другу (это подробно рассматривается ниже)."

#: queries.xml:279(literal)
msgid "INNER JOIN"
msgstr "INNER JOIN"

#: queries.xml:282(para)
msgid ""
"For each row R1 of T1, the joined table has a row for each row in T2 that "
"satisfies the join condition with R1."
msgstr ""
"Для каждой строки R1 из T1 в результирующей таблице содержится строка для "
"каждой строки в T2, удовлетворяющей условию соединения с R1."

#: queries.xml:290(literal)
msgid "LEFT OUTER JOIN"
msgstr "LEFT OUTER JOIN"

#: queries.xml:291(indexterm)
msgid "<primary>join</primary> <secondary>left</secondary>"
msgstr "<primary>соединение</primary> <secondary>левое</secondary>"

#: queries.xml:296(indexterm)
msgid "<primary>left join</primary>"
msgstr "<primary>левое соединение</primary>"

#: queries.xml:302(para)
msgid ""
"First, an inner join is performed. Then, for each row in T1 that does not "
"satisfy the join condition with any row in T2, a joined row is added with "
"null values in columns of T2. Thus, the joined table always has at least one "
"row for each row in T1."
msgstr ""
"Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат "
"добавляются все строки из T1, которым не соответствуют никакие строки в T2, "
"а вместо значений столбцов T2 вставляются NULL. Таким образом, в "
"результирующей таблице всегда будет минимум одна строка для каждой строки из "
"T1."

#: queries.xml:313(literal)
msgid "RIGHT OUTER JOIN"
msgstr "RIGHT OUTER JOIN"

#: queries.xml:314(indexterm)
msgid "<primary>join</primary> <secondary>right</secondary>"
msgstr "<primary>соединение</primary> <secondary>справа</secondary>"

#: queries.xml:319(indexterm)
msgid "<primary>right join</primary>"
msgstr "<primary>правое соединение</primary>"

#: queries.xml:325(para)
msgid ""
"First, an inner join is performed. Then, for each row in T2 that does not "
"satisfy the join condition with any row in T1, a joined row is added with "
"null values in columns of T1. This is the converse of a left join: the "
"result table will always have a row for each row in T2."
msgstr ""
"Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат "
"добавляются все строки из T2, которым не соответствуют никакие строки в T1, "
"а вместо значений столбцов T1 вставляются NULL. Это соединение является "
"обратным к левому (LEFT JOIN): в результирующей таблице всегда будет минимум "
"одна строка для каждой строки из T2."

#: queries.xml:336(literal)
msgid "FULL OUTER JOIN"
msgstr "FULL OUTER JOIN"

#: queries.xml:339(para)
msgid ""
"First, an inner join is performed. Then, for each row in T1 that does not "
"satisfy the join condition with any row in T2, a joined row is added with "
"null values in columns of T2. Also, for each row of T2 that does not satisfy "
"the join condition with any row in T1, a joined row with null values in the "
"columns of T1 is added."
msgstr ""
"Сначала выполняется внутреннее соединение. Затем в результат добавляются все "
"строки из T1, которым не соответствуют никакие строки в T2, а вместо "
"значений столбцов T2 вставляются NULL. И наконец, в результат включаются все "
"строки из T2, которым не соответствуют никакие строки в T1, а вместо "
"значений столбцов T1 вставляются NULL."

#: queries.xml:274(para)
msgid "The possible types of qualified join are: <placeholder-1/>"
msgstr "Возможные типы соединений с сопоставлениями строк: <placeholder-1/>"

#: queries.xml:352(para)
msgid ""
"The <literal>ON</literal> clause is the most general kind of join condition: "
"it takes a Boolean value expression of the same kind as is used in a "
"<literal>WHERE</literal> clause. A pair of rows from <replaceable>T1</"
"replaceable> and <replaceable>T2</replaceable> match if the <literal>ON</"
"literal> expression evaluates to true."
msgstr ""
"Предложение <literal>ON</literal> определяет наиболее общую форму условия "
"соединения: в нём указываются выражения логического типа, подобные тем, что "
"используются в предложении <literal>WHERE</literal>. Пара строк из "
"<replaceable>T1</replaceable> и <replaceable>T2</replaceable> соответствуют "
"друг другу, если выражение <literal>ON</literal> возвращает для них true."

#: queries.xml:360(para)
msgid ""
"The <literal>USING</literal> clause is a shorthand that allows you to take "
"advantage of the specific situation where both sides of the join use the "
"same name for the joining column(s). It takes a comma-separated list of the "
"shared column names and forms a join condition that includes an equality "
"comparison for each one. For example, joining <replaceable>T1</replaceable> "
"and <replaceable>T2</replaceable> with <literal>USING (a, b)</literal> "
"produces the join condition <literal>ON <replaceable>T1</replaceable>.a = "
"<replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b = "
"<replaceable>T2</replaceable>.b</literal>."
msgstr ""
"<literal>USING</literal> &mdash; это сокращённая запись условия, полезная в "
"ситуации, когда с обеих сторон соединения столбцы имеют одинаковые имена. "
"Она принимает список общих имён столбцов через запятую и формирует условие "
"соединения с равенством этих столбцов. Например, запись соединения "
"<replaceable>T1</replaceable> и <replaceable>T2</replaceable> с "
"<literal>USING (a, b)</literal> формирует условие <literal>ON "
"<replaceable>T1</replaceable>.a = <replaceable>T2</replaceable>.a AND "
"<replaceable>T1</replaceable>.b = <replaceable>T2</replaceable>.b</literal>."

#: queries.xml:373(para)
msgid ""
"Furthermore, the output of <literal>JOIN USING</literal> suppresses "
"redundant columns: there is no need to print both of the matched columns, "
"since they must have equal values. While <literal>JOIN ON</literal> produces "
"all columns from <replaceable>T1</replaceable> followed by all columns from "
"<replaceable>T2</replaceable>, <literal>JOIN USING</literal> produces one "
"output column for each of the listed column pairs (in the listed order), "
"followed by any remaining columns from <replaceable>T1</replaceable>, "
"followed by any remaining columns from <replaceable>T2</replaceable>."
msgstr ""
"Более того, при выводе <literal>JOIN USING</literal> исключаются избыточные "
"столбцы: оба сопоставленных столбца выводить не нужно, так как они содержат "
"одинаковые значения. Тогда как <literal>JOIN ON</literal> выдаёт все столбцы "
"из <replaceable>T1</replaceable>, а за ними все столбцы из <replaceable>T2</"
"replaceable>, <literal>JOIN USING</literal> выводит один столбец для каждой "
"пары (в указанном порядке), за ними все оставшиеся столбцы из "
"<replaceable>T1</replaceable> и, наконец, все оставшиеся столбцы "
"<replaceable>T2</replaceable>."

#: queries.xml:385(indexterm)
msgid "<primary>join</primary> <secondary>natural</secondary>"
msgstr "<primary>соединение</primary> <secondary>естественное</secondary>"

#: queries.xml:389(indexterm)
msgid "<primary>natural join</primary>"
msgstr "<primary>естественное соединение</primary>"

#: queries.xml:384(para)
msgid ""
"<placeholder-1/> <placeholder-2/> Finally, <literal>NATURAL</literal> is a "
"shorthand form of <literal>USING</literal>: it forms a <literal>USING</"
"literal> list consisting of all column names that appear in both input "
"tables. As with <literal>USING</literal>, these columns appear only once in "
"the output table. If there are no common column names, <literal>NATURAL "
"JOIN</literal> behaves like <literal>JOIN ... ON TRUE</literal>, producing a "
"cross-product join."
msgstr ""
"<placeholder-1/> <placeholder-2/> Наконец, <literal>NATURAL</literal> "
"&mdash; сокращённая форма <literal>USING</literal>: она образует список "
"<literal>USING</literal> из всех имён столбцов, существующих в обеих входных "
"таблицах. Как и с <literal>USING</literal>, эти столбцы оказываются в "
"выходной таблице в единственном экземпляре. Если столбцов с одинаковыми "
"именами не находится, <literal>NATURAL JOIN</literal> действует как "
"<literal>JOIN ... ON TRUE</literal> и выдаёт декартово произведение строк."

#: queries.xml:402(para)
msgid ""
"<literal>USING</literal> is reasonably safe from column changes in the "
"joined relations since only the listed columns are combined. "
"<literal>NATURAL</literal> is considerably more risky since any schema "
"changes to either relation that cause a new matching column name to be "
"present will cause the join to combine that new column as well."
msgstr ""
"Предложение <literal>USING</literal> разумно защищено от изменений в "
"соединяемых отношениях, так как оно связывает только явно перечисленные "
"столбцы. <literal>NATURAL</literal> считается более рискованным, так как при "
"любом изменении схемы в одном или другом отношении, когда появляются столбцы "
"с совпадающими именами, при соединении будут связываться и эти новые столбцы."

#: queries.xml:417(programlisting)
#, no-wrap
msgid ""
" num | name\n"
"-----+------\n"
"   1 | a\n"
"   2 | b\n"
"   3 | c"
msgstr ""
" num | name\n"
"-----+------\n"
"   1 | a\n"
"   2 | b\n"
"   3 | c"

#: queries.xml:425(programlisting)
#, no-wrap
msgid ""
" num | value\n"
"-----+-------\n"
"   1 | xxx\n"
"   3 | yyy\n"
"   5 | zzz"
msgstr ""
" num | value\n"
"-----+-------\n"
"   1 | xxx\n"
"   3 | yyy\n"
"   5 | zzz"

#: queries.xml:415(para)
msgid ""
"To put this together, assume we have tables <literal>t1</literal>: "
"<placeholder-1/> and <literal>t2</literal>: <placeholder-2/> then we get the "
"following results for the various joins: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</"
"userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   1 | a    |   3 | yyy\n"
"   1 | a    |   5 | zzz\n"
"   2 | b    |   1 | xxx\n"
"   2 | b    |   3 | yyy\n"
"   2 | b    |   5 | zzz\n"
"   3 | c    |   1 | xxx\n"
"   3 | c    |   3 | yyy\n"
"   3 | c    |   5 | zzz\n"
"(9 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   3 | c    |   3 | yyy\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);"
"</userinput>\n"
" num | name | value\n"
"-----+------+-------\n"
"   1 | a    | xxx\n"
"   3 | c    | yyy\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</"
"userinput>\n"
" num | name | value\n"
"-----+------+-------\n"
"   1 | a    | xxx\n"
"   3 | c    | yyy\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   2 | b    |     |\n"
"   3 | c    |   3 | yyy\n"
"(3 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);"
"</userinput>\n"
" num | name | value\n"
"-----+------+-------\n"
"   1 | a    | xxx\n"
"   2 | b    |\n"
"   3 | c    | yyy\n"
"(3 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   3 | c    |   3 | yyy\n"
"     |      |   5 | zzz\n"
"(3 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   2 | b    |     |\n"
"   3 | c    |   3 | yyy\n"
"     |      |   5 | zzz\n"
"(4 rows)\n"
"</screen>"
msgstr ""
"Для наглядности предположим, что у нас есть таблицы <literal>t1</literal>: "
"<placeholder-1/> и <literal>t2</literal>: <placeholder-2/> С ними для разных "
"типов соединений мы получим следующие результаты: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</"
"userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   1 | a    |   3 | yyy\n"
"   1 | a    |   5 | zzz\n"
"   2 | b    |   1 | xxx\n"
"   2 | b    |   3 | yyy\n"
"   2 | b    |   5 | zzz\n"
"   3 | c    |   1 | xxx\n"
"   3 | c    |   3 | yyy\n"
"   3 | c    |   5 | zzz\n"
"(9 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   3 | c    |   3 | yyy\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);"
"</userinput>\n"
" num | name | value\n"
"-----+------+-------\n"
"   1 | a    | xxx\n"
"   3 | c    | yyy\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</"
"userinput>\n"
" num | name | value\n"
"-----+------+-------\n"
"   1 | a    | xxx\n"
"   3 | c    | yyy\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   2 | b    |     |\n"
"   3 | c    |   3 | yyy\n"
"(3 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);"
"</userinput>\n"
" num | name | value\n"
"-----+------+-------\n"
"   1 | a    | xxx\n"
"   2 | b    |\n"
"   3 | c    | yyy\n"
"(3 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   3 | c    |   3 | yyy\n"
"     |      |   5 | zzz\n"
"(3 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = "
"t2.num;</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   2 | b    |     |\n"
"   3 | c    |   3 | yyy\n"
"     |      |   5 | zzz\n"
"(4 rows)\n"
"</screen>"

#: queries.xml:504(para)
msgid ""
"The join condition specified with <literal>ON</literal> can also contain "
"conditions that do not relate directly to the join. This can prove useful "
"for some queries but needs to be thought out carefully. For example: "
"<screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = "
"t2.num AND t2.value = 'xxx';</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   2 | b    |     |\n"
"   3 | c    |     |\n"
"(3 rows)\n"
"</screen> Notice that placing the restriction in the <literal>WHERE</"
"literal> clause produces a different result: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = "
"t2.num WHERE t2.value = 'xxx';</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"(1 row)\n"
"</screen> This is because a restriction placed in the <literal>ON</literal> "
"clause is processed <emphasis>before</emphasis> the join, while a "
"restriction placed in the <literal>WHERE</literal> clause is processed "
"<emphasis>after</emphasis> the join. That does not matter with inner joins, "
"but it matters a lot with outer joins."
msgstr ""
"Условие соединения в предложении <literal>ON</literal> может также содержать "
"выражения, не связанные непосредственно с соединением. Это может быть "
"полезно в некоторых запросах, но не следует использовать это необдуманно. "
"Рассмотрите следующий запрос: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = "
"t2.num AND t2.value = 'xxx';</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"   2 | b    |     |\n"
"   3 | c    |     |\n"
"(3 rows)\n"
"</screen> Заметьте, что если поместить ограничение в предложение "
"<literal>WHERE</literal>, вы получите другой результат: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = "
"t2.num WHERE t2.value = 'xxx';</userinput>\n"
" num | name | num | value\n"
"-----+------+-----+-------\n"
"   1 | a    |   1 | xxx\n"
"(1 row)\n"
"</screen> Это связано с тем, что ограничение, помещённое в предложение "
"<literal>ON</literal>, обрабатывается <emphasis>до</emphasis> операции "
"соединения, тогда как ограничение в <literal>WHERE</literal> &mdash; "
"<emphasis>после</emphasis>. Это не имеет значения при внутренних "
"соединениях, но важно при внешних."

#: queries.xml:537(title)
msgid "Table and Column Aliases"
msgstr "Псевдонимы таблиц и столбцов"

#: queries.xml:539(indexterm)
msgid "<primary>alias</primary> <secondary>in the FROM clause</secondary>"
msgstr "<primary>псевдоним</primary> <secondary>в предложении FROM</secondary>"

#: queries.xml:544(indexterm)
msgid "<primary>label</primary> <see>alias</see>"
msgstr "<primary>метка</primary> <see>псевдоним</see>"

#: queries.xml:549(para)
msgid ""
"A temporary name can be given to tables and complex table references to be "
"used for references to the derived table in the rest of the query. This is "
"called a <firstterm>table alias</firstterm>."
msgstr ""
"Таблицам и ссылкам на сложные таблицы в запросе можно дать временное имя, по "
"которому к ним можно будет обращаться в рамках запроса. Такое имя называется "
"<firstterm>псевдонимом таблицы</firstterm>."

#: queries.xml:556(para)
msgid ""
"To create a table alias, write <synopsis>\n"
"FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</"
"replaceable>\n"
"</synopsis> or <synopsis>\n"
"FROM <replaceable>table_reference</replaceable> <replaceable>alias</"
"replaceable>\n"
"</synopsis> The <literal>AS</literal> key word is optional noise. "
"<replaceable>alias</replaceable> can be any identifier."
msgstr ""
"Определить псевдоним таблицы можно, написав <synopsis>\n"
"FROM <replaceable>табличная_ссылка</replaceable> AS <replaceable>псевдоним</"
"replaceable>\n"
"</synopsis> или <synopsis>\n"
"FROM <replaceable>табличная_ссылка</replaceable> <replaceable>псевдоним</"
"replaceable>\n"
"</synopsis> Ключевое слово <literal>AS</literal> является необязательным. "
"Вместо <replaceable>псевдоним</replaceable> здесь может быть любой "
"идентификатор."

#: queries.xml:573(programlisting)
#, no-wrap
msgid "SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;"
msgstr ""
"SELECT * FROM \"очень_длинное_имя_таблицы\" s JOIN \"другое_длинное_имя\" a\n"
"  ON s.id = a.num;"

#: queries.xml:569(para)
msgid ""
"A typical application of table aliases is to assign short identifiers to "
"long table names to keep the join clauses readable. For example: "
"<placeholder-1/>"
msgstr ""
"Псевдонимы часто применяются для назначения коротких идентификаторов длинным "
"именам таблиц с целью улучшения читаемости запросов. Например: "
"<placeholder-1/>"

#: queries.xml:583(programlisting)
#, no-wrap
msgid "SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- wrong"
msgstr "SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- неправильно"

#: queries.xml:578(para)
msgid ""
"The alias becomes the new name of the table reference so far as the current "
"query is concerned &mdash; it is not allowed to refer to the table by the "
"original name elsewhere in the query. Thus, this is not valid: "
"<placeholder-1/>"
msgstr ""
"Псевдоним становится новым именем таблицы в рамках текущего запроса, т. е. "
"после назначения псевдонима использовать исходное имя таблицы в другом месте "
"запроса нельзя. Таким образом, следующий запрос недопустим: <placeholder-1/>"

#: queries.xml:591(programlisting)
#, no-wrap
msgid "SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;"
msgstr ""
"SELECT * FROM people AS mother JOIN people AS child\n"
"  ON mother.id = child.mother_id;"

#: queries.xml:588(para)
msgid ""
"Table aliases are mainly for notational convenience, but it is necessary to "
"use them when joining a table to itself, e.g.: <placeholder-1/> "
"Additionally, an alias is required if the table reference is a subquery (see "
"<xref linkend=\"queries-subqueries\"/>)."
msgstr ""
"Хотя в основном псевдонимы используются для удобства, они бывают необходимы, "
"когда таблица соединяется сама с собой, например: <placeholder-1/> Кроме "
"того, псевдонимы обязательно нужно назначать подзапросам (см. <xref remap="
"\"4\" linkend=\"queries-subqueries\"/>)."

#: queries.xml:603(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...\n"
"SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ..."
msgstr ""
"SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...\n"
"SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ..."

#: queries.xml:598(para)
msgid ""
"Parentheses are used to resolve ambiguities. In the following example, the "
"first statement assigns the alias <literal>b</literal> to the second "
"instance of <literal>my_table</literal>, but the second statement assigns "
"the alias to the result of the join: <placeholder-1/>"
msgstr ""
"В случае неоднозначности определения псевдонимов можно использовать скобки. "
"В следующем примере первый оператор назначает псевдоним <literal>b</literal> "
"второму экземпляру <literal>my_table</literal>, а второй оператор назначает "
"псевдоним результату соединения: <placeholder-1/>"

#: queries.xml:609(para)
msgid ""
"Another form of table aliasing gives temporary names to the columns of the "
"table, as well as the table itself: <synopsis>\n"
"FROM <replaceable>table_reference</replaceable> <optional>AS</optional> "
"<replaceable>alias</replaceable> ( <replaceable>column1</replaceable> "
"<optional>, <replaceable>column2</replaceable> <optional>, ...</optional></"
"optional> )\n"
"</synopsis> If fewer column aliases are specified than the actual table has "
"columns, the remaining columns are not renamed. This syntax is especially "
"useful for self-joins or subqueries."
msgstr ""
"В другой форме назначения псевдонима временные имена даются не только "
"таблицам, но и её столбцам: <synopsis>\n"
"FROM <replaceable>табличная_ссылка</replaceable> <optional>AS</optional> "
"<replaceable>псевдоним</replaceable> ( <replaceable>столбец1</replaceable> "
"<optional>, <replaceable>столбец2</replaceable> <optional>, ...</optional></"
"optional> )\n"
"</synopsis> Если псевдонимов столбцов оказывается меньше, чем фактически "
"столбцов в таблице, остальные столбцы сохраняют свои исходные имена. Эта "
"запись особенно полезна для замкнутых соединений или подзапросов."

#: queries.xml:624(programlisting)
#, no-wrap
msgid "SELECT a.* FROM my_table AS a JOIN your_table AS b ON ..."
msgstr "SELECT a.* FROM my_table AS a JOIN your_table AS b ON ..."

#: queries.xml:628(programlisting)
#, no-wrap
msgid "SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c"
msgstr "SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c"

#: queries.xml:620(para)
msgid ""
"When an alias is applied to the output of a <literal>JOIN</literal> clause, "
"the alias hides the original name(s) within the <literal>JOIN</literal>. For "
"example: <placeholder-1/> is valid SQL, but: <placeholder-2/> is not valid; "
"the table alias <literal>a</literal> is not visible outside the alias "
"<literal>c</literal>."
msgstr ""
"Когда псевдоним применяется к результату <literal>JOIN</literal>, он "
"скрывает оригинальные имена таблиц внутри <literal>JOIN</literal>. Например, "
"это допустимый SQL-запрос: <placeholder-1/>а запрос: <placeholder-2/> "
"ошибочный, так как псевдоним таблицы <literal>a</literal> не виден снаружи "
"определения псевдонима <literal>c</literal>."

#: queries.xml:637(title)
msgid "Subqueries"
msgstr "Подзапросы"

#: queries.xml:639(indexterm)
msgid "<primary>subquery</primary>"
msgstr "<primary>подзапрос</primary>"

#: queries.xml:648(programlisting)
#, no-wrap
msgid "FROM (SELECT * FROM table1) AS alias_name"
msgstr "FROM (SELECT * FROM table1) AS псевдоним"

#: queries.xml:643(para)
msgid ""
"Subqueries specifying a derived table must be enclosed in parentheses and "
"<emphasis>must</emphasis> be assigned a table alias name (as in <xref "
"linkend=\"queries-table-aliases\"/>). For example: <placeholder-1/>"
msgstr ""
"Подзапросы, образующие таблицы, должны заключаться в скобки и им "
"<emphasis>обязательно</emphasis> должны назначаться псевдонимы (как описано "
"в <xref remap=\"6\" linkend=\"queries-table-aliases\"/>). Например: "
"<placeholder-1/>"

#: queries.xml:653(para)
msgid ""
"This example is equivalent to <literal>FROM table1 AS alias_name</literal>. "
"More interesting cases, which cannot be reduced to a plain join, arise when "
"the subquery involves grouping or aggregation."
msgstr ""
"Этот пример равносилен записи <literal>FROM table1 AS псевдоним</literal>. "
"Более интересные ситуации, которые нельзя свести к простому соединению, "
"возникают, когда в подзапросе используются агрегирующие функции или "
"группировка."

#: queries.xml:662(programlisting)
#, no-wrap
msgid ""
"FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))\n"
"     AS names(first, last)"
msgstr ""
"FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))\n"
"     AS names(first, last)"

#: queries.xml:660(para)
msgid ""
"A subquery can also be a <command>VALUES</command> list: <placeholder-1/> "
"Again, a table alias is required. Assigning alias names to the columns of "
"the <command>VALUES</command> list is optional, but is good practice. For "
"more information see <xref linkend=\"queries-values\"/>."
msgstr ""
"Подзапросом может также быть список <command>VALUES</command>: "
"<placeholder-1/> Такому подзапросу тоже требуется псевдоним. Назначать "
"псевдонимы столбцам списка <command>VALUES</command> не требуется, но вообще "
"это хороший приём. Подробнее это описано в <xref remap=\"6\" linkend="
"\"queries-values\"/>."

#: queries.xml:673(title)
msgid "Table Functions"
msgstr "Табличные функции"

#: queries.xml:675(indexterm)
msgid "<primary>table function</primary>"
msgstr "<primary>табличная функция</primary>"

#: queries.xml:677(indexterm)
msgid "<primary>function</primary> <secondary>in the FROM clause</secondary>"
msgstr "<primary>функция</primary> <secondary>в предложении FROM</secondary>"

#: queries.xml:682(para)
msgid ""
"Table functions are functions that produce a set of rows, made up of either "
"base data types (scalar types) or composite data types (table rows). They "
"are used like a table, view, or subquery in the <literal>FROM</literal> "
"clause of a query. Columns returned by table functions can be included in "
"<literal>SELECT</literal>, <literal>JOIN</literal>, or <literal>WHERE</"
"literal> clauses in the same manner as columns of a table, view, or subquery."
msgstr ""
"Табличные функции &mdash; это функции, выдающие набор строк, содержащих либо "
"базовые типы данных (скалярных типов), либо составные типы (табличные "
"строки). Они применяются в запросах как таблицы, представления или "
"подзапросы в предложении <literal>FROM</literal>. Столбцы, возвращённые "
"табличными функциями, можно включить в выражения <literal>SELECT</literal>, "
"<literal>JOIN</literal> или <literal>WHERE</literal> так же, как столбцы "
"таблиц, представлений или подзапросов."

#: queries.xml:692(para)
msgid ""
"Table functions may also be combined using the <literal>ROWS FROM</literal> "
"syntax, with the results returned in parallel columns; the number of result "
"rows in this case is that of the largest function result, with smaller "
"results padded with null values to match."
msgstr ""
"Табличные функции можно также скомбинировать, используя запись <literal>ROWS "
"FROM</literal>. Результаты функций будут возвращены в параллельных столбцах; "
"число строк в этом случае будет наибольшим из результатов всех функций, а "
"результаты функций с меньшим количеством строк будут дополнены значениями "
"NULL."

#: queries.xml:700(replaceable) queries.xml:701(replaceable)
#: queries.xml:775(replaceable) queries.xml:776(replaceable)
#: queries.xml:777(replaceable)
msgid "function_call"
msgstr "вызов_функции"

#: queries.xml:700(optional) queries.xml:701(optional)
#: queries.xml:724(optional)
msgid "WITH ORDINALITY"
msgstr "WITH ORDINALITY"

#: queries.xml:700(optional) queries.xml:701(optional)
#: queries.xml:724(optional) queries.xml:775(optional)
msgid "AS"
msgstr "AS"

#: queries.xml:700(replaceable) queries.xml:701(replaceable)
#: queries.xml:724(replaceable)
msgid "table_alias"
msgstr "псевдоним_таблицы"

#: queries.xml:700(replaceable) queries.xml:701(replaceable)
#: queries.xml:724(replaceable)
msgid "column_alias"
msgstr "псевдоним_столбца"

#: queries.xml:700(optional) queries.xml:701(optional)
#: queries.xml:724(optional) queries.xml:775(optional)
#: queries.xml:776(optional) queries.xml:777(optional)
msgid ", ..."
msgstr ", ..."

#: queries.xml:700(optional) queries.xml:701(optional)
#: queries.xml:724(optional)
msgid "(<placeholder-1/> <placeholder-2/>)"
msgstr "(<placeholder-1/> <placeholder-2/>)"

#: queries.xml:699(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> <placeholder-2/> <optional><placeholder-3/> <placeholder-4/> <placeholder-5/></optional>\n"
"ROWS FROM( <placeholder-6/> <placeholder-7/> ) <placeholder-8/> <optional><placeholder-9/> <placeholder-10/> <placeholder-11/></optional>"
msgstr ""
"<placeholder-1/> <placeholder-2/> <optional><placeholder-3/> <placeholder-4/> <placeholder-5/></optional>\n"
"ROWS FROM( <placeholder-6/> <placeholder-7/> ) <placeholder-8/> <optional><placeholder-9/> <placeholder-10/> <placeholder-11/></optional>"

#: queries.xml:704(para)
msgid ""
"If the <literal>WITH ORDINALITY</literal> clause is specified, an additional "
"column of type <type>bigint</type> will be added to the function result "
"columns. This column numbers the rows of the function result set, starting "
"from 1. (This is a generalization of the SQL-standard syntax for "
"<literal>UNNEST ... WITH ORDINALITY</literal>.) By default, the ordinal "
"column is called <literal>ordinality</literal>, but a different column name "
"can be assigned to it using an <literal>AS</literal> clause."
msgstr ""
"Если указано предложение <literal>WITH ORDINALITY</literal>, к столбцам "
"результатов функций будет добавлен ещё один, с типом <type>bigint</type>. В "
"этом столбце нумеруются строки результирующего набора, начиная с 1. (Это "
"обобщение стандартного SQL-синтаксиса <literal>UNNEST ... WITH ORDINALITY</"
"literal>.) По умолчанию, этот столбец называется <literal>ordinality</"
"literal>, но ему можно присвоить и другое имя с помощью указания "
"<literal>AS</literal>."

#: queries.xml:715(para)
msgid ""
"The special table function <literal>UNNEST</literal> may be called with any "
"number of array parameters, and it returns a corresponding number of "
"columns, as if <literal>UNNEST</literal> (<xref linkend=\"functions-array\"/"
">) had been called on each parameter separately and combined using the "
"<literal>ROWS FROM</literal> construct."
msgstr ""
"Специальную табличную функцию <literal>UNNEST</literal> можно вызвать с "
"любым числом параметров-массивов, а возвращает она соответствующее число "
"столбцов, как если бы <literal>UNNEST</literal> (<xref linkend=\"functions-"
"array\"/>) вызывалась для каждого параметра в отдельности, а результаты "
"объединялись с помощью конструкции <literal>ROWS FROM</literal>."

#: queries.xml:724(replaceable)
msgid "array_expression"
msgstr "выражение_массива"

#: queries.xml:723(synopsis)
#, no-wrap
msgid "UNNEST( <placeholder-1/> <placeholder-2/> ) <placeholder-3/> <optional><placeholder-4/> <placeholder-5/> <placeholder-6/></optional>"
msgstr "UNNEST( <placeholder-1/> <placeholder-2/> ) <placeholder-3/> <optional><placeholder-4/> <placeholder-5/> <placeholder-6/></optional>"

#: queries.xml:727(para)
msgid ""
"If no <replaceable>table_alias</replaceable> is specified, the function name "
"is used as the table name; in the case of a <literal>ROWS FROM()</literal> "
"construct, the first function's name is used."
msgstr ""
"Если <replaceable>псевдоним_таблицы</replaceable> не указан, в качестве "
"имени таблицы используется имя функции; в случае с конструкцией "
"<literal>ROWS FROM()</literal> &mdash; имя первой функции."

#: queries.xml:733(para)
msgid ""
"If column aliases are not supplied, then for a function returning a base "
"data type, the column name is also the same as the function name. For a "
"function returning a composite type, the result columns get the names of the "
"individual attributes of the type."
msgstr ""
"Если псевдонимы столбцов не указаны, то для функции, возвращающей базовый "
"тип данных, именем столбца будет имя функции. Для функций, возвращающих "
"составной тип, имена результирующих столбцов определяются индивидуальными "
"атрибутами типа."

#: queries.xml:742(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE foo (fooid int, foosubid int, fooname text);\n"
"\n"
"CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n"
"    SELECT * FROM foo WHERE fooid = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM getfoo(1) AS t1;\n"
"\n"
"SELECT * FROM foo\n"
"    WHERE foosubid IN (\n"
"                        SELECT foosubid\n"
"                        FROM getfoo(foo.fooid) z\n"
"                        WHERE z.fooid = foo.fooid\n"
"                      );\n"
"\n"
"CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);\n"
"\n"
"SELECT * FROM vw_getfoo;"
msgstr ""
"CREATE TABLE foo (fooid int, foosubid int, fooname text);\n"
"\n"
"CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n"
"    SELECT * FROM foo WHERE fooid = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM getfoo(1) AS t1;\n"
"\n"
"SELECT * FROM foo\n"
"    WHERE foosubid IN (\n"
"                        SELECT foosubid\n"
"                        FROM getfoo(foo.fooid) z\n"
"                        WHERE z.fooid = foo.fooid\n"
"                      );\n"
"\n"
"CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);\n"
"\n"
"SELECT * FROM vw_getfoo;"

#: queries.xml:740(para)
msgid "Some examples: <placeholder-1/>"
msgstr "Несколько примеров: <placeholder-1/>"

#: queries.xml:764(para)
msgid ""
"In some cases it is useful to define table functions that can return "
"different column sets depending on how they are invoked. To support this, "
"the table function can be declared as returning the pseudotype <type>record</"
"type>. When such a function is used in a query, the expected row structure "
"must be specified in the query itself, so that the system can know how to "
"parse and plan the query. This syntax looks like:"
msgstr ""
"В некоторых случаях бывает удобно определить табличную функцию, возвращающую "
"различные наборы столбцов при разных вариантах вызова. Для этого нужно "
"указать, что она возвращает псевдотип <type>record</type>. Используя такую "
"функцию, ожидаемую структуру строк нужно описать в самом запросе, чтобы "
"система знала, как разобрать запрос и составить его план. Записывается это "
"так:"

#: queries.xml:775(replaceable) queries.xml:776(replaceable)
msgid "alias"
msgstr "псевдоним"

#: queries.xml:775(replaceable) queries.xml:776(replaceable)
#: queries.xml:777(replaceable)
msgid "column_definition"
msgstr "определение_столбца"

#: queries.xml:774(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> (<placeholder-4/> <placeholder-5/>)\n"
"<placeholder-6/> AS <optional><placeholder-7/></optional> (<placeholder-8/> <placeholder-9/>)\n"
"ROWS FROM( ... <placeholder-10/> AS (<placeholder-11/> <placeholder-12/>) <placeholder-13/> )"
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> (<placeholder-4/> <placeholder-5/>)\n"
"<placeholder-6/> AS <optional><placeholder-7/></optional> (<placeholder-8/> <placeholder-9/>)\n"
"ROWS FROM( ... <placeholder-10/> AS (<placeholder-11/> <placeholder-12/>) <placeholder-13/> )"

#: queries.xml:780(para)
msgid ""
"When not using the <literal>ROWS FROM()</literal> syntax, the "
"<replaceable>column_definition</replaceable> list replaces the column alias "
"list that could otherwise be attached to the <literal>FROM</literal> item; "
"the names in the column definitions serve as column aliases. When using the "
"<literal>ROWS FROM()</literal> syntax, a <replaceable>column_definition</"
"replaceable> list can be attached to each member function separately; or if "
"there is only one member function and no <literal>WITH ORDINALITY</literal> "
"clause, a <replaceable>column_definition</replaceable> list can be written "
"in place of a column alias list following <literal>ROWS FROM()</literal>."
msgstr ""
"Без <literal>ROWS FROM()</literal> список <replaceable>определения_столбцов</"
"replaceable> заменяет список псевдонимов, который можно также добавить в "
"предложении <literal>FROM</literal>; имена в определениях столбцов служат "
"псевдонимами. С <literal>ROWS FROM()</literal> список "
"<replaceable>определения_столбцов</replaceable> можно добавить к каждой "
"функции отдельно, либо в случае с одной функцией и без предложения "
"<literal>WITH ORDINALITY</literal>, список "
"<replaceable>определения_столбцов</replaceable> можно записать вместо списка "
"с псевдонимами столбцов после <literal>ROWS FROM()</literal>."

#: queries.xml:795(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')\n"
"      AS t1(proname name, prosrc text)\n"
"    WHERE proname LIKE 'bytea%';"
msgstr ""
"SELECT *\n"
"    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')\n"
"      AS t1(proname name, prosrc text)\n"
"    WHERE proname LIKE 'bytea%';"

#: queries.xml:793(para)
msgid ""
"Consider this example: <placeholder-1/> The <xref linkend=\"contrib-dblink-"
"function\"/> function (part of the <xref linkend=\"dblink\"/> module) "
"executes a remote query. It is declared to return <type>record</type> since "
"it might be used for any kind of query. The actual column set must be "
"specified in the calling query so that the parser knows, for example, what "
"<literal>*</literal> should expand to."
msgstr ""
"Взгляните на этот пример: <placeholder-1/> Здесь функция <xref linkend="
"\"contrib-dblink-function\"/> (из модуля <xref linkend=\"dblink\"/>) "
"выполняет удалённый запрос. Она объявлена как функция, возвращающая тип "
"<type>record</type>, так как он подойдёт для запроса любого типа. В этом "
"случае фактический набор столбцов функции необходимо описать в вызывающем её "
"запросе, чтобы анализатор запроса знал, например, как преобразовать "
"<literal>*</literal>."

#: queries.xml:812(title)
msgid "<literal>LATERAL</literal> Subqueries"
msgstr "Подзапросы <literal>LATERAL</literal>"

#: queries.xml:814(indexterm)
msgid "<primary>LATERAL</primary> <secondary>in the FROM clause</secondary>"
msgstr "<primary>LATERAL</primary> <secondary>в предложении FROM</secondary>"

#: queries.xml:819(para)
msgid ""
"Subqueries appearing in <literal>FROM</literal> can be preceded by the key "
"word <literal>LATERAL</literal>. This allows them to reference columns "
"provided by preceding <literal>FROM</literal> items. (Without "
"<literal>LATERAL</literal>, each subquery is evaluated independently and so "
"cannot cross-reference any other <literal>FROM</literal> item.)"
msgstr ""
"Перед подзапросами в предложении <literal>FROM</literal> можно добавить "
"ключевое слово <literal>LATERAL</literal>. Это позволит ссылаться в них на "
"столбцы предшествующих элементов списка <literal>FROM</literal>. (Без "
"<literal>LATERAL</literal> каждый подзапрос выполняется независимо и поэтому "
"не может обращаться к другим элементам <literal>FROM</literal>.)"

#: queries.xml:828(para)
msgid ""
"Table functions appearing in <literal>FROM</literal> can also be preceded by "
"the key word <literal>LATERAL</literal>, but for functions the key word is "
"optional; the function's arguments can contain references to columns "
"provided by preceding <literal>FROM</literal> items in any case."
msgstr ""
"Перед табличными функциями в предложении <literal>FROM</literal> также можно "
"указать <literal>LATERAL</literal>, но для них это ключевое слово "
"необязательно; в аргументах функций в любом случае можно обращаться к "
"столбцам в предыдущих элементах <literal>FROM</literal>."

#: queries.xml:835(para)
msgid ""
"A <literal>LATERAL</literal> item can appear at top level in the "
"<literal>FROM</literal> list, or within a <literal>JOIN</literal> tree. In "
"the latter case it can also refer to any items that are on the left-hand "
"side of a <literal>JOIN</literal> that it is on the right-hand side of."
msgstr ""
"Элемент <literal>LATERAL</literal> может находиться на верхнем уровне списка "
"<literal>FROM</literal> или в дереве <literal>JOIN</literal>. В последнем "
"случае он может также ссылаться на любые элементы в левой части "
"<literal>JOIN</literal>, справа от которого он находится."

#: queries.xml:842(para)
msgid ""
"When a <literal>FROM</literal> item contains <literal>LATERAL</literal> "
"cross-references, evaluation proceeds as follows: for each row of the "
"<literal>FROM</literal> item providing the cross-referenced column(s), or "
"set of rows of multiple <literal>FROM</literal> items providing the columns, "
"the <literal>LATERAL</literal> item is evaluated using that row or row set's "
"values of the columns. The resulting row(s) are joined as usual with the "
"rows they were computed from. This is repeated for each row or set of rows "
"from the column source table(s)."
msgstr ""
"Когда элемент <literal>FROM</literal> содержит ссылки <literal>LATERAL</"
"literal>, запрос выполняется следующим образом: сначала для строки элемента "
"<literal>FROM</literal> с целевыми столбцами, или набора строк из нескольких "
"элементов <literal>FROM</literal>, содержащих целевые столбцы, вычисляется "
"элемент <literal>LATERAL</literal> со значениями этих столбцов. Затем "
"результирующие строки обычным образом соединяются со строками, из которых "
"они были вычислены. Эта процедура повторяется для всех строк исходных таблиц."

#: queries.xml:855(programlisting)
#, no-wrap
msgid "SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;"
msgstr "SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;"

#: queries.xml:860(programlisting)
#, no-wrap
msgid "SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;"
msgstr "SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;"

#: queries.xml:869(programlisting)
#, no-wrap
msgid ""
"SELECT p1.id, p2.id, v1, v2\n"
"FROM polygons p1, polygons p2,\n"
"     LATERAL vertices(p1.poly) v1,\n"
"     LATERAL vertices(p2.poly) v2\n"
"WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;"
msgstr ""
"SELECT p1.id, p2.id, v1, v2\n"
"FROM polygons p1, polygons p2,\n"
"     LATERAL vertices(p1.poly) v1,\n"
"     LATERAL vertices(p2.poly) v2\n"
"WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;"

#: queries.xml:877(programlisting)
#, no-wrap
msgid ""
"SELECT p1.id, p2.id, v1, v2\n"
"FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,\n"
"     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2\n"
"WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;"
msgstr ""
"SELECT p1.id, p2.id, v1, v2\n"
"FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,\n"
"     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2\n"
"WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;"

#: queries.xml:853(para)
msgid ""
"A trivial example of <literal>LATERAL</literal> is <placeholder-1/> This is "
"not especially useful since it has exactly the same result as the more "
"conventional <placeholder-2/> <literal>LATERAL</literal> is primarily useful "
"when the cross-referenced column is necessary for computing the row(s) to be "
"joined. A common application is providing an argument value for a set-"
"returning function. For example, supposing that <function>vertices(polygon)</"
"function> returns the set of vertices of a polygon, we could identify close-"
"together vertices of polygons stored in a table with: <placeholder-3/> This "
"query could also be written <placeholder-4/> or in several other equivalent "
"formulations. (As already mentioned, the <literal>LATERAL</literal> key word "
"is unnecessary in this example, but we use it for clarity.)"
msgstr ""
"<literal>LATERAL</literal> можно использовать так: <placeholder-1/> Здесь "
"это не очень полезно, так как тот же результат можно получить более простым "
"и привычным способом: <placeholder-2/> Применять <literal>LATERAL</literal> "
"имеет смысл в основном, когда для вычисления соединяемых строк необходимо "
"обратиться к столбцам других таблиц. В частности, это полезно, когда нужно "
"передать значение функции, возвращающей набор данных. Например, если "
"предположить, что <function>vertices(polygon)</function> возвращает набор "
"вершин многоугольника, близкие вершины многоугольников из таблицы polygons "
"можно получить так: <placeholder-3/> Этот запрос можно записать и так: "
"<placeholder-4/> или переформулировать другими способами. (Как уже "
"упоминалось, в данном примере ключевое слово <literal>LATERAL</literal> не "
"требуется, но мы добавили его для ясности.)"

#: queries.xml:896(programlisting)
#, no-wrap
msgid ""
"SELECT m.name\n"
"FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true\n"
"WHERE pname IS NULL;"
msgstr ""
"SELECT m.name\n"
"FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true\n"
"WHERE pname IS NULL;"

#: queries.xml:888(para)
msgid ""
"It is often particularly handy to <literal>LEFT JOIN</literal> to a "
"<literal>LATERAL</literal> subquery, so that source rows will appear in the "
"result even if the <literal>LATERAL</literal> subquery produces no rows for "
"them. For example, if <function>get_product_names()</function> returns the "
"names of products made by a manufacturer, but some manufacturers in our "
"table currently produce no products, we could find out which ones those are "
"like this: <placeholder-1/>"
msgstr ""
"Особенно полезно бывает использовать <literal>LEFT JOIN</literal> с "
"подзапросом <literal>LATERAL</literal>, чтобы исходные строки оказывались в "
"результате, даже если подзапрос <literal>LATERAL</literal> не возвращает "
"строк. Например, если функция <function>get_product_names()</function> "
"выдаёт названия продуктов, выпущенных определённым производителем, но о "
"продукции некоторых производителей информации нет, мы можем найти, каких "
"именно, примерно так: <placeholder-1/>"

#: queries.xml:906(title)
msgid "The <literal>WHERE</literal> Clause"
msgstr "Предложение <literal>WHERE</literal>"

#: queries.xml:908(indexterm)
msgid "<primary>WHERE</primary>"
msgstr "<primary>WHERE</primary>"

#: queries.xml:912(para)
msgid ""
"The syntax of the <xref linkend=\"sql-where\" endterm=\"sql-where-title\"/> "
"is <synopsis>\n"
"WHERE <replaceable>search_condition</replaceable>\n"
"</synopsis> where <replaceable>search_condition</replaceable> is any value "
"expression (see <xref linkend=\"sql-expressions\"/>) that returns a value of "
"type <type>boolean</type>."
msgstr ""
"<xref linkend=\"sql-where\" endterm=\"sql-where-title\"/> записывается так: "
"<synopsis>\n"
"WHERE <replaceable>условие_ограничения</replaceable>\n"
"</synopsis> где <replaceable>условие_ограничения</replaceable> &mdash; любое "
"выражение значения (см. <xref remap=\"4\" linkend=\"sql-expressions\"/>), "
"выдающее результат типа <type>boolean</type>."

#: queries.xml:923(para)
msgid ""
"After the processing of the <literal>FROM</literal> clause is done, each row "
"of the derived virtual table is checked against the search condition. If the "
"result of the condition is true, the row is kept in the output table, "
"otherwise (i.e., if the result is false or null) it is discarded. The search "
"condition typically references at least one column of the table generated in "
"the <literal>FROM</literal> clause; this is not required, but otherwise the "
"<literal>WHERE</literal> clause will be fairly useless."
msgstr ""
"После обработки предложения <literal>FROM</literal> каждая строка полученной "
"виртуальной таблицы проходит проверку по условию ограничения. Если результат "
"условия равен true, эта строка остаётся в выходной таблице, а иначе (если "
"результат равен false или NULL) отбрасывается. В условии ограничения, как "
"правило, задействуется минимум один столбец из таблицы, полученной на выходе "
"<literal>FROM</literal>. Хотя строго говоря, это не требуется, но в "
"противном случае предложение <literal>WHERE</literal> будет бессмысленным."

#: queries.xml:939(programlisting)
#, no-wrap
msgid "FROM a, b WHERE a.id = b.id AND b.val &gt; 5"
msgstr "FROM a, b WHERE a.id = b.id AND b.val &gt; 5"

#: queries.xml:943(programlisting)
#, no-wrap
msgid "FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5"
msgstr "FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5"

#: queries.xml:947(programlisting)
#, no-wrap
msgid "FROM a NATURAL JOIN b WHERE b.val &gt; 5"
msgstr "FROM a NATURAL JOIN b WHERE b.val &gt; 5"

#: queries.xml:935(para)
msgid ""
"The join condition of an inner join can be written either in the "
"<literal>WHERE</literal> clause or in the <literal>JOIN</literal> clause. "
"For example, these table expressions are equivalent: <placeholder-1/> and: "
"<placeholder-2/> or perhaps even: <placeholder-3/> Which one of these you "
"use is mainly a matter of style. The <literal>JOIN</literal> syntax in the "
"<literal>FROM</literal> clause is probably not as portable to other SQL "
"database management systems, even though it is in the SQL standard. For "
"outer joins there is no choice: they must be done in the <literal>FROM</"
"literal> clause. The <literal>ON</literal> or <literal>USING</literal> "
"clause of an outer join is <emphasis>not</emphasis> equivalent to a "
"<literal>WHERE</literal> condition, because it results in the addition of "
"rows (for unmatched input rows) as well as the removal of rows in the final "
"result."
msgstr ""
"Условие для внутреннего соединения можно записать как в предложении "
"<literal>WHERE</literal>, так и в предложении <literal>JOIN</literal>. "
"Например, это выражение: <placeholder-1/> равнозначно этому: <placeholder-2/"
"> и возможно, даже этому: <placeholder-3/> Какой вариант выбрать, в основном "
"дело вкуса и стиля. Вариант с <literal>JOIN</literal> внутри предложения "
"<literal>FROM</literal>, возможно, не лучший с точки зрения совместимости с "
"другими СУБД, хотя он и описан в стандарте SQL. Но для внешних соединений "
"других вариантов нет: их можно записывать только во <literal>FROM</literal>. "
"Предложения <literal>ON</literal> и <literal>USING</literal> во внешних "
"соединениях <emphasis>не</emphasis> равнозначны условию <literal>WHERE</"
"literal>, так как они могут добавлять строки (для входных строк без "
"соответствия), а также удалять их из конечного результата."

#: queries.xml:965(programlisting)
#, no-wrap
msgid ""
"SELECT ... FROM fdt WHERE c1 &gt; 5\n"
"\n"
"SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)\n"
"\n"
"SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)\n"
"\n"
"SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)\n"
"\n"
"SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100\n"
"\n"
"SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)"
msgstr ""
"SELECT ... FROM fdt WHERE c1 &gt; 5\n"
"\n"
"SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)\n"
"\n"
"SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)\n"
"\n"
"SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)\n"
"\n"
"SELECT ... FROM fdt WHERE c1 BETWEEN\n"
"  (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100\n"
"\n"
"SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)"

#: queries.xml:963(para)
msgid ""
"Here are some examples of <literal>WHERE</literal> clauses: <placeholder-1/> "
"<literal>fdt</literal> is the table derived in the <literal>FROM</literal> "
"clause. Rows that do not meet the search condition of the <literal>WHERE</"
"literal> clause are eliminated from <literal>fdt</literal>. Notice the use "
"of scalar subqueries as value expressions. Just like any other query, the "
"subqueries can employ complex table expressions. Notice also how "
"<literal>fdt</literal> is referenced in the subqueries. Qualifying "
"<literal>c1</literal> as <literal>fdt.c1</literal> is only necessary if "
"<literal>c1</literal> is also the name of a column in the derived input "
"table of the subquery. But qualifying the column name adds clarity even when "
"it is not needed. This example shows how the column naming scope of an outer "
"query extends into its inner queries."
msgstr ""
"Несколько примеров запросов с <literal>WHERE</literal>: <placeholder-1/> "
"<literal>fdt</literal> &mdash; название таблицы, порождённой в предложении "
"<literal>FROM</literal>. Строки, которые не соответствуют условию "
"<literal>WHERE</literal>, исключаются из <literal>fdt</literal>. Обратите "
"внимание, как в качестве выражений значения используются скалярные "
"подзапросы. Как и любые другие запросы, подзапросы могут содержать сложные "
"табличные выражения. Заметьте также, что <literal>fdt</literal> используется "
"в подзапросах. Дополнение имени <literal>c1</literal> в виде <literal>fdt."
"c1</literal> необходимо только, если в порождённой таблице в подзапросе "
"также оказывается столбец <literal>c1</literal>. Полное имя придаёт ясность "
"даже там, где без него можно обойтись. Этот пример показывает, как область "
"именования столбцов внешнего запроса распространяется на все вложенные в "
"него внутренние запросы."

#: queries.xml:995(title)
msgid "The <literal>GROUP BY</literal> and <literal>HAVING</literal> Clauses"
msgstr "Предложения <literal>GROUP BY</literal> и <literal>HAVING</literal>"

#: queries.xml:997(indexterm)
msgid "<primary>GROUP BY</primary>"
msgstr "<primary>GROUP BY</primary>"

#: queries.xml:1001(indexterm)
msgid "<primary>grouping</primary>"
msgstr "<primary>группировка</primary>"

#: queries.xml:1005(para)
msgid ""
"After passing the <literal>WHERE</literal> filter, the derived input table "
"might be subject to grouping, using the <literal>GROUP BY</literal> clause, "
"and elimination of group rows using the <literal>HAVING</literal> clause."
msgstr ""
"Строки порождённой входной таблицы, прошедшие фильтр <literal>WHERE</"
"literal>, можно сгруппировать с помощью предложения <literal>GROUP BY</"
"literal>, а затем оставить в результате только нужные группы строк, "
"используя предложение <literal>HAVING</literal>."

#: queries.xml:1013(replaceable)
msgid "select_list"
msgstr "список_выборки"

#: queries.xml:1015(optional)
msgid "WHERE ..."
msgstr "WHERE ..."

#: queries.xml:1016(replaceable)
msgid "grouping_column_reference"
msgstr "группирующий_столбец"

#: queries.xml:1016(optional)
msgid ", <placeholder-1/>"
msgstr ", <placeholder-1/>"

#: queries.xml:1012(synopsis)
#, no-wrap
msgid ""
"SELECT <placeholder-1/>\n"
"    FROM ...\n"
"    <placeholder-2/>\n"
"    GROUP BY <placeholder-3/> <placeholder-4/>..."
msgstr ""
"SELECT <placeholder-1/>\n"
"    FROM ...\n"
"    <placeholder-2/>\n"
"    GROUP BY <placeholder-3/> <placeholder-4/>..."

#: queries.xml:1019(para)
msgid ""
"The <xref linkend=\"sql-groupby\" endterm=\"sql-groupby-title\"/> is used to "
"group together those rows in a table that have the same values in all the "
"columns listed. The order in which the columns are listed does not matter. "
"The effect is to combine each set of rows having common values into one "
"group row that represents all rows in the group. This is done to eliminate "
"redundancy in the output and/or compute aggregates that apply to these "
"groups. For instance: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>\n"
" x | y\n"
"---+---\n"
" a | 3\n"
" c | 2\n"
" b | 5\n"
" a | 1\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</"
"userinput>\n"
" x\n"
"---\n"
" a\n"
" b\n"
" c\n"
"(3 rows)\n"
"</screen>"
msgstr ""
"<xref linkend=\"sql-groupby\" endterm=\"sql-groupby-title\"/> группирует "
"строки таблицы, объединяя их в одну группу при совпадении значений во всех "
"перечисленных столбцах. Порядок, в котором указаны столбцы, не имеет "
"значения. В результате наборы строк с одинаковыми значениями преобразуются в "
"отдельные строки, представляющие все строки группы. Это может быть полезно "
"для устранения избыточности выходных данных и/или для вычисления агрегатных "
"функций, применённых к этим группам. Например: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>\n"
" x | y\n"
"---+---\n"
" a | 3\n"
" c | 2\n"
" b | 5\n"
" a | 1\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</"
"userinput>\n"
" x\n"
"---\n"
" a\n"
" b\n"
" c\n"
"(3 rows)\n"
"</screen>"

#: queries.xml:1048(para)
msgid ""
"In the second query, we could not have written <literal>SELECT * FROM test1 "
"GROUP BY x</literal>, because there is no single value for the column "
"<literal>y</literal> that could be associated with each group. The grouped-"
"by columns can be referenced in the select list since they have a single "
"value in each group."
msgstr ""
"Во втором запросе мы не могли написать <literal>SELECT * FROM test1 GROUP BY "
"x</literal>, так как для столбца <literal>y</literal> нет единого значения, "
"связанного с каждой группой. Однако столбцы, по которым выполняется "
"группировка, можно использовать в списке выборки, так как они имеют "
"единственное значение в каждой группе."

#: queries.xml:1056(para)
msgid ""
"In general, if a table is grouped, columns that are not listed in "
"<literal>GROUP BY</literal> cannot be referenced except in aggregate "
"expressions. An example with aggregate expressions is: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</"
"userinput>\n"
" x | sum\n"
"---+-----\n"
" a |   4\n"
" b |   5\n"
" c |   2\n"
"(3 rows)\n"
"</screen> Here <literal>sum</literal> is an aggregate function that computes "
"a single value over the entire group. More information about the available "
"aggregate functions can be found in <xref linkend=\"functions-aggregate\"/>."
msgstr ""
"Вообще говоря, в группированной таблице столбцы, не включённые в список "
"<literal>GROUP BY</literal>, можно использовать только в агрегатных "
"выражениях. Пример такого агрегатного выражения: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</"
"userinput>\n"
" x | sum\n"
"---+-----\n"
" a |   4\n"
" b |   5\n"
" c |   2\n"
"(3 rows)\n"
"</screen> Здесь <literal>sum</literal> &mdash; агрегатная функция, "
"вычисляющая единственное значение для всей группы. Подробную информацию о "
"существующих агрегатных функциях можно найти в <xref remap=\"6\" linkend="
"\"functions-aggregate\"/>."

#: queries.xml:1076(para)
msgid ""
"Grouping without aggregate expressions effectively calculates the set of "
"distinct values in a column. This can also be achieved using the "
"<literal>DISTINCT</literal> clause (see <xref linkend=\"queries-distinct\"/"
">)."
msgstr ""
"Группировка без агрегатных выражений по сути выдаёт набор различающихся "
"значений столбцов. Этот же результат можно получить с помощью предложения "
"<literal>DISTINCT</literal> (см. <xref remap=\"4\" linkend=\"queries-distinct"
"\"/>)."

#: queries.xml:1087(programlisting)
#, no-wrap
msgid ""
"SELECT product_id, p.name, (sum(s.units) * p.price) AS sales\n"
"    FROM products p LEFT JOIN sales s USING (product_id)\n"
"    GROUP BY product_id, p.name, p.price;"
msgstr ""
"SELECT product_id, p.name, (sum(s.units) * p.price) AS sales\n"
"    FROM products p LEFT JOIN sales s USING (product_id)\n"
"    GROUP BY product_id, p.name, p.price;"

#: queries.xml:1084(para)
msgid ""
"Here is another example: it calculates the total sales for each product "
"(rather than the total sales of all products): <placeholder-1/> In this "
"example, the columns <literal>product_id</literal>, <literal>p.name</"
"literal>, and <literal>p.price</literal> must be in the <literal>GROUP BY</"
"literal> clause since they are referenced in the query select list (but see "
"below). The column <literal>s.units</literal> does not have to be in the "
"<literal>GROUP BY</literal> list since it is only used in an aggregate "
"expression (<literal>sum(...)</literal>), which represents the sales of a "
"product. For each product, the query returns a summary row about all sales "
"of the product."
msgstr ""
"Взгляните на следующий пример: в нём вычисляется общая сумма продаж по "
"каждому продукту (а не общая сумма по всем продуктам): <placeholder-1/> В "
"этом примере столбцы <literal>product_id</literal>, <literal>p.name</"
"literal> и <literal>p.price</literal> должны присутствовать в списке "
"<literal>GROUP BY</literal>, так как они используются в списке выборки. "
"Столбец <literal>s.units</literal> может отсутствовать в списке "
"<literal>GROUP BY</literal>, так как он используется только в агрегатном "
"выражении (<literal>sum(...)</literal>), вычисляющем сумму продаж. Для "
"каждого продукта этот запрос возвращает строку с итоговой суммой по всем "
"продажам данного продукта."

#: queries.xml:1103(indexterm)
msgid "<primary>functional dependency</primary>"
msgstr "<primary>функциональная зависимость</primary>"

#: queries.xml:1105(para)
msgid ""
"If the products table is set up so that, say, <literal>product_id</literal> "
"is the primary key, then it would be enough to group by <literal>product_id</"
"literal> in the above example, since name and price would be "
"<firstterm>functionally dependent</firstterm> on the product ID, and so "
"there would be no ambiguity about which name and price value to return for "
"each product ID group."
msgstr ""
"Если бы в таблице products по столбцу <literal>product_id</literal> был "
"создан первичный ключ, тогда в данном примере было бы достаточно "
"сгруппировать строки по <literal>product_id</literal>, так как название и "
"цена продукта <firstterm>функционально зависят</firstterm> от кода продукта "
"и можно однозначно определить, какое название и цену возвращать для каждой "
"группы по ID."

#: queries.xml:1115(para)
msgid ""
"In strict SQL, <literal>GROUP BY</literal> can only group by columns of the "
"source table but <productname>PostgreSQL</productname> extends this to also "
"allow <literal>GROUP BY</literal> to group by columns in the select list. "
"Grouping by value expressions instead of simple column names is also allowed."
msgstr ""
"В стандарте SQL <literal>GROUP BY</literal> может группировать только по "
"столбцам исходной таблицы, но расширение <productname>PostgreSQL</"
"productname> позволяет использовать в <literal>GROUP BY</literal> столбцы из "
"списка выборки. Также возможна группировка по выражениям, а не просто именам "
"столбцов."

#: queries.xml:1123(indexterm)
msgid "<primary>HAVING</primary>"
msgstr "<primary>HAVING</primary>"

#: queries.xml:1127(para)
msgid ""
"If a table has been grouped using <literal>GROUP BY</literal>, but only "
"certain groups are of interest, the <literal>HAVING</literal> clause can be "
"used, much like a <literal>WHERE</literal> clause, to eliminate groups from "
"the result. The syntax is: <synopsis>\n"
"SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</"
"optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>\n"
"</synopsis> Expressions in the <literal>HAVING</literal> clause can refer "
"both to grouped expressions and to ungrouped expressions (which necessarily "
"involve an aggregate function)."
msgstr ""
"Если таблица была сгруппирована с помощью <literal>GROUP BY</literal>, но "
"интерес представляют только некоторые группы, отфильтровать их можно с "
"помощью предложения <literal>HAVING</literal>, действующего подобно "
"<literal>WHERE</literal>. Записывается это так: <synopsis>\n"
"SELECT <replaceable>список_выборки</replaceable> FROM ... <optional>WHERE ..."
"</optional> GROUP BY ...\n"
"  HAVING <replaceable>логическое_выражение</replaceable>\n"
"</synopsis> В предложении <literal>HAVING</literal> могут использоваться и "
"группирующие выражения, и выражения, не участвующие в группировке (в этом "
"случае это должны быть агрегирующие функции)."

#: queries.xml:1141(para)
msgid ""
"Example: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x "
"HAVING sum(y) &gt; 3;</userinput>\n"
" x | sum\n"
"---+-----\n"
" a |   4\n"
" b |   5\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x "
"HAVING x &lt; 'c';</userinput>\n"
" x | sum\n"
"---+-----\n"
" a |   4\n"
" b |   5\n"
"(2 rows)\n"
"</screen>"
msgstr ""
"Пример: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x "
"HAVING sum(y) &gt; 3;</userinput>\n"
" x | sum\n"
"---+-----\n"
" a |   4\n"
" b |   5\n"
"(2 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x "
"HAVING x &lt; 'c';</userinput>\n"
" x | sum\n"
"---+-----\n"
" a |   4\n"
" b |   5\n"
"(2 rows)\n"
"</screen>"

#: queries.xml:1162(programlisting)
#, no-wrap
msgid ""
"SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit\n"
"    FROM products p LEFT JOIN sales s USING (product_id)\n"
"    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'\n"
"    GROUP BY product_id, p.name, p.price, p.cost\n"
"    HAVING sum(p.price * s.units) &gt; 5000;"
msgstr ""
"SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit\n"
"    FROM products p LEFT JOIN sales s USING (product_id)\n"
"    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'\n"
"    GROUP BY product_id, p.name, p.price, p.cost\n"
"    HAVING sum(p.price * s.units) &gt; 5000;"

#: queries.xml:1160(para)
msgid ""
"Again, a more realistic example: <placeholder-1/> In the example above, the "
"<literal>WHERE</literal> clause is selecting rows by a column that is not "
"grouped (the expression is only true for sales during the last four weeks), "
"while the <literal>HAVING</literal> clause restricts the output to groups "
"with total gross sales over 5000. Note that the aggregate expressions do not "
"necessarily need to be the same in all parts of the query."
msgstr ""
"И ещё один более реалистичный пример: <placeholder-1/> В данном примере "
"предложение <literal>WHERE</literal> выбирает строки по столбцу, не "
"включённому в группировку (выражение истинно только для продаж за последние "
"четыре недели), тогда как предложение <literal>HAVING</literal> "
"отфильтровывает группы с общей суммой продаж больше 5000. Заметьте, что "
"агрегатные выражения не обязательно должны быть одинаковыми во всех частях "
"запроса."

#: queries.xml:1177(para)
msgid ""
"If a query contains aggregate function calls, but no <literal>GROUP BY</"
"literal> clause, grouping still occurs: the result is a single group row (or "
"perhaps no rows at all, if the single row is then eliminated by "
"<literal>HAVING</literal>). The same is true if it contains a "
"<literal>HAVING</literal> clause, even without any aggregate function calls "
"or <literal>GROUP BY</literal> clause."
msgstr ""
"Если в запросе есть вызовы агрегатных функций, но нет предложения "
"<literal>GROUP BY</literal>, строки всё равно будут группироваться: в "
"результате окажется одна строка группы (или возможно, ни одной строки, если "
"эта строка будет отброшена предложением <literal>HAVING</literal>). Это "
"справедливо и для запросов, которые содержат только предложение "
"<literal>HAVING</literal>, но не содержат вызовы агрегатных функций и "
"предложение <literal>GROUP BY</literal>."

#: queries.xml:1188(title)
msgid ""
"<literal>GROUPING SETS</literal>, <literal>CUBE</literal>, and "
"<literal>ROLLUP</literal>"
msgstr ""
"<literal>GROUPING SETS</literal>, <literal>CUBE</literal> и <literal>ROLLUP</"
"literal>"

#: queries.xml:1190(indexterm)
msgid "<primary>GROUPING SETS</primary>"
msgstr "<primary>GROUPING SETS</primary>"

#: queries.xml:1193(indexterm)
msgid "<primary>CUBE</primary>"
msgstr "<primary>CUBE</primary>"

#: queries.xml:1196(indexterm)
msgid "<primary>ROLLUP</primary>"
msgstr "<primary>ROLLUP</primary>"

#: queries.xml:1200(para)
msgid ""
"More complex grouping operations than those described above are possible "
"using the concept of <firstterm>grouping sets</firstterm>. The data selected "
"by the <literal>FROM</literal> and <literal>WHERE</literal> clauses is "
"grouped separately by each specified grouping set, aggregates computed for "
"each group just as for simple <literal>GROUP BY</literal> clauses, and then "
"the results returned. For example: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>\n"
" brand | size | sales\n"
"-------+------+-------\n"
" Foo   | L    |  10\n"
" Foo   | M    |  20\n"
" Bar   | M    |  15\n"
" Bar   | L    |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT brand, size, sum(sales) FROM "
"items_sold GROUP BY GROUPING SETS ((brand), (size), ());</userinput>\n"
" brand | size | sum\n"
"-------+------+-----\n"
" Foo   |      |  30\n"
" Bar   |      |  20\n"
"       | L    |  15\n"
"       | M    |  35\n"
"       |      |  50\n"
"(5 rows)\n"
"</screen>"
msgstr ""
"Более сложные, чем описанные выше, операции группировки возможны с "
"концепцией <firstterm>наборов группирования</firstterm>. Данные, выбранные "
"предложениями <literal>FROM</literal> и <literal>WHERE</literal>, "
"группируются отдельно для каждого заданного набора группирования, затем для "
"каждой группы вычисляются агрегатные функции как для простых предложений "
"<literal>GROUP BY</literal>, и в конце возвращаются результаты. Например: "
"<screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>\n"
" brand | size | sales\n"
"-------+------+-------\n"
" Foo   | L    |  10\n"
" Foo   | M    |  20\n"
" Bar   | M    |  15\n"
" Bar   | L    |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT brand, size, sum(sales) FROM "
"items_sold GROUP BY GROUPING SETS ((brand), (size), ());</userinput>\n"
" brand | size | sum\n"
"-------+------+-----\n"
" Foo   |      |  30\n"
" Bar   |      |  20\n"
"       | L    |  15\n"
"       | M    |  35\n"
"       |      |  50\n"
"(5 rows)\n"
"</screen>"

#: queries.xml:1229(para)
msgid ""
"Each sublist of <literal>GROUPING SETS</literal> may specify zero or more "
"columns or expressions and is interpreted the same way as though it were "
"directly in the <literal>GROUP BY</literal> clause. An empty grouping set "
"means that all rows are aggregated down to a single group (which is output "
"even if no input rows were present), as described above for the case of "
"aggregate functions with no <literal>GROUP BY</literal> clause."
msgstr ""
"В каждом внутреннем списке <literal>GROUPING SETS</literal> могут задаваться "
"ноль или более столбцов или выражений, которые воспринимаются так же, как "
"если бы они были непосредственно записаны в предложении <literal>GROUP BY</"
"literal>. Пустой набор группировки означает, что все строки сводятся к одной "
"группе (которая выводится, даже если входных строк нет), как описано выше "
"для агрегатных функций без предложения <literal>GROUP BY</literal>."

#: queries.xml:1238(para)
msgid ""
"References to the grouping columns or expressions are replaced by null "
"values in result rows for grouping sets in which those columns do not "
"appear. To distinguish which grouping a particular output row resulted from, "
"see <xref linkend=\"functions-grouping-table\"/>."
msgstr ""
"Ссылки на группирующие столбцы или выражения заменяются в результирующих "
"строках значениями NULL для тех группирующих наборов, в которых эти столбцы "
"отсутствуют. Чтобы можно было понять, результатом какого группирования стала "
"конкретная выходная строка, предназначена функция, описанная в <xref remap="
"\"6\" linkend=\"functions-grouping-table\"/>."

#: queries.xml:1248(programlisting)
#, no-wrap
msgid "ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )"
msgstr "ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )"

#: queries.xml:1253(programlisting)
#, no-wrap
msgid ""
"GROUPING SETS (\n"
"    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),\n"
"    ...\n"
"    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),\n"
"    ( <replaceable>e1</replaceable> ),\n"
"    ( )\n"
")"
msgstr ""
"GROUPING SETS (\n"
"    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),\n"
"    ...\n"
"    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),\n"
"    ( <replaceable>e1</replaceable> ),\n"
"    ( )\n"
")"

#: queries.xml:1245(para)
msgid ""
"A shorthand notation is provided for specifying two common types of grouping "
"set. A clause of the form <placeholder-1/> represents the given list of "
"expressions and all prefixes of the list including the empty list; thus it "
"is equivalent to <placeholder-2/> This is commonly used for analysis over "
"hierarchical data; e.g. total salary by department, division, and company-"
"wide total."
msgstr ""
"Для указания двух распространённых видов наборов группирования предусмотрена "
"краткая запись. Предложение формы <placeholder-1/> представляет заданный "
"список выражений и всех префиксов списка, включая пустой список; то есть оно "
"равнозначно записи <placeholder-2/> Оно часто применяется для анализа "
"иерархических данных, например, для суммирования зарплаты по отделам, "
"подразделениям и компании в целом."

#: queries.xml:1268(programlisting)
#, no-wrap
msgid "CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )"
msgstr "CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )"

#: queries.xml:1273(programlisting)
#, no-wrap
msgid "CUBE ( a, b, c )"
msgstr "CUBE ( a, b, c )"

#: queries.xml:1277(programlisting)
#, no-wrap
msgid ""
"GROUPING SETS (\n"
"    ( a, b, c ),\n"
"    ( a, b    ),\n"
"    ( a,    c ),\n"
"    ( a       ),\n"
"    (    b, c ),\n"
"    (    b    ),\n"
"    (       c ),\n"
"    (         )\n"
")"
msgstr ""
"GROUPING SETS (\n"
"    ( a, b, c ),\n"
"    ( a, b    ),\n"
"    ( a,    c ),\n"
"    ( a       ),\n"
"    (    b, c ),\n"
"    (    b    ),\n"
"    (       c ),\n"
"    (         )\n"
")"

#: queries.xml:1266(para)
msgid ""
"A clause of the form <placeholder-1/> represents the given list and all of "
"its possible subsets (i.e. the power set). Thus <placeholder-2/> is "
"equivalent to <placeholder-3/>"
msgstr ""
"Предложение формы <placeholder-1/> представляет заданный список и все его "
"возможные подмножества (степень множества). Таким образом, запись "
"<placeholder-2/> равнозначна <placeholder-3/>"

#: queries.xml:1297(programlisting)
#, no-wrap
msgid "CUBE ( (a, b), (c, d) )"
msgstr "CUBE ( (a, b), (c, d) )"

#: queries.xml:1301(programlisting)
#, no-wrap
msgid ""
"GROUPING SETS (\n"
"    ( a, b, c, d ),\n"
"    ( a, b       ),\n"
"    (       c, d ),\n"
"    (            )\n"
")"
msgstr ""
"GROUPING SETS (\n"
"    ( a, b, c, d ),\n"
"    ( a, b       ),\n"
"    (       c, d ),\n"
"    (            )\n"
")"

#: queries.xml:1310(programlisting)
#, no-wrap
msgid "ROLLUP ( a, (b, c), d )"
msgstr "ROLLUP ( a, (b, c), d )"

#: queries.xml:1314(programlisting)
#, no-wrap
msgid ""
"GROUPING SETS (\n"
"    ( a, b, c, d ),\n"
"    ( a, b, c    ),\n"
"    ( a          ),\n"
"    (            )\n"
")"
msgstr ""
"GROUPING SETS (\n"
"    ( a, b, c, d ),\n"
"    ( a, b, c    ),\n"
"    ( a          ),\n"
"    (            )\n"
")"

#: queries.xml:1291(para)
msgid ""
"The individual elements of a <literal>CUBE</literal> or <literal>ROLLUP</"
"literal> clause may be either individual expressions, or sublists of "
"elements in parentheses. In the latter case, the sublists are treated as "
"single units for the purposes of generating the individual grouping sets. "
"For example: <placeholder-1/> is equivalent to <placeholder-2/> and "
"<placeholder-3/> is equivalent to <placeholder-4/>"
msgstr ""
"Элементами предложений <literal>CUBE</literal> и <literal>ROLLUP</literal> "
"могут быть либо отдельные выражения, либо вложенные списки элементов в "
"скобках. Вложенные списки обрабатываются как атомарные единицы, с которыми "
"формируются отдельные наборы группирования. Например: <placeholder-1/> "
"равнозначно <placeholder-2/> и <placeholder-3/> равнозначно <placeholder-4/>"

#: queries.xml:1324(para)
msgid ""
"The <literal>CUBE</literal> and <literal>ROLLUP</literal> constructs can be "
"used either directly in the <literal>GROUP BY</literal> clause, or nested "
"inside a <literal>GROUPING SETS</literal> clause. If one <literal>GROUPING "
"SETS</literal> clause is nested inside another, the effect is the same as if "
"all the elements of the inner clause had been written directly in the outer "
"clause."
msgstr ""
"Конструкции <literal>CUBE</literal> и <literal>ROLLUP</literal> могут "
"применяться либо непосредственно в предложении <literal>GROUP BY</literal>, "
"либо вкладываться внутрь предложения <literal>GROUPING SETS</literal>. Если "
"одно предложение <literal>GROUPING SETS</literal> вкладывается внутрь "
"другого, результат будет таким же, как если бы все элементы внутреннего "
"предложения были записаны непосредственно во внешнем."

#: queries.xml:1336(programlisting)
#, no-wrap
msgid "GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))"
msgstr "GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))"

#: queries.xml:1340(programlisting)
#, no-wrap
msgid ""
"GROUP BY GROUPING SETS (\n"
"    (a, b, c, d), (a, b, c, e),\n"
"    (a, b, d),    (a, b, e),\n"
"    (a, c, d),    (a, c, e),\n"
"    (a, d),       (a, e)\n"
")"
msgstr ""
"GROUP BY GROUPING SETS (\n"
"    (a, b, c, d), (a, b, c, e),\n"
"    (a, b, d),    (a, b, e),\n"
"    (a, c, d),    (a, c, e),\n"
"    (a, d),       (a, e)\n"
")"

#: queries.xml:1332(para)
msgid ""
"If multiple grouping items are specified in a single <literal>GROUP BY</"
"literal> clause, then the final list of grouping sets is the cross product "
"of the individual items. For example: <placeholder-1/> is equivalent to "
"<placeholder-2/>"
msgstr ""
"Если в одном предложении <literal>GROUP BY</literal> задаётся несколько "
"элементов группирования, окончательный список наборов группирования "
"образуется как прямое произведение этих элементов. Например: <placeholder-1/"
"> равнозначно <placeholder-2/>"

#: queries.xml:1351(para)
msgid ""
"The construct <literal>(a, b)</literal> is normally recognized in "
"expressions as a <link linkend=\"sql-syntax-row-constructors\">row "
"constructor</link>. Within the <literal>GROUP BY</literal> clause, this does "
"not apply at the top levels of expressions, and <literal>(a, b)</literal> is "
"parsed as a list of expressions as described above. If for some reason you "
"<emphasis>need</emphasis> a row constructor in a grouping expression, use "
"<literal>ROW(a, b)</literal>."
msgstr ""
"Конструкция <literal>(a, b)</literal> обычно воспринимается в выражениях как "
"<link linkend=\"sql-syntax-row-constructors\">конструктор строки</link>. "
"Однако в предложении <literal>GROUP BY</literal> на верхнем уровне выражений "
"запись <literal>(a, b)</literal> воспринимается как список выражений, как "
"описано выше. Если вам по какой-либо причине <emphasis>нужен</emphasis> "
"именно конструктор строки в выражении группирования, используйте запись "
"<literal>ROW(a, b)</literal>."

#: queries.xml:1363(title)
msgid "Window Function Processing"
msgstr "Обработка оконных функций"

#: queries.xml:1365(indexterm)
msgid ""
"<primary>window function</primary> <secondary>order of execution</secondary>"
msgstr ""
"<primary>оконная функция</primary> <secondary>порядок выполнения</secondary>"

#: queries.xml:1370(para)
msgid ""
"If the query contains any window functions (see <xref linkend=\"tutorial-"
"window\"/>, <xref linkend=\"functions-window\"/> and <xref linkend=\"syntax-"
"window-functions\"/>), these functions are evaluated after any grouping, "
"aggregation, and <literal>HAVING</literal> filtering is performed. That is, "
"if the query uses any aggregates, <literal>GROUP BY</literal>, or "
"<literal>HAVING</literal>, then the rows seen by the window functions are "
"the group rows instead of the original table rows from <literal>FROM</"
"literal>/<literal>WHERE</literal>."
msgstr ""
"Если запрос содержит оконные функции (см. <xref remap=\"4\" linkend="
"\"tutorial-window\"/>, <xref remap=\"4\" linkend=\"functions-window\"/> и "
"<xref remap=\"4\" linkend=\"syntax-window-functions\"/>), эти функции "
"вычисляются после каждой группировки, агрегатных выражений и фильтрации "
"<literal>HAVING</literal>. Другими словами, если в запросе есть агрегатные "
"функции, предложения <literal>GROUP BY</literal> или <literal>HAVING</"
"literal>, оконные функции видят не исходные строки, полученные из "
"<literal>FROM</literal>/<literal>WHERE</literal>, а сгруппированные."

#: queries.xml:1382(para)
msgid ""
"When multiple window functions are used, all the window functions having "
"syntactically equivalent <literal>PARTITION BY</literal> and <literal>ORDER "
"BY</literal> clauses in their window definitions are guaranteed to be "
"evaluated in a single pass over the data. Therefore they will see the same "
"sort ordering, even if the <literal>ORDER BY</literal> does not uniquely "
"determine an ordering. However, no guarantees are made about the evaluation "
"of functions having different <literal>PARTITION BY</literal> or "
"<literal>ORDER BY</literal> specifications. (In such cases a sort step is "
"typically required between the passes of window function evaluations, and "
"the sort is not guaranteed to preserve ordering of rows that its "
"<literal>ORDER BY</literal> sees as equivalent.)"
msgstr ""
"Когда используются несколько оконных функций, все оконные функции, имеющие в "
"своих определениях синтаксически равнозначные предложения <literal>PARTITION "
"BY</literal> и <literal>ORDER BY</literal>, гарантированно обрабатывают "
"данные за один проход. Таким образом, они увидят один порядок сортировки, "
"даже если <literal>ORDER BY</literal> не определяет порядок однозначно. "
"Однако относительно функций с разными формулировками <literal>PARTITION BY</"
"literal> и <literal>ORDER BY</literal> никаких гарантий не даётся. (В таких "
"случаях между проходами вычислений оконных функций обычно требуется "
"дополнительный этап сортировки и эта сортировка может не сохранять порядок "
"строк, равнозначный с точки зрения <literal>ORDER BY</literal>.)"

#: queries.xml:1395(para)
msgid ""
"Currently, window functions always require presorted data, and so the query "
"output will be ordered according to one or another of the window functions' "
"<literal>PARTITION BY</literal>/<literal>ORDER BY</literal> clauses. It is "
"not recommended to rely on this, however. Use an explicit top-level "
"<literal>ORDER BY</literal> clause if you want to be sure the results are "
"sorted in a particular way."
msgstr ""
"В настоящее время оконные функции всегда требуют предварительно "
"отсортированных данных, так что результат запроса будет отсортирован "
"согласно тому или иному предложению <literal>PARTITION BY</literal>/"
"<literal>ORDER BY</literal> оконных функций. Однако полагаться на это не "
"следует. Если вы хотите, чтобы результаты сортировались определённым "
"образом, явно добавьте предложение <literal>ORDER BY</literal> на верхнем "
"уровне запроса."

#: queries.xml:1408(title)
msgid "Select Lists"
msgstr "Списки выборки"

#: queries.xml:1410(indexterm)
msgid "<primary>SELECT</primary> <secondary>select list</secondary>"
msgstr "<primary>SELECT</primary> <secondary>список выборки</secondary>"

#: queries.xml:1415(para)
msgid ""
"As shown in the previous section, the table expression in the "
"<command>SELECT</command> command constructs an intermediate virtual table "
"by possibly combining tables, views, eliminating rows, grouping, etc. This "
"table is finally passed on to processing by the <firstterm>select list</"
"firstterm>. The select list determines which <emphasis>columns</emphasis> of "
"the intermediate table are actually output."
msgstr ""
"Как говорилось в предыдущем разделе, табличное выражение в <command>SELECT</"
"command> создаёт промежуточную виртуальную таблицу, возможно объединяя "
"таблицы, представления, группируя и исключая лишние строки и т. д. "
"Полученная таблица передаётся для обработки в <firstterm>список выборки</"
"firstterm>. Этот список выбирает, какие <emphasis>столбцы</emphasis> "
"промежуточной таблицы должны выводиться в результате и как именно."

#: queries.xml:1426(title)
msgid "Select-List Items"
msgstr "Элементы списка выборки"

#: queries.xml:1428(indexterm)
msgid "<primary>*</primary>"
msgstr "<primary>*</primary>"

#: queries.xml:1438(programlisting)
#, no-wrap
msgid "SELECT a, b, c FROM ..."
msgstr "SELECT a, b, c FROM ..."

#: queries.xml:1432(para)
msgid ""
"The simplest kind of select list is <literal>*</literal> which emits all "
"columns that the table expression produces. Otherwise, a select list is a "
"comma-separated list of value expressions (as defined in <xref linkend=\"sql-"
"expressions\"/>). For instance, it could be a list of column names: "
"<placeholder-1/> The columns names <literal>a</literal>, <literal>b</"
"literal>, and <literal>c</literal> are either the actual names of the "
"columns of tables referenced in the <literal>FROM</literal> clause, or the "
"aliases given to them as explained in <xref linkend=\"queries-table-aliases"
"\"/>. The name space available in the select list is the same as in the "
"<literal>WHERE</literal> clause, unless grouping is used, in which case it "
"is the same as in the <literal>HAVING</literal> clause."
msgstr ""
"Простейший список выборки образует элемент <literal>*</literal>, который "
"выбирает все столбцы из полученного табличного выражения. Список выборки "
"также может содержать список выражений значения через запятую (как "
"определено в <xref remap=\"6\" linkend=\"sql-expressions\"/>). Например, это "
"может быть список имён столбцов: <placeholder-1/> Имена столбцов <literal>a</"
"literal>, <literal>b</literal> и <literal>c</literal> представляют либо "
"фактические имена столбцов таблиц, перечисленных в предложении "
"<literal>FROM</literal>, либо их псевдонимы, определённые как описано в "
"<xref remap=\"6\" linkend=\"queries-table-aliases\"/>. Пространство имён в "
"списке выборки то же, что и в предложении <literal>WHERE</literal>, если не "
"используется группировка. В противном случае оно совпадает с пространством "
"имён предложения <literal>HAVING</literal>."

#: queries.xml:1453(programlisting)
#, no-wrap
msgid "SELECT tbl1.a, tbl2.a, tbl1.b FROM ..."
msgstr "SELECT tbl1.a, tbl2.a, tbl1.b FROM ..."

#: queries.xml:1458(programlisting)
#, no-wrap
msgid "SELECT tbl1.*, tbl2.a FROM ..."
msgstr "SELECT tbl1.*, tbl2.a FROM ..."

#: queries.xml:1450(para)
msgid ""
"If more than one table has a column of the same name, the table name must "
"also be given, as in: <placeholder-1/> When working with multiple tables, it "
"can also be useful to ask for all the columns of a particular table: "
"<placeholder-2/> See <xref linkend=\"rowtypes-usage\"/> for more about the "
"<replaceable>table_name</replaceable><literal>.*</literal> notation."
msgstr ""
"Если столбец с заданным именем есть в нескольких таблицах, необходимо также "
"указать имя таблицы, например так: <placeholder-1/> Обращаясь к нескольким "
"таблицам, бывает удобно получить сразу все столбцы одной из таблиц: "
"<placeholder-2/> Подробнее запись <replaceable>имя_таблицы</"
"replaceable><literal>.*</literal> описывается в <xref remap=\"6\" linkend="
"\"rowtypes-usage\"/>."

#: queries.xml:1465(para)
msgid ""
"If an arbitrary value expression is used in the select list, it conceptually "
"adds a new virtual column to the returned table. The value expression is "
"evaluated once for each result row, with the row's values substituted for "
"any column references. But the expressions in the select list do not have to "
"reference any columns in the table expression of the <literal>FROM</literal> "
"clause; they can be constant arithmetic expressions, for instance."
msgstr ""
"Если в списке выборки используется обычное выражение значения, по сути при "
"этом в возвращаемую таблицу добавляется новый виртуальный столбец. Выражение "
"значения вычисляется один раз для каждой строки результата со значениями "
"столбцов в данной строке. Хотя выражения в списке выборки не обязательно "
"должны обращаться к столбцам табличного выражения из предложения "
"<literal>FROM</literal>; они могут содержать, например и простые "
"арифметические выражения."

#: queries.xml:1477(title)
msgid "Column Labels"
msgstr "Метки столбцов"

#: queries.xml:1479(indexterm)
msgid "<primary>alias</primary> <secondary>in the select list</secondary>"
msgstr "<primary>псевдоним</primary> <secondary>в списке выборке</secondary>"

#: queries.xml:1488(programlisting)
#, no-wrap
msgid "SELECT a AS value, b + c AS sum FROM ..."
msgstr "SELECT a AS value, b + c AS sum FROM ..."

#: queries.xml:1484(para)
msgid ""
"The entries in the select list can be assigned names for subsequent "
"processing, such as for use in an <literal>ORDER BY</literal> clause or for "
"display by the client application. For example: <placeholder-1/>"
msgstr ""
"Элементам в списке выборки можно назначить имена для последующей обработки, "
"например, для указания в предложении <literal>ORDER BY</literal> или для "
"вывода в клиентском приложении. Например: <placeholder-1/>"

#: queries.xml:1493(para)
msgid ""
"If no output column name is specified using <literal>AS</literal>, the "
"system assigns a default column name. For simple column references, this is "
"the name of the referenced column. For function calls, this is the name of "
"the function. For complex expressions, the system will generate a generic "
"name."
msgstr ""
"Если выходное имя столбца не определено (с помощью <literal>AS</literal>), "
"система назначает имя сама. Для простых ссылок на столбцы этим именем "
"становится имя целевого столбца, а для вызовов функций это имя функции. Для "
"сложных выражений система генерирует некоторое подходящее имя."

#: queries.xml:1508(programlisting)
#, no-wrap
msgid "SELECT a value, b + c AS sum FROM ..."
msgstr "SELECT a value, b + c AS sum FROM ..."

#: queries.xml:1512(programlisting)
#, no-wrap
msgid "SELECT a \"value\", b + c AS sum FROM ..."
msgstr "SELECT a \"value\", b + c AS sum FROM ..."

#: queries.xml:1501(para)
msgid ""
"The <literal>AS</literal> keyword is optional, but only if the new column "
"name does not match any <productname>PostgreSQL</productname> keyword (see "
"<xref linkend=\"sql-keywords-appendix\"/>). To avoid an accidental match to "
"a keyword, you can double-quote the column name. For example, "
"<literal>VALUE</literal> is a keyword, so this does not work: <placeholder-1/"
"> but this does: <placeholder-2/> For protection against possible future "
"keyword additions, it is recommended that you always either write "
"<literal>AS</literal> or double-quote the output column name."
msgstr ""
"Слово <literal>AS</literal> можно опустить, но только если имя нового "
"столбца не является ключевым словом <productname>PostgreSQL</productname> "
"(см. <xref remap=\"4\" linkend=\"sql-keywords-appendix\"/>). Во избежание "
"случайного совпадения имени с ключевым словом это имя можно заключить в "
"кавычки. Например, <literal>VALUE</literal> &mdash; ключевое слово, поэтому "
"такой вариант не будет работать: <placeholder-1/> а такой будет: "
"<placeholder-2/> Для предотвращения конфликта с ключевыми словами, которые "
"могут появиться в будущем, рекомендуется всегда писать <literal>AS</literal> "
"или заключать метки выходных столбцов в кавычки."

#: queries.xml:1521(para)
msgid ""
"The naming of output columns here is different from that done in the "
"<literal>FROM</literal> clause (see <xref linkend=\"queries-table-aliases\"/"
">). It is possible to rename the same column twice, but the name assigned in "
"the select list is the one that will be passed on."
msgstr ""
"Именование выходных столбцов отличается от того, что происходит в "
"предложении <literal>FROM</literal> (см. <xref remap=\"4\" linkend=\"queries-"
"table-aliases\"/>). Один столбец можно переименовать дважды, но на выходе "
"окажется имя, назначенное в списке выборки."

#: queries.xml:1532(literal)
msgid "DISTINCT"
msgstr "DISTINCT"

#: queries.xml:1534(indexterm)
msgid "<primary>DISTINCT</primary>"
msgstr "<primary>DISTINCT</primary>"

#: queries.xml:1538(indexterm)
msgid "<primary>duplicates</primary>"
msgstr "<primary>дублирование</primary>"

#: queries.xml:1542(para)
msgid ""
"After the select list has been processed, the result table can optionally be "
"subject to the elimination of duplicate rows. The <literal>DISTINCT</"
"literal> key word is written directly after <literal>SELECT</literal> to "
"specify this: <synopsis>\n"
"SELECT DISTINCT <replaceable>select_list</replaceable> ...\n"
"</synopsis> (Instead of <literal>DISTINCT</literal> the key word "
"<literal>ALL</literal> can be used to specify the default behavior of "
"retaining all rows.)"
msgstr ""
"После обработки списка выборки в результирующей таблице можно дополнительно "
"исключить дублирующиеся строки. Для этого сразу после <literal>SELECT</"
"literal> добавляется ключевое слово <literal>DISTINCT</literal>: <synopsis>\n"
"SELECT DISTINCT <replaceable>список_выборки</replaceable> ...\n"
"</synopsis> (Чтобы явно включить поведение по умолчанию, когда возвращаются "
"все строки, вместо <literal>DISTINCT</literal> можно указать ключевое слово "
"<literal>ALL</literal>.)"

#: queries.xml:1554(indexterm)
msgid ""
"<primary>null value</primary> <secondary sortas=\"DISTINCT\">in DISTINCT</"
"secondary>"
msgstr ""
"<primary>NULL-значение</primary> <secondary sortas=\"DISTINCT\">в DISTINCT</"
"secondary>"

#: queries.xml:1559(para)
msgid ""
"Obviously, two rows are considered distinct if they differ in at least one "
"column value. Null values are considered equal in this comparison."
msgstr ""
"Две строки считаются разными, если они содержат различные значения минимум в "
"одном столбце. При этом значения NULL полагаются равными."

#: queries.xml:1565(para)
msgid ""
"Alternatively, an arbitrary expression can determine what rows are to be "
"considered distinct: <synopsis>\n"
"SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, "
"<replaceable>expression</replaceable> ...</optional>) "
"<replaceable>select_list</replaceable> ...\n"
"</synopsis> Here <replaceable>expression</replaceable> is an arbitrary value "
"expression that is evaluated for all rows. A set of rows for which all the "
"expressions are equal are considered duplicates, and only the first row of "
"the set is kept in the output. Note that the <quote>first row</quote> of a "
"set is unpredictable unless the query is sorted on enough columns to "
"guarantee a unique ordering of the rows arriving at the <literal>DISTINCT</"
"literal> filter. (<literal>DISTINCT ON</literal> processing occurs after "
"<literal>ORDER BY</literal> sorting.)"
msgstr ""
"Кроме того, можно явно определить, какие строки будут считаться различными, "
"следующим образом: <synopsis>\n"
"SELECT DISTINCT ON (<replaceable>выражение</replaceable> <optional>, "
"<replaceable>выражение</replaceable> ...</optional>) "
"<replaceable>список_выборки</replaceable> ...\n"
"</synopsis> Здесь <replaceable>выражение</replaceable> &mdash; обычное "
"выражение значения, вычисляемое для всех строк. Строки, для которых "
"перечисленные выражения дают один результат, считаются дублирующимися и "
"возвращается только первая строка из такого набора. Заметьте, что "
"<quote>первая строка</quote> набора может быть любой, если только запрос не "
"включает сортировку, гарантирующую однозначный порядок строк, поступающих в "
"фильтр <literal>DISTINCT</literal>. (Обработка <literal>DISTINCT ON</"
"literal> производится после сортировки <literal>ORDER BY</literal>.)"

#: queries.xml:1582(para)
msgid ""
"The <literal>DISTINCT ON</literal> clause is not part of the SQL standard "
"and is sometimes considered bad style because of the potentially "
"indeterminate nature of its results. With judicious use of <literal>GROUP "
"BY</literal> and subqueries in <literal>FROM</literal>, this construct can "
"be avoided, but it is often the most convenient alternative."
msgstr ""
"Предложение <literal>DISTINCT ON</literal> не описано в стандарте SQL и "
"иногда его применение считается плохим стилем из-за возможной "
"неопределённости в результатах. При разумном использовании <literal>GROUP "
"BY</literal> и подзапросов во <literal>FROM</literal> можно обойтись без "
"этой конструкции, но часто она бывает удобнее."

#: queries.xml:1595(title)
msgid "Combining Queries"
msgstr "Сочетание запросов"

#: queries.xml:1597(indexterm)
msgid "<primary>UNION</primary>"
msgstr "<primary>UNION</primary>"

#: queries.xml:1600(indexterm)
msgid "<primary>INTERSECT</primary>"
msgstr "<primary>INTERSECT</primary>"

#: queries.xml:1603(indexterm)
msgid "<primary>EXCEPT</primary>"
msgstr "<primary>EXCEPT</primary>"

#: queries.xml:1606(indexterm)
msgid "<primary>set union</primary>"
msgstr "<primary>объединение множеств</primary>"

#: queries.xml:1609(indexterm)
msgid "<primary>set intersection</primary>"
msgstr "<primary>пересечение множеств</primary>"

#: queries.xml:1612(indexterm)
msgid "<primary>set difference</primary>"
msgstr "<primary>вычитание множеств</primary>"

#: queries.xml:1615(indexterm)
msgid "<primary>set operation</primary>"
msgstr "<primary>операции над множествами</primary>"

#: queries.xml:1619(para)
msgid ""
"The results of two queries can be combined using the set operations union, "
"intersection, and difference. The syntax is <synopsis>\n"
"<replaceable>query1</replaceable> UNION <optional>ALL</optional> "
"<replaceable>query2</replaceable>\n"
"<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> "
"<replaceable>query2</replaceable>\n"
"<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> "
"<replaceable>query2</replaceable>\n"
"</synopsis> <replaceable>query1</replaceable> and <replaceable>query2</"
"replaceable> are queries that can use any of the features discussed up to "
"this point. Set operations can also be nested and chained, for example "
"<synopsis>\n"
"<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> "
"UNION <replaceable>query3</replaceable>\n"
"</synopsis> which is executed as: <synopsis>\n"
"(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) "
"UNION <replaceable>query3</replaceable>\n"
"</synopsis>"
msgstr ""
"Результаты двух запросов можно обработать, используя операции над "
"множествами: объединение, пересечение и вычитание. Эти операции записываются "
"соответственно так: <synopsis>\n"
"<replaceable>запрос1</replaceable> UNION <optional>ALL</optional> "
"<replaceable>запрос2</replaceable>\n"
"<replaceable>запрос1</replaceable> INTERSECT <optional>ALL</optional> "
"<replaceable>запрос2</replaceable>\n"
"<replaceable>запрос1</replaceable> EXCEPT <optional>ALL</optional> "
"<replaceable>запрос2</replaceable>\n"
"</synopsis> Здесь <replaceable>запрос1</replaceable> и <replaceable>запрос2</"
"replaceable> &mdash; это запросы, в которых могут использоваться все "
"возможности, рассмотренные до этого. Операции над множествами тоже можно "
"вкладывать и соединять, например:<synopsis>\n"
"<replaceable>запрос1</replaceable> UNION <replaceable>запрос2</replaceable> "
"UNION <replaceable>запрос3</replaceable>\n"
"</synopsis> Этот сложный запрос выполняется так: <synopsis>\n"
"(<replaceable>запрос1</replaceable> UNION <replaceable>запрос2</"
"replaceable>) UNION <replaceable>запрос3</replaceable>\n"
"</synopsis>"

#: queries.xml:1640(para)
msgid ""
"<literal>UNION</literal> effectively appends the result of "
"<replaceable>query2</replaceable> to the result of <replaceable>query1</"
"replaceable> (although there is no guarantee that this is the order in which "
"the rows are actually returned). Furthermore, it eliminates duplicate rows "
"from its result, in the same way as <literal>DISTINCT</literal>, unless "
"<literal>UNION ALL</literal> is used."
msgstr ""
"<literal>UNION</literal> по сути добавляет результаты второго запроса к "
"результатам первого (хотя никакой порядок возвращаемых строк при этом не "
"гарантируется). Более того, эта операция убирает дублирующиеся строки из "
"результата так же, как это делает <literal>DISTINCT</literal>, если только "
"не указано <literal>UNION ALL</literal>."

#: queries.xml:1649(para)
msgid ""
"<literal>INTERSECT</literal> returns all rows that are both in the result of "
"<replaceable>query1</replaceable> and in the result of <replaceable>query2</"
"replaceable>. Duplicate rows are eliminated unless <literal>INTERSECT ALL</"
"literal> is used."
msgstr ""
"<literal>INTERSECT</literal> возвращает все строки, содержащиеся в "
"результате и первого, и второго запроса. Дублирующиеся строки "
"отфильтровываются, если не указано <literal>ALL</literal>."

#: queries.xml:1656(para)
msgid ""
"<literal>EXCEPT</literal> returns all rows that are in the result of "
"<replaceable>query1</replaceable> but not in the result of "
"<replaceable>query2</replaceable>. (This is sometimes called the "
"<firstterm>difference</firstterm> between two queries.) Again, duplicates "
"are eliminated unless <literal>EXCEPT ALL</literal> is used."
msgstr ""
"<literal>EXCEPT</literal> возвращает все строки, которые есть в результате "
"первого запроса, но отсутствуют в результате второго. (Иногда это называют "
"<firstterm>разницей</firstterm> двух запросов.) И здесь дублирующиеся строки "
"отфильтровываются, если не указано <literal>ALL</literal>."

#: queries.xml:1664(para)
msgid ""
"In order to calculate the union, intersection, or difference of two queries, "
"the two queries must be <quote>union compatible</quote>, which means that "
"they return the same number of columns and the corresponding columns have "
"compatible data types, as described in <xref linkend=\"typeconv-union-case\"/"
">."
msgstr ""
"Чтобы можно было вычислить объединение, пересечение или разницу результатов "
"двух запросов, эти запросы должны быть <quote>совместимыми для объединения</"
"quote>, что означает, что они должны иметь одинаковое число столбцов и "
"соответствующие столбцы должны быть совместимых типов, как описывается в "
"<xref remap=\"6\" linkend=\"typeconv-union-case\"/>."

#: queries.xml:1675(title)
msgid "Sorting Rows"
msgstr "Сортировка строк"

#: queries.xml:1677(indexterm)
msgid "<primary>sorting</primary>"
msgstr "<primary>сортировка</primary>"

#: queries.xml:1681(indexterm)
msgid "<primary>ORDER BY</primary>"
msgstr "<primary>ORDER BY</primary>"

#: queries.xml:1685(para)
msgid ""
"After a query has produced an output table (after the select list has been "
"processed) it can optionally be sorted. If sorting is not chosen, the rows "
"will be returned in an unspecified order. The actual order in that case will "
"depend on the scan and join plan types and the order on disk, but it must "
"not be relied on. A particular output ordering can only be guaranteed if the "
"sort step is explicitly chosen."
msgstr ""
"После того как запрос выдал таблицу результатов (после обработки списка "
"выборки), её можно отсортировать. Если сортировка не задана, строки "
"возвращаются в неопределённом порядке. Фактический порядок строк в этом "
"случае будет зависеть от плана соединения и сканирования, а также от порядка "
"данных на диске, поэтому полагаться на него нельзя. Определённый порядок "
"выводимых строк гарантируется, только если этап сортировки задан явно."

#: queries.xml:1705(programlisting)
#, no-wrap
msgid "SELECT a, b FROM table1 ORDER BY a + b, c;"
msgstr "SELECT a, b FROM table1 ORDER BY a + b, c;"

#: queries.xml:1718(para)
msgid ""
"Actually, <productname>PostgreSQL</productname> uses the <firstterm>default "
"B-tree operator class</firstterm> for the expression's data type to "
"determine the sort ordering for <literal>ASC</literal> and <literal>DESC</"
"literal>. Conventionally, data types will be set up so that the <literal>&lt;"
"</literal> and <literal>&gt;</literal> operators correspond to this sort "
"ordering, but a user-defined data type's designer could choose to do "
"something different."
msgstr ""
"На деле <productname>PostgreSQL</productname> определяет порядок сортировки "
"для <literal>ASC</literal> и <literal>DESC</literal> по <firstterm>классу "
"оператора B-дерева по умолчанию</firstterm> для типа данных выражения. "
"Обычно типы данных создаются так, что этому порядку соответствуют операторы "
"<literal>&lt;</literal> и <literal>&gt;</literal>, но возможно разработать "
"собственный тип данных, который будет вести себя по-другому."

#: queries.xml:1695(para)
msgid ""
"The <literal>ORDER BY</literal> clause specifies the sort order: <synopsis>\n"
"SELECT <replaceable>select_list</replaceable>\n"
"    FROM <replaceable>table_expression</replaceable>\n"
"    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | "
"DESC</optional> <optional>NULLS { FIRST | LAST }</optional>\n"
"             <optional>, <replaceable>sort_expression2</replaceable> "
"<optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</"
"optional> ...</optional>\n"
"</synopsis> The sort expression(s) can be any expression that would be valid "
"in the query's select list. An example is: <placeholder-1/> When more than "
"one expression is specified, the later values are used to sort rows that are "
"equal according to the earlier values. Each expression can be followed by an "
"optional <literal>ASC</literal> or <literal>DESC</literal> keyword to set "
"the sort direction to ascending or descending. <literal>ASC</literal> order "
"is the default. Ascending order puts smaller values first, where "
"<quote>smaller</quote> is defined in terms of the <literal>&lt;</literal> "
"operator. Similarly, descending order is determined with the <literal>&gt;</"
"literal> operator. <placeholder-2/>"
msgstr ""
"Порядок сортировки определяет предложение <literal>ORDER BY</literal>: "
"<synopsis>\n"
"SELECT <replaceable>список_выборки</replaceable>\n"
"    FROM <replaceable>табличное_выражение</replaceable>\n"
"    ORDER BY <replaceable>выражение_сортировки1</replaceable> <optional>ASC "
"| DESC</optional> <optional>NULLS { FIRST | LAST }</optional>\n"
"             <optional>, <replaceable>выражение_сортировки2</replaceable> "
"<optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</"
"optional> ...</optional>\n"
"</synopsis> Выражениями сортировки могут быть любые выражения, допустимые в "
"списке выборки запроса. Например: <placeholder-1/> Когда указывается "
"несколько выражений, последующие значения позволяют отсортировать строки, в "
"которых совпали все предыдущие значения. Каждое выражение можно дополнить "
"ключевыми словами <literal>ASC</literal> или <literal>DESC</literal>, "
"которые выбирают сортировку соответственно по возрастанию или убыванию. По "
"умолчанию принят порядок по возрастанию (<literal>ASC</literal>). При "
"сортировке по возрастанию сначала идут меньшие значения, где понятие "
"<quote>меньше</quote> определяется оператором <literal>&lt;</literal>. "
"Подобным образом, сортировка по возрастанию определяется оператором "
"<literal>&gt;</literal>. <placeholder-2/>"

#: queries.xml:1730(para)
msgid ""
"The <literal>NULLS FIRST</literal> and <literal>NULLS LAST</literal> options "
"can be used to determine whether nulls appear before or after non-null "
"values in the sort ordering. By default, null values sort as if larger than "
"any non-null value; that is, <literal>NULLS FIRST</literal> is the default "
"for <literal>DESC</literal> order, and <literal>NULLS LAST</literal> "
"otherwise."
msgstr ""
"Для определения места значений NULL можно использовать указания "
"<literal>NULLS FIRST</literal> и <literal>NULLS LAST</literal>, которые "
"помещают значения NULL соответственно до или после значений не NULL. По "
"умолчанию значения NULL считаются больше любых других, то есть "
"подразумевается <literal>NULLS FIRST</literal> для порядка <literal>DESC</"
"literal> и <literal>NULLS LAST</literal> в противном случае."

#: queries.xml:1738(para)
msgid ""
"Note that the ordering options are considered independently for each sort "
"column. For example <literal>ORDER BY x, y DESC</literal> means "
"<literal>ORDER BY x ASC, y DESC</literal>, which is not the same as "
"<literal>ORDER BY x DESC, y DESC</literal>."
msgstr ""
"Заметьте, что порядки сортировки определяются независимо для каждого "
"столбца. Например, <literal>ORDER BY x, y DESC</literal> означает "
"<literal>ORDER BY x ASC, y DESC</literal>, и это не то же самое, что "
"<literal>ORDER BY x DESC, y DESC</literal>."

#: queries.xml:1748(programlisting)
#, no-wrap
msgid ""
"SELECT a + b AS sum, c FROM table1 ORDER BY sum;\n"
"SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;"
msgstr ""
"SELECT a + b AS sum, c FROM table1 ORDER BY sum;\n"
"SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;"

#: queries.xml:1755(programlisting)
#, no-wrap
msgid "SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- wrong"
msgstr "SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- неправильно"

#: queries.xml:1745(para)
msgid ""
"A <replaceable>sort_expression</replaceable> can also be the column label or "
"number of an output column, as in: <placeholder-1/> both of which sort by "
"the first output column. Note that an output column name has to stand alone, "
"that is, it cannot be used in an expression &mdash; for example, this is "
"<emphasis>not</emphasis> correct: <placeholder-2/> This restriction is made "
"to reduce ambiguity. There is still ambiguity if an <literal>ORDER BY</"
"literal> item is a simple name that could match either an output column name "
"or a column from the table expression. The output column is used in such "
"cases. This would only cause confusion if you use <literal>AS</literal> to "
"rename an output column to match some other table column's name."
msgstr ""
"Здесь <replaceable>выражение_сортировки</replaceable> может быть меткой "
"столбца или номером выводимого столбца, как в данном примере: <placeholder-1/"
">Оба эти запроса сортируют результат по первому столбцу. Заметьте, что имя "
"выводимого столбца должно оставаться само по себе, его нельзя использовать в "
"выражении. Например, это <emphasis>ошибка</emphasis>: <placeholder-2/> Это "
"ограничение позволяет уменьшить неоднозначность. Тем не менее "
"неоднозначность возможна, когда в <literal>ORDER BY</literal> указано "
"простое имя, но оно соответствует и имени выходного столбца, и столбцу из "
"табличного выражения. В этом случае используется выходной столбец. Эта "
"ситуация может возникнуть, только когда с помощью <literal>AS</literal> "
"выходному столбцу назначается то же имя, что имеет столбец в другой таблице."

#: queries.xml:1766(para)
msgid ""
"<literal>ORDER BY</literal> can be applied to the result of a "
"<literal>UNION</literal>, <literal>INTERSECT</literal>, or <literal>EXCEPT</"
"literal> combination, but in this case it is only permitted to sort by "
"output column names or numbers, not by expressions."
msgstr ""
"<literal>ORDER BY</literal> можно применить к результату комбинации "
"<literal>UNION</literal>, <literal>INTERSECT</literal> и <literal>EXCEPT</"
"literal>, но в этом случае возможна сортировка только по номерам или именам "
"столбцов, но не по выражениям."

#: queries.xml:1776(title)
msgid "<literal>LIMIT</literal> and <literal>OFFSET</literal>"
msgstr "<literal>LIMIT</literal> и <literal>OFFSET</literal>"

#: queries.xml:1778(indexterm)
msgid "<primary>LIMIT</primary>"
msgstr "<primary>LIMIT</primary>"

#: queries.xml:1782(indexterm)
msgid "<primary>OFFSET</primary>"
msgstr "<primary>OFFSET</primary>"

#: queries.xml:1786(para)
msgid ""
"<literal>LIMIT</literal> and <literal>OFFSET</literal> allow you to retrieve "
"just a portion of the rows that are generated by the rest of the query: "
"<synopsis>\n"
"SELECT <replaceable>select_list</replaceable>\n"
"    FROM <replaceable>table_expression</replaceable>\n"
"    <optional> ORDER BY ... </optional>\n"
"    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> "
"<optional> OFFSET <replaceable>number</replaceable> </optional>\n"
"</synopsis>"
msgstr ""
"Указания <literal>LIMIT</literal> и <literal>OFFSET</literal> позволяют "
"получить только часть строк из тех, что выдал остальной запрос: <synopsis>\n"
"SELECT <replaceable>список_выборки</replaceable>\n"
"    FROM <replaceable>табличное_выражение</replaceable>\n"
"    <optional> ORDER BY ... </optional>\n"
"    <optional> LIMIT { <replaceable>число</replaceable> | ALL } </optional> "
"<optional> OFFSET <replaceable>число</replaceable> </optional>\n"
"</synopsis>"

#: queries.xml:1797(para)
msgid ""
"If a limit count is given, no more than that many rows will be returned (but "
"possibly fewer, if the query itself yields fewer rows). <literal>LIMIT ALL</"
"literal> is the same as omitting the <literal>LIMIT</literal> clause, as is "
"<literal>LIMIT</literal> with a NULL argument."
msgstr ""
"Если указывается число LIMIT, в результате возвращается не больше заданного "
"числа строк (меньше может быть, если сам запрос выдал меньшее количество "
"строк). <literal>LIMIT ALL</literal> равносильно отсутствию указания "
"<literal>LIMIT</literal>, как и <literal>LIMIT</literal> с аргументом NULL."

#: queries.xml:1804(para)
msgid ""
"<literal>OFFSET</literal> says to skip that many rows before beginning to "
"return rows. <literal>OFFSET 0</literal> is the same as omitting the "
"<literal>OFFSET</literal> clause, as is <literal>OFFSET</literal> with a "
"NULL argument."
msgstr ""
"<literal>OFFSET</literal> указывает пропустить указанное число строк, прежде "
"чем начать выдавать строки. <literal>OFFSET 0</literal> равносильно "
"отсутствию указания <literal>OFFSET</literal>, как и <literal>OFFSET</"
"literal> с аргументом NULL."

#: queries.xml:1810(para)
msgid ""
"If both <literal>OFFSET</literal> and <literal>LIMIT</literal> appear, then "
"<literal>OFFSET</literal> rows are skipped before starting to count the "
"<literal>LIMIT</literal> rows that are returned."
msgstr ""
"Если указано и <literal>OFFSET</literal>, и <literal>LIMIT</literal>, "
"сначала система пропускает <literal>OFFSET</literal> строк, а затем начинает "
"подсчитывать строки для ограничения <literal>LIMIT</literal>."

#: queries.xml:1817(para)
msgid ""
"When using <literal>LIMIT</literal>, it is important to use an "
"<literal>ORDER BY</literal> clause that constrains the result rows into a "
"unique order. Otherwise you will get an unpredictable subset of the query's "
"rows. You might be asking for the tenth through twentieth rows, but tenth "
"through twentieth in what ordering? The ordering is unknown, unless you "
"specified <literal>ORDER BY</literal>."
msgstr ""
"Применяя <literal>LIMIT</literal>, важно использовать также предложение "
"<literal>ORDER BY</literal>, чтобы строки результата выдавались в "
"определённом порядке. Иначе будут возвращаться непредсказуемые подмножества "
"строк. Вы можете запросить строки с десятой по двадцатую, но какой порядок "
"вы имеете в виду? Порядок будет неизвестен, если не добавить <literal>ORDER "
"BY</literal>."

#: queries.xml:1826(para)
msgid ""
"The query optimizer takes <literal>LIMIT</literal> into account when "
"generating query plans, so you are very likely to get different plans "
"(yielding different row orders) depending on what you give for "
"<literal>LIMIT</literal> and <literal>OFFSET</literal>. Thus, using "
"different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to "
"select different subsets of a query result <emphasis>will give inconsistent "
"results</emphasis> unless you enforce a predictable result ordering with "
"<literal>ORDER BY</literal>. This is not a bug; it is an inherent "
"consequence of the fact that SQL does not promise to deliver the results of "
"a query in any particular order unless <literal>ORDER BY</literal> is used "
"to constrain the order."
msgstr ""
"Оптимизатор запроса учитывает ограничение <literal>LIMIT</literal>, строя "
"планы выполнения запросов, поэтому вероятнее всего планы (а значит и порядок "
"строк) будут меняться при разных <literal>LIMIT</literal> и <literal>OFFSET</"
"literal>. Таким образом, различные значения <literal>LIMIT</literal>/"
"<literal>OFFSET</literal>, выбирающие разные подмножества результатов "
"запроса, <emphasis>приведут к несогласованности результатов</emphasis>, если "
"не установить предсказуемую сортировку с помощью <literal>ORDER BY</"
"literal>. Это не ошибка, а неизбежное следствие того, что SQL не гарантирует "
"вывод результатов запроса в некотором порядке, если порядок не определён "
"явно предложением <literal>ORDER BY</literal>."

#: queries.xml:1840(para)
msgid ""
"The rows skipped by an <literal>OFFSET</literal> clause still have to be "
"computed inside the server; therefore a large <literal>OFFSET</literal> "
"might be inefficient."
msgstr ""
"Строки, пропускаемые согласно предложению <literal>OFFSET</literal>, тем не "
"менее должны вычисляться на сервере. Таким образом, при больших значениях "
"<literal>OFFSET</literal> работает неэффективно."

#: queries.xml:1849(title)
msgid "<literal>VALUES</literal> Lists"
msgstr "Списки <literal>VALUES</literal>"

#: queries.xml:1851(indexterm)
msgid "<primary>VALUES</primary>"
msgstr "<primary>VALUES</primary>"

#: queries.xml:1855(para)
msgid ""
"<literal>VALUES</literal> provides a way to generate a <quote>constant "
"table</quote> that can be used in a query without having to actually create "
"and populate a table on-disk. The syntax is <synopsis>\n"
"VALUES ( <replaceable class=\"parameter\">expression</replaceable> [, ...] ) "
"[, ...]\n"
"</synopsis> Each parenthesized list of expressions generates a row in the "
"table. The lists must all have the same number of elements (i.e., the number "
"of columns in the table), and corresponding entries in each list must have "
"compatible data types. The actual data type assigned to each column of the "
"result is determined using the same rules as for <literal>UNION</literal> "
"(see <xref linkend=\"typeconv-union-case\"/>)."
msgstr ""
"Предложение <literal>VALUES</literal> позволяет создать <quote>постоянную "
"таблицу</quote>, которую можно использовать в запросе, не создавая и не "
"наполняя таблицу в БД. Синтаксис предложения: <synopsis>\n"
"VALUES ( <replaceable class=\"parameter\">выражение</replaceable> [, ...] ) "
"[, ...]\n"
"</synopsis> Для каждого списка выражений в скобках создаётся строка таблицы. "
"Все списки должны иметь одинаковое число элементов (т. е. число столбцов в "
"таблице) и соответствующие элементы во всех списках должны иметь совместимые "
"типы данных. Фактический тип данных столбцов результата определяется по тем "
"же правилам, что и для <literal>UNION</literal> (см. <xref remap=\"4\" "
"linkend=\"typeconv-union-case\"/>)."

#: queries.xml:1872(programlisting)
#, no-wrap
msgid "VALUES (1, 'one'), (2, 'two'), (3, 'three');"
msgstr "VALUES (1, 'one'), (2, 'two'), (3, 'three');"

#: queries.xml:1878(programlisting)
#, no-wrap
msgid ""
"SELECT 1 AS column1, 'one' AS column2\n"
"UNION ALL\n"
"SELECT 2, 'two'\n"
"UNION ALL\n"
"SELECT 3, 'three';"
msgstr ""
"SELECT 1 AS column1, 'one' AS column2\n"
"UNION ALL\n"
"SELECT 2, 'two'\n"
"UNION ALL\n"
"SELECT 3, 'three';"

#: queries.xml:1892(programlisting)
#, no-wrap
msgid ""
"=&gt; SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);\n"
" num | letter\n"
"-----+--------\n"
"   1 | one\n"
"   2 | two\n"
"   3 | three\n"
"(3 rows)"
msgstr ""
"=&gt; SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);\n"
" num | letter\n"
"-----+--------\n"
"   1 | one\n"
"   2 | two\n"
"   3 | three\n"
"(3 rows)"

#: queries.xml:1870(para)
msgid ""
"As an example: <placeholder-1/> will return a table of two columns and three "
"rows. It's effectively equivalent to: <placeholder-2/> By default, "
"<productname>PostgreSQL</productname> assigns the names <literal>column1</"
"literal>, <literal>column2</literal>, etc. to the columns of a "
"<literal>VALUES</literal> table. The column names are not specified by the "
"SQL standard and different database systems do it differently, so it's "
"usually better to override the default names with a table alias list, like "
"this: <placeholder-3/>"
msgstr ""
"Как пример: <placeholder-1/> вернёт таблицу из двух столбцов и трёх строк. "
"Это равносильно такому запросу: <placeholder-2/> По умолчанию "
"<productname>PostgreSQL</productname> назначает столбцам таблицы "
"<literal>VALUES</literal> имена <literal>column1</literal>, "
"<literal>column2</literal> и т. д. Имена столбцов не определены в стандарте "
"SQL и в другой СУБД они могут быть другими, поэтому обычно лучше "
"переопределить имена списком псевдонимов, например так: <placeholder-3/>"

#: queries.xml:1903(para)
msgid ""
"Syntactically, <literal>VALUES</literal> followed by expression lists is "
"treated as equivalent to: <synopsis>\n"
"SELECT <replaceable>select_list</replaceable> FROM "
"<replaceable>table_expression</replaceable>\n"
"</synopsis> and can appear anywhere a <literal>SELECT</literal> can. For "
"example, you can use it as part of a <literal>UNION</literal>, or attach a "
"<replaceable>sort_specification</replaceable> (<literal>ORDER BY</literal>, "
"<literal>LIMIT</literal>, and/or <literal>OFFSET</literal>) to it. "
"<literal>VALUES</literal> is most commonly used as the data source in an "
"<command>INSERT</command> command, and next most commonly as a subquery."
msgstr ""
"Синтаксически список <literal>VALUES</literal> с набором выражений "
"равнозначен: <synopsis>\n"
"SELECT <replaceable>список_выборки</replaceable> FROM "
"<replaceable>табличное_выражение</replaceable>\n"
"</synopsis> и допускается везде, где допустим <literal>SELECT</literal>. "
"Например, вы можете использовать его в составе <literal>UNION</literal> или "
"добавить к нему <replaceable>определение_сортировки</replaceable> "
"(<literal>ORDER BY</literal>, <literal>LIMIT</literal> и/или "
"<literal>OFFSET</literal>). <literal>VALUES</literal> чаще всего "
"используется как источник данных для команды <command>INSERT</command>, а "
"также как подзапрос."

#: queries.xml:1917(para)
msgid "For more information see <xref linkend=\"sql-values\"/>."
msgstr ""
"За дополнительными сведениями обратитесь к справке <xref remap=\"1\" linkend="
"\"sql-values\"/>."

#: queries.xml:1925(title)
msgid "<literal>WITH</literal> Queries (Common Table Expressions)"
msgstr "Запросы <literal>WITH</literal> (Общие табличные выражения)"

#: queries.xml:1927(indexterm)
msgid "<primary>WITH</primary> <secondary>in SELECT</secondary>"
msgstr "<primary>WITH</primary> <secondary>внутри SELECT</secondary>"

#: queries.xml:1932(indexterm)
msgid "<primary>common table expression</primary> <see>WITH</see>"
msgstr "<primary>общее табличное выражение</primary> <see>WITH</see>"

#: queries.xml:1937(para)
msgid ""
"<literal>WITH</literal> provides a way to write auxiliary statements for use "
"in a larger query. These statements, which are often referred to as Common "
"Table Expressions or <acronym>CTE</acronym>s, can be thought of as defining "
"temporary tables that exist just for one query. Each auxiliary statement in "
"a <literal>WITH</literal> clause can be a <command>SELECT</command>, "
"<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</"
"command>; and the <literal>WITH</literal> clause itself is attached to a "
"primary statement that can also be a <command>SELECT</command>, "
"<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</"
"command>."
msgstr ""
"<literal>WITH</literal> предоставляет способ записывать дополнительные "
"операторы для применения в больших запросах. Эти операторы, которые также "
"называют общими табличными выражениями (Common Table Expressions, "
"<acronym>CTE</acronym>), можно представить как определения временных таблиц, "
"существующих только для одного запроса. Дополнительным оператором в "
"предложении <literal>WITH</literal> может быть <command>SELECT</command>, "
"<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>, а само предложение <literal>WITH</literal> присоединяется к "
"основному оператору, которым также может быть <command>SELECT</command>, "
"<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>."

#: queries.xml:1950(title)
msgid "<command>SELECT</command> in <literal>WITH</literal>"
msgstr "<command>SELECT</command> в <literal>WITH</literal>"

#: queries.xml:1956(programlisting)
#, no-wrap
msgid ""
"WITH regional_sales AS (\n"
"        SELECT region, SUM(amount) AS total_sales\n"
"        FROM orders\n"
"        GROUP BY region\n"
"     ), top_regions AS (\n"
"        SELECT region\n"
"        FROM regional_sales\n"
"        WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)\n"
"     )\n"
"SELECT region,\n"
"       product,\n"
"       SUM(quantity) AS product_units,\n"
"       SUM(amount) AS product_sales\n"
"FROM orders\n"
"WHERE region IN (SELECT region FROM top_regions)\n"
"GROUP BY region, product;"
msgstr ""
"WITH regional_sales AS (\n"
"    SELECT region, SUM(amount) AS total_sales\n"
"    FROM orders\n"
"    GROUP BY region\n"
"   ), top_regions AS (\n"
"    SELECT region\n"
"    FROM regional_sales\n"
"    WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)\n"
"   )\n"
"SELECT region,\n"
"   product,\n"
"   SUM(quantity) AS product_units,\n"
"   SUM(amount) AS product_sales\n"
"FROM orders\n"
"WHERE region IN (SELECT region FROM top_regions)\n"
"GROUP BY region, product;"

#: queries.xml:1952(para)
msgid ""
"The basic value of <command>SELECT</command> in <literal>WITH</literal> is "
"to break down complicated queries into simpler parts. An example is: "
"<placeholder-1/> which displays per-product sales totals in only the top "
"sales regions. The <literal>WITH</literal> clause defines two auxiliary "
"statements named <structname>regional_sales</structname> and "
"<structname>top_regions</structname>, where the output of "
"<structname>regional_sales</structname> is used in <structname>top_regions</"
"structname> and the output of <structname>top_regions</structname> is used "
"in the primary <command>SELECT</command> query. This example could have been "
"written without <literal>WITH</literal>, but we'd have needed two levels of "
"nested sub-<command>SELECT</command>s. It's a bit easier to follow this way."
msgstr ""
"Основное предназначение <command>SELECT</command> в предложении "
"<literal>WITH</literal> заключается в разбиении сложных запросов на простые "
"части. Например, запрос: <placeholder-1/> выводит итоги по продажам только "
"для передовых регионов. Предложение <literal>WITH</literal> определяет два "
"дополнительных оператора <structname>regional_sales</structname> и "
"<structname>top_regions</structname> так, что результат "
"<structname>regional_sales</structname> используется в "
"<structname>top_regions</structname>, а результат <structname>top_regions</"
"structname> используется в основном запросе <command>SELECT</command>. Этот "
"пример можно было бы переписать без <literal>WITH</literal>, но тогда нам "
"понадобятся два уровня вложенных подзапросов <command>SELECT</command>. "
"Показанным выше способом это можно сделать немного проще."

#: queries.xml:1994(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE t(n) AS (\n"
"    VALUES (1)\n"
"  UNION ALL\n"
"    SELECT n+1 FROM t WHERE n &lt; 100\n"
")\n"
"SELECT sum(n) FROM t;"
msgstr ""
"WITH RECURSIVE t(n) AS (\n"
"    VALUES (1)\n"
"  UNION ALL\n"
"    SELECT n+1 FROM t WHERE n &lt; 100\n"
")\n"
"SELECT sum(n) FROM t;"

#: queries.xml:1986(para)
msgid ""
"The optional <literal>RECURSIVE</literal> modifier changes <literal>WITH</"
"literal> from a mere syntactic convenience into a feature that accomplishes "
"things not otherwise possible in standard SQL. Using <literal>RECURSIVE</"
"literal>, a <literal>WITH</literal> query can refer to its own output. A "
"very simple example is this query to sum the integers from 1 through 100: "
"<placeholder-1/> The general form of a recursive <literal>WITH</literal> "
"query is always a <firstterm>non-recursive term</firstterm>, then "
"<literal>UNION</literal> (or <literal>UNION ALL</literal>), then a "
"<firstterm>recursive term</firstterm>, where only the recursive term can "
"contain a reference to the query's own output. Such a query is executed as "
"follows:"
msgstr ""
"Необязательное указание <literal>RECURSIVE</literal> превращает "
"<literal>WITH</literal> из простого синтаксического удобства в средство "
"реализации того, что невозможно в стандартном SQL. Используя "
"<literal>RECURSIVE</literal>, запрос <literal>WITH</literal> может "
"обращаться к собственному результату. Очень простой пример, суммирующий "
"числа от 1 до 100: <placeholder-1/> В общем виде рекурсивный запрос "
"<literal>WITH</literal> всегда записывается как <firstterm>не рекурсивная "
"часть</firstterm>, потом <literal>UNION</literal> (или <literal>UNION ALL</"
"literal>), а затем <firstterm>рекурсивная часть</firstterm>, где только в "
"рекурсивной части можно обратиться к результату запроса. Такой запрос "
"выполняется следующим образом:"

#: queries.xml:2012(title)
msgid "Recursive Query Evaluation"
msgstr "Вычисление рекурсивного запроса"

#: queries.xml:2015(para)
msgid ""
"Evaluate the non-recursive term. For <literal>UNION</literal> (but not "
"<literal>UNION ALL</literal>), discard duplicate rows. Include all remaining "
"rows in the result of the recursive query, and also place them in a "
"temporary <firstterm>working table</firstterm>."
msgstr ""
"Вычисляется не рекурсивная часть. Для <literal>UNION</literal> (но не "
"<literal>UNION ALL</literal>) отбрасываются дублирующиеся строки. Все "
"оставшиеся строки включаются в результат рекурсивного запроса и также "
"помещаются во временную <firstterm>рабочую таблицу</firstterm>."

#: queries.xml:2024(para)
msgid "So long as the working table is not empty, repeat these steps:"
msgstr "Пока рабочая таблица не пуста, повторяются следующие действия:"

#: queries.xml:2029(para)
msgid ""
"Evaluate the recursive term, substituting the current contents of the "
"working table for the recursive self-reference. For <literal>UNION</literal> "
"(but not <literal>UNION ALL</literal>), discard duplicate rows and rows that "
"duplicate any previous result row. Include all remaining rows in the result "
"of the recursive query, and also place them in a temporary "
"<firstterm>intermediate table</firstterm>."
msgstr ""
"Вычисляется рекурсивная часть так, что рекурсивная ссылка на сам запрос "
"обращается к текущему содержимому рабочей таблицы. Для <literal>UNION</"
"literal> (но не <literal>UNION ALL</literal>) отбрасываются дублирующиеся "
"строки и строки, дублирующие ранее полученные. Все оставшиеся строки "
"включаются в результат рекурсивного запроса и также помещаются во временную "
"<firstterm>промежуточную таблицу</firstterm>."

#: queries.xml:2040(para)
msgid ""
"Replace the contents of the working table with the contents of the "
"intermediate table, then empty the intermediate table."
msgstr ""
"Содержимое рабочей таблицы заменяется содержимым промежуточной таблицы, а "
"затем промежуточная таблица очищается."

#: queries.xml:2050(para)
msgid ""
"Strictly speaking, this process is iteration not recursion, but "
"<literal>RECURSIVE</literal> is the terminology chosen by the SQL standards "
"committee."
msgstr ""
"Строго говоря, этот процесс является итерационным, а не рекурсивным, но "
"комитетом по стандартам SQL был выбран термин <literal>RECURSIVE</literal>."

#: queries.xml:2057(para)
msgid ""
"In the example above, the working table has just a single row in each step, "
"and it takes on the values from 1 through 100 in successive steps. In the "
"100th step, there is no output because of the <literal>WHERE</literal> "
"clause, and so the query terminates."
msgstr ""
"В показанном выше примере в рабочей таблице на каждом этапе содержится всего "
"одна строка и в ней последовательно накапливаются значения от 1 до 100. На "
"сотом шаге, благодаря условию <literal>WHERE</literal>, не возвращается "
"ничего, так что вычисление запроса завершается."

#: queries.xml:2070(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE included_parts(sub_part, part, quantity) AS (\n"
"    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'\n"
"  UNION ALL\n"
"    SELECT p.sub_part, p.part, p.quantity\n"
"    FROM included_parts pr, parts p\n"
"    WHERE p.part = pr.sub_part\n"
"  )\n"
"SELECT sub_part, SUM(quantity) as total_quantity\n"
"FROM included_parts\n"
"GROUP BY sub_part"
msgstr ""
"WITH RECURSIVE included_parts(sub_part, part, quantity) AS (\n"
"    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'\n"
"  UNION ALL\n"
"    SELECT p.sub_part, p.part, p.quantity\n"
"    FROM included_parts pr, parts p\n"
"    WHERE p.part = pr.sub_part\n"
"  )\n"
"SELECT sub_part, SUM(quantity) as total_quantity\n"
"FROM included_parts\n"
"GROUP BY sub_part"

#: queries.xml:2064(para)
msgid ""
"Recursive queries are typically used to deal with hierarchical or tree-"
"structured data. A useful example is this query to find all the direct and "
"indirect sub-parts of a product, given only a table that shows immediate "
"inclusions: <placeholder-1/>"
msgstr ""
"Рекурсивные запросы обычно применяются для работы с иерархическими или "
"древовидными структурами данных. В качестве полезного примера можно привести "
"запрос, находящий все непосредственные и косвенные составные части продукта, "
"используя только таблицу с прямыми связями: <placeholder-1/>"

#: queries.xml:2097(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE search_graph(id, link, data, depth) AS (\n"
"        SELECT g.id, g.link, g.data, 1\n"
"        FROM graph g\n"
"      UNION ALL\n"
"        SELECT g.id, g.link, g.data, sg.depth + 1\n"
"        FROM graph g, search_graph sg\n"
"        WHERE g.id = sg.link\n"
")\n"
"SELECT * FROM search_graph;"
msgstr ""
"WITH RECURSIVE search_graph(id, link, data, depth) AS (\n"
"        SELECT g.id, g.link, g.data, 1\n"
"        FROM graph g\n"
"      UNION ALL\n"
"        SELECT g.id, g.link, g.data, sg.depth + 1\n"
"        FROM graph g, search_graph sg\n"
"        WHERE g.id = sg.link\n"
")\n"
"SELECT * FROM search_graph;"

#: queries.xml:2116(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n"
"        SELECT g.id, g.link, g.data, 1,\n"
"          ARRAY[g.id],\n"
"          false\n"
"        FROM graph g\n"
"      UNION ALL\n"
"        SELECT g.id, g.link, g.data, sg.depth + 1,\n"
"          path || g.id,\n"
"          g.id = ANY(path)\n"
"        FROM graph g, search_graph sg\n"
"        WHERE g.id = sg.link AND NOT cycle\n"
")\n"
"SELECT * FROM search_graph;"
msgstr ""
"WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n"
"        SELECT g.id, g.link, g.data, 1,\n"
"          ARRAY[g.id],\n"
"          false\n"
"        FROM graph g\n"
"      UNION ALL\n"
"        SELECT g.id, g.link, g.data, sg.depth + 1,\n"
"          path || g.id,\n"
"          g.id = ANY(path)\n"
"        FROM graph g, search_graph sg\n"
"        WHERE g.id = sg.link AND NOT cycle\n"
")\n"
"SELECT * FROM search_graph;"

#: queries.xml:2084(para)
msgid ""
"When working with recursive queries it is important to be sure that the "
"recursive part of the query will eventually return no tuples, or else the "
"query will loop indefinitely. Sometimes, using <literal>UNION</literal> "
"instead of <literal>UNION ALL</literal> can accomplish this by discarding "
"rows that duplicate previous output rows. However, often a cycle does not "
"involve output rows that are completely duplicate: it may be necessary to "
"check just one or a few fields to see if the same point has been reached "
"before. The standard method for handling such situations is to compute an "
"array of the already-visited values. For example, consider the following "
"query that searches a table <structname>graph</structname> using a "
"<structfield>link</structfield> field: <placeholder-1/> This query will loop "
"if the <structfield>link</structfield> relationships contain cycles. Because "
"we require a <quote>depth</quote> output, just changing <literal>UNION ALL</"
"literal> to <literal>UNION</literal> would not eliminate the looping. "
"Instead we need to recognize whether we have reached the same row again "
"while following a particular path of links. We add two columns "
"<structfield>path</structfield> and <structfield>cycle</structfield> to the "
"loop-prone query: <placeholder-2/> Aside from preventing cycles, the array "
"value is often useful in its own right as representing the <quote>path</"
"quote> taken to reach any particular row."
msgstr ""
"Работая с рекурсивными запросами, важно обеспечить, чтобы рекурсивная часть "
"запроса в конце концов не выдала никаких кортежей (строк), в противном "
"случае цикл будет бесконечным. Иногда для этого достаточно применять "
"<literal>UNION</literal> вместо <literal>UNION ALL</literal>, так как при "
"этом будут отбрасываться строки, которые уже есть в результате. Однако часто "
"в цикле выдаются строки, не совпадающие полностью с предыдущими: в таких "
"случаях может иметь смысл проверить одно или несколько полей, чтобы "
"определить, не была ли текущая точка достигнута раньше. Стандартный способ "
"решения подобных задач &mdash; вычислить массив с уже обработанными "
"значениями. Например, рассмотрите следующий запрос, просматривающий таблицу "
"<structname>graph</structname> по полю <structfield>link</structfield>: "
"<placeholder-1/> Этот запрос зациклится, если связи <structfield>link</"
"structfield> содержат циклы. Так как нам нужно получать в результате "
"<quote>depth</quote>, одно лишь изменение <literal>UNION ALL</literal> на "
"<literal>UNION</literal> не позволит избежать зацикливания. Вместо этого мы "
"должны как-то определить, что уже достигали текущей строки, пройдя некоторый "
"путь. Для этого мы добавляем два столбца <structfield>path</structfield> и "
"<structfield>cycle</structfield> и получаем запрос, защищённый от "
"зацикливания: <placeholder-2/> Помимо предотвращения циклов, значения "
"массива часто бывают полезны сами по себе для представления <quote>пути</"
"quote>, приведшего к определённой строке."

#: queries.xml:2141(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n"
"        SELECT g.id, g.link, g.data, 1,\n"
"          ARRAY[ROW(g.f1, g.f2)],\n"
"          false\n"
"        FROM graph g\n"
"      UNION ALL\n"
"        SELECT g.id, g.link, g.data, sg.depth + 1,\n"
"          path || ROW(g.f1, g.f2),\n"
"          ROW(g.f1, g.f2) = ANY(path)\n"
"        FROM graph g, search_graph sg\n"
"        WHERE g.id = sg.link AND NOT cycle\n"
")\n"
"SELECT * FROM search_graph;"
msgstr ""
"WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n"
"        SELECT g.id, g.link, g.data, 1,\n"
"          ARRAY[ROW(g.f1, g.f2)],\n"
"          false\n"
"        FROM graph g\n"
"      UNION ALL\n"
"        SELECT g.id, g.link, g.data, sg.depth + 1,\n"
"          path || ROW(g.f1, g.f2),\n"
"          ROW(g.f1, g.f2) = ANY(path)\n"
"        FROM graph g, search_graph sg\n"
"        WHERE g.id = sg.link AND NOT cycle\n"
")\n"
"SELECT * FROM search_graph;"

#: queries.xml:2136(para)
msgid ""
"In the general case where more than one field needs to be checked to "
"recognize a cycle, use an array of rows. For example, if we needed to "
"compare fields <structfield>f1</structfield> and <structfield>f2</"
"structfield>: <placeholder-1/>"
msgstr ""
"В общем случае, когда для выявления цикла нужно проверять несколько полей, "
"следует использовать массив строк. Например, если нужно сравнить поля "
"<structfield>f1</structfield> и <structfield>f2</structfield>: "
"<placeholder-1/>"

#: queries.xml:2159(para)
msgid ""
"Omit the <literal>ROW()</literal> syntax in the common case where only one "
"field needs to be checked to recognize a cycle. This allows a simple array "
"rather than a composite-type array to be used, gaining efficiency."
msgstr ""
"Часто для распознавания цикла достаточного одного поля и тогда "
"<literal>ROW()</literal> можно опустить. При этом будет использоваться не "
"массив данных составного типа, а простой массив, что более эффективно."

#: queries.xml:2167(para)
msgid ""
"The recursive query evaluation algorithm produces its output in breadth-"
"first search order. You can display the results in depth-first search order "
"by making the outer query <literal>ORDER BY</literal> a <quote>path</quote> "
"column constructed in this way."
msgstr ""
"Этот алгоритм рекурсивного вычисления запроса выдаёт в результате узлы, "
"упорядоченные по пути погружения. Чтобы получить результаты, отсортированные "
"по глубине, можно добавить во внешний запрос <literal>ORDER BY</literal> по "
"столбцу <quote>path</quote>, полученному, как показано выше."

#: queries.xml:2181(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE t(n) AS (\n"
"    SELECT 1\n"
"  UNION ALL\n"
"    SELECT n+1 FROM t\n"
")\n"
"SELECT n FROM t LIMIT 100;"
msgstr ""
"WITH RECURSIVE t(n) AS (\n"
"    SELECT 1\n"
"  UNION ALL\n"
"    SELECT n+1 FROM t\n"
")\n"
"SELECT n FROM t LIMIT 100;"

#: queries.xml:2175(para)
msgid ""
"A helpful trick for testing queries when you are not certain if they might "
"loop is to place a <literal>LIMIT</literal> in the parent query. For "
"example, this query would loop forever without the <literal>LIMIT</literal>: "
"<placeholder-1/> This works because <productname>PostgreSQL</productname>'s "
"implementation evaluates only as many rows of a <literal>WITH</literal> "
"query as are actually fetched by the parent query. Using this trick in "
"production is not recommended, because other systems might work differently. "
"Also, it usually won't work if you make the outer query sort the recursive "
"query's results or join them to some other table, because in such cases the "
"outer query will usually try to fetch all of the <literal>WITH</literal> "
"query's output anyway."
msgstr ""
"Для тестирования запросов, которые могут зацикливаться, есть хороший приём "
"&mdash; добавить <literal>LIMIT</literal> в родительский запрос. Например, "
"следующий запрос зациклится, если не добавить предложение <literal>LIMIT</"
"literal>: <placeholder-1/> Но в данном случае этого не происходит, так как в "
"<productname>PostgreSQL</productname> запрос <literal>WITH</literal> выдаёт "
"столько строк, сколько фактически принимает родительский запрос. В "
"производственной среде использовать этот приём не рекомендуется, так как "
"другие системы могут вести себя по-другому. Кроме того, это не будет "
"работать, если внешний запрос сортирует результаты рекурсивного запроса или "
"соединяет их с другой таблицей, так как в подобных случаях внешний запрос "
"обычно всё равно выбирает результат запроса <literal>WITH</literal> "
"полностью."

#: queries.xml:2200(para)
msgid ""
"A useful property of <literal>WITH</literal> queries is that they are "
"evaluated only once per execution of the parent query, even if they are "
"referred to more than once by the parent query or sibling <literal>WITH</"
"literal> queries. Thus, expensive calculations that are needed in multiple "
"places can be placed within a <literal>WITH</literal> query to avoid "
"redundant work. Another possible application is to prevent unwanted multiple "
"evaluations of functions with side-effects. However, the other side of this "
"coin is that the optimizer is less able to push restrictions from the parent "
"query down into a <literal>WITH</literal> query than an ordinary subquery. "
"The <literal>WITH</literal> query will generally be evaluated as written, "
"without suppression of rows that the parent query might discard afterwards. "
"(But, as mentioned above, evaluation might stop early if the reference(s) to "
"the query demand only a limited number of rows.)"
msgstr ""
"Запросы <literal>WITH</literal> имеют полезное свойство &mdash; они "
"вычисляются только раз для всего родительского запроса, даже если этот "
"запрос или соседние запросы <literal>WITH</literal> обращаются к ним "
"неоднократно. Таким образом, сложные вычисления, результаты которых нужны в "
"нескольких местах, можно выносить в запросы <literal>WITH</literal> в целях "
"оптимизации. Кроме того, такие запросы позволяют избежать нежелательных "
"вычислений функций с побочными эффектами. Однако есть и обратная сторона "
"&mdash; оптимизатор не может распространить ограничения родительского "
"запроса на запрос <literal>WITH</literal> так, как он делает это для "
"обычного подзапроса. Запрос <literal>WITH</literal> обычно выполняется "
"буквально и возвращает все строки, включая те, что потом может отбросить "
"родительский запрос. (Но как было сказано выше, вычисление может "
"остановиться раньше, если в ссылке на этот запрос затребуется только "
"ограниченное число строк.)"

#: queries.xml:2217(para)
msgid ""
"The examples above only show <literal>WITH</literal> being used with "
"<command>SELECT</command>, but it can be attached in the same way to "
"<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</"
"command>. In each case it effectively provides temporary table(s) that can "
"be referred to in the main command."
msgstr ""
"Примеры выше показывают только предложение <literal>WITH</literal> с "
"<command>SELECT</command>, но таким же образом его можно использовать с "
"командами <command>INSERT</command>, <command>UPDATE</command> и "
"<command>DELETE</command>. В каждом случае он по сути создаёт временную "
"таблицу, к которой можно обратиться в основной команде."

#: queries.xml:2227(title)
msgid "Data-Modifying Statements in <literal>WITH</literal>"
msgstr "Изменение данных в <literal>WITH</literal>"

#: queries.xml:2235(programlisting)
#, no-wrap
msgid ""
"WITH moved_rows AS (\n"
"    DELETE FROM products\n"
"    WHERE\n"
"        \"date\" &gt;= '2010-10-01' AND\n"
"        \"date\" &lt; '2010-11-01'\n"
"    RETURNING *\n"
")\n"
"INSERT INTO products_log\n"
"SELECT * FROM moved_rows;"
msgstr ""
"WITH moved_rows AS (\n"
"    DELETE FROM products\n"
"    WHERE\n"
"        \"date\" &gt;= '2010-10-01' AND\n"
"        \"date\" &lt; '2010-11-01'\n"
"    RETURNING *\n"
")\n"
"INSERT INTO products_log\n"
"SELECT * FROM moved_rows;"

#: queries.xml:2229(para)
msgid ""
"You can use data-modifying statements (<command>INSERT</command>, "
"<command>UPDATE</command>, or <command>DELETE</command>) in <literal>WITH</"
"literal>. This allows you to perform several different operations in the "
"same query. An example is: <placeholder-1/> This query effectively moves "
"rows from <structname>products</structname> to <structname>products_log</"
"structname>. The <command>DELETE</command> in <literal>WITH</literal> "
"deletes the specified rows from <structname>products</structname>, returning "
"their contents by means of its <literal>RETURNING</literal> clause; and then "
"the primary query reads that output and inserts it into "
"<structname>products_log</structname>."
msgstr ""
"В предложении <literal>WITH</literal> можно также использовать операторы, "
"изменяющие данные (<command>INSERT</command>, <command>UPDATE</command> или "
"<command>DELETE</command>). Это позволяет выполнять в одном запросе сразу "
"несколько разных операций. Например: <placeholder-1/> Этот запрос фактически "
"перемещает строки из <structname>products</structname> в "
"<structname>products_log</structname>. Оператор <command>DELETE</command> в "
"<literal>WITH</literal> удаляет указанные строки из <structname>products</"
"structname> и возвращает их содержимое в предложении <literal>RETURNING</"
"literal>; а затем главный запрос читает это содержимое и вставляет в таблицу "
"<structname>products_log</structname>."

#: queries.xml:2255(para)
msgid ""
"A fine point of the above example is that the <literal>WITH</literal> clause "
"is attached to the <command>INSERT</command>, not the sub-<command>SELECT</"
"command> within the <command>INSERT</command>. This is necessary because "
"data-modifying statements are only allowed in <literal>WITH</literal> "
"clauses that are attached to the top-level statement. However, normal "
"<literal>WITH</literal> visibility rules apply, so it is possible to refer "
"to the <literal>WITH</literal> statement's output from the sub-"
"<command>SELECT</command>."
msgstr ""
"Следует заметить, что предложение <literal>WITH</literal> в данном случае "
"присоединяется к оператору <command>INSERT</command>, а не к "
"<command>SELECT</command>, вложенному в <command>INSERT</command>. Это "
"необходимо, так как <literal>WITH</literal> может содержать операторы, "
"изменяющие данные, только на верхнем уровне запроса. Однако при этом "
"применяются обычные правила видимости <literal>WITH</literal>, так что к "
"результату <literal>WITH</literal> можно обратиться и из вложенного "
"оператора <command>SELECT</command>."

#: queries.xml:2277(programlisting)
#, no-wrap
msgid ""
"WITH t AS (\n"
"    DELETE FROM foo\n"
")\n"
"DELETE FROM bar;"
msgstr ""
"WITH t AS (\n"
"    DELETE FROM foo\n"
")\n"
"DELETE FROM bar;"

#: queries.xml:2265(para)
msgid ""
"Data-modifying statements in <literal>WITH</literal> usually have "
"<literal>RETURNING</literal> clauses (see <xref linkend=\"dml-returning\"/"
">), as shown in the example above. It is the output of the "
"<literal>RETURNING</literal> clause, <emphasis>not</emphasis> the target "
"table of the data-modifying statement, that forms the temporary table that "
"can be referred to by the rest of the query. If a data-modifying statement "
"in <literal>WITH</literal> lacks a <literal>RETURNING</literal> clause, then "
"it forms no temporary table and cannot be referred to in the rest of the "
"query. Such a statement will be executed nonetheless. A not-particularly-"
"useful example is: <placeholder-1/> This example would remove all rows from "
"tables <structname>foo</structname> and <structname>bar</structname>. The "
"number of affected rows reported to the client would only include rows "
"removed from <structname>bar</structname>."
msgstr ""
"Операторы, изменяющие данные, в <literal>WITH</literal> обычно дополняются "
"предложением <literal>RETURNING</literal> (см. <xref remap=\"4\" linkend="
"\"dml-returning\"/>), как показано в этом примере. Важно понимать, что "
"временная таблица, которую можно будет использовать в остальном запросе, "
"создаётся из результата <literal>RETURNING</literal>, а <emphasis>не</"
"emphasis> целевой таблицы оператора. Если оператор, изменяющий данные, в "
"<literal>WITH</literal> не дополнен предложением <literal>RETURNING</"
"literal>, временная таблица не создаётся и обращаться к ней в остальном "
"запросе нельзя. Однако такой запрос всё равно будет выполнен. Например, "
"допустим следующий не очень практичный запрос: <placeholder-1/> Он удалит "
"все строки из таблиц <structname>foo</structname> и <structname>bar</"
"structname>. При этом число задействованных строк, которое получит клиент, "
"будет подсчитываться только по строкам, удалённым из <structname>bar</"
"structname>."

#: queries.xml:2294(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE included_parts(sub_part, part) AS (\n"
"    SELECT sub_part, part FROM parts WHERE part = 'our_product'\n"
"  UNION ALL\n"
"    SELECT p.sub_part, p.part\n"
"    FROM included_parts pr, parts p\n"
"    WHERE p.part = pr.sub_part\n"
"  )\n"
"DELETE FROM parts\n"
"  WHERE part IN (SELECT part FROM included_parts);"
msgstr ""
"WITH RECURSIVE included_parts(sub_part, part) AS (\n"
"    SELECT sub_part, part FROM parts WHERE part = 'our_product'\n"
"  UNION ALL\n"
"    SELECT p.sub_part, p.part\n"
"    FROM included_parts pr, parts p\n"
"    WHERE p.part = pr.sub_part\n"
"  )\n"
"DELETE FROM parts\n"
"  WHERE part IN (SELECT part FROM included_parts);"

#: queries.xml:2289(para)
msgid ""
"Recursive self-references in data-modifying statements are not allowed. In "
"some cases it is possible to work around this limitation by referring to the "
"output of a recursive <literal>WITH</literal>, for example: <placeholder-1/> "
"This query would remove all direct and indirect subparts of a product."
msgstr ""
"Рекурсивные ссылки в операторах, изменяющих данные, не допускаются. В "
"некоторых случаях это ограничение можно обойти, обратившись к конечному "
"результату рекурсивного <literal>WITH</literal>, например так: "
"<placeholder-1/> Этот запрос удаляет все непосредственные и косвенные "
"составные части продукта."

#: queries.xml:2309(para)
msgid ""
"Data-modifying statements in <literal>WITH</literal> are executed exactly "
"once, and always to completion, independently of whether the primary query "
"reads all (or indeed any) of their output. Notice that this is different "
"from the rule for <command>SELECT</command> in <literal>WITH</literal>: as "
"stated in the previous section, execution of a <command>SELECT</command> is "
"carried only as far as the primary query demands its output."
msgstr ""
"Операторы, изменяющие данные в <literal>WITH</literal>, выполняются только "
"один раз и всегда полностью, вне зависимости от того, принимает ли их "
"результат основной запрос. Заметьте, что это отличается от поведения "
"<command>SELECT</command> в <literal>WITH</literal>: как говорилось в "
"предыдущем разделе, <command>SELECT</command> выполняется только до тех пор, "
"пока его результаты востребованы основным запросом."

#: queries.xml:2330(programlisting)
#, no-wrap
msgid ""
"WITH t AS (\n"
"    UPDATE products SET price = price * 1.05\n"
"    RETURNING *\n"
")\n"
"SELECT * FROM products;"
msgstr ""
"WITH t AS (\n"
"    UPDATE products SET price = price * 1.05\n"
"    RETURNING *\n"
")\n"
"SELECT * FROM products;"

#: queries.xml:2341(programlisting)
#, no-wrap
msgid ""
"WITH t AS (\n"
"    UPDATE products SET price = price * 1.05\n"
"    RETURNING *\n"
")\n"
"SELECT * FROM t;"
msgstr ""
"WITH t AS (\n"
"    UPDATE products SET price = price * 1.05\n"
"    RETURNING *\n"
")\n"
"SELECT * FROM t;"

#: queries.xml:2318(para)
msgid ""
"The sub-statements in <literal>WITH</literal> are executed concurrently with "
"each other and with the main query. Therefore, when using data-modifying "
"statements in <literal>WITH</literal>, the order in which the specified "
"updates actually happen is unpredictable. All the statements are executed "
"with the same <firstterm>snapshot</firstterm> (see <xref linkend=\"mvcc\"/"
">), so they cannot <quote>see</quote> one another's effects on the target "
"tables. This alleviates the effects of the unpredictability of the actual "
"order of row updates, and means that <literal>RETURNING</literal> data is "
"the only way to communicate changes between different <literal>WITH</"
"literal> sub-statements and the main query. An example of this is that in "
"<placeholder-1/> the outer <command>SELECT</command> would return the "
"original prices before the action of the <command>UPDATE</command>, while in "
"<placeholder-2/> the outer <command>SELECT</command> would return the "
"updated data."
msgstr ""
"Вложенные операторы в <literal>WITH</literal> выполняются одновременно друг "
"с другом и с основным запросом. Таким образом, порядок, в котором операторы "
"в <literal>WITH</literal> будут фактически изменять данные, непредсказуем. "
"Все эти операторы выполняются с одним <firstterm>снимком данных</firstterm> "
"(см. <xref remap=\"4\" linkend=\"mvcc\"/>), так что они не могут "
"<quote>видеть</quote>, как каждый из них меняет целевые таблицы. Это "
"уменьшает эффект непредсказуемости фактического порядка изменения строк и "
"означает, что <literal>RETURNING</literal> &mdash; единственный вариант "
"передачи изменений от вложенных операторов <literal>WITH</literal> основному "
"запросу. Например, в данном случае: <placeholder-1/> внешний оператор "
"<command>SELECT</command> выдаст цены, которые были до действия "
"<command>UPDATE</command>, тогда как в запросе <placeholder-2/> внешний "
"<command>SELECT</command> выдаст изменённые данные."

#: queries.xml:2352(para)
msgid ""
"Trying to update the same row twice in a single statement is not supported. "
"Only one of the modifications takes place, but it is not easy (and sometimes "
"not possible) to reliably predict which one. This also applies to deleting a "
"row that was already updated in the same statement: only the update is "
"performed. Therefore you should generally avoid trying to modify a single "
"row twice in a single statement. In particular avoid writing <literal>WITH</"
"literal> sub-statements that could affect the same rows changed by the main "
"statement or a sibling sub-statement. The effects of such a statement will "
"not be predictable."
msgstr ""
"Неоднократное изменение одной и той же строки в рамках одного оператора не "
"поддерживается. Иметь место будет только одно из нескольких изменений и "
"надёжно определить, какое именно, часто довольно сложно (а иногда и вовсе "
"невозможно). Это так же касается случая, когда строка удаляется и изменяется "
"в том же операторе: в результате может быть выполнено только обновление. "
"Поэтому в общем случае следует избегать подобного наложения операций. В "
"частности, избегайте подзапросов <literal>WITH</literal>, которые могут "
"повлиять на строки, изменяемые основным оператором или операторами, "
"вложенные в него. Результат действия таких запросов будет непредсказуемым."

#: queries.xml:2364(para)
msgid ""
"At present, any table used as the target of a data-modifying statement in "
"<literal>WITH</literal> must not have a conditional rule, nor an "
"<literal>ALSO</literal> rule, nor an <literal>INSTEAD</literal> rule that "
"expands to multiple statements."
msgstr ""
"В настоящее время, для оператора, изменяющего данные в <literal>WITH</"
"literal>, в качестве целевой нельзя использовать таблицу, для которой "
"определено условное правило или правило <literal>ALSO</literal> или "
"<literal>INSTEAD</literal>, если оно состоит из нескольких операторов."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: queries.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
