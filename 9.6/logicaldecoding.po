# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-05-10 10:49+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: logicaldecoding.xml:4(title) logicaldecoding.xml:174(title)
msgid "Logical Decoding"
msgstr "Логическое декодирование"

#: logicaldecoding.xml:5(indexterm) logicaldecoding.xml:176(indexterm)
msgid "<primary>Logical Decoding</primary>"
msgstr "<primary>Логическое декодирование</primary>"

#: logicaldecoding.xml:8(para)
msgid ""
"PostgreSQL provides infrastructure to stream the modifications performed via "
"SQL to external consumers. This functionality can be used for a variety of "
"purposes, including replication solutions and auditing."
msgstr ""
"PostgreSQL обеспечивает инфраструктуру для потоковой передачи изменений, "
"выполняемых через SQL, внешним потребителям. Эта функциональность может быть "
"полезна для самых разных целей, включая аудит и реализацию репликации."

#: logicaldecoding.xml:14(para)
msgid ""
"Changes are sent out in streams identified by logical replication slots."
msgstr ""
"Изменения передаются в потоках, связываемых со слотами логической репликации."

#: logicaldecoding.xml:18(para)
msgid ""
"The format in which those changes are streamed is determined by the output "
"plugin used. An example plugin is provided in the PostgreSQL distribution. "
"Additional plugins can be written to extend the choice of available formats "
"without modifying any core code. Every output plugin has access to each "
"individual new row produced by <command>INSERT</command> and the new row "
"version created by <command>UPDATE</command>. Availability of old row "
"versions for <command>UPDATE</command> and <command>DELETE</command> depends "
"on the configured replica identity (see <xref linkend=\"sql-createtable-"
"replica-identity\"/>)."
msgstr ""
"Формат, в котором передаются изменения, определяет используемый модуль "
"вывода. Пример модуля вывода включён в дистрибутив PostgreSQL. Также "
"возможно разработать и другие модули, расширяющие выбор доступных форматов, "
"не затрагивая код ядра самого сервера. Любой модуль вывода получает на вход "
"отдельные строки, создаваемые командой <command>INSERT</command>, и новые "
"версии строк, которые создаёт <command>UPDATE</command>. Доступность старых "
"версий строк для <command>UPDATE</command> и <command>DELETE</command> "
"зависит от выбора варианта идентификации реплики (см. описание <xref linkend="
"\"sql-createtable-replica-identity\"/>)."

#: logicaldecoding.xml:31(para)
msgid ""
"Changes can be consumed either using the streaming replication protocol (see "
"<xref linkend=\"protocol-replication\"/> and <xref linkend=\"logicaldecoding-"
"walsender\"/>), or by calling functions via SQL (see <xref linkend="
"\"logicaldecoding-sql\"/>). It is also possible to write additional methods "
"of consuming the output of a replication slot without modifying core code "
"(see <xref linkend=\"logicaldecoding-writer\"/>)."
msgstr ""
"Изменения могут быть получены либо по протоколу потоковой репликации (см. "
"<xref remap=\"4\" linkend=\"protocol-replication\"/> и <xref remap=\"4\" "
"linkend=\"logicaldecoding-walsender\"/>), либо через функции, вызываемые в "
"SQL (см. <xref remap=\"4\" linkend=\"logicaldecoding-sql\"/>). Также "
"возможно разработать дополнительные методы для обработки данных, поступающих "
"через слот репликации, не модифицируя код ядра сервера (см. <xref remap="
"\"4\" linkend=\"logicaldecoding-writer\"/>)."

#: logicaldecoding.xml:42(title)
msgid "Logical Decoding Examples"
msgstr "Примеры логического декодирования"

#: logicaldecoding.xml:44(para)
msgid ""
"The following example demonstrates controlling logical decoding using the "
"SQL interface."
msgstr ""
"Следующий пример демонстрирует управление логическим декодированием на "
"уровне SQL."

#: logicaldecoding.xml:49(para)
msgid ""
"Before you can use logical decoding, you must set <xref linkend=\"guc-wal-"
"level\"/> to <literal>logical</literal> and <xref linkend=\"guc-max-"
"replication-slots\"/> to at least 1. Then, you should connect to the target "
"database (in the example below, <literal>postgres</literal>) as a superuser."
msgstr ""
"Прежде чем вы сможете использовать логическое декодирование, вы должны "
"установить в <xref linkend=\"guc-wal-level\"/> значение <literal>logical</"
"literal>, а в <xref linkend=\"guc-max-replication-slots\"/> значение, не "
"меньшее 1. После этого вы должны подключиться к целевой базе данных (в "
"следующем примере, это <literal>postgres</literal>) как суперпользователь."

#: logicaldecoding.xml:57(programlisting)
#, no-wrap
msgid ""
"postgres=# -- Create a slot named 'regression_slot' using the output plugin 'test_decoding'\n"
"postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding');\n"
"    slot_name    | xlog_position\n"
"-----------------+---------------\n"
" regression_slot | 0/16B1970\n"
"(1 row)\n"
"\n"
"postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;\n"
"    slot_name    |    plugin     | slot_type | database | active | restart_lsn | confirmed_flush_lsn\n"
"-----------------+---------------+-----------+----------+--------+-------------+-----------------\n"
" regression_slot | test_decoding | logical   | postgres | f      | 0/16A4408   | 0/16A4440\n"
"(1 row)\n"
"\n"
"postgres=# -- There are no changes to see yet\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location | xid | data\n"
"----------+-----+------\n"
"(0 rows)\n"
"\n"
"postgres=# CREATE TABLE data(id serial primary key, data text);\n"
"CREATE TABLE\n"
"\n"
"postgres=# -- DDL isn't replicated, so all you'll see is the transaction\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location  | xid |    data\n"
"-----------+-----+------------\n"
" 0/16D5D48 | 688 | BEGIN 688\n"
" 0/16E0380 | 688 | COMMIT 688\n"
"(2 rows)\n"
"\n"
"postgres=# -- Once changes are read, they're consumed and not emitted\n"
"postgres=# -- in a subsequent call:\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location | xid | data\n"
"----------+-----+------\n"
"(0 rows)\n"
"\n"
"postgres=# BEGIN;\n"
"postgres=# INSERT INTO data(data) VALUES('1');\n"
"postgres=# INSERT INTO data(data) VALUES('2');\n"
"postgres=# COMMIT;\n"
"\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E0478 | 689 | BEGIN 689\n"
" 0/16E0478 | 689 | table public.data: INSERT: id[integer]:1 data[text]:'1'\n"
" 0/16E0580 | 689 | table public.data: INSERT: id[integer]:2 data[text]:'2'\n"
" 0/16E0650 | 689 | COMMIT 689\n"
"(4 rows)\n"
"\n"
"postgres=# INSERT INTO data(data) VALUES('3');\n"
"\n"
"postgres=# -- You can also peek ahead in the change stream without consuming changes\n"
"postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E09C0 | 690 | BEGIN 690\n"
" 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'\n"
" 0/16E0B90 | 690 | COMMIT 690\n"
"(3 rows)\n"
"\n"
"postgres=# -- The next call to pg_logical_slot_peek_changes() returns the same changes again\n"
"postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E09C0 | 690 | BEGIN 690\n"
" 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'\n"
" 0/16E0B90 | 690 | COMMIT 690\n"
"(3 rows)\n"
"\n"
"postgres=# -- options can be passed to output plugin, to influence the formatting\n"
"postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E09C0 | 690 | BEGIN 690\n"
" 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'\n"
" 0/16E0B90 | 690 | COMMIT 690 (at 2014-02-27 16:41:51.863092+01)\n"
"(3 rows)\n"
"\n"
"postgres=# -- Remember to destroy a slot you no longer need to stop it consuming\n"
"postgres=# -- server resources:\n"
"postgres=# SELECT pg_drop_replication_slot('regression_slot');\n"
" pg_drop_replication_slot\n"
"-----------------------\n"
"\n"
"(1 row)"
msgstr ""
"postgres=# -- Создать слот с именем 'regression_slot', использующий модуль вывода 'test_decoding'\n"
"postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding');\n"
"    slot_name    | xlog_position\n"
"-----------------+---------------\n"
" regression_slot | 0/16B1970\n"
"(1 row)\n"
"\n"
"postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;\n"
"    slot_name    |    plugin     | slot_type | database | active | restart_lsn | confirmed_flush_lsn\n"
"-----------------+---------------+-----------+----------+--------+-------------+-----------------\n"
" regression_slot | test_decoding | logical   | postgres | f      | 0/16A4408   | 0/16A4440\n"
"(1 row)\n"
"\n"
"postgres=# -- Пока никакие изменения не видны\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location | xid | data\n"
"----------+-----+------\n"
"(0 rows)\n"
"\n"
"postgres=# CREATE TABLE data(id serial primary key, data text);\n"
"CREATE TABLE\n"
"\n"
"postgres=# -- DDL не реплицируется, поэтому видна только транзакция\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location  | xid |    data\n"
"-----------+-----+------------\n"
" 0/16D5D48 | 688 | BEGIN 688\n"
" 0/16E0380 | 688 | COMMIT 688\n"
"(2 rows)\n"
"\n"
"postgres=# -- Когда изменения прочитаны, они считаются обработанными и уже не выдаются\n"
"postgres=# -- в последующем вызове:\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location | xid | data\n"
"----------+-----+------\n"
"(0 rows)\n"
"\n"
"postgres=# BEGIN;\n"
"postgres=# INSERT INTO data(data) VALUES('1');\n"
"postgres=# INSERT INTO data(data) VALUES('2');\n"
"postgres=# COMMIT;\n"
"\n"
"postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E0478 | 689 | BEGIN 689\n"
" 0/16E0478 | 689 | table public.data: INSERT: id[integer]:1 data[text]:'1'\n"
" 0/16E0580 | 689 | table public.data: INSERT: id[integer]:2 data[text]:'2'\n"
" 0/16E0650 | 689 | COMMIT 689\n"
"(4 rows)\n"
"\n"
"postgres=# INSERT INTO data(data) VALUES('3');\n"
"\n"
"postgres=# -- Также можно заглянуть вперёд в потоке изменений, не считывая эти изменения\n"
"postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E09C0 | 690 | BEGIN 690\n"
" 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'\n"
" 0/16E0B90 | 690 | COMMIT 690\n"
"(3 rows)\n"
"\n"
"postgres=# -- Следующий вызов pg_logical_slot_peek_changes() снова возвращает те же изменения\n"
"postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E09C0 | 690 | BEGIN 690\n"
" 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'\n"
" 0/16E0B90 | 690 | COMMIT 690\n"
"(3 rows)\n"
"\n"
"postgres=# -- Модулю вывода можно передать параметры, влияющие на форматирование\n"
"postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');\n"
" location  | xid |                     data\n"
"-----------+-----+-----------------------------------------------\n"
" 0/16E09C0 | 690 | BEGIN 690\n"
" 0/16E09C0 | 690 | table public.data: INSERT: id[integer]:3 data[text]:'3'\n"
" 0/16E0B90 | 690 | COMMIT 690 (at 2014-02-27 16:41:51.863092+01)\n"
"(3 rows)\n"
"\n"
"postgres=# -- Не забудьте удалить слот, который вам больше не нужен, чтобы он\n"
"postgres=# -- не потреблял ресурсы сервера:\n"
"postgres=# SELECT pg_drop_replication_slot('regression_slot');\n"
" pg_drop_replication_slot\n"
"-----------------------\n"
"\n"
"(1 row)"

#: logicaldecoding.xml:147(para)
msgid ""
"The following example shows how logical decoding is controlled over the "
"streaming replication protocol, using the program <xref linkend=\"app-"
"pgrecvlogical\"/> included in the PostgreSQL distribution. This requires "
"that client authentication is set up to allow replication connections (see "
"<xref linkend=\"streaming-replication-authentication\"/>) and that "
"<varname>max_wal_senders</varname> is set sufficiently high to allow an "
"additional connection."
msgstr ""
"Следующий пример показывает, как можно управлять логическим декодированием "
"средствами протокола потоковой репликации, используя программу <xref linkend="
"\"app-pgrecvlogical\"/>, включённую в дистрибутив PostgreSQL. Для этого "
"нужно, чтобы конфигурация аутентификации клиентов допускала подключения для "
"репликации (см. <xref remap=\"4\" linkend=\"streaming-replication-"
"authentication\"/>) и чтобы значение <varname>max_wal_senders</varname> было "
"достаточно большим и позволило установить дополнительное подключение."

#: logicaldecoding.xml:157(programlisting)
#, no-wrap
msgid ""
"$ pg_recvlogical -d postgres --slot test --create-slot\n"
"$ pg_recvlogical -d postgres --slot test --start -f -\n"
"<keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo>\n"
"$ psql -d postgres -c \"INSERT INTO data(data) VALUES('4');\"\n"
"$ fg\n"
"BEGIN 693\n"
"table public.data: INSERT: id[integer]:4 data[text]:'4'\n"
"COMMIT 693\n"
"<keycombo action=\"simul\"><keycap>Control</keycap><keycap>C</keycap></keycombo>\n"
"$ pg_recvlogical -d postgres --slot test --drop-slot"
msgstr ""
"$ pg_recvlogical -d postgres --slot test --create-slot\n"
"$ pg_recvlogical -d postgres --slot test --start -f -\n"
"<keycombo action=\"simul\"><keycap>Control</keycap><keycap>Z</keycap></keycombo>\n"
"$ psql -d postgres -c \"INSERT INTO data(data) VALUES('4');\"\n"
"$ fg\n"
"BEGIN 693\n"
"table public.data: INSERT: id[integer]:4 data[text]:'4'\n"
"COMMIT 693\n"
"<keycombo action=\"simul\"><keycap>Control</keycap><keycap>C</keycap></keycombo>\n"
"$ pg_recvlogical -d postgres --slot test --drop-slot"

#: logicaldecoding.xml:172(title)
msgid "Logical Decoding Concepts"
msgstr "Концепции логического декодирования"

#: logicaldecoding.xml:180(para)
msgid ""
"Logical decoding is the process of extracting all persistent changes to a "
"database's tables into a coherent, easy to understand format which can be "
"interpreted without detailed knowledge of the database's internal state."
msgstr ""
"Логическое декодирование — это процедура извлечения всех постоянных "
"изменений, происходящих в таблицах базы данных, в согласованном и понятном "
"формате, который можно интерпретировать, не имея полного представления о "
"внутреннем состоянии базы данных."

#: logicaldecoding.xml:187(para)
msgid ""
"In <productname>PostgreSQL</productname>, logical decoding is implemented by "
"decoding the contents of the <link linkend=\"wal\">write-ahead log</link>, "
"which describe changes on a storage level, into an application-specific form "
"such as a stream of tuples or SQL statements."
msgstr ""
"В <productname>PostgreSQL</productname> логическое декодирование реализуется "
"путём перевода содержимого <link linkend=\"wal\">журнала упреждающей записи</"
"link>, описывающего изменения на уровне хранения, в специальную форму уровня "
"приложения, например, в поток кортежей или операторов SQL."

#: logicaldecoding.xml:196(title)
msgid "Replication Slots"
msgstr "Слоты репликации"

#: logicaldecoding.xml:198(indexterm)
msgid ""
"<primary>replication slot</primary> <secondary>logical replication</"
"secondary>"
msgstr ""
"<primary>слот репликации</primary> <secondary>логическая репликация</"
"secondary>"

#: logicaldecoding.xml:203(para)
msgid ""
"In the context of logical replication, a slot represents a stream of changes "
"that can be replayed to a client in the order they were made on the origin "
"server. Each slot streams a sequence of changes from a single database."
msgstr ""
"В контексте логической репликации слот представляет поток изменений, которые "
"могут быть воспроизведены клиентом в том порядке, в каком они происходили на "
"исходном сервере. Через каждый слот передаётся последовательность изменений "
"в одной базе данных."

#: logicaldecoding.xml:211(para)
msgid ""
"<productname>PostgreSQL</productname> also has streaming replication slots "
"(see <xref linkend=\"streaming-replication\"/>), but they are used somewhat "
"differently there."
msgstr ""
"В <productname>PostgreSQL</productname> также есть слоты потоковой "
"репликации (см. <xref remap=\"4\" linkend=\"streaming-replication\"/>), но "
"они используются несколько по-другому."

#: logicaldecoding.xml:217(para)
msgid ""
"A replication slot has an identifier that is unique across all databases in "
"a <productname>PostgreSQL</productname> cluster. Slots persist independently "
"of the connection using them and are crash-safe."
msgstr ""
"Слоту репликации назначается идентификатор, уникальный для всех баз данных в "
"кластере <productname>PostgreSQL</productname>. Слоты сохраняются независимо "
"от подключений, использующих их, и защищены от сбоев сервера."

#: logicaldecoding.xml:223(para)
msgid ""
"A logical slot will emit each change just once in normal operation. The "
"current position of each slot is persisted only at checkpoint, so in the "
"case of a crash the slot may return to an earlier LSN, which will then cause "
"recent changes to be resent when the server restarts. Logical decoding "
"clients are responsible for avoiding ill effects from handling the same "
"message more than once. Clients may wish to record the last LSN they saw "
"when decoding and skip over any repeated data or (when using the replication "
"protocol) request that decoding start from that LSN rather than letting the "
"server determine the start point. The Replication Progress Tracking feature "
"is designed for this purpose, refer to <link linkend=\"replication-origins"
"\">replication origins</link>."
msgstr ""
"При обычных условиях через логический слот каждое изменение передаётся "
"только один раз. Текущая позиция в каждом слоте сохраняется только в "
"контрольной точке, так что в случае сбоя слот может вернуться к предыдущему "
"LSN, вследствие чего последние изменения могут быть переданы повторно при "
"перезапуске сервера. За исключение нежелательных эффектов от повторной "
"обработки одного и того же сообщения отвечают клиенты логического "
"декодирования. Клиенты могут запоминать при декодировании, какой последний "
"LSN они уже получали, и пропускать повторяющиеся данные или (при "
"использовании протокола репликации) запрашивать, чтобы декодирование "
"начиналось с этого LSN, а не с позиции, выбираемой сервером. Для этого "
"разработан механизм отслеживания репликации, о котором можно узнать "
"подробнее в описании <link linkend=\"replication-origins\">источников "
"репликации</link>."

#: logicaldecoding.xml:237(para)
msgid ""
"Multiple independent slots may exist for a single database. Each slot has "
"its own state, allowing different consumers to receive changes from "
"different points in the database change stream. For most applications, a "
"separate slot will be required for each consumer."
msgstr ""
"Для одной базы данных могут существовать несколько независимых слотов. "
"Каждый слот имеет собственное состояние, что позволяет различным "
"потребителям получать изменения с разных позиций в потоке изменений базы "
"данных. Для большинства приложений каждому потребителю требуется отдельный "
"слот."

#: logicaldecoding.xml:244(para)
msgid ""
"A logical replication slot knows nothing about the state of the receiver(s). "
"It's even possible to have multiple different receivers using the same slot "
"at different times; they'll just get the changes following on from when the "
"last receiver stopped consuming them. Only one receiver may consume changes "
"from a slot at any given time."
msgstr ""
"Слот логической репликации ничего не знает о состоянии получателя(ей). "
"Возможно даже иметь несколько различных потребителей одного слота в разные "
"моменты времени; они просто будут получать изменения с момента, когда их "
"перестал получать предыдущий потребитель. Но в любой определённый момент "
"получать изменения может только один потребитель."

#: logicaldecoding.xml:253(para)
msgid ""
"Replication slots persist across crashes and know nothing about the state of "
"their consumer(s). They will prevent removal of required resources even when "
"there is no connection using them. This consumes storage because neither "
"required WAL nor required rows from the system catalogs can be removed by "
"<command>VACUUM</command> as long as they are required by a replication "
"slot. So if a slot is no longer required it should be dropped."
msgstr ""
"Слоты репликации сохраняются при сбоях сервера и ничего не знают о состоянии "
"их потребителя(ей). Они не дают удалять требуемые ресурсы, даже когда не "
"используются никаким подключением. На это уходит место в хранилище, так как "
"ни сегменты WAL, ни требуемые строки из системных каталогов нельзя будет "
"удалить в результате <command>VACUUM</command>, пока они нужны этому слоту "
"репликации. Поэтому, если слот больше не требуется, его следует удалять."

#: logicaldecoding.xml:265(title)
msgid "Output Plugins"
msgstr "Модули вывода"

#: logicaldecoding.xml:266(para)
msgid ""
"Output plugins transform the data from the write-ahead log's internal "
"representation into the format the consumer of a replication slot desires."
msgstr ""
"Модули вывода переводят данные из внутреннего представления в журнале "
"упреждающей записи в формат, устраивающий потребителя слота репликации."

#: logicaldecoding.xml:273(title)
msgid "Exported Snapshots"
msgstr "Экспортированные снимки"

#: logicaldecoding.xml:274(para)
msgid ""
"When a new replication slot is created using the streaming replication "
"interface, a snapshot is exported (see <xref linkend=\"functions-snapshot-"
"synchronization\"/>), which will show exactly the state of the database "
"after which all changes will be included in the change stream. This can be "
"used to create a new replica by using <link linkend=\"sql-set-transaction"
"\"><literal>SET TRANSACTION SNAPSHOT</literal></link> to read the state of "
"the database at the moment the slot was created. This transaction can then "
"be used to dump the database's state at that point in time, which afterwards "
"can be updated using the slot's contents without losing any changes."
msgstr ""
"Когда новый слот репликации создаётся через интерфейс потоковой репликации, "
"экспортируется снимок (см. <xref remap=\"4\" linkend=\"functions-snapshot-"
"synchronization\"/>), который будет показывать ровно то состояние базы "
"данных, изменения после которого будут включаться в поток изменений. "
"Используя его, можно создать новую реплику, воспользовавшись командой <link "
"linkend=\"sql-set-transaction\"><literal>SET TRANSACTION SNAPSHOT</literal></"
"link>, чтобы получить состояние базы в момент создания слота. После этого "
"данную транзакцию можно использовать для выгрузки состояния базы на момент "
"экспорт снимка, а затем изменять это состояние, применяя содержимое слота, "
"так что никакие изменения не будут потеряны."

#: logicaldecoding.xml:290(title)
msgid "Streaming Replication Protocol Interface"
msgstr "Интерфейс протокола потоковой репликации"

#: logicaldecoding.xml:296(replaceable) logicaldecoding.xml:300(replaceable)
#: logicaldecoding.xml:304(replaceable)
msgid "slot_name"
msgstr "имя_слота"

#: logicaldecoding.xml:296(replaceable)
msgid "output_plugin"
msgstr "модуль_вывода"

#: logicaldecoding.xml:296(literal)
msgid "CREATE_REPLICATION_SLOT <placeholder-1/> LOGICAL <placeholder-2/>"
msgstr "CREATE_REPLICATION_SLOT <placeholder-1/> LOGICAL <placeholder-2/>"

#: logicaldecoding.xml:300(literal)
msgid "DROP_REPLICATION_SLOT <placeholder-1/>"
msgstr "DROP_REPLICATION_SLOT <placeholder-1/>"

#: logicaldecoding.xml:304(literal)
msgid "START_REPLICATION SLOT <placeholder-1/> LOGICAL ..."
msgstr "START_REPLICATION SLOT <placeholder-1/> LOGICAL ..."

#: logicaldecoding.xml:292(para)
msgid ""
"The commands <placeholder-1/> are used to create, drop, and stream changes "
"from a replication slot, respectively. These commands are only available "
"over a replication connection; they cannot be used via SQL. See <xref "
"linkend=\"protocol-replication\"/> for details on these commands."
msgstr ""
"Команды <placeholder-1/> применяются для создания, удаления и передачи "
"изменений из слота репликации, соответственно. Эти команды доступны только "
"для соединения репликации; их нельзя использовать в обычном SQL. Подробнее "
"они описаны в <xref remap=\"6\" linkend=\"protocol-replication\"/>."

#: logicaldecoding.xml:313(para)
msgid ""
"The command <xref linkend=\"app-pgrecvlogical\"/> can be used to control "
"logical decoding over a streaming replication connection. (It uses these "
"commands internally.)"
msgstr ""
"Для управления логическим декодированием по соединению потоковой репликации "
"можно применять программу <xref linkend=\"app-pgrecvlogical\"/>. (Внутри неё "
"используются эти команды.)"

#: logicaldecoding.xml:321(title)
msgid "Logical Decoding <acronym>SQL</acronym> Interface"
msgstr "Интерфейс логического декодирования на уровне <acronym>SQL</acronym>"

#: logicaldecoding.xml:323(para)
msgid ""
"See <xref linkend=\"functions-replication\"/> for detailed documentation on "
"the SQL-level API for interacting with logical decoding."
msgstr ""
"Подробнее API уровня SQL для взаимодействия с механизмом логическим "
"декодированием описан в <xref remap=\"6\" linkend=\"functions-replication\"/"
">."

#: logicaldecoding.xml:328(para)
msgid ""
"Synchronous replication (see <xref linkend=\"synchronous-replication\"/>) is "
"only supported on replication slots used over the streaming replication "
"interface. The function interface and additional, non-core interfaces do not "
"support synchronous replication."
msgstr ""
"Синхронная репликация (см. <xref remap=\"4\" linkend=\"synchronous-"
"replication\"/>) поддерживается только для слотов репликации, которые "
"используются через интерфейс потоковой репликации. Интерфейс функций и "
"дополнительные, не системные интерфейсы не поддерживают синхронную "
"репликацию."

#: logicaldecoding.xml:337(title)
msgid "System Catalogs Related to Logical Decoding"
msgstr "Системные каталоги, связанные с логическим декодированием"

#: logicaldecoding.xml:339(para)
msgid ""
"The <link linkend=\"view-pg-replication-slots"
"\"><structname>pg_replication_slots</structname></link> view and the <link "
"linkend=\"monitoring-stats-views-table\"><structname>pg_stat_replication</"
"structname></link> view provide information about the current state of "
"replication slots and streaming replication connections respectively. These "
"views apply to both physical and logical replication."
msgstr ""
"Информацию о текущем состоянии слотов репликации и соединений потоковой "
"репликации отображают представления <link linkend=\"view-pg-replication-slots"
"\"><structname>pg_replication_slots</structname></link> и <link linkend="
"\"monitoring-stats-views-table\"><structname>pg_stat_replication</"
"structname></link>, соответственно. Эти представления относятся и к "
"физической, и к логической репликации."

#: logicaldecoding.xml:350(title)
msgid "Logical Decoding Output Plugins"
msgstr "Модули вывода логического декодирования"

#: logicaldecoding.xml:351(para)
msgid ""
"An example output plugin can be found in the <link linkend=\"test-decoding"
"\"><filename>contrib/test_decoding</filename></link> subdirectory of the "
"PostgreSQL source tree."
msgstr ""
"Пример модуля вывода можно найти в подкаталоге <link linkend=\"test-decoding"
"\"><filename>contrib/test_decoding</filename></link> в дереве исходного кода "
"PostgreSQL."

#: logicaldecoding.xml:359(title)
msgid "Initialization Function"
msgstr "Функция инициализации"

#: logicaldecoding.xml:360(indexterm)
msgid "<primary>_PG_output_plugin_init</primary>"
msgstr "<primary>_PG_output_plugin_init</primary>"

#: logicaldecoding.xml:372(programlisting)
#, fuzzy, no-wrap
msgid ""
"typedef struct OutputPluginCallbacks\n"
"{\n"
"    LogicalDecodeStartupCB startup_cb;\n"
"    LogicalDecodeBeginCB begin_cb;\n"
"    LogicalDecodeChangeCB change_cb;\n"
"    LogicalDecodeCommitCB commit_cb;\n"
"    LogicalDecodeMessageCB message_cb;\n"
"    LogicalDecodeFilterByOriginCB filter_by_origin_cb;\n"
"    LogicalDecodeShutdownCB shutdown_cb;\n"
"} OutputPluginCallbacks;\n"
"\n"
"typedef void (*LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);"
msgstr ""
"typedef struct OutputPluginCallbacks\n"
"{\n"
"    LogicalDecodeStartupCB startup_cb;\n"
"    LogicalDecodeBeginCB begin_cb;\n"
"    LogicalDecodeChangeCB change_cb;\n"
"    LogicalDecodeCommitCB commit_cb;\n"
"    LogicalDecodeMessageCB message_cb;\n"
"    LogicalDecodeFilterByOriginCB filter_by_origin_cb;\n"
"    LogicalDecodeShutdownCB shutdown_cb;\n"
"} OutputPluginCallbacks;\n"
"\n"
"typedef void (*LogicalOutputPluginInit)(struct OutputPluginCallbacks *cb);"

#: logicaldecoding.xml:363(para)
msgid ""
"An output plugin is loaded by dynamically loading a shared library with the "
"output plugin's name as the library base name. The normal library search "
"path is used to locate the library. To provide the required output plugin "
"callbacks and to indicate that the library is actually an output plugin it "
"needs to provide a function named <function>_PG_output_plugin_init</"
"function>. This function is passed a struct that needs to be filled with the "
"callback function pointers for individual actions. <placeholder-1/> The "
"<function>begin_cb</function>, <function>change_cb</function> and "
"<function>commit_cb</function> callbacks are required, while "
"<function>startup_cb</function>, <function>filter_by_origin_cb</function> "
"and <function>shutdown_cb</function> are optional."
msgstr ""
"Модуль вывода загружается в результате динамической загрузки разделяемой "
"библиотеки (при этом в качестве имени библиотеки задаётся имя модуля). Для "
"нахождения библиотеки применяется обычный путь поиска библиотек. В этой "
"библиотеке должна быть функция <function>_PG_output_plugin_init</function>, "
"которая показывает, что библиотека на самом деле представляет собой модуль "
"вывода, и устанавливает требуемые обработчики модуля вывода. Этой функции "
"передаётся структура, в которой должны быть заполнены указатели на функции-"
"обработчики отдельных действий. <placeholder-1/> Обработчики "
"<function>begin_cb</function>, <function>change_cb</function> и "
"<function>commit_cb</function> должны устанавливаться обязательно, а "
"<function>startup_cb</function>, <function>filter_by_origin_cb</function> и "
"<function>shutdown_cb</function> могут отсутствовать."

#: logicaldecoding.xml:395(title)
msgid "Capabilities"
msgstr "Возможности"

#: logicaldecoding.xml:404(programlisting)
#, no-wrap
msgid ""
"ALTER TABLE user_catalog_table SET (user_catalog_table = true);\n"
"CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);"
msgstr ""
"ALTER TABLE user_catalog_table SET (user_catalog_table = true);\n"
"CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);"

#: logicaldecoding.xml:397(para)
msgid ""
"To decode, format and output changes, output plugins can use most of the "
"backend's normal infrastructure, including calling output functions. Read "
"only access to relations is permitted as long as only relations are accessed "
"that either have been created by <command>initdb</command> in the "
"<literal>pg_catalog</literal> schema, or have been marked as user provided "
"catalog tables using <placeholder-1/> Any actions leading to transaction ID "
"assignment are prohibited. That, among others, includes writing to tables, "
"performing DDL changes, and calling <literal>txid_current()</literal>."
msgstr ""
"Для декодирования, форматирования и вывода изменений модули вывода могут "
"использовать практически всю обычную инфраструктуру сервера, включая вызов "
"функций вывода типов. К отношениям разрешается доступ только на чтение, если "
"только эти отношения были созданы программой <command>initdb</command> в "
"схеме <literal>pg_catalog</literal>, либо помечены как пользовательские "
"таблицы каталогов командами <placeholder-1/> Любые действия, которые требует "
"присвоения идентификатора транзакции, запрещаются. В частности, к этим "
"действиям относятся операции записи в таблицы, изменения DDL и вызов "
"<literal>txid_current()</literal>."

#: logicaldecoding.xml:415(title)
msgid "Output Modes"
msgstr "Режимы вывода"

#: logicaldecoding.xml:417(para)
#, fuzzy
msgid ""
"Output plugin callbacks can pass data to the consumer in nearly arbitrary "
"formats. For some use cases, like viewing the changes via SQL, returning "
"data in a data type that can contain arbitrary data (e.g., <type>bytea</"
"type>) is cumbersome. If the output plugin only outputs textual data in the "
"server's encoding, it can declare that by setting "
"<literal>OutputPluginOptions.output_type</literal> to "
"<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> instead of "
"<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal> in the <link linkend="
"\"logicaldecoding-output-plugin-startup\">startup callback</link>. In that "
"case, all the data has to be in the server's encoding so that a <type>text</"
"type> datum can contain it. This is checked in assertion-enabled builds."
msgstr ""
"Обработчики в модуле вывода могут передавать данные потребителю в "
"практически любых форматах. Для некоторых вариантов использования, например, "
"просмотра изменений через SQL, вывод информации в типах, которые могут "
"содержать произвольные данные (например, <type>bytea</type>), может быть "
"неудобоваримым. Если модуль вывода выводит только текстовые данные в "
"кодировке сервера, он может объявить это, установив в "
"<literal>OutputPluginOptions.output_mode</literal> значение "
"<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> вместо "
"<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal> в <link linkend="
"\"logicaldecoding-output-plugin-startup\">обработчике запуска</link>. В этом "
"случае все данные должны быть в кодировке сервера, чтобы их можно было "
"передать в значении типа <type>text</type>. Это контролируется в сборках с "
"включёнными проверочными утверждениями."

#: logicaldecoding.xml:434(title)
msgid "Output Plugin Callbacks"
msgstr "Обработчики в модуле вывода"

#: logicaldecoding.xml:436(para)
msgid ""
"An output plugin gets notified about changes that are happening via various "
"callbacks it needs to provide."
msgstr ""
"Модуль вывода уведомляется о происходящих изменениях через различные "
"обработчики, которые он должен установить."

#: logicaldecoding.xml:441(para)
msgid ""
"Concurrent transactions are decoded in commit order, and only changes "
"belonging to a specific transaction are decoded between the <literal>begin</"
"literal> and <literal>commit</literal> callbacks. Transactions that were "
"rolled back explicitly or implicitly never get decoded. Successful "
"savepoints are folded into the transaction containing them in the order they "
"were executed within that transaction."
msgstr ""
"Параллельные транзакции декодируются в порядке фиксирования, при этом только "
"изменения, относящиеся к определённой транзакции, декодируются между "
"вызовами обработчиков <literal>begin</literal> и <literal>commit</literal>. "
"Транзакции, отменённые явно или неявно, никогда не декодируются. Успешные "
"точки сохранения заворачиваются в транзакцию, содержащую их, в том порядке, "
"в како они выполнялись в этой транзакции."

#: logicaldecoding.xml:453(para)
msgid ""
"Only transactions that have already safely been flushed to disk will be "
"decoded. That can lead to a <command>COMMIT</command> not immediately being "
"decoded in a directly following <literal>pg_logical_slot_get_changes()</"
"literal> when <varname>synchronous_commit</varname> is set to <literal>off</"
"literal>."
msgstr ""
"Декодироваться будут только те транзакции, которые уже успешно сброшены на "
"диск. Вследствие этого, <command>COMMIT</command> может не декодироваться в "
"следующем сразу за ним вызове <literal>pg_logical_slot_get_changes()</"
"literal>, когда <varname>synchronous_commit</varname> имеет значение "
"<literal>off</literal>."

#: logicaldecoding.xml:463(title)
msgid "Startup Callback"
msgstr "Обработчик запуска"

#: logicaldecoding.xml:468(programlisting)
#, fuzzy, no-wrap
msgid ""
"typedef void (*LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,\n"
"                                        OutputPluginOptions *options,\n"
"                                        bool is_init);"
msgstr ""
"typedef void (*LogicalDecodeStartupCB) (\n"
"    struct LogicalDecodingContext *ctx,\n"
"    OutputPluginOptions *options,\n"
"    bool is_init\n"
");"

#: logicaldecoding.xml:477(programlisting)
#, no-wrap
msgid ""
"typedef struct OutputPluginOptions\n"
"{\n"
"    OutputPluginOutputType output_type;\n"
"} OutputPluginOptions;"
msgstr ""
"typedef struct OutputPluginOptions\n"
"{\n"
"    OutputPluginOutputType output_type;\n"
"} OutputPluginOptions;"

#: logicaldecoding.xml:464(para)
msgid ""
"The optional <function>startup_cb</function> callback is called whenever a "
"replication slot is created or asked to stream changes, independent of the "
"number of changes that are ready to be put out. <placeholder-1/> The "
"<literal>is_init</literal> parameter will be true when the replication slot "
"is being created and false otherwise. <parameter>options</parameter> points "
"to a struct of options that output plugins can set: <placeholder-2/> "
"<literal>output_type</literal> has to either be set to "
"<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> or "
"<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>. See also <xref linkend="
"\"logicaldecoding-output-mode\"/>."
msgstr ""
"Необязательный обработчик <function>startup_cb</function> вызывается, когда "
"слот репликации создаётся или через него запрашивается передача изменений, "
"независимо от того, в каком количестве изменения готовы к передаче. "
"<placeholder-1/> Параметр <literal>is_init</literal> будет равен true, когда "
"слот репликации создаётся, и false в противном случае. Параметр "
"<parameter>options</parameter> указывает на структуру параметров, которые "
"могут устанавливать модули вывода: <placeholder-2/> В поле "
"<literal>output_type</literal> должно быть значение "
"<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> или "
"<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>. См. также <xref remap=\"4\" "
"linkend=\"logicaldecoding-output-mode\"/>."

#: logicaldecoding.xml:489(para)
msgid ""
"The startup callback should validate the options present in <literal>ctx-&gt;"
"output_plugin_options</literal>. If the output plugin needs to have a state, "
"it can use <literal>ctx-&gt;output_plugin_private</literal> to store it."
msgstr ""
"Обработчик запуска должен проверить параметры, представленные в <literal>ctx-"
"&gt;output_plugin_options</literal>. Если модулю вывода требуется "
"поддерживать состояние, он может сохранить его в <literal>ctx-&gt;"
"output_plugin_private</literal>."

#: logicaldecoding.xml:498(title)
msgid "Shutdown Callback"
msgstr "Обработчик выключения"

#: logicaldecoding.xml:505(programlisting)
#, fuzzy, no-wrap
msgid "typedef void (*LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);"
msgstr ""
"typedef void (*LogicalDecodeShutdownCB) (\n"
"    struct LogicalDecodingContext *ctx\n"
");"

#: logicaldecoding.xml:500(para)
msgid ""
"The optional <function>shutdown_cb</function> callback is called whenever a "
"formerly active replication slot is not used anymore and can be used to "
"deallocate resources private to the output plugin. The slot isn't "
"necessarily being dropped, streaming is just being stopped. <placeholder-1/>"
msgstr ""
"Необязательный обработчик <function>shutdown_cb</function> вызывается, когда "
"ранее активный слот репликации перестаёт использоваться, так что ресурсы, "
"занятые модулем вывода, можно освободить. При этом слот не обязательно "
"удаляется, прекращается только потоковая передача через него. <placeholder-1/"
">"

#: logicaldecoding.xml:512(title)
msgid "Transaction Begin Callback"
msgstr "Обработчик начала транзакции"

#: logicaldecoding.xml:518(programlisting)
#, fuzzy, no-wrap
msgid ""
"typedef void (*LogicalDecodeBeginCB) (struct LogicalDecodingContext *ctx,\n"
"                                      ReorderBufferTXN *txn);"
msgstr ""
"typedef void (*LogicalDecodeBeginCB) (\n"
"    struct LogicalDecodingContext *,\n"
"    ReorderBufferTXN *txn\n"
");"

#: logicaldecoding.xml:514(para)
msgid ""
"The required <function>begin_cb</function> callback is called whenever a "
"start of a committed transaction has been decoded. Aborted transactions and "
"their contents never get decoded. <placeholder-1/> The <parameter>txn</"
"parameter> parameter contains meta information about the transaction, like "
"the time stamp at which it has been committed and its XID."
msgstr ""
"Обязательный обработчик <function>begin_cb</function> вызывается, когда "
"декодируется начало зафиксированной транзакции. Прерванные транзакции и их "
"содержимое никогда не декодируется. <placeholder-1/> Параметр "
"<parameter>txn</parameter> содержит метаинформацию о транзакции, в частности "
"её идентификатор и время её фиксирования."

#: logicaldecoding.xml:529(title)
msgid "Transaction End Callback"
msgstr "Обработчик завершения транзакции"

#: logicaldecoding.xml:537(programlisting)
#, fuzzy, no-wrap
msgid ""
"typedef void (*LogicalDecodeCommitCB) (struct LogicalDecodingContext *ctx,\n"
"                                       ReorderBufferTXN *txn,\n"
"                                       XLogRecPtr commit_lsn);"
msgstr ""
"typedef void (*LogicalDecodeCommitCB) (\n"
"    struct LogicalDecodingContext *,\n"
"    ReorderBufferTXN *txn\n"
");"

#: logicaldecoding.xml:531(para)
msgid ""
"The required <function>commit_cb</function> callback is called whenever a "
"transaction commit has been decoded. The <function>change_cb</function> "
"callbacks for all modified rows will have been called before this, if there "
"have been any modified rows. <placeholder-1/>"
msgstr ""
"Обязательный обработчик <function>commit_cb</function> вызывается, когда "
"декодируется фиксирование транзакции. Перед этим обработчиком будет "
"вызываться обработчик <function>change_cb</function> для всех изменённых "
"строк (если строки были изменены). <placeholder-1/>"

#: logicaldecoding.xml:546(title)
msgid "Change Callback"
msgstr "Обработчик изменения"

#: logicaldecoding.xml:555(programlisting)
#, fuzzy, no-wrap
msgid ""
"typedef void (*LogicalDecodeChangeCB) (struct LogicalDecodingContext *ctx,\n"
"                                       ReorderBufferTXN *txn,\n"
"                                       Relation relation,\n"
"                                       ReorderBufferChange *change);"
msgstr ""
"typedef void (*LogicalDecodeChangeCB) (\n"
"    struct LogicalDecodingContext *ctx,\n"
"    ReorderBufferTXN *txn,\n"
"    Relation relation,\n"
"    ReorderBufferChange *change\n"
");"

#: logicaldecoding.xml:548(para)
msgid ""
"The required <function>change_cb</function> callback is called for every "
"individual row modification inside a transaction, may it be an "
"<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</"
"command>. Even if the original command modified several rows at once the "
"callback will be called individually for each row. <placeholder-1/> The "
"<parameter>ctx</parameter> and <parameter>txn</parameter> parameters have "
"the same contents as for the <function>begin_cb</function> and "
"<function>commit_cb</function> callbacks, but additionally the relation "
"descriptor <parameter>relation</parameter> points to the relation the row "
"belongs to and a struct <parameter>change</parameter> describing the row "
"modification are passed in."
msgstr ""
"Обязательный обработчик <function>change_cb</function> вызывается для "
"каждого отдельного изменения строки в транзакции, производимого командами "
"<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>. Даже если команда изменила несколько строк сразу, этот обработчик "
"будет вызываться для каждой отдельной строки. <placeholder-1/> Параметры "
"<parameter>ctx</parameter> и <parameter>txn</parameter> имеют то же "
"содержимое, что и для обработчиков <function>begin_cb</function> и "
"<function>commit_cb</function>; дополнительный дескриптор отношения "
"<parameter>relation</parameter> указывает на отношение, к которому "
"принадлежит строка, а структура <parameter>change</parameter> описывает "
"передаваемое изменение строки."

#: logicaldecoding.xml:571(para)
msgid ""
"Only changes in user defined tables that are not unlogged (see <xref linkend="
"\"sql-createtable-unlogged\"/>) and not temporary (see <xref linkend=\"sql-"
"createtable-temporary\"/>) can be extracted using logical decoding."
msgstr ""
"В процессе логического декодирования могут быть обработаны изменения только "
"в таблицах, не являющихся нежурналируемыми (см. описание <xref linkend=\"sql-"
"createtable-unlogged\"/>) или временными (см. описание <xref remap=\"4\" "
"linkend=\"sql-createtable-temporary\"/>)."

#: logicaldecoding.xml:581(title)
msgid "Origin Filter Callback"
msgstr "Обработчик фильтрации источника"

#: logicaldecoding.xml:588(programlisting)
#, fuzzy, no-wrap
msgid ""
"typedef bool (*LogicalDecodeFilterByOriginCB) (struct LogicalDecodingContext *ctx,\n"
"                                               RepOriginId origin_id);"
msgstr ""
"typedef bool (*LogicalDecodeFilterByOriginCB) (\n"
"    struct LogicalDecodingContext *ctx,\n"
"    RepNodeId origin_id\n"
");"

#: logicaldecoding.xml:583(para)
msgid ""
"The optional <function>filter_by_origin_cb</function> callback is called to "
"determine whether data that has been replayed from <parameter>origin_id</"
"parameter> is of interest to the output plugin. <placeholder-1/> The "
"<parameter>ctx</parameter> parameter has the same contents as for the other "
"callbacks. No information but the origin is available. To signal that "
"changes originating on the passed in node are irrelevant, return true, "
"causing them to be filtered away; false otherwise. The other callbacks will "
"not be called for transactions and changes that have been filtered away."
msgstr ""
"Необязательный обработчик <function>filter_by_origin_cb</function> "
"вызывается, чтобы отметить, интересуют ли модуль вывода изменения, "
"воспроизводимые из указанного источника (<parameter>origin_id</parameter>). "
"<placeholder-1/> В параметре <parameter>ctx</parameter> передаётся та же "
"информация, что и для других обработчиков. Чтобы отметить, что изменения, "
"поступающие из переданного узла, не представляют интереса, модуль должен "
"вернуть true, вследствие чего эти изменения будут фильтроваться; в противном "
"случае он должен вернуть false. Другие обработчики для фильтруемых "
"транзакций и изменений вызываться не будут."

#: logicaldecoding.xml:599(para)
msgid ""
"This is useful when implementing cascading or multidirectional replication "
"solutions. Filtering by the origin allows to prevent replicating the same "
"changes back and forth in such setups. While transactions and changes also "
"carry information about the origin, filtering via this callback is "
"noticeably more efficient."
msgstr ""
"Это полезно при реализации каскадной или разнонаправленной репликации. "
"Фильтрация по источнику в таких конфигурациях позволяет предотвратить "
"передачу взад-вперёд одних и тех же изменений. Хотя информацию об источнике "
"можно также извлечь из транзакций и изменений, фильтрация с помощью этого "
"обработчика гораздо более эффективна."

#: logicaldecoding.xml:610(title)
msgid "Generic Message Callback"
msgstr "Обработчик произвольных сообщений"

#: logicaldecoding.xml:615(programlisting)
#, fuzzy, no-wrap
msgid ""
"typedef void (*LogicalDecodeMessageCB) (struct LogicalDecodingContext *ctx,\n"
"                                        ReorderBufferTXN *txn,\n"
"                                        XLogRecPtr message_lsn,\n"
"                                        bool transactional,\n"
"                                        const char *prefix,\n"
"                                        Size message_size,\n"
"                                        const char *message);"
msgstr ""
"typedef void (*LogicalDecodeMessageCB) (\n"
"    struct LogicalDecodingContext *,\n"
"    ReorderBufferTXN *txn,\n"
"    XLogRecPtr message_lsn,\n"
"    bool transactional,\n"
"    const char *prefix,\n"
"    Size message_size,\n"
"    const char *message\n"
");"

#: logicaldecoding.xml:612(para)
msgid ""
"The optional <function>message_cb</function> callback is called whenever a "
"logical decoding message has been decoded. <placeholder-1/> The "
"<parameter>txn</parameter> parameter contains meta information about the "
"transaction, like the time stamp at which it has been committed and its XID. "
"Note however that it can be NULL when the message is non-transactional and "
"the XID was not assigned yet in the transaction which logged the message. "
"The <parameter>lsn</parameter> has WAL position of the message. The "
"<parameter>transactional</parameter> says if the message was sent as "
"transactional or not. The <parameter>prefix</parameter> is arbitrary null-"
"terminated prefix which can be used for identifying interesting messages for "
"the current plugin. And finally the <parameter>message</parameter> parameter "
"holds the actual message of <parameter>message_size</parameter> size."
msgstr ""
"Необязательный обработчик <function>message_cb</function> вызывается при "
"получении сообщения логического декодирования. <placeholder-1/> Параметр "
"<parameter>txn</parameter> содержит метаинформацию о транзакции, включая "
"время её фиксации и её XID. Заметьте, однако, что в нём может передаваться "
"NULL, когда сообщение нетранзакционное и транзакции, в которой было выдано "
"сообщение, ещё не назначен XID. В параметре <parameter>lsn</parameter> "
"отмечается позиция сообщения в WAL. Параметр <parameter>transactional</"
"parameter> показывает, было ли сообщение передано как транзакционное. В "
"параметре <parameter>prefix</parameter> передаётся некоторый префикс "
"(завершающийся нулём), по которому текущий модуль может выделять "
"интересующие его сообщения. И наконец, параметр <parameter>message</"
"parameter> содержит само сообщение размером <parameter>message_size</"
"parameter> байт."

#: logicaldecoding.xml:636(para)
msgid ""
"Extra care should be taken to ensure that the prefix the output plugin "
"considers interesting is unique. Using name of the extension or the output "
"plugin itself is often a good choice."
msgstr ""
"Необходимо дополнительно позаботиться о том, чтобы префикс, определяющий "
"интересующие модуль вывода сообщения, был уникальным. Удачным выбором обычно "
"будет имя расширения или самого модуля вывода."

#: logicaldecoding.xml:646(title)
msgid "Functions for Producing Output"
msgstr "Функции для формирования вывода"

#: logicaldecoding.xml:648(para)
msgid ""
"To actually produce output, output plugins can write data to the "
"<literal>StringInfo</literal> output buffer in <literal>ctx-&gt;out</"
"literal> when inside the <function>begin_cb</function>, <function>commit_cb</"
"function>, or <function>change_cb</function> callbacks. Before writing to "
"the output buffer, <function>OutputPluginPrepareWrite(ctx, last_write)</"
"function> has to be called, and after finishing writing to the buffer, "
"<function>OutputPluginWrite(ctx, last_write)</function> has to be called to "
"perform the write. The <parameter>last_write</parameter> indicates whether a "
"particular write was the callback's last write."
msgstr ""
"Чтобы действительно вывести данные, модули вывода могут записывать их в "
"буфер <literal>StringInfo</literal> через <literal>ctx-&gt;out</literal>, "
"внутри обработчиков <function>begin_cb</function>, <function>commit_cb</"
"function> или <function>change_cb</function>. Прежде чем записывать данные в "
"этот буфер, необходимо вызвать <function>OutputPluginPrepareWrite(ctx, "
"last_write)</function>, а завершив запись в буфер, нужно вызвать "
"<function>OutputPluginWrite(ctx, last_write)</function>, чтобы собственно "
"произвести запись. Параметр <parameter>last_write</parameter> указывает, "
"была ли эта определённая операция записи последней в данном обработчике."

#: logicaldecoding.xml:664(programlisting)
#, no-wrap
msgid ""
"OutputPluginPrepareWrite(ctx, true);\n"
"appendStringInfo(ctx-&gt;out, \"BEGIN %u\", txn-&gt;xid);\n"
"OutputPluginWrite(ctx, true);"
msgstr ""
"OutputPluginPrepareWrite(ctx, true);\n"
"appendStringInfo(ctx-&gt;out, \"BEGIN %u\", txn-&gt;xid);\n"
"OutputPluginWrite(ctx, true);"

#: logicaldecoding.xml:661(para)
msgid ""
"The following example shows how to output data to the consumer of an output "
"plugin: <placeholder-1/>"
msgstr ""
"Следующий пример показывает, как вывести данные для потребителя модуля "
"вывода: <placeholder-1/>"

#: logicaldecoding.xml:674(title)
msgid "Logical Decoding Output Writers"
msgstr "Запись вывода логического декодирования"

#: logicaldecoding.xml:676(para)
msgid ""
"It is possible to add more output methods for logical decoding. For details, "
"see <filename>src/backend/replication/logical/logicalfuncs.c</filename>. "
"Essentially, three functions need to be provided: one to read WAL, one to "
"prepare writing output, and one to write the output (see <xref linkend="
"\"logicaldecoding-output-plugin-output\"/>)."
msgstr ""
"Архитектура сервера позволяет добавлять другие методы вывода для логического "
"декодирования. За подробностями обратитесь к коду <filename>src/backend/"
"replication/logical/logicalfuncs.c</filename>. По сути, необходимо "
"реализовать три функции: одну для чтения WAL, другую для подготовки к "
"записи, и третью для записи вывода (см. <xref remap=\"4\" linkend="
"\"logicaldecoding-output-plugin-output\"/>)."

#: logicaldecoding.xml:687(title)
msgid "Synchronous Replication Support for Logical Decoding"
msgstr "Поддержка синхронной репликации для логического декодирования"

#: logicaldecoding.xml:689(para)
msgid ""
"Logical decoding can be used to build <link linkend=\"synchronous-replication"
"\">synchronous replication</link> solutions with the same user interface as "
"synchronous replication for <link linkend=\"streaming-replication"
"\">streaming replication</link>. To do this, the streaming replication "
"interface (see <xref linkend=\"logicaldecoding-walsender\"/>) must be used "
"to stream out data. Clients have to send <literal>Standby status update (F)</"
"literal> (see <xref linkend=\"protocol-replication\"/>) messages, just like "
"streaming replication clients do."
msgstr ""
"Логическое декодирование может использоваться для реализации <link linkend="
"\"synchronous-replication\">синхронной репликации</link> с тем же внешним "
"интерфейсом, что и синхронная репликация поверх <link linkend=\"streaming-"
"replication\">потоковой репликации</link>. Для этого потоковая передача "
"данных должна происходить через интерфейс потоковой репликации (см. <xref "
"remap=\"4\" linkend=\"logicaldecoding-walsender\"/>). Клиенты такой "
"репликации должны посылать сообщения <literal>Обновление состояния "
"резервного сервера (F)</literal> (см. <xref remap=\"4\" linkend=\"protocol-"
"replication\"/>), как и клиенты потоковой репликации."

#: logicaldecoding.xml:702(para)
msgid ""
"A synchronous replica receiving changes via logical decoding will work in "
"the scope of a single database. Since, in contrast to that, "
"<parameter>synchronous_standby_names</parameter> currently is server wide, "
"this means this technique will not work properly if more than one database "
"is actively used."
msgstr ""
"Синхронная реплика, получающая изменения через логическое декодирование, "
"будет работать в рамках одной базы данных. Так как "
"<parameter>synchronous_standby_names</parameter> в настоящее время, "
"напротив, устанавливается на уровне сервера, это означает, что этот подход "
"не будет работать корректно при использовании нескольких баз данных."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: logicaldecoding.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
