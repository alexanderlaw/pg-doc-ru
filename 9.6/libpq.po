# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-08-09 16:00+0300\n"
"PO-Revision-Date: 2017-07-12 08:18+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: libpq.xml:5(title)
msgid "<application>libpq</application> - C Library"
msgstr "<application>libpq</application> — библиотека для языка C"

#: libpq.xml:7(indexterm)
msgid "<primary>libpq</primary>"
msgstr "<primary>libpq</primary>"

#: libpq.xml:11(indexterm)
msgid "<primary>C</primary>"
msgstr "<primary>C</primary>"

#: libpq.xml:15(para)
msgid ""
"<application>libpq</application> is the <acronym>C</acronym> application "
"programmer's interface to <productname>PostgreSQL</productname>. "
"<application>libpq</application> is a set of library functions that allow "
"client programs to pass queries to the <productname>PostgreSQL</productname> "
"backend server and to receive the results of these queries."
msgstr ""
"<application>libpq</application> — это интерфейс <productname>PostgreSQL</"
"productname> для программирования приложений на языке <acronym>C</acronym>. "
"Библиотека <application>libpq</application> содержит набор функций, "
"используя которые клиентские программы могут передавать запросы серверу "
"<productname>PostgreSQL</productname> и принимать результаты этих запросов."

#: libpq.xml:23(para)
msgid ""
"<application>libpq</application> is also the underlying engine for several "
"other <productname>PostgreSQL</productname> application interfaces, "
"including those written for C++, Perl, Python, Tcl and <application>ECPG</"
"application>. So some aspects of <application>libpq</application>'s behavior "
"will be important to you if you use one of those packages. In particular, "
"<xref linkend=\"libpq-envars\"/>, <xref linkend=\"libpq-pgpass\"/> and <xref "
"linkend=\"libpq-ssl\"/> describe behavior that is visible to the user of any "
"application that uses <application>libpq</application>."
msgstr ""
"<application>libpq</application> также является базовым механизмом для "
"нескольких других прикладных интерфейсов <productname>PostgreSQL</"
"productname>, включая те, что написаны для C++, Perl, Python, Tcl и "
"<application>ECPG</application>. Поэтому некоторые аспекты поведения "
"<application>libpq</application> будут важны для вас, если вы используете "
"один из этих пакетов. В частности, <xref linkend=\"libpq-envars\"/>, <xref "
"linkend=\"libpq-pgpass\"/> и <xref linkend=\"libpq-ssl\"/> описывают "
"поведение, видимое пользователю любого приложения, использующего "
"<application>libpq</application>."

#: libpq.xml:36(para)
msgid ""
"Some short programs are included at the end of this chapter (<xref linkend="
"\"libpq-example\"/>) to show how to write programs that use "
"<application>libpq</application>. There are also several complete examples "
"of <application>libpq</application> applications in the directory "
"<filename>src/test/examples</filename> in the source code distribution."
msgstr ""
"В конце этой главы включены короткие программы (<xref linkend=\"libpq-example"
"\"/>), показывающие, как писать программы, которые используют "
"<application>libpq</application>. В каталоге <filename>src/test/examples</"
"filename> дистрибутивного комплекта исходных текстов приведено несколько "
"завершённых примеров приложений <application>libpq</application>."

#: libpq.xml:46(indexterm) libpq.xml:1387(indexterm)
msgid "<primary>libpq-fe.h</primary>"
msgstr "<primary>libpq-fe.h</primary>"

#: libpq.xml:43(para)
msgid ""
"Client programs that use <application>libpq</application> must include the "
"header file <filename>libpq-fe.h</filename><placeholder-1/> and must link "
"with the <application>libpq</application> library."
msgstr ""
"Клиентские программы, которые используют <application>libpq</application>, "
"должны включать заголовочный файл <filename>libpq-fe.h</"
"filename><placeholder-1/> и должны компоноваться с библиотекой "
"<application>libpq</application>."

#: libpq.xml:51(title)
msgid "Database Connection Control Functions"
msgstr "Функции управления подключением к базе данных"

#: libpq.xml:59(indexterm)
msgid "<primary>PGconn</primary>"
msgstr "<primary>PGconn</primary>"

#: libpq.xml:70(para)
msgid ""
"On Unix, forking a process with open libpq connections can lead to "
"unpredictable results because the parent and child processes share the same "
"sockets and operating system resources. For this reason, such usage is not "
"recommended, though doing an <function>exec</function> from the child "
"process to load a new executable is safe."
msgstr ""
"В системе Unix создание дочернего процесса на основе процесса, уже имеющего "
"открытые подключения с помощью libpq, может привести к непредсказуемым "
"результатам, потому что родительский и дочерний процессы совместно "
"используют одни и те же сокеты и ресурсы операционной системы. По этой "
"причине подобный подход не рекомендуется. Однако использование системного "
"вызова <function>exec</function> из дочернего процесса для загрузки нового "
"исполняемого файла является безопасным."

#: libpq.xml:80(para)
msgid ""
"On Windows, there is a way to improve performance if a single database "
"connection is repeatedly started and shutdown. Internally, libpq calls "
"<function>WSAStartup()</function> and <function>WSACleanup()</function> for "
"connection startup and shutdown, respectively. <function>WSAStartup()</"
"function> increments an internal Windows library reference count which is "
"decremented by <function>WSACleanup()</function>. When the reference count "
"is just one, calling <function>WSACleanup()</function> frees all resources "
"and all DLLs are unloaded. This is an expensive operation. To avoid this, an "
"application can manually call <function>WSAStartup()</function> so resources "
"will not be freed when the last database connection is closed."
msgstr ""
"В системе Windows существует способ повышения производительности, при "
"котором единственное соединение с базой данных повторно стартует и "
"останавливается. На внутреннем уровне libpq вызывает <function>WSAStartup()</"
"function> и <function>WSACleanup()</function> для старта и остановки "
"соединения соответственно. <function>WSAStartup()</function> увеличивает на "
"единицу внутренний счётчик ссылок в библиотеке Windows, который уменьшается "
"на единицу при вызове <function>WSACleanup()</function>. Когда счётчик "
"ссылок равен единице, вызов <function>WSACleanup()</function> освобождает "
"все ресурсы, и все библиотеки DLL выгружаются. Это дорогостоящая операция. "
"Для её избежания приложение может \"вручную\" вызвать "
"<function>WSAStartup()</function>, чтобы ресурсы не были освобождены, когда "
"закрыто последнее соединение с базой данных."

#: libpq.xml:96(function)
msgid "PQconnectdbParams"
msgstr "PQconnectdbParams"

#: libpq.xml:96(indexterm)
msgid "<primary>PQconnectdbParams</primary>"
msgstr "<primary>PQconnectdbParams</primary>"

#: libpq.xml:98(para)
msgid ""
"Makes a new connection to the database server. <synopsis>\n"
"PGconn *PQconnectdbParams(const char * const *keywords,\n"
"                          const char * const *values,\n"
"                          int expand_dbname);\n"
"</synopsis>"
msgstr ""
"Создаёт новое подключение к серверу баз данных. <synopsis>\n"
"PGconn *PQconnectdbParams(const char * const *keywords,\n"
"                          const char * const *values,\n"
"                          int expand_dbname);\n"
"</synopsis>"

#: libpq.xml:108(para)
msgid ""
"This function opens a new database connection using the parameters taken "
"from two <symbol>NULL</symbol>-terminated arrays. The first, "
"<literal>keywords</literal>, is defined as an array of strings, each one "
"being a key word. The second, <literal>values</literal>, gives the value for "
"each key word. Unlike <function>PQsetdbLogin</function> below, the parameter "
"set can be extended without changing the function signature, so use of this "
"function (or its nonblocking analogs <function>PQconnectStartParams</"
"function> and <function>PQconnectPoll</function>) is preferred for new "
"application programming."
msgstr ""
"Эта функция открывает новое соединение с базой данных, используя параметры, "
"содержащиеся в двух массивах, завершающихся символом <symbol>NULL</symbol>. "
"Первый из них, <literal>keywords</literal>, определяется как массив строк, "
"каждая из которых представляет собой ключевое слово. Второй, "
"<literal>values</literal>, даёт значение для каждого ключевого слова. В "
"отличие от <function>PQsetdbLogin</function>, описываемой ниже, набор "
"параметров может быть расширен без изменения сигнатуры функции, поэтому "
"использование данной функции (или её неблокирующих аналогов "
"<function>PQconnectStartParams</function> и <function>PQconnectPoll</"
"function>) является предпочтительным при разработке новых приложений."

#: libpq.xml:120(para)
msgid ""
"The currently recognized parameter key words are listed in <xref linkend="
"\"libpq-paramkeywords\"/>."
msgstr ""
"Ключевые слова-параметры, распознаваемые в настоящее время, приведены в "
"<xref remap=\"6\" linkend=\"libpq-paramkeywords\"/>."

#: libpq.xml:125(para)
msgid ""
"When <literal>expand_dbname</literal> is non-zero, the <parameter>dbname</"
"parameter> key word value is allowed to be recognized as a connection "
"string. Only the first occurrence of <parameter>dbname</parameter> is "
"expanded this way, any subsequent <parameter>dbname</parameter> value is "
"processed as plain database name. More details on the possible connection "
"string formats appear in <xref linkend=\"libpq-connstring\"/>."
msgstr ""
"Когда <literal>expand_dbname</literal> имеет ненулевое значение, тогда в "
"качестве значения, соответствующего ключевому слову <parameter>dbname</"
"parameter>, может быть указана строка подключения. Только первый экземпляр "
"<parameter>dbname</parameter> расширяется таким образом, а все последующие "
"значения <parameter>dbname</parameter> будут обработаны как обычные имена "
"базы данных. Дополнительные сведения о возможных форматах строки подключения "
"можно найти в <xref remap=\"6\" linkend=\"libpq-connstring\"/>."

#: libpq.xml:135(para)
msgid ""
"The passed arrays can be empty to use all default parameters, or can contain "
"one or more parameter settings. They should be matched in length. Processing "
"will stop at the first <symbol>NULL</symbol> element in the "
"<literal>keywords</literal> array."
msgstr ""
"Передаваемые массивы могут быть пустыми. В этом случае используются все "
"параметры по умолчанию. Массивы могут также содержать один или более "
"элементов и должны быть согласованы по длине. Обработка прекращается, когда "
"найден первый элемент со значением <symbol>NULL</symbol> в массиве "
"<literal>keywords</literal>."

#: libpq.xml:142(para)
msgid ""
"If any parameter is <symbol>NULL</symbol> or an empty string, the "
"corresponding environment variable (see <xref linkend=\"libpq-envars\"/>) is "
"checked. If the environment variable is not set either, then the indicated "
"built-in defaults are used."
msgstr ""
"Если какой-либо параметр имеет значение <symbol>NULL</symbol> или содержит "
"пустую строку, проверяется значение соответствующей переменной окружения "
"(см. <xref remap=\"4\" linkend=\"libpq-envars\"/>). Если и переменная "
"окружения не установлена, используется встроенное значение по умолчанию."

#: libpq.xml:149(para)
msgid ""
"In general key words are processed from the beginning of these arrays in "
"index order. The effect of this is that when key words are repeated, the "
"last processed value is retained. Therefore, through careful placement of "
"the <parameter>dbname</parameter> key word, it is possible to determine what "
"may be overridden by a <parameter>conninfo</parameter> string, and what may "
"not."
msgstr ""
"В общем случае ключевые слова обрабатываются в индексном порядке, начиная с "
"начала этих массивов. Вследствие такого подхода, когда ключевые слова "
"повторяются, сохраняется последнее обработанное значение. Следовательно, за "
"счёт соответствующего расположения ключевого слова <parameter>dbname</"
"parameter> можно регулировать, что может быть переопределено строкой "
"<parameter>conninfo</parameter>, а что не может."

#: libpq.xml:161(function)
msgid "PQconnectdb"
msgstr "PQconnectdb"

#: libpq.xml:161(indexterm)
msgid "<primary>PQconnectdb</primary>"
msgstr "<primary>PQconnectdb</primary>"

#: libpq.xml:163(para)
msgid ""
"Makes a new connection to the database server. <synopsis>\n"
"PGconn *PQconnectdb(const char *conninfo);\n"
"</synopsis>"
msgstr ""
"Создаёт новое подключение к серверу баз данных. <synopsis>\n"
"PGconn *PQconnectdb(const char *conninfo);\n"
"</synopsis>"

#: libpq.xml:171(para)
msgid ""
"This function opens a new database connection using the parameters taken "
"from the string <literal>conninfo</literal>."
msgstr ""
"Эта функция открывает новое соединение с базой данных, используя параметры, "
"полученные из строки <literal>conninfo</literal>."

#: libpq.xml:176(para)
msgid ""
"The passed string can be empty to use all default parameters, or it can "
"contain one or more parameter settings separated by whitespace, or it can "
"contain a <acronym>URI</acronym>. See <xref linkend=\"libpq-connstring\"/> "
"for details."
msgstr ""
"Передаваемая строка может быть пустой. В этом случае используются все "
"параметры по умолчанию. Она также может содержать одно или более значений "
"параметров, разделённых пробелами, или <acronym>URI</acronym>. За "
"подробностями обратитесь к <xref remap=\"3\" linkend=\"libpq-connstring\"/>."

#: libpq.xml:188(function)
msgid "PQsetdbLogin"
msgstr "PQsetdbLogin"

#: libpq.xml:188(indexterm)
msgid "<primary>PQsetdbLogin</primary>"
msgstr "<primary>PQsetdbLogin</primary>"

#: libpq.xml:190(para)
msgid ""
"Makes a new connection to the database server. <synopsis>\n"
"PGconn *PQsetdbLogin(const char *pghost,\n"
"                     const char *pgport,\n"
"                     const char *pgoptions,\n"
"                     const char *pgtty,\n"
"                     const char *dbName,\n"
"                     const char *login,\n"
"                     const char *pwd);\n"
"</synopsis>"
msgstr ""
"Создаёт новое подключение к серверу баз данных. <synopsis>\n"
"PGconn *PQsetdbLogin(const char *pghost,\n"
"                     const char *pgport,\n"
"                     const char *pgoptions,\n"
"                     const char *pgtty,\n"
"                     const char *dbName,\n"
"                     const char *login,\n"
"                     const char *pwd);\n"
"</synopsis>"

#: libpq.xml:203(para)
msgid ""
"This is the predecessor of <function>PQconnectdb</function> with a fixed set "
"of parameters. It has the same functionality except that the missing "
"parameters will always take on default values. Write <symbol>NULL</symbol> "
"or an empty string for any one of the fixed parameters that is to be "
"defaulted."
msgstr ""
"Это предшественница функции <function>PQconnectdb</function> с фиксированным "
"набором параметров. Она имеет такую же функциональность, за исключением "
"того, что непереданные параметры всегда принимают значения по умолчанию. "
"Подставьте <symbol>NULL</symbol> или пустую строку в качестве любого из "
"фиксированных параметров, которые должны принять значения по умолчанию."

#: libpq.xml:210(para)
msgid ""
"If the <parameter>dbName</parameter> contains an <symbol>=</symbol> sign or "
"has a valid connection <acronym>URI</acronym> prefix, it is taken as a "
"<parameter>conninfo</parameter> string in exactly the same way as if it had "
"been passed to <function>PQconnectdb</function>, and the remaining "
"parameters are then applied as specified for <function>PQconnectdbParams</"
"function>."
msgstr ""
"Если параметр <parameter>dbName</parameter> содержит знак <symbol>=</symbol> "
"или имеет допустимый префикс <acronym>URI</acronym> для подключения, то он "
"воспринимается в качестве строки <parameter>conninfo</parameter> точно таким "
"же образом, как если бы он был передан функции <function>PQconnectdb</"
"function>, а оставшиеся параметры затем применяются, как указано для "
"<function>PQconnectdbParams</function>."

#: libpq.xml:221(function)
msgid "PQsetdb"
msgstr "PQsetdb"

#: libpq.xml:221(indexterm)
msgid "<primary>PQsetdb</primary>"
msgstr "<primary>PQsetdb</primary>"

#: libpq.xml:223(para)
msgid ""
"Makes a new connection to the database server. <synopsis>\n"
"PGconn *PQsetdb(char *pghost,\n"
"                char *pgport,\n"
"                char *pgoptions,\n"
"                char *pgtty,\n"
"                char *dbName);\n"
"</synopsis>"
msgstr ""
"Создаёт новое подключение к серверу баз данных. <synopsis>\n"
"PGconn *PQsetdb(char *pghost,\n"
"                char *pgport,\n"
"                char *pgoptions,\n"
"                char *pgtty,\n"
"                char *dbName);\n"
"</synopsis>"

#: libpq.xml:234(para)
msgid ""
"This is a macro that calls <function>PQsetdbLogin</function> with null "
"pointers for the <parameter>login</parameter> and <parameter>pwd</parameter> "
"parameters. It is provided for backward compatibility with very old programs."
msgstr ""
"Это макрос, который вызывает <function>PQsetdbLogin</function> с нулевыми "
"указателями в качестве значений параметров <parameter>login</parameter> и "
"<parameter>pwd</parameter>. Обеспечивает обратную совместимость с очень "
"старыми программами."

#: libpq.xml:243(function)
msgid "PQconnectStartParams"
msgstr "PQconnectStartParams"

#: libpq.xml:243(indexterm)
msgid "<primary>PQconnectStartParams</primary>"
msgstr "<primary>PQconnectStartParams</primary>"

#: libpq.xml:244(function)
msgid "PQconnectStart"
msgstr "PQconnectStart"

#: libpq.xml:244(indexterm)
msgid "<primary>PQconnectStart</primary>"
msgstr "<primary>PQconnectStart</primary>"

#: libpq.xml:245(function)
msgid "PQconnectPoll"
msgstr "PQconnectPoll"

#: libpq.xml:245(indexterm)
msgid "<primary>PQconnectPoll</primary>"
msgstr "<primary>PQconnectPoll</primary>"

#: libpq.xml:248(indexterm) libpq.xml:4053(indexterm)
msgid "<primary>nonblocking connection</primary>"
msgstr "<primary>неблокирующее соединение</primary>"

#: libpq.xml:247(para)
msgid ""
"<placeholder-1/> Make a connection to the database server in a nonblocking "
"manner. <synopsis>\n"
"PGconn *PQconnectStartParams(const char * const *keywords,\n"
"                             const char * const *values,\n"
"                             int expand_dbname);\n"
"\n"
"PGconn *PQconnectStart(const char *conninfo);\n"
"\n"
"PostgresPollingStatusType PQconnectPoll(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"<placeholder-1/> Создают подключение к серверу баз данных неблокирующим "
"способом. <synopsis>\n"
"PGconn *PQconnectStartParams(const char * const *keywords,\n"
"                             const char * const *values,\n"
"                             int expand_dbname);\n"
"\n"
"PGconn *PQconnectStart(const char *conninfo);\n"
"\n"
"PostgresPollingStatusType PQconnectPoll(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:262(para)
msgid ""
"These three functions are used to open a connection to a database server "
"such that your application's thread of execution is not blocked on remote I/"
"O whilst doing so. The point of this approach is that the waits for I/O to "
"complete can occur in the application's main loop, rather than down inside "
"<function>PQconnectdbParams</function> or <function>PQconnectdb</function>, "
"and so the application can manage this operation in parallel with other "
"activities."
msgstr ""
"Три эти функции используются для того, чтобы открыть подключение к серверу "
"баз данных таким образом, чтобы поток исполнения вашего приложения не был "
"заблокирован при выполнении удалённой операции ввода/вывода в процессе "
"подключения. Суть этого подхода в том, чтобы ожидание завершения операций "
"ввода/вывода могло происходить в главном цикле приложения, а не в внутри "
"функций <function>PQconnectdbParams</function> или <function>PQconnectdb</"
"function>, с тем, чтобы приложение могло управлять этой операцией "
"параллельно с другой работой."

#: libpq.xml:271(para)
msgid ""
"With <function>PQconnectStartParams</function>, the database connection is "
"made using the parameters taken from the <literal>keywords</literal> and "
"<literal>values</literal> arrays, and controlled by <literal>expand_dbname</"
"literal>, as described above for <function>PQconnectdbParams</function>."
msgstr ""
"С помощью функции <function>PQconnectStartParams</function> подключение к "
"базе данных выполняется, используя параметры, взятые из массивов "
"<literal>keywords</literal> и <literal>values</literal>, а управление "
"осуществляется с помощью <literal>expand_dbname</literal>, как описано выше "
"для <function>PQconnectdbParams</function>."

#: libpq.xml:278(para)
msgid ""
"With <function>PQconnectStart</function>, the database connection is made "
"using the parameters taken from the string <literal>conninfo</literal> as "
"described above for <function>PQconnectdb</function>."
msgstr ""
"С помощью функции <function>PQconnectStart</function> подключение к базе "
"данных выполняется, используя параметры, взятые из строки <literal>conninfo</"
"literal>, как описано выше для <function>PQconnectdb</function>."

#: libpq.xml:290(para)
msgid ""
"The <literal>hostaddr</literal> and <literal>host</literal> parameters are "
"used appropriately to ensure that name and reverse name queries are not "
"made. See the documentation of these parameters in <xref linkend=\"libpq-"
"paramkeywords\"/> for details."
msgstr ""
"Параметры <literal>hostaddr</literal> и <literal>host</literal> используются "
"надлежащим образом, чтобы прямой и обратный DNS-запросы не выполнялись. "
"Подробнее эти параметры описаны в <xref remap=\"6\" linkend=\"libpq-"
"paramkeywords\"/>."

#: libpq.xml:298(para)
msgid ""
"If you call <function>PQtrace</function>, ensure that the stream object into "
"which you trace will not block."
msgstr ""
"Если вы вызываете <function>PQtrace</function>, обеспечьте, чтобы поток, в "
"который выводится трассировочная информация, не заблокировался."

#: libpq.xml:305(para)
msgid ""
"You ensure that the socket is in the appropriate state before calling "
"<function>PQconnectPoll</function>, as described below."
msgstr ""
"Вы обеспечиваете, чтобы сокет находился в соответствующем состоянии перед "
"вызовом <function>PQconnectPoll</function>, как описано ниже."

#: libpq.xml:284(para)
msgid ""
"Neither <function>PQconnectStartParams</function> nor "
"<function>PQconnectStart</function> nor <function>PQconnectPoll</function> "
"will block, so long as a number of restrictions are met: <placeholder-1/>"
msgstr ""
"Ни <function>PQconnectStartParams</function>, ни <function>PQconnectStart</"
"function>, ни <function>PQconnectPoll</function> не заблокируются до тех "
"пор, пока выполняется ряд ограничений: <placeholder-1/>"

#: libpq.xml:313(para)
msgid ""
"Note: use of <function>PQconnectStartParams</function> is analogous to "
"<function>PQconnectStart</function> shown below."
msgstr ""
"Примечание: использование <function>PQconnectStartParams</function> "
"аналогично использованию <function>PQconnectStart</function>, показанному "
"ниже."

#: libpq.xml:318(para)
msgid ""
"To begin a nonblocking connection request, call <literal>conn = "
"PQconnectStart(\"<replaceable>connection_info_string</replaceable>\")</"
"literal>. If <varname>conn</varname> is null, then <application>libpq</"
"application> has been unable to allocate a new <structname>PGconn</"
"structname> structure. Otherwise, a valid <structname>PGconn</structname> "
"pointer is returned (though not yet representing a valid connection to the "
"database). On return from <function>PQconnectStart</function>, call "
"<literal>status = PQstatus(conn)</literal>. If <varname>status</varname> "
"equals <symbol>CONNECTION_BAD</symbol>, <function>PQconnectStart</function> "
"has failed."
msgstr ""
"Чтобы начать неблокирующий запрос на подключение, вызовите <literal>conn = "
"PQconnectStart(\"<replaceable>connection_info_string</replaceable>\")</"
"literal>. Если значение <varname>conn</varname> пустое, то, значит, "
"<application>libpq</application> не смогла распределить память для новой "
"структуры <structname>PGconn</structname>. В противном случае будет "
"возвращён корректный указатель <structname>PGconn</structname> (хотя ещё и "
"не представляющий действительного подключения к базе данных). После возврата "
"из <function>PQconnectStart</function> вызовите <literal>status = "
"PQstatus(conn)</literal>. Если <varname>status</varname> имеет значение "
"<symbol>CONNECTION_BAD</symbol>, то, значит, вызов <function>PQconnectStart</"
"function> завершился сбоем."

#: libpq.xml:327(para)
msgid ""
"If <function>PQconnectStart</function> succeeds, the next stage is to poll "
"<application>libpq</application> so that it can proceed with the connection "
"sequence. Use <function>PQsocket(conn)</function> to obtain the descriptor "
"of the socket underlying the database connection. Loop thus: If "
"<function>PQconnectPoll(conn)</function> last returned "
"<symbol>PGRES_POLLING_READING</symbol>, wait until the socket is ready to "
"read (as indicated by <function>select()</function>, <function>poll()</"
"function>, or similar system function). Then call "
"<function>PQconnectPoll(conn)</function> again. Conversely, if "
"<function>PQconnectPoll(conn)</function> last returned "
"<symbol>PGRES_POLLING_WRITING</symbol>, wait until the socket is ready to "
"write, then call <function>PQconnectPoll(conn)</function> again. If you have "
"yet to call <function>PQconnectPoll</function>, i.e., just after the call to "
"<function>PQconnectStart</function>, behave as if it last returned "
"<symbol>PGRES_POLLING_WRITING</symbol>. Continue this loop until "
"<function>PQconnectPoll(conn)</function> returns "
"<symbol>PGRES_POLLING_FAILED</symbol>, indicating the connection procedure "
"has failed, or <symbol>PGRES_POLLING_OK</symbol>, indicating the connection "
"has been successfully made."
msgstr ""
"Если вызов <function>PQconnectStart</function> был успешным, теперь нужно "
"опросить <application>libpq</application>, чтобы она могла возобновить "
"процесс подключения. Используйте <function>PQsocket(conn)</function> для "
"получения дескриптора сокета, лежащего в основе соединения с базой данных. "
"Организуйте цикл таким образом: если <function>PQconnectPoll(conn)</"
"function> в последний раз возвратила <symbol>PGRES_POLLING_READING</symbol>, "
"то подождите, пока сокет не станет готовым к выполнению операции чтения (это "
"покажет функция <function>select()</function>, <function>poll()</function> "
"или подобная системная функция). Затем вызовите "
"<function>PQconnectPoll(conn)</function> опять. И наоборот, если "
"<function>PQconnectPoll(conn)</function> в последний раз возвратила "
"<symbol>PGRES_POLLING_WRITING</symbol>, то подождите, пока сокет не станет "
"готовым к выполнению операции записи, затем вызовите "
"<function>PQconnectPoll(conn)</function> снова. Если вам всё же приходится "
"вызвать <function>PQconnectPoll</function>, то есть сразу после вызова "
"<function>PQconnectStart</function>, поступайте так, как будто она в "
"последний раз возвратила <symbol>PGRES_POLLING_WRITING</symbol>. Продолжайте "
"этот цикл до тех пор, пока <function>PQconnectPoll(conn)</function> не "
"возвратит <symbol>PGRES_POLLING_FAILED</symbol>, показывая, что процедура "
"подключения завершилась сбоем, или <symbol>PGRES_POLLING_OK</symbol>, "
"показывая, что соединение было успешно установлено."

#: libpq.xml:362(symbol)
msgid "CONNECTION_STARTED"
msgstr "CONNECTION_STARTED"

#: libpq.xml:364(para)
msgid "Waiting for connection to be made."
msgstr "Ожидание, пока соединение будет установлено."

#: libpq.xml:371(symbol)
msgid "CONNECTION_MADE"
msgstr "CONNECTION_MADE"

#: libpq.xml:373(para)
msgid "Connection OK; waiting to send."
msgstr "Соединение установлено; ожидание отправки."

#: libpq.xml:380(symbol)
msgid "CONNECTION_AWAITING_RESPONSE"
msgstr "CONNECTION_AWAITING_RESPONSE"

#: libpq.xml:382(para)
msgid "Waiting for a response from the server."
msgstr "Ожидание ответа от сервера."

#: libpq.xml:389(symbol)
msgid "CONNECTION_AUTH_OK"
msgstr "CONNECTION_AUTH_OK"

#: libpq.xml:391(para)
msgid "Received authentication; waiting for backend start-up to finish."
msgstr "Аутентификация получена; ожидание завершения запуска серверной части."

#: libpq.xml:398(symbol)
msgid "CONNECTION_SSL_STARTUP"
msgstr "CONNECTION_SSL_STARTUP"

#: libpq.xml:400(para)
msgid "Negotiating SSL encryption."
msgstr "Согласование SSL-шифрования."

#: libpq.xml:407(symbol)
msgid "CONNECTION_SETENV"
msgstr "CONNECTION_SETENV"

#: libpq.xml:409(para)
msgid "Negotiating environment-driven parameter settings."
msgstr "Согласование значений параметров, зависящих от программной среды."

#: libpq.xml:420(programlisting)
#, no-wrap
msgid ""
"switch(PQstatus(conn))\n"
"{\n"
"        case CONNECTION_STARTED:\n"
"            feedback = \"Connecting...\";\n"
"            break;\n"
"\n"
"        case CONNECTION_MADE:\n"
"            feedback = \"Connected to server...\";\n"
"            break;\n"
".\n"
".\n"
".\n"
"        default:\n"
"            feedback = \"Connecting...\";\n"
"}"
msgstr ""
"switch(PQstatus(conn))\n"
"{\n"
"        case CONNECTION_STARTED:\n"
"            feedback = \"Подключение...\";\n"
"            break;\n"
"\n"
"        case CONNECTION_MADE:\n"
"            feedback = \"Подключён к серверу...\";\n"
"            break;\n"
".\n"
".\n"
".\n"
"        default:\n"
"            feedback = \"Подключение...\";\n"
"}"

#: libpq.xml:350(para)
msgid ""
"At any time during connection, the status of the connection can be checked "
"by calling <function>PQstatus</function>. If this call returns "
"<symbol>CONNECTION_BAD</symbol>, then the connection procedure has failed; "
"if the call returns <function>CONNECTION_OK</function>, then the connection "
"is ready. Both of these states are equally detectable from the return value "
"of <function>PQconnectPoll</function>, described above. Other states might "
"also occur during (and only during) an asynchronous connection procedure. "
"These indicate the current stage of the connection procedure and might be "
"useful to provide feedback to the user for example. These statuses are: "
"<placeholder-1/> Note that, although these constants will remain (in order "
"to maintain compatibility), an application should never rely upon these "
"occurring in a particular order, or at all, or on the status always being "
"one of these documented values. An application might do something like this: "
"<placeholder-2/>"
msgstr ""
"В любое время в процессе подключения его состояние можно проверить, вызвав "
"<function>PQstatus</function>. Если этот вызов возвратит "
"<symbol>CONNECTION_BAD</symbol>, значит, процедура подключения завершилась "
"сбоем; если вызов возвратит <function>CONNECTION_OK</function>, значит, "
"соединение готово. Оба эти состояния можно определить на основе "
"возвращаемого значения функции <function>PQconnectPoll</function>, описанной "
"выше. Другие состояния могут также иметь место в течение (и только в "
"течение) асинхронной процедуры подключения. Они показывают текущую стадию "
"процедуры подключения и могут быть полезны, например, для предоставления "
"обратной связи пользователю. Вот эти состояния: <placeholder-1/> Заметьте, "
"что, хотя эти константы и сохранятся (для поддержания совместимости), "
"приложение никогда не должно полагаться на то, что они появятся в каком-то "
"конкретном порядке или вообще появятся, а также на то, что состояние всегда "
"примет одно из этих документированных значений. Приложение может сделать что-"
"то наподобие: <placeholder-2/>"

#: libpq.xml:439(para)
msgid ""
"The <literal>connect_timeout</literal> connection parameter is ignored when "
"using <function>PQconnectPoll</function>; it is the application's "
"responsibility to decide whether an excessive amount of time has elapsed. "
"Otherwise, <function>PQconnectStart</function> followed by a "
"<function>PQconnectPoll</function> loop is equivalent to "
"<function>PQconnectdb</function>."
msgstr ""
"Параметр подключения <literal>connect_timeout</literal> игнорируется, когда "
"используется <function>PQconnectPoll</function>; именно приложение отвечает "
"за принятие решения о том, является ли истекшее время чрезмерным. В "
"противном случае вызов <function>PQconnectStart</function> с последующим "
"вызовом <function>PQconnectPoll в цикле</function> будут эквивалентны вызову "
"<function>PQconnectdb</function>."

#: libpq.xml:448(para)
msgid ""
"Note that if <function>PQconnectStart</function> returns a non-null pointer, "
"you must call <function>PQfinish</function> when you are finished with it, "
"in order to dispose of the structure and any associated memory blocks. This "
"must be done even if the connection attempt fails or is abandoned."
msgstr ""
"Заметьте, что если <function>PQconnectStart</function> возвращает ненулевой "
"указатель, вы должны вызвать <function>PQfinish</function> для завершения, "
"чтобы ликвидировать структуру и любые связанные с ней блоки памяти. Это "
"должно быть сделано, даже если попытка подключения не была успешной или была "
"прекращена."

#: libpq.xml:458(function)
msgid "PQconndefaults"
msgstr "PQconndefaults"

#: libpq.xml:458(indexterm)
msgid "<primary>PQconndefaults</primary>"
msgstr "<primary>PQconndefaults</primary>"

#: libpq.xml:460(para)
msgid ""
"Returns the default connection options. <synopsis>\n"
"PQconninfoOption *PQconndefaults(void);\n"
"\n"
"typedef struct\n"
"{\n"
"    char   *keyword;   /* The keyword of the option */\n"
"    char   *envvar;    /* Fallback environment variable name */\n"
"    char   *compiled;  /* Fallback compiled in default value */\n"
"    char   *val;       /* Option's current value, or NULL */\n"
"    char   *label;     /* Label for field in connect dialog */\n"
"    char   *dispchar;  /* Indicates how to display this field\n"
"                          in a connect dialog. Values are:\n"
"                          \"\"        Display entered value as is\n"
"                          \"*\"       Password field - hide value\n"
"                          \"D\"       Debug option - don't show by default "
"*/\n"
"    int     dispsize;  /* Field size in characters for dialog */\n"
"} PQconninfoOption;\n"
"</synopsis>"
msgstr ""
"Возвращает значения по умолчанию для параметров подключения. <synopsis>\n"
"PQconninfoOption *PQconndefaults(void);\n"
"\n"
"typedef struct\n"
"{\n"
"    char   *keyword;   /* Ключевое слово для данного параметра */\n"
"    char   *envvar;    /* Имя альтернативной переменной окружения */\n"
"    char   *compiled;  /* Альтернативное значение по умолчанию, назначенное "
"при компиляции */\n"
"    char   *val;       /* Текущее значение параметра или NULL */\n"
"    char   *label;     /* Обозначение этого поля в диалоге подключения */\n"
"    char   *dispchar;  /* Показывает, как отображать это поле\n"
"                          в диалоге подключения. Значения следующие:\n"
"                          \"\"        Отображать введённое значение \"как "
"есть\"\n"
"                          \"*\"       Поле пароля — скрывать значение\n"
"                          \"D\"       Параметр отладки — не показывать по "
"умолчанию */\n"
"    int     dispsize;  /* Размер поля в символах для диалога */\n"
"} PQconninfoOption;\n"
"</synopsis>"

#: libpq.xml:482(para)
msgid ""
"Returns a connection options array. This can be used to determine all "
"possible <function>PQconnectdb</function> options and their current default "
"values. The return value points to an array of <structname>PQconninfoOption</"
"structname> structures, which ends with an entry having a null "
"<structfield>keyword</structfield> pointer. The null pointer is returned if "
"memory could not be allocated. Note that the current default values "
"(<structfield>val</structfield> fields) will depend on environment variables "
"and other context. A missing or invalid service file will be silently "
"ignored. Callers must treat the connection options data as read-only."
msgstr ""
"Возвращает массив параметров подключения. Он может использоваться для "
"определения всех возможных параметров <function>PQconnectdb</function> и их "
"текущих значений по умолчанию. Возвращаемое значение указывает на массив "
"структур <structname>PQconninfoOption</structname>, который завершается "
"элементом, имеющим нулевой указатель <structfield>keyword</structfield>. "
"Если выделить память не удалось, то возвращается нулевой указатель. Обратите "
"внимание, что текущие значения по умолчанию (поля <structfield>val</"
"structfield>) будут зависеть от переменных среды и другого контекста. "
"Отсутствующий или неверный сервисный файл будет молча проигнорирован. "
"Вызывающие функции должны рассматривать данные параметров по умолчанию как "
"\"только для чтения\"."

#: libpq.xml:495(para)
msgid ""
"After processing the options array, free it by passing it to "
"<function>PQconninfoFree</function>. If this is not done, a small amount of "
"memory is leaked for each call to <function>PQconndefaults</function>."
msgstr ""
"После обработки массива параметров освободите память, передав его функции "
"<function>PQconninfoFree</function>. Если этого не делать, то при каждом "
"вызове функции <function>PQconndefaults</function> будут происходить "
"небольшие \"утечки\" памяти."

#: libpq.xml:505(function)
msgid "PQconninfo"
msgstr "PQconninfo"

#: libpq.xml:505(indexterm)
msgid "<primary>PQconninfo</primary>"
msgstr "<primary>PQconninfo</primary>"

#: libpq.xml:507(para)
msgid ""
"Returns the connection options used by a live connection. <synopsis>\n"
"PQconninfoOption *PQconninfo(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает параметры подключения, используемые действующим соединением. "
"<synopsis>\n"
"PQconninfoOption *PQconninfo(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:514(para)
msgid ""
"Returns a connection options array. This can be used to determine all "
"possible <function>PQconnectdb</function> options and the values that were "
"used to connect to the server. The return value points to an array of "
"<structname>PQconninfoOption</structname> structures, which ends with an "
"entry having a null <structfield>keyword</structfield> pointer. All notes "
"above for <function>PQconndefaults</function> also apply to the result of "
"<function>PQconninfo</function>."
msgstr ""
"Возвращает массив параметров подключения. Он может использоваться для "
"определения всех возможных параметров <function>PQconnectdb</function> и "
"значений, которые были использованы для подключения к серверу. Возвращаемое "
"значение указывает на массив структур <structname>PQconninfoOption</"
"structname>, который завершается элементом, имеющим нулевой указатель "
"<structfield>keyword</structfield>. Все замечания, приведённые выше для "
"<function>PQconndefaults</function>, также справедливы и для результата "
"<function>PQconninfo</function>."

#: libpq.xml:529(function)
msgid "PQconninfoParse"
msgstr "PQconninfoParse"

#: libpq.xml:529(indexterm)
msgid "<primary>PQconninfoParse</primary>"
msgstr "<primary>PQconninfoParse</primary>"

#: libpq.xml:531(para)
msgid ""
"Returns parsed connection options from the provided connection string. "
"<synopsis>\n"
"PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);\n"
"</synopsis>"
msgstr ""
"Возвращает разобранные параметры подключения, переданные в строке "
"подключения. <synopsis>\n"
"PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);\n"
"</synopsis>"

#: libpq.xml:539(para)
msgid ""
"Parses a connection string and returns the resulting options as an array; or "
"returns <symbol>NULL</symbol> if there is a problem with the connection "
"string. This function can be used to extract the <function>PQconnectdb</"
"function> options in the provided connection string. The return value points "
"to an array of <structname>PQconninfoOption</structname> structures, which "
"ends with an entry having a null <structfield>keyword</structfield> pointer."
msgstr ""
"Разбирает строку подключения и возвращает результирующие параметры в виде "
"массива; возвращает <symbol>NULL</symbol>, если возникают проблемы при "
"разборе строки подключения. Эту функцию можно использовать для извлечения "
"параметров функции <function>PQconnectdb</function> из предоставленной "
"строки подключения. Возвращаемое значение указывает на массив структур "
"<structname>PQconninfoOption</structname>, который завершается элементом, "
"имеющим нулевой указатель <structfield>keyword</structfield>."

#: libpq.xml:549(para)
msgid ""
"All legal options will be present in the result array, but the "
"<literal>PQconninfoOption</literal> for any option not present in the "
"connection string will have <literal>val</literal> set to <literal>NULL</"
"literal>; default values are not inserted."
msgstr ""
"Все разрешённые параметры будут присутствовать в результирующем массиве, но "
"<literal>PQconninfoOption</literal> для любого параметра, не присутствующего "
"в строке подключения, будет иметь значение <literal>NULL</literal> в поле "
"<literal>val</literal>; значения по умолчанию не подставляются."

#: libpq.xml:556(para)
msgid ""
"If <literal>errmsg</literal> is not <symbol>NULL</symbol>, then "
"<literal>*errmsg</literal> is set to <symbol>NULL</symbol> on success, else "
"to a <function>malloc</function>'d error string explaining the problem. (It "
"is also possible for <literal>*errmsg</literal> to be set to <symbol>NULL</"
"symbol> and the function to return <symbol>NULL</symbol>; this indicates an "
"out-of-memory condition.)"
msgstr ""
"Если <literal>errmsg</literal> не равно <symbol>NULL</symbol>, тогда в "
"случае успеха <literal>*errmsg</literal> присваивается <symbol>NULL</"
"symbol>, а в противном случае -- адрес строки сообщения об ошибке, "
"объясняющего проблему. Память для этой строки выделяет функция "
"<function>malloc</function>. (Также возможна ситуация, когда "
"<literal>*errmsg</literal> будет установлено в <symbol>NULL</symbol>, и при "
"этом функция возвращает <symbol>NULL</symbol>. Это указывает на нехватку "
"памяти.)"

#: libpq.xml:564(para)
msgid ""
"After processing the options array, free it by passing it to "
"<function>PQconninfoFree</function>. If this is not done, some memory is "
"leaked for each call to <function>PQconninfoParse</function>. Conversely, if "
"an error occurs and <literal>errmsg</literal> is not <symbol>NULL</symbol>, "
"be sure to free the error string using <function>PQfreemem</function>."
msgstr ""
"После обработки массива параметров освободите память, передав его функции "
"<function>PQconninfoFree</function>. Если этого не делать, тогда некоторое "
"количество памяти будет утекать при каждом вызове <function>PQconninfoParse</"
"function>. И наоборот, если произошла ошибка и <literal>errmsg</literal> не "
"равно <symbol>NULL</symbol>, обязательно освободите память, занимаемую "
"строкой сообщения об ошибке, используя <function>PQfreemem</function>."

#: libpq.xml:576(function)
msgid "PQfinish"
msgstr "PQfinish"

#: libpq.xml:576(indexterm)
msgid "<primary>PQfinish</primary>"
msgstr "<primary>PQfinish</primary>"

#: libpq.xml:578(para)
msgid ""
"Closes the connection to the server. Also frees memory used by the "
"<structname>PGconn</structname> object. <synopsis>\n"
"void PQfinish(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Закрывает соединение с сервером. Также освобождает память, используемую "
"объектом <structname>PGconn</structname>. <synopsis>\n"
"void PQfinish(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:586(para)
msgid ""
"Note that even if the server connection attempt fails (as indicated by "
"<function>PQstatus</function>), the application should call "
"<function>PQfinish</function> to free the memory used by the "
"<structname>PGconn</structname> object. The <structname>PGconn</structname> "
"pointer must not be used again after <function>PQfinish</function> has been "
"called."
msgstr ""
"Обратите внимание, что даже если попытка подключения к серверу потерпела "
"неудачу (как показывает <function>PQstatus</function>), приложение все равно "
"должно вызвать <function>PQfinish</function>, чтобы освободить память, "
"используемую объектом <structname>PGconn</structname>. Указатель "
"<structname>PGconn</structname> не должен использоваться повторно после "
"того, как была вызвана функция <function>PQfinish</function>."

#: libpq.xml:597(function)
msgid "PQreset"
msgstr "PQreset"

#: libpq.xml:597(indexterm)
msgid "<primary>PQreset</primary>"
msgstr "<primary>PQreset</primary>"

#: libpq.xml:599(para)
msgid ""
"Resets the communication channel to the server. <synopsis>\n"
"void PQreset(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Переустанавливает канал связи с сервером. <synopsis>\n"
"void PQreset(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:606(para)
msgid ""
"This function will close the connection to the server and attempt to "
"reestablish a new connection to the same server, using all the same "
"parameters previously used. This might be useful for error recovery if a "
"working connection is lost."
msgstr ""
"Эта функция закроет подключение к серверу, а потом попытается восстановить "
"подключение к тому же серверу, используя все те же параметры, которые "
"использовались прежде. Это может быть полезным для восстановления после "
"ошибки, если работающее соединение оказалось потерянным."

#: libpq.xml:617(function)
msgid "PQresetStart"
msgstr "PQresetStart"

#: libpq.xml:617(indexterm)
msgid "<primary>PQresetStart</primary>"
msgstr "<primary>PQresetStart</primary>"

#: libpq.xml:618(function)
msgid "PQresetPoll"
msgstr "PQresetPoll"

#: libpq.xml:618(indexterm)
msgid "<primary>PQresetPoll</primary>"
msgstr "<primary>PQresetPoll</primary>"

#: libpq.xml:620(para)
msgid ""
"Reset the communication channel to the server, in a nonblocking manner. "
"<synopsis>\n"
"int PQresetStart(PGconn *conn);\n"
"\n"
"PostgresPollingStatusType PQresetPoll(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Переустанавливает канал связи с сервером неблокирующим способом. <synopsis>\n"
"int PQresetStart(PGconn *conn);\n"
"\n"
"PostgresPollingStatusType PQresetPoll(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:630(para)
msgid ""
"These functions will close the connection to the server and attempt to "
"reestablish a new connection to the same server, using all the same "
"parameters previously used. This can be useful for error recovery if a "
"working connection is lost. They differ from <function>PQreset</function> "
"(above) in that they act in a nonblocking manner. These functions suffer "
"from the same restrictions as <function>PQconnectStartParams</function>, "
"<function>PQconnectStart</function> and <function>PQconnectPoll</function>."
msgstr ""
"Эти функции закроют подключение к серверу, а потом попытаются восстановить "
"подключение к тому же серверу, используя все те же параметры, которые "
"использовались прежде. Это может быть полезным для восстановления после "
"ошибки, если работающее соединение оказалось потерянным. Они отличаются от "
"<function>PQreset</function> (см. выше) тем, что действуют неблокирующим "
"способом. На эти функции налагаются те же ограничения, что и на "
"<function>PQconnectStartParams</function>, <function>PQconnectStart</"
"function> и <function>PQconnectPoll</function>."

#: libpq.xml:640(para)
msgid ""
"To initiate a connection reset, call <function>PQresetStart</function>. If "
"it returns 0, the reset has failed. If it returns 1, poll the reset using "
"<function>PQresetPoll</function> in exactly the same way as you would create "
"the connection using <function>PQconnectPoll</function>."
msgstr ""
"Чтобы приступить к переустановке подключения, вызовите "
"<function>PQresetStart</function>. Если она возвратит 0, переустановка "
"завершилась неудачно. Если она возвратит 1, опросите результат "
"переустановки, используя <function>PQresetPoll</function>, точно таким же "
"образом, как если бы вы создавали подключение, используя "
"<function>PQconnectPoll</function>."

#: libpq.xml:651(function)
msgid "PQpingParams"
msgstr "PQpingParams"

#: libpq.xml:651(indexterm)
msgid "<primary>PQpingParams</primary>"
msgstr "<primary>PQpingParams</primary>"

#: libpq.xml:671(literal)
msgid "PQPING_OK"
msgstr "PQPING_OK"

#: libpq.xml:673(para)
msgid "The server is running and appears to be accepting connections."
msgstr "Сервер работает и, по-видимому, принимает подключения."

#: libpq.xml:680(literal)
msgid "PQPING_REJECT"
msgstr "PQPING_REJECT"

#: libpq.xml:682(para)
msgid ""
"The server is running but is in a state that disallows connections (startup, "
"shutdown, or crash recovery)."
msgstr ""
"Сервер работает, но находится в состоянии, которое запрещает подключения "
"(запуск, завершение работы или восстановление после аварийного отказа)."

#: libpq.xml:690(literal)
msgid "PQPING_NO_RESPONSE"
msgstr "PQPING_NO_RESPONSE"

#: libpq.xml:692(para)
msgid ""
"The server could not be contacted. This might indicate that the server is "
"not running, or that there is something wrong with the given connection "
"parameters (for example, wrong port number), or that there is a network "
"connectivity problem (for example, a firewall blocking the connection "
"request)."
msgstr ""
"Контакт с сервером не удался. Это может указывать на то, что сервер не "
"запущен или что-то не в порядке с параметрами данного подключения (например, "
"неверный номер порта), или имеет место проблема с возможностью соединения по "
"сети (например, брандмауэр блокирует запрос на подключение)."

#: libpq.xml:703(literal)
msgid "PQPING_NO_ATTEMPT"
msgstr "PQPING_NO_ATTEMPT"

#: libpq.xml:705(para)
msgid ""
"No attempt was made to contact the server, because the supplied parameters "
"were obviously incorrect or there was some client-side problem (for example, "
"out of memory)."
msgstr ""
"Никакой попытки установить контакт с сервером сделано не было, поскольку "
"предоставленные параметры были явно некорректными, или имела место какая-то "
"проблема на стороне клиента (например, нехватка памяти)."

#: libpq.xml:653(para)
msgid ""
"<function>PQpingParams</function> reports the status of the server. It "
"accepts connection parameters identical to those of "
"<function>PQconnectdbParams</function>, described above. It is not necessary "
"to supply correct user name, password, or database name values to obtain the "
"server status; however, if incorrect values are provided, the server will "
"log a failed connection attempt. <synopsis>\n"
"PGPing PQpingParams(const char * const *keywords,\n"
"                    const char * const *values,\n"
"                    int expand_dbname);\n"
"</synopsis> The function returns one of the following values: <placeholder-1/"
">"
msgstr ""
"<function>PQpingParams</function> сообщает состояние сервера. Она принимает "
"параметры подключения, идентичные тем, что получает функция "
"<function>PQconnectdbParams</function>, описанная выше. Нет необходимости "
"предоставлять корректные имя пользователя, пароль или имя базы данных, чтобы "
"получить состояние сервера. Однако, если предоставлены некорректные "
"значения, сервер занесёт в журнал неудачную попытку подключения.<synopsis>\n"
"PGPing PQpingParams(const char * const *keywords,\n"
"                    const char * const *values,\n"
"                    int expand_dbname);\n"
"</synopsis> Функция возвращает одно из следующих значений: <placeholder-1/>"

#: libpq.xml:720(function)
msgid "PQping"
msgstr "PQping"

#: libpq.xml:720(indexterm)
msgid "<primary>PQping</primary>"
msgstr "<primary>PQping</primary>"

#: libpq.xml:722(para)
msgid ""
"<function>PQping</function> reports the status of the server. It accepts "
"connection parameters identical to those of <function>PQconnectdb</"
"function>, described above. It is not necessary to supply correct user name, "
"password, or database name values to obtain the server status; however, if "
"incorrect values are provided, the server will log a failed connection "
"attempt. <synopsis>\n"
"PGPing PQping(const char *conninfo);\n"
"</synopsis>"
msgstr ""
"<function>PQping</function> сообщает состояние сервера. Она принимает "
"параметры подключения, идентичные тем, что получает функция "
"<function>PQconnectdb</function>, описанная выше. Нет необходимости "
"предоставлять корректные имя пользователя, пароль или имя базы данных, чтобы "
"получить состояние сервера. Однако, если предоставлены некорректные "
"значения, сервер занесёт в журнал неудачную попытку подключения. <synopsis>\n"
"PGPing PQping(const char *conninfo);\n"
"</synopsis>"

#: libpq.xml:735(para)
msgid ""
"The return values are the same as for <function>PQpingParams</function>."
msgstr ""
"Возвращаемые значения такие же, как и для <function>PQpingParams</function>."

#: libpq.xml:53(para)
msgid ""
"The following functions deal with making a connection to a "
"<productname>PostgreSQL</productname> backend server. An application program "
"can have several backend connections open at one time. (One reason to do "
"that is to access more than one database.) Each connection is represented by "
"a <structname>PGconn</structname><placeholder-1/> object, which is obtained "
"from the function <function>PQconnectdb</function>, "
"<function>PQconnectdbParams</function>, or <function>PQsetdbLogin</"
"function>. Note that these functions will always return a non-null object "
"pointer, unless perhaps there is too little memory even to allocate the "
"<structname>PGconn</structname> object. The <function>PQstatus</function> "
"function should be called to check the return value for a successful "
"connection before queries are sent via the connection object. <placeholder-2/"
"> <placeholder-3/> <placeholder-4/>"
msgstr ""
"Следующие функции имеют дело с созданием подключения к серверу "
"<productname>PostgreSQL</productname>. Прикладная программа может иметь "
"несколько подключений к серверу, открытых одновременно. (Одна из причин "
"этого заключается в необходимости доступа к более чем одной базе данных.) "
"Каждое соединение представляется объектом <structname>PGconn</"
"structname><placeholder-1/>, который можно получить от функций "
"<function>PQconnectdb</function>, <function>PQconnectdbParams</function> или "
"<function>PQsetdbLogin</function>. Обратите внимание, что эти функции всегда "
"возвратят ненулевой указатель на объект, если только, возможно, не осталось "
"слишком мало памяти даже для того, чтобы выделить её для объекта "
"<structname>PGconn</structname>. Прежде чем передавать запросы через объект "
"подключения, следует вызвать функцию <function>PQstatus</function> для "
"проверки возвращаемого значения в случае успешного подключения. "
"<placeholder-2/> <placeholder-3/> <placeholder-4/>"

#: libpq.xml:746(title)
msgid "Connection Strings"
msgstr "Строки параметров подключения"

#: libpq.xml:748(indexterm)
msgid "<primary><literal>conninfo</literal></primary>"
msgstr "<primary><literal>conninfo</literal></primary>"

#: libpq.xml:752(indexterm)
msgid "<primary><literal>URI</literal></primary>"
msgstr "<primary><literal>URI</literal></primary>"

#: libpq.xml:756(para)
msgid ""
"Several <application>libpq</application> functions parse a user-specified "
"string to obtain connection parameters. There are two accepted formats for "
"these strings: plain <literal>keyword = value</literal> strings and <ulink "
"url=\"http://www.ietf.org/rfc/rfc3986.txt\">RFC 3986</ulink> URIs."
msgstr ""
"Несколько функций <application>libpq</application> занимаются разбором "
"строки, заданной пользователем, чтобы получить параметры подключения. Для "
"этих строк существует два общепринятых формата: простые строки вида "
"<literal>keyword = value</literal> и URI в соответствии с <ulink url="
"\"http://www.ietf.org/rfc/rfc3986.txt\">RFC 3986</ulink>."

#: libpq.xml:765(title)
msgid "Keyword/Value Connection Strings"
msgstr "Строки параметров подключения вида \"ключ/значение\""

#: libpq.xml:767(para)
msgid ""
"In the first format, each parameter setting is in the form <literal>keyword "
"= value</literal>. Spaces around the equal sign are optional. To write an "
"empty value, or a value containing spaces, surround it with single quotes, e."
"g., <literal>keyword = 'a value'</literal>. Single quotes and backslashes "
"within the value must be escaped with a backslash, i.e., <literal>\\'</"
"literal> and <literal>\\\\</literal>."
msgstr ""
"Согласно первому формату, установка каждого параметра выполняется в форме "
"<literal>keyword = value</literal>. Пробелы вокруг знака равенства не "
"являются обязательными. Для записи пустого значения или значения, "
"содержащего пробелы, заключите его в одинарные кавычки, например, "
"<literal>keyword = 'a value'</literal>. Одинарные кавычки и символы обратной "
"косой черты внутри значения нужно обязательно экранировать с помощью символа "
"обратной косой черты, т. е., <literal>\\'</literal> и <literal>\\\\</"
"literal>."

#: libpq.xml:779(programlisting)
#, no-wrap
msgid "host=localhost port=5432 dbname=mydb connect_timeout=10"
msgstr "host=localhost port=5432 dbname=mydb connect_timeout=10"

#: libpq.xml:777(para)
msgid "Example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#: libpq.xml:784(para)
msgid ""
"The recognized parameter key words are listed in <xref linkend=\"libpq-"
"paramkeywords\"/>."
msgstr ""
"Ключевые слова-параметры, распознаваемые в настоящее время, приведены в "
"<xref remap=\"6\" linkend=\"libpq-paramkeywords\"/>."

#: libpq.xml:791(title)
msgid "Connection URIs"
msgstr "URI для подключения"

#: libpq.xml:793(para)
msgid ""
"The general form for a connection <acronym>URI</acronym> is: <synopsis>\n"
"postgresql://[user[:password]@][netloc][:port][/dbname][?"
"param1=value1&amp;...]\n"
"</synopsis>"
msgstr ""
"Общая форма <acronym>URI</acronym> для подключения такова: <synopsis>\n"
"postgresql://[user[:password]@][netloc][:port][/dbname][?"
"param1=value1&amp;...]\n"
"</synopsis>"

#: libpq.xml:805(programlisting)
#, no-wrap
msgid ""
"postgresql://\n"
"postgresql://localhost\n"
"postgresql://localhost:5433\n"
"postgresql://localhost/mydb\n"
"postgresql://user@localhost\n"
"postgresql://user:secret@localhost\n"
"postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp"
msgstr ""
"postgresql://\n"
"postgresql://localhost\n"
"postgresql://localhost:5433\n"
"postgresql://localhost/mydb\n"
"postgresql://user@localhost\n"
"postgresql://user:secret@localhost\n"
"postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp"

#: libpq.xml:816(programlisting)
#, no-wrap
msgid "postgresql:///mydb?host=localhost&amp;port=5433"
msgstr "postgresql:///mydb?host=localhost&amp;port=5433"

#: libpq.xml:800(para)
msgid ""
"The <acronym>URI</acronym> scheme designator can be either "
"<literal>postgresql://</literal> or <literal>postgres://</literal>. Each of "
"the <acronym>URI</acronym> parts is optional. The following examples "
"illustrate valid <acronym>URI</acronym> syntax uses: <placeholder-1/> "
"Components of the hierarchical part of the <acronym>URI</acronym> can also "
"be given as parameters. For example: <placeholder-2/>"
msgstr ""
"В качестве обозначения схемы <acronym>URI</acronym> может использоваться "
"либо <literal>postgresql://</literal>, либо <literal>postgres://</literal>. "
"Каждая из частей <acronym>URI</acronym> является необязательной. В следующих "
"примерах показано правильное использование синтаксиса <acronym>URI</"
"acronym>: <placeholder-1/> Компоненты иерархической части <acronym>URI</"
"acronym> можно также передавать в виде параметров. Например: <placeholder-2/>"

#: libpq.xml:821(para)
msgid ""
"Percent-encoding may be used to include symbols with special meaning in any "
"of the <acronym>URI</acronym> parts."
msgstr ""
"Для включения символов, имеющих специальное значение, в любой части "
"<acronym>URI</acronym> можно применять URL-кодирование (с использованием "
"символа %)."

#: libpq.xml:826(para)
msgid ""
"Any connection parameters not corresponding to key words listed in <xref "
"linkend=\"libpq-paramkeywords\"/> are ignored and a warning message about "
"them is sent to <filename>stderr</filename>."
msgstr ""
"Любые параметры соединения, не соответствующие ключевым словам, приведённым "
"в <xref remap=\"6\" linkend=\"libpq-paramkeywords\"/>, игнорируются, а "
"предупреждающее сообщение об этом направляется на <filename>stderr</"
"filename>."

#: libpq.xml:832(para)
msgid ""
"For improved compatibility with JDBC connection <acronym>URI</acronym>s, "
"instances of parameter <literal>ssl=true</literal> are translated into "
"<literal>sslmode=require</literal>."
msgstr ""
"Для улучшения совместимости с теми <acronym>URI</acronym>, которые служат "
"для подключения через JDBC, все экземпляры параметра <literal>ssl=true</"
"literal> преобразуются в <literal>sslmode=require</literal>."

#: libpq.xml:838(para)
msgid ""
"The host part may be either host name or an IP address. To specify an IPv6 "
"host address, enclose it in square brackets: <synopsis>\n"
"postgresql://[2001:db8::1234]/database\n"
"</synopsis>"
msgstr ""
"Сервер можно представить либо доменным именем, либо IP-адресом. При "
"использовании протокола IPv6 нужно заключить адрес в квадратные скобки: "
"<synopsis format=\"linespecific \">postgresql://[2001:db8::1234]/database\n"
"</synopsis>"

#: libpq.xml:855(programlisting)
#, no-wrap
msgid ""
"postgresql:///dbname?host=/var/lib/postgresql\n"
"postgresql://%2Fvar%2Flib%2Fpostgresql/dbname"
msgstr ""
"postgresql:///dbname?host=/var/lib/postgresql\n"
"postgresql://%2Fvar%2Flib%2Fpostgresql/dbname"

#: libpq.xml:846(para)
msgid ""
"The host component is interpreted as described for the parameter <xref "
"linkend=\"libpq-connect-host\"/>. In particular, a Unix-domain socket "
"connection is chosen if the host part is either empty or starts with a "
"slash, otherwise a TCP/IP connection is initiated. Note, however, that the "
"slash is a reserved character in the hierarchical part of the URI. So, to "
"specify a non-standard Unix-domain socket directory, either omit the host "
"specification in the URI and specify the host as a parameter, or percent-"
"encode the path in the host component of the URI: <placeholder-1/>"
msgstr ""
"Компонент \"host\" интерпретируется в соответствии с описанием параметра "
"<xref linkend=\"libpq-connect-host\"/>. В частности, если этот компонент "
"пуст или начинается с символа косой черты, выбирается соединение через "
"доменные сокеты Unix, а в противном случае инициируется соединение по TCP/"
"IP. Обратите внимание, однако, что символ косой черты в иерархической части "
"URI является зарезервированным. Поэтому, чтобы указать нестандартный каталог "
"Unix-сокета, нужно поступить одним из двух способов: не задавать сервер в "
"URI и указать сервер в качестве параметра, либо закодировать путь в "
"компоненте \"host\" с процентами: <placeholder-1/>"

#: libpq.xml:864(title)
msgid "Parameter Key Words"
msgstr "Ключевые слова-параметры"

#: libpq.xml:871(literal)
msgid "host"
msgstr "host"

#: libpq.xml:874(indexterm)
msgid "<primary>host name</primary>"
msgstr "<primary>имя компьютера</primary>"

#: libpq.xml:880(indexterm)
msgid "<primary>Unix domain socket</primary>"
msgstr "<primary>доменный сокет Unix</primary>"

#: libpq.xml:873(para)
msgid ""
"Name of host to connect to.<placeholder-1/> If this begins with a slash, it "
"specifies Unix-domain communication rather than TCP/IP communication; the "
"value is the name of the directory in which the socket file is stored. The "
"default behavior when <literal>host</literal> is not specified is to connect "
"to a Unix-domain socket<placeholder-2/> in <filename>/tmp</filename> (or "
"whatever socket directory was specified when <productname>PostgreSQL</"
"productname> was built). On machines without Unix-domain sockets, the "
"default is to connect to <literal>localhost</literal>."
msgstr ""
"Имя компьютера для подключения.<placeholder-1/> Если оно начинается с косой "
"черты, то тогда предписывается установление связи через домен Unix, а не "
"посредством TCP/IP; значением является имя каталога, в котором создаётся "
"файл сокета. По умолчанию, когда <literal>host</literal> не указан, "
"подключение производится к доменному сокету Unix <placeholder-2/> в каталоге "
"<filename>/tmp</filename> (или в том каталоге, который был назначен при "
"сборке <productname>PostgreSQL</productname>). В системах, не поддерживающих "
"доменные сокеты Unix, подключение по умолчанию производится к "
"<literal>localhost</literal>."

#: libpq.xml:889(literal)
msgid "hostaddr"
msgstr "hostaddr"

#: libpq.xml:891(para)
msgid ""
"Numeric IP address of host to connect to. This should be in the standard "
"IPv4 address format, e.g., <literal>172.28.40.9</literal>. If your machine "
"supports IPv6, you can also use those addresses. TCP/IP communication is "
"always used when a nonempty string is specified for this parameter."
msgstr ""
"Числовой IP-адрес компьютера для подключения. Он должен быть представлен в "
"стандартном формате адресов IPv4, например, <literal>172.28.40.9</literal>. "
"Если ваша машина поддерживает IPv6, вы можете использовать и эти адреса. "
"Связь по протоколу TCP/IP используется всегда, когда в качестве этого "
"параметра передана непустая строка."

#: libpq.xml:908(para)
msgid ""
"If <literal>host</literal> is specified without <literal>hostaddr</literal>, "
"a host name lookup occurs."
msgstr ""
"Если <literal>host</literal> указан, а <literal>hostaddr</literal> не "
"указан, тогда выполняется поиск на сервере имён."

#: libpq.xml:914(para)
msgid ""
"If <literal>hostaddr</literal> is specified without <literal>host</literal>, "
"the value for <literal>hostaddr</literal> gives the server network address. "
"The connection attempt will fail if the authentication method requires a "
"host name."
msgstr ""
"Если указан <literal>hostaddr</literal>, а <literal>host</literal> не "
"указан, тогда значение <literal>hostaddr</literal> даёт сетевой адрес "
"сервера. Попытка подключения завершится неудачей, если метод аутентификации "
"требует наличия имени компьютера."

#: libpq.xml:922(para)
msgid ""
"If both <literal>host</literal> and <literal>hostaddr</literal> are "
"specified, the value for <literal>hostaddr</literal> gives the server "
"network address. The value for <literal>host</literal> is ignored unless the "
"authentication method requires it, in which case it will be used as the host "
"name."
msgstr ""
"Если указаны как <literal>host</literal>, так и <literal>hostaddr</literal>, "
"тогда значение <literal>hostaddr</literal> даёт сетевой адрес сервера, а "
"значение <literal>host</literal> игнорируется, если только метод "
"аутентификации его не потребует. В таком случае оно будет использоваться в "
"качестве имени компьютера."

#: libpq.xml:899(para)
msgid ""
"Using <literal>hostaddr</literal> instead of <literal>host</literal> allows "
"the application to avoid a host name look-up, which might be important in "
"applications with time constraints. However, a host name is required for "
"GSSAPI or SSPI authentication methods, as well as for <literal>verify-full</"
"literal> SSL certificate verification. The following rules are used: "
"<placeholder-1/> Note that authentication is likely to fail if "
"<literal>host</literal> is not the name of the server at network address "
"<literal>hostaddr</literal>. Also, note that <literal>host</literal> rather "
"than <literal>hostaddr</literal> is used to identify the connection in "
"<filename>~/.pgpass</filename> (see <xref linkend=\"libpq-pgpass\"/>)."
msgstr ""
"Использование <literal>hostaddr</literal> вместо <literal>host</literal> "
"позволяет приложению избежать поиска на сервере имён, что может быть важно "
"для приложений, имеющих временные ограничения. Однако, имя компьютера "
"требуется для методов аутентификации GSSAPI или SSPI, а также для проверки "
"полномочий на основе SSL-сертификатов в режиме <literal>verify-full</"
"literal>. Используются следующие правила: <placeholder-1/> Заметьте, что "
"аутентификация может завершится неудачей, если <literal>host</literal> не "
"является именем сервера, имеющего сетевой адрес <literal>hostaddr</literal>. "
"Заметьте также, что <literal>host</literal>, а не <literal>hostaddr</"
"literal> используется для того, чтобы идентифицировать соединение в "
"<filename>~/.pgpass</filename> (см. <xref remap=\"4\" linkend=\"libpq-pgpass"
"\"/>)."

#: libpq.xml:938(para)
msgid ""
"Without either a host name or host address, <application>libpq</application> "
"will connect using a local Unix-domain socket; or on machines without Unix-"
"domain sockets, it will attempt to connect to <literal>localhost</literal>."
msgstr ""
"Если не указаны ни имя компьютера, ни его адрес, <application>libpq</"
"application> будет производить подключение, используя локальный доменный "
"сокет Unix; в системах, не поддерживающих сокеты Unix, она будет пытаться "
"подключиться к <literal>localhost</literal>."

#: libpq.xml:948(literal)
msgid "port"
msgstr "port"

#: libpq.xml:953(indexterm)
msgid "<primary>port</primary>"
msgstr "<primary>port</primary>"

#: libpq.xml:950(para)
msgid ""
"Port number to connect to at the server host, or socket file name extension "
"for Unix-domain connections.<placeholder-1/>"
msgstr ""
"Номер порта для подключения на сервере или расширение имени файла-сокета для "
"подключений на основе домена Unix.<placeholder-1/>"

#: libpq.xml:959(literal)
msgid "dbname"
msgstr "dbname"

#: libpq.xml:961(para)
msgid ""
"The database name. Defaults to be the same as the user name. In certain "
"contexts, the value is checked for extended formats; see <xref linkend="
"\"libpq-connstring\"/> for more details on those."
msgstr ""
"Имя базы данных. По умолчанию оно совпадает с именем пользователя. В "
"определённых контекстах это значение проверяется на соответствие расширенным "
"форматам; см. <xref remap=\"4\" linkend=\"libpq-connstring\"/> для получения "
"подробной информации."

#: libpq.xml:971(literal)
msgid "user"
msgstr "user"

#: libpq.xml:973(para)
msgid ""
"<productname>PostgreSQL</productname> user name to connect as. Defaults to "
"be the same as the operating system name of the user running the application."
msgstr ""
"Имя пользователя <productname>PostgreSQL</productname>, используемое для "
"подключения. По умолчанию используется то же имя, которое имеет в "
"операционной системе пользователь, от лица которого выполняется приложение."

#: libpq.xml:982(literal)
msgid "password"
msgstr "password"

#: libpq.xml:984(para)
msgid "Password to be used if the server demands password authentication."
msgstr ""
"Пароль, используемый в случае, когда сервер требует аутентификации по паролю."

#: libpq.xml:991(literal)
msgid "connect_timeout"
msgstr "connect_timeout"

#: libpq.xml:993(para)
msgid ""
"Maximum wait for connection, in seconds (write as a decimal integer string). "
"Zero or not specified means wait indefinitely. It is not recommended to use "
"a timeout of less than 2 seconds."
msgstr ""
"Максимальный период ожидания подключения, в секундах (записывается в виде "
"строки, представляющей десятичное целое число)."

#: libpq.xml:1002(literal)
msgid "client_encoding"
msgstr "client_encoding"

#: libpq.xml:1004(para)
msgid ""
"This sets the <varname>client_encoding</varname> configuration parameter for "
"this connection. In addition to the values accepted by the corresponding "
"server option, you can use <literal>auto</literal> to determine the right "
"encoding from the current locale in the client (<envar>LC_CTYPE</envar> "
"environment variable on Unix systems)."
msgstr ""
"Этим устанавливается конфигурационный параметр <varname>client_encoding</"
"varname> для данного подключения. В дополнение к значениям, которые "
"принимает соответствующий параметр сервера, вы можете использовать значение "
"<literal>auto</literal>. В этом случае правильная кодировка определяется на "
"основе текущей локали на стороне клиента (в системах Unix это переменная "
"системного окружения <envar>LC_CTYPE</envar>)."

#: libpq.xml:1017(literal)
msgid "options"
msgstr "options"

#: libpq.xml:1019(para)
msgid ""
"Specifies command-line options to send to the server at connection start. "
"For example, setting this to <literal>-c geqo=off</literal> sets the "
"session's value of the <varname>geqo</varname> parameter to <literal>off</"
"literal>. Spaces within this string are considered to separate command-line "
"arguments, unless escaped with a backslash (<literal>\\</literal>); write "
"<literal>\\\\</literal> to represent a literal backslash. For a detailed "
"discussion of the available options, consult <xref linkend=\"runtime-config"
"\"/>."
msgstr ""
"Задаёт параметры командной строки, которые будут отправлены серверу при "
"установлении соединения. Например, значение <literal>-c geqo=off</literal> "
"установит для параметра сеанса <varname>geqo</varname> значение "
"<literal>off</literal>. Пробелы в этой строке считаются разделяющими "
"аргументы командной строки, если только перед ними не стоит обратная косая "
"черта (<literal>\\</literal>); чтобы записать собственно обратную косую "
"черту, её нужно продублировать (<literal>\\\\</literal>). Подробное описание "
"возможных параметров можно найти в <xref remap=\"6\" linkend=\"runtime-config"
"\"/>."

#: libpq.xml:1033(literal)
msgid "application_name"
msgstr "application_name"

#: libpq.xml:1035(para)
msgid ""
"Specifies a value for the <xref linkend=\"guc-application-name\"/> "
"configuration parameter."
msgstr ""
"Устанавливает значение для конфигурационного параметра <xref linkend=\"guc-"
"application-name\"/>."

#: libpq.xml:1043(literal)
msgid "fallback_application_name"
msgstr "fallback_application_name"

#: libpq.xml:1045(para)
msgid ""
"Specifies a fallback value for the <xref linkend=\"guc-application-name\"/> "
"configuration parameter. This value will be used if no value has been given "
"for <literal>application_name</literal> via a connection parameter or the "
"<envar>PGAPPNAME</envar> environment variable. Specifying a fallback name is "
"useful in generic utility programs that wish to set a default application "
"name but allow it to be overridden by the user."
msgstr ""
"Устанавливает альтернативное значение для конфигурационного параметра <xref "
"linkend=\"guc-application-name\"/>. Это значение будет использоваться, если "
"для параметра <literal>application_name</literal> не было передано никакого "
"значения с помощью параметров подключения или переменной системного "
"окружения <envar>PGAPPNAME</envar>. Задание альтернативного имени полезно "
"для универсальных программ-утилит, которые желают установить имя приложения "
"по умолчанию, но позволяют пользователю изменить его."

#: libpq.xml:1059(literal)
msgid "keepalives"
msgstr "keepalives"

#: libpq.xml:1061(para)
msgid ""
"Controls whether client-side TCP keepalives are used. The default value is "
"1, meaning on, but you can change this to 0, meaning off, if keepalives are "
"not wanted. This parameter is ignored for connections made via a Unix-domain "
"socket."
msgstr ""
"Управляет использованием сообщений keepalive протокола TCP на стороне "
"клиента. Значение по умолчанию равно 1, что означает использование "
"сообщений. Вы можете изменить его на 0, если эти сообщения не нужны. Для "
"соединений, установленных через доменный сокет Unix, этот параметр "
"игнорируется."

#: libpq.xml:1071(literal)
msgid "keepalives_idle"
msgstr "keepalives_idle"

#: libpq.xml:1073(para)
#, fuzzy
msgid ""
"Controls the number of seconds of inactivity after which TCP should send a "
"keepalive message to the server. A value of zero uses the system default. "
"This parameter is ignored for connections made via a Unix-domain socket, or "
"if keepalives are disabled. It is only supported on systems where "
"<symbol>TCP_KEEPIDLE</symbol> or an equivalent socket option is available, "
"and on Windows; on other systems, it has no effect."
msgstr ""
"Управляет длительностью периода отсутствия активности, выраженного числом "
"секунд, по истечении которого TCP должен отправить сообщение keepalive "
"серверу. Нулевое значение этого параметра означает, что будет использоваться "
"системное значение по умолчанию. Этот параметр игнорируется, если "
"подключение выполнено через доменный сокет Unix или если сообщения keepalive "
"отключены. Он поддерживается только в системах, где для сокетов доступны "
"параметры <symbol>TCP_KEEPIDLE</symbol> или <symbol>TCP_KEEPALIVE</symbol>, "
"а также в системе Windows; в других системах он не имеет никакого влияния."

#: libpq.xml:1086(literal)
msgid "keepalives_interval"
msgstr "keepalives_interval"

#: libpq.xml:1088(para)
#, fuzzy
msgid ""
"Controls the number of seconds after which a TCP keepalive message that is "
"not acknowledged by the server should be retransmitted. A value of zero uses "
"the system default. This parameter is ignored for connections made via a "
"Unix-domain socket, or if keepalives are disabled. It is only supported on "
"systems where <symbol>TCP_KEEPINTVL</symbol> or an equivalent socket option "
"is available, and on Windows; on other systems, it has no effect."
msgstr ""
"Управляет количеством секунд, по прошествии которых keepalive-сообщение "
"протокола TCP, получение которого не подтверждено сервером, должно быть "
"отправлено повторно. Нулевое значение этого параметра указывает, что будет "
"использоваться системное значение по умолчанию. Этот параметр игнорируется "
"для соединений, установленных через сокеты домена Unix, или если keepalive-"
"сообщения отключены. Он поддерживается только в системах, где для сокетов "
"предусмотрен параметр <symbol>TCP_KEEPINTVL</symbol>, а также в системе "
"Windows; в других системах он не имеет никакого влияния."

#: libpq.xml:1101(literal)
msgid "keepalives_count"
msgstr "keepalives_count"

#: libpq.xml:1103(para)
#, fuzzy
msgid ""
"Controls the number of TCP keepalives that can be lost before the client's "
"connection to the server is considered dead. A value of zero uses the system "
"default. This parameter is ignored for connections made via a Unix-domain "
"socket, or if keepalives are disabled. It is only supported on systems where "
"<symbol>TCP_KEEPCNT</symbol> or an equivalent socket option is available; on "
"other systems, it has no effect."
msgstr ""
"Управляет количеством keepalive-сообщений протокола TCP, которые могут быть "
"потеряны, прежде чем соединение клиента с сервером будет признано "
"неработающим. Нулевое значение этого параметра указывает, что будет "
"использоваться системное значение по умолчанию. Этот параметр игнорируется "
"для соединений, установленных через сокеты домена Unix, или если keepalive-"
"сообщения отключены. Он поддерживается только в системах, где для сокетов "
"предусмотрен параметр <symbol>TCP_KEEPCNT</symbol>; в других системах он не "
"имеет никакого влияния."

#: libpq.xml:1116(literal)
msgid "tty"
msgstr "tty"

#: libpq.xml:1118(para)
msgid "Ignored (formerly, this specified where to send server debug output)."
msgstr ""
"Игнорируется (прежде он указывал, куда направить вывод отладочных сообщений "
"сервера)."

#: libpq.xml:1125(literal) libpq.xml:7524(literal)
msgid "sslmode"
msgstr "sslmode"

#: libpq.xml:1134(literal) libpq.xml:7533(literal)
msgid "disable"
msgstr "disable"

#: libpq.xml:1136(para)
msgid "only try a non-<acronym>SSL</acronym> connection"
msgstr ""
"следует пытаться установить только соединение без использования "
"<acronym>SSL</acronym>"

#: libpq.xml:1143(literal) libpq.xml:7542(literal)
msgid "allow"
msgstr "allow"

#: libpq.xml:1145(para)
msgid ""
"first try a non-<acronym>SSL</acronym> connection; if that fails, try an "
"<acronym>SSL</acronym> connection"
msgstr ""
"сначала следует попытаться установить соединение без использования "
"<acronym>SSL</acronym>; если попытка будет неудачной, нужно попытаться "
"установить <acronym>SSL</acronym>-соединение"

#: libpq.xml:1153(term)
msgid "<literal>prefer</literal> (default)"
msgstr "<literal>prefer</literal> (по умолчанию)"

#: libpq.xml:1155(para)
msgid ""
"first try an <acronym>SSL</acronym> connection; if that fails, try a non-"
"<acronym>SSL</acronym> connection"
msgstr ""
"сначала следует попытаться установить <acronym>SSL</acronym>-соединение; "
"если попытка будет неудачной, нужно попытаться установить соединение без "
"использования <acronym>SSL</acronym>"

#: libpq.xml:1163(literal) libpq.xml:7560(literal)
msgid "require"
msgstr "require"

#: libpq.xml:1165(para)
msgid ""
"only try an <acronym>SSL</acronym> connection. If a root CA file is present, "
"verify the certificate in the same way as if <literal>verify-ca</literal> "
"was specified"
msgstr ""
"следует попытаться установить только <acronym>SSL</acronym>-соединение. Если "
"присутствует файл корневого центра сертификации, то нужно верифицировать "
"сертификат таким же способом, как будто был указан параметр <literal>verify-"
"ca</literal>"

#: libpq.xml:1174(literal) libpq.xml:7569(literal)
msgid "verify-ca"
msgstr "verify-ca"

#: libpq.xml:1176(para)
msgid ""
"only try an <acronym>SSL</acronym> connection, and verify that the server "
"certificate is issued by a trusted certificate authority (<acronym>CA</"
"acronym>)"
msgstr ""
"следует попытаться установить только <acronym>SSL</acronym>-соединение, при "
"этом проконтролировать, чтобы сертификат сервера был выпущен доверенным "
"центром сертификации (<acronym>CA</acronym>)"

#: libpq.xml:1185(literal) libpq.xml:7578(literal)
msgid "verify-full"
msgstr "verify-full"

#: libpq.xml:1187(para)
msgid ""
"only try an <acronym>SSL</acronym> connection, verify that the server "
"certificate is issued by a trusted <acronym>CA</acronym> and that the "
"requested server host name matches that in the certificate"
msgstr ""
"следует попытаться установить только <acronym>SSL</acronym>-соединение, при "
"этом проконтролировать, чтобы сертификат сервера был выпущен доверенным "
"центром сертификации (<acronym>CA</acronym>) и чтобы имя запрошенного "
"сервера соответствовало имени в сертификате"

#: libpq.xml:1127(para)
msgid ""
"This option determines whether or with what priority a secure <acronym>SSL</"
"acronym> TCP/IP connection will be negotiated with the server. There are six "
"modes: <placeholder-1/> See <xref linkend=\"libpq-ssl\"/> for a detailed "
"description of how these options work."
msgstr ""
"Этот параметр определяет, будет ли согласовываться с сервером защищённое "
"<acronym>SSL</acronym>-соединение по протоколу TCP/IP, и если да, то в какой "
"очередности. Всего предусмотрено шесть режимов: <placeholder-1/> В <xref "
"remap=\"6\" linkend=\"libpq-ssl\"/> приведено подробное описание работы этих "
"режимов."

#: libpq.xml:1210(indexterm)
msgid ""
"<primary>SSL</primary><secondary sortas=\"libpq\">with libpq</secondary>"
msgstr "<primary>SSL</primary> <secondary sortas=\"libpq\">с libpq</secondary>"

#: libpq.xml:1201(para)
msgid ""
"<literal>sslmode</literal> is ignored for Unix domain socket communication. "
"If <productname>PostgreSQL</productname> is compiled without SSL support, "
"using options <literal>require</literal>, <literal>verify-ca</literal>, or "
"<literal>verify-full</literal> will cause an error, while options "
"<literal>allow</literal> and <literal>prefer</literal> will be accepted but "
"<application>libpq</application> will not actually attempt an <acronym>SSL</"
"acronym> connection.<placeholder-1/>"
msgstr ""
"<literal>sslmode</literal> игнорируется при использовании сокетов домена "
"Unix. Если <productname>PostgreSQL</productname> скомпилирован без поддержки "
"SSL, использование параметров <literal>require</literal>, <literal>verify-"
"ca</literal> или <literal>verify-full</literal> приведёт к ошибке, в то "
"время как параметры <literal>allow</literal> и <literal>prefer</literal> "
"будут приняты, но <application>libpq</application> в действительности не "
"будет пытаться установить <acronym>SSL</acronym>-соединение.<placeholder-1/>"

#: libpq.xml:1217(literal)
msgid "requiressl"
msgstr "requiressl"

#: libpq.xml:1219(para)
msgid ""
"This option is deprecated in favor of the <literal>sslmode</literal> setting."
msgstr ""
"Использовать этот параметр не рекомендуется, в качестве замены предлагается "
"установить <literal>sslmode</literal>."

#: libpq.xml:1224(para)
msgid ""
"If set to 1, an <acronym>SSL</acronym> connection to the server is required "
"(this is equivalent to <literal>sslmode</literal> <literal>require</"
"literal>). <application>libpq</application> will then refuse to connect if "
"the server does not accept an <acronym>SSL</acronym> connection. If set to 0 "
"(default), <application>libpq</application> will negotiate the connection "
"type with the server (equivalent to <literal>sslmode</literal> "
"<literal>prefer</literal>). This option is only available if "
"<productname>PostgreSQL</productname> is compiled with SSL support."
msgstr ""
"Если установлено значение 1, то требуется <acronym>SSL</acronym>-соединение "
"с сервером (это эквивалентно <literal>sslmode</literal> <literal>require</"
"literal>). <application>libpq</application> в таком случае откажется "
"подключаться, если сервер не принимает <acronym>SSL</acronym>-соединений. "
"Если установлено значение 0 (по умолчанию), тогда <application>libpq</"
"application> будет согласовывать тип подключения с сервером (эквивалентно "
"<literal>sslmode</literal> <literal>prefer</literal>). Этот параметр "
"доступен, если только <productname>PostgreSQL</productname> скомпилирован с "
"поддержкой SSL."

#: libpq.xml:1239(literal)
msgid "sslcompression"
msgstr "sslcompression"

#: libpq.xml:1241(para)
msgid ""
"If set to 1 (default), data sent over SSL connections will be compressed "
"(this requires <productname>OpenSSL</productname> version 0.9.8 or later). "
"If set to 0, compression will be disabled (this requires "
"<productname>OpenSSL</productname> 1.0.0 or later). This parameter is "
"ignored if a connection without SSL is made, or if the version of "
"<productname>OpenSSL</productname> used does not support it."
msgstr ""
"Если установлено значение 1 (по умолчанию), данные, пересылаемые через SSL-"
"соединения, будут сжиматься (это требует <productname>OpenSSL</productname> "
"версии 0.9.8 или более поздней). Если установлено значение 0, сжатие будет "
"отключено (это требует <productname>OpenSSL</productname> версии 1.0.0 или "
"более поздней). Этот параметр игнорируется, если выполнено подключение без "
"SSL, или если используемая версия <productname>OpenSSL</productname> не "
"поддерживает его."

#: libpq.xml:1251(para)
msgid ""
"Compression uses CPU time, but can improve throughput if the network is the "
"bottleneck. Disabling compression can improve response time and throughput "
"if CPU performance is the limiting factor."
msgstr ""
"Сжатие требует процессорного времени, но может улучшить пропускную "
"способность, если узким местом является сеть. Отключение сжатия может "
"улучшить время отклика и пропускную способность, если ограничивающим "
"фактором является производительность CPU."

#: libpq.xml:1261(literal)
msgid "sslcert"
msgstr "sslcert"

#: libpq.xml:1263(para)
msgid ""
"This parameter specifies the file name of the client SSL certificate, "
"replacing the default <filename>~/.postgresql/postgresql.crt</filename>. "
"This parameter is ignored if an SSL connection is not made."
msgstr ""
"Этот параметр предписывает имя файла для SSL-сертификата клиента, "
"заменяющего файл по умолчанию <filename> ~/.postgresql/postgresql.crt</"
"filename>. Этот параметр игнорируется, если SSL-подключение не выполнено."

#: libpq.xml:1273(literal)
msgid "sslkey"
msgstr "sslkey"

#: libpq.xml:1275(para)
msgid ""
"This parameter specifies the location for the secret key used for the client "
"certificate. It can either specify a file name that will be used instead of "
"the default <filename>~/.postgresql/postgresql.key</filename>, or it can "
"specify a key obtained from an external <quote>engine</quote> (engines are "
"<productname>OpenSSL</productname> loadable modules). An external engine "
"specification should consist of a colon-separated engine name and an engine-"
"specific key identifier. This parameter is ignored if an SSL connection is "
"not made."
msgstr ""
"Этот параметр предписывает местоположение секретного ключа, используемого "
"для сертификата клиента. Он может либо указывать имя файла, которое будет "
"использоваться вместо имени по умолчанию <filename> ~/.postgresql/postgresql."
"key</filename>, либо он может указывать ключ, полученный от внешнего "
"<quote>криптомодуля</quote> (криптомодули — это загружаемые модули "
"<productname>OpenSSL</productname>). Спецификация внешнего криптомодуля "
"должна состоять из имени модуля и ключевого идентификатора, зависящего от "
"конкретного модуля, разделённых двоеточием. Этот параметр игнорируется, если "
"SSL-подключение не выполнено."

#: libpq.xml:1290(literal)
msgid "sslrootcert"
msgstr "sslrootcert"

#: libpq.xml:1292(para)
msgid ""
"This parameter specifies the name of a file containing SSL certificate "
"authority (<acronym>CA</acronym>) certificate(s). If the file exists, the "
"server's certificate will be verified to be signed by one of these "
"authorities. The default is <filename>~/.postgresql/root.crt</filename>."
msgstr ""
"Этот параметр указывает имя файла, содержащего SSL-сертификаты, выданные "
"Центром сертификации (<acronym>CA</acronym>). Если файл существует, "
"сертификат сервера будет проверен на предмет его подписания одним из этих "
"центров. Имя по умолчанию — <filename> ~/.postgresql/root.crt</filename>."

#: libpq.xml:1303(literal)
msgid "sslcrl"
msgstr "sslcrl"

#: libpq.xml:1305(para)
msgid ""
"This parameter specifies the file name of the SSL certificate revocation "
"list (CRL). Certificates listed in this file, if it exists, will be rejected "
"while attempting to authenticate the server's certificate. The default is "
"<filename>~/.postgresql/root.crl</filename>."
msgstr ""
"Этот параметр указывает имя файла, содержащего список отозванных SSL-"
"сертификатов (CRL). Сертификаты, перечисленные в этом файле, если он "
"существует, будут отвергаться при попытке установить подлинность сертификата "
"сервера. Имя по умолчанию такое <filename>~/.postgresql/root.crl</filename>."

#: libpq.xml:1316(literal)
msgid "requirepeer"
msgstr "requirepeer"

#: libpq.xml:1318(para)
msgid ""
"This parameter specifies the operating-system user name of the server, for "
"example <literal>requirepeer=postgres</literal>. When making a Unix-domain "
"socket connection, if this parameter is set, the client checks at the "
"beginning of the connection that the server process is running under the "
"specified user name; if it is not, the connection is aborted with an error. "
"This parameter can be used to provide server authentication similar to that "
"available with SSL certificates on TCP/IP connections. (Note that if the "
"Unix-domain socket is in <filename>/tmp</filename> or another publicly "
"writable location, any user could start a server listening there. Use this "
"parameter to ensure that you are connected to a server run by a trusted "
"user.) This option is only supported on platforms for which the "
"<literal>peer</literal> authentication method is implemented; see <xref "
"linkend=\"auth-peer\"/>."
msgstr ""
"Этот параметр указывает имя пользователя операционной системы, "
"предназначенное для сервера, например, <literal>requirepeer=postgres</"
"literal>. При создании подключения через сокет домена Unix, если этот "
"параметр установлен, клиент проверяет в самом начале процедуры подключения, "
"что серверный процесс запущен от имени указанного пользователя; если это не "
"так, соединение аварийно прерывается с ошибкой. Этот параметр можно "
"использовать, чтобы обеспечить аутентификацию сервера, подобную той, которая "
"доступна с помощью SSL-сертификатов при соединениях по протоколу TCP/IP. "
"(Заметьте, что если сокет домена Unix находится в каталоге <filename>/tmp</"
"filename> или в другом каталоге, запись в который разрешена всем "
"пользователям, тогда любой пользователь сможет запустить сервер, "
"прослушивающий сокет в том каталоге. Используйте этот параметр, чтобы "
"гарантировать, что вы подключены к серверу, запущенному доверенным "
"пользователем.) Он поддерживается только на платформах, для которых "
"реализован метод аутентификации <literal>peer</literal>; см. <xref remap="
"\"4\" linkend=\"auth-peer\"/>."

#: libpq.xml:1339(literal)
msgid "krbsrvname"
msgstr "krbsrvname"

#: libpq.xml:1341(para)
msgid ""
"Kerberos service name to use when authenticating with GSSAPI. This must "
"match the service name specified in the server configuration for Kerberos "
"authentication to succeed. (See also <xref linkend=\"gssapi-auth\"/>.)"
msgstr ""
"Имя сервиса Kerberos, предназначенное для использования при аутентификации "
"на основе GSSAPI. Оно должно соответствовать имени сервиса, указанному в "
"конфигурации сервера, чтобы аутентификация на основе Kerberos прошла "
"успешно. (См. также <xref remap=\"4\" linkend=\"gssapi-auth\"/>.)"

#: libpq.xml:1351(literal)
msgid "gsslib"
msgstr "gsslib"

#: libpq.xml:1353(para)
msgid ""
"GSS library to use for GSSAPI authentication. Only used on Windows. Set to "
"<literal>gssapi</literal> to force libpq to use the GSSAPI library for "
"authentication instead of the default SSPI."
msgstr ""
"Библиотека GSS, предназначенная для использования при аутентификации на "
"основе GSSAPI. Используется только в системе Windows. Назначьте значение "
"<literal>gssapi</literal>, чтобы заставить libpq использовать для "
"аутентификации библиотеку GSSAPI вместо SSPI, применяемого по умолчанию."

#: libpq.xml:1362(literal)
msgid "service"
msgstr "service"

#: libpq.xml:1364(para)
msgid ""
"Service name to use for additional parameters. It specifies a service name "
"in <filename>pg_service.conf</filename> that holds additional connection "
"parameters. This allows applications to specify only a service name so "
"connection parameters can be centrally maintained. See <xref linkend=\"libpq-"
"pgservice\"/>."
msgstr ""
"Имя сервиса, используемое для задания дополнительных параметров. Оно "
"указывает имя сервиса в файле <filename>pg_service.conf</filename>, который "
"содержит дополнительные параметры подключения. Это позволяет приложениям "
"указывать только имя сервиса, поскольку параметры подключения могут "
"поддерживаться централизованно. См. <xref remap=\"4\" linkend=\"libpq-"
"pgservice\"/>."

#: libpq.xml:866(para)
msgid "The currently recognized parameter key words are: <placeholder-1/>"
msgstr ""
"Ключевые слова-параметры, распознаваемые в настоящее время, следующие: "
"<placeholder-1/>"

#: libpq.xml:1378(title)
msgid "Connection Status Functions"
msgstr "Функции, описывающие текущее состояние подключения"

#: libpq.xml:1380(para)
msgid ""
"These functions can be used to interrogate the status of an existing "
"database connection object."
msgstr ""
"Эти функции могут использоваться для опроса состояния объекта, описывающего "
"существующее подключение к базе данных."

#: libpq.xml:1388(indexterm)
msgid "<primary>libpq-int.h</primary>"
msgstr "<primary>libpq-int.h</primary>"

#: libpq.xml:1386(para)
msgid ""
"<placeholder-1/> <placeholder-2/> <application>libpq</application> "
"application programmers should be careful to maintain the "
"<structname>PGconn</structname> abstraction. Use the accessor functions "
"described below to get at the contents of <structname>PGconn</structname>. "
"Reference to internal <structname>PGconn</structname> fields using "
"<filename>libpq-int.h</filename> is not recommended because they are subject "
"to change in the future."
msgstr ""
"<placeholder-1/> <placeholder-2/> Разработчики приложений на основе "
"<application>libpq</application> должны тщательно поддерживать абстракцию "
"<structname>PGconn</structname>. Следует использовать функции доступа, "
"описанные ниже, для получения содержимого <structname>PGconn</structname>. "
"Обращение напрямую к внутренним полям <structname>PGconn</structname>, "
"используя сведения из <filename>libpq-int.h</filename>, не рекомендуется, "
"поскольку они могут измениться в будущем."

#: libpq.xml:1405(function)
msgid "PQdb"
msgstr "PQdb"

#: libpq.xml:1406(indexterm)
msgid "<primary>PQdb</primary>"
msgstr "<primary>PQdb</primary>"

#: libpq.xml:1412(para)
msgid ""
"Returns the database name of the connection. <synopsis>\n"
"char *PQdb(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает имя базы данных, с которой установлено соединение. <synopsis>\n"
"char *PQdb(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1423(function)
msgid "PQuser"
msgstr "PQuser"

#: libpq.xml:1424(indexterm)
msgid "<primary>PQuser</primary>"
msgstr "<primary>PQuser</primary>"

#: libpq.xml:1430(para)
msgid ""
"Returns the user name of the connection. <synopsis>\n"
"char *PQuser(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает имя пользователя, который установил соединение.<synopsis>\n"
"char *PQuser(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1441(function)
msgid "PQpass"
msgstr "PQpass"

#: libpq.xml:1442(indexterm)
msgid "<primary>PQpass</primary>"
msgstr "<primary>PQpass</primary>"

#: libpq.xml:1448(para)
msgid ""
"Returns the password of the connection. <synopsis>\n"
"char *PQpass(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает пароль, использованный для подключения.<synopsis>\n"
"char *PQpass(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1459(function)
msgid "PQhost"
msgstr "PQhost"

#: libpq.xml:1460(indexterm)
msgid "<primary>PQhost</primary>"
msgstr "<primary>PQhost</primary>"

#: libpq.xml:1466(para)
msgid ""
"Returns the server host name of the connection. This can be a host name, an "
"IP address, or a directory path if the connection is via Unix socket. (The "
"path case can be distinguished because it will always be an absolute path, "
"beginning with <literal>/</literal>.) <synopsis>\n"
"char *PQhost(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает имя сервера для текущего соединения. Это может быть имя "
"компьютера, IP-адрес или путь к каталогу, если подключение установлено через "
"сокет Unix. (Подключение к сокету можно распознать, потому что путь всегда "
"абсолютный и начинается с <literal>/</literal>.) <synopsis>\n"
"char *PQhost(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1481(function)
msgid "PQport"
msgstr "PQport"

#: libpq.xml:1482(indexterm)
msgid "<primary>PQport</primary>"
msgstr "<primary>PQport</primary>"

#: libpq.xml:1488(para)
msgid ""
"Returns the port of the connection. <synopsis>\n"
"char *PQport(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает номер порта, на котором установлено соединение.<synopsis>\n"
"char *PQport(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1500(function)
msgid "PQtty"
msgstr "PQtty"

#: libpq.xml:1501(indexterm)
msgid "<primary>PQtty</primary>"
msgstr "<primary>PQtty</primary>"

#: libpq.xml:1507(para)
msgid ""
"Returns the debug <acronym>TTY</acronym> of the connection. (This is "
"obsolete, since the server no longer pays attention to the <acronym>TTY</"
"acronym> setting, but the function remains for backward compatibility.) "
"<synopsis>\n"
"char *PQtty(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает имя отладочного терминала (<acronym>TTY</acronym>), связанного с "
"данным соединением. (Это устаревшая функция, поскольку сервер более не "
"обращает внимания на установку <acronym>TTY</acronym>, но она остаётся для "
"обеспечения обратной совместимости.) <synopsis>\n"
"char *PQtty(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1522(function)
msgid "PQoptions"
msgstr "PQoptions"

#: libpq.xml:1523(indexterm)
msgid "<primary>PQoptions</primary>"
msgstr "<primary>PQoptions</primary>"

#: libpq.xml:1529(para)
msgid ""
"Returns the command-line options passed in the connection request. "
"<synopsis>\n"
"char *PQoptions(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает параметры командной строки, переданные в запросе на подключение."
"<synopsis>\n"
"char *PQoptions(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1398(para)
msgid ""
"The following functions return parameter values established at connection. "
"These values are fixed for the life of the <structname>PGconn</structname> "
"object. <placeholder-1/>"
msgstr ""
"Следующие функции возвращают значения параметров, установленные при "
"подключении. Эти значения фиксированы на время жизни объекта "
"<structname>PGconn</structname>. <placeholder-1/>"

#: libpq.xml:1547(function)
msgid "PQstatus"
msgstr "PQstatus"

#: libpq.xml:1548(indexterm)
msgid "<primary>PQstatus</primary>"
msgstr "<primary>PQstatus</primary>"

#: libpq.xml:1554(para)
msgid ""
"Returns the status of the connection. <synopsis>\n"
"ConnStatusType PQstatus(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает состояние подключения.<synopsis>\n"
"ConnStatusType PQstatus(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1561(para)
msgid ""
"The status can be one of a number of values. However, only two of these are "
"seen outside of an asynchronous connection procedure: "
"<literal>CONNECTION_OK</literal> and <literal>CONNECTION_BAD</literal>. A "
"good connection to the database has the status <literal>CONNECTION_OK</"
"literal>. A failed connection attempt is signaled by status "
"<literal>CONNECTION_BAD</literal>. Ordinarily, an OK status will remain so "
"until <function>PQfinish</function>, but a communications failure might "
"result in the status changing to <literal>CONNECTION_BAD</literal> "
"prematurely. In that case the application could try to recover by calling "
"<function>PQreset</function>."
msgstr ""
"Статус может принимать одно из ряда значений. Однако, только два из них "
"видны извне процедуры асинхронного подключения: <literal>CONNECTION_OK</"
"literal> и <literal>CONNECTION_BAD</literal>. Успешное подключение к базе "
"данных имеет статус <literal>CONNECTION_OK</literal>. О неудачной попытке "
"подключения сигнализирует статус <literal>CONNECTION_BAD</literal>. Обычно "
"статус OK остаётся таковым до вызова <function>PQfinish</function>, но сбой "
"в коммуникации может привести к тому, что статус изменится на "
"<literal>CONNECTION_BAD</literal> преждевременно. В таком случае приложение "
"может попытаться восстановиться, вызвав <function>PQreset</function>."

#: libpq.xml:1576(para)
msgid ""
"See the entry for <function>PQconnectStartParams</function>, "
"<function>PQconnectStart</function> and <function>PQconnectPoll</function> "
"with regards to other status codes that might be returned."
msgstr ""
"См. статьи, посвященные <function>PQconnectStartParams</function>, "
"<function>PQconnectStart</function> и <function>PQconnectPoll</function>, "
"относительно других кодов статуса, которые могут быть возвращены этими "
"функциями."

#: libpq.xml:1586(function)
msgid "PQtransactionStatus"
msgstr "PQtransactionStatus"

#: libpq.xml:1587(indexterm)
msgid "<primary>PQtransactionStatus</primary>"
msgstr "<primary>PQtransactionStatus</primary>"

#: libpq.xml:1593(para)
msgid ""
"Returns the current in-transaction status of the server. <synopsis>\n"
"PGTransactionStatusType PQtransactionStatus(const PGconn *conn);\n"
"</synopsis> The status can be <literal>PQTRANS_IDLE</literal> (currently "
"idle), <literal>PQTRANS_ACTIVE</literal> (a command is in progress), "
"<literal>PQTRANS_INTRANS</literal> (idle, in a valid transaction block), or "
"<literal>PQTRANS_INERROR</literal> (idle, in a failed transaction block). "
"<literal>PQTRANS_UNKNOWN</literal> is reported if the connection is bad. "
"<literal>PQTRANS_ACTIVE</literal> is reported only when a query has been "
"sent to the server and not yet completed."
msgstr ""
"Возвращает текущий статус сервера, отражающий процесс выполнения транзакций. "
"<synopsis>\n"
"PGTransactionStatusType PQtransactionStatus(const PGconn *conn);\n"
"</synopsis> Статус может быть одним из <literal>PQTRANS_IDLE</literal> (в "
"настоящее время не занят обработкой транзакции), <literal>PQTRANS_ACTIVE</"
"literal> (команда в процессе обработки), <literal>PQTRANS_INTRANS</literal> "
"(не выполняет работу, но находится в рамках действительной транзакции) или "
"<literal>PQTRANS_INERROR</literal> (не выполняет работу, но находится в "
"рамках транзакции, завершившейся сбоем). Статус принимает значение "
"<literal>PQTRANS_UNKNOWN</literal>, если соединение не работает. Статус "
"принимает значение <literal>PQTRANS_ACTIVE</literal> только тогда, когда "
"запрос был отправлен серверу, но ещё не завершён."

#: libpq.xml:1613(function)
msgid "PQparameterStatus"
msgstr "PQparameterStatus"

#: libpq.xml:1614(indexterm)
msgid "<primary>PQparameterStatus</primary>"
msgstr "<primary>PQparameterStatus</primary>"

#: libpq.xml:1620(para)
msgid ""
"Looks up a current parameter setting of the server. <synopsis>\n"
"const char *PQparameterStatus(const PGconn *conn, const char *paramName);\n"
"</synopsis> Certain parameter values are reported by the server "
"automatically at connection startup or whenever their values change. "
"<function>PQparameterStatus</function> can be used to interrogate these "
"settings. It returns the current value of a parameter if known, or "
"<symbol>NULL</symbol> if the parameter is not known."
msgstr ""
"Отыскивает текущее значение параметра сервера. <synopsis>\n"
"const char *PQparameterStatus(const PGconn *conn, const char *paramName);\n"
"</synopsis> Значения определённых параметров сервер сообщает автоматически в "
"начале процедуры подключения или тогда, когда их значения изменяются. "
"<function>PQparameterStatus</function> можно использовать, чтобы запросить "
"эти значения. Функция возвращает текущее значение параметра, если оно "
"известно, или <symbol>NULL</symbol>, если параметр неизвестен."

#: libpq.xml:1634(para)
msgid ""
"Parameters reported as of the current release include "
"<varname>server_version</varname>, <varname>server_encoding</varname>, "
"<varname>client_encoding</varname>, <varname>application_name</varname>, "
"<varname>is_superuser</varname>, <varname>session_authorization</varname>, "
"<varname>DateStyle</varname>, <varname>IntervalStyle</varname>, "
"<varname>TimeZone</varname>, <varname>integer_datetimes</varname>, and "
"<varname>standard_conforming_strings</varname>. (<varname>server_encoding</"
"varname>, <varname>TimeZone</varname>, and <varname>integer_datetimes</"
"varname> were not reported by releases before 8.0; "
"<varname>standard_conforming_strings</varname> was not reported by releases "
"before 8.1; <varname>IntervalStyle</varname> was not reported by releases "
"before 8.4; <varname>application_name</varname> was not reported by releases "
"before 9.0.) Note that <varname>server_version</varname>, "
"<varname>server_encoding</varname> and <varname>integer_datetimes</varname> "
"cannot change after startup."
msgstr ""
"Параметры, значения которых сообщает сервер, в текущей версии включают "
"<varname>server_version</varname>, <varname>server_encoding</varname>, "
"<varname>client_encoding</varname>, <varname>application_name</varname>, "
"<varname>is_superuser</varname>, <varname>session_authorization</varname>, "
"<varname>DateStyle</varname>, <varname>IntervalStyle</varname>, "
"<varname>TimeZone</varname>, <varname>integer_datetimes</varname> и "
"<varname>standard_conforming_strings</varname>. (Значения параметров "
"<varname>server_encoding</varname>, <varname>TimeZone</varname> и "
"<varname>integer_datetimes</varname> сервер до версии 8.0 не сообщал; "
"<varname>standard_conforming_strings</varname> сервер до версии 8.1 не "
"сообщал; <varname>IntervalStyle</varname> сервер до версии 8.4 не сообщал; "
"<varname>application_name</varname> сервер до версии 9.0 не сообщал.) "
"Учтите, что <varname>server_version</varname>, <varname>server_encoding</"
"varname> и <varname>integer_datetimes</varname> нельзя изменить после "
"запуска."

#: libpq.xml:1660(para)
msgid ""
"Pre-3.0-protocol servers do not report parameter settings, but "
"<application>libpq</application> includes logic to obtain values for "
"<varname>server_version</varname> and <varname>client_encoding</varname> "
"anyway. Applications are encouraged to use <function>PQparameterStatus</"
"function> rather than <foreignphrase>ad hoc</foreignphrase> code to "
"determine these values. (Beware however that on a pre-3.0 connection, "
"changing <varname>client_encoding</varname> via <command>SET</command> after "
"connection startup will not be reflected by <function>PQparameterStatus</"
"function>.) For <varname>server_version</varname>, see also "
"<function>PQserverVersion</function>, which returns the information in a "
"numeric form that is much easier to compare against."
msgstr ""
"Серверы, поддерживающие протокол только до версии 3.0, не могут сообщать "
"установки параметров, но <application>libpq</application> включает средства, "
"чтобы получить значения для <varname>server_version</varname> и "
"<varname>client_encoding</varname> в любом случае. Поощряется использование "
"в приложениях <function>PQparameterStatus</function>, а не специально "
"написанного (<foreignphrase>ad hoc</foreignphrase>) кода, для определения "
"этих значений. (Примите к сведению, однако, что в соединениях, основанных на "
"протоколе версии до 3.0, изменение <varname>client_encoding</varname> "
"посредством команды <command>SET</command> после начала процедуры "
"подключения не будет отражаться функцией <function>PQparameterStatus</"
"function>.) Сведения о <varname>server_version</varname> приведены также в "
"описании функции <function>PQserverVersion</function>, возвращающей "
"информацию в числовой форме, в которой гораздо легче выполнять сравнение."

#: libpq.xml:1674(para)
msgid ""
"If no value for <varname>standard_conforming_strings</varname> is reported, "
"applications can assume it is <literal>off</literal>, that is, backslashes "
"are treated as escapes in string literals. Also, the presence of this "
"parameter can be taken as an indication that the escape string syntax "
"(<literal>E'...'</literal>) is accepted."
msgstr ""
"Если для <varname>standard_conforming_strings</varname> не передано никакого "
"значения, то приложения могут принять его равным <literal>off</literal>. Это "
"означает, что символы обратной косой черты в строковых литералах "
"интерпретируются в качестве спецсимволов. Также, наличие этого параметра "
"может рассматриваться как указание на то, что синтаксис escape-строк "
"(<literal>E'...'</literal>) является приемлемым."

#: libpq.xml:1682(para)
msgid ""
"Although the returned pointer is declared <literal>const</literal>, it in "
"fact points to mutable storage associated with the <literal>PGconn</literal> "
"structure. It is unwise to assume the pointer will remain valid across "
"queries."
msgstr ""
"Хотя возвращаемый указатель объявлен со спецификатором <literal>const</"
"literal>, фактически он указывает на изменяемое хранилище, связанное со "
"структурой <literal>PGconn</literal>. Не стоит рассчитывать на то, что "
"указатель останется действительным при последующих запросах."

#: libpq.xml:1692(function)
msgid "PQprotocolVersion"
msgstr "PQprotocolVersion"

#: libpq.xml:1693(indexterm)
msgid "<primary>PQprotocolVersion</primary>"
msgstr "<primary>PQprotocolVersion</primary>"

#: libpq.xml:1699(para)
msgid ""
"Interrogates the frontend/backend protocol being used. <synopsis>\n"
"int PQprotocolVersion(const PGconn *conn);\n"
"</synopsis> Applications might wish to use this function to determine "
"whether certain features are supported. Currently, the possible values are 2 "
"(2.0 protocol), 3 (3.0 protocol), or zero (connection bad). The protocol "
"version will not change after connection startup is complete, but it could "
"theoretically change during a connection reset. The 3.0 protocol will "
"normally be used when communicating with <productname>PostgreSQL</"
"productname> 7.4 or later servers; pre-7.4 servers support only protocol "
"2.0. (Protocol 1.0 is obsolete and not supported by <application>libpq</"
"application>.)"
msgstr ""
"Запрашивает протокол, используемый между клиентом и сервером. <synopsis>\n"
"int PQprotocolVersion(const PGconn *conn);\n"
"</synopsis> Приложения могут использовать эту функцию, чтобы определить, "
"поддерживаются ли опредёленные функциональные возможности. В настоящее время "
"возможными значениями являются 2 (протокол версии 2.0), 3 (протокол версии "
"3.0) или ноль (проблемы в подключении). Версия протокола не будет изменяться "
"после завершения процедуры подключения, но теоретически она могла бы "
"измениться в процессе переподключения. Версия протокола 3.0 обычно "
"используется при взаимодействии с серверами <productname>PostgreSQL</"
"productname> версии 7.4 или более поздними; серверы до версии 7.4 "
"поддерживают только протокол версии 2.0. (Протокол версии 1.0 является "
"устаревшим и не поддерживается библиотекой <application>libpq</application>.)"

#: libpq.xml:1720(function)
msgid "PQserverVersion"
msgstr "PQserverVersion"

#: libpq.xml:1721(indexterm)
msgid "<primary>PQserverVersion</primary>"
msgstr "<primary>PQserverVersion</primary>"

#: libpq.xml:1727(para)
msgid ""
"Returns an integer representing the backend version. <synopsis>\n"
"int PQserverVersion(const PGconn *conn);\n"
"</synopsis> Applications might use this function to determine the version of "
"the database server they are connected to. The number is formed by "
"converting the major, minor, and revision numbers into two-decimal-digit "
"numbers and appending them together. For example, version 8.1.5 will be "
"returned as 80105, and version 8.2 will be returned as 80200 (leading zeroes "
"are not shown). Zero is returned if the connection is bad."
msgstr ""
"Возвращает целое число, представляющее версию сервера. <synopsis>\n"
"int PQserverVersion(const PGconn *conn);\n"
"</synopsis> Приложения могут использовать эту функцию, чтобы определить "
"версию сервера баз данных, к которому они подключены. Число формируется "
"путём преобразования номеров старшей, младшей и корректирующей версий в "
"двузначные десятичные числа и соединения их вместе. Например, для версии "
"8.1.5 будет возвращено число 80105, а для версии 8.2 будет возвращено число "
"80200 (ведущие нули не показаны). Если соединение не работает, то "
"возвращается ноль."

#: libpq.xml:1745(function)
msgid "PQerrorMessage"
msgstr "PQerrorMessage"

#: libpq.xml:1746(indexterm)
msgid "<primary>PQerrorMessage</primary>"
msgstr "<primary>PQerrorMessage</primary>"

#: libpq.xml:1753(indexterm)
msgid "<primary>error message</primary>"
msgstr "<primary>сообщение об ошибке</primary>"

#: libpq.xml:1752(para)
msgid ""
"<placeholder-1/> Returns the error message most recently generated by an "
"operation on the connection. <synopsis>\n"
"char *PQerrorMessage(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"<placeholder-1/> Возвращает сообщение об ошибке, наиболее недавно "
"сгенерированное операцией, выполненной в рамках текущего подключения. "
"<synopsis>\n"
"char *PQerrorMessage(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1762(para)
msgid ""
"Nearly all <application>libpq</application> functions will set a message for "
"<function>PQerrorMessage</function> if they fail. Note that by "
"<application>libpq</application> convention, a nonempty "
"<function>PQerrorMessage</function> result can consist of multiple lines, "
"and will include a trailing newline. The caller should not free the result "
"directly. It will be freed when the associated <structname>PGconn</"
"structname> handle is passed to <function>PQfinish</function>. The result "
"string should not be expected to remain the same across operations on the "
"<literal>PGconn</literal> structure."
msgstr ""
"Почти все функции библиотеки <application>libpq</application> в случае сбоя "
"сформируют сообщение для <function>PQerrorMessage</function>. Обратите "
"внимание, что по соглашениям, принятым в <application>libpq</application>, "
"непустой результат функции <function>PQerrorMessage</function> может "
"состоять из нескольких строк и будет включать завершающий символ новой "
"строки. Вызывающая функция не должна освобождать память, на которую "
"указывает возвращаемое значение, напрямую. Она будет освобождена, когда "
"связанный с ней дескриптор <structname>PGconn</structname> будет передан "
"функции <function>PQfinish</function>. Не стоит ожидать, что результирующая "
"строка останется той же самой при выполнении нескольких операций со "
"структурой <literal>PGconn</literal>."

#: libpq.xml:1778(function)
msgid "PQsocket"
msgstr "PQsocket"

#: libpq.xml:1778(indexterm)
msgid "<primary>PQsocket</primary>"
msgstr "<primary>PQsocket</primary>"

#: libpq.xml:1780(para)
msgid ""
"Obtains the file descriptor number of the connection socket to the server. A "
"valid descriptor will be greater than or equal to 0; a result of -1 "
"indicates that no server connection is currently open. (This will not change "
"during normal operation, but could change during connection setup or reset.) "
"<synopsis>\n"
"int PQsocket(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Получает номер файлового дескриптора для сокета соединения с сервером. "
"Действительный дескриптор будет больше или равен 0; значение -1 показывает, "
"что в данный момент не открыто ни одного соединения с сервером. (Значение не "
"изменится во время обычной работы, но может измениться во время установки "
"или переустановки подключения.) <synopsis>\n"
"int PQsocket(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1796(function)
msgid "PQbackendPID"
msgstr "PQbackendPID"

#: libpq.xml:1796(indexterm)
msgid "<primary>PQbackendPID</primary>"
msgstr "<primary>PQbackendPID</primary>"

#: libpq.xml:1799(indexterm)
msgid ""
"<primary>PID</primary> <secondary>determining PID of server process</"
"secondary> <tertiary>in libpq</tertiary>"
msgstr ""
"<primary>PID</primary> <secondary>определение PID серверного процесса</"
"secondary> <tertiary>в libpq</tertiary>"

#: libpq.xml:1798(para)
msgid ""
"Returns the process <acronym>ID</acronym> (PID)<placeholder-1/> of the "
"backend process handling this connection. <synopsis>\n"
"int PQbackendPID(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает <acronym>ID</acronym> (PID)<placeholder-1/> серверного процесса, "
"обрабатывающего это подключение. <synopsis>\n"
"int PQbackendPID(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1811(para)
msgid ""
"The backend <acronym>PID</acronym> is useful for debugging purposes and for "
"comparison to <command>NOTIFY</command> messages (which include the "
"<acronym>PID</acronym> of the notifying backend process). Note that the "
"<acronym>PID</acronym> belongs to a process executing on the database server "
"host, not the local host!"
msgstr ""
"<acronym>PID</acronym> серверного процесса полезен для отладочных целей и "
"для сопоставления с сообщениями команды <command>NOTIFY</command> (которые "
"включают <acronym>PID</acronym> уведомляющего серверного процесса). Примите "
"к сведению, что <acronym>PID</acronym> принадлежит процессу, выполняющемуся "
"на компьютере сервера баз данных, а не на локальном компьютере."

#: libpq.xml:1823(function)
msgid "PQconnectionNeedsPassword"
msgstr "PQconnectionNeedsPassword"

#: libpq.xml:1823(indexterm)
msgid "<primary>PQconnectionNeedsPassword</primary>"
msgstr "<primary>PQconnectionNeedsPassword</primary>"

#: libpq.xml:1825(para)
msgid ""
"Returns true (1) if the connection authentication method required a "
"password, but none was available. Returns false (0) if not. <synopsis>\n"
"int PQconnectionNeedsPassword(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает true (1), если метод аутентификации соединения требовал пароля, "
"однако он не был предоставлен. Возвращает false (0), если пароль не "
"требовался. <synopsis>\n"
"int PQconnectionNeedsPassword(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1835(para)
msgid ""
"This function can be applied after a failed connection attempt to decide "
"whether to prompt the user for a password."
msgstr ""
"Эту функцию можно применить после неудачной попытки подключения, чтобы "
"решить, нужно ли предлагать пользователю ввести пароль."

#: libpq.xml:1843(function)
msgid "PQconnectionUsedPassword"
msgstr "PQconnectionUsedPassword"

#: libpq.xml:1843(indexterm)
msgid "<primary>PQconnectionUsedPassword</primary>"
msgstr "<primary>PQconnectionUsedPassword</primary>"

#: libpq.xml:1845(para)
msgid ""
"Returns true (1) if the connection authentication method used a password. "
"Returns false (0) if not. <synopsis>\n"
"int PQconnectionUsedPassword(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает true (1), если метод аутентификации соединения использовал "
"пароль. Возвращает false (0) в противном случае. <synopsis>\n"
"int PQconnectionUsedPassword(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1854(para)
msgid ""
"This function can be applied after either a failed or successful connection "
"attempt to detect whether the server demanded a password."
msgstr ""
"Эту функцию можно применить как после неудачной, так и после успешной "
"попытки подключения, чтобы определить, требовал ли сервер предоставления "
"пароля."

#: libpq.xml:1540(para)
msgid ""
"The following functions return status data that can change as operations are "
"executed on the <structname>PGconn</structname> object. <placeholder-1/>"
msgstr ""
"Следующие функции возвращают данные статуса, который может измениться в "
"процессе выполнения операций на объекте <structname>PGconn</structname>. "
"<placeholder-1/>"

#: libpq.xml:1869(function)
msgid "PQsslInUse"
msgstr "PQsslInUse"

#: libpq.xml:1869(indexterm)
msgid "<primary>PQsslInUse</primary>"
msgstr "<primary>PQsslInUse</primary>"

#: libpq.xml:1871(para)
msgid ""
"Returns true (1) if the connection uses SSL, false (0) if not. <synopsis>\n"
"int PQsslInUse(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает true (1), если для текущего подключения используется SSL, и false "
"(0) в противном случае. <synopsis>\n"
"int PQsslInUse(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1883(function)
msgid "PQsslAttribute"
msgstr "PQsslAttribute"

#: libpq.xml:1883(indexterm)
msgid "<primary>PQsslAttribute</primary>"
msgstr "<primary>PQsslAttribute</primary>"

#: libpq.xml:1885(para)
msgid ""
"Returns SSL-related information about the connection. <synopsis>\n"
"const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);\n"
"</synopsis>"
msgstr ""
"Возвращает связанную с SSL информацию о соединении. <synopsis>\n"
"const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);\n"
"</synopsis>"

#: libpq.xml:1893(para)
msgid ""
"The list of available attributes varies depending on the SSL library being "
"used, and the type of connection. If an attribute is not available, returns "
"NULL."
msgstr ""
"Список доступных атрибутов зависит от применяемой библиотеки SSL и типа "
"подключения. Если атрибут недоступен, возвращается NULL."

#: libpq.xml:1903(literal)
msgid "library"
msgstr "library"

#: libpq.xml:1905(para)
msgid ""
"Name of the SSL implementation in use. (Currently, only <literal>\"OpenSSL"
"\"</literal> is implemented)"
msgstr ""
"Имя используемой реализации SSL. (В настоящее время поддерживается только "
"<literal>\"OpenSSL\"</literal>)"

#: libpq.xml:1912(literal)
msgid "protocol"
msgstr "protocol"

#: libpq.xml:1914(para)
msgid ""
"SSL/TLS version in use. Common values are <literal>\"SSLv2\"</literal>, "
"<literal>\"SSLv3\"</literal>, <literal>\"TLSv1\"</literal>, <literal>"
"\"TLSv1.1\"</literal> and <literal>\"TLSv1.2\"</literal>, but an "
"implementation may return other strings if some other protocol is used."
msgstr ""
"Применяемая версия SSL/TLS. Наиболее распространены варианты <literal>"
"\"SSLv2\"</literal>, <literal>\"SSLv3\"</literal>, <literal>\"TLSv1\"</"
"literal>, <literal>\"TLSv1.1\"</literal> и <literal>\"TLSv1.2\"</literal>, "
"но реализация может возвращать и другие строки, если применяется какой-то "
"другой протокол."

#: libpq.xml:1924(literal)
msgid "key_bits"
msgstr "key_bits"

#: libpq.xml:1926(para)
msgid "Number of key bits used by the encryption algorithm."
msgstr "Число бит в ключе, используемом алгоритмом шифрования."

#: libpq.xml:1932(literal)
msgid "cipher"
msgstr "cipher"

#: libpq.xml:1934(para)
msgid ""
"A short name of the ciphersuite used, e.g. <literal>\"DHE-RSA-DES-CBC3-SHA"
"\"</literal>. The names are specific to each SSL implementation."
msgstr ""
"Краткое имя применяемого комплекта шифров, например: <literal>\"DHE-RSA-DES-"
"CBC3-SHA\"</literal>. Эти имена могут быть разными в разных реализациях SSL."

#: libpq.xml:1942(literal)
msgid "compression"
msgstr "compression"

#: libpq.xml:1944(para)
msgid ""
"If SSL compression is in use, returns the name of the compression algorithm, "
"or \"on\" if compression is used but the algorithm is not known. If "
"compression is not in use, returns \"off\"."
msgstr ""
"Если применяется сжатие SSL, возвращает имя алгоритма сжатия, либо \"on\", "
"если сжатие используется, но его алгоритм неизвестен. Если сжатие не "
"применяется, возвращает \"off\"."

#: libpq.xml:1899(para)
msgid "The following attributes are commonly available: <placeholder-1/>"
msgstr "Обычно доступны следующие атрибуты: <placeholder-1/>"

#: libpq.xml:1957(function)
msgid "PQsslAttributeNames"
msgstr "PQsslAttributeNames"

#: libpq.xml:1957(indexterm)
msgid "<primary>PQsslAttributeNames</primary>"
msgstr "<primary>PQsslAttributeNames</primary>"

#: libpq.xml:1959(para)
msgid ""
"Return an array of SSL attribute names available. The array is terminated by "
"a NULL pointer. <synopsis>\n"
"const char * const * PQsslAttributeNames(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает массив имён доступных атрибутов SSL. Завершается массив "
"указателем NULL. <synopsis>\n"
"const char * const * PQsslAttributeNames(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:1969(function)
msgid "PQsslStruct"
msgstr "PQsslStruct"

#: libpq.xml:1969(indexterm)
msgid "<primary>PQsslStruct</primary>"
msgstr "<primary>PQsslStruct</primary>"

#: libpq.xml:1971(para)
msgid ""
"Return a pointer to an SSL-implementation-specific object describing the "
"connection. <synopsis>\n"
"void *PQsslStruct(const PGconn *conn, const char *struct_name);\n"
"</synopsis>"
msgstr ""
"Возвращает указатель на специфичный для реализации SSL объект, описывающий "
"подключение. <synopsis>\n"
"void *PQsslStruct(const PGconn *conn, const char *struct_name);\n"
"</synopsis>"

#: libpq.xml:1978(para)
msgid ""
"The struct(s) available depend on the SSL implementation in use. For "
"OpenSSL, there is one struct, available under the name \"OpenSSL\", and it "
"returns a pointer to the OpenSSL <literal>SSL</literal> struct. To use this "
"function, code along the following lines could be used: <placeholder-1/>"
msgstr ""
"Доступная структура (или структуры) зависит от того, какая реализация SSL "
"применяется. Для OpenSSL выдаётся одна структура под именем \"OpenSSL\", и "
"эта структура, на которую указывает возвращённый указатель, имеет тип "
"<literal>SSL</literal> (определённый в OpenSSL). Для обращения к этой "
"функции можно воспользоваться кодом в следующих строках: <placeholder-1/>"

#: libpq.xml:2001(para)
msgid ""
"This structure can be used to verify encryption levels, check server "
"certificates, and more. Refer to the <productname>OpenSSL</productname> "
"documentation for information about this structure."
msgstr ""
"Эта структура может использоваться, чтобы сличить уровни шифрования, "
"проверить сертификаты сервера и т. д. За информацией об этой структуре "
"обратитесь к документации по <productname>OpenSSL</productname>."

#: libpq.xml:2010(function)
msgid "PQgetssl"
msgstr "PQgetssl"

#: libpq.xml:2010(indexterm)
msgid "<primary>PQgetssl</primary>"
msgstr "<primary>PQgetssl</primary>"

#: libpq.xml:2013(indexterm)
msgid "<primary>SSL</primary><secondary sortas=\"libpq\">in libpq</secondary>"
msgstr "<primary>SSL</primary> <secondary sortas=\"libpq\">в libpq</secondary>"

#: libpq.xml:2012(para)
msgid ""
"<placeholder-1/> Returns the SSL structure used in the connection, or null "
"if SSL is not in use. <synopsis>\n"
"void *PQgetssl(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"<placeholder-1/> Возвращает структуру SSL, использовавшуюся в соединении, "
"или null, если SSL не используется. <synopsis>\n"
"void *PQgetssl(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:2022(para)
msgid ""
"This function is equivalent to <literal>PQsslStruct(conn, \"OpenSSL\")</"
"literal>. It should not be used in new applications, because the returned "
"struct is specific to OpenSSL and will not be available if another SSL "
"implementation is used. To check if a connection uses SSL, call "
"<function>PQsslInUse</function> instead, and for more details about the "
"connection, use <function>PQsslAttribute</function>."
msgstr ""
"Эта функция равнозначна <literal>PQsslStruct(conn, \"OpenSSL\")</literal>. "
"Её не следует применять в новых приложениях, так как возвращаемая структура "
"специфична для OpenSSL и её нельзя будет получить с другой реализацией SSL. "
"Чтобы проверить, использует ли подключение SSL, лучше вызвать "
"<function>PQsslInUse</function>, а чтобы получить свойства подключения — "
"<function>PQsslAttribute</function>."

#: libpq.xml:1863(para)
msgid ""
"The following functions return information related to SSL. This information "
"usually doesn't change after a connection is established. <placeholder-1/>"
msgstr ""
"Следующие функции возвращают информацию, относящуюся к SSL. Эта информация "
"обычно не меняется после того, как подключение установлено. <placeholder-1/>"

#: libpq.xml:2039(title)
msgid "Command Execution Functions"
msgstr "Функции для исполнения команд"

#: libpq.xml:2041(para)
msgid ""
"Once a connection to a database server has been successfully established, "
"the functions described here are used to perform SQL queries and commands."
msgstr ""
"После того как соединение с сервером было успешно установлено, функции, "
"описанные в этом разделе, используются для выполнения SQL-запросов и команд."

#: libpq.xml:2048(title)
msgid "Main Functions"
msgstr "Главные функции"

#: libpq.xml:2054(function)
msgid "PQexec"
msgstr "PQexec"

#: libpq.xml:2055(indexterm)
msgid "<primary>PQexec</primary>"
msgstr "<primary>PQexec</primary>"

#: libpq.xml:2061(para)
msgid ""
"Submits a command to the server and waits for the result. <synopsis>\n"
"PGresult *PQexec(PGconn *conn, const char *command);\n"
"</synopsis>"
msgstr ""
"Передаёт команду серверу и ожидает результата. <synopsis>\n"
"PGresult *PQexec(PGconn *conn, const char *command);\n"
"</synopsis>"

#: libpq.xml:2069(para)
msgid ""
"Returns a <structname>PGresult</structname> pointer or possibly a null "
"pointer. A non-null pointer will generally be returned except in out-of-"
"memory conditions or serious errors such as inability to send the command to "
"the server. The <function>PQresultStatus</function> function should be "
"called to check the return value for any errors (including the value of a "
"null pointer, in which case it will return <symbol>PGRES_FATAL_ERROR</"
"symbol>). Use <function>PQerrorMessage</function> to get more information "
"about such errors."
msgstr ""
"Возвращает указатель на <structname>PGresult</structname> или, возможно, "
"пустой указатель (null). Как правило, возвращается непустой указатель, "
"исключением являются ситуации нехватки памяти или серьёзные ошибки, такие, "
"как невозможность отправки команды серверу. Для проверки возвращаемого "
"значения на наличие ошибок следует вызывать функцию "
"<function>PQresultStatus</function> (в случае нулевого указателя она "
"возвратит <symbol>PGRES_FATAL_ERROR</symbol>). Для получения дополнительной "
"информации о таких ошибках используйте функцию <function>PQerrorMessage</"
"function>."

#: libpq.xml:2050(para)
msgid ""
"<placeholder-1/> The command string can include multiple SQL commands "
"(separated by semicolons). Multiple queries sent in a single "
"<function>PQexec</function> call are processed in a single transaction, "
"unless there are explicit <command>BEGIN</command>/<command>COMMIT</command> "
"commands included in the query string to divide it into multiple "
"transactions. Note however that the returned <structname>PGresult</"
"structname> structure describes only the result of the last command executed "
"from the string. Should one of the commands fail, processing of the string "
"stops with it and the returned <structname>PGresult</structname> describes "
"the error condition."
msgstr ""
"<placeholder-1/> Строка команды может включать в себя более одной SQL-"
"команды (которые разделяются точкой с запятой). Несколько запросов, "
"отправленных с помощью одного вызова <function>PQexec</function>, "
"обрабатываются в рамках одной транзакции, если только команды "
"<command>BEGIN</command>/<command>COMMIT</command> не включены явно в строку "
"запроса, чтобы разделить его на несколько транзакций. Обратите внимание, "
"однако, что возвращаемая структура <structname>PGresult</structname> "
"описывает только результат последней из выполненных команд, содержащихся в "
"строке запроса. Если одна из команд завершается сбоем, то обработка строки "
"запроса на этом останавливается, и возвращённая структура "
"<structname>PGresult</structname> описывает состояние ошибки."

#: libpq.xml:2100(function)
msgid "PQexecParams"
msgstr "PQexecParams"

#: libpq.xml:2101(indexterm)
msgid "<primary>PQexecParams</primary>"
msgstr "<primary>PQexecParams</primary>"

#: libpq.xml:2107(para)
msgid ""
"Submits a command to the server and waits for the result, with the ability "
"to pass parameters separately from the SQL command text. <synopsis>\n"
"PGresult *PQexecParams(PGconn *conn,\n"
"                       const char *command,\n"
"                       int nParams,\n"
"                       const Oid *paramTypes,\n"
"                       const char * const *paramValues,\n"
"                       const int *paramLengths,\n"
"                       const int *paramFormats,\n"
"                       int resultFormat);\n"
"</synopsis>"
msgstr ""
"Отправляет команду серверу и ожидает результата. Имеет возможность передать "
"параметры отдельно от текста SQL-команды. <synopsis>\n"
"PGresult *PQexecParams(PGconn *conn,\n"
"                       const char *command,\n"
"                       int nParams,\n"
"                       const Oid *paramTypes,\n"
"                       const char * const *paramValues,\n"
"                       const int *paramLengths,\n"
"                       const int *paramFormats,\n"
"                       int resultFormat);\n"
"</synopsis>"

#: libpq.xml:2124(para)
msgid ""
"<function>PQexecParams</function> is like <function>PQexec</function>, but "
"offers additional functionality: parameter values can be specified "
"separately from the command string proper, and query results can be "
"requested in either text or binary format. <function>PQexecParams</function> "
"is supported only in protocol 3.0 and later connections; it will fail when "
"using protocol 2.0."
msgstr ""
"<function>PQexecParams</function> подобна <function>PQexec</function>, но "
"предлагает дополнительную функциональность: значения параметров могут быть "
"указаны отдельно от самой строки-команды, а результаты запроса могут быть "
"затребованы либо в текстовом, либо в двоичном формате. "
"<function>PQexecParams</function> поддерживается только при подключениях по "
"протоколу версии 3.0 или более поздних версий. Её вызов завершится сбоем при "
"использовании протокола версии 2.0."

#: libpq.xml:2137(parameter)
msgid "conn"
msgstr "conn"

#: libpq.xml:2140(para)
msgid "The connection object to send the command through."
msgstr "Объект, описывающий подключение, через которое пересылается команда."

#: libpq.xml:2147(parameter)
msgid "command"
msgstr "command"

#: libpq.xml:2149(para)
msgid ""
"The SQL command string to be executed. If parameters are used, they are "
"referred to in the command string as <literal>$1</literal>, <literal>$2</"
"literal>, etc."
msgstr ""
"Строка SQL-команды, которая должна быть выполнена. Если используются "
"параметры, то в строке команды на них ссылаются, как <literal>$1</literal>, "
"<literal>$2</literal> и т. д."

#: libpq.xml:2158(parameter)
msgid "nParams"
msgstr "nParams"

#: libpq.xml:2160(para)
msgid ""
"The number of parameters supplied; it is the length of the arrays "
"<parameter>paramTypes[]</parameter>, <parameter>paramValues[]</parameter>, "
"<parameter>paramLengths[]</parameter>, and <parameter>paramFormats[]</"
"parameter>. (The array pointers can be <symbol>NULL</symbol> when "
"<parameter>nParams</parameter> is zero.)"
msgstr ""
"Число предоставляемых параметров. Оно равно длине массивов "
"<parameter>paramTypes[]</parameter>, <parameter>paramValues[]</parameter>, "
"<parameter>paramLengths[]</parameter> и <parameter>paramFormats[]</"
"parameter>. (Указатели на массивы могут быть равны <symbol>NULL</symbol>, "
"когда <parameter>nParams</parameter> равно нулю.)"

#: libpq.xml:2171(parameter)
msgid "paramTypes[]"
msgstr "paramTypes[]"

#: libpq.xml:2173(para)
msgid ""
"Specifies, by OID, the data types to be assigned to the parameter symbols. "
"If <parameter>paramTypes</parameter> is <symbol>NULL</symbol>, or any "
"particular element in the array is zero, the server infers a data type for "
"the parameter symbol in the same way it would do for an untyped literal "
"string."
msgstr ""
"Предписывает, посредством OID, типы данных, которые должны быть назначены "
"параметрам. Если значение <parameter>paramTypes </parameter> равно "
"<symbol>NULL</symbol> или какой-либо отдельный элемент в массиве равен нулю, "
"тогда сервер самостоятельно определит тип данных для параметра точно таким "
"же образом, как он сделал бы для литеральной строки, тип которой не указан."

#: libpq.xml:2184(parameter)
msgid "paramValues[]"
msgstr "paramValues[]"

#: libpq.xml:2186(para)
msgid ""
"Specifies the actual values of the parameters. A null pointer in this array "
"means the corresponding parameter is null; otherwise the pointer points to a "
"zero-terminated text string (for text format) or binary data in the format "
"expected by the server (for binary format)."
msgstr ""
"Указывает фактические значения параметров. Нулевой указатель в этом массиве "
"означает, что соответствующий параметр равен null; в противном случае "
"указатель указывает на текстовую строку, завершающуюся нулевым символом (для "
"текстового формата), или на двоичные данные в формате, которого ожидает "
"сервер (для двоичного формата)."

#: libpq.xml:2197(parameter)
msgid "paramLengths[]"
msgstr "paramLengths[]"

#: libpq.xml:2199(para)
msgid ""
"Specifies the actual data lengths of binary-format parameters. It is ignored "
"for null parameters and text-format parameters. The array pointer can be "
"null when there are no binary parameters."
msgstr ""
"Указывает фактические длины данных для параметров, представленных в двоичном "
"формате. Он игнорируется для параметров, имеющих значение null, и для "
"параметров, представленных в текстовом формате. Указатель на массив может "
"быть нулевым, когда нет двоичных параметров."

#: libpq.xml:2208(parameter)
msgid "paramFormats[]"
msgstr "paramFormats[]"

#: libpq.xml:2210(para)
msgid ""
"Specifies whether parameters are text (put a zero in the array entry for the "
"corresponding parameter) or binary (put a one in the array entry for the "
"corresponding parameter). If the array pointer is null then all parameters "
"are presumed to be text strings."
msgstr ""
"Указывает, являются ли параметры текстовыми (поместите нуль в элемент "
"массива, соответствующий такому параметру) или двоичными (поместите единицу "
"в элемент массива, соответствующий такому параметру). Если указатель на "
"массив является нулевым, тогда все параметры считаются текстовыми строками."

#: libpq.xml:2217(para)
msgid ""
"Values passed in binary format require knowledge of the internal "
"representation expected by the backend. For example, integers must be passed "
"in network byte order. Passing <type>numeric</type> values requires "
"knowledge of the server storage format, as implemented in <filename>src/"
"backend/utils/adt/numeric.c::numeric_send()</filename> and <filename>src/"
"backend/utils/adt/numeric.c::numeric_recv()</filename>."
msgstr ""
"Значения, переданные в двоичном формате, требуют знания внутреннего "
"представления, которого ожидает сервер. Например, целые числа должны "
"передаваться с использованием сетевого порядка байтов. Передача значений "
"типа <type>numeric</type> требует знания того формата, в котором их хранит "
"сервер, как это реализовано в <filename>src/backend/utils/adt/numeric.c::"
"numeric_send()</filename> и <filename>src/backend/utils/adt/numeric.c::"
"numeric_recv()</filename>."

#: libpq.xml:2231(parameter)
msgid "resultFormat"
msgstr "resultFormat"

#: libpq.xml:2233(para)
msgid ""
"Specify zero to obtain results in text format, or one to obtain results in "
"binary format. (There is not currently a provision to obtain different "
"result columns in different formats, although that is possible in the "
"underlying protocol.)"
msgstr ""
"Требует указать ноль, чтобы получить результаты в текстовом формате, или "
"единицу, чтобы получить результаты в двоичном формате. (В настоящее время "
"нет возможности получить различные столбцы результата в разных форматах, "
"хотя это и возможно на уровне протокола, лежащего в основе подключений.)"

#: libpq.xml:2132(para)
msgid "The function arguments are: <placeholder-1/>"
msgstr "Параметры функции следующие: <placeholder-1/>"

#: libpq.xml:2248(para)
msgid ""
"The primary advantage of <function>PQexecParams</function> over "
"<function>PQexec</function> is that parameter values can be separated from "
"the command string, thus avoiding the need for tedious and error-prone "
"quoting and escaping."
msgstr ""
"Важнейшим преимуществом <function>PQexecParams</function> над "
"<function>PQexec</function> является то, что значения параметров могут быть "
"отделены от строки-команды. Это позволяет избежать использования кавычек и "
"экранирующих символов, что является трудоёмким методом, часто приводящим к "
"ошибкам."

#: libpq.xml:2255(para)
msgid ""
"Unlike <function>PQexec</function>, <function>PQexecParams</function> allows "
"at most one SQL command in the given string. (There can be semicolons in it, "
"but not more than one nonempty command.) This is a limitation of the "
"underlying protocol, but has some usefulness as an extra defense against SQL-"
"injection attacks."
msgstr ""
"В отличие от <function>PQexec</function>, <function>PQexecParams</function> "
"позволяет включать не более одной SQL-команды в строку запроса. (В ней могут "
"содержаться точки с запятой, однако может присутствовать не более одной "
"непустой команды.) Это ограничение накладывается базовым протоколом, но оно "
"приносит и некоторую пользу в качестве дополнительной защиты от атак методом "
"SQL-инъекций."

#: libpq.xml:2271(programlisting)
#, no-wrap
msgid "SELECT * FROM mytable WHERE x = $1::bigint;"
msgstr "SELECT * FROM mytable WHERE x = $1::bigint;"

#: libpq.xml:2264(para)
msgid ""
"Specifying parameter types via OIDs is tedious, particularly if you prefer "
"not to hard-wire particular OID values into your program. However, you can "
"avoid doing so even in cases where the server by itself cannot determine the "
"type of the parameter, or chooses a different type than you want. In the SQL "
"command text, attach an explicit cast to the parameter symbol to show what "
"data type you will send. For example: <placeholder-1/> This forces parameter "
"<literal>$1</literal> to be treated as <type>bigint</type>, whereas by "
"default it would be assigned the same type as <literal>x</literal>. Forcing "
"the parameter type decision, either this way or by specifying a numeric type "
"OID, is strongly recommended when sending parameter values in binary format, "
"because binary format has less redundancy than text format and so there is "
"less chance that the server will detect a type mismatch mistake for you."
msgstr ""
"Указание типов параметров с помощью OID является трудоёмким, особенно если "
"вы предпочитаете не указывать явно значений OID в вашей программе. Однако, "
"вы можете избежать этого даже в случаях, когда сервер самостоятельно не "
"может определить тип параметра или выбирает не тот тип, который вы хотите. В "
"строке SQL-команды добавьте явное приведение типа для этого параметра, чтобы "
"показать, какой тип данных вы будете отправлять. Например: <placeholder-1/> "
"Это приведёт к тому, что параметр <literal>$1</literal> будет считаться "
"имеющим тип <type>bigint</type>, в то время как по умолчанию ему был бы "
"назначен тот же самый тип, что и <literal>x</literal>. Такое явное принятие "
"решения о типе параметра либо с помощью описанного метода, либо путём "
"задания числового OID строго рекомендуется, когда значения параметров "
"отправляются в двоичном формате, поскольку двоичный формат имеет меньшую "
"избыточность, чем текстовый, и поэтому гораздо менее вероятно, что сервер "
"обнаружит ошибку несоответствия типов, допущенную вами."

#: libpq.xml:2286(function)
msgid "PQprepare"
msgstr "PQprepare"

#: libpq.xml:2287(indexterm)
msgid "<primary>PQprepare</primary>"
msgstr "<primary>PQprepare</primary>"

#: libpq.xml:2293(para)
msgid ""
"Submits a request to create a prepared statement with the given parameters, "
"and waits for completion. <synopsis>\n"
"PGresult *PQprepare(PGconn *conn,\n"
"                    const char *stmtName,\n"
"                    const char *query,\n"
"                    int nParams,\n"
"                    const Oid *paramTypes);\n"
"</synopsis>"
msgstr ""
"Отправляет запрос, чтобы создать подготовленный оператор с конкретными "
"параметрами, и ожидает завершения. <synopsis>\n"
"PGresult *PQprepare(PGconn *conn,\n"
"                    const char *stmtName,\n"
"                    const char *query,\n"
"                    int nParams,\n"
"                    const Oid *paramTypes);\n"
"</synopsis>"

#: libpq.xml:2305(para)
msgid ""
"<function>PQprepare</function> creates a prepared statement for later "
"execution with <function>PQexecPrepared</function>. This feature allows "
"commands to be executed repeatedly without being parsed and planned each "
"time; see <xref linkend=\"sql-prepare\"/> for details. <function>PQprepare</"
"function> is supported only in protocol 3.0 and later connections; it will "
"fail when using protocol 2.0."
msgstr ""
"<function>PQprepare</function> создаёт подготовленный оператор для "
"последующего исполнения с помощью <function>PQexecPrepared</function>. "
"Благодаря этому, команды, которые будут выполняться многократно, не "
"потребуется разбирать и планировать каждый раз; за подробностями обратитесь "
"к <xref remap=\"3\" linkend=\"sql-prepare\"/>. <function>PQprepare</"
"function> поддерживается только с подключениями по протоколу 3.0 и новее; с "
"протоколом 2.0 эта функция работать не будет."

#: libpq.xml:2314(para)
msgid ""
"The function creates a prepared statement named <parameter>stmtName</"
"parameter> from the <parameter>query</parameter> string, which must contain "
"a single SQL command. <parameter>stmtName</parameter> can be <literal>\"\"</"
"literal> to create an unnamed statement, in which case any pre-existing "
"unnamed statement is automatically replaced; otherwise it is an error if the "
"statement name is already defined in the current session. If any parameters "
"are used, they are referred to in the query as <literal>$1</literal>, "
"<literal>$2</literal>, etc. <parameter>nParams</parameter> is the number of "
"parameters for which types are pre-specified in the array "
"<parameter>paramTypes[]</parameter>. (The array pointer can be <symbol>NULL</"
"symbol> when <parameter>nParams</parameter> is zero.) "
"<parameter>paramTypes[]</parameter> specifies, by OID, the data types to be "
"assigned to the parameter symbols. If <parameter>paramTypes</parameter> is "
"<symbol>NULL</symbol>, or any particular element in the array is zero, the "
"server assigns a data type to the parameter symbol in the same way it would "
"do for an untyped literal string. Also, the query can use parameter symbols "
"with numbers higher than <parameter>nParams</parameter>; data types will be "
"inferred for these symbols as well. (See <function>PQdescribePrepared</"
"function> for a means to find out what data types were inferred.)"
msgstr ""
"Функция создаёт подготовленный оператор с именем <parameter>stmtName</"
"parameter> из строки <parameter>query</parameter>, которая должна содержать "
"единственную SQL-команду. <parameter>stmtName</parameter> может быть пустой "
"строкой <literal>\"\"</literal>, тогда будет создан неименованный оператор "
"(в таком случае любой уже существующий неименованный оператор будет "
"автоматически заменён), в противном случае, если имя оператора уже "
"определено в текущем сеансе работы, будет ошибка. Если используются "
"параметры, то в запросе к ним обращаются таким образом: <literal>$1</"
"literal>, <literal>$2</literal> и т. д. <parameter>nParams</parameter> "
"представляет число параметров, типы данных для которых указаны в массиве "
"<parameter>paramTypes[]</parameter>. (Указатель на массив может быть равен "
"<symbol>NULL</symbol>, когда значение <parameter>nParams</parameter> равно "
"нулю.) <parameter>paramTypes[]</parameter> указывает, посредством OID, типы "
"данных, которые будут назначены параметрам. Если <parameter>paramTypes</"
"parameter> равен <symbol>NULL</symbol> или какой-либо элемент в этом массиве "
"равен нулю, то сервер назначает тип данных соответствующему параметру точно "
"таким же способом, как он сделал бы для литеральной строки, не имеющей типа. "
"Также в запросе можно использовать параметры с номерами, большими, чем "
"<parameter>nParams</parameter>; типы данных для них сервер также сможет "
"подобрать. (См. описание <function>PQdescribePrepared</function>, где "
"сказано, какие существуют средства, чтобы определить, какие типы данных были "
"подобраны)."

#: libpq.xml:2338(para)
msgid ""
"As with <function>PQexec</function>, the result is normally a "
"<structname>PGresult</structname> object whose contents indicate server-side "
"success or failure. A null result indicates out-of-memory or inability to "
"send the command at all. Use <function>PQerrorMessage</function> to get more "
"information about such errors."
msgstr ""
"Как и при вызове <function>PQexec</function>, результатом является объект "
"<structname>PGresult</structname>, содержимое которого показывает успех или "
"сбой на стороне сервера. Нулевой указатель означает нехватку памяти или "
"невозможность вообще отправить команду. Для получения дополнительной "
"информации о таких ошибках используйте <function>PQerrorMessage</function>."

#: libpq.xml:2283(para)
msgid ""
"<placeholder-1/> Prepared statements for use with <function>PQexecPrepared</"
"function> can also be created by executing SQL <xref linkend=\"sql-prepare\"/"
"> statements. Also, although there is no <application>libpq</application> "
"function for deleting a prepared statement, the SQL <xref linkend=\"sql-"
"deallocate\"/> statement can be used for that purpose."
msgstr ""
"<placeholder-1/> Подготовленные операторы для использования с "
"<function>PQexecPrepared</function> можно также создать путём исполнения SQL-"
"команд <xref linkend=\"sql-prepare\"/>. Также, хотя никакой функции "
"<application>libpq</application> для удаления подготовленного оператора не "
"предусмотрено, для этой цели можно воспользоваться SQL-командой <xref "
"linkend=\"sql-deallocate\"/>."

#: libpq.xml:2362(function)
msgid "PQexecPrepared"
msgstr "PQexecPrepared"

#: libpq.xml:2363(indexterm)
msgid "<primary>PQexecPrepared</primary>"
msgstr "<primary>PQexecPrepared</primary>"

#: libpq.xml:2369(para)
msgid ""
"Sends a request to execute a prepared statement with given parameters, and "
"waits for the result. <synopsis>\n"
"PGresult *PQexecPrepared(PGconn *conn,\n"
"                         const char *stmtName,\n"
"                         int nParams,\n"
"                         const char * const *paramValues,\n"
"                         const int *paramLengths,\n"
"                         const int *paramFormats,\n"
"                         int resultFormat);\n"
"</synopsis>"
msgstr ""
"Отправляет запрос на исполнение подготовленного оператора с данными "
"параметрами и ожидает результата. <synopsis>\n"
"PGresult *PQexecPrepared(PGconn *conn,\n"
"                         const char *stmtName,\n"
"                         int nParams,\n"
"                         const char * const *paramValues,\n"
"                         const int *paramLengths,\n"
"                         const int *paramFormats,\n"
"                         int resultFormat);\n"
"</synopsis>"

#: libpq.xml:2383(para)
msgid ""
"<function>PQexecPrepared</function> is like <function>PQexecParams</"
"function>, but the command to be executed is specified by naming a "
"previously-prepared statement, instead of giving a query string. This "
"feature allows commands that will be used repeatedly to be parsed and "
"planned just once, rather than each time they are executed. The statement "
"must have been prepared previously in the current session. "
"<function>PQexecPrepared</function> is supported only in protocol 3.0 and "
"later connections; it will fail when using protocol 2.0."
msgstr ""
"<function>PQexecPrepared</function> подобна <function>PQexecParams</"
"function>, но команда, подлежащая исполнению, указывается путём передачи "
"имени предварительно подготовленного оператора вместо передачи строки "
"запроса. Эта возможность позволяет командам, которые вызываются многократно, "
"подвергаться разбору и планированию только один раз, а не при каждом их "
"исполнении. Оператор должен быть подготовлен предварительно в рамках "
"текущего сеанса работы. <function>PQexecPrepared</function> поддерживается "
"только в соединениях по протоколу версии 3.0 или более поздних версий. При "
"использовании протокола версии 2.0 функция завершится сбоем."

#: libpq.xml:2395(para)
msgid ""
"The parameters are identical to <function>PQexecParams</function>, except "
"that the name of a prepared statement is given instead of a query string, "
"and the <parameter>paramTypes[]</parameter> parameter is not present (it is "
"not needed since the prepared statement's parameter types were determined "
"when it was created)."
msgstr ""
"Параметры идентичны <function>PQexecParams</function>, за исключением того, "
"что вместо строки запроса передаётся имя подготовленного оператора, и "
"отсутствует параметр <parameter>paramTypes[]</parameter> (он не нужен, "
"поскольку типы данных для параметров подготовленного оператора были "
"определены при его создании)."

#: libpq.xml:2406(function)
msgid "PQdescribePrepared"
msgstr "PQdescribePrepared"

#: libpq.xml:2407(indexterm)
msgid "<primary>PQdescribePrepared</primary>"
msgstr "<primary>PQdescribePrepared</primary>"

#: libpq.xml:2413(para)
msgid ""
"Submits a request to obtain information about the specified prepared "
"statement, and waits for completion. <synopsis>\n"
"PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);\n"
"</synopsis>"
msgstr ""
"Передаёт запрос на получение информации об указанном подготовленном "
"операторе и ожидает завершения. <synopsis>\n"
"PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);\n"
"</synopsis>"

#: libpq.xml:2421(para)
msgid ""
"<function>PQdescribePrepared</function> allows an application to obtain "
"information about a previously prepared statement. "
"<function>PQdescribePrepared</function> is supported only in protocol 3.0 "
"and later connections; it will fail when using protocol 2.0."
msgstr ""
"<function>PQdescribePrepared</function> позволяет приложению получить "
"информацию о предварительно подготовленном операторе. "
"<function>PQdescribePrepared</function> поддерживается только в соединениях "
"по протоколу версии 3.0 или более поздних версий. При использовании "
"протокола версии 2.0 функция завершится сбоем."

#: libpq.xml:2428(para)
msgid ""
"<parameter>stmtName</parameter> can be <literal>\"\"</literal> or "
"<symbol>NULL</symbol> to reference the unnamed statement, otherwise it must "
"be the name of an existing prepared statement. On success, a "
"<structname>PGresult</structname> with status <literal>PGRES_COMMAND_OK</"
"literal> is returned. The functions <function>PQnparams</function> and "
"<function>PQparamtype</function> can be applied to this "
"<structname>PGresult</structname> to obtain information about the parameters "
"of the prepared statement, and the functions <function>PQnfields</function>, "
"<function>PQfname</function>, <function>PQftype</function>, etc provide "
"information about the result columns (if any) of the statement."
msgstr ""
"Для ссылки на неименованный оператор значение <parameter>stmtName</"
"parameter> может быть пустой строкой <literal>\"\"</literal> или "
"<symbol>NULL</symbol>, в противном случае оно должно быть именем "
"существующего подготовленного оператора. В случае успешного выполнения "
"возвращается <structname>PGresult</structname> со статусом "
"<literal>PGRES_COMMAND_OK</literal>. Функции <function>PQnparams</function> "
"и <function>PQparamtype</function> позволяют извлечь из "
"<structname>PGresult</structname> информацию о параметрах подготовленного "
"оператора, а функции <function>PQnfields</function>, <function>PQfname</"
"function>, <function>PQftype</function> и т. п. предоставляют информацию о "
"результирующих столбцах (если они есть) данного оператора."

#: libpq.xml:2446(function)
msgid "PQdescribePortal"
msgstr "PQdescribePortal"

#: libpq.xml:2447(indexterm)
msgid "<primary>PQdescribePortal</primary>"
msgstr "<primary>PQdescribePortal</primary>"

#: libpq.xml:2453(para)
msgid ""
"Submits a request to obtain information about the specified portal, and "
"waits for completion. <synopsis>\n"
"PGresult *PQdescribePortal(PGconn *conn, const char *portalName);\n"
"</synopsis>"
msgstr ""
"Передаёт запрос на получение информации об указанном портале и ожидает "
"завершения. <synopsis>\n"
"PGresult *PQdescribePortal(PGconn *conn, const char *portalName);\n"
"</synopsis>"

#: libpq.xml:2461(para)
msgid ""
"<function>PQdescribePortal</function> allows an application to obtain "
"information about a previously created portal. (<application>libpq</"
"application> does not provide any direct access to portals, but you can use "
"this function to inspect the properties of a cursor created with a "
"<command>DECLARE CURSOR</command> SQL command.) <function>PQdescribePortal</"
"function> is supported only in protocol 3.0 and later connections; it will "
"fail when using protocol 2.0."
msgstr ""
"<function>PQdescribePortal</function> позволяет приложению получить "
"информацию о предварительно созданном портале. (<application>libpq</"
"application> не предоставляет прямого доступа к порталам, но вы можете "
"использовать эту функцию для ознакомления со свойствами курсора, созданного "
"с помощью SQL-команды <command>DECLARE CURSOR</command>.) "
"<function>PQdescribePortal</function> поддерживается только в соединениях по "
"протоколу версии 3.0 или более поздних версий. При использовании протокола "
"версии 2.0 функция завершится сбоем."

#: libpq.xml:2471(para)
msgid ""
"<parameter>portalName</parameter> can be <literal>\"\"</literal> or "
"<symbol>NULL</symbol> to reference the unnamed portal, otherwise it must be "
"the name of an existing portal. On success, a <structname>PGresult</"
"structname> with status <literal>PGRES_COMMAND_OK</literal> is returned. The "
"functions <function>PQnfields</function>, <function>PQfname</function>, "
"<function>PQftype</function>, etc can be applied to the "
"<structname>PGresult</structname> to obtain information about the result "
"columns (if any) of the portal."
msgstr ""
"Для ссылки на неименованный портал значение <parameter>portalName</"
"parameter> может быть пустой строкой <literal>\"\"</literal> или "
"<symbol>NULL</symbol>, в противном случае оно должно быть именем "
"существующего портала. В случае успешного завершения возвращается "
"<structname>PGresult</structname> со статусом <literal>PGRES_COMMAND_OK</"
"literal>. С помощью функций <function>PQnfields</function>, "
"<function>PQfname</function>, <function>PQftype</function> и т. д. можно "
"извлечь из <structname>PGresult</structname> информацию о результирующих "
"столбцах (если они есть) данного портала."

#: libpq.xml:2487(indexterm)
msgid "<primary>PGresult</primary>"
msgstr "<primary>PGresult</primary>"

#: libpq.xml:2499(function)
msgid "PQresultStatus"
msgstr "PQresultStatus"

#: libpq.xml:2500(indexterm)
msgid "<primary>PQresultStatus</primary>"
msgstr "<primary>PQresultStatus</primary>"

#: libpq.xml:2506(para)
msgid ""
"Returns the result status of the command. <synopsis>\n"
"ExecStatusType PQresultStatus(const PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает статус результата выполнения команды. <synopsis>\n"
"ExecStatusType PQresultStatus(const PGresult *res);\n"
"</synopsis>"

#: libpq.xml:2518(literal)
msgid "PGRES_EMPTY_QUERY"
msgstr "PGRES_EMPTY_QUERY"

#: libpq.xml:2520(para)
msgid "The string sent to the server was empty."
msgstr "Строка, отправленная серверу, была пустой."

#: libpq.xml:2527(literal)
msgid "PGRES_COMMAND_OK"
msgstr "PGRES_COMMAND_OK"

#: libpq.xml:2529(para)
msgid "Successful completion of a command returning no data."
msgstr "Успешное завершение команды, не возвращающей никаких данных."

#: libpq.xml:2536(literal)
msgid "PGRES_TUPLES_OK"
msgstr "PGRES_TUPLES_OK"

#: libpq.xml:2538(para)
msgid ""
"Successful completion of a command returning data (such as a "
"<command>SELECT</command> or <command>SHOW</command>)."
msgstr ""
"Успешное завершение команды, возвращающей данные (такой, как "
"<command>SELECT</command> или <command>SHOW</command>)."

#: libpq.xml:2546(literal)
msgid "PGRES_COPY_OUT"
msgstr "PGRES_COPY_OUT"

#: libpq.xml:2548(para)
msgid "Copy Out (from server) data transfer started."
msgstr "Начат перенос данных Copy Out (с сервера)."

#: libpq.xml:2555(literal)
msgid "PGRES_COPY_IN"
msgstr "PGRES_COPY_IN"

#: libpq.xml:2557(para)
msgid "Copy In (to server) data transfer started."
msgstr "Начат перенос данных Copy In (на сервер)."

#: libpq.xml:2564(literal)
msgid "PGRES_BAD_RESPONSE"
msgstr "PGRES_BAD_RESPONSE"

#: libpq.xml:2566(para)
msgid "The server's response was not understood."
msgstr "Ответ сервера не был распознан."

#: libpq.xml:2573(literal)
msgid "PGRES_NONFATAL_ERROR"
msgstr "PGRES_NONFATAL_ERROR"

#: libpq.xml:2575(para)
msgid "A nonfatal error (a notice or warning) occurred."
msgstr "Произошла не фатальная ошибка (уведомление или предупреждение)."

#: libpq.xml:2582(literal)
msgid "PGRES_FATAL_ERROR"
msgstr "PGRES_FATAL_ERROR"

#: libpq.xml:2584(para)
msgid "A fatal error occurred."
msgstr "Произошла фатальная ошибка."

#: libpq.xml:2591(literal)
msgid "PGRES_COPY_BOTH"
msgstr "PGRES_COPY_BOTH"

#: libpq.xml:2593(para)
msgid ""
"Copy In/Out (to and from server) data transfer started. This feature is "
"currently used only for streaming replication, so this status should not "
"occur in ordinary applications."
msgstr ""
"Начат перенос данных Copy In/Out (на сервер и с сервера). Эта функция в "
"настоящее время используется только для потоковой репликации, поэтому такой "
"статус не должен иметь место в обычных приложениях."

#: libpq.xml:2602(literal)
msgid "PGRES_SINGLE_TUPLE"
msgstr "PGRES_SINGLE_TUPLE"

#: libpq.xml:2604(para)
msgid ""
"The <structname>PGresult</structname> contains a single result tuple from "
"the current command. This status occurs only when single-row mode has been "
"selected for the query (see <xref linkend=\"libpq-single-row-mode\"/>)."
msgstr ""
"Структура <structname>PGresult</structname> содержит только одну "
"результирующую строку, возвращённую текущей командой. Этот статус имеет "
"место только тогда, когда для данного запроса был выбран режим построчного "
"вывода (см. <xref remap=\"4\" linkend=\"libpq-single-row-mode\"/>)."

#: libpq.xml:2513(para)
msgid ""
"<function>PQresultStatus</function> can return one of the following values: "
"<placeholder-1/> If the result status is <literal>PGRES_TUPLES_OK</literal> "
"or <literal>PGRES_SINGLE_TUPLE</literal>, then the functions described below "
"can be used to retrieve the rows returned by the query. Note that a "
"<command>SELECT</command> command that happens to retrieve zero rows still "
"shows <literal>PGRES_TUPLES_OK</literal>. <literal>PGRES_COMMAND_OK</"
"literal> is for commands that can never return rows (<command>INSERT</"
"command> or <command>UPDATE</command> without a <literal>RETURNING</literal> "
"clause, etc.). A response of <literal>PGRES_EMPTY_QUERY</literal> might "
"indicate a bug in the client software."
msgstr ""
"<function>PQresultStatus</function> может возвращать одно из следующих "
"значений: <placeholder-1/> Если статус результата <literal>PGRES_TUPLES_OK</"
"literal> или <literal>PGRES_SINGLE_TUPLE</literal>, тогда для извлечения "
"строк, возвращённых запросом, можно использовать функции, описанные ниже. "
"Обратите внимание, что команда <command>SELECT</command>, даже когда она не "
"извлекает ни одной строки, всё же показывает <literal>PGRES_TUPLES_OK</"
"literal>. <literal>PGRES_COMMAND_OK</literal> предназначен для команд, "
"которые никогда не возвращают строки (<command>INSERT</command> или "
"<command>UPDATE</command> без использования предложения <literal>RETURNING</"
"literal> и др.). Ответ <literal>PGRES_EMPTY_QUERY</literal> может указывать "
"на наличие ошибки в клиентском программном обеспечении."

#: libpq.xml:2627(para)
msgid ""
"A result of status <symbol>PGRES_NONFATAL_ERROR</symbol> will never be "
"returned directly by <function>PQexec</function> or other query execution "
"functions; results of this kind are instead passed to the notice processor "
"(see <xref linkend=\"libpq-notice-processing\"/>)."
msgstr ""
"Результат со статусом <symbol>PGRES_NONFATAL_ERROR</symbol> никогда не будет "
"возвращён напрямую функцией <function>PQexec</function> или другими "
"функциями исполнения запросов; вместо этого результаты такого вида "
"передаются обработчику уведомлений (см. <xref remap=\"4\" linkend=\"libpq-"
"notice-processing\"/>)."

#: libpq.xml:2639(function)
msgid "PQresStatus"
msgstr "PQresStatus"

#: libpq.xml:2640(indexterm)
msgid "<primary>PQresStatus</primary>"
msgstr "<primary>PQresStatus</primary>"

#: libpq.xml:2646(para)
msgid ""
"Converts the enumerated type returned by <function>PQresultStatus</function> "
"into a string constant describing the status code. The caller should not "
"free the result. <synopsis>\n"
"char *PQresStatus(ExecStatusType status);\n"
"</synopsis>"
msgstr ""
"Преобразует значение перечислимого типа, возвращённое функцией "
"<function>PQresultStatus</function>, в строковую константу, описывающую код "
"статуса. Вызывающая функция не должна освобождать память, на которую "
"указывает возвращаемый указатель. <synopsis>\n"
"char *PQresStatus(ExecStatusType status);\n"
"</synopsis>"

#: libpq.xml:2660(function)
msgid "PQresultErrorMessage"
msgstr "PQresultErrorMessage"

#: libpq.xml:2661(indexterm)
msgid "<primary>PQresultErrorMessage</primary>"
msgstr "<primary>PQresultErrorMessage</primary>"

#: libpq.xml:2667(para)
msgid ""
"Returns the error message associated with the command, or an empty string if "
"there was no error. <synopsis>\n"
"char *PQresultErrorMessage(const PGresult *res);\n"
"</synopsis> If there was an error, the returned string will include a "
"trailing newline. The caller should not free the result directly. It will be "
"freed when the associated <structname>PGresult</structname> handle is passed "
"to <function>PQclear</function>."
msgstr ""
"Возвращает сообщение об ошибке, связанное с командой, или пустую строку, "
"если ошибки не произошло. <synopsis>\n"
"char *PQresultErrorMessage(const PGresult *res);\n"
"</synopsis> Если произошла ошибка, то возвращённая строка будет включать "
"завершающий символ новой строки. Вызывающая функция не должна напрямую "
"освобождать память, на которую указывает возвращаемый указатель. Она будет "
"освобождена, когда соответствующий указатель <structname>PGresult</"
"structname> будет передан функции <function>PQclear</function>."

#: libpq.xml:2679(para)
msgid ""
"Immediately following a <function>PQexec</function> or "
"<function>PQgetResult</function> call, <function>PQerrorMessage</function> "
"(on the connection) will return the same string as "
"<function>PQresultErrorMessage</function> (on the result). However, a "
"<structname>PGresult</structname> will retain its error message until "
"destroyed, whereas the connection's error message will change when "
"subsequent operations are done. Use <function>PQresultErrorMessage</"
"function> when you want to know the status associated with a particular "
"<structname>PGresult</structname>; use <function>PQerrorMessage</function> "
"when you want to know the status from the latest operation on the connection."
msgstr ""
"Если непосредственно после вызова <function>PQexec</function> или "
"<function>PQgetResult</function> вызвать функцию <function>PQerrorMessage</"
"function> (для данного подключения), то она возвратит ту же самую строку, "
"что и <function>PQresultErrorMessage</function> (для данного результата). "
"Однако, <structname>PGresult</structname> сохранит своё сообщение об ошибке "
"до тех пор, пока не будет уничтожен, в то время, как сообщение об ошибке, "
"связанное с данным подключением, будет изменяться при выполнении последующих "
"операций. Воспользуйтесь функцией <function>PQresultErrorMessage</function>, "
"когда вы хотите узнать статус, связанный с конкретной структурой "
"<structname>PGresult</structname>; используйте функцию "
"<function>PQerrorMessage</function>, когда вы хотите узнать статус "
"выполнения самой последней операции на данном соединении."

#: libpq.xml:2698(function)
msgid "PQresultVerboseErrorMessage"
msgstr "PQresultVerboseErrorMessage"

#: libpq.xml:2699(indexterm)
msgid "<primary>PQresultVerboseErrorMessage</primary>"
msgstr "<primary>PQresultVerboseErrorMessage</primary>"

#: libpq.xml:2705(para)
msgid ""
"Returns a reformatted version of the error message associated with a "
"<structname>PGresult</structname> object. <synopsis>\n"
"char *PQresultVerboseErrorMessage(const PGresult *res,\n"
"                                  PGVerbosity verbosity,\n"
"                                  PGContextVisibility show_context);\n"
"</synopsis> In some situations a client might wish to obtain a more detailed "
"version of a previously-reported error. "
"<function>PQresultVerboseErrorMessage</function> addresses this need by "
"computing the message that would have been produced by "
"<function>PQresultErrorMessage</function> if the specified verbosity "
"settings had been in effect for the connection when the given "
"<structname>PGresult</structname> was generated. If the "
"<structname>PGresult</structname> is not an error result, <quote>PGresult is "
"not an error result</quote> is reported instead. The returned string "
"includes a trailing newline."
msgstr ""
"Возвращает переформатированную версию сообщения об ошибке, связанного с "
"объектом <structname>PGresult</structname>. <synopsis>\n"
"char *PQresultVerboseErrorMessage(const PGresult *res,\n"
"                                  PGVerbosity verbosity,\n"
"                                  PGContextVisibility show_context);\n"
"</synopsis> В некоторых ситуациях клиент может захотеть получить более "
"подробную версию ранее выданного сообщения об ошибке. Эту потребность "
"удовлетворяет функция <function>PQresultVerboseErrorMessage</function>, "
"формируя сообщение, которое было бы выдано функцией "
"<function>PQresultErrorMessage</function>, если бы заданный уровень "
"детализации был текущим для соединения в момент заполнения "
"<structname>PGresult</structname>. Если же в <structname>PGresult</"
"structname> не содержится ошибка, вместо этого выдаётся сообщение "
"<quote>PGresult is not an error result</quote> (PGresult — не результат с "
"ошибкой). Возвращаемое этой функцией сообщение завершается переводом строки."

#: libpq.xml:2725(para)
msgid ""
"Unlike most other functions for extracting data from a <structname>PGresult</"
"structname>, the result of this function is a freshly allocated string. The "
"caller must free it using <function>PQfreemem()</function> when the string "
"is no longer needed."
msgstr ""
"В отличие от многих других функций, извлекающих данные из "
"<structname>PGresult</structname>, результат этой функции — новая "
"размещённая в памяти строка. Когда эта строка будет не нужна, вызывающий код "
"должен освободить её место, вызвав <function>PQfreemem()</function>."

#: libpq.xml:2732(para)
msgid "A NULL return is possible if there is insufficient memory."
msgstr "При нехватке памяти может быть возвращёно NULL."

#: libpq.xml:2739(function)
msgid "PQresultErrorField"
msgstr "PQresultErrorField"

#: libpq.xml:2739(indexterm)
msgid "<primary>PQresultErrorField</primary>"
msgstr "<primary>PQresultErrorField</primary>"

#: libpq.xml:2741(para)
msgid ""
"Returns an individual field of an error report. <synopsis>\n"
"char *PQresultErrorField(const PGresult *res, int fieldcode);\n"
"</synopsis> <parameter>fieldcode</parameter> is an error field identifier; "
"see the symbols listed below. <symbol>NULL</symbol> is returned if the "
"<structname>PGresult</structname> is not an error or warning result, or does "
"not include the specified field. Field values will normally not include a "
"trailing newline. The caller should not free the result directly. It will be "
"freed when the associated <structname>PGresult</structname> handle is passed "
"to <function>PQclear</function>."
msgstr ""
"Возвращает индивидуальное поле из отчёта об ошибке. <synopsis>\n"
"char *PQresultErrorField(const PGresult *res, int fieldcode);\n"
"</synopsis> <parameter>fieldcode</parameter> это идентификатор поля ошибки; "
"см. символические константы, перечисленные ниже. Если <structname>PGresult</"
"structname> не содержит ошибки или предупреждения или не включает указанное "
"поле, то возвращается <symbol>NULL</symbol>. Значения полей обычно не "
"включают завершающий символ новой строки. Вызывающая функция не должна "
"напрямую освобождать память, на которую указывает возвращаемый указатель. "
"Она будет освобождена, когда соответствующий указатель <structname>PGresult</"
"structname> будет передан функции <function>PQclear</function>."

#: libpq.xml:2760(symbol)
msgid "PG_DIAG_SEVERITY"
msgstr "PG_DIAG_SEVERITY"

#: libpq.xml:2762(para)
msgid ""
"The severity; the field contents are <literal>ERROR</literal>, "
"<literal>FATAL</literal>, or <literal>PANIC</literal> (in an error message), "
"or <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal>, or <literal>LOG</literal> (in a notice "
"message), or a localized translation of one of these. Always present."
msgstr ""
"Серьёзность; поле может содержать <literal>ERROR</literal>, <literal>FATAL</"
"literal> или <literal>PANIC</literal> (в сообщении об ошибке) либо "
"<literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal> или <literal>LOG</literal> (в сообщении-"
"уведомлении) либо локализованный перевод одного из этих значений. "
"Присутствует всегда."

#: libpq.xml:2773(symbol)
msgid "PG_DIAG_SEVERITY_NONLOCALIZED"
msgstr "PG_DIAG_SEVERITY_NONLOCALIZED"

#: libpq.xml:2775(para)
msgid ""
"The severity; the field contents are <literal>ERROR</literal>, "
"<literal>FATAL</literal>, or <literal>PANIC</literal> (in an error message), "
"or <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal>, or <literal>LOG</literal> (in a notice "
"message). This is identical to the <symbol>PG_DIAG_SEVERITY</symbol> field "
"except that the contents are never localized. This is present only in "
"reports generated by <productname>PostgreSQL</productname> versions 9.6 and "
"later."
msgstr ""
"Серьёзность; поле может содержать <literal>ERROR</literal>, <literal>FATAL</"
"literal> или <literal>PANIC</literal> (в сообщении об ошибке) либо "
"<literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal> или <literal>LOG</literal> (в сообщении-"
"уведомлении). Это поле подобно <symbol>PG_DIAG_SEVERITY</symbol>, но его "
"содержимое никогда не переводится. Присутствует только в отчётах, выдаваемых "
"<productname>PostgreSQL</productname> версии 9.6 и новее."

#: libpq.xml:2790(symbol)
msgid "PG_DIAG_SQLSTATE"
msgstr "PG_DIAG_SQLSTATE"

#: libpq.xml:2791(indexterm)
msgid "<primary>error codes</primary> <secondary>libpq</secondary>"
msgstr "<primary>коды ошибок</primary> <secondary>libpq</secondary>"

#: libpq.xml:2797(para)
msgid ""
"The SQLSTATE code for the error. The SQLSTATE code identifies the type of "
"error that has occurred; it can be used by front-end applications to perform "
"specific operations (such as error handling) in response to a particular "
"database error. For a list of the possible SQLSTATE codes, see <xref linkend="
"\"errcodes-appendix\"/>. This field is not localizable, and is always "
"present."
msgstr ""
"Код ошибки в соответствии с соглашением о кодах SQLSTATE. Код SQLSTATE "
"идентифицирует тип случившейся ошибки; он может использоваться клиентскими "
"приложениями, чтобы выполнять конкретные операции (такие, как обработка "
"ошибок) в ответ на конкретную ошибку базы данных. Список возможных кодов "
"SQLSTATE приведён в <xref remap=\"6\" linkend=\"errcodes-appendix\"/>. Это "
"поле не подлежит локализации. Оно всегда присутствует."

#: libpq.xml:2810(symbol)
msgid "PG_DIAG_MESSAGE_PRIMARY"
msgstr "PG_DIAG_MESSAGE_PRIMARY"

#: libpq.xml:2812(para)
msgid ""
"The primary human-readable error message (typically one line). Always "
"present."
msgstr ""
"Главное сообщение об ошибке, предназначенное для прочтения пользователем. "
"Как правило составляет всего одну строку. Это поле всегда присутствует."

#: libpq.xml:2820(symbol)
msgid "PG_DIAG_MESSAGE_DETAIL"
msgstr "PG_DIAG_MESSAGE_DETAIL"

#: libpq.xml:2822(para)
msgid ""
"Detail: an optional secondary error message carrying more detail about the "
"problem. Might run to multiple lines."
msgstr ""
"Необязательное дополнительное сообщение об ошибке, передающее более "
"детальную информацию о проблеме. Может занимать несколько строк."

#: libpq.xml:2830(symbol)
msgid "PG_DIAG_MESSAGE_HINT"
msgstr "PG_DIAG_MESSAGE_HINT"

#: libpq.xml:2832(para)
msgid ""
"Hint: an optional suggestion what to do about the problem. This is intended "
"to differ from detail in that it offers advice (potentially inappropriate) "
"rather than hard facts. Might run to multiple lines."
msgstr ""
"Подсказка: необязательное предположение о том, что можно сделать в данной "
"проблемной ситуации. Оно должно отличаться от детальной информации в том "
"смысле, что оно предлагает совет (возможно, и неподходящий), а не просто "
"факты. Может занимать несколько строк."

#: libpq.xml:2842(symbol)
msgid "PG_DIAG_STATEMENT_POSITION"
msgstr "PG_DIAG_STATEMENT_POSITION"

#: libpq.xml:2844(para)
msgid ""
"A string containing a decimal integer indicating an error cursor position as "
"an index into the original statement string. The first character has index "
"1, and positions are measured in characters not bytes."
msgstr ""
"Строка, содержащая десятичное целое число, указывающее позицию расположения "
"ошибки в качестве индекса в оригинальной строке оператора. Первый символ "
"имеет позицию 1, при этом позиции измеряются в символах а не в байтах."

#: libpq.xml:2854(symbol)
msgid "PG_DIAG_INTERNAL_POSITION"
msgstr "PG_DIAG_INTERNAL_POSITION"

#: libpq.xml:2856(para)
msgid ""
"This is defined the same as the <symbol>PG_DIAG_STATEMENT_POSITION</symbol> "
"field, but it is used when the cursor position refers to an internally "
"generated command rather than the one submitted by the client. The "
"<symbol>PG_DIAG_INTERNAL_QUERY</symbol> field will always appear when this "
"field appears."
msgstr ""
"Это поле определяется точно так же, как и поле "
"<symbol>PG_DIAG_STATEMENT_POSITION</symbol>, но оно используется, когда "
"позиция местонахождения ошибки относится к команде, сгенерированной "
"внутренними модулями, а не к команде, представленной клиентом. Когда "
"появляется это поле, то всегда появляется и поле "
"<symbol>PG_DIAG_INTERNAL_QUERY</symbol>."

#: libpq.xml:2868(symbol)
msgid "PG_DIAG_INTERNAL_QUERY"
msgstr "PG_DIAG_INTERNAL_QUERY"

#: libpq.xml:2870(para)
msgid ""
"The text of a failed internally-generated command. This could be, for "
"example, a SQL query issued by a PL/pgSQL function."
msgstr ""
"Текст команды, сгенерированной внутренними модулями, завершившейся сбоем. "
"Это мог бы быть, например, SQL-запрос, выданный функцией на языке PL/pgSQL."

#: libpq.xml:2878(symbol)
msgid "PG_DIAG_CONTEXT"
msgstr "PG_DIAG_CONTEXT"

#: libpq.xml:2880(para)
msgid ""
"An indication of the context in which the error occurred. Presently this "
"includes a call stack traceback of active procedural language functions and "
"internally-generated queries. The trace is one entry per line, most recent "
"first."
msgstr ""
"Характеристика контекста, в котором произошла ошибка. В настоящее время она "
"включает вывод стека вызовов активных функций процедурного языка и запросов, "
"сгенерированных внутренними модулями. Стек выводится по одному элементу в "
"строке, при этом первым идет самый последний из элементов (самый недавний "
"вызов)."

#: libpq.xml:2890(symbol)
msgid "PG_DIAG_SCHEMA_NAME"
msgstr "PG_DIAG_SCHEMA_NAME"

#: libpq.xml:2892(para)
msgid ""
"If the error was associated with a specific database object, the name of the "
"schema containing that object, if any."
msgstr ""
"Если ошибка была связана с конкретным объектом базы данных, то в это поле "
"будет записано имя схемы, содержащей данный объект."

#: libpq.xml:2900(symbol)
msgid "PG_DIAG_TABLE_NAME"
msgstr "PG_DIAG_TABLE_NAME"

#: libpq.xml:2902(para)
msgid ""
"If the error was associated with a specific table, the name of the table. "
"(Refer to the schema name field for the name of the table's schema.)"
msgstr ""
"Если ошибка была связана с конкретной таблицей, то в это поле будет записано "
"имя таблицы. (Для получения имени схемы для данной таблицы обратитесь к "
"полю, содержащему имя схемы.)"

#: libpq.xml:2911(symbol)
msgid "PG_DIAG_COLUMN_NAME"
msgstr "PG_DIAG_COLUMN_NAME"

#: libpq.xml:2913(para)
msgid ""
"If the error was associated with a specific table column, the name of the "
"column. (Refer to the schema and table name fields to identify the table.)"
msgstr ""
"Если ошибка была связана с конкретным столбцом таблицы, то в это поле будет "
"записано имя столбца. (Чтобы идентифицировать таблицу, обратитесь к полям, "
"содержащим имена схемы и таблицы.)"

#: libpq.xml:2922(symbol)
msgid "PG_DIAG_DATATYPE_NAME"
msgstr "PG_DIAG_DATATYPE_NAME"

#: libpq.xml:2924(para)
msgid ""
"If the error was associated with a specific data type, the name of the data "
"type. (Refer to the schema name field for the name of the data type's "
"schema.)"
msgstr ""
"Если ошибка была связана с конкретным типом данных, то в это поле будет "
"записано имя типа данных. (Чтобы получить имя схемы, которой принадлежит "
"этот тип данных, обратитесь к полю, содержащему имя схемы.)"

#: libpq.xml:2933(symbol)
msgid "PG_DIAG_CONSTRAINT_NAME"
msgstr "PG_DIAG_CONSTRAINT_NAME"

#: libpq.xml:2935(para)
msgid ""
"If the error was associated with a specific constraint, the name of the "
"constraint. Refer to fields listed above for the associated table or domain. "
"(For this purpose, indexes are treated as constraints, even if they weren't "
"created with constraint syntax.)"
msgstr ""
"Если ошибка была связана с конкретным ограничением, то в это поле будет "
"записано имя ограничения. Чтобы получить имя таблицы или домена, связанных с "
"этим ограничением, обратитесь к полям, перечисленным выше. (С этой целью "
"индексы рассматриваются как ограничения, даже если они и не были созданы с "
"помощью синтаксиса для создания ограничений.)"

#: libpq.xml:2946(symbol)
msgid "PG_DIAG_SOURCE_FILE"
msgstr "PG_DIAG_SOURCE_FILE"

#: libpq.xml:2948(para)
msgid "The file name of the source-code location where the error was reported."
msgstr ""
"Имя файла, содержащего позицию в исходном коде, для которой было выдано "
"сообщение об ошибка."

#: libpq.xml:2956(symbol)
msgid "PG_DIAG_SOURCE_LINE"
msgstr "PG_DIAG_SOURCE_LINE"

#: libpq.xml:2958(para)
msgid ""
"The line number of the source-code location where the error was reported."
msgstr ""
"Номер строки той позиции в исходном коде, для которой было выдано сообщение "
"об ошибке."

#: libpq.xml:2966(symbol)
msgid "PG_DIAG_SOURCE_FUNCTION"
msgstr "PG_DIAG_SOURCE_FUNCTION"

#: libpq.xml:2968(para)
msgid "The name of the source-code function reporting the error."
msgstr "Имя функции в исходном коде, сообщающей об ошибке."

#: libpq.xml:2756(para)
msgid "The following field codes are available: <placeholder-1/>"
msgstr "Доступны следующие коды полей: <placeholder-1/>"

#: libpq.xml:2977(para)
msgid ""
"The fields for schema name, table name, column name, data type name, and "
"constraint name are supplied only for a limited number of error types; see "
"<xref linkend=\"errcodes-appendix\"/>. Do not assume that the presence of "
"any of these fields guarantees the presence of another field. Core error "
"sources observe the interrelationships noted above, but user-defined "
"functions may use these fields in other ways. In the same vein, do not "
"assume that these fields denote contemporary objects in the current database."
msgstr ""
"Поля для имени схемы, имени таблицы, имени столбца, имени типа данных и "
"имени ограничения предоставляются лишь для ограниченного числа типов ошибок; "
"см. <xref remap=\"4\" linkend=\"errcodes-appendix\"/>. Не рассчитывайте на "
"то, что присутствие любого из этих полей гарантирует и присутствие какого-то "
"другого поля. Базовые источники ошибок придерживаются взаимосвязей, "
"описанных выше, но функции, определённые пользователем, могут использовать "
"эти поля другими способами. Аналогично, не рассчитывайте на то, что эти поля "
"обозначают объекты, существующие в текущей базе данных в настоящий момент."

#: libpq.xml:2989(para)
msgid ""
"The client is responsible for formatting displayed information to meet its "
"needs; in particular it should break long lines as needed. Newline "
"characters appearing in the error message fields should be treated as "
"paragraph breaks, not line breaks."
msgstr ""
"Клиент отвечает за форматирование отображаемой информации в соответствии с "
"его нуждами; в частности, он должен разбивать длинные строки, как требуется. "
"Символы новой строки, встречающиеся в полях сообщения об ошибке, должны "
"обрабатываться, как разрывы абзацев, а не строк."

#: libpq.xml:2996(para)
msgid ""
"Errors generated internally by <application>libpq</application> will have "
"severity and primary message, but typically no other fields. Errors returned "
"by a pre-3.0-protocol server will include severity and primary message, and "
"sometimes a detail message, but no other fields."
msgstr ""
"Ошибки, сгенерированные внутренними модулями <application>libpq</"
"application>, будут иметь поля серьёзности ошибки и основного сообщения, но, "
"как правило, никаких других полей. Ошибки, возвращаемые сервером, работающим "
"по протоколу версии ниже 3.0, будут включать поля серьёзности ошибки и "
"основного сообщения, а также иногда детальное сообщение, но больше никаких "
"полей."

#: libpq.xml:3003(para)
msgid ""
"Note that error fields are only available from <structname>PGresult</"
"structname> objects, not <structname>PGconn</structname> objects; there is "
"no <function>PQerrorField</function> function."
msgstr ""
"Заметьте, что поля ошибки доступны только из объектов <structname>PGresult</"
"structname>, а не из объектов <structname>PGconn</structname>. Не существует "
"функции <function>PQerrorField</function>."

#: libpq.xml:3013(function)
msgid "PQclear"
msgstr "PQclear"

#: libpq.xml:3013(indexterm)
msgid "<primary>PQclear</primary>"
msgstr "<primary>PQclear</primary>"

#: libpq.xml:3015(para)
msgid ""
"Frees the storage associated with a <structname>PGresult</structname>. Every "
"command result should be freed via <function>PQclear</function> when it is "
"no longer needed. <synopsis>\n"
"void PQclear(PGresult *res);\n"
"</synopsis>"
msgstr ""
"Освобождает область памяти, связанную с <structname>PGresult</structname>. "
"Результат выполнения каждой команды должен быть освобождён с помощью "
"<function>PQclear</function>, когда он больше не нужен. <synopsis>\n"
"void PQclear(PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3026(para)
msgid ""
"You can keep a <structname>PGresult</structname> object around for as long "
"as you need it; it does not go away when you issue a new command, nor even "
"if you close the connection. To get rid of it, you must call "
"<function>PQclear</function>. Failure to do this will result in memory leaks "
"in your application."
msgstr ""
"Вы можете держать объект <structname>PGresult</structname> под рукой до тех "
"пор, пока он вам нужен; он не исчезает, ни когда вы выдаёте новую команду, "
"ни даже если вы закрываете соединение. Чтобы от него избавиться, вы должны "
"вызвать <function>PQclear</function>. Если этого не делать, то в результате "
"будут иметь место утечки памяти в вашем приложении."

#: libpq.xml:2486(para)
msgid ""
"The <structname>PGresult</structname><placeholder-1/> structure encapsulates "
"the result returned by the server. <application>libpq</application> "
"application programmers should be careful to maintain the "
"<structname>PGresult</structname> abstraction. Use the accessor functions "
"below to get at the contents of <structname>PGresult</structname>. Avoid "
"directly referencing the fields of the <structname>PGresult</structname> "
"structure because they are subject to change in the future. <placeholder-2/>"
msgstr ""
"Структура <structname>PGresult</structname><placeholder-1/> содержит "
"результат, возвращённый сервером. Разработчики приложений "
"<application>libpq</application> должны тщательно поддерживать абстракцию "
"<structname>PGresult</structname>. Для получения доступа к содержимому "
"<structname>PGresult</structname> используйте функции доступа, описанные "
"ниже. Избегайте непосредственного обращения к полям структуры "
"<structname>PGresult</structname>, поскольку они могут измениться в будущем. "
"<placeholder-2/>"

#: libpq.xml:3040(title)
msgid "Retrieving Query Result Information"
msgstr "Извлечение информации, связанной с результатом запроса"

#: libpq.xml:3042(para)
msgid ""
"These functions are used to extract information from a <structname>PGresult</"
"structname> object that represents a successful query result (that is, one "
"that has status <literal>PGRES_TUPLES_OK</literal> or "
"<literal>PGRES_SINGLE_TUPLE</literal>). They can also be used to extract "
"information from a successful Describe operation: a Describe's result has "
"all the same column information that actual execution of the query would "
"provide, but it has zero rows. For objects with other status values, these "
"functions will act as though the result has zero rows and zero columns."
msgstr ""
"Эти функции служат для извлечения информации из объекта "
"<structname>PGresult</structname>, который представляет результат успешного "
"запроса (то есть такого, который имеет статус <literal>PGRES_TUPLES_OK</"
"literal> или <literal>PGRES_SINGLE_TUPLE</literal>). Их также можно "
"использовать для извлечения информации об успешной операции DESCRIBE: "
"результат этой операции содержит всю ту же самую информацию о столбцах, "
"которая была бы получена при реальном исполнении запроса, но не содержит ни "
"одной строки. Для объектов, имеющих другие значения статуса, эти функции "
"будут действовать таким образом, как будто результат не содержит ни одной "
"строки и ни одного столбца."

#: libpq.xml:3057(function)
msgid "PQntuples"
msgstr "PQntuples"

#: libpq.xml:3058(indexterm)
msgid "<primary>PQntuples</primary>"
msgstr "<primary>PQntuples</primary>"

#: libpq.xml:3064(para)
msgid ""
"Returns the number of rows (tuples) in the query result. Because it returns "
"an integer result, large result sets might overflow the return value on 32-"
"bit operating systems. <synopsis>\n"
"int PQntuples(const PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает число строк (кортежей) в полученной выборке. Поскольку она "
"возвращает целое число, большие выборки могут привести к переполнению "
"возвращаемого значения в 32-разрядных операционных системах. <synopsis>\n"
"int PQntuples(const PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3079(function) libpq.xml:5075(function)
msgid "PQnfields"
msgstr "PQnfields"

#: libpq.xml:3080(indexterm)
msgid "<primary>PQnfields</primary>"
msgstr "<primary>PQnfields</primary>"

#: libpq.xml:3086(para)
msgid ""
"Returns the number of columns (fields) in each row of the query result. "
"<synopsis>\n"
"int PQnfields(const PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает число столбцов (полей) в каждой строке полученной выборки. "
"<synopsis>\n"
"int PQnfields(const PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3099(function)
msgid "PQfname"
msgstr "PQfname"

#: libpq.xml:3100(indexterm)
msgid "<primary>PQfname</primary>"
msgstr "<primary>PQfname</primary>"

#: libpq.xml:3106(para)
msgid ""
"Returns the column name associated with the given column number. Column "
"numbers start at 0. The caller should not free the result directly. It will "
"be freed when the associated <structname>PGresult</structname> handle is "
"passed to <function>PQclear</function>. <synopsis>\n"
"char *PQfname(const PGresult *res,\n"
"              int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает имя столбца, соответствующего данному номеру столбца. Номера "
"столбцов начинаются с 0. Вызывающая функция не должна напрямую освобождать "
"память, на которую указывает возвращаемый указатель. Она будет освобождена, "
"когда соответствующий указатель на <structname>PGresult</structname> будет "
"передан функции <function>PQclear</function>. <synopsis>\n"
"char *PQfname(const PGresult *res,\n"
"              int column_number);\n"
"</synopsis>"

#: libpq.xml:3118(para)
msgid "<symbol>NULL</symbol> is returned if the column number is out of range."
msgstr ""
"Если номер столбца выходит за пределы допустимого диапазона, то возвращается "
"<symbol>NULL</symbol>."

#: libpq.xml:3126(function)
msgid "PQfnumber"
msgstr "PQfnumber"

#: libpq.xml:3127(indexterm)
msgid "<primary>PQfnumber</primary>"
msgstr "<primary>PQfnumber</primary>"

#: libpq.xml:3133(para)
msgid ""
"Returns the column number associated with the given column name. <synopsis>\n"
"int PQfnumber(const PGresult *res,\n"
"              const char *column_name);\n"
"</synopsis>"
msgstr ""
"Возвращает номер столбца, соответствующий данному имени столбца. <synopsis>\n"
"int PQfnumber(const PGresult *res,\n"
"              const char *column_name);\n"
"</synopsis>"

#: libpq.xml:3141(para)
msgid "-1 is returned if the given name does not match any column."
msgstr ""
"Если данное имя не совпадает с именем ни одного из столбцов, то возвращается "
"-1."

#: libpq.xml:3149(programlisting)
#, no-wrap
msgid "SELECT 1 AS FOO, 2 AS \"BAR\";"
msgstr "SELECT 1 AS FOO, 2 AS \"BAR\";"

#: libpq.xml:3153(programlisting)
#, no-wrap
msgid ""
"PQfname(res, 0)              <lineannotation>foo</lineannotation>\n"
"PQfname(res, 1)              <lineannotation>BAR</lineannotation>\n"
"PQfnumber(res, \"FOO\")        <lineannotation>0</lineannotation>\n"
"PQfnumber(res, \"foo\")        <lineannotation>0</lineannotation>\n"
"PQfnumber(res, \"BAR\")        <lineannotation>-1</lineannotation>\n"
"PQfnumber(res, \"\\\"BAR\\\"\")    <lineannotation>1</lineannotation>"
msgstr ""
"PQfname(res, 0)              <lineannotation>foo</lineannotation>\n"
"PQfname(res, 1)              <lineannotation>BAR</lineannotation>\n"
"PQfnumber(res, \"FOO\")        <lineannotation>0</lineannotation>\n"
"PQfnumber(res, \"foo\")        <lineannotation>0</lineannotation>\n"
"PQfnumber(res, \"BAR\")        <lineannotation>-1</lineannotation>\n"
"PQfnumber(res, \"\\\"BAR\\\"\")    <lineannotation>1</lineannotation>"

#: libpq.xml:3145(para)
msgid ""
"The given name is treated like an identifier in an SQL command, that is, it "
"is downcased unless double-quoted. For example, given a query result "
"generated from the SQL command: <placeholder-1/> we would have the results: "
"<placeholder-2/>"
msgstr ""
"Данное имя интерпретируется, как идентификатор в SQL-команде. Это означает, "
"что оно переводится в нижний регистр, если только оно не заключено в двойные "
"кавычки. Например, для выборки, сгенерированной с помощью такой SQL-команды: "
"<placeholder-1/> мы получили бы следующие результаты: <placeholder-2/>"

#: libpq.xml:3167(function)
msgid "PQftable"
msgstr "PQftable"

#: libpq.xml:3168(indexterm)
msgid "<primary>PQftable</primary>"
msgstr "<primary>PQftable</primary>"

#: libpq.xml:3174(para)
msgid ""
"Returns the OID of the table from which the given column was fetched. Column "
"numbers start at 0. <synopsis>\n"
"Oid PQftable(const PGresult *res,\n"
"             int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает OID таблицы, из которой был получен данный столбец. Номера "
"столбцов начинаются с 0. <synopsis>\n"
"Oid PQftable(const PGresult *res,\n"
"             int column_number);\n"
"</synopsis>"

#: libpq.xml:3183(para)
msgid ""
"<literal>InvalidOid</literal> is returned if the column number is out of "
"range, or if the specified column is not a simple reference to a table "
"column, or when using pre-3.0 protocol. You can query the system table "
"<literal>pg_class</literal> to determine exactly which table is referenced."
msgstr ""
"В следующих случаях возвращается <literal>InvalidOid</literal>: если номер "
"столбца выходит за пределы допустимого диапазона; если указанный столбец не "
"является простой ссылкой на столбец таблицы; когда используется протокол "
"версии более ранней, чем 3.0. Вы можете сделать запрос к системной таблице "
"<literal>pg_class</literal>, чтобы точно определить, к какой таблице было "
"произведено обращение."

#: libpq.xml:3191(para)
msgid ""
"The type <type>Oid</type> and the constant <literal>InvalidOid</literal> "
"will be defined when you include the <application>libpq</application> header "
"file. They will both be some integer type."
msgstr ""
"Тип данных <type>Oid</type> и константа <literal>InvalidOid</literal> будут "
"определены, когда вы включите заголовочный файл для <application>libpq</"
"application>. Они будут принадлежать к одному из целочисленных типов."

#: libpq.xml:3202(function)
msgid "PQftablecol"
msgstr "PQftablecol"

#: libpq.xml:3203(indexterm)
msgid "<primary>PQftablecol</primary>"
msgstr "<primary>PQftablecol</primary>"

#: libpq.xml:3209(para)
msgid ""
"Returns the column number (within its table) of the column making up the "
"specified query result column. Query-result column numbers start at 0, but "
"table columns have nonzero numbers. <synopsis>\n"
"int PQftablecol(const PGresult *res,\n"
"                int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает номер столбца (в пределах его таблицы) для указанного столбца в "
"полученной выборке. Номера столбцов в полученной выборке начинаются с 0, но "
"столбцы в таблице имеют ненулевые номера. <synopsis>\n"
"int PQftablecol(const PGresult *res,\n"
"                int column_number);\n"
"</synopsis>"

#: libpq.xml:3219(para)
msgid ""
"Zero is returned if the column number is out of range, or if the specified "
"column is not a simple reference to a table column, or when using pre-3.0 "
"protocol."
msgstr ""
"В следующих случаях возвращается ноль: если номер столбца выходит за пределы "
"допустимого диапазона; если указанный столбец не является простой ссылкой на "
"столбец таблицы; когда используется протокол версии более ранней, чем 3.0."

#: libpq.xml:3229(function) libpq.xml:5110(function)
msgid "PQfformat"
msgstr "PQfformat"

#: libpq.xml:3230(indexterm)
msgid "<primary>PQfformat</primary>"
msgstr "<primary>PQfformat</primary>"

#: libpq.xml:3236(para)
msgid ""
"Returns the format code indicating the format of the given column. Column "
"numbers start at 0. <synopsis>\n"
"int PQfformat(const PGresult *res,\n"
"              int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает код формата, показывающий формат данного столбца. Номера столбцов "
"начинаются с 0. <synopsis>\n"
"int PQfformat(const PGresult *res,\n"
"              int column_number);\n"
"</synopsis>"

#: libpq.xml:3245(para)
msgid ""
"Format code zero indicates textual data representation, while format code "
"one indicates binary representation. (Other codes are reserved for future "
"definition.)"
msgstr ""
"Значение кода формата, равное нулю, указывает на текстовое представление "
"данных, в то время, как значение, равное единице, означает двоичное "
"представление. (Другие значения кодов зарезервированы для определения в "
"будущем.)"

#: libpq.xml:3255(function)
msgid "PQftype"
msgstr "PQftype"

#: libpq.xml:3256(indexterm)
msgid "<primary>PQftype</primary>"
msgstr "<primary>PQftype</primary>"

#: libpq.xml:3262(para)
msgid ""
"Returns the data type associated with the given column number. The integer "
"returned is the internal OID number of the type. Column numbers start at 0. "
"<synopsis>\n"
"Oid PQftype(const PGresult *res,\n"
"            int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает тип данных, соответствующий данному номеру столбца. Возвращаемое "
"целое значение является внутренним номером OID для этого типа. Номера "
"столбцов начинаются с 0. <synopsis>\n"
"Oid PQftype(const PGresult *res,\n"
"            int column_number);\n"
"</synopsis>"

#: libpq.xml:3272(para)
msgid ""
"You can query the system table <literal>pg_type</literal> to obtain the "
"names and properties of the various data types. The <acronym>OID</acronym>s "
"of the built-in data types are defined in the file <filename>src/include/"
"catalog/pg_type.h</filename> in the source tree."
msgstr ""
"Вы может сделать запрос к системной таблице <literal>pg_type</literal>, "
"чтобы получить имена и свойства различных типов данных. Значения "
"<acronym>OID</acronym> для встроенных типов данных определены в файле "
"<filename>src/include/catalog/pg_type.h</filename> в дереве исходных кодов."

#: libpq.xml:3284(function)
msgid "PQfmod"
msgstr "PQfmod"

#: libpq.xml:3285(indexterm)
msgid "<primary>PQfmod</primary>"
msgstr "<primary>PQfmod</primary>"

#: libpq.xml:3291(para)
msgid ""
"Returns the type modifier of the column associated with the given column "
"number. Column numbers start at 0. <synopsis>\n"
"int PQfmod(const PGresult *res,\n"
"           int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает модификатор типа для столбца, соответствующего данному номеру. "
"Номера столбцов начинаются с 0. <synopsis>\n"
"int PQfmod(const PGresult *res,\n"
"           int column_number);\n"
"</synopsis>"

#: libpq.xml:3300(para)
msgid ""
"The interpretation of modifier values is type-specific; they typically "
"indicate precision or size limits. The value -1 is used to indicate "
"<quote>no information available</quote>. Most data types do not use "
"modifiers, in which case the value is always -1."
msgstr ""
"Интерпретация значений модификатора зависит от типа; они обычно показывают "
"точность или предельные размеры. Значение -1 используется, чтобы показать "
"<quote>нет доступной информации</quote>. Большинство типов данных не "
"используют модификаторов, в таком случае значение всегда будет -1."

#: libpq.xml:3312(function)
msgid "PQfsize"
msgstr "PQfsize"

#: libpq.xml:3313(indexterm)
msgid "<primary>PQfsize</primary>"
msgstr "<primary>PQfsize</primary>"

#: libpq.xml:3319(para)
msgid ""
"Returns the size in bytes of the column associated with the given column "
"number. Column numbers start at 0. <synopsis>\n"
"int PQfsize(const PGresult *res,\n"
"            int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает размер в байтах для столбца, соответствующего данному номеру. "
"Номера столбцов начинаются с 0. <synopsis>\n"
"int PQfsize(const PGresult *res,\n"
"            int column_number);\n"
"</synopsis>"

#: libpq.xml:3328(para)
msgid ""
"<function>PQfsize</function> returns the space allocated for this column in "
"a database row, in other words the size of the server's internal "
"representation of the data type. (Accordingly, it is not really very useful "
"to clients.) A negative value indicates the data type is variable-length."
msgstr ""
"<function>PQfsize</function> возвращает размер пространства, выделенного для "
"этого столбца в строке базы данных, другими словами, это размер внутреннего "
"представления этого типа данных на сервере. (Следовательно, эта информация "
"не является по-настоящему полезной для клиентов.) Отрицательное значение "
"говорит о том, что тип данных имеет переменную длину."

#: libpq.xml:3340(function) libpq.xml:5091(function)
msgid "PQbinaryTuples"
msgstr "PQbinaryTuples"

#: libpq.xml:3341(indexterm)
msgid "<primary>PQbinaryTuples</primary>"
msgstr "<primary>PQbinaryTuples</primary>"

#: libpq.xml:3347(para)
msgid ""
"Returns 1 if the <structname>PGresult</structname> contains binary data and "
"0 if it contains text data. <synopsis>\n"
"int PQbinaryTuples(const PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает 1, если <structname>PGresult</structname> содержит двоичные "
"данные, или 0, если данные текстовые. <synopsis>\n"
"int PQbinaryTuples(const PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3355(para)
msgid ""
"This function is deprecated (except for its use in connection with "
"<command>COPY</command>), because it is possible for a single "
"<structname>PGresult</structname> to contain text data in some columns and "
"binary data in others. <function>PQfformat</function> is preferred. "
"<function>PQbinaryTuples</function> returns 1 only if all columns of the "
"result are binary (format 1)."
msgstr ""
"Эта функция не рекомендуется к использованию (за исключением применения в "
"связи с командой <command>COPY</command>), поскольку один и тот же "
"<structname>PGresult</structname> может содержать в некоторых столбцах "
"текстовые данные, а в остальных &mdash; двоичные. Предпочтительнее "
"использовать <function>PQfformat</function>. <function>PQbinaryTuples</"
"function> возвращает 1, только если все столбцы в выборке являются двоичными "
"(код формата 1)."

#: libpq.xml:3368(function)
msgid "PQgetvalue"
msgstr "PQgetvalue"

#: libpq.xml:3369(indexterm)
msgid "<primary>PQgetvalue</primary>"
msgstr "<primary>PQgetvalue</primary>"

#: libpq.xml:3375(para)
msgid ""
"Returns a single field value of one row of a <structname>PGresult</"
"structname>. Row and column numbers start at 0. The caller should not free "
"the result directly. It will be freed when the associated "
"<structname>PGresult</structname> handle is passed to <function>PQclear</"
"function>. <synopsis>\n"
"char *PQgetvalue(const PGresult *res,\n"
"                 int row_number,\n"
"                 int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает значение одного поля из одной строки, содержащейся в "
"<structname>PGresult</structname>. Номера строк и столбцов начинаются с 0. "
"Вызывающая функция не должна напрямую освобождать память, на которую "
"указывает возвращаемый указатель. Она будет освобождена, когда "
"соответствующий указатель на <structname>PGresult</structname> будет передан "
"функции <function>PQclear</function>.  <synopsis>\n"
"char *PQgetvalue(const PGresult *res,\n"
"                 int row_number,\n"
"                 int column_number);\n"
"</synopsis>"

#: libpq.xml:3388(para)
msgid ""
"For data in text format, the value returned by <function>PQgetvalue</"
"function> is a null-terminated character string representation of the field "
"value. For data in binary format, the value is in the binary representation "
"determined by the data type's <function>typsend</function> and "
"<function>typreceive</function> functions. (The value is actually followed "
"by a zero byte in this case too, but that is not ordinarily useful, since "
"the value is likely to contain embedded nulls.)"
msgstr ""
"Для данных в текстовом формате значение, возвращаемое функцией "
"<function>PQgetvalue</function>, является значением поля, представленным в "
"виде символьной строки с завершающим нулевым символом. Для данных в двоичном "
"формате используется двоичное представление значения. Оно определяется "
"функциями <function>typsend</function> и <function>typreceive</function> для "
"конкретного типа данных. (В этом случае к значению также добавляется нулевой "
"байт, но обычно это не приносит пользы, поскольку вероятно, что значение уже "
"содержит нулевые байты.)"

#: libpq.xml:3399(para)
msgid ""
"An empty string is returned if the field value is null. See "
"<function>PQgetisnull</function> to distinguish null values from empty-"
"string values."
msgstr ""
"Пустая строка возвращается в том случае, когда значение поля отсутствует "
"(null). См. <function>PQgetisnull</function>, чтобы отличать отсутствие "
"значения (null) от значения, равного пустой строке."

#: libpq.xml:3405(para)
msgid ""
"The pointer returned by <function>PQgetvalue</function> points to storage "
"that is part of the <structname>PGresult</structname> structure. One should "
"not modify the data it points to, and one must explicitly copy the data into "
"other storage if it is to be used past the lifetime of the "
"<structname>PGresult</structname> structure itself."
msgstr ""
"Указатель, возвращаемый функцией <function>PQgetvalue</function>, указывает "
"на область хранения, которая является частью структуры <structname>PGresult</"
"structname>. Не следует модифицировать данные, на которые указывает этот "
"указатель, а нужно явно скопировать данные в другую область хранения, если "
"предполагается их использовать за пределами времени жизни самой структуры "
"<structname>PGresult</structname>."

#: libpq.xml:3418(function)
msgid "PQgetisnull"
msgstr "PQgetisnull"

#: libpq.xml:3419(indexterm)
msgid "<primary>PQgetisnull</primary>"
msgstr "<primary>PQgetisnull</primary>"

#: libpq.xml:3422(indexterm)
msgid ""
"<primary>null value</primary> <secondary sortas=\"libpq\">in libpq</"
"secondary>"
msgstr ""
"<primary>значение NULL</primary> <secondary sortas=\"libpq\">в libpq</"
"secondary>"

#: libpq.xml:3429(para)
msgid ""
"Tests a field for a null value. Row and column numbers start at 0. "
"<synopsis>\n"
"int PQgetisnull(const PGresult *res,\n"
"                int row_number,\n"
"                int column_number);\n"
"</synopsis>"
msgstr ""
"Проверяет поле на предмет отсутствия значения (null). Номера строк и "
"столбцов начинаются с 0. <synopsis>\n"
"int PQgetisnull(const PGresult *res,\n"
"                int row_number,\n"
"                int column_number);\n"
"</synopsis>"

#: libpq.xml:3439(para)
msgid ""
"This function returns 1 if the field is null and 0 if it contains a non-null "
"value. (Note that <function>PQgetvalue</function> will return an empty "
"string, not a null pointer, for a null field.)"
msgstr ""
"Эта функция возвращает 1, если значение в поле отсутствует (null), и 0, если "
"поле содержит непустое (non-null) значение. (Обратите внимание, что "
"<function>PQgetvalue</function> возвратит пустую строку, а не нулевой "
"указатель, если значение в поле отсутствует.)"

#: libpq.xml:3450(function)
msgid "PQgetlength"
msgstr "PQgetlength"

#: libpq.xml:3451(indexterm)
msgid "<primary>PQgetlength</primary>"
msgstr "<primary>PQgetlength</primary>"

#: libpq.xml:3456(para)
msgid ""
"Returns the actual length of a field value in bytes. Row and column numbers "
"start at 0. <synopsis>\n"
"int PQgetlength(const PGresult *res,\n"
"                int row_number,\n"
"                int column_number);\n"
"</synopsis>"
msgstr ""
"Возвращает фактическую длину значения поля в байтах. Номера строк и столбцов "
"начинаются с 0. <synopsis>\n"
"int PQgetlength(const PGresult *res,\n"
"                int row_number,\n"
"                int column_number);\n"
"</synopsis>"

#: libpq.xml:3466(para)
msgid ""
"This is the actual data length for the particular data value, that is, the "
"size of the object pointed to by <function>PQgetvalue</function>. For text "
"data format this is the same as <function>strlen()</function>. For binary "
"format this is essential information. Note that one should <emphasis>not</"
"emphasis> rely on <function>PQfsize</function> to obtain the actual data "
"length."
msgstr ""
"Это фактическая длина данных для конкретного значения данных, то есть размер "
"объекта, на который указывает <function>PQgetvalue</function>. Для "
"текстового формата данных это то же самое, что <function>strlen()</"
"function>. Для двоичного же формата это существенная информация. Обратите "
"внимание, что <emphasis>не</emphasis> следует полагаться на "
"<function>PQfsize</function>, чтобы получить фактическую длину данных."

#: libpq.xml:3480(function)
msgid "PQnparams"
msgstr "PQnparams"

#: libpq.xml:3481(indexterm)
msgid "<primary>PQnparams</primary>"
msgstr "<primary>PQnparams</primary>"

#: libpq.xml:3487(para)
msgid ""
"Returns the number of parameters of a prepared statement. <synopsis>\n"
"int PQnparams(const PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает число параметров подготовленного оператора. <synopsis>\n"
"int PQnparams(const PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3494(para) libpq.xml:3519(para)
msgid ""
"This function is only useful when inspecting the result of "
"<function>PQdescribePrepared</function>. For other types of queries it will "
"return zero."
msgstr ""
"Эта функция полезна только при исследовании результата работы функции "
"<function>PQdescribePrepared</function>. Для других типов запросов она "
"возвратит ноль."

#: libpq.xml:3504(function)
msgid "PQparamtype"
msgstr "PQparamtype"

#: libpq.xml:3505(indexterm)
msgid "<primary>PQparamtype</primary>"
msgstr "<primary>PQparamtype</primary>"

#: libpq.xml:3511(para)
msgid ""
"Returns the data type of the indicated statement parameter. Parameter "
"numbers start at 0. <synopsis>\n"
"Oid PQparamtype(const PGresult *res, int param_number);\n"
"</synopsis>"
msgstr ""
"Возвращает тип данных для указанного параметра оператора. Номера параметров "
"начинаются с 0. <synopsis>\n"
"Oid PQparamtype(const PGresult *res, int param_number);\n"
"</synopsis>"

#: libpq.xml:3529(function)
msgid "PQprint"
msgstr "PQprint"

#: libpq.xml:3530(indexterm)
msgid "<primary>PQprint</primary>"
msgstr "<primary>PQprint</primary>"

#: libpq.xml:3536(para)
msgid ""
"Prints out all the rows and, optionally, the column names to the specified "
"output stream. <synopsis>\n"
"void PQprint(FILE *fout,      /* output stream */\n"
"             const PGresult *res,\n"
"             const PQprintOpt *po);\n"
"typedef struct\n"
"{\n"
"    pqbool  header;      /* print output field headings and row count */\n"
"    pqbool  align;       /* fill align the fields */\n"
"    pqbool  standard;    /* old brain dead format */\n"
"    pqbool  html3;       /* output HTML tables */\n"
"    pqbool  expanded;    /* expand tables */\n"
"    pqbool  pager;       /* use pager for output if needed */\n"
"    char    *fieldSep;   /* field separator */\n"
"    char    *tableOpt;   /* attributes for HTML table element */\n"
"    char    *caption;    /* HTML table caption */\n"
"    char    **fieldName; /* null-terminated array of replacement field names "
"*/\n"
"} PQprintOpt;\n"
"</synopsis>"
msgstr ""
"Выводит все строки и, по выбору, имена столбцов в указанный поток вывода. "
"<synopsis>\n"
"void PQprint(FILE *fout,      /* поток вывода */\n"
"             const PGresult *res,\n"
"             const PQprintOpt *po);\n"
"typedef struct\n"
"{\n"
"    pqbool  header;      /* печатать заголовки полей и счётчик строк */\n"
"    pqbool  align;       /* выравнивать поля */\n"
"    pqbool  standard;    /* старый формат */\n"
"    pqbool  html3;       /* выводить HTML-таблицы */\n"
"    pqbool  expanded;    /* расширять таблицы */\n"
"    pqbool  pager;       /* использовать программу для постраничного "
"просмотра, если нужно */\n"
"    char    *fieldSep;   /* разделитель полей */\n"
"    char    *tableOpt;   /* атрибуты для HTML-таблицы */\n"
"    char    *caption;    /* заголовок HTML-таблицы */\n"
"    char    **fieldName; /* массив заменителей для имён полей, завершающийся "
"нулевым символом */\n"
"} PQprintOpt;\n"
"</synopsis>"

#: libpq.xml:3559(para)
msgid ""
"This function was formerly used by <application>psql</application> to print "
"query results, but this is no longer the case. Note that it assumes all the "
"data is in text format."
msgstr ""
"Эту функцию прежде использовала утилита <application>psql</application> для "
"вывода результатов запроса, но больше она её не использует. Обратите "
"внимание, предполагается, что все данные представлены в текстовом формате."

#: libpq.xml:3570(title)
msgid "Retrieving Other Result Information"
msgstr "Получение другой информации о результате"

#: libpq.xml:3572(para)
msgid ""
"These functions are used to extract other information from "
"<structname>PGresult</structname> objects."
msgstr ""
"Эти функции используются для получения остальной информации из объектов "
"<structname>PGresult</structname>."

#: libpq.xml:3580(function)
msgid "PQcmdStatus"
msgstr "PQcmdStatus"

#: libpq.xml:3581(indexterm)
msgid "<primary>PQcmdStatus</primary>"
msgstr "<primary>PQcmdStatus</primary>"

#: libpq.xml:3587(para)
msgid ""
"Returns the command status tag from the SQL command that generated the "
"<structname>PGresult</structname>. <synopsis>\n"
"char *PQcmdStatus(PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает дескриптор статуса для SQL-команды, которая сгенерировала "
"<structname>PGresult</structname>. <synopsis>\n"
"char *PQcmdStatus(PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3595(para)
msgid ""
"Commonly this is just the name of the command, but it might include "
"additional data such as the number of rows processed. The caller should not "
"free the result directly. It will be freed when the associated "
"<structname>PGresult</structname> handle is passed to <function>PQclear</"
"function>."
msgstr ""
"Как правило, это просто имя команды, но могут быть включены и дополнительные "
"сведения, такие, как число обработанных строк. Вызывающая функция не должна "
"напрямую освобождать память, на которую указывает возвращаемый указатель. "
"Она будет освобождена, когда соответствующий указатель на "
"<structname>PGresult</structname> будет передан функции <function>PQclear</"
"function>."

#: libpq.xml:3607(function)
msgid "PQcmdTuples"
msgstr "PQcmdTuples"

#: libpq.xml:3608(indexterm)
msgid "<primary>PQcmdTuples</primary>"
msgstr "<primary>PQcmdTuples</primary>"

#: libpq.xml:3614(para)
msgid ""
"Returns the number of rows affected by the SQL command. <synopsis>\n"
"char *PQcmdTuples(PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает число строк, которые затронула SQL-команда. <synopsis>\n"
"char *PQcmdTuples(PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3621(para)
msgid ""
"This function returns a string containing the number of rows affected by the "
"<acronym>SQL</acronym> statement that generated the <structname>PGresult</"
"structname>. This function can only be used following the execution of a "
"<command>SELECT</command>, <command>CREATE TABLE AS</command>, "
"<command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</"
"command>, <command>MOVE</command>, <command>FETCH</command>, or "
"<command>COPY</command> statement, or an <command>EXECUTE</command> of a "
"prepared query that contains an <command>INSERT</command>, <command>UPDATE</"
"command>, or <command>DELETE</command> statement. If the command that "
"generated the <structname>PGresult</structname> was anything else, "
"<function>PQcmdTuples</function> returns an empty string. The caller should "
"not free the return value directly. It will be freed when the associated "
"<structname>PGresult</structname> handle is passed to <function>PQclear</"
"function>."
msgstr ""
"Эта функция возвращает строковое значение, содержащее число строк, которые "
"затронул <acronym>SQL</acronym>-оператор, сгенерировавший данный "
"<structname>PGresult</structname>. Эту функцию можно использовать только "
"сразу после выполнения команд <command>SELECT</command>, <command>CREATE "
"TABLE AS</command>, <command>INSERT</command>, <command>UPDATE</command>, "
"<command>DELETE</command>, <command>MOVE</command>, <command>FETCH</command> "
"или <command>COPY</command>, а также после оператора <command>EXECUTE</"
"command>, выполнившего подготовленный запрос, содержащий команды "
"<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>. Если команда, которая сгенерировала <structname>PGresult</"
"structname>, была какой-то иной, то <function>PQcmdTuples</function> "
"возвращает пустую строку. Вызывающая функция не должна напрямую освобождать "
"память, на которую указывает возвращаемый указатель. Она будет освобождена, "
"когда соответствующий указатель на <structname>PGresult</structname> будет "
"передан функции <function>PQclear</function>."

#: libpq.xml:3641(function)
msgid "PQoidValue"
msgstr "PQoidValue"

#: libpq.xml:3642(indexterm)
msgid "<primary>PQoidValue</primary>"
msgstr "<primary>PQoidValue</primary>"

#: libpq.xml:3649(indexterm)
msgid "<primary>OID</primary><secondary>in libpq</secondary>"
msgstr "<primary>OID</primary> <secondary>в libpq</secondary>"

#: libpq.xml:3648(para)
msgid ""
"Returns the OID<placeholder-1/> of the inserted row, if the <acronym>SQL</"
"acronym> command was an <command>INSERT</command> that inserted exactly one "
"row into a table that has OIDs, or a <command>EXECUTE</command> of a "
"prepared query containing a suitable <command>INSERT</command> statement. "
"Otherwise, this function returns <literal>InvalidOid</literal>. This "
"function will also return <literal>InvalidOid</literal> if the table "
"affected by the <command>INSERT</command> statement does not contain OIDs. "
"<synopsis>\n"
"Oid PQoidValue(const PGresult *res);\n"
"</synopsis>"
msgstr ""
"Возвращает OID<placeholder-1/> вставленной строки, если <acronym>SQL</"
"acronym>-команда была командой <command>INSERT</command>, которая вставила "
"ровно одну строку в таблицу, имеющую идентификаторы OID, или командой "
"<command>EXECUTE</command>, которая выполнила подготовленный запрос, "
"содержащий соответствующий оператор <command>INSERT</command>. В противном "
"случае эта функция возвращает <literal>InvalidOid</literal>. Эта функция "
"также возвратит <literal>InvalidOid</literal>, если таблица, затронутая "
"командой <command>INSERT</command>, не содержит идентификаторов OID. "
"<synopsis>\n"
"Oid PQoidValue(const PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3666(function)
msgid "PQoidStatus"
msgstr "PQoidStatus"

#: libpq.xml:3667(indexterm)
msgid "<primary>PQoidStatus</primary>"
msgstr "<primary>PQoidStatus</primary>"

#: libpq.xml:3673(para)
msgid ""
"This function is deprecated in favor of <function>PQoidValue</function> and "
"is not thread-safe. It returns a string with the OID of the inserted row, "
"while <function>PQoidValue</function> returns the OID value. <synopsis>\n"
"char *PQoidStatus(const PGresult *res);\n"
"</synopsis>"
msgstr ""
"Эта функция считается не рекомендуемой к использованию (в качестве замены "
"служит <function>PQoidValue</function>), а также она не отвечает требованиям "
"потоковой безопасности. Она возвращает строковое значение, содержащее OID "
"вставленной строки, в то время как <function>PQoidValue</function> "
"возвращает значение OID. <synopsis>\n"
"char *PQoidStatus(const PGresult *res);\n"
"</synopsis>"

#: libpq.xml:3690(title)
msgid "Escaping Strings for Inclusion in SQL Commands"
msgstr "Экранирование строковых значений для включения в SQL-команды"

#: libpq.xml:3692(indexterm)
msgid "<primary>escaping strings</primary> <secondary>in libpq</secondary>"
msgstr ""
"<primary>экранированные строки</primary> <secondary>в libpq</secondary>"

#: libpq.xml:3700(function)
msgid "PQescapeLiteral"
msgstr "PQescapeLiteral"

#: libpq.xml:3701(indexterm)
msgid "<primary>PQescapeLiteral</primary>"
msgstr "<primary>PQescapeLiteral</primary>"

#: libpq.xml:3708(synopsis)
#, no-wrap
msgid "char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);"
msgstr "char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);"

#: libpq.xml:3713(para)
msgid ""
"<function>PQescapeLiteral</function> escapes a string for use within an SQL "
"command. This is useful when inserting data values as literal constants in "
"SQL commands. Certain characters (such as quotes and backslashes) must be "
"escaped to prevent them from being interpreted specially by the SQL parser. "
"<function>PQescapeLiteral</function> performs this operation."
msgstr ""
"<function>PQescapeLiteral</function> экранирует строковое значение для "
"использования внутри SQL-команды. Это полезно при вставке в SQL-команды "
"значений данных в виде литеральных констант. Определённые символы (такие, "
"как кавычки и символы обратной косой черты) должны экранироваться, чтобы "
"предотвратить их специальную интерпретацию синтаксическим анализатором языка "
"SQL. <function>PQescapeLiteral</function> выполняет эту операцию."

#: libpq.xml:3722(para)
msgid ""
"<function>PQescapeLiteral</function> returns an escaped version of the "
"<parameter>str</parameter> parameter in memory allocated with "
"<function>malloc()</function>. This memory should be freed using "
"<function>PQfreemem()</function> when the result is no longer needed. A "
"terminating zero byte is not required, and should not be counted in "
"<parameter>length</parameter>. (If a terminating zero byte is found before "
"<parameter>length</parameter> bytes are processed, "
"<function>PQescapeLiteral</function> stops at the zero; the behavior is thus "
"rather like <function>strncpy</function>.) The return string has all special "
"characters replaced so that they can be properly processed by the "
"<productname>PostgreSQL</productname> string literal parser. A terminating "
"zero byte is also added. The single quotes that must surround "
"<productname>PostgreSQL</productname> string literals are included in the "
"result string."
msgstr ""
"<function>PQescapeLiteral</function> возвращает экранированную версию "
"параметра <parameter>str</parameter>, размещённую в области памяти, "
"распределённой с помощью функции <function>malloc()</function>. Эту память "
"нужно освобождать с помощью функции <function>PQfreemem()</function>, когда "
"возвращённое значение больше не требуется. Завершающий нулевой байт не нужен "
"и не должен учитываться в параметре <parameter>length</parameter>. (Если "
"завершающий нулевой байт был найден до того, как были обработаны "
"<parameter>length</parameter> байтов, то <function>PQescapeLiteral</"
"function> останавливает работу на нулевом байте; таким образом, поведение "
"функции напоминает <function>strncpy</function>.) В возвращённой строке все "
"специальные символы заменены таким образом, что синтаксический анализатор "
"строковых литералов <productname>PostgreSQL</productname> может обработать "
"их должным образом. Завершающий нулевой байт также будет добавлен. Одинарные "
"кавычки, которые должны окружать строковые литералы <productname>PostgreSQL</"
"productname>, включаются в результирующую строку."

#: libpq.xml:3739(para)
msgid ""
"On error, <function>PQescapeLiteral</function> returns <symbol>NULL</symbol> "
"and a suitable message is stored in the <parameter>conn</parameter> object."
msgstr ""
"В случае ошибки <function>PQescapeLiteral</function> возвращает "
"<symbol>NULL</symbol>, и в объект <parameter>conn</parameter> помещается "
"соответствующее сообщение."

#: libpq.xml:3745(para)
msgid ""
"It is especially important to do proper escaping when handling strings that "
"were received from an untrustworthy source. Otherwise there is a security "
"risk: you are vulnerable to <quote>SQL injection</quote> attacks wherein "
"unwanted SQL commands are fed to your database."
msgstr ""
"Особенно важно выполнять надлежащее экранирование при обработке строк, "
"полученных из ненадёжных источников. В противном случае ваша безопасность "
"подвергается риску из-за уязвимости в отношении атак с использованием "
"<quote>SQL-инъекций</quote>, с помощью которых нежелательные SQL-команды "
"направляются в вашу базу данных."

#: libpq.xml:3754(para)
msgid ""
"Note that it is not necessary nor correct to do escaping when a data value "
"is passed as a separate parameter in <function>PQexecParams</function> or "
"its sibling routines."
msgstr ""
"Обратите внимание, что нет необходимости (и это будет даже некорректно) "
"экранировать значения данных, передаваемых в виде отдельных параметров в "
"функцию <function>PQexecParams</function> или родственные ей функции."

#: libpq.xml:3764(function)
msgid "PQescapeIdentifier"
msgstr "PQescapeIdentifier"

#: libpq.xml:3765(indexterm)
msgid "<primary>PQescapeIdentifier</primary>"
msgstr "<primary>PQescapeIdentifier</primary>"

#: libpq.xml:3772(synopsis)
#, no-wrap
msgid "char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);"
msgstr "char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);"

#: libpq.xml:3777(para)
msgid ""
"<function>PQescapeIdentifier</function> escapes a string for use as an SQL "
"identifier, such as a table, column, or function name. This is useful when a "
"user-supplied identifier might contain special characters that would "
"otherwise not be interpreted as part of the identifier by the SQL parser, or "
"when the identifier might contain upper case characters whose case should be "
"preserved."
msgstr ""
"<function>PQescapeIdentifier</function> экранирует строку, предназначенную "
"для использования в качестве идентификатора SQL, такого, как таблица, "
"столбец или имя функции. Это полезно, когда идентификатор, выбранный "
"пользователем, может содержать специальные символы, которые в противном "
"случае не интерпретировались бы синтаксическим анализатором SQL, как часть "
"идентификатора, или когда идентификатор может содержать символы верхнего "
"регистра, и этот регистр требуется сохранить."

#: libpq.xml:3786(para)
msgid ""
"<function>PQescapeIdentifier</function> returns a version of the "
"<parameter>str</parameter> parameter escaped as an SQL identifier in memory "
"allocated with <function>malloc()</function>. This memory must be freed "
"using <function>PQfreemem()</function> when the result is no longer needed. "
"A terminating zero byte is not required, and should not be counted in "
"<parameter>length</parameter>. (If a terminating zero byte is found before "
"<parameter>length</parameter> bytes are processed, "
"<function>PQescapeIdentifier</function> stops at the zero; the behavior is "
"thus rather like <function>strncpy</function>.) The return string has all "
"special characters replaced so that it will be properly processed as an SQL "
"identifier. A terminating zero byte is also added. The return string will "
"also be surrounded by double quotes."
msgstr ""
"<function>PQescapeIdentifier</function> возвращает версию параметра "
"<parameter>str</parameter>, экранированную как SQL-идентификатор, и "
"размещённую в области памяти, распределённой с помощью функции "
"<function>malloc()</function>. Эту память нужно освобождать с помощью "
"функции <function>PQfreemem()</function>, когда возвращённое значение больше "
"не требуется. Завершающий нулевой байт не нужен и не должен учитываться в "
"параметре <parameter>length</parameter>. (Если завершающий нулевой байт был "
"найден до того, как были обработаны <parameter>length</parameter> байтов, то "
"<function>PQescapeIdentifier</function> останавливает работу на нулевом "
"байте; таким образом, поведение функции напоминает <function>strncpy</"
"function>.) В возвращённой строке все специальные символы заменены таким "
"образом, что она будет надлежащим образом обработана, как SQL-идентификатор. "
"Завершающий нулевой байт также будет добавлен. Возвращённая строка также "
"будет заключена в двойные кавычки."

#: libpq.xml:3802(para)
msgid ""
"On error, <function>PQescapeIdentifier</function> returns <symbol>NULL</"
"symbol> and a suitable message is stored in the <parameter>conn</parameter> "
"object."
msgstr ""
"В случае ошибки <function>PQescapeIdentifier</function> возвращает "
"<symbol>NULL</symbol>, и в объект <parameter>conn</parameter> помещается "
"соответствующее сообщение."

#: libpq.xml:3808(para)
msgid ""
"As with string literals, to prevent SQL injection attacks, SQL identifiers "
"must be escaped when they are received from an untrustworthy source."
msgstr ""
"Как и в случае со строковыми литералами, для того чтобы предотвратить атаки "
"с помощью SQL-инъекций, SQL-идентификаторы должны экранироваться, когда они "
"получены из ненадёжного источника."

#: libpq.xml:3819(function)
msgid "PQescapeStringConn"
msgstr "PQescapeStringConn"

#: libpq.xml:3820(indexterm)
msgid "<primary>PQescapeStringConn</primary>"
msgstr "<primary>PQescapeStringConn</primary>"

#: libpq.xml:3827(synopsis)
#, no-wrap
msgid ""
"size_t PQescapeStringConn(PGconn *conn,\n"
"                          char *to, const char *from, size_t length,\n"
"                          int *error);"
msgstr ""
"size_t PQescapeStringConn(PGconn *conn,\n"
"                          char *to, const char *from, size_t length,\n"
"                          int *error);"

#: libpq.xml:3834(para)
msgid ""
"<function>PQescapeStringConn</function> escapes string literals, much like "
"<function>PQescapeLiteral</function>. Unlike <function>PQescapeLiteral</"
"function>, the caller is responsible for providing an appropriately sized "
"buffer. Furthermore, <function>PQescapeStringConn</function> does not "
"generate the single quotes that must surround <productname>PostgreSQL</"
"productname> string literals; they should be provided in the SQL command "
"that the result is inserted into. The parameter <parameter>from</parameter> "
"points to the first character of the string that is to be escaped, and the "
"<parameter>length</parameter> parameter gives the number of bytes in this "
"string. A terminating zero byte is not required, and should not be counted "
"in <parameter>length</parameter>. (If a terminating zero byte is found "
"before <parameter>length</parameter> bytes are processed, "
"<function>PQescapeStringConn</function> stops at the zero; the behavior is "
"thus rather like <function>strncpy</function>.) <parameter>to</parameter> "
"shall point to a buffer that is able to hold at least one more byte than "
"twice the value of <parameter>length</parameter>, otherwise the behavior is "
"undefined. Behavior is likewise undefined if the <parameter>to</parameter> "
"and <parameter>from</parameter> strings overlap."
msgstr ""
"<function>PQescapeStringConn</function> экранирует строковые литералы "
"наподобие <function>PQescapeLiteral</function>. Но, в отличие от "
"<function>PQescapeLiteral</function>, за предоставление буфера надлежащего "
"размера отвечает вызывающая функция. Более того, "
"<function>PQescapeStringConn</function> не добавляет одинарные кавычки, "
"которые должны окружать строковые литералы <productname>PostgreSQL</"
"productname>; они должны быть включены в SQL-команду, в которую вставляется "
"результирующая строка. Параметр <parameter>from</parameter> указывает на "
"первый символ строки, которая должна экранироваться, а параметр "
"<parameter>length</parameter> задаёт число байтов в этой строке. Завершающий "
"нулевой байт не требуется и не должен учитываться в параметре "
"<parameter>length</parameter>. (Если завершающий нулевой байт был найден до "
"того, как были обработаны <parameter>length</parameter> байтов, то "
"<function>PQescapeStringConn</function> останавливает работу на нулевом "
"байте; таким образом, поведение функции напоминает <function>strncpy</"
"function>.) Параметр <parameter>to</parameter> должен указывать на буфер, "
"который сможет вместить как минимум на один байт больше, чем предписывает "
"удвоенное значение параметра <parameter>length</parameter>, в противном "
"случае поведение функции не определено. Поведение будет также не определено, "
"если строки <parameter>to</parameter> и <parameter>from</parameter> "
"перекрываются."

#: libpq.xml:3855(para)
msgid ""
"If the <parameter>error</parameter> parameter is not <symbol>NULL</symbol>, "
"then <literal>*error</literal> is set to zero on success, nonzero on error. "
"Presently the only possible error conditions involve invalid multibyte "
"encoding in the source string. The output string is still generated on "
"error, but it can be expected that the server will reject it as malformed. "
"On error, a suitable message is stored in the <parameter>conn</parameter> "
"object, whether or not <parameter>error</parameter> is <symbol>NULL</symbol>."
msgstr ""
"Если параметр <parameter>error</parameter> не равен <symbol>NULL</symbol>, "
"тогда значение <literal>*error</literal> устанавливается равным нулю в "
"случае успешной работы и не равным нулю в случае ошибки. В настоящее время "
"единственным возможным условием возникновения ошибки является неверная "
"мультибайтовая кодировка в исходной строке. Выходная строка формируется даже "
"при наличии ошибки, но можно ожидать, что сервер отвергнет её как неверно "
"сформированную. В случае ошибки в объект <parameter>conn</parameter> "
"записывается соответствующее сообщение независимо от того, равно ли "
"<symbol>NULL</symbol> значение параметра <parameter>error</parameter>."

#: libpq.xml:3865(para)
msgid ""
"<function>PQescapeStringConn</function> returns the number of bytes written "
"to <parameter>to</parameter>, not including the terminating zero byte."
msgstr ""
"<function>PQescapeStringConn</function> возвращает число байтов, записанных "
"по адресу <parameter>to</parameter>, не включая завершающий нулевой байт."

#: libpq.xml:3874(function)
msgid "PQescapeString"
msgstr "PQescapeString"

#: libpq.xml:3875(indexterm)
msgid "<primary>PQescapeString</primary>"
msgstr "<primary>PQescapeString</primary>"

#: libpq.xml:3881(para)
msgid ""
"<function>PQescapeString</function> is an older, deprecated version of "
"<function>PQescapeStringConn</function>. <synopsis>\n"
"size_t PQescapeString (char *to, const char *from, size_t length);\n"
"</synopsis>"
msgstr ""
"<function>PQescapeString</function> является более старой, не "
"рекомендованной к использованию версией функции "
"<function>PQescapeStringConn</function>. <synopsis>\n"
"size_t PQescapeString (char *to, const char *from, size_t length);\n"
"</synopsis>"

#: libpq.xml:3889(para)
msgid ""
"The only difference from <function>PQescapeStringConn</function> is that "
"<function>PQescapeString</function> does not take <structname>PGconn</"
"structname> or <parameter>error</parameter> parameters. Because of this, it "
"cannot adjust its behavior depending on the connection properties (such as "
"character encoding) and therefore <emphasis>it might give the wrong results</"
"emphasis>. Also, it has no way to report error conditions."
msgstr ""
"Единственное отличие от <function>PQescapeStringConn</function> состоит в "
"том, что функция <function>PQescapeString</function> не принимает "
"<structname>PGconn</structname> или <parameter>error</parameter> в качестве "
"параметров. Из-за этого она не может скорректировать своё поведение в "
"зависимости от свойств подключения (таких, как кодировка символов) и, "
"следовательно, <emphasis>она может выдавать неверные результаты</emphasis>. "
"Также она не имеет способа сообщить об ошибках."

#: libpq.xml:3899(para)
msgid ""
"<function>PQescapeString</function> can be used safely in client programs "
"that work with only one <productname>PostgreSQL</productname> connection at "
"a time (in this case it can find out what it needs to know <quote>behind the "
"scenes</quote>). In other contexts it is a security hazard and should be "
"avoided in favor of <function>PQescapeStringConn</function>."
msgstr ""
"<function>PQescapeString</function> может безопасно использоваться в "
"клиентских программах, которые работают лишь с одним подключением к "
"<productname>PostgreSQL</productname> за один раз (в этом случае функция "
"может найти то, что ей нужно знать, <quote>за кулисами</quote>). В других "
"контекстах её использование несёт в себе угрозу безопасности и его следует "
"избегать в пользу применения функции <function>PQescapeStringConn</function>."

#: libpq.xml:3912(function)
msgid "PQescapeByteaConn"
msgstr "PQescapeByteaConn"

#: libpq.xml:3913(indexterm)
msgid "<primary>PQescapeByteaConn</primary>"
msgstr "<primary>PQescapeByteaConn</primary>"

#: libpq.xml:3919(para)
msgid ""
"Escapes binary data for use within an SQL command with the type <type>bytea</"
"type>. As with <function>PQescapeStringConn</function>, this is only used "
"when inserting data directly into an SQL command string. <synopsis>\n"
"unsigned char *PQescapeByteaConn(PGconn *conn,\n"
"                                 const unsigned char *from,\n"
"                                 size_t from_length,\n"
"                                 size_t *to_length);\n"
"</synopsis>"
msgstr ""
"Экранирует двоичные данные для их использования внутри SQL-команды с типом "
"данных <type>bytea</type>. Как и в случае с <function>PQescapeStringConn</"
"function>, эта функция применяется только тогда, когда данные вставляются "
"непосредственно в строку SQL-команды. <synopsis>\n"
"unsigned char *PQescapeByteaConn(PGconn *conn,\n"
"                                 const unsigned char *from,\n"
"                                 size_t from_length,\n"
"                                 size_t *to_length);\n"
"</synopsis>"

#: libpq.xml:3931(para)
msgid ""
"Certain byte values must be escaped when used as part of a <type>bytea</"
"type> literal in an <acronym>SQL</acronym> statement. "
"<function>PQescapeByteaConn</function> escapes bytes using either hex "
"encoding or backslash escaping. See <xref linkend=\"datatype-binary\"/> for "
"more information."
msgstr ""
"Байты, имеющие определённые значения, должны экранироваться, когда они "
"используются в качестве составной части литерала, имеющего тип <type>bytea</"
"type>, в <acronym>SQL</acronym>-операторе. <function>PQescapeByteaConn</"
"function> экранирует байты, используя либо hex-кодирование, либо "
"экранирование с помощью обратной косой черты. См. <xref remap=\"4\" linkend="
"\"datatype-binary\"/> для получения дополнительной информации."

#: libpq.xml:3939(para)
msgid ""
"The <parameter>from</parameter> parameter points to the first byte of the "
"string that is to be escaped, and the <parameter>from_length</parameter> "
"parameter gives the number of bytes in this binary string. (A terminating "
"zero byte is neither necessary nor counted.) The <parameter>to_length</"
"parameter> parameter points to a variable that will hold the resultant "
"escaped string length. This result string length includes the terminating "
"zero byte of the result."
msgstr ""
"Параметр <parameter>from</parameter> указывает на первый байт строки, "
"которая должна экранироваться, а параметр <parameter>from_length</parameter> "
"задаёт число байтов в этой двоичной строке. (Завершающий нулевой байт не "
"нужен и не учитывается.) Параметр <parameter>to_length</parameter> указывает "
"на переменную, которая будет содержать длину результирующей экранированной "
"строки. Эта длина включает завершающий нулевой байт результирующей строки."

#: libpq.xml:3950(para)
msgid ""
"<function>PQescapeByteaConn</function> returns an escaped version of the "
"<parameter>from</parameter> parameter binary string in memory allocated with "
"<function>malloc()</function>. This memory should be freed using "
"<function>PQfreemem()</function> when the result is no longer needed. The "
"return string has all special characters replaced so that they can be "
"properly processed by the <productname>PostgreSQL</productname> string "
"literal parser, and the <type>bytea</type> input function. A terminating "
"zero byte is also added. The single quotes that must surround "
"<productname>PostgreSQL</productname> string literals are not part of the "
"result string."
msgstr ""
"<function>PQescapeByteaConn</function> возвращает экранированную версию "
"двоичной строки, на которую указывает параметр <parameter>from</parameter>, "
"и размещает её в памяти, распределённой с помощью <function>malloc()</"
"function>. Эта память должна быть освобождена с помощью функции "
"<function>PQfreemem()</function>, когда результирующая строка больше не "
"нужна. В возвращаемой строке все специальные символы заменены так, чтобы "
"синтаксический анализатор литеральных строк <productname>PostgreSQL</"
"productname> и функция ввода для типа <type>bytea</type> могли обработать их "
"надлежащим образом. Завершающий нулевой байт также добавляется. Одинарные "
"кавычки, которые должны окружать строковые литералы <productname>PostgreSQL</"
"productname>, не являются частью результирующей строки."

#: libpq.xml:3963(para)
msgid ""
"On error, a null pointer is returned, and a suitable error message is stored "
"in the <parameter>conn</parameter> object. Currently, the only possible "
"error is insufficient memory for the result string."
msgstr ""
"В случае ошибки возвращается нулевой указатель, и соответствующее сообщение "
"об ошибке записывается в объект <parameter>conn</parameter>. В настоящее "
"время единственной возможной ошибкой может быть нехватка памяти для "
"результирующей строки."

#: libpq.xml:3973(function)
msgid "PQescapeBytea"
msgstr "PQescapeBytea"

#: libpq.xml:3974(indexterm)
msgid "<primary>PQescapeBytea</primary>"
msgstr "<primary>PQescapeBytea</primary>"

#: libpq.xml:3980(para)
msgid ""
"<function>PQescapeBytea</function> is an older, deprecated version of "
"<function>PQescapeByteaConn</function>. <synopsis>\n"
"unsigned char *PQescapeBytea(const unsigned char *from,\n"
"                             size_t from_length,\n"
"                             size_t *to_length);\n"
"</synopsis>"
msgstr ""
"<function>PQescapeBytea</function> является более старой, не рекомендуемой к "
"использованию версией функции <function>PQescapeByteaConn</function>. "
"<synopsis>\n"
"unsigned char *PQescapeBytea(const unsigned char *from,\n"
"                             size_t from_length,\n"
"                             size_t *to_length);\n"
"</synopsis>"

#: libpq.xml:3990(para)
msgid ""
"The only difference from <function>PQescapeByteaConn</function> is that "
"<function>PQescapeBytea</function> does not take a <structname>PGconn</"
"structname> parameter. Because of this, <function>PQescapeBytea</function> "
"can only be used safely in client programs that use a single "
"<productname>PostgreSQL</productname> connection at a time (in this case it "
"can find out what it needs to know <quote>behind the scenes</quote>). It "
"<emphasis>might give the wrong results</emphasis> if used in programs that "
"use multiple database connections (use <function>PQescapeByteaConn</"
"function> in such cases)."
msgstr ""
"Единственное отличие от <function>PQescapeByteaConn</function> состоит в "
"том, что функция <function>PQescapeBytea</function> не принимает "
"<structname>PGconn</structname> в качестве параметра. Из-за этого "
"<function>PQescapeBytea</function> может безопасно использоваться в "
"клиентских программах, которые работают лишь с одним подключением к "
"<productname>PostgreSQL</productname> за один раз (в этом случае функция "
"может найти то, что ей нужно знать, <quote>за кулисами</quote>). Она "
"<emphasis>может выдавать неверные результаты</emphasis> при использовании в "
"программах, которые формируют множественные подключения к базе данных (в "
"таких случаях используйте <function>PQescapeByteaConn</function>)."

#: libpq.xml:4006(function)
msgid "PQunescapeBytea"
msgstr "PQunescapeBytea"

#: libpq.xml:4007(indexterm)
msgid "<primary>PQunescapeBytea</primary>"
msgstr "<primary>PQunescapeBytea</primary>"

#: libpq.xml:4013(para)
msgid ""
"Converts a string representation of binary data into binary data &mdash; the "
"reverse of <function>PQescapeBytea</function>. This is needed when "
"retrieving <type>bytea</type> data in text format, but not when retrieving "
"it in binary format. <synopsis>\n"
"unsigned char *PQunescapeBytea(const unsigned char *from, size_t "
"*to_length);\n"
"</synopsis>"
msgstr ""
"Преобразует строковое представление двоичных данных в двоичные данные "
"&mdash; является обратной функцией к функции <function>PQescapeBytea</"
"function>. Она нужна, когда данные типа <type>bytea</type> извлекаются в "
"текстовом формате, но не когда они извлекаются в двоичном формате. "
"<synopsis>\n"
"unsigned char *PQunescapeBytea(const unsigned char *from, size_t "
"*to_length);\n"
"</synopsis>"

#: libpq.xml:4024(para)
msgid ""
"The <parameter>from</parameter> parameter points to a string such as might "
"be returned by <function>PQgetvalue</function> when applied to a "
"<type>bytea</type> column. <function>PQunescapeBytea</function> converts "
"this string representation into its binary representation. It returns a "
"pointer to a buffer allocated with <function>malloc()</function>, or "
"<symbol>NULL</symbol> on error, and puts the size of the buffer in "
"<parameter>to_length</parameter>. The result must be freed using "
"<function>PQfreemem</function> when it is no longer needed."
msgstr ""
"Параметр <parameter>from</parameter> указывает на строку, такую, какую могла "
"бы возвратить функция <function>PQgetvalue</function>, применённая к столбцу "
"типа <type>bytea</type>. <function>PQunescapeBytea</function> преобразует "
"это строковое представление в его двоичное представление. Она возвращает "
"указатель на буфер, распределённый с помощью функции <function>malloc()</"
"function> (или <symbol>NULL</symbol> в случае ошибки) и помещает размер "
"буфера по адресу <parameter>to_length</parameter>. Когда результат не будет "
"нужен, необходимо освободить его память, вызвав <function>PQfreemem</"
"function>."

#: libpq.xml:4035(para)
msgid ""
"This conversion is not exactly the inverse of <function>PQescapeBytea</"
"function>, because the string is not expected to be <quote>escaped</quote> "
"when received from <function>PQgetvalue</function>. In particular this means "
"there is no need for string quoting considerations, and so no need for a "
"<structname>PGconn</structname> parameter."
msgstr ""
"Это преобразование не является точной инверсией для <function>PQescapeBytea</"
"function>, поскольку ожидается, что строка, полученная от "
"<function>PQgetvalue</function>, не будет <quote>экранированной</quote>. В "
"частности, это означает, что учитывать режим спецпоследовательностей не "
"нужно, и поэтому в параметре нет необходимости <structname>PGconn</"
"structname>."

#: libpq.xml:4051(title)
msgid "Asynchronous Command Processing"
msgstr "Асинхронная обработка команд"

#: libpq.xml:4064(para)
msgid ""
"<function>PQexec</function> waits for the command to be completed. The "
"application might have other work to do (such as maintaining a user "
"interface), in which case it won't want to block waiting for the response."
msgstr ""
"<function>PQexec</function> ожидает завершения выполнения команды. "
"Приложение может иметь и другую работу, которую нужно делать (такую, как "
"поддержание пользовательского интерфейса), в таком случае оно не захочет "
"блокироваться, ожидая ответа."

#: libpq.xml:4073(para)
msgid ""
"Since the execution of the client application is suspended while it waits "
"for the result, it is hard for the application to decide that it would like "
"to try to cancel the ongoing command. (It can be done from a signal handler, "
"but not otherwise.)"
msgstr ""
"Поскольку выполнение клиентского приложения приостанавливается, пока оно "
"ожидает результата, то приложению трудно решить, что оно хотело бы "
"попытаться отменить выполняющуюся команду. (Это можно сделать из обработчика "
"сигнала, но никак иначе.)"

#: libpq.xml:4082(para)
msgid ""
"<function>PQexec</function> can return only one <structname>PGresult</"
"structname> structure. If the submitted command string contains multiple "
"<acronym>SQL</acronym> commands, all but the last <structname>PGresult</"
"structname> are discarded by <function>PQexec</function>."
msgstr ""
"<function>PQexec</function> может возвратить только одну структуру "
"<structname>PGresult</structname>. Если отправленная серверу строка-команда "
"содержит множественные <acronym>SQL</acronym>-команды, то все структуры "
"<structname>PGresult</structname>, кроме последней, отбрасываются функцией "
"<function>PQexec</function>."

#: libpq.xml:4092(para)
msgid ""
"<function>PQexec</function> always collects the command's entire result, "
"buffering it in a single <structname>PGresult</structname>. While this "
"simplifies error-handling logic for the application, it can be impractical "
"for results containing many rows."
msgstr ""
"<function>PQexec</function> всегда собирает все результаты выполнения "
"команды, буферизуя их в единственной структуре <structname>PGresult</"
"structname>. В то время как для приложения это упрощает логику обработки "
"ошибок, это может быть непрактично, когда результат содержит много строк."

#: libpq.xml:4057(para)
msgid ""
"The <function>PQexec</function> function is adequate for submitting commands "
"in normal, synchronous applications. It has a few deficiencies, however, "
"that can be of importance to some users: <placeholder-1/>"
msgstr ""
"Функция <function>PQexec</function> хорошо подходит для отправки команд "
"серверу в нормальных, синхронных приложениях. Однако, она имеет ряд "
"недостатков, которые могут иметь значение для некоторых пользователей: "
"<placeholder-1/>"

#: libpq.xml:4124(function)
msgid "PQsendQuery"
msgstr "PQsendQuery"

#: libpq.xml:4125(indexterm)
msgid "<primary>PQsendQuery</primary>"
msgstr "<primary>PQsendQuery</primary>"

#: libpq.xml:4131(para)
msgid ""
"Submits a command to the server without waiting for the result(s). 1 is "
"returned if the command was successfully dispatched and 0 if not (in which "
"case, use <function>PQerrorMessage</function> to get more information about "
"the failure). <synopsis>\n"
"int PQsendQuery(PGconn *conn, const char *command);\n"
"</synopsis> After successfully calling <function>PQsendQuery</function>, "
"call <function>PQgetResult</function> one or more times to obtain the "
"results. <function>PQsendQuery</function> cannot be called again (on the "
"same connection) until <function>PQgetResult</function> has returned a null "
"pointer, indicating that the command is done."
msgstr ""
"Отправляет команду серверу, не ожидая получения результата. Если команда "
"была отправлена успешно, то функция возвратит значение 1, в противном случае "
"она возвратит 0 (тогда нужно воспользоваться функцией "
"<function>PQerrorMessage</function> для получения дополнительной информации "
"о сбое). <synopsis>\n"
"int PQsendQuery(PGconn *conn, const char *command);\n"
"</synopsis> После успешного вызова <function>PQsendQuery</function> вызовите "
"<function>PQgetResult</function> один или несколько раз, чтобы получить "
"результат. Функцию <function>PQsendQuery</function> нельзя вызвать повторно "
"(на том же самом соединении) до тех пор, пока <function>PQgetResult</"
"function> не вернёт нулевой указатель, означающий, что выполнение команды "
"завершено."

#: libpq.xml:4151(function)
msgid "PQsendQueryParams"
msgstr "PQsendQueryParams"

#: libpq.xml:4152(indexterm)
msgid "<primary>PQsendQueryParams</primary>"
msgstr "<primary>PQsendQueryParams</primary>"

#: libpq.xml:4158(para)
msgid ""
"Submits a command and separate parameters to the server without waiting for "
"the result(s). <synopsis>\n"
"int PQsendQueryParams(PGconn *conn,\n"
"                      const char *command,\n"
"                      int nParams,\n"
"                      const Oid *paramTypes,\n"
"                      const char * const *paramValues,\n"
"                      const int *paramLengths,\n"
"                      const int *paramFormats,\n"
"                      int resultFormat);\n"
"</synopsis> This is equivalent to <function>PQsendQuery</function> except "
"that query parameters can be specified separately from the query string. The "
"function's parameters are handled identically to <function>PQexecParams</"
"function>. Like <function>PQexecParams</function>, it will not work on 2.0-"
"protocol connections, and it allows only one command in the query string."
msgstr ""
"Отправляет серверу команду и обособленные параметры, не ожидая получения "
"результатов. <synopsis>\n"
"int PQsendQueryParams(PGconn *conn,\n"
"                      const char *command,\n"
"                      int nParams,\n"
"                      const Oid *paramTypes,\n"
"                      const char * const *paramValues,\n"
"                      const int *paramLengths,\n"
"                      const int *paramFormats,\n"
"                      int resultFormat);\n"
"</synopsis> Эта функция эквивалентна функции <function>PQsendQuery</"
"function>, за исключением того, что параметры запроса можно указать отдельно "
"от самой строки запроса. Эта функция обрабатывает свои параметры точно так "
"же, как и функция <function>PQexecParams</function>. Аналогично функции "
"<function>PQexecParams</function>, данная функция не будет работать при "
"подключениях по протоколу версии 2.0, также она позволяет включить только "
"одну команду в строку запроса."

#: libpq.xml:4184(function)
msgid "PQsendPrepare"
msgstr "PQsendPrepare"

#: libpq.xml:4185(indexterm)
msgid "<primary>PQsendPrepare</primary>"
msgstr "<primary>PQsendPrepare</primary>"

#: libpq.xml:4191(para)
msgid ""
"Sends a request to create a prepared statement with the given parameters, "
"without waiting for completion. <synopsis>\n"
"int PQsendPrepare(PGconn *conn,\n"
"                  const char *stmtName,\n"
"                  const char *query,\n"
"                  int nParams,\n"
"                  const Oid *paramTypes);\n"
"</synopsis> This is an asynchronous version of <function>PQprepare</"
"function>: it returns 1 if it was able to dispatch the request, and 0 if "
"not. After a successful call, call <function>PQgetResult</function> to "
"determine whether the server successfully created the prepared statement. "
"The function's parameters are handled identically to <function>PQprepare</"
"function>. Like <function>PQprepare</function>, it will not work on 2.0-"
"protocol connections."
msgstr ""
"Посылает запрос на создание подготовленного оператора с данными параметрами "
"и не дожидается завершения его выполнения.<synopsis>\n"
"int PQsendPrepare(PGconn *conn,\n"
"                  const char *stmtName,\n"
"                  const char *query,\n"
"                  int nParams,\n"
"                  const Oid *paramTypes);\n"
"</synopsis> Это асинхронная версия функции <function>PQprepare</function>. "
"Она возвращает 1, если ей удалось отправить запрос, и 0 в противном случае. "
"После её успешного вызова следует вызвать функцию <function>PQgetResult</"
"function>, чтобы определить, успешно ли создал сервер подготовленный "
"оператор. Эта функция обрабатывает свои параметры точно так же, как и "
"функция <function>PQprepare</function>. Аналогично функции "
"<function>PQprepare</function>, данная функция не будет работать при "
"подключениях по протоколу версии 2.0."

#: libpq.xml:4216(function)
msgid "PQsendQueryPrepared"
msgstr "PQsendQueryPrepared"

#: libpq.xml:4217(indexterm)
msgid "<primary>PQsendQueryPrepared</primary>"
msgstr "<primary>PQsendQueryPrepared</primary>"

#: libpq.xml:4223(para)
msgid ""
"Sends a request to execute a prepared statement with given parameters, "
"without waiting for the result(s). <synopsis>\n"
"int PQsendQueryPrepared(PGconn *conn,\n"
"                        const char *stmtName,\n"
"                        int nParams,\n"
"                        const char * const *paramValues,\n"
"                        const int *paramLengths,\n"
"                        const int *paramFormats,\n"
"                        int resultFormat);\n"
"</synopsis> This is similar to <function>PQsendQueryParams</function>, but "
"the command to be executed is specified by naming a previously-prepared "
"statement, instead of giving a query string. The function's parameters are "
"handled identically to <function>PQexecPrepared</function>. Like "
"<function>PQexecPrepared</function>, it will not work on 2.0-protocol "
"connections."
msgstr ""
"Посылает запрос на выполнение подготовленного оператора с данными "
"параметрами, не ожидая получения результата. <synopsis>\n"
"int PQsendQueryPrepared(PGconn *conn,\n"
"                        const char *stmtName,\n"
"                        int nParams,\n"
"                        const char * const *paramValues,\n"
"                        const int *paramLengths,\n"
"                        const int *paramFormats,\n"
"                        int resultFormat);\n"
"</synopsis> Эта функция подобна функции <function>PQsendQueryParams</"
"function>, но команда, которая должна быть выполнена, задаётся путём "
"указания предварительно подготовленного оператора, вместо задания строки "
"запроса. Эта функция обрабатывает свои параметры точно так же, как и функция "
"<function>PQexecPrepared</function>. Аналогично функции "
"<function>PQexecPrepared</function>, данная функция не будет работать при "
"подключениях по протоколу версии 2.0."

#: libpq.xml:4249(function)
msgid "PQsendDescribePrepared"
msgstr "PQsendDescribePrepared"

#: libpq.xml:4250(indexterm)
msgid "<primary>PQsendDescribePrepared</primary>"
msgstr "<primary>PQsendDescribePrepared</primary>"

#: libpq.xml:4256(para)
msgid ""
"Submits a request to obtain information about the specified prepared "
"statement, without waiting for completion. <synopsis>\n"
"int PQsendDescribePrepared(PGconn *conn, const char *stmtName);\n"
"</synopsis> This is an asynchronous version of <function>PQdescribePrepared</"
"function>: it returns 1 if it was able to dispatch the request, and 0 if "
"not. After a successful call, call <function>PQgetResult</function> to "
"obtain the results. The function's parameters are handled identically to "
"<function>PQdescribePrepared</function>. Like <function>PQdescribePrepared</"
"function>, it will not work on 2.0-protocol connections."
msgstr ""
"Отправляет запрос на получение информации об указанном подготовленном "
"операторе и не дожидается завершения выполнения запроса. <synopsis>\n"
"int PQsendDescribePrepared(PGconn *conn, const char *stmtName);\n"
"</synopsis> Это асинхронная версия функции <function>PQdescribePrepared</"
"function>. Она возвращает 1, если ей удалось отправить запрос, и 0 в "
"противном случае. После её успешного вызова следует вызвать функцию "
"<function>PQgetResult</function> для получения результата. Эта функция "
"обрабатывает свои параметры точно так же, как и функция "
"<function>PQdescribePrepared</function>. Аналогично функции "
"<function>PQdescribePrepared</function>, данная функция не будет работать "
"при подключениях по протоколу версии 2.0."

#: libpq.xml:4276(function)
msgid "PQsendDescribePortal"
msgstr "PQsendDescribePortal"

#: libpq.xml:4277(indexterm)
msgid "<primary>PQsendDescribePortal</primary>"
msgstr "<primary>PQsendDescribePortal</primary>"

#: libpq.xml:4283(para)
msgid ""
"Submits a request to obtain information about the specified portal, without "
"waiting for completion. <synopsis>\n"
"int PQsendDescribePortal(PGconn *conn, const char *portalName);\n"
"</synopsis> This is an asynchronous version of <function>PQdescribePortal</"
"function>: it returns 1 if it was able to dispatch the request, and 0 if "
"not. After a successful call, call <function>PQgetResult</function> to "
"obtain the results. The function's parameters are handled identically to "
"<function>PQdescribePortal</function>. Like <function>PQdescribePortal</"
"function>, it will not work on 2.0-protocol connections."
msgstr ""
"Отправляет запрос на получение информации об указанном портале и не "
"дожидается завершения выполнения запроса. <synopsis>\n"
"int PQsendDescribePortal(PGconn *conn, const char *portalName);\n"
"</synopsis> Это асинхронная версия функции <function>PQdescribePortal</"
"function>. Она возвращает 1, если ей удалось отправить запрос, и 0 в "
"противном случае. После её успешного вызова следует вызвать функцию "
"<function>PQgetResult</function> для получения результата. Эта функция "
"обрабатывает свои параметры точно так же, как и функция "
"<function>PQdescribePortal</function>. Аналогично функции "
"<function>PQdescribePortal</function>, данная функция не будет работать при "
"подключениях по протоколу версии 2.0."

#: libpq.xml:4303(function)
msgid "PQgetResult"
msgstr "PQgetResult"

#: libpq.xml:4304(indexterm)
msgid "<primary>PQgetResult</primary>"
msgstr "<primary>PQgetResult</primary>"

#: libpq.xml:4310(para)
msgid ""
"Waits for the next result from a prior <function>PQsendQuery</function>, "
"<function>PQsendQueryParams</function>, <function>PQsendPrepare</function>, "
"<function>PQsendQueryPrepared</function>, <function>PQsendDescribePrepared</"
"function>, or <function>PQsendDescribePortal</function> call, and returns "
"it. A null pointer is returned when the command is complete and there will "
"be no more results. <synopsis>\n"
"PGresult *PQgetResult(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Ожидает получения следующего результата после предшествующего вызова "
"<function>PQsendQuery</function>, <function>PQsendQueryParams</function>, "
"<function>PQsendPrepare</function>, <function>PQsendQueryPrepared</"
"function>, <function>PQsendDescribePrepared</function> или "
"<function>PQsendDescribePortal</function> и возвращает его. Когда команда "
"завершена и результатов больше не будет, тогда возвращается нулевой "
"указатель. <synopsis>\n"
"PGresult *PQgetResult(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4326(para)
msgid ""
"<function>PQgetResult</function> must be called repeatedly until it returns "
"a null pointer, indicating that the command is done. (If called when no "
"command is active, <function>PQgetResult</function> will just return a null "
"pointer at once.) Each non-null result from <function>PQgetResult</function> "
"should be processed using the same <structname>PGresult</structname> "
"accessor functions previously described. Don't forget to free each result "
"object with <function>PQclear</function> when done with it. Note that "
"<function>PQgetResult</function> will block only if a command is active and "
"the necessary response data has not yet been read by "
"<function>PQconsumeInput</function>."
msgstr ""
"Функция <function>PQgetResult</function> должна вызываться повторно до тех "
"пор, пока она не вернёт нулевой указатель, означающий, что команда "
"завершена. (Если она вызвана, когда нет ни одной активной команды, тогда "
"<function>PQgetResult</function> просто возвратит нулевой указатель сразу "
"же.) Каждый ненулевой результат, полученный от <function>PQgetResult</"
"function>, должен обрабатываться с помощью тех же самых функций доступа к "
"структуре <structname>PGresult</structname>, которые были описаны выше. Не "
"забывайте освобождать память, занимаемую каждым результирующим объектом, с "
"помощью функции <function>PQclear</function>, когда работа с этим объектом "
"закончена. Обратите внимание, что <function>PQgetResult</function> "
"заблокируется, только если какая-либо команда активна, а необходимые "
"ответные данные ещё не были прочитаны функцией <function>PQconsumeInput</"
"function>."

#: libpq.xml:4342(para)
msgid ""
"Even when <function>PQresultStatus</function> indicates a fatal error, "
"<function>PQgetResult</function> should be called until it returns a null "
"pointer, to allow <application>libpq</application> to process the error "
"information completely."
msgstr ""
"Даже когда <function>PQresultStatus</function> показывает фатальную ошибку, "
"все равно следует вызывать функцию <function>PQgetResult</function> до тех "
"пор, пока она не возвратит нулевой указатель, чтобы позволить "
"<application>libpq</application> полностью обработать информацию об ошибке."

#: libpq.xml:4102(para)
msgid ""
"Applications that do not like these limitations can instead use the "
"underlying functions that <function>PQexec</function> is built from: "
"<function>PQsendQuery</function> and <function>PQgetResult</function>. There "
"are also <function>PQsendQueryParams</function>, <function>PQsendPrepare</"
"function>, <function>PQsendQueryPrepared</function>, "
"<function>PQsendDescribePrepared</function>, and "
"<function>PQsendDescribePortal</function>, which can be used with "
"<function>PQgetResult</function> to duplicate the functionality of "
"<function>PQexecParams</function>, <function>PQprepare</function>, "
"<function>PQexecPrepared</function>, <function>PQdescribePrepared</"
"function>, and <function>PQdescribePortal</function> respectively. "
"<placeholder-1/>"
msgstr ""
"Приложения, которым эти ограничения не подходят, могут вместо "
"<function>PQexec</function> использовать базовые функции, на основе которых "
"и построена функция <function>PQexec</function>: <function>PQsendQuery</"
"function> и <function>PQgetResult</function>. Есть также функции "
"<function>PQsendQueryParams</function>, <function>PQsendPrepare</function>, "
"<function>PQsendQueryPrepared</function>, <function>PQsendDescribePrepared</"
"function> и <function>PQsendDescribePortal</function>, которые можно "
"использовать совместно с <function>PQgetResult</function>, чтобы "
"продублировать функциональность <function>PQexecParams</function>, "
"<function>PQprepare</function>, <function>PQexecPrepared</function>, "
"<function>PQdescribePrepared</function> и <function>PQdescribePortal</"
"function> соответственно. <placeholder-1/>"

#: libpq.xml:4354(para)
msgid ""
"Using <function>PQsendQuery</function> and <function>PQgetResult</function> "
"solves one of <function>PQexec</function>'s problems: If a command string "
"contains multiple <acronym>SQL</acronym> commands, the results of those "
"commands can be obtained individually. (This allows a simple form of "
"overlapped processing, by the way: the client can be handling the results of "
"one command while the server is still working on later queries in the same "
"command string.)"
msgstr ""
"Использование <function>PQsendQuery</function> и <function>PQgetResult</"
"function> решает одну из проблем <function>PQexec</function>: если строка "
"команды содержит несколько <acronym>SQL</acronym>-команд, то результаты "
"каждой из них можно получить индивидуально. (Между прочим, это позволяет "
"организовать частичное совмещение обработки: клиент может обрабатывать "
"результаты одной команды, в то время как сервер ещё работает с более "
"поздними запросами, содержащимися в той же самой строке-команде.)"

#: libpq.xml:4365(para)
msgid ""
"Another frequently-desired feature that can be obtained with "
"<function>PQsendQuery</function> and <function>PQgetResult</function> is "
"retrieving large query results a row at a time. This is discussed in <xref "
"linkend=\"libpq-single-row-mode\"/>."
msgstr ""
"Ещё одной часто требующейся функциональной возможностью, которую можно "
"получить с помощью <function>PQsendQuery</function> и <function>PQgetResult</"
"function>, является извлечение больших выборок по одной строке за раз. Это "
"обсуждается в <xref remap=\"6\" linkend=\"libpq-single-row-mode\"/>."

#: libpq.xml:4381(function)
msgid "PQconsumeInput"
msgstr "PQconsumeInput"

#: libpq.xml:4382(indexterm)
msgid "<primary>PQconsumeInput</primary>"
msgstr "<primary>PQconsumeInput</primary>"

#: libpq.xml:4388(para)
msgid ""
"If input is available from the server, consume it. <synopsis>\n"
"int PQconsumeInput(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Если сервер готов передать данные, принять их. <synopsis>\n"
"int PQconsumeInput(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4395(para)
msgid ""
"<function>PQconsumeInput</function> normally returns 1 indicating <quote>no "
"error</quote>, but returns 0 if there was some kind of trouble (in which "
"case <function>PQerrorMessage</function> can be consulted). Note that the "
"result does not say whether any input data was actually collected. After "
"calling <function>PQconsumeInput</function>, the application can check "
"<function>PQisBusy</function> and/or <function>PQnotifies</function> to see "
"if their state has changed."
msgstr ""
"<function>PQconsumeInput</function> обычно возвращает 1, показывая, что "
"<quote>ошибки нет</quote>, но возвращает 0, если имела место какая-либо "
"проблема (в таком случае можно обратиться к функции "
"<function>PQerrorMessage</function> за уточнением). Обратите внимание, что "
"результат не говорит, были ли какие-либо входные данные фактически собраны. "
"После вызова функции <function>PQconsumeInput</function> приложение может "
"проверить <function>PQisBusy</function> и/или <function>PQnotifies</"
"function>, чтобы посмотреть, не изменилось ли их состояние."

#: libpq.xml:4406(para)
msgid ""
"<function>PQconsumeInput</function> can be called even if the application is "
"not prepared to deal with a result or notification just yet. The function "
"will read available data and save it in a buffer, thereby causing a "
"<function>select()</function> read-ready indication to go away. The "
"application can thus use <function>PQconsumeInput</function> to clear the "
"<function>select()</function> condition immediately, and then examine the "
"results at leisure."
msgstr ""
"<function>PQconsumeInput</function> можно вызвать, даже если приложение ещё "
"не готово иметь дело с результатом или уведомлением. Функция прочитает "
"доступные данные и сохранит их в буфере, при этом обрабатывая условие "
"готовности к чтению функции <function>select()</function>. Таким образом, "
"приложение может использовать <function>PQconsumeInput</function>, чтобы "
"немедленно обработать это состояние <function>select()</function>, а изучать "
"результаты позже."

#: libpq.xml:4421(function)
msgid "PQisBusy"
msgstr "PQisBusy"

#: libpq.xml:4422(indexterm)
msgid "<primary>PQisBusy</primary>"
msgstr "<primary>PQisBusy</primary>"

#: libpq.xml:4428(para)
msgid ""
"Returns 1 if a command is busy, that is, <function>PQgetResult</function> "
"would block waiting for input. A 0 return indicates that "
"<function>PQgetResult</function> can be called with assurance of not "
"blocking. <synopsis>\n"
"int PQisBusy(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает 1, если команда занята работой, то есть функция "
"<function>PQgetResult</function> была бы заблокирована в ожидании ввода. "
"Возвращаемое значение 0 показывает, что функция <function>PQgetResult</"
"function> при её вызове гарантированно не будет заблокирована. <synopsis>\n"
"int PQisBusy(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4438(para)
msgid ""
"<function>PQisBusy</function> will not itself attempt to read data from the "
"server; therefore <function>PQconsumeInput</function> must be invoked first, "
"or the busy state will never end."
msgstr ""
"Функция <function>PQisBusy</function> сама не будет пытаться прочитать "
"данные с сервера; следовательно, сначала нужно вызвать "
"<function>PQconsumeInput</function>, иначе состояние занятости никогда не "
"прекратится."

#: libpq.xml:4372(para)
msgid ""
"By itself, calling <function>PQgetResult</function> will still cause the "
"client to block until the server completes the next <acronym>SQL</acronym> "
"command. This can be avoided by proper use of two more functions: "
"<placeholder-1/>"
msgstr ""
"Сам по себе вызов <function>PQgetResult</function> всё же заставит клиента "
"заблокироваться до те пор, пока сервер не завершит выполнение следующей "
"<acronym>SQL</acronym>-команды. Этого можно избежать с помощью надлежащего "
"использования ещё двух функций: <placeholder-1/>"

#: libpq.xml:4448(para)
msgid ""
"A typical application using these functions will have a main loop that uses "
"<function>select()</function> or <function>poll()</function> to wait for all "
"the conditions that it must respond to. One of the conditions will be input "
"available from the server, which in terms of <function>select()</function> "
"means readable data on the file descriptor identified by <function>PQsocket</"
"function>. When the main loop detects input ready, it should call "
"<function>PQconsumeInput</function> to read the input. It can then call "
"<function>PQisBusy</function>, followed by <function>PQgetResult</function> "
"if <function>PQisBusy</function> returns false (0). It can also call "
"<function>PQnotifies</function> to detect <command>NOTIFY</command> messages "
"(see <xref linkend=\"libpq-notify\"/>)."
msgstr ""
"В типичном приложении, использующем эти функции, будет главный цикл, в "
"котором функции <function>select()</function> или <function>poll()</"
"function> служат для организации ожидания наступления всех условий, на "
"которые цикл должен отвечать. Одним из условий будет наличие ввода, "
"доступного от сервера, что в терминах функции <function>select()</function> "
"означает наличие данных, готовых для чтения на файловом дескрипторе, "
"идентифицируемом с помощью <function>PQsocket</function>. Когда главный цикл "
"обнаруживает ввод, готовый для чтения, он должен вызвать "
"<function>PQconsumeInput</function>, чтобы прочитать этот ввод. Затем он "
"может вызвать <function>PQisBusy</function>, а после неё уже "
"<function>PQgetResult</function>, если <function>PQisBusy</function> "
"возвратит \"ложь\" (0). Главный цикл может также вызвать "
"<function>PQnotifies</function>, чтобы обнаружить сообщения <command>NOTIFY</"
"command> (см. <xref remap=\"4\" linkend=\"libpq-notify\"/>)."

#: libpq.xml:4464(para)
msgid ""
"A client that uses <function>PQsendQuery</function>/<function>PQgetResult</"
"function> can also attempt to cancel a command that is still being processed "
"by the server; see <xref linkend=\"libpq-cancel\"/>. But regardless of the "
"return value of <function>PQcancel</function>, the application must continue "
"with the normal result-reading sequence using <function>PQgetResult</"
"function>. A successful cancellation will simply cause the command to "
"terminate sooner than it would have otherwise."
msgstr ""
"Клиент, который использует <function>PQsendQuery</function>/"
"<function>PQgetResult</function>, может также попытаться отменить команду, "
"которая всё ещё обрабатывается сервером; см. <xref remap=\"4\" linkend="
"\"libpq-cancel\"/>. Но, независимо от возвращаемого значения функции "
"<function>PQcancel</function>, приложение должно продолжать обычную "
"последовательность операций чтения результатов запроса, используя "
"<function>PQgetResult</function>. Успешная отмена просто заставит команду "
"завершиться раньше, чем она сделала бы в противном случае."

#: libpq.xml:4490(function)
msgid "PQsetnonblocking"
msgstr "PQsetnonblocking"

#: libpq.xml:4491(indexterm)
msgid "<primary>PQsetnonblocking</primary>"
msgstr "<primary>PQsetnonblocking</primary>"

#: libpq.xml:4497(para)
msgid ""
"Sets the nonblocking status of the connection. <synopsis>\n"
"int PQsetnonblocking(PGconn *conn, int arg);\n"
"</synopsis>"
msgstr ""
"Устанавливает неблокирующий статус подключения. <synopsis>\n"
"int PQsetnonblocking(PGconn *conn, int arg);\n"
"</synopsis>"

#: libpq.xml:4504(para)
msgid ""
"Sets the state of the connection to nonblocking if <parameter>arg</"
"parameter> is 1, or blocking if <parameter>arg</parameter> is 0. Returns 0 "
"if OK, -1 if error."
msgstr ""
"Устанавливает состояние подключения как неблокирующее, если <parameter>arg</"
"parameter> равен 1, или блокирующее, если <parameter>arg</parameter> равен "
"0. Возвращает 0 в случае успешного завершения и -1 в случае ошибки."

#: libpq.xml:4510(para)
msgid ""
"In the nonblocking state, calls to <function>PQsendQuery</function>, "
"<function>PQputline</function>, <function>PQputnbytes</function>, "
"<function>PQputCopyData</function>, and <function>PQendcopy</function> will "
"not block but instead return an error if they need to be called again."
msgstr ""
"В неблокирующем состоянии вызовы <function>PQsendQuery</function>, "
"<function>PQputline</function>, <function>PQputnbytes</function>, "
"<function>PQputCopyData</function> и <function>PQendcopy</function> не будут "
"блокироваться, а вместо этого возвратят ошибку, если вызов должен быть "
"повторным."

#: libpq.xml:4518(para)
msgid ""
"Note that <function>PQexec</function> does not honor nonblocking mode; if it "
"is called, it will act in blocking fashion anyway."
msgstr ""
"Обратите внимание, что функция <function>PQexec</function> не соблюдает "
"неблокирующий режим. Если она вызывается, она всё равно работает в "
"блокирующем режиме."

#: libpq.xml:4527(function)
msgid "PQisnonblocking"
msgstr "PQisnonblocking"

#: libpq.xml:4528(indexterm)
msgid "<primary>PQisnonblocking</primary>"
msgstr "<primary>PQisnonblocking</primary>"

#: libpq.xml:4534(para)
msgid ""
"Returns the blocking status of the database connection. <synopsis>\n"
"int PQisnonblocking(const PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Возвращает режим блокирования для подключения базы данных. <synopsis>\n"
"int PQisnonblocking(const PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4541(para)
msgid ""
"Returns 1 if the connection is set to nonblocking mode and 0 if blocking."
msgstr ""
"Возвращает 1, если подключение установлено в неблокирующем режиме, и 0, если "
"режим блокирующий."

#: libpq.xml:4550(function)
msgid "PQflush"
msgstr "PQflush"

#: libpq.xml:4551(indexterm)
msgid "<primary>PQflush</primary>"
msgstr "<primary>PQflush</primary>"

#: libpq.xml:4557(para)
msgid ""
"Attempts to flush any queued output data to the server. Returns 0 if "
"successful (or if the send queue is empty), -1 if it failed for some reason, "
"or 1 if it was unable to send all the data in the send queue yet (this case "
"can only occur if the connection is nonblocking). <synopsis>\n"
"int PQflush(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Пытается сбросить любые выходные данные, стоящие в очереди, на сервер. "
"Возвращает 0 в случае успеха (или если очередь на отправку пуста), -1 в "
"случае сбоя по какой-либо причине или 1, если она ещё не смогла отправить "
"все данные, находящиеся в очереди (этот случай может иметь место, только "
"если соединение неблокирующее). <synopsis>\n"
"int PQflush(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4476(para)
msgid ""
"By using the functions described above, it is possible to avoid blocking "
"while waiting for input from the database server. However, it is still "
"possible that the application will block waiting to send output to the "
"server. This is relatively uncommon but can happen if very long SQL commands "
"or data values are sent. (It is much more probable if the application sends "
"data via <command>COPY IN</command>, however.) To prevent this possibility "
"and achieve completely nonblocking database operation, the following "
"additional functions can be used. <placeholder-1/>"
msgstr ""
"Используя функции, описанные выше, можно избежать блокирования, ожидая ввода "
"от сервера баз данных. Однако, всё же возможно, что приложение будет "
"заблокировано в ожидании отправки вывода на сервер. Это бывает относительно "
"нечасто, но может иметь место, если отправлены очень длинные SQL-команды или "
"значения данных. (Однако, это значительно более вероятно, если приложение "
"отправляет данные через команду <command>COPY IN</command>.) Чтобы "
"предотвратить эту возможность и достичь совершенно неблокирующего режима "
"работы с базой данных, можно использовать следующие дополнительные функции. "
"<placeholder-1/>"

#: libpq.xml:4572(para)
msgid ""
"After sending any command or data on a nonblocking connection, call "
"<function>PQflush</function>. If it returns 1, wait for the socket to become "
"read- or write-ready. If it becomes write-ready, call <function>PQflush</"
"function> again. If it becomes read-ready, call <function>PQconsumeInput</"
"function>, then call <function>PQflush</function> again. Repeat until "
"<function>PQflush</function> returns 0. (It is necessary to check for read-"
"ready and drain the input with <function>PQconsumeInput</function>, because "
"the server can block trying to send us data, e.g. NOTICE messages, and won't "
"read our data until we read its.) Once <function>PQflush</function> returns "
"0, wait for the socket to be read-ready and then read the response as "
"described above."
msgstr ""
"После отправки любой команды или данных через неблокирующее подключение "
"следует вызвать функцию <function>PQflush</function>. Если она возвратит 1, "
"подождите, пока сокет станет готовым к чтению или записи. Если он станет "
"готовым к записи, то вызовите <function>PQflush</function> снова. Если он "
"станет готовым к чтению, то вызовите <function>PQconsumeInput</function>, а "
"затем вызовите <function>PQflush</function> снова. Повторяйте до тех пор, "
"пока <function>PQflush</function> не возвратит 0. (Необходимо выполнять "
"проверку на состояние готовности к чтению и забирать входные данные с "
"помощью <function>PQconsumeInput</function>, потому что сервер может "
"заблокироваться, пытаясь отправить нам данные, например, сообщения NOTICE, и "
"не будет читать наши данные до тех пор, пока мы не прочитаем его.) Как "
"только <function>PQflush</function> возвратит 0, подождите, пока сокет не "
"станет готовым к чтению, а затем прочитайте ответ, как описано выше."

#: libpq.xml:4590(title)
msgid "Retrieving Query Results Row-By-Row"
msgstr "Построчное извлечение результатов запроса"

#: libpq.xml:4592(indexterm)
msgid "<primary>libpq</primary> <secondary>single-row mode</secondary>"
msgstr "<primary>libpq</primary> <secondary>однострочный режим</secondary>"

#: libpq.xml:4597(para)
msgid ""
"Ordinarily, <application>libpq</application> collects a SQL command's entire "
"result and returns it to the application as a single <structname>PGresult</"
"structname>. This can be unworkable for commands that return a large number "
"of rows. For such cases, applications can use <function>PQsendQuery</"
"function> and <function>PQgetResult</function> in <firstterm>single-row "
"mode</firstterm>. In this mode, the result row(s) are returned to the "
"application one at a time, as they are received from the server."
msgstr ""
"Обычно <application>libpq</application> собирает весь результат выполнения "
"SQL-команды и возвращает его приложению в виде единственной структуры "
"<structname>PGresult</structname>. Это может оказаться неприемлемым для "
"команд, которые возвращают большое число строк. В таких случаях приложение "
"может воспользоваться функциями <function>PQsendQuery</function> и "
"<function>PQgetResult</function> в <firstterm>однострочном режиме</"
"firstterm>. В этом режиме результирующие строки передаются приложению по "
"одной за один раз, по мере того, как они принимаются от сервера."

#: libpq.xml:4608(para)
msgid ""
"To enter single-row mode, call <function>PQsetSingleRowMode</function> "
"immediately after a successful call of <function>PQsendQuery</function> (or "
"a sibling function). This mode selection is effective only for the currently "
"executing query. Then call <function>PQgetResult</function> repeatedly, "
"until it returns null, as documented in <xref linkend=\"libpq-async\"/>. If "
"the query returns any rows, they are returned as individual "
"<structname>PGresult</structname> objects, which look like normal query "
"results except for having status code <literal>PGRES_SINGLE_TUPLE</literal> "
"instead of <literal>PGRES_TUPLES_OK</literal>. After the last row, or "
"immediately if the query returns zero rows, a zero-row object with status "
"<literal>PGRES_TUPLES_OK</literal> is returned; this is the signal that no "
"more rows will arrive. (But note that it is still necessary to continue "
"calling <function>PQgetResult</function> until it returns null.) All of "
"these <structname>PGresult</structname> objects will contain the same row "
"description data (column names, types, etc) that an ordinary "
"<structname>PGresult</structname> object for the query would have. Each "
"object should be freed with <function>PQclear</function> as usual."
msgstr ""
"Для того чтобы войти в однострочный режим, вызовите "
"<function>PQsetSingleRowMode</function> сразу же после успешного вызова "
"функции <function>PQsendQuery</function> (или родственной функции). Выбор "
"этого режима действителен только для текущего исполняющегося запроса. Затем "
"повторно вызывайте функцию <function>PQgetResult</function> до тех пор, пока "
"она не возвратит null, как описано в <xref linkend=\"libpq-async\"/>. Если "
"запрос возвращает какое-то число строк, то они возвращаются в виде "
"индивидуальных объектов <structname>PGresult</structname>, которые выглядят, "
"как обычные выборки, за исключением того, что их код статуса будет "
"<literal>PGRES_SINGLE_TUPLE</literal> вместо <literal>PGRES_TUPLES_OK</"
"literal>. После последней строки (или сразу же, если запрос не возвращает ни "
"одной строки) будет возвращён объект, не содержащий ни одной строки и "
"имеющий статус <literal>PGRES_TUPLES_OK</literal>; это сигнал о том, что "
"строк больше не будет. (Но обратите внимание, что всё же необходимо "
"продолжать вызывать функцию <function>PQgetResult</function>, пока она не "
"возвратит значение null.) Все эти объекты <structname>PGresult</structname> "
"будут содержать те же самые описательные данные (имена столбцов, типы и т. "
"д.), которые имел бы обычный объект <structname>PGresult</structname>. "
"Память, занимаемую каждым объектом, нужно освобождать с помощью "
"<function>PQclear</function>, как обычно."

#: libpq.xml:4633(function)
msgid "PQsetSingleRowMode"
msgstr "PQsetSingleRowMode"

#: libpq.xml:4634(indexterm)
msgid "<primary>PQsetSingleRowMode</primary>"
msgstr "<primary>PQsetSingleRowMode</primary>"

#: libpq.xml:4640(para)
msgid ""
"Select single-row mode for the currently-executing query. <synopsis>\n"
"int PQsetSingleRowMode(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Выбирает однострочный режим для текущего выполняющегося запроса. <synopsis>\n"
"int PQsetSingleRowMode(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4648(para)
msgid ""
"This function can only be called immediately after <function>PQsendQuery</"
"function> or one of its sibling functions, before any other operation on the "
"connection such as <function>PQconsumeInput</function> or "
"<function>PQgetResult</function>. If called at the correct time, the "
"function activates single-row mode for the current query and returns 1. "
"Otherwise the mode stays unchanged and the function returns 0. In any case, "
"the mode reverts to normal after completion of the current query."
msgstr ""
"Эту функцию можно вызывать только непосредственно после функции "
"<function>PQsendQuery</function> или одной из её родственных функций, до "
"выполнения любой другой операции на этом подключении, такой, как "
"<function>PQconsumeInput</function> или <function>PQgetResult</function>. "
"Будучи вызванной своевременно, функция активирует однострочный режим для "
"текущего запроса и возвращает 1. В противном случае режим остаётся не "
"изменённым, а функция возвращает 0. В любом случае режим возвращается в "
"нормальное состояние после завершения текущего запроса."

#: libpq.xml:4665(para)
msgid ""
"While processing a query, the server may return some rows and then encounter "
"an error, causing the query to be aborted. Ordinarily, <application>libpq</"
"application> discards any such rows and reports only the error. But in "
"single-row mode, those rows will have already been returned to the "
"application. Hence, the application will see some "
"<literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname> "
"objects followed by a <literal>PGRES_FATAL_ERROR</literal> object. For "
"proper transactional behavior, the application must be designed to discard "
"or undo whatever has been done with the previously-processed rows, if the "
"query ultimately fails."
msgstr ""
"В процессе обработки запроса сервер может возвратить некоторое количество "
"строк, а затем столкнуться с ошибкой, вынуждающей его аварийно завершить "
"запрос. Обычно <application>libpq</application> отбрасывает такие строки и "
"сообщает только об ошибке. Но в однострочном режиме эти строки уже будут "
"возвращены приложению. Следовательно, приложение увидит ряд объектов "
"<structname>PGresult</structname>, имеющих статус "
"<literal>PGRES_SINGLE_TUPLE</literal>, за которыми последует объект со "
"статусом <literal>PGRES_FATAL_ERROR</literal>. Для обеспечения надлежащего "
"поведения транзакций приложение должно быть спроектировано таким образом, "
"чтобы отбрасывать или отменять все операции, проведённые с уже обработанными "
"строками, если запрос в конечном итоге завершается сбоем."

#: libpq.xml:4682(title)
msgid "Canceling Queries in Progress"
msgstr "Отмена запросов в процессе выполнения"

#: libpq.xml:4684(indexterm)
msgid "<primary>canceling</primary> <secondary>SQL command</secondary>"
msgstr "<primary>отмена</primary> <secondary>SQL-команд</secondary>"

#: libpq.xml:4697(function)
msgid "PQgetCancel"
msgstr "PQgetCancel"

#: libpq.xml:4698(indexterm)
msgid "<primary>PQgetCancel</primary>"
msgstr "<primary>PQgetCancel</primary>"

#: libpq.xml:4704(para)
msgid ""
"Creates a data structure containing the information needed to cancel a "
"command issued through a particular database connection. <synopsis>\n"
"PGcancel *PQgetCancel(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Создаёт структуру данных, содержащую информацию, необходимую для отмены "
"команды, запущенной через конкретное подключение к базе данных.<synopsis>\n"
"PGcancel *PQgetCancel(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4714(indexterm)
msgid "<primary>PGcancel</primary>"
msgstr "<primary>PGcancel</primary>"

#: libpq.xml:4712(para)
msgid ""
"<function>PQgetCancel</function> creates a <structname>PGcancel</"
"structname><placeholder-1/> object given a <structname>PGconn</structname> "
"connection object. It will return <symbol>NULL</symbol> if the given "
"<parameter>conn</parameter> is <symbol>NULL</symbol> or an invalid "
"connection. The <structname>PGcancel</structname> object is an opaque "
"structure that is not meant to be accessed directly by the application; it "
"can only be passed to <function>PQcancel</function> or "
"<function>PQfreeCancel</function>."
msgstr ""
"Функция <function>PQgetCancel</function> создаёт объект "
"<structname>PGcancel</structname><placeholder-1/>, получив объект "
"<structname>PGconn</structname>, описывающий подключение. Она возвратит "
"<symbol>NULL</symbol>, если данный параметр <parameter>conn</parameter> "
"равен <symbol>NULL</symbol> или представляет собой недействительное "
"подключения. Объект <structname>PGcancel</structname> является непрозрачной "
"структурой, которая не предназначена для того, чтобы приложение обращалось к "
"ней напрямую; её можно только передавать функции <function>PQcancel</"
"function> или <function>PQfreeCancel</function>."

#: libpq.xml:4727(function)
msgid "PQfreeCancel"
msgstr "PQfreeCancel"

#: libpq.xml:4728(indexterm)
msgid "<primary>PQfreeCancel</primary>"
msgstr "<primary>PQfreeCancel</primary>"

#: libpq.xml:4734(para)
msgid ""
"Frees a data structure created by <function>PQgetCancel</function>. "
"<synopsis>\n"
"void PQfreeCancel(PGcancel *cancel);\n"
"</synopsis>"
msgstr ""
"Освобождает память, занимаемую структурой данных, созданной функцией "
"<function>PQgetCancel</function>. <synopsis>\n"
"void PQfreeCancel(PGcancel *cancel);\n"
"</synopsis>"

#: libpq.xml:4741(para)
msgid ""
"<function>PQfreeCancel</function> frees a data object previously created by "
"<function>PQgetCancel</function>."
msgstr ""
"<function>PQfreeCancel</function> освобождает память, занимаемую объектом, "
"предварительно созданным функцией <function>PQgetCancel</function>."

#: libpq.xml:4750(function)
msgid "PQcancel"
msgstr "PQcancel"

#: libpq.xml:4751(indexterm)
msgid "<primary>PQcancel</primary>"
msgstr "<primary>PQcancel</primary>"

#: libpq.xml:4757(para)
msgid ""
"Requests that the server abandon processing of the current command. "
"<synopsis>\n"
"int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);\n"
"</synopsis>"
msgstr ""
"Требует, чтобы сервер прекратил обработку текущей команды. <synopsis>\n"
"int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);\n"
"</synopsis>"

#: libpq.xml:4764(para)
msgid ""
"The return value is 1 if the cancel request was successfully dispatched and "
"0 if not. If not, <parameter>errbuf</parameter> is filled with an "
"explanatory error message. <parameter>errbuf</parameter> must be a char "
"array of size <parameter>errbufsize</parameter> (the recommended size is 256 "
"bytes)."
msgstr ""
"Возвращаемое значение равно 1, если запрос на отмену был успешно отправлен, "
"и 0 в противном случае. В случае неудачной отправки <parameter>errbuf</"
"parameter> заполняется пояснительным сообщением об ошибке. "
"<parameter>errbuf</parameter> должен быть массивом символов, имеющим размер "
"<parameter>errbufsize</parameter> (рекомендуемый размер составляет 256 "
"байтов)."

#: libpq.xml:4772(para)
msgid ""
"Successful dispatch is no guarantee that the request will have any effect, "
"however. If the cancellation is effective, the current command will "
"terminate early and return an error result. If the cancellation fails (say, "
"because the server was already done processing the command), then there will "
"be no visible result at all."
msgstr ""
"Успешная отправка ещё не является гарантией того, что запрос будет иметь "
"какой-то эффект. Если отмена сработала, текущая команда завершится досрочно "
"и возвратит в качестве результата ошибку. Если же отмена не получится "
"(например, потому, что сервер уже завершил обработку команды), тогда вообще "
"не будет видимого результата."

#: libpq.xml:4781(para)
msgid ""
"<function>PQcancel</function> can safely be invoked from a signal handler, "
"if the <parameter>errbuf</parameter> is a local variable in the signal "
"handler. The <structname>PGcancel</structname> object is read-only as far as "
"<function>PQcancel</function> is concerned, so it can also be invoked from a "
"thread that is separate from the one manipulating the <structname>PGconn</"
"structname> object."
msgstr ""
"<function>PQcancel</function> можно безопасно вызывать из обработчика "
"сигнала, если <parameter>errbuf</parameter> является локальной переменной в "
"обработчике сигнала. Объект <structname>PGcancel</structname> доступен "
"только в режиме чтения, пока речь идёт о функции <function>PQcancel</"
"function>, поэтому её можно также вызывать из потока, отдельного от того, "
"который управляет объектом <structname>PGconn</structname>."

#: libpq.xml:4796(function)
msgid "PQrequestCancel"
msgstr "PQrequestCancel"

#: libpq.xml:4797(indexterm)
msgid "<primary>PQrequestCancel</primary>"
msgstr "<primary>PQrequestCancel</primary>"

#: libpq.xml:4803(para)
msgid ""
"<function>PQrequestCancel</function> is a deprecated variant of "
"<function>PQcancel</function>. <synopsis>\n"
"int PQrequestCancel(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"<function>PQrequestCancel</function> является нерекомендуемым вариантом "
"функции <function>PQcancel</function>. <synopsis>\n"
"int PQrequestCancel(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:4811(para)
msgid ""
"Requests that the server abandon processing of the current command. It "
"operates directly on the <structname>PGconn</structname> object, and in case "
"of failure stores the error message in the <structname>PGconn</structname> "
"object (whence it can be retrieved by <function>PQerrorMessage</function>). "
"Although the functionality is the same, this approach creates hazards for "
"multiple-thread programs and signal handlers, since it is possible that "
"overwriting the <structname>PGconn</structname>'s error message will mess up "
"the operation currently in progress on the connection."
msgstr ""
"Выдаёт запрос на то, чтобы сервер прекратил обработку текущей команды. "
"Функция работает напрямую с объектом <structname>PGconn</structname> и в "
"случае сбоя сохраняет сообщение об ошибке в объекте <structname>PGconn</"
"structname> (откуда его можно извлечь с помощью <function>PQerrorMessage</"
"function>). Хотя функциональность та же самая, этот подход создаёт риски для "
"многопоточных программ и обработчиков сигналов, поскольку возможно, что "
"перезапись сообщения об ошибке, хранящегося в объекте <structname>PGconn</"
"structname>, внесёт путаницу в текущую операцию, выполняемую на данном "
"подключении."

#: libpq.xml:4689(para)
msgid ""
"A client application can request cancellation of a command that is still "
"being processed by the server, using the functions described in this "
"section. <placeholder-1/> <placeholder-2/>"
msgstr ""
"Клиентское приложение может запросить отмену команды, которая ещё "
"обрабатывается сервером, используя функции, описанные в этом разделе. "
"<placeholder-1/> <placeholder-2/>"

#: libpq.xml:4830(title)
msgid "The Fast-Path Interface"
msgstr "Интерфейс быстрого пути"

#: libpq.xml:4832(indexterm)
msgid "<primary>fast path</primary>"
msgstr "<primary>быстрый путь</primary>"

#: libpq.xml:4836(para)
msgid ""
"<productname>PostgreSQL</productname> provides a fast-path interface to send "
"simple function calls to the server."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет интерфейс для передачи "
"серверу простых вызовов функций по быстрому пути."

#: libpq.xml:4842(para)
msgid ""
"This interface is somewhat obsolete, as one can achieve similar performance "
"and greater functionality by setting up a prepared statement to define the "
"function call. Then, executing the statement with binary transmission of "
"parameters and results substitutes for a fast-path function call."
msgstr ""
"Этот интерфейс несколько устарел, поскольку можно достичь подобной "
"производительности и большей функциональности путём создания подготовленного "
"оператора, определяющего вызов функции. Последующее выполнение этого "
"оператора с передачей параметров и результатов в двоичном виде можно считать "
"заменой вызову по быстрому пути."

#: libpq.xml:4852(indexterm)
msgid "<primary>PQfn</primary>"
msgstr "<primary>PQfn</primary>"

#: libpq.xml:4851(para)
msgid ""
"The function <function>PQfn</function><placeholder-1/> requests execution of "
"a server function via the fast-path interface: <synopsis>\n"
"PGresult *PQfn(PGconn *conn,\n"
"               int fnid,\n"
"               int *result_buf,\n"
"               int *result_len,\n"
"               int result_is_int,\n"
"               const PQArgBlock *args,\n"
"               int nargs);\n"
"\n"
"typedef struct\n"
"{\n"
"    int len;\n"
"    int isint;\n"
"    union\n"
"    {\n"
"        int *ptr;\n"
"        int integer;\n"
"    } u;\n"
"} PQArgBlock;\n"
"</synopsis>"
msgstr ""
"Функция <function>PQfn</function><placeholder-1/> запрашивает выполнение "
"серверной функции посредством интерфейса быстрого доступа: <synopsis>\n"
"PGresult *PQfn(PGconn *conn,\n"
"               int fnid,\n"
"               int *result_buf,\n"
"               int *result_len,\n"
"               int result_is_int,\n"
"               const PQArgBlock *args,\n"
"               int nargs);\n"
"\n"
"typedef struct\n"
"{\n"
"    int len;\n"
"    int isint;\n"
"    union\n"
"    {\n"
"        int *ptr;\n"
"        int integer;\n"
"    } u;\n"
"} PQArgBlock;\n"
"</synopsis>"

#: libpq.xml:4876(para)
msgid ""
"The <parameter>fnid</parameter> argument is the OID of the function to be "
"executed. <parameter>args</parameter> and <parameter>nargs</parameter> "
"define the parameters to be passed to the function; they must match the "
"declared function argument list. When the <parameter>isint</parameter> field "
"of a parameter structure is true, the <parameter>u.integer</parameter> value "
"is sent to the server as an integer of the indicated length (this must be 2 "
"or 4 bytes); proper byte-swapping occurs. When <parameter>isint</parameter> "
"is false, the indicated number of bytes at <parameter>*u.ptr</parameter> are "
"sent with no processing; the data must be in the format expected by the "
"server for binary transmission of the function's argument data type. (The "
"declaration of <parameter>u.ptr</parameter> as being of type <type>int *</"
"type> is historical; it would be better to consider it <type>void *</type>.) "
"<parameter>result_buf</parameter> points to the buffer in which to place the "
"function's return value. The caller must have allocated sufficient space to "
"store the return value. (There is no check!) The actual result length in "
"bytes will be returned in the integer pointed to by <parameter>result_len</"
"parameter>. If a 2- or 4-byte integer result is expected, set "
"<parameter>result_is_int</parameter> to 1, otherwise set it to 0. Setting "
"<parameter>result_is_int</parameter> to 1 causes <application>libpq</"
"application> to byte-swap the value if necessary, so that it is delivered as "
"a proper <type>int</type> value for the client machine; note that a 4-byte "
"integer is delivered into <parameter>*result_buf</parameter> for either "
"allowed result size. When <parameter>result_is_int</parameter> is 0, the "
"binary-format byte string sent by the server is returned unmodified. (In "
"this case it's better to consider <parameter>result_buf</parameter> as being "
"of type <type>void *</type>.)"
msgstr ""
"Аргумент <parameter>fnid</parameter> представляет собой OID функции, которая "
"подлежит выполнению. <parameter>args</parameter> и <parameter>nargs</"
"parameter> определяют параметры, которые должны быть переданы этой функции; "
"они должны соответствовать списку аргументов объявленной функции. Когда поле "
"<parameter>isint</parameter> структуры, передаваемой в качестве параметра, "
"имеет значение \"истина\", тогда значение <parameter>u.integer</parameter> "
"передаётся серверу в виде целого числа указанной длины (это должно быть 2 "
"или 4 байта); при этом устанавливается нужный порядок байтов. Когда "
"<parameter>isint</parameter> имеет значение \"ложь\", тогда указанное число "
"байтов по адресу <parameter>*u.ptr</parameter> отправляется без какой-либо "
"обработки; данные должны быть представлены в формате, которого ожидает "
"сервер для передачи в двоичном виде данных того типа, что и аргументы "
"функции. (Объявление поля <parameter>u.ptr</parameter>, как имеющего тип "
"<type>int *</type>, является историческим; было бы лучше рассматривать его "
"как тип <type>void *</type>.) <parameter>result_buf</parameter> указывает на "
"буфер, в который должно быть помещено возвращаемое значение функции. "
"Вызывающий код должен выделить достаточное место для сохранения "
"возвращаемого значения. (Это никак не проверяется!) Фактическая длина "
"результирующего значения в байтах будет возвращена в переменной целого типа, "
"на которую указывает <parameter>result_len</parameter>. Если ожидается "
"получение двух- или четырёхбайтового целочисленного результата, то присвойте "
"параметру <parameter>result_is_int</parameter> значение 1, в противном "
"случае назначьте ему 0. Когда параметр <parameter>result_is_int</parameter> "
"равен 1, <application>libpq</application> переставляет байты в передаваемом "
"значении, если это необходимо, так, чтобы оно было доставлено на клиентскую "
"машину в виде правильного значения типа <type>int</type>; обратите внимание, "
"что по адресу <parameter>*result_buf</parameter> доставляется "
"четырёхбайтовое целое для любого допустимого размера результата. Когда "
"<parameter>result_is_int</parameter> равен 0, тогда строка байтов в двоичном "
"формате, отправленная сервером, будет возвращена немодифицированной. (В этом "
"случае лучше рассматривать <parameter>result_buf</parameter> как имеющий тип "
"<type>void *</type>.)"

#: libpq.xml:4907(para)
msgid ""
"<function>PQfn</function> always returns a valid <structname>PGresult</"
"structname> pointer. The result status should be checked before the result "
"is used. The caller is responsible for freeing the <structname>PGresult</"
"structname> with <function>PQclear</function> when it is no longer needed."
msgstr ""
"<function>PQfn</function> всегда возвращает действительный указатель на "
"объект <structname>PGresult</structname>. Перед использованием результата "
"нужно сначала проверить его статус. Вызывающая функция отвечает за "
"освобождение памяти, занимаемой объектом <structname>PGresult</structname>, "
"когда он больше не нужен, с помощью <function>PQclear</function>."

#: libpq.xml:4915(para)
msgid ""
"Note that it is not possible to handle null arguments, null results, nor set-"
"valued results when using this interface."
msgstr ""
"Обратите внимание, что при использовании этого интерфейса невозможно "
"обработать NULL в аргументах и результате, а также множества значений в "
"результате."

#: libpq.xml:4923(title)
msgid "Asynchronous Notification"
msgstr "Асинхронное уведомление"

#: libpq.xml:4925(indexterm)
msgid "<primary>NOTIFY</primary> <secondary>in libpq</secondary>"
msgstr "<primary>NOTIFY</primary> <secondary>в libpq</secondary>"

#: libpq.xml:4930(para)
msgid ""
"<productname>PostgreSQL</productname> offers asynchronous notification via "
"the <command>LISTEN</command> and <command>NOTIFY</command> commands. A "
"client session registers its interest in a particular notification channel "
"with the <command>LISTEN</command> command (and can stop listening with the "
"<command>UNLISTEN</command> command). All sessions listening on a particular "
"channel will be notified asynchronously when a <command>NOTIFY</command> "
"command with that channel name is executed by any session. A <quote>payload</"
"quote> string can be passed to communicate additional data to the listeners."
msgstr ""
"<productname>PostgreSQL</productname> предлагает асинхронное уведомление "
"посредством команд <command>LISTEN</command> и <command>NOTIFY</command>. "
"Клиентский сеанс работы регистрирует свою заинтересованность в конкретном "
"канале уведомлений с помощью команды <command>LISTEN</command> (и может "
"остановить прослушивание с помощью команды <command>UNLISTEN</command>). Все "
"сеансы, прослушивающие конкретный канал, будут уведомляться в асинхронном "
"режиме, когда в рамках любого сеанса команда <command>NOTIFY</command> "
"выполняется с параметром, указывающим имя этого канала. Для передачи "
"дополнительных данных прослушивающим сеансам может использоваться строка "
"<quote>payload</quote>."

#: libpq.xml:4948(indexterm)
msgid "<primary>PQnotifies</primary>"
msgstr "<primary>PQnotifies</primary>"

#: libpq.xml:4942(para)
msgid ""
"<application>libpq</application> applications submit <command>LISTEN</"
"command>, <command>UNLISTEN</command>, and <command>NOTIFY</command> "
"commands as ordinary SQL commands. The arrival of <command>NOTIFY</command> "
"messages can subsequently be detected by calling <function>PQnotifies</"
"function>.<placeholder-1/>"
msgstr ""
"Приложения, использующие <application>libpq</application>, отправляют "
"серверу команды <command>LISTEN</command>, <command>UNLISTEN</command> и "
"<command>NOTIFY</command>, как обычные SQL-команды. Прибытие сообщений от "
"команды <command>NOTIFY</command> можно впоследствии обнаружить с помощью "
"вызова функции <function>PQnotifies</function>.<placeholder-1/>"

#: libpq.xml:4951(para)
msgid ""
"The function <function>PQnotifies</function> returns the next notification "
"from a list of unhandled notification messages received from the server. It "
"returns a null pointer if there are no pending notifications. Once a "
"notification is returned from <function>PQnotifies</function>, it is "
"considered handled and will be removed from the list of notifications. "
"<synopsis>\n"
"PGnotify *PQnotifies(PGconn *conn);\n"
"\n"
"typedef struct pgNotify\n"
"{\n"
"    char *relname;              /* notification channel name */\n"
"    int  be_pid;                /* process ID of notifying server process "
"*/\n"
"    char *extra;                /* notification payload string */\n"
"} PGnotify;\n"
"</synopsis> After processing a <structname>PGnotify</structname> object "
"returned by <function>PQnotifies</function>, be sure to free it with "
"<function>PQfreemem</function>. It is sufficient to free the "
"<structname>PGnotify</structname> pointer; the <structfield>relname</"
"structfield> and <structfield>extra</structfield> fields do not represent "
"separate allocations. (The names of these fields are historical; in "
"particular, channel names need not have anything to do with relation names.)"
msgstr ""
"Функция <function>PQnotifies</function> возвращает следующее уведомление из "
"списка необработанных уведомительных сообщений, полученных от сервера. Она "
"возвращает нулевой указатель, если нет уведомлений, ожидающих обработки. Как "
"только уведомление возвращено из функции <function>PQnotifies</function>, "
"оно считается обработанным и будет удалено из списка уведомлений. "
"<synopsis>\n"
"PGnotify *PQnotifies(PGconn *conn);\n"
"\n"
"typedef struct pgNotify\n"
"{\n"
"    char *relname;              /* имя канала уведомлений */\n"
"    int  be_pid;                /* ID серверного процесса, посылающего "
"уведомление */\n"
"    char *extra;                /* строка сообщения в уведомлении */\n"
"} PGnotify;\n"
"</synopsis> После обработки объекта <structname>PGnotify</structname>, "
"возвращённого функцией <function>PQnotifies</function>, обязательно "
"освободите память, занимаемую им, с помощью функции <function>PQfreemem</"
"function>. Достаточно освободить указатель на <structname>PGnotify</"
"structname>; поля <structfield>relname</structfield> и <structfield>extra</"
"structfield> не представляют отдельных областей памяти. (Имена этих полей "
"являются таковыми по историческим причинам; в частности, имена каналов не "
"обязаны иметь ничего общего с именами реляционных отношений.)"

#: libpq.xml:4979(para)
msgid ""
"<xref linkend=\"libpq-example-2\"/> gives a sample program that illustrates "
"the use of asynchronous notification."
msgstr ""
"<xref linkend=\"libpq-example-2\"/> представляет пример программы, "
"иллюстрирующей использование асинхронного уведомления."

#: libpq.xml:4984(para)
msgid ""
"<function>PQnotifies</function> does not actually read data from the server; "
"it just returns messages previously absorbed by another <application>libpq</"
"application> function. In prior releases of <application>libpq</"
"application>, the only way to ensure timely receipt of <command>NOTIFY</"
"command> messages was to constantly submit commands, even empty ones, and "
"then check <function>PQnotifies</function> after each <function>PQexec</"
"function>. While this still works, it is deprecated as a waste of processing "
"power."
msgstr ""
"Функция <function>PQnotifies</function> в действительности не читает данные "
"с сервера; она просто возвращает сообщения, предварительно собранные другой "
"функцией библиотеки <application>libpq</application>. В предшествующих "
"выпусках <application>libpq</application> единственным способом обеспечения "
"своевременного получения сообщений от команды <command>NOTIFY</command> была "
"постоянная отправка команд, даже пустых, а затем проверка "
"<function>PQnotifies</function> после каждого вызова <function>PQexec</"
"function>. Хотя этот метод всё ещё работает, он не рекомендуется, поскольку "
"растрачивает впустую процессорное время."

#: libpq.xml:4995(para)
msgid ""
"A better way to check for <command>NOTIFY</command> messages when you have "
"no useful commands to execute is to call <function>PQconsumeInput</"
"function>, then check <function>PQnotifies</function>. You can use "
"<function>select()</function> to wait for data to arrive from the server, "
"thereby using no <acronym>CPU</acronym> power unless there is something to "
"do. (See <function>PQsocket</function> to obtain the file descriptor number "
"to use with <function>select()</function>.) Note that this will work OK "
"whether you submit commands with <function>PQsendQuery</function>/"
"<function>PQgetResult</function> or simply use <function>PQexec</function>. "
"You should, however, remember to check <function>PQnotifies</function> after "
"each <function>PQgetResult</function> or <function>PQexec</function>, to see "
"if any notifications came in during the processing of the command."
msgstr ""
"Более хорошим способом проверки наличия сообщений от команды "
"<command>NOTIFY</command>, когда у вас нет полезных команд для выполнения, "
"является вызов функции <function>PQconsumeInput</function> с последующей "
"проверкой <function>PQnotifies</function>. Вы можете использовать "
"<function>select()</function>, чтобы подождать прибытия данных с сервера, "
"тем самым не используя мощности <acronym>CPU</acronym>, если нет полезной "
"работы. (См. <function>PQsocket</function> насчёт получения номера файлового "
"дескриптора для использования его с <function>select()</function>.) Обратите "
"внимание, что это будет хорошо работать, независимо от того, отправляете ли "
"вы команды с помощью <function>PQsendQuery</function>/<function>PQgetResult</"
"function> или просто используете <function>PQexec</function>. Следует, "
"однако, не забывать проверять <function>PQnotifies</function> после каждого "
"вызова <function>PQgetResult</function> или <function>PQexec</function>, "
"чтобы увидеть, не прибыли ли какие-либо уведомления в процессе обработки "
"команды."

#: libpq.xml:5015(title)
msgid "Functions Associated with the <command>COPY</command> Command"
msgstr "Функции, связанные с командой <command>COPY</command>"

#: libpq.xml:5017(indexterm)
msgid "<primary>COPY</primary> <secondary>with libpq</secondary>"
msgstr "<primary>COPY</primary> <secondary>с libpq</secondary>"

#: libpq.xml:5022(para)
msgid ""
"The <command>COPY</command> command in <productname>PostgreSQL</productname> "
"has options to read from or write to the network connection used by "
"<application>libpq</application>. The functions described in this section "
"allow applications to take advantage of this capability by supplying or "
"consuming copied data."
msgstr ""
"Команда <command>COPY</command> в <productname>PostgreSQL</productname> "
"имеет возможность читать и записывать данные через сетевое подключение, "
"установленное <application>libpq</application>. Описанные в этом разделе "
"функции позволяют приложениям воспользоваться этой возможностью для передачи "
"или приёма копируемых данных."

#: libpq.xml:5030(para)
msgid ""
"The overall process is that the application first issues the SQL "
"<command>COPY</command> command via <function>PQexec</function> or one of "
"the equivalent functions. The response to this (if there is no error in the "
"command) will be a <structname>PGresult</structname> object bearing a status "
"code of <literal>PGRES_COPY_OUT</literal> or <literal>PGRES_COPY_IN</"
"literal> (depending on the specified copy direction). The application should "
"then use the functions of this section to receive or transmit data rows. "
"When the data transfer is complete, another <structname>PGresult</"
"structname> object is returned to indicate success or failure of the "
"transfer. Its status will be <literal>PGRES_COMMAND_OK</literal> for success "
"or <literal>PGRES_FATAL_ERROR</literal> if some problem was encountered. At "
"this point further SQL commands can be issued via <function>PQexec</"
"function>. (It is not possible to execute other SQL commands using the same "
"connection while the <command>COPY</command> operation is in progress.)"
msgstr ""
"Общая процедура такова: сначала приложение выдаёт SQL-команду <command>COPY</"
"command>, вызывая <function>PQexec</function> или одну из подобных функций. "
"В ответ оно должно получить (если не возникла ошибка) объект "
"<structname>PGresult</structname> с кодом состояния <literal>PGRES_COPY_OUT</"
"literal> или <literal>PGRES_COPY_IN</literal> (в зависимости от направления "
"копирования). Затем приложение должно использовать функции, описанные в этом "
"разделе, и принимать или передавать строки данных. По завершении передачи "
"возвращается ещё один объект <structname>PGresult</structname>, сообщающий о "
"состоянии завершения передачи. В случае успеха он содержит код состояния "
"<literal>PGRES_COMMAND_OK</literal>, а если возникает какая-то проблема — "
"<literal>PGRES_FATAL_ERROR</literal>. После этого можно продолжать выполнять "
"SQL-команды через <function>PQexec</function>. (Пока операция <command>COPY</"
"command> не завершена, выполнять другие SQL-команды через то же подключение "
"нельзя.)"

#: libpq.xml:5049(para)
msgid ""
"If a <command>COPY</command> command is issued via <function>PQexec</"
"function> in a string that could contain additional commands, the "
"application must continue fetching results via <function>PQgetResult</"
"function> after completing the <command>COPY</command> sequence. Only when "
"<function>PQgetResult</function> returns <symbol>NULL</symbol> is it certain "
"that the <function>PQexec</function> command string is done and it is safe "
"to issue more commands."
msgstr ""
"Если команда <command>COPY</command> была выполнена через <function>PQexec</"
"function> в строке, содержащей дополнительные команды, приложение должно "
"продолжить получать результаты через <function>PQgetResult</function> после "
"завершения последовательности <command>COPY</command>. Только когда "
"<function>PQgetResult</function> возвращает <symbol>NULL</symbol>, можно с "
"уверенностью считать, что командная строка <function>PQexec</function> "
"выполнена полностью, и безопасно передавать другие команды."

#: libpq.xml:5059(para)
msgid ""
"The functions of this section should be executed only after obtaining a "
"result status of <literal>PGRES_COPY_OUT</literal> or "
"<literal>PGRES_COPY_IN</literal> from <function>PQexec</function> or "
"<function>PQgetResult</function>."
msgstr ""
"Функции, описанные в этом разделе, должны выполняться только после получения "
"кода состояния <literal>PGRES_COPY_OUT</literal> или <literal>PGRES_COPY_IN</"
"literal> от функции <function>PQexec</function> или <function>PQgetResult</"
"function>."

#: libpq.xml:5076(indexterm)
msgid "<primary>PQnfields</primary> <secondary>with COPY</secondary>"
msgstr "<primary>PQnfields</primary> <secondary>с COPY</secondary>"

#: libpq.xml:5083(para)
msgid "Returns the number of columns (fields) to be copied."
msgstr "Возвращает число копируемых столбцов (полей)."

#: libpq.xml:5092(indexterm)
msgid "<primary>PQbinaryTuples</primary> <secondary>with COPY</secondary>"
msgstr "<primary>PQbinaryTuples</primary> <secondary>с COPY</secondary>"

#: libpq.xml:5099(para)
msgid ""
"0 indicates the overall copy format is textual (rows separated by newlines, "
"columns separated by separator characters, etc). 1 indicates the overall "
"copy format is binary. See <xref linkend=\"sql-copy\"/> for more information."
msgstr ""
"Значение 0 указывает, что для всей операции копирования применяется "
"текстовый формат (строки разделяются символами новой строки, столбцы "
"разделяются символами-разделителями и т. д.). Значение 1 указывает, что для "
"всей операции копирования применяется двоичный формат. За дополнительными "
"сведениями обратитесь к <xref remap=\"3\" linkend=\"sql-copy\"/>."

#: libpq.xml:5111(indexterm)
msgid "<primary>PQfformat</primary> <secondary>with COPY</secondary>"
msgstr "<primary>PQfformat</primary> <secondary>с COPY</secondary>"

#: libpq.xml:5118(para)
msgid ""
"Returns the format code (0 for text, 1 for binary) associated with each "
"column of the copy operation. The per-column format codes will always be "
"zero when the overall copy format is textual, but the binary format can "
"support both text and binary columns. (However, as of the current "
"implementation of <command>COPY</command>, only binary columns appear in a "
"binary copy; so the per-column formats always match the overall format at "
"present.)"
msgstr ""
"Возвращает код формата (0 — текстовый, 1 — двоичный), связанный с каждым "
"копируемым столбцом. Коды форматов столбцов всегда будут нулевыми, если "
"общий формат копирования — текстовый, но с двоичным форматом поддерживаются "
"и текстовые, и двоичные столбцы. (Однако в текущей реализации <command>COPY</"
"command> при двоичном копировании столбцы могут быть только двоичными, так "
"что форматы столбцов должны всегда соответствовать общему формату.)"

#: libpq.xml:5066(para)
msgid ""
"A <structname>PGresult</structname> object bearing one of these status "
"values carries some additional data about the <command>COPY</command> "
"operation that is starting. This additional data is available using "
"functions that are also used in connection with query results: "
"<placeholder-1/>"
msgstr ""
"Объект <structname>PGresult</structname> с таким кодом состояния содержит "
"дополнительные данные о начавшейся операции <command>COPY</command>. Эти "
"данные можно получить функциями, также применяющимися при обработке "
"результатов запроса: <placeholder-1/>"

#: libpq.xml:5133(para)
msgid ""
"These additional data values are only available when using protocol 3.0. "
"When using protocol 2.0, all these functions will return 0."
msgstr ""
"Эти дополнительные значения данных доступны только при использовании "
"протокола 3.0. С протоколом 2.0 все эти функции возвращают 0."

#: libpq.xml:5140(title)
msgid "Functions for Sending <command>COPY</command> Data"
msgstr "Функции для передачи данных <command>COPY</command>"

#: libpq.xml:5142(para)
msgid ""
"These functions are used to send data during <literal>COPY FROM STDIN</"
"literal>. They will fail if called when the connection is not in "
"<literal>COPY_IN</literal> state."
msgstr ""
"Эти функции применяются для передачи данных при операции <literal>COPY FROM "
"STDIN</literal>. Они не будут работать, если подключение находится не в "
"состоянии <literal>COPY_IN</literal>."

#: libpq.xml:5151(function)
msgid "PQputCopyData"
msgstr "PQputCopyData"

#: libpq.xml:5152(indexterm)
msgid "<primary>PQputCopyData</primary>"
msgstr "<primary>PQputCopyData</primary>"

#: libpq.xml:5158(para)
msgid ""
"Sends data to the server during <literal>COPY_IN</literal> state. "
"<synopsis>\n"
"int PQputCopyData(PGconn *conn,\n"
"                  const char *buffer,\n"
"                  int nbytes);\n"
"</synopsis>"
msgstr ""
"Отправляет данные на сервер, когда активно состояние <literal>COPY_IN</"
"literal>. <synopsis>\n"
"int PQputCopyData(PGconn *conn,\n"
"                  const char *buffer,\n"
"                  int nbytes);\n"
"</synopsis>"

#: libpq.xml:5167(para)
msgid ""
"Transmits the <command>COPY</command> data in the specified "
"<parameter>buffer</parameter>, of length <parameter>nbytes</parameter>, to "
"the server. The result is 1 if the data was queued, zero if it was not "
"queued because of full buffers (this will only happen in nonblocking mode), "
"or -1 if an error occurred. (Use <function>PQerrorMessage</function> to "
"retrieve details if the return value is -1. If the value is zero, wait for "
"write-ready and try again.)"
msgstr ""
"Передаёт серверу данные <command>COPY</command> из указанного буфера "
"(<parameter>buffer</parameter>), длиной <parameter>nbytes</parameter> байт. "
"Она возвращает 1, если данные были переданы, 0, если они не попали в "
"очередь, так как буферы были заполнены (это возможно только в неблокирующем "
"режиме), или -1, если произошла ошибка. (Если возвращено -1, подробности "
"ошибки можно узнать, вызвав <function>PQerrorMessage</function>. Если "
"получен 0, дождитесь состояния готовности к записи и повторите попытку.)"

#: libpq.xml:5178(para)
msgid ""
"The application can divide the <command>COPY</command> data stream into "
"buffer loads of any convenient size. Buffer-load boundaries have no semantic "
"significance when sending. The contents of the data stream must match the "
"data format expected by the <command>COPY</command> command; see <xref "
"linkend=\"sql-copy\"/> for details."
msgstr ""
"Приложение может разделять поток данных <command>COPY</command> на "
"буферизуемые блоки любого удобного размера. Границы буфера не имеют "
"семантического значения при передаче. Содержимое потока данных должно "
"соответствовать формату данных, ожидаемому командой <command>COPY</command>; "
"за подробностями обратитесь к <xref remap=\"3\" linkend=\"sql-copy\"/>."

#: libpq.xml:5190(function)
msgid "PQputCopyEnd"
msgstr "PQputCopyEnd"

#: libpq.xml:5191(indexterm)
msgid "<primary>PQputCopyEnd</primary>"
msgstr "<primary>PQputCopyEnd</primary>"

#: libpq.xml:5197(para)
msgid ""
"Sends end-of-data indication to the server during <literal>COPY_IN</literal> "
"state. <synopsis>\n"
"int PQputCopyEnd(PGconn *conn,\n"
"                 const char *errormsg);\n"
"</synopsis>"
msgstr ""
"Отправляет признак конца данных на сервер, когда активно состояние "
"<literal>COPY_IN</literal>. <synopsis>\n"
"int PQputCopyEnd(PGconn *conn,\n"
"                 const char *errormsg);\n"
"</synopsis>"

#: libpq.xml:5205(para)
msgid ""
"Ends the <literal>COPY_IN</literal> operation successfully if "
"<parameter>errormsg</parameter> is <symbol>NULL</symbol>. If "
"<parameter>errormsg</parameter> is not <symbol>NULL</symbol> then the "
"<command>COPY</command> is forced to fail, with the string pointed to by "
"<parameter>errormsg</parameter> used as the error message. (One should not "
"assume that this exact error message will come back from the server, "
"however, as the server might have already failed the <command>COPY</command> "
"for its own reasons. Also note that the option to force failure does not "
"work when using pre-3.0-protocol connections.)"
msgstr ""
"Завершает операцию <literal>COPY_IN</literal> с успешным результатом, если в "
"<parameter>errormsg</parameter> передаётся <symbol>NULL</symbol>. Если "
"<parameter>errormsg</parameter> не <symbol>NULL</symbol>, команда "
"<command>COPY</command> будет завершена с ошибкой, а сообщением об ошибке "
"будет строка, переданная в <parameter>errormsg</parameter>. (Однако не "
"следует полагать, что именно это сообщение будет получено от сервера назад, "
"так как сервер мог уже прервать операцию <command>COPY</command> по своим "
"причинам. Также заметьте, что принудительный вызов ошибки не работает с "
"соединениями по протоколу версии до 3.0.)"

#: libpq.xml:5218(para)
msgid ""
"The result is 1 if the termination message was sent; or in nonblocking mode, "
"this may only indicate that the termination message was successfully queued. "
"(In nonblocking mode, to be certain that the data has been sent, you should "
"next wait for write-ready and call <function>PQflush</function>, repeating "
"until it returns zero.) Zero indicates that the function could not queue the "
"termination message because of full buffers; this will only happen in "
"nonblocking mode. (In this case, wait for write-ready and try the "
"<function>PQputCopyEnd</function> call again.) If a hard error occurs, -1 is "
"returned; you can use <function>PQerrorMessage</function> to retrieve "
"details."
msgstr ""
"Эта функция возвращает 1, если сообщение завершения было передано; в "
"неблокирующем режиме это означает только, что сообщение завершения успешно "
"поставлено в очередь. (Чтобы удостовериться, что данные были успешно "
"отправлены в неблокирующем режиме, следует дождаться готовности к записи и "
"вызывать <function>PQflush</function> в цикле, пока она не вернёт ноль.) "
"Нулевой результат означает, что функция не смогла поставить сообщение "
"завершения в очередь по причине заполнения буферов; это возможно только в "
"неблокирующем режиме. (В этом случае нужно дождаться готовности к записи и "
"попытаться вызвать <function>PQputCopyEnd</function> снова.) Если "
"действительно происходит ошибка, возвращается -1; получить её подробности "
"можно, вызвав <function>PQerrorMessage</function>."

#: libpq.xml:5232(para)
msgid ""
"After successfully calling <function>PQputCopyEnd</function>, call "
"<function>PQgetResult</function> to obtain the final result status of the "
"<command>COPY</command> command. One can wait for this result to be "
"available in the usual way. Then return to normal operation."
msgstr ""
"После успешного вызова <function>PQputCopyEnd</function> вызовите "
"<function>PQgetResult</function>, чтобы узнать окончательный результат "
"команды <command>COPY</command>. Ожидать появления этого результата можно "
"обычным образом. Затем вернитесь к обычным операциям."

#: libpq.xml:5245(title)
msgid "Functions for Receiving <command>COPY</command> Data"
msgstr "Функции для приёма данных <command>COPY</command>"

#: libpq.xml:5247(para)
msgid ""
"These functions are used to receive data during <literal>COPY TO STDOUT</"
"literal>. They will fail if called when the connection is not in "
"<literal>COPY_OUT</literal> state."
msgstr ""
"Эти функции применяются для получения данных при операции <literal>COPY TO "
"STDOUT</literal>. Они не будут работать, если подключение находится не в "
"состоянии <literal>COPY_OUT</literal>."

#: libpq.xml:5256(function)
msgid "PQgetCopyData"
msgstr "PQgetCopyData"

#: libpq.xml:5257(indexterm)
msgid "<primary>PQgetCopyData</primary>"
msgstr "<primary>PQgetCopyData</primary>"

#: libpq.xml:5263(para)
msgid ""
"Receives data from the server during <literal>COPY_OUT</literal> state. "
"<synopsis>\n"
"int PQgetCopyData(PGconn *conn,\n"
"                  char **buffer,\n"
"                  int async);\n"
"</synopsis>"
msgstr ""
"Принимает данные от сервера, когда активно состояние <literal>COPY_OUT</"
"literal>. <synopsis>\n"
"int PQgetCopyData(PGconn *conn,\n"
"                  char **buffer,\n"
"                  int async);\n"
"</synopsis>"

#: libpq.xml:5272(para)
msgid ""
"Attempts to obtain another row of data from the server during a "
"<command>COPY</command>. Data is always returned one data row at a time; if "
"only a partial row is available, it is not returned. Successful return of a "
"data row involves allocating a chunk of memory to hold the data. The "
"<parameter>buffer</parameter> parameter must be non-<symbol>NULL</symbol>. "
"<parameter>*buffer</parameter> is set to point to the allocated memory, or "
"to <symbol>NULL</symbol> in cases where no buffer is returned. A non-"
"<symbol>NULL</symbol> result buffer should be freed using "
"<function>PQfreemem</function> when no longer needed."
msgstr ""
"Запрашивает следующую строку данных с сервера в процессе операции "
"<command>COPY</command>. Данные всегда возвращаются строка за строкой; если "
"поступила только часть строки, она не возвращается. Успешное получение "
"строки данных подразумевает выделение блока памяти для этих данных. В "
"параметре <parameter>buffer</parameter> ей передаётся указатель, отличный от "
"<symbol>NULL</symbol>. По адресу <parameter>*buffer</parameter> записывается "
"указатель на выделенную память, либо <symbol>NULL</symbol>, когда буфер не "
"возвращается. Если буфер результата отличен от <symbol>NULL</symbol>, его "
"следует освободить, когда он станет не нужен, вызвав <function>PQfreemem</"
"function>."

#: libpq.xml:5285(para)
msgid ""
"When a row is successfully returned, the return value is the number of data "
"bytes in the row (this will always be greater than zero). The returned "
"string is always null-terminated, though this is probably only useful for "
"textual <command>COPY</command>. A result of zero indicates that the "
"<command>COPY</command> is still in progress, but no row is yet available "
"(this is only possible when <parameter>async</parameter> is true). A result "
"of -1 indicates that the <command>COPY</command> is done. A result of -2 "
"indicates that an error occurred (consult <function>PQerrorMessage</"
"function> for the reason)."
msgstr ""
"Когда строка получена успешно, возвращается число байт данных в этой строке "
"(это число всегда больше нуля). Возвращаемое строковое значение всегда "
"завершается нулём, хотя это полезно, вероятно, только для текстовой "
"<command>COPY</command>. Нулевой результат означает, что операция "
"<command>COPY</command> продолжает выполняться, но строка ещё не готова (это "
"возможно, только когда параметр <parameter>async</parameter> равен true). "
"Возвращённое значение -1 означает, что команда <command>COPY</command> "
"завершена, а -2 показывает, что произошла ошибка (её причину можно узнать с "
"помощью <function>PQerrorMessage</function>)."

#: libpq.xml:5297(para)
msgid ""
"When <parameter>async</parameter> is true (not zero), "
"<function>PQgetCopyData</function> will not block waiting for input; it will "
"return zero if the <command>COPY</command> is still in progress but no "
"complete row is available. (In this case wait for read-ready and then call "
"<function>PQconsumeInput</function> before calling <function>PQgetCopyData</"
"function> again.) When <parameter>async</parameter> is false (zero), "
"<function>PQgetCopyData</function> will block until data is available or the "
"operation completes."
msgstr ""
"Когда параметр <parameter>async</parameter> равен true (отличен от нуля), "
"функция <function>PQgetCopyData</function> не будет блокироваться, ожидая "
"данных; она возвратит ноль, если выполнение <command>COPY</command> "
"продолжается, но полная строка ещё не получена. (В этом случае нужно "
"дождаться готовности к чтению и затем вызвать <function>PQconsumeInput</"
"function>, прежде чем вызывать <function>PQgetCopyData</function> ещё раз.) "
"Когда <parameter>async</parameter> равен false (нулю), "
"<function>PQgetCopyData</function> будет заблокирована до поступления данных "
"или окончания операции."

#: libpq.xml:5308(para)
msgid ""
"After <function>PQgetCopyData</function> returns -1, call "
"<function>PQgetResult</function> to obtain the final result status of the "
"<command>COPY</command> command. One can wait for this result to be "
"available in the usual way. Then return to normal operation."
msgstr ""
"Когда <function>PQgetCopyData</function> возвращает -1, вызовите "
"<function>PQgetResult</function>, чтобы узнать окончательный результат "
"команды <command>COPY</command>. Ожидать появления этого результата можно "
"обычным образом. Затем вернитесь к обычным операциям."

#: libpq.xml:5321(title)
msgid "Obsolete Functions for <command>COPY</command>"
msgstr "Устаревшие функции для <command>COPY</command>"

#: libpq.xml:5323(para)
msgid ""
"These functions represent older methods of handling <command>COPY</command>. "
"Although they still work, they are deprecated due to poor error handling, "
"inconvenient methods of detecting end-of-data, and lack of support for "
"binary or nonblocking transfers."
msgstr ""
"Эти функции представляют старые методы выполнения операции <command>COPY</"
"command>. Хотя они продолжают работать, они признаны устаревшими из-за "
"плохой обработки ошибок, неудобных способов обнаружения конца данных и "
"отсутствия поддержки двоичных или неблокирующих передач."

#: libpq.xml:5333(function)
msgid "PQgetline"
msgstr "PQgetline"

#: libpq.xml:5334(indexterm)
msgid "<primary>PQgetline</primary>"
msgstr "<primary>PQgetline</primary>"

#: libpq.xml:5340(para)
msgid ""
"Reads a newline-terminated line of characters (transmitted by the server) "
"into a buffer string of size <parameter>length</parameter>. <synopsis>\n"
"int PQgetline(PGconn *conn,\n"
"              char *buffer,\n"
"              int length);\n"
"</synopsis>"
msgstr ""
"Читает передаваемую сервером строку символов, завершающуюся символом новой "
"строки, в буфер (buffer) размера <parameter>length</parameter>. <synopsis>\n"
"int PQgetline(PGconn *conn,\n"
"              char *buffer,\n"
"              int length);\n"
"</synopsis>"

#: libpq.xml:5350(para)
msgid ""
"This function copies up to <parameter>length</parameter>-1 characters into "
"the buffer and converts the terminating newline into a zero byte. "
"<function>PQgetline</function> returns <symbol>EOF</symbol> at the end of "
"input, 0 if the entire line has been read, and 1 if the buffer is full but "
"the terminating newline has not yet been read."
msgstr ""
"Эта функция копирует <parameter>length</parameter>-1 символов в буфер и "
"преобразует символ конца строки в нулевой байт. <function>PQgetline</"
"function> возвращает <symbol>EOF</symbol> в конце ввода, 0, если была "
"прочитана вся строка, и 1, если буфер заполнен, но завершающий символ конца "
"строки ещё не прочитан."

#: libpq.xml:5357(para)
msgid ""
"Note that the application must check to see if a new line consists of the "
"two characters <literal>\\.</literal>, which indicates that the server has "
"finished sending the results of the <command>COPY</command> command. If the "
"application might receive lines that are more than <parameter>length</"
"parameter>-1 characters long, care is needed to be sure it recognizes the "
"<literal>\\.</literal> line correctly (and does not, for example, mistake "
"the end of a long data line for a terminator line)."
msgstr ""
"Заметьте, что приложение должно проверить, не состоит ли новая строка в "
"точности из двух символов <literal>\\.</literal>, что будет означать, что "
"сервер завершил передачу результатов команды <command>COPY</command>. Если "
"приложение может принимать строки длиннее <parameter>length</parameter>-1 "
"символов, необходимо позаботиться о том, чтобы оно корректно распознавало "
"строку <literal>\\.</literal> (а не воспринимало, например, конец длинной "
"строки данных как завершающую строку)."

#: libpq.xml:5372(function)
msgid "PQgetlineAsync"
msgstr "PQgetlineAsync"

#: libpq.xml:5373(indexterm)
msgid "<primary>PQgetlineAsync</primary>"
msgstr "<primary>PQgetlineAsync</primary>"

#: libpq.xml:5379(para)
msgid ""
"Reads a row of <command>COPY</command> data (transmitted by the server) into "
"a buffer without blocking. <synopsis>\n"
"int PQgetlineAsync(PGconn *conn,\n"
"                   char *buffer,\n"
"                   int bufsize);\n"
"</synopsis>"
msgstr ""
"Читает передаваемую сервером строку данных <command>COPY</command> в буфер "
"без блокировки. <synopsis>\n"
"int PQgetlineAsync(PGconn *conn,\n"
"                   char *buffer,\n"
"                   int bufsize);\n"
"</synopsis>"

#: libpq.xml:5389(para)
msgid ""
"This function is similar to <function>PQgetline</function>, but it can be "
"used by applications that must read <command>COPY</command> data "
"asynchronously, that is, without blocking. Having issued the <command>COPY</"
"command> command and gotten a <literal>PGRES_COPY_OUT</literal> response, "
"the application should call <function>PQconsumeInput</function> and "
"<function>PQgetlineAsync</function> until the end-of-data signal is detected."
msgstr ""
"Эта функция похожа на <function>PQgetline</function>, но может применяться в "
"приложениях, которые должны читать данные <command>COPY</command> "
"асинхронно, то есть, без блокировки. Запустив команду <command>COPY</"
"command> и получив ответ <literal>PGRES_COPY_OUT</literal>, приложение "
"должно вызывать <function>PQconsumeInput</function> и "
"<function>PQgetlineAsync</function>, пока не будет получен сигнал конца "
"данных."

#: libpq.xml:5399(para)
msgid ""
"Unlike <function>PQgetline</function>, this function takes responsibility "
"for detecting end-of-data."
msgstr ""
"В отличие от <function>PQgetline</function>, эта функция сама отвечает за "
"обнаружение конца данных."

#: libpq.xml:5404(para)
msgid ""
"On each call, <function>PQgetlineAsync</function> will return data if a "
"complete data row is available in <application>libpq</application>'s input "
"buffer. Otherwise, no data is returned until the rest of the row arrives. "
"The function returns -1 if the end-of-copy-data marker has been recognized, "
"or 0 if no data is available, or a positive number giving the number of "
"bytes of data returned. If -1 is returned, the caller must next call "
"<function>PQendcopy</function>, and then return to normal processing."
msgstr ""
"При каждом вызове <function>PQgetlineAsync</function> будет возвращать "
"данные, если во входном буфере <application>libpq</application> оказывается "
"полная строка данных. В противном случае никакие данные не возвращаются до "
"поступления остального содержимого строки. Эта функция возвращает -1, если "
"обнаруживается признак завершения копирования, или 0, если данные не "
"получены, или положительное количество возвращённых байт данных. Если "
"возвращается -1, вызывающий код должен затем вызвать <function>PQendcopy</"
"function> и после этого перейти в обычный режим работы."

#: libpq.xml:5414(para)
msgid ""
"The data returned will not extend beyond a data-row boundary. If possible a "
"whole row will be returned at one time. But if the buffer offered by the "
"caller is too small to hold a row sent by the server, then a partial data "
"row will be returned. With textual data this can be detected by testing "
"whether the last returned byte is <literal>\\n</literal> or not. (In a "
"binary <command>COPY</command>, actual parsing of the <command>COPY</"
"command> data format will be needed to make the equivalent determination.) "
"The returned string is not null-terminated. (If you want to add a "
"terminating null, be sure to pass a <parameter>bufsize</parameter> one "
"smaller than the room actually available.)"
msgstr ""
"Возвращаемые данные не будут пересекать границы строк данных. При этом может "
"быть возвращена одна строка целиком. Но если буфер, выделенный вызывающим "
"кодом, оказывается слишком мал для строки, передаваемой сервером, возвращена "
"будет часть строки. Когда передаются текстовые данные, это можно выявить, "
"проверив, содержит ли последний возвращаемый байт символ <literal>\\n</"
"literal>. (Для <command>COPY</command> в двоичном формате потребуется "
"собственно разобрать формат данных <command>COPY</command>, чтобы выявить "
"подобную ситуацию.) Возвращаемая строка не завершается нулём. (Если вы "
"хотите получить строку с нулём в конце, передайте в <parameter>bufsize</"
"parameter> число на единицу меньше фактического размера блока.)"

#: libpq.xml:5431(function)
msgid "PQputline"
msgstr "PQputline"

#: libpq.xml:5432(indexterm)
msgid "<primary>PQputline</primary>"
msgstr "<primary>PQputline</primary>"

#: libpq.xml:5438(para)
msgid ""
"Sends a null-terminated string to the server. Returns 0 if OK and "
"<symbol>EOF</symbol> if unable to send the string. <synopsis>\n"
"int PQputline(PGconn *conn,\n"
"              const char *string);\n"
"</synopsis>"
msgstr ""
"Передаёт серверу строку, завершённую нулём. Возвращает 0 в случае успеха, "
"либо <symbol>EOF</symbol>, если передать строку не удаётся. <synopsis>\n"
"int PQputline(PGconn *conn,\n"
"              const char *string);\n"
"</synopsis>"

#: libpq.xml:5447(para)
msgid ""
"The <command>COPY</command> data stream sent by a series of calls to "
"<function>PQputline</function> has the same format as that returned by "
"<function>PQgetlineAsync</function>, except that applications are not "
"obliged to send exactly one data row per <function>PQputline</function> "
"call; it is okay to send a partial line or multiple lines per call."
msgstr ""
"Поток данных <command>COPY</command>, передаваемых последовательностью "
"вызовов <function>PQputline</function>, имеет тот же формат, что возвращает "
"<function>PQgetlineAsync</function>, за исключением того, что приложения не "
"обязательно должны передавать по одной строке данных за вызов "
"<function>PQputline</function>; они могут посылать части строк или сразу "
"несколько строк."

#: libpq.xml:5457(para)
msgid ""
"Before <productname>PostgreSQL</productname> protocol 3.0, it was necessary "
"for the application to explicitly send the two characters <literal>\\.</"
"literal> as a final line to indicate to the server that it had finished "
"sending <command>COPY</command> data. While this still works, it is "
"deprecated and the special meaning of <literal>\\.</literal> can be expected "
"to be removed in a future release. It is sufficient to call "
"<function>PQendcopy</function> after having sent the actual data."
msgstr ""
"До версии 3.0 протокола <productname>PostgreSQL</productname> приложение "
"должно было явно отправлять два символа <literal>\\.</literal> последней "
"строкой, чтобы сообщить серверу, что оно закончило передачу данных "
"<command>COPY</command>. Хотя это по-прежнему работает, такое поведение "
"считается устаревшим и ожидается, что особое значение <literal>\\.</literal> "
"будет исключено в будущих версиях. Передав собственно данные, сейчас "
"достаточно вызвать <function>PQendcopy</function>."

#: libpq.xml:5472(function)
msgid "PQputnbytes"
msgstr "PQputnbytes"

#: libpq.xml:5473(indexterm)
msgid "<primary>PQputnbytes</primary>"
msgstr "<primary>PQputnbytes</primary>"

#: libpq.xml:5479(para)
msgid ""
"Sends a non-null-terminated string to the server. Returns 0 if OK and "
"<symbol>EOF</symbol> if unable to send the string. <synopsis>\n"
"int PQputnbytes(PGconn *conn,\n"
"                const char *buffer,\n"
"                int nbytes);\n"
"</synopsis>"
msgstr ""
"Передаёт серверу строку, не завершённую нулём. Возвращает 0 в случае успеха, "
"либо <symbol>EOF</symbol>, если передать строку не удаётся. <synopsis>\n"
"int PQputnbytes(PGconn *conn,\n"
"                const char *buffer,\n"
"                int nbytes);\n"
"</synopsis>"

#: libpq.xml:5489(para)
msgid ""
"This is exactly like <function>PQputline</function>, except that the data "
"buffer need not be null-terminated since the number of bytes to send is "
"specified directly. Use this procedure when sending binary data."
msgstr ""
"Поведение этой функции не отличается от <function>PQputline</function>, но "
"её буфер данных не должен содержать завершающий ноль, так как для неё число "
"передаваемых байт задаётся непосредственно. Используйте эту функцию для "
"передачи двоичных данных."

#: libpq.xml:5499(function)
msgid "PQendcopy"
msgstr "PQendcopy"

#: libpq.xml:5500(indexterm)
msgid "<primary>PQendcopy</primary>"
msgstr "<primary>PQendcopy</primary>"

#: libpq.xml:5506(para)
msgid ""
"Synchronizes with the server. <synopsis>\n"
"int PQendcopy(PGconn *conn);\n"
"</synopsis> This function waits until the server has finished the copying. "
"It should either be issued when the last string has been sent to the server "
"using <function>PQputline</function> or when the last string has been "
"received from the server using <function>PGgetline</function>. It must be "
"issued or the server will get <quote>out of sync</quote> with the client. "
"Upon return from this function, the server is ready to receive the next SQL "
"command. The return value is 0 on successful completion, nonzero otherwise. "
"(Use <function>PQerrorMessage</function> to retrieve details if the return "
"value is nonzero.)"
msgstr ""
"Производит синхронизацию с сервером. <synopsis>\n"
"int PQendcopy(PGconn *conn);\n"
"</synopsis> Эта функция ожидает завершения копирования сервером. Её следует "
"вызывать, либо когда серверу была передана последняя строка функцией "
"<function>PQputline</function>, либо когда от сервера была получена "
"последняя строка функцией <function>PGgetline</function>. Если её не "
"вызвать, сервер <quote>потеряет синхронизацию</quote> с клиентом. После "
"завершения этой функции сервер готов принимать следующую команду SQL. В "
"случае успешного завершения возвращается 0, в противном случае — ненулевое "
"значение. (Чтобы получить подробности ошибки при ненулевом значении, "
"вызовите <function>PQerrorMessage</function>.)"

#: libpq.xml:5523(para)
msgid ""
"When using <function>PQgetResult</function>, the application should respond "
"to a <literal>PGRES_COPY_OUT</literal> result by executing "
"<function>PQgetline</function> repeatedly, followed by <function>PQendcopy</"
"function> after the terminator line is seen. It should then return to the "
"<function>PQgetResult</function> loop until <function>PQgetResult</function> "
"returns a null pointer. Similarly a <literal>PGRES_COPY_IN</literal> result "
"is processed by a series of <function>PQputline</function> calls followed by "
"<function>PQendcopy</function>, then return to the <function>PQgetResult</"
"function> loop. This arrangement will ensure that a <command>COPY</command> "
"command embedded in a series of <acronym>SQL</acronym> commands will be "
"executed correctly."
msgstr ""
"Вызывая <function>PQgetResult</function>, приложение должно обрабатывать "
"результат <literal>PGRES_COPY_OUT</literal>, в цикле выполняя "
"<function>PQgetline</function>, а обнаружив завершающую строку, вызвать "
"<function>PQendcopy</function>. Затем оно должно вернуться к циклу "
"<function>PQgetResult</function>, и выйти из него, когда "
"<function>PQgetResult</function> возвратит нулевой указатель. Подобным "
"образом, получив результат <literal>PGRES_COPY_IN</literal>, приложение "
"должно выполнить серию вызовов <function>PQputline</function>, завершить её, "
"вызвав <function>PQendcopy</function>, а затем вернуться к циклу "
"<function>PQgetResult</function>. При такой организации обработки команда "
"<command>COPY</command> будет корректно выполняться и в составе "
"последовательности команд <acronym>SQL</acronym>."

#: libpq.xml:5538(para)
msgid ""
"Older applications are likely to submit a <command>COPY</command> via "
"<function>PQexec</function> and assume that the transaction is done after "
"<function>PQendcopy</function>. This will work correctly only if the "
"<command>COPY</command> is the only <acronym>SQL</acronym> command in the "
"command string."
msgstr ""
"Старые приложения обычно передают команду <command>COPY</command> через "
"<function>PQexec</function> и рассчитывают, что транзакция будет завершена "
"после <function>PQendcopy</function>. Это будет работать, только если "
"команда <command>COPY</command> является единственной <acronym>SQL</acronym>-"
"командой в строке команд."

#: libpq.xml:5554(title)
msgid "Control Functions"
msgstr "Функции управления"

#: libpq.xml:5556(para)
msgid ""
"These functions control miscellaneous details of <application>libpq</"
"application>'s behavior."
msgstr ""
"Эти функции управляют различными аспектами поведения <application>libpq</"
"application>."

#: libpq.xml:5564(function)
msgid "PQclientEncoding"
msgstr "PQclientEncoding"

#: libpq.xml:5565(indexterm)
msgid "<primary>PQclientEncoding</primary>"
msgstr "<primary>PQclientEncoding</primary>"

#: libpq.xml:5571(para)
msgid ""
"Returns the client encoding. <synopsis>\n"
"int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);\n"
"</synopsis> Note that it returns the encoding ID, not a symbolic string such "
"as <literal>EUC_JP</literal>. If unsuccessful, it returns -1. To convert an "
"encoding ID to an encoding name, you can use: <synopsis>\n"
"char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);\n"
"</synopsis>"
msgstr ""
"Возвращает кодировку клиента. <synopsis>\n"
"int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);\n"
"</synopsis> Заметьте, что она возвращает идентификатор кодировки, а не "
"символьную строку вида <literal>EUC_JP</literal>. В случае ошибки она "
"возвращает -1. Преобразовать идентификатор кодировки в имя можно, "
"воспользовавшись следующей функцией: <synopsis>\n"
"char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);\n"
"</synopsis>"

#: libpq.xml:5591(function)
msgid "PQsetClientEncoding"
msgstr "PQsetClientEncoding"

#: libpq.xml:5592(indexterm)
msgid "<primary>PQsetClientEncoding</primary>"
msgstr "<primary>PQsetClientEncoding</primary>"

#: libpq.xml:5598(para)
msgid ""
"Sets the client encoding. <synopsis>\n"
"int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char "
"*<replaceable>encoding</replaceable>);\n"
"</synopsis> <replaceable>conn</replaceable> is a connection to the server, "
"and <replaceable>encoding</replaceable> is the encoding you want to use. If "
"the function successfully sets the encoding, it returns 0, otherwise -1. The "
"current encoding for this connection can be determined by using "
"<function>PQclientEncoding</function>."
msgstr ""
"Устанавливает кодировку клиента. <synopsis>\n"
"int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char "
"*<replaceable>encoding</replaceable>);\n"
"</synopsis> В <replaceable>conn</replaceable> передаётся соединение с "
"сервером, а в <replaceable>encoding</replaceable> — имя требуемой кодировки. "
"Если функция устанавливает кодировку успешно, она возвращает 0, или -1 в "
"противном случае. Определить текущую кодировку для соединения можно, "
"воспользовавшись функцией <function>PQclientEncoding</function>."

#: libpq.xml:5615(function)
msgid "PQsetErrorVerbosity"
msgstr "PQsetErrorVerbosity"

#: libpq.xml:5616(indexterm)
msgid "<primary>PQsetErrorVerbosity</primary>"
msgstr "<primary>PQsetErrorVerbosity</primary>"

#: libpq.xml:5622(para)
msgid ""
"Determines the verbosity of messages returned by <function>PQerrorMessage</"
"function> and <function>PQresultErrorMessage</function>. <synopsis>\n"
"typedef enum\n"
"{\n"
"    PQERRORS_TERSE,\n"
"    PQERRORS_DEFAULT,\n"
"    PQERRORS_VERBOSE\n"
"} PGVerbosity;\n"
"\n"
"PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);\n"
"</synopsis> <function>PQsetErrorVerbosity</function> sets the verbosity "
"mode, returning the connection's previous setting. In <firstterm>TERSE</"
"firstterm> mode, returned messages include severity, primary text, and "
"position only; this will normally fit on a single line. The default mode "
"produces messages that include the above plus any detail, hint, or context "
"fields (these might span multiple lines). The <firstterm>VERBOSE</firstterm> "
"mode includes all available fields. Changing the verbosity does not affect "
"the messages available from already-existing <structname>PGresult</"
"structname> objects, only subsequently-created ones. (But see "
"<function>PQresultVerboseErrorMessage</function> if you want to print a "
"previous error with a different verbosity.)"
msgstr ""
"Определяет уровень детализации сообщений, возвращаемых функциями "
"<function>PQerrorMessage</function> и <function>PQresultErrorMessage</"
"function>. <synopsis>\n"
"typedef enum\n"
"{\n"
"    PQERRORS_TERSE,\n"
"    PQERRORS_DEFAULT,\n"
"    PQERRORS_VERBOSE\n"
"} PGVerbosity;\n"
"\n"
"PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);\n"
"</synopsis> <function>PQsetErrorVerbosity</function> устанавливает уровень "
"детализации и возвращает предыдущее значение для соединения. В &laquo;"
"лаконичном&raquo; режиме (<firstterm>TERSE</firstterm>) возвращаемые "
"сообщения содержат только уровень серьёзности, основной текст и позицию; всё "
"это обычно умещается в одной строке. В режиме по умолчанию выдаваемые "
"сообщения дополнительно содержат поля подробного описания, подсказки или "
"контекста (они могут занимать несколько строк). В &laquo;многословном&raquo; "
"режиме (<firstterm>VERBOSE</firstterm>) передаются все доступные поля "
"сообщения. Изменение уровня детализации не влияет на сообщения, уже "
"сформированные в существующих объектах <structname>PGresult</structname>, а "
"затрагивает только последующие сообщения. (Но можно воспользоваться "
"<function>PQresultVerboseErrorMessage</function>, чтобы получить предыдущую "
"ошибку с другим уровнем детализации.)"

#: libpq.xml:5653(function)
msgid "PQsetErrorContextVisibility"
msgstr "PQsetErrorContextVisibility"

#: libpq.xml:5654(indexterm)
msgid "<primary>PQsetErrorContextVisibility</primary>"
msgstr "<primary>PQsetErrorContextVisibility</primary>"

#: libpq.xml:5660(para)
msgid ""
"Determines the handling of <literal>CONTEXT</literal> fields in messages "
"returned by <function>PQerrorMessage</function> and "
"<function>PQresultErrorMessage</function>. <synopsis>\n"
"typedef enum\n"
"{\n"
"    PQSHOW_CONTEXT_NEVER,\n"
"    PQSHOW_CONTEXT_ERRORS,\n"
"    PQSHOW_CONTEXT_ALWAYS\n"
"} PGContextVisibility;\n"
"\n"
"PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, "
"PGContextVisibility show_context);\n"
"</synopsis> <function>PQsetErrorContextVisibility</function> sets the "
"context display mode, returning the connection's previous setting. This mode "
"controls whether the <literal>CONTEXT</literal> field is included in "
"messages (unless the verbosity setting is <firstterm>TERSE</firstterm>, in "
"which case <literal>CONTEXT</literal> is never shown). The <firstterm>NEVER</"
"firstterm> mode never includes <literal>CONTEXT</literal>, while "
"<firstterm>ALWAYS</firstterm> always includes it if available. In "
"<firstterm>ERRORS</firstterm> mode (the default), <literal>CONTEXT</literal> "
"fields are included only for error messages, not for notices and warnings. "
"Changing this mode does not affect the messages available from already-"
"existing <structname>PGresult</structname> objects, only subsequently-"
"created ones. (But see <function>PQresultVerboseErrorMessage</function> if "
"you want to print a previous error with a different display mode.)"
msgstr ""
"Определяет вариант обработки полей <literal>КОНТЕКСТ</literal> в сообщениях, "
"возвращаемых функциями <function>PQerrorMessage</function> и "
"<function>PQresultErrorMessage</function>. <synopsis>\n"
"typedef enum\n"
"{\n"
"    PQSHOW_CONTEXT_NEVER,\n"
"    PQSHOW_CONTEXT_ERRORS,\n"
"    PQSHOW_CONTEXT_ALWAYS\n"
"} PGContextVisibility;\n"
"\n"
"PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, "
"PGContextVisibility show_context);\n"
"</synopsis> <function>PQsetErrorContextVisibility</function> устанавливает "
"режим вывода контекста сообщений и возвращает предыдущее значение. В "
"зависимости от этого режима, поле <literal>КОНТЕКСТ</literal> может "
"включаться в сообщения или нет (если только не выбран уровень детализации "
"<firstterm>TERSE</firstterm>, при котором <literal>КОНТЕКСТ</literal> не "
"выводится никогда). В режиме <firstterm>NEVER</firstterm> поле "
"<literal>КОНТЕКСТ</literal> не выводится никогда, а в режиме "
"<firstterm>ALWAYS</firstterm>, выводится всегда (если оно имеется). В режиме "
"<firstterm>ERRORS</firstterm> (по умолчанию), поля <literal>CONTEXT</"
"literal> включаются только в сообщения об ошибках, но не в уведомления или "
"предупреждения. Изменение этого уровня не влияет на сообщения, уже "
"сформированные в существующих объектах <structname>PGresult</structname>, а "
"затрагивает только последующие сообщения. (Но можно воспользоваться "
"<function>PQresultVerboseErrorMessage</function>, чтобы получить предыдущую "
"ошибку с другим режимом вывода контекста.)"

#: libpq.xml:5695(function)
msgid "PQtrace"
msgstr "PQtrace"

#: libpq.xml:5696(indexterm)
msgid "<primary>PQtrace</primary>"
msgstr "<primary>PQtrace</primary>"

#: libpq.xml:5702(para)
msgid ""
"Enables tracing of the client/server communication to a debugging file "
"stream. <synopsis>\n"
"void PQtrace(PGconn *conn, FILE *stream);\n"
"</synopsis>"
msgstr ""
"Включает трассировку клиент-серверного взаимодействия с выводом в поток "
"отладочных сообщений. <synopsis>\n"
"void PQtrace(PGconn *conn, FILE *stream);\n"
"</synopsis>"

#: libpq.xml:5710(para)
msgid ""
"On Windows, if the <application>libpq</application> library and an "
"application are compiled with different flags, this function call will crash "
"the application because the internal representation of the <literal>FILE</"
"literal> pointers differ. Specifically, multithreaded/single-threaded, "
"release/debug, and static/dynamic flags should be the same for the library "
"and all applications using that library."
msgstr ""
"В Windows, если библиотека <application>libpq</application> и приложение "
"скомпилированы с разными флагами, эта функция может вызвать крах приложения "
"из-за различий внутреннего представления указателей <literal>FILE</literal>. "
"В частности, флаги многопоточной/однопоточной, выпускаемой/отладочной или "
"статической/динамической сборки должны быть одинаковыми для библиотеки и "
"всех использующих её приложений."

#: libpq.xml:5725(function)
msgid "PQuntrace"
msgstr "PQuntrace"

#: libpq.xml:5726(indexterm)
msgid "<primary>PQuntrace</primary>"
msgstr "<primary>PQuntrace</primary>"

#: libpq.xml:5732(para)
msgid ""
"Disables tracing started by <function>PQtrace</function>. <synopsis>\n"
"void PQuntrace(PGconn *conn);\n"
"</synopsis>"
msgstr ""
"Выключает трассировку, запущенную функцией <function>PQtrace</function>. "
"<synopsis>\n"
"void PQuntrace(PGconn *conn);\n"
"</synopsis>"

#: libpq.xml:5745(title)
msgid "Miscellaneous Functions"
msgstr "Функции разного назначения"

#: libpq.xml:5747(para)
msgid "As always, there are some functions that just don't fit anywhere."
msgstr ""
"Как всегда, находятся функции, которые не попадают ни в одну из категорий."

#: libpq.xml:5754(function)
msgid "PQfreemem"
msgstr "PQfreemem"

#: libpq.xml:5755(indexterm)
msgid "<primary>PQfreemem</primary>"
msgstr "<primary>PQfreemem</primary>"

#: libpq.xml:5761(para)
msgid ""
"Frees memory allocated by <application>libpq</application>. <synopsis>\n"
"void PQfreemem(void *ptr);\n"
"</synopsis>"
msgstr ""
"Освобождает память, которую выделила <application>libpq</application>. "
"<synopsis>\n"
"void PQfreemem(void *ptr);\n"
"</synopsis>"

#: libpq.xml:5768(para)
msgid ""
"Frees memory allocated by <application>libpq</application>, particularly "
"<function>PQescapeByteaConn</function>, <function>PQescapeBytea</function>, "
"<function>PQunescapeBytea</function>, and <function>PQnotifies</function>. "
"It is particularly important that this function, rather than "
"<function>free()</function>, be used on Microsoft Windows. This is because "
"allocating memory in a DLL and releasing it in the application works only if "
"multithreaded/single-threaded, release/debug, and static/dynamic flags are "
"the same for the DLL and the application. On non-Microsoft Windows "
"platforms, this function is the same as the standard library function "
"<function>free()</function>."
msgstr ""
"Освобождает память, выделенную библиотекой <application>libpq</application>, "
"а именно функциями <function>PQescapeByteaConn</function>, "
"<function>PQescapeBytea</function>, <function>PQunescapeBytea</function> и "
"<function>PQnotifies</function>. Особенно важно использовать именно эту "
"функцию, а не <function>free()</function>, в Microsoft Windows. Это связано "
"с тем, что выделение памяти в DLL и освобождение её в приложении будет "
"работать, только если флаги многопоточной/однопоточной, выпускаемой/"
"отладочной или статической/динамической сборки для DLL и приложения "
"полностью совпадают. На других платформах эта функция действует так же, как "
"стандартная библиотечная функция <function>free()</function>."

#: libpq.xml:5787(function)
msgid "PQconninfoFree"
msgstr "PQconninfoFree"

#: libpq.xml:5788(indexterm)
msgid "<primary>PQconninfoFree</primary>"
msgstr "<primary>PQconninfoFree</primary>"

#: libpq.xml:5794(para)
msgid ""
"Frees the data structures allocated by <function>PQconndefaults</function> "
"or <function>PQconninfoParse</function>. <synopsis>\n"
"void PQconninfoFree(PQconninfoOption *connOptions);\n"
"</synopsis>"
msgstr ""
"Освобождает структуры данных, выделенные функциями <function>PQconndefaults</"
"function> и <function>PQconninfoParse</function>. <synopsis>\n"
"void PQconninfoFree(PQconninfoOption *connOptions);\n"
"</synopsis>"

#: libpq.xml:5802(para)
msgid ""
"A simple <function>PQfreemem</function> will not do for this, since the "
"array contains references to subsidiary strings."
msgstr ""
"Простая функция <function>PQfreemem</function> не подойдёт для этого, так "
"как эти структуры содержат ссылки на подчинённые строки."

#: libpq.xml:5811(function)
msgid "PQencryptPassword"
msgstr "PQencryptPassword"

#: libpq.xml:5812(indexterm)
msgid "<primary>PQencryptPassword</primary>"
msgstr "<primary>PQencryptPassword</primary>"

#: libpq.xml:5818(para)
msgid ""
"Prepares the encrypted form of a <productname>PostgreSQL</productname> "
"password. <synopsis>\n"
"char * PQencryptPassword(const char *passwd, const char *user);\n"
"</synopsis> This function is intended to be used by client applications that "
"wish to send commands like <literal>ALTER USER joe PASSWORD 'pwd'</literal>. "
"It is good practice not to send the original cleartext password in such a "
"command, because it might be exposed in command logs, activity displays, and "
"so on. Instead, use this function to convert the password to encrypted form "
"before it is sent. The arguments are the cleartext password, and the SQL "
"name of the user it is for. The return value is a string allocated by "
"<function>malloc</function>, or <symbol>NULL</symbol> if out of memory. The "
"caller can assume the string doesn't contain any special characters that "
"would require escaping. Use <function>PQfreemem</function> to free the "
"result when done with it."
msgstr ""
"Подготавливает зашифрованную форму пароля <productname>PostgreSQL</"
"productname>. <synopsis>\n"
"char * PQencryptPassword(const char *passwd, const char *user);\n"
"</synopsis> Эта функция предназначена для клиентских приложений, желающих "
"передавать команды вида <literal>ALTER USER joe PASSWORD 'pwd'</literal>. В "
"такой команде лучше не передавать исходный пароль открытым текстом, так как "
"он может появиться в рабочих журналах, мониторе активности и т. д. Вместо "
"этого, воспользуйтесь данной функцией и переведите пароль в зашифрованную "
"форму, прежде чем передавать его. В аргументах ей передаётся пароль в "
"открытом виде и имя пользователя SQL, для которого он предназначен. "
"Возвращает она строку, выделенную функцией <function>malloc</function>, или "
"<symbol>NULL</symbol> в случае нехватки памяти. Вызывающий код может "
"рассчитывать на то, что в этой строке не будет специальных символов, "
"требующих экранирования. Завершив работу с этой строкой, вызовите "
"<function>PQfreemem</function>, чтобы освободить её."

#: libpq.xml:5841(function)
msgid "PQmakeEmptyPGresult"
msgstr "PQmakeEmptyPGresult"

#: libpq.xml:5842(indexterm)
msgid "<primary>PQmakeEmptyPGresult</primary>"
msgstr "<primary>PQmakeEmptyPGresult</primary>"

#: libpq.xml:5848(para)
msgid ""
"Constructs an empty <structname>PGresult</structname> object with the given "
"status. <synopsis>\n"
"PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);\n"
"</synopsis>"
msgstr ""
"Конструирует пустой объект <structname>PGresult</structname> с указанным "
"состоянием. <synopsis>\n"
"PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);\n"
"</synopsis>"

#: libpq.xml:5855(para)
msgid ""
"This is <application>libpq</application>'s internal function to allocate and "
"initialize an empty <structname>PGresult</structname> object. This function "
"returns <symbol>NULL</symbol> if memory could not be allocated. It is "
"exported because some applications find it useful to generate result objects "
"(particularly objects with error status) themselves. If <parameter>conn</"
"parameter> is not null and <parameter>status</parameter> indicates an error, "
"the current error message of the specified connection is copied into the "
"<structname>PGresult</structname>. Also, if <parameter>conn</parameter> is "
"not null, any event procedures registered in the connection are copied into "
"the <structname>PGresult</structname>. (They do not get "
"<literal>PGEVT_RESULTCREATE</literal> calls, but see "
"<function>PQfireResultCreateEvents</function>.) Note that <function>PQclear</"
"function> should eventually be called on the object, just as with a "
"<structname>PGresult</structname> returned by <application>libpq</"
"application> itself."
msgstr ""
"Это внутренняя функция <application>libpq</application>, выделяющая память и "
"инициализирующая пустой объект <structname>PGresult</structname>. Эта "
"функция возвращает <symbol>NULL</symbol>, если не может выделить память. Она "
"сделана экспортируемой, так как некоторые приложения находят полезным "
"создавать объекты результатов (в частности, объекты с состоянием ошибки) "
"самостоятельно. Если в <parameter>conn</parameter> передаётся не null и "
"<parameter>status</parameter> указывает на ошибку, в <structname>PGresult</"
"structname> копируется текущее сообщение об ошибке для заданного соединения. "
"Также, если в <parameter>conn</parameter> передаётся не null, в "
"<structname>PGresult</structname> копируются все процедуры событий, "
"зарегистрированные для этого соединения. (При этом вызовы "
"<literal>PGEVT_RESULTCREATE</literal> не выполняются; см. описание "
"<function>PQfireResultCreateEvents</function>.) Заметьте, что в конце для "
"этого объекта следует вызвать <function>PQclear</function>, как и для "
"объекта <structname>PGresult</structname>, возвращённого самой библиотекой "
"<application>libpq</application>."

#: libpq.xml:5878(function)
msgid "PQfireResultCreateEvents"
msgstr "PQfireResultCreateEvents"

#: libpq.xml:5879(indexterm)
msgid "<primary>PQfireResultCreateEvents</primary>"
msgstr "<primary>PQfireResultCreateEvents</primary>"

#: libpq.xml:5884(para)
msgid ""
"Fires a <literal>PGEVT_RESULTCREATE</literal> event (see <xref linkend="
"\"libpq-events\"/>) for each event procedure registered in the "
"<structname>PGresult</structname> object. Returns non-zero for success, zero "
"if any event procedure fails. <synopsis>\n"
"int PQfireResultCreateEvents(PGconn *conn, PGresult *res);\n"
"</synopsis>"
msgstr ""
"Вызывает событие <literal>PGEVT_RESULTCREATE</literal> (см. <xref remap="
"\"4\" linkend=\"libpq-events\"/>) для каждой процедуры событий, "
"зарегистрированной в объекте <structname>PGresult</structname>. Возвращает "
"ненулевое значение в случае успеха или ноль в случае ошибки в одной из "
"процедур. <synopsis>\n"
"int PQfireResultCreateEvents(PGconn *conn, PGresult *res);\n"
"</synopsis>"

#: libpq.xml:5895(para)
msgid ""
"The <literal>conn</literal> argument is passed through to event procedures "
"but not used directly. It can be <symbol>NULL</symbol> if the event "
"procedures won't use it."
msgstr ""
"Аргумент <literal>conn</literal> передаётся процедурам событий, но "
"непосредственно не используется. Он может быть равен <symbol>NULL</symbol>, "
"если он не нужен процедурам событий."

#: libpq.xml:5901(para)
msgid ""
"Event procedures that have already received a <literal>PGEVT_RESULTCREATE</"
"literal> or <literal>PGEVT_RESULTCOPY</literal> event for this object are "
"not fired again."
msgstr ""
"Процедуры событий, уже получившие событие <literal>PGEVT_RESULTCREATE</"
"literal> или <literal>PGEVT_RESULTCOPY</literal> для этого объекта, больше "
"не вызываются."

#: libpq.xml:5907(para)
msgid ""
"The main reason that this function is separate from "
"<function>PQmakeEmptyPGresult</function> is that it is often appropriate to "
"create a <structname>PGresult</structname> and fill it with data before "
"invoking the event procedures."
msgstr ""
"Основная причина отделения этой функции от <function>PQmakeEmptyPGresult</"
"function> в том, что часто требуется создать объект <structname>PGresult</"
"structname> и наполнить его данными, прежде чем вызывать процедуры событий."

#: libpq.xml:5918(function)
msgid "PQcopyResult"
msgstr "PQcopyResult"

#: libpq.xml:5919(indexterm)
msgid "<primary>PQcopyResult</primary>"
msgstr "<primary>PQcopyResult</primary>"

#: libpq.xml:5925(para)
msgid ""
"Makes a copy of a <structname>PGresult</structname> object. The copy is not "
"linked to the source result in any way and <function>PQclear</function> must "
"be called when the copy is no longer needed. If the function fails, "
"<symbol>NULL</symbol> is returned. <synopsis>\n"
"PGresult *PQcopyResult(const PGresult *src, int flags);\n"
"</synopsis>"
msgstr ""
"Создаёт копию объекта <structname>PGresult</structname>. Эта копия никак не "
"связана с исходным результатом и поэтому, когда она становится не нужна, "
"необходимо вызвать <function>PQclear</function>. Если функция завершается "
"ошибкой, она возвращает <symbol>NULL</symbol>. <synopsis>\n"
"PGresult *PQcopyResult(const PGresult *src, int flags);\n"
"</synopsis>"

#: libpq.xml:5936(para)
msgid ""
"This is not intended to make an exact copy. The returned result is always "
"put into <literal>PGRES_TUPLES_OK</literal> status, and does not copy any "
"error message in the source. (It does copy the command status string, "
"however.) The <parameter>flags</parameter> argument determines what else is "
"copied. It is a bitwise OR of several flags. <literal>PG_COPYRES_ATTRS</"
"literal> specifies copying the source result's attributes (column "
"definitions). <literal>PG_COPYRES_TUPLES</literal> specifies copying the "
"source result's tuples. (This implies copying the attributes, too.) "
"<literal>PG_COPYRES_NOTICEHOOKS</literal> specifies copying the source "
"result's notify hooks. <literal>PG_COPYRES_EVENTS</literal> specifies "
"copying the source result's events. (But any instance data associated with "
"the source is not copied.)"
msgstr ""
"Создаваемая копия не будет точной. В возвращаемый результат всегда "
"помещается состояние <literal>PGRES_TUPLES_OK</literal> и в него не "
"копируются никакие сообщения об ошибках из исходного объекта. (Однако в него "
"копируется строка состояния команды.) Что ещё в него будет копироваться, "
"определяет аргумент <parameter>flags</parameter>, в котором складываются "
"несколько флагов. Флаг <literal>PG_COPYRES_ATTRS</literal> включает "
"копирование атрибутов исходного объекта (определений столбцов), а флаг "
"<literal>PG_COPYRES_TUPLES</literal> включает копирование кортежей из "
"исходного объекта (при этом также копируются и атрибуты.) Флаг "
"<literal>PG_COPYRES_NOTICEHOOKS</literal> включает копирование обработчиков "
"замечаний, а флаг <literal>PG_COPYRES_EVENTS</literal> — событий из "
"исходного объекта результата. (Но любые данные, связанные с экземпляром "
"исходного объекта, не копируются.)"

#: libpq.xml:5957(function)
msgid "PQsetResultAttrs"
msgstr "PQsetResultAttrs"

#: libpq.xml:5958(indexterm)
msgid "<primary>PQsetResultAttrs</primary>"
msgstr "<primary>PQsetResultAttrs</primary>"

#: libpq.xml:5964(para)
msgid ""
"Sets the attributes of a <structname>PGresult</structname> object. "
"<synopsis>\n"
"int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc "
"*attDescs);\n"
"</synopsis>"
msgstr ""
"Устанавливает атрибуты объекта <structname>PGresult</structname>. "
"<synopsis>\n"
"int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc "
"*attDescs);\n"
"</synopsis>"

#: libpq.xml:5971(para)
msgid ""
"The provided <parameter>attDescs</parameter> are copied into the result. If "
"the <parameter>attDescs</parameter> pointer is <symbol>NULL</symbol> or "
"<parameter>numAttributes</parameter> is less than one, the request is "
"ignored and the function succeeds. If <parameter>res</parameter> already "
"contains attributes, the function will fail. If the function fails, the "
"return value is zero. If the function succeeds, the return value is non-zero."
msgstr ""
"Предоставленная структура <parameter>attDescs</parameter> копируется в "
"результат. Если указатель <parameter>attDescs</parameter> равен "
"<symbol>NULL</symbol> или <parameter>numAttributes</parameter> меньше "
"одного, запрос игнорируется и функция выполняется без ошибки. Если "
"<parameter>res</parameter> уже содержит атрибуты, функция завершается "
"ошибкой. В случае ошибки функция возвращает ноль, а в обратном случае — "
"ненулевое значение."

#: libpq.xml:5985(function)
msgid "PQsetvalue"
msgstr "PQsetvalue"

#: libpq.xml:5986(indexterm)
msgid "<primary>PQsetvalue</primary>"
msgstr "<primary>PQsetvalue</primary>"

#: libpq.xml:5992(para)
msgid ""
"Sets a tuple field value of a <structname>PGresult</structname> object. "
"<synopsis>\n"
"int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int "
"len);\n"
"</synopsis>"
msgstr ""
"Устанавливает значение поля кортежа в объекте <structname>PGresult</"
"structname>. <synopsis>\n"
"int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int "
"len);\n"
"</synopsis>"

#: libpq.xml:5999(para)
msgid ""
"The function will automatically grow the result's internal tuples array as "
"needed. However, the <parameter>tup_num</parameter> argument must be less "
"than or equal to <function>PQntuples</function>, meaning this function can "
"only grow the tuples array one tuple at a time. But any field of any "
"existing tuple can be modified in any order. If a value at "
"<parameter>field_num</parameter> already exists, it will be overwritten. If "
"<parameter>len</parameter> is -1 or <parameter>value</parameter> is "
"<symbol>NULL</symbol>, the field value will be set to an SQL null value. The "
"<parameter>value</parameter> is copied into the result's private storage, "
"thus is no longer needed after the function returns. If the function fails, "
"the return value is zero. If the function succeeds, the return value is non-"
"zero."
msgstr ""
"Эта функция автоматически увеличивает внутренний массив кортежей при "
"необходимости. Однако значение <parameter>tup_num</parameter> должно быть "
"меньше или равно <function>PQntuples</function>, что означает, что эта "
"функция может увеличивать массив кортежей только на один кортеж. Но в "
"существующем кортеже любые поля могут изменяться в любом порядке. Если "
"значение в поле с номером <parameter>field_num</parameter> уже существует, "
"оно будет перезаписано. Если <parameter>len</parameter> равно -1 или "
"<parameter>value</parameter> равно <symbol>NULL</symbol>, в поле будет "
"записано значение SQL NULL. Устанавливаемое значение (<parameter>value</"
"parameter>) копируется в закрытую область объекта результата, так что от "
"него можно избавиться после завершения функции. Если функция завершается "
"ошибкой, она возвращает ноль, а в обратном случае — ненулевое значение."

#: libpq.xml:6019(function)
msgid "PQresultAlloc"
msgstr "PQresultAlloc"

#: libpq.xml:6020(indexterm)
msgid "<primary>PQresultAlloc</primary>"
msgstr "<primary>PQresultAlloc</primary>"

#: libpq.xml:6026(para)
msgid ""
"Allocate subsidiary storage for a <structname>PGresult</structname> object. "
"<synopsis>\n"
"void *PQresultAlloc(PGresult *res, size_t nBytes);\n"
"</synopsis>"
msgstr ""
"Выделяет подчинённую область памяти для объекта <structname>PGresult</"
"structname>. <synopsis>\n"
"void *PQresultAlloc(PGresult *res, size_t nBytes);\n"
"</synopsis>"

#: libpq.xml:6033(para)
msgid ""
"Any memory allocated with this function will be freed when <parameter>res</"
"parameter> is cleared. If the function fails, the return value is "
"<symbol>NULL</symbol>. The result is guaranteed to be adequately aligned for "
"any type of data, just as for <function>malloc</function>."
msgstr ""
"Любая память, выделенная этой функцией, будет освобождена при очистке "
"объекта <parameter>res</parameter>. В случае ошибки эта функция возвращает "
"<symbol>NULL</symbol>. Результат гарантированно выравнивается должным "
"образом для любого типа данных, как и при <function>malloc</function>."

#: libpq.xml:6045(function)
msgid "PQlibVersion"
msgstr "PQlibVersion"

#: libpq.xml:6046(indexterm)
msgid "<primary>PQlibVersion</primary> <seealso>PQserverVersion</seealso>"
msgstr "<primary>PQlibVersion</primary> <seealso>PQserverVersion</seealso>"

#: libpq.xml:6053(para)
msgid ""
"Return the version of <productname>libpq</productname> that is being used. "
"<synopsis>\n"
"int PQlibVersion(void);\n"
"</synopsis>"
msgstr ""
"Возвращает версию используемой библиотеки <productname>libpq</productname>. "
"<synopsis>\n"
"int PQlibVersion(void);\n"
"</synopsis>"

#: libpq.xml:6060(para)
msgid ""
"The result of this function can be used to determine, at run time, if "
"specific functionality is available in the currently loaded version of "
"libpq. The function can be used, for example, to determine which connection "
"options are available for <function>PQconnectdb</function> or if the "
"<literal>hex</literal> <type>bytea</type> output added in PostgreSQL 9.0 is "
"supported."
msgstr ""
"По результату этой функции можно во время выполнения определить, "
"предоставляется ли определённая функциональность загруженной в данный момент "
"версией libpq. Эта функция может использоваться, например, чтобы понять, "
"какие параметры соединения может принять <function>PQconnectdb</function> "
"или поддерживается ли вывод <type>bytea</type> в формате <literal>hex</"
"literal>, появившийся в PostgreSQL 9.0."

#: libpq.xml:6069(para)
msgid ""
"The number is formed by converting the major, minor, and revision numbers "
"into two-decimal-digit numbers and appending them together. For example, "
"version 9.1 will be returned as 90100, and version 9.1.2 will be returned as "
"90102 (leading zeroes are not shown)."
msgstr ""
"Это число формируется в результате преобразования номеров старшей, "
"дополнительной и корректирующей версии в числа из двух цифр и соединения их "
"вместе. Например, для версии 9.1 будет возвращено 90100, а для версии 9.1.2 "
"— 90102 (ведущие нули не показываются)."

#: libpq.xml:6077(para)
msgid ""
"This function appeared in <productname>PostgreSQL</productname> version 9.1, "
"so it cannot be used to detect required functionality in earlier versions, "
"since linking to it will create a link dependency on version 9.1."
msgstr ""
"Эта функция появилась в <productname>PostgreSQL</productname> версии 9.1, "
"поэтому с её помощью нельзя проверить функциональность предыдущих версий, "
"так как при компоновке с ней будет создана зависимость от версии 9.1."

#: libpq.xml:6092(title)
msgid "Notice Processing"
msgstr "Обработка замечаний"

#: libpq.xml:6094(indexterm)
msgid "<primary>notice processing</primary> <secondary>in libpq</secondary>"
msgstr "<primary>обработка замечаний</primary> <secondary>в libpq</secondary>"

#: libpq.xml:6099(para)
msgid ""
"Notice and warning messages generated by the server are not returned by the "
"query execution functions, since they do not imply failure of the query. "
"Instead they are passed to a notice handling function, and execution "
"continues normally after the handler returns. The default notice handling "
"function prints the message on <filename>stderr</filename>, but the "
"application can override this behavior by supplying its own handling "
"function."
msgstr ""
"Сообщения с замечаниями и предупреждениями, выдаваемые сервером, не "
"возвращаются функциями, выполняющими запросы, так как они не свидетельствуют "
"об ошибке в запросе. Вместо этого они передаются функции обработки замечаний "
"и после завершения этой функции выполнение продолжается как обычно. "
"Стандартная функция обработки замечаний выводит сообщение в "
"<filename>stderr</filename>, но приложение может переопределить это "
"поведение, предоставив собственный обработчик."

#: libpq.xml:6109(para)
msgid ""
"For historical reasons, there are two levels of notice handling, called the "
"notice receiver and notice processor. The default behavior is for the notice "
"receiver to format the notice and pass a string to the notice processor for "
"printing. However, an application that chooses to provide its own notice "
"receiver will typically ignore the notice processor layer and just do all "
"the work in the notice receiver."
msgstr ""
"По историческим причинам обработка замечаний выполняется на двух уровнях, "
"приёмником замечаний и обработчиком замечаний. По умолчанию приёмник "
"замечаний форматирует замечание и передаёт сформированную строку обработчику "
"замечаний для вывода. Однако приложения, которые реализуют свой приёмник "
"замечаний, обычно просто игнорируют слой обработчика и выполняют все "
"действия в коде приёмника."

#: libpq.xml:6120(indexterm)
msgid "<primary>notice receiver</primary>"
msgstr "<primary>приёмник замечаний</primary>"

#: libpq.xml:6121(indexterm)
msgid "<primary>PQsetNoticeReceiver</primary>"
msgstr "<primary>PQsetNoticeReceiver</primary>"

#: libpq.xml:6124(indexterm)
msgid "<primary>notice processor</primary>"
msgstr "<primary>обработчик замечаний</primary>"

#: libpq.xml:6125(indexterm)
msgid "<primary>PQsetNoticeProcessor</primary>"
msgstr "<primary>PQsetNoticeProcessor</primary>"

#: libpq.xml:6118(para)
msgid ""
"The function <function>PQsetNoticeReceiver</function> <placeholder-1/> "
"<placeholder-2/> sets or examines the current notice receiver for a "
"connection object. Similarly, <function>PQsetNoticeProcessor</function> "
"<placeholder-3/> <placeholder-4/> sets or examines the current notice "
"processor. <synopsis>\n"
"typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);\n"
"\n"
"PQnoticeReceiver\n"
"PQsetNoticeReceiver(PGconn *conn,\n"
"                    PQnoticeReceiver proc,\n"
"                    void *arg);\n"
"\n"
"typedef void (*PQnoticeProcessor) (void *arg, const char *message);\n"
"\n"
"PQnoticeProcessor\n"
"PQsetNoticeProcessor(PGconn *conn,\n"
"                     PQnoticeProcessor proc,\n"
"                     void *arg);\n"
"</synopsis> Each of these functions returns the previous notice receiver or "
"processor function pointer, and sets the new value. If you supply a null "
"function pointer, no action is taken, but the current pointer is returned."
msgstr ""
"Функция <function>PQsetNoticeReceiver</function> <placeholder-1/> "
"<placeholder-2/> устанавливает или возвращает текущий приёмник замечаний для "
"объекта соединения. Подобным образом, <function>PQsetNoticeProcessor</"
"function> <placeholder-3/> <placeholder-4/> устанавливает или возвращает "
"текущий обработчик замечаний. <synopsis>\n"
"typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);\n"
"\n"
"PQnoticeReceiver\n"
"PQsetNoticeReceiver(PGconn *conn,\n"
"                    PQnoticeReceiver proc,\n"
"                    void *arg);\n"
"\n"
"typedef void (*PQnoticeProcessor) (void *arg, const char *message);\n"
"\n"
"PQnoticeProcessor\n"
"PQsetNoticeProcessor(PGconn *conn,\n"
"                     PQnoticeProcessor proc,\n"
"                     void *arg);\n"
"</synopsis> Каждая из этих функций возвращает указатель на ранее "
"установленный приёмник или обработчик замечаний и устанавливает новый "
"указатель. Если ей передаётся нулевой указатель, она ничего не делает, "
"только возвращает текущий указатель."

#: libpq.xml:6150(para)
msgid ""
"When a notice or warning message is received from the server, or generated "
"internally by <application>libpq</application>, the notice receiver function "
"is called. It is passed the message in the form of a "
"<symbol>PGRES_NONFATAL_ERROR</symbol> <structname>PGresult</structname>. "
"(This allows the receiver to extract individual fields using "
"<function>PQresultErrorField</function>, or obtain a complete preformatted "
"message using <function>PQresultErrorMessage</function> or "
"<function>PQresultVerboseErrorMessage</function>.) The same void pointer "
"passed to <function>PQsetNoticeReceiver</function> is also passed. (This "
"pointer can be used to access application-specific state if needed.)"
msgstr ""
"Когда сообщение с замечанием или предупреждением поступает от сервера, либо "
"выдаётся самой библиотекой <application>libpq</application>, вызывается "
"функция приёмника замечания. Сообщение передаётся ей в виде состояния "
"<symbol>PGRES_NONFATAL_ERROR</symbol> объекта <structname>PGresult</"
"structname>. (Это позволяет приёмнику извлечь из него отдельные поля, "
"используя <function>PQresultErrorField</function>, либо получить полное "
"готовое сообщение, вызвав <function>PQresultErrorMessage</function> или "
"<function>PQresultVerboseErrorMessage</function>.) Ей также передаётся тот "
"же неопределённый указатель, что был передан функции "
"<function>PQsetNoticeReceiver</function>. (Этот указатель может пригодиться "
"для обращения к внутреннему состоянию приложения при необходимости.)"

#: libpq.xml:6164(para)
msgid ""
"The default notice receiver simply extracts the message (using "
"<function>PQresultErrorMessage</function>) and passes it to the notice "
"processor."
msgstr ""
"Стандартный приёмник замечаний просто извлекает сообщение (вызывая "
"<function>PQresultErrorMessage</function>) и передаёт его обработчику "
"замечаний."

#: libpq.xml:6170(para)
msgid ""
"The notice processor is responsible for handling a notice or warning message "
"given in text form. It is passed the string text of the message (including a "
"trailing newline), plus a void pointer that is the same one passed to "
"<function>PQsetNoticeProcessor</function>. (This pointer can be used to "
"access application-specific state if needed.)"
msgstr ""
"Обработчик замечаний отвечает за обработку сообщения с замечанием или "
"предупреждением в текстовом виде. Ему передаётся строка с текстом сообщения "
"(включающая завершающий символ новой строки) и неопределённый указатель, "
"который был передан функции <function>PQsetNoticeProcessor</function>. (Этот "
"указатель может пригодиться для обращения к внутреннему состоянию приложения "
"при необходимости.)"

#: libpq.xml:6180(programlisting)
#, no-wrap
msgid ""
"static void\n"
"defaultNoticeProcessor(void *arg, const char *message)\n"
"{\n"
"    fprintf(stderr, \"%s\", message);\n"
"}"
msgstr ""
"static void\n"
"defaultNoticeProcessor(void *arg, const char *message)\n"
"{\n"
"    fprintf(stderr, \"%s\", message);\n"
"}"

#: libpq.xml:6178(para)
msgid "The default notice processor is simply: <placeholder-1/>"
msgstr "Стандартный обработчик замечаний прост: <placeholder-1/>"

#: libpq.xml:6189(para)
msgid ""
"Once you have set a notice receiver or processor, you should expect that "
"that function could be called as long as either the <structname>PGconn</"
"structname> object or <structname>PGresult</structname> objects made from it "
"exist. At creation of a <structname>PGresult</structname>, the "
"<structname>PGconn</structname>'s current notice handling pointers are "
"copied into the <structname>PGresult</structname> for possible use by "
"functions like <function>PQgetvalue</function>."
msgstr ""
"Установив приёмник или обработчик замечаний, вы можете ожидать, что эта "
"функция будет вызываться, пока будут существовать объект <structname>PGconn</"
"structname> или объекты <structname>PGresult</structname>, созданные с ней. "
"Когда создаётся <structname>PGresult</structname>, указатели текущих "
"обработчиков замечаний, установленные в <structname>PGconn</structname>, "
"копируются в <structname>PGresult</structname> для возможного использования "
"функциями вроде <function>PQgetvalue</function>."

#: libpq.xml:6202(title)
msgid "Event System"
msgstr "Система событий"

#: libpq.xml:6204(para)
msgid ""
"<application>libpq</application>'s event system is designed to notify "
"registered event handlers about interesting <application>libpq</application> "
"events, such as the creation or destruction of <structname>PGconn</"
"structname> and <structname>PGresult</structname> objects. A principal use "
"case is that this allows applications to associate their own data with a "
"<structname>PGconn</structname> or <structname>PGresult</structname> and "
"ensure that that data is freed at an appropriate time."
msgstr ""
"Система событий <application>libpq</application> разработана для уведомления "
"функций-обработчиков об интересных событиях <application>libpq</"
"application>, например, о создании и уничтожении объектов "
"<structname>PGconn</structname> и <structname>PGresult</structname>. "
"Основное их предназначение в том, чтобы позволить приложениям связать "
"собственные данные с объектами <structname>PGconn</structname> и "
"<structname>PGresult</structname> и обеспечить их освобождение в нужное "
"время."

#: libpq.xml:6215(para)
msgid ""
"Each registered event handler is associated with two pieces of data, known "
"to <application>libpq</application> only as opaque <literal>void *</literal> "
"pointers. There is a <firstterm>passthrough</firstterm> pointer that is "
"provided by the application when the event handler is registered with a "
"<structname>PGconn</structname>. The passthrough pointer never changes for "
"the life of the <structname>PGconn</structname> and all "
"<structname>PGresult</structname>s generated from it; so if used, it must "
"point to long-lived data. In addition there is an <firstterm>instance data</"
"firstterm> pointer, which starts out <symbol>NULL</symbol> in every "
"<structname>PGconn</structname> and <structname>PGresult</structname>. This "
"pointer can be manipulated using the <function>PQinstanceData</function>, "
"<function>PQsetInstanceData</function>, <function>PQresultInstanceData</"
"function> and <function>PQsetResultInstanceData</function> functions. Note "
"that unlike the passthrough pointer, instance data of a <structname>PGconn</"
"structname> is not automatically inherited by <structname>PGresult</"
"structname>s created from it. <application>libpq</application> does not know "
"what passthrough and instance data pointers point to (if anything) and will "
"never attempt to free them &mdash; that is the responsibility of the event "
"handler."
msgstr ""
"Каждый зарегистрированный обработчик событий связывается с двумя элементами "
"данных, которые известны <application>libpq</application> только как скрытые "
"указатели <literal>void *</literal>. Первый <firstterm>сквозной</firstterm> "
"указатель передаётся приложением, когда обработчик событий регистрируется в "
"<structname>PGconn</structname>. Этот указатель никогда не меняется на "
"протяжении жизни <structname>PGconn</structname> и все объекты "
"<structname>PGresult</structname> создаются с ним; поэтому, если он "
"используется, он должен указывать на долгоживущие данные. В дополнение к "
"нему имеется указатель <firstterm>данных экземпляра</firstterm>, который "
"изначально равен <symbol>NULL</symbol> во всех объектах <structname>PGconn</"
"structname> и <structname>PGresult</structname>. Этим указателем можно "
"управлять с помощью функций <function>PQinstanceData</function>, "
"<function>PQsetInstanceData</function>, <function>PQresultInstanceData</"
"function> и <function>PQsetResultInstanceData</function>. Заметьте, что в "
"отличие от сквозного указателя, данные экземпляра <structname>PGconn</"
"structname> автоматически не наследуются объектами <structname>PGresult</"
"structname>, создаваемыми из него. Библиотека <application>libpq</"
"application> не знает, на что указывают сквозной указатель и указатель "
"данных экземпляра (если они ненулевые) и никогда не будет пытаться "
"освобождать их &mdash; за это отвечает обработчик событий."

#: libpq.xml:6238(title)
msgid "Event Types"
msgstr "Типы событий"

#: libpq.xml:6240(para)
msgid ""
"The enum <literal>PGEventId</literal> names the types of events handled by "
"the event system. All its values have names beginning with <literal>PGEVT</"
"literal>. For each event type, there is a corresponding event info structure "
"that carries the parameters passed to the event handlers. The event types "
"are:"
msgstr ""
"Перечисление <literal>PGEventId</literal> описывает типы событий, "
"обрабатываемых системой событий. Имена всех их значений начинаются с "
"<literal>PGEVT</literal>. Для каждого типа событий имеется соответствующая "
"структура информации о событии, содержащая параметры, передаваемые "
"обработчикам событий. Определены следующие типы событий:"

#: libpq.xml:6250(literal)
msgid "PGEVT_REGISTER"
msgstr "PGEVT_REGISTER"

#: libpq.xml:6252(para)
msgid ""
"The register event occurs when <function>PQregisterEventProc</function> is "
"called. It is the ideal time to initialize any <literal>instanceData</"
"literal> an event procedure may need. Only one register event will be fired "
"per event handler per connection. If the event procedure fails, the "
"registration is aborted. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"} PGEventRegister;\n"
"</synopsis> When a <literal>PGEVT_REGISTER</literal> event is received, the "
"<parameter>evtInfo</parameter> pointer should be cast to a "
"<structname>PGEventRegister *</structname>. This structure contains a "
"<structname>PGconn</structname> that should be in the "
"<literal>CONNECTION_OK</literal> status; guaranteed if one calls "
"<function>PQregisterEventProc</function> right after obtaining a good "
"<structname>PGconn</structname>. When returning a failure code, all cleanup "
"must be performed as no <literal>PGEVT_CONNDESTROY</literal> event will be "
"sent."
msgstr ""
"Событие регистрации происходит, когда вызывается "
"<function>PQregisterEventProc</function>. Это идеальное время для "
"инициализации данных экземпляра (<literal>instanceData</literal>), которые "
"могут понадобиться процедуре событий. Для каждого обработчика событий в "
"рамках соединения будет выдаваться только одно событие регистрации. Если "
"обработка события завершается ошибкой, регистрация прерывается. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"} PGEventRegister;\n"
"</synopsis> При поступлении события <literal>PGEVT_REGISTER</literal> "
"указатель <parameter>evtInfo</parameter> следует привести к "
"<structname>PGEventRegister *</structname>. Эта структура содержит объект "
"<structname>PGconn</structname>, который должен быть в состоянии "
"<literal>CONNECTION_OK</literal>; это гарантируется, если "
"<function>PQregisterEventProc</function> вызывается сразу после получения "
"рабочего объекта <structname>PGconn</structname>. В случае выдачи кода "
"ошибки всю очистку необходимо провести самостоятельно, так как событие "
"<literal>PGEVT_CONNDESTROY</literal> не поступит."

#: libpq.xml:6280(literal)
msgid "PGEVT_CONNRESET"
msgstr "PGEVT_CONNRESET"

#: libpq.xml:6282(para)
msgid ""
"The connection reset event is fired on completion of <function>PQreset</"
"function> or <function>PQresetPoll</function>. In both cases, the event is "
"only fired if the reset was successful. If the event procedure fails, the "
"entire connection reset will fail; the <structname>PGconn</structname> is "
"put into <literal>CONNECTION_BAD</literal> status and <function>PQresetPoll</"
"function> will return <literal>PGRES_POLLING_FAILED</literal>. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"} PGEventConnReset;\n"
"</synopsis> When a <literal>PGEVT_CONNRESET</literal> event is received, the "
"<parameter>evtInfo</parameter> pointer should be cast to a "
"<structname>PGEventConnReset *</structname>. Although the contained "
"<structname>PGconn</structname> was just reset, all event data remains "
"unchanged. This event should be used to reset/reload/requery any associated "
"<literal>instanceData</literal>. Note that even if the event procedure fails "
"to process <literal>PGEVT_CONNRESET</literal>, it will still receive a "
"<literal>PGEVT_CONNDESTROY</literal> event when the connection is closed."
msgstr ""
"Событие сброса соединения происходит при завершении <function>PQreset</"
"function> или <function>PQresetPoll</function>. В обоих случаях это событие "
"вызывается, только если сброс был успешным. Если обработка события "
"завершается ошибкой, происходит сбой всей операции сброса соединения; объект "
"<structname>PGconn</structname> переходит в состояние "
"<literal>CONNECTION_BAD</literal> и <function>PQresetPoll</function> "
"возвращает <literal>PGRES_POLLING_FAILED</literal>. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"} PGEventConnReset;\n"
"</synopsis> При поступлении события <literal>PGEVT_CONNRESET</literal> "
"указатель <parameter>evtInfo</parameter> следует привести к "
"<structname>PGEventConnReset *</structname>. Хотя переданный объект "
"<structname>PGconn</structname> был только что сброшен, все данные события "
"остаются неизменными. При поступлении этого события должны быть сброшены/"
"перезагружены/вновь запрошены все сопутствующие данные "
"<literal>instanceData</literal>. Заметьте, что даже если обработчик события "
"выдаст ошибку при обработке <literal>PGEVT_CONNRESET</literal>, событие "
"<literal>PGEVT_CONNDESTROY</literal> всё равно поступит при закрытии "
"соединения."

#: libpq.xml:6313(literal)
msgid "PGEVT_CONNDESTROY"
msgstr "PGEVT_CONNDESTROY"

#: libpq.xml:6315(para)
msgid ""
"The connection destroy event is fired in response to <function>PQfinish</"
"function>. It is the event procedure's responsibility to properly clean up "
"its event data as libpq has no ability to manage this memory. Failure to "
"clean up will lead to memory leaks. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"} PGEventConnDestroy;\n"
"</synopsis> When a <literal>PGEVT_CONNDESTROY</literal> event is received, "
"the <parameter>evtInfo</parameter> pointer should be cast to a "
"<structname>PGEventConnDestroy *</structname>. This event is fired prior to "
"<function>PQfinish</function> performing any other cleanup. The return value "
"of the event procedure is ignored since there is no way of indicating a "
"failure from <function>PQfinish</function>. Also, an event procedure failure "
"should not abort the process of cleaning up unwanted memory."
msgstr ""
"Событие уничтожения соединения вызывается в ответ на вызов "
"<function>PQfinish</function>. Обработчик этого события отвечает за "
"корректную очистку своих данных событий, так как libpq не может управлять "
"его памятью. Невыполнение очистки должным образом приведёт к утечкам памяти. "
"<synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"} PGEventConnDestroy;\n"
"</synopsis> При поступлении события <literal>PGEVT_CONNDESTROY</literal> "
"указатель <parameter>evtInfo</parameter> следует привести к "
"<structname>PGEventConnDestroy *</structname>. Это событие происходит перед "
"тем, как <function>PQfinish</function> производит всю остальную очистку. "
"Значение, возвращаемое обработчиком событий, игнорируется, так как из "
"<function>PQfinish</function> никак нельзя сообщить об ошибке. Кроме того, "
"ошибка в обработчике событий не должна прерывать процесс очистки ставшей "
"ненужной памяти."

#: libpq.xml:6342(literal)
msgid "PGEVT_RESULTCREATE"
msgstr "PGEVT_RESULTCREATE"

#: libpq.xml:6344(para)
msgid ""
"The result creation event is fired in response to any query execution "
"function that generates a result, including <function>PQgetResult</"
"function>. This event will only be fired after the result has been created "
"successfully. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"    PGresult *result;\n"
"} PGEventResultCreate;\n"
"</synopsis> When a <literal>PGEVT_RESULTCREATE</literal> event is received, "
"the <parameter>evtInfo</parameter> pointer should be cast to a "
"<structname>PGEventResultCreate *</structname>. The <parameter>conn</"
"parameter> is the connection used to generate the result. This is the ideal "
"place to initialize any <literal>instanceData</literal> that needs to be "
"associated with the result. If the event procedure fails, the result will be "
"cleared and the failure will be propagated. The event procedure must not try "
"to <function>PQclear</function> the result object for itself. When returning "
"a failure code, all cleanup must be performed as no "
"<literal>PGEVT_RESULTDESTROY</literal> event will be sent."
msgstr ""
"Событие создания объекта результата происходит при завершении любой функции, "
"выполняющей запрос и получающей результат, включая <function>PQgetResult</"
"function>. Это событие происходит только после того, как результат был "
"успешно получен. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGconn *conn;\n"
"    PGresult *result;\n"
"} PGEventResultCreate;\n"
"</synopsis> При поступлении события <literal>PGEVT_RESULTCREATE</literal> "
"указатель <parameter>evtInfo</parameter> следует привести к "
"<structname>PGEventResultCreate *</structname>. В <parameter>conn</"
"parameter> передаётся соединение, для которого сформирован результат. Это "
"идеальное место для инициализации любых данных <literal>instanceData</"
"literal>, которые нужно связать с результатом. В случае сбоя обработчика "
"объект результата очищается и ошибка распространяется дальше. Обработчик "
"события не должен пытаться выполнять <function>PQclear</function> для "
"объекта результата самостоятельно. Возвращая ошибку, необходимо выполнить "
"очистку данных, так как событие <literal>PGEVT_RESULTDESTROY</literal> для "
"этого объекта не поступит."

#: libpq.xml:6374(literal)
msgid "PGEVT_RESULTCOPY"
msgstr "PGEVT_RESULTCOPY"

#: libpq.xml:6376(para)
msgid ""
"The result copy event is fired in response to <function>PQcopyResult</"
"function>. This event will only be fired after the copy is complete. Only "
"event procedures that have successfully handled the "
"<literal>PGEVT_RESULTCREATE</literal> or <literal>PGEVT_RESULTCOPY</literal> "
"event for the source result will receive <literal>PGEVT_RESULTCOPY</literal> "
"events. <synopsis>\n"
"typedef struct\n"
"{\n"
"    const PGresult *src;\n"
"    PGresult *dest;\n"
"} PGEventResultCopy;\n"
"</synopsis> When a <literal>PGEVT_RESULTCOPY</literal> event is received, "
"the <parameter>evtInfo</parameter> pointer should be cast to a "
"<structname>PGEventResultCopy *</structname>. The <parameter>src</parameter> "
"result is what was copied while the <parameter>dest</parameter> result is "
"the copy destination. This event can be used to provide a deep copy of "
"<literal>instanceData</literal>, since <literal>PQcopyResult</literal> "
"cannot do that. If the event procedure fails, the entire copy operation will "
"fail and the <parameter>dest</parameter> result will be cleared. When "
"returning a failure code, all cleanup must be performed as no "
"<literal>PGEVT_RESULTDESTROY</literal> event will be sent for the "
"destination result."
msgstr ""
"Событие копирования объекта результата происходит при выполнении функции "
"<function>PQcopyResult</function>. Это событие происходит только после того, "
"как копирование будет завершено. Только те обработчики событий, которые "
"успешно обработали событие <literal>PGEVT_RESULTCREATE</literal> или "
"<literal>PGEVT_RESULTCOPY</literal> для исходного объекта, получат событие "
"<literal>PGEVT_RESULTCOPY</literal>. <synopsis>\n"
"typedef struct\n"
"{\n"
"    const PGresult *src;\n"
"    PGresult *dest;\n"
"} PGEventResultCopy;\n"
"</synopsis> При поступлении события <literal>PGEVT_RESULTCOPY</literal> "
"указатель <parameter>evtInfo</parameter> следует привести к "
"<structname>PGEventResultCopy *</structname>. Поле <parameter>src</"
"parameter> указывает на объект результата, который копируется, а "
"<parameter>dest</parameter> — на целевой объект. Это событие может "
"применяться для реализации внутреннего копирования <literal>instanceData</"
"literal>, так как сама функция <literal>PQcopyResult</literal> не может это "
"сделать. В случае сбоя обработчика вся операция копирования прерывается и "
"объект результата в <parameter>dest</parameter> очищается. Возвращая ошибку, "
"необходимо выполнить очистку данных целевого объекта, так как событие "
"<literal>PGEVT_RESULTDESTROY</literal> для него не поступит."

#: libpq.xml:6409(literal)
msgid "PGEVT_RESULTDESTROY"
msgstr "PGEVT_RESULTDESTROY"

#: libpq.xml:6411(para)
msgid ""
"The result destroy event is fired in response to a <function>PQclear</"
"function>. It is the event procedure's responsibility to properly clean up "
"its event data as libpq has no ability to manage this memory. Failure to "
"clean up will lead to memory leaks. <synopsis>\n"
"typedef struct\n"
"{\n"
"    PGresult *result;\n"
"} PGEventResultDestroy;\n"
"</synopsis> When a <literal>PGEVT_RESULTDESTROY</literal> event is received, "
"the <parameter>evtInfo</parameter> pointer should be cast to a "
"<structname>PGEventResultDestroy *</structname>. This event is fired prior "
"to <function>PQclear</function> performing any other cleanup. The return "
"value of the event procedure is ignored since there is no way of indicating "
"a failure from <function>PQclear</function>. Also, an event procedure "
"failure should not abort the process of cleaning up unwanted memory."
msgstr ""
"Событие уничтожения объекта результата происходит при выполнении "
"<function>PQclear</function>. Обработчик этого события отвечает за "
"корректную очистку своих данных событий, так как libpq не может управлять "
"его памятью. Невыполнение очистки должным образом приведёт к утечкам памяти. "
"<synopsis>\n"
"typedef struct\n"
"{\n"
"    PGresult *result;\n"
"} PGEventResultDestroy;\n"
"</synopsis> При поступлении события <literal>PGEVT_RESULTDESTROY</literal> "
"указатель <parameter>evtInfo</parameter> следует привести к "
"<structname>PGEventResultDestroy *</structname>. Это событие происходит "
"перед тем, как <function>PQclear</function> производит всю остальную "
"очистку. Значение, возвращаемое обработчиком событий, игнорируется, так как "
"из <function>PQclear</function> никак нельзя сообщить об ошибке. Кроме того, "
"ошибка в обработчике событий не должна прерывать процесс очистки ставшей "
"ненужной памяти."

#: libpq.xml:6440(title)
msgid "Event Callback Procedure"
msgstr "Процедура обработки событий"

#: libpq.xml:6445(literal)
msgid "PGEventProc"
msgstr "PGEventProc"

#: libpq.xml:6446(indexterm)
msgid "<primary>PGEventProc</primary>"
msgstr "<primary>PGEventProc</primary>"

#: libpq.xml:6452(para)
msgid ""
"<literal>PGEventProc</literal> is a typedef for a pointer to an event "
"procedure, that is, the user callback function that receives events from "
"libpq. The signature of an event procedure must be <synopsis>\n"
"int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)\n"
"</synopsis> The <parameter>evtId</parameter> parameter indicates which "
"<literal>PGEVT</literal> event occurred. The <parameter>evtInfo</parameter> "
"pointer must be cast to the appropriate structure type to obtain further "
"information about the event. The <parameter>passThrough</parameter> "
"parameter is the pointer provided to <function>PQregisterEventProc</"
"function> when the event procedure was registered. The function should "
"return a non-zero value if it succeeds and zero if it fails."
msgstr ""
"<literal>PGEventProc</literal> — это определение типа для указателя на "
"обработчик событий, то есть функцию обратного вызова, получающую события от "
"libpq. Обработчик событий должен иметь такую сигнатуру: <synopsis>\n"
"int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)\n"
"</synopsis> Параметр <parameter>evtId</parameter> говорит, какое событие "
"<literal>PGEVT</literal> произошло. Указатель <parameter>evtInfo</parameter> "
"должен приводиться к типу определённой структуры для получения "
"дополнительной информации о событии. В параметре <parameter>passThrough</"
"parameter> передаётся сквозной указатель, поступивший в "
"<function>PQregisterEventProc</function> при регистрации обработчика "
"события. Эта функция должна вернуть ненулевое значение в случае успеха или "
"ноль в противном случае."

#: libpq.xml:6471(para)
msgid ""
"A particular event procedure can be registered only once in any "
"<structname>PGconn</structname>. This is because the address of the "
"procedure is used as a lookup key to identify the associated instance data."
msgstr ""
"Обработчик определённого события может быть зарегистрирован в любом "
"<structname>PGconn</structname> только раз. Это связано с тем, что адрес "
"обработчика используется как ключ для выбора связанных данных экземпляра."

#: libpq.xml:6478(para)
msgid ""
"On Windows, functions can have two different addresses: one visible from "
"outside a DLL and another visible from inside the DLL. One should be careful "
"that only one of these addresses is used with <application>libpq</"
"application>'s event-procedure functions, else confusion will result. The "
"simplest rule for writing code that will work is to ensure that event "
"procedures are declared <literal>static</literal>. If the procedure's "
"address must be available outside its own source file, expose a separate "
"function to return the address."
msgstr ""
"В Windows функции могут иметь два разных адреса: один, видимый снаружи DLL, "
"и второй, видимый внутри DLL. Учитывая это, надо позаботиться о том, чтобы "
"только один из адресов использовался с функциями обработки событий "
"<application>libpq</application>, иначе возникнет путаница. Самый простой "
"способ написать код, который будет работать — всегда помечать обработчик "
"событий как <literal>static</literal>. Если адрес обработчика нужно получить "
"вне его исходного файла, экспортируйте отдельную функцию, которая будет "
"возвращать этот адрес."

#: libpq.xml:6495(title)
msgid "Event Support Functions"
msgstr "Функции поддержки событий"

#: libpq.xml:6500(function)
msgid "PQregisterEventProc"
msgstr "PQregisterEventProc"

#: libpq.xml:6501(indexterm)
msgid "<primary>PQregisterEventProc</primary>"
msgstr "<primary>PQregisterEventProc</primary>"

#: libpq.xml:6507(para)
msgid ""
"Registers an event callback procedure with libpq. <synopsis>\n"
"int PQregisterEventProc(PGconn *conn, PGEventProc proc,\n"
"                        const char *name, void *passThrough);\n"
"</synopsis>"
msgstr ""
"Регистрирует обработчик событий в libpq. <synopsis>\n"
"int PQregisterEventProc(PGconn *conn, PGEventProc proc,\n"
"                        const char *name, void *passThrough);\n"
"</synopsis>"

#: libpq.xml:6516(para)
msgid ""
"An event procedure must be registered once on each <structname>PGconn</"
"structname> you want to receive events about. There is no limit, other than "
"memory, on the number of event procedures that can be registered with a "
"connection. The function returns a non-zero value if it succeeds and zero if "
"it fails."
msgstr ""
"Обработчик событий должен быть зарегистрирован один раз для каждого "
"соединения <structname>PGconn</structname>, события которого представляют "
"интерес. Число обработчиков событий, которые можно зарегистрировать для "
"соединения, не ограничивается ничем, кроме объёма памяти. Эта функция "
"возвращает ненулевое значение в случае успеха или ноль в противном случае."

#: libpq.xml:6524(para)
msgid ""
"The <parameter>proc</parameter> argument will be called when a libpq event "
"is fired. Its memory address is also used to lookup <literal>instanceData</"
"literal>. The <parameter>name</parameter> argument is used to refer to the "
"event procedure in error messages. This value cannot be <symbol>NULL</"
"symbol> or a zero-length string. The name string is copied into the "
"<structname>PGconn</structname>, so what is passed need not be long-lived. "
"The <parameter>passThrough</parameter> pointer is passed to the "
"<parameter>proc</parameter> whenever an event occurs. This argument can be "
"<symbol>NULL</symbol>."
msgstr ""
"Процедура, переданная в аргументе <parameter>proc</parameter>, будет "
"вызываться, когда произойдёт событие libpq. Её адрес в памяти также "
"применяется для поиска данных <literal>instanceData</literal>. Аргумент "
"<parameter>name</parameter> используется при упоминании обработчика событий "
"в сообщениях об ошибках. Это значение не может быть равно <symbol>NULL</"
"symbol> или указывать на строку нулевой длины. Эта строка имени копируется в "
"<structname>PGconn</structname>, так что переданная строка может быть "
"временной. Сквозной указатель (<parameter>passThrough</parameter>) будет "
"передаваться обработчику <parameter>proc</parameter> при каждом вызове "
"события. Этот аргумент может равняться <symbol>NULL</symbol>."

#: libpq.xml:6540(function)
msgid "PQsetInstanceData"
msgstr "PQsetInstanceData"

#: libpq.xml:6541(indexterm)
msgid "<primary>PQsetInstanceData</primary>"
msgstr "<primary>PQsetInstanceData</primary>"

#: libpq.xml:6546(para)
msgid ""
"Sets the connection <parameter>conn</parameter>'s <literal>instanceData</"
"literal> for procedure <parameter>proc</parameter> to <parameter>data</"
"parameter>. This returns non-zero for success and zero for failure. (Failure "
"is only possible if <parameter>proc</parameter> has not been properly "
"registered in <parameter>conn</parameter>.) <synopsis>\n"
"int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);\n"
"</synopsis>"
msgstr ""
"Устанавливает для подключения <parameter>conn</parameter> указатель "
"<literal>instanceData</literal> для обработчика <parameter>proc</parameter> "
"равным <parameter>data</parameter>. Эта функция возвращает ненулевое "
"значение в случае успеха или ноль в противном случае. (Ошибка возможна, "
"только если обработчик <parameter>proc</parameter> не был корректно "
"зарегистрирован для соединения <parameter>conn</parameter>.) <synopsis>\n"
"int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);\n"
"</synopsis>"

#: libpq.xml:6562(function)
msgid "PQinstanceData"
msgstr "PQinstanceData"

#: libpq.xml:6563(indexterm)
msgid "<primary>PQinstanceData</primary>"
msgstr "<primary>PQinstanceData</primary>"

#: libpq.xml:6568(para)
msgid ""
"Returns the connection <parameter>conn</parameter>'s <literal>instanceData</"
"literal> associated with procedure <parameter>proc</parameter>, or "
"<symbol>NULL</symbol> if there is none. <synopsis>\n"
"void *PQinstanceData(const PGconn *conn, PGEventProc proc);\n"
"</synopsis>"
msgstr ""
"Возвращает для соединения <parameter>conn</parameter> указатель на "
"<literal>instanceData</literal>, связанный с обработчиком <parameter>proc</"
"parameter>, либо <symbol>NULL</symbol>, если такого обработчика нет. "
"<synopsis>\n"
"void *PQinstanceData(const PGconn *conn, PGEventProc proc);\n"
"</synopsis>"

#: libpq.xml:6583(function)
msgid "PQresultSetInstanceData"
msgstr "PQresultSetInstanceData"

#: libpq.xml:6584(indexterm)
msgid "<primary>PQresultSetInstanceData</primary>"
msgstr "<primary>PQresultSetInstanceData</primary>"

#: libpq.xml:6589(para)
msgid ""
"Sets the result's <literal>instanceData</literal> for <parameter>proc</"
"parameter> to <parameter>data</parameter>. This returns non-zero for success "
"and zero for failure. (Failure is only possible if <parameter>proc</"
"parameter> has not been properly registered in the result.) <synopsis>\n"
"int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);\n"
"</synopsis>"
msgstr ""
"Устанавливает для объекта результата (<parameter>res</parameter>) указатель "
"<literal>instanceData</literal> для обработчика <parameter>proc</parameter> "
"равным <parameter>data</parameter>. Эта функция возвращает ненулевое "
"значение в случае успеха или ноль в противном случае. (Ошибка возможна, "
"только если обработчик <parameter>proc</parameter> не был корректно "
"зарегистрирован для объекта результата.) <synopsis>\n"
"int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);\n"
"</synopsis>"

#: libpq.xml:6605(function)
msgid "PQresultInstanceData"
msgstr "PQresultInstanceData"

#: libpq.xml:6606(indexterm)
msgid "<primary>PQresultInstanceData</primary>"
msgstr "<primary>PQresultInstanceData</primary>"

#: libpq.xml:6611(para)
msgid ""
"Returns the result's <literal>instanceData</literal> associated with "
"<parameter>proc</parameter>, or <symbol>NULL</symbol> if there is none. "
"<synopsis>\n"
"void *PQresultInstanceData(const PGresult *res, PGEventProc proc);\n"
"</synopsis>"
msgstr ""
"Возвращает для объекта результата (<parameter>res</parameter>) указатель на "
"<literal>instanceData</literal>, связанный с обработчиком <parameter>proc</"
"parameter>, либо <symbol>NULL</symbol>, если такого обработчика нет. "
"<synopsis>\n"
"void *PQresultInstanceData(const PGresult *res, PGEventProc proc);\n"
"</synopsis>"

#: libpq.xml:6625(title)
msgid "Event Example"
msgstr "Пример обработки событий"

#: libpq.xml:6627(para)
msgid ""
"Here is a skeleton example of managing private data associated with libpq "
"connections and results."
msgstr ""
"Ниже показан схематичный пример управления внутренними данными, связанными с "
"подключениями и результатами libpq."

#: libpq.xml:6781(title)
msgid "Environment Variables"
msgstr "Переменные окружения"

#: libpq.xml:6783(indexterm)
msgid "<primary>environment variable</primary>"
msgstr "<primary>переменная окружения</primary>"

#: libpq.xml:6798(indexterm)
msgid "<primary><envar>PGHOST</envar></primary>"
msgstr "<primary><envar>PGHOST</envar></primary>"

#: libpq.xml:6797(para)
msgid ""
"<placeholder-1/> <envar>PGHOST</envar> behaves the same as the <xref linkend="
"\"libpq-connect-host\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGHOST</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-host\"/>."

#: libpq.xml:6808(indexterm)
msgid "<primary><envar>PGHOSTADDR</envar></primary>"
msgstr "<primary><envar>PGHOSTADDR</envar></primary>"

#: libpq.xml:6807(para)
msgid ""
"<placeholder-1/> <envar>PGHOSTADDR</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-hostaddr\"/> connection parameter. This can be set "
"instead of or in addition to <envar>PGHOST</envar> to avoid DNS lookup "
"overhead."
msgstr ""
"<placeholder-1/> <envar>PGHOSTADDR</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-hostaddr\"/>. Эту переменную можно "
"задать вместо или вместе с <envar>PGHOST</envar> для предотвращения поиска "
"адреса в DNS."

#: libpq.xml:6820(indexterm)
msgid "<primary><envar>PGPORT</envar></primary>"
msgstr "<primary><envar>PGPORT</envar></primary>"

#: libpq.xml:6819(para)
msgid ""
"<placeholder-1/> <envar>PGPORT</envar> behaves the same as the <xref linkend="
"\"libpq-connect-port\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGPORT</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-port\"/>."

#: libpq.xml:6830(indexterm)
msgid "<primary><envar>PGDATABASE</envar></primary>"
msgstr "<primary><envar>PGDATABASE</envar></primary>"

#: libpq.xml:6829(para)
msgid ""
"<placeholder-1/> <envar>PGDATABASE</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-dbname\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGDATABASE</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-dbname\"/>."

#: libpq.xml:6840(indexterm)
msgid "<primary><envar>PGUSER</envar></primary>"
msgstr "<primary><envar>PGUSER</envar></primary>"

#: libpq.xml:6839(para)
msgid ""
"<placeholder-1/> <envar>PGUSER</envar> behaves the same as the <xref linkend="
"\"libpq-connect-user\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGUSER</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-user\"/>."

#: libpq.xml:6850(indexterm)
msgid "<primary><envar>PGPASSWORD</envar></primary>"
msgstr "<primary><envar>PGPASSWORD</envar></primary>"

#: libpq.xml:6849(para)
msgid ""
"<placeholder-1/> <envar>PGPASSWORD</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-password\"/> connection parameter. Use of this "
"environment variable is not recommended for security reasons, as some "
"operating systems allow non-root users to see process environment variables "
"via <application>ps</application>; instead consider using the <filename>~/."
"pgpass</filename> file (see <xref linkend=\"libpq-pgpass\"/>)."
msgstr ""
"<placeholder-1/> <envar>PGPASSWORD</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-password\"/>. Использовать эту "
"переменную окружения не рекомендуется по соображениям безопасности, так как "
"в некоторых операционных системах непривилегированные пользователи могут "
"видеть переменные окружения процессов в выводе <application>ps</"
"application>; вместо этого лучше использовать файл <filename>~/.pgpass</"
"filename> (см. <xref remap=\"4\" linkend=\"libpq-pgpass\"/>)."

#: libpq.xml:6865(indexterm)
msgid "<primary><envar>PGPASSFILE</envar></primary>"
msgstr "<primary><envar>PGPASSFILE</envar></primary>"

#: libpq.xml:6864(para)
msgid ""
"<placeholder-1/> <envar>PGPASSFILE</envar> specifies the name of the "
"password file to use for lookups. If not set, it defaults to <filename>~/."
"pgpass</filename> (see <xref linkend=\"libpq-pgpass\"/>)."
msgstr ""
"<placeholder-1/> <envar>PGPASSFILE</envar> устанавливает имя файла паролей, "
"в котором будут находиться сохранённые пароли. По умолчанию применяется имя "
"файла <filename>~/.pgpass</filename> (см. <xref remap=\"4\" linkend=\"libpq-"
"pgpass\"/>)."

#: libpq.xml:6876(indexterm)
msgid "<primary><envar>PGSERVICE</envar></primary>"
msgstr "<primary><envar>PGSERVICE</envar></primary>"

#: libpq.xml:6875(para)
msgid ""
"<placeholder-1/> <envar>PGSERVICE</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-service\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGSERVICE</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-service\"/>."

#: libpq.xml:6886(indexterm)
msgid "<primary><envar>PGSERVICEFILE</envar></primary>"
msgstr "<primary><envar>PGSERVICEFILE</envar></primary>"

#: libpq.xml:6885(para)
msgid ""
"<placeholder-1/> <envar>PGSERVICEFILE</envar> specifies the name of the per-"
"user connection service file. If not set, it defaults to <filename>~/."
"pg_service.conf</filename> (see <xref linkend=\"libpq-pgservice\"/>)."
msgstr ""
"<placeholder-1/> <envar>PGSERVICEFILE</envar> задаёт имя личного файла "
"пользователя с параметрами подключения к службам. По умолчанию применяется "
"имя файла <filename>~/.pg_service.conf</filename> (см. <xref remap=\"4\" "
"linkend=\"libpq-pgservice\"/>)."

#: libpq.xml:6898(indexterm)
msgid "<primary><envar>PGOPTIONS</envar></primary>"
msgstr "<primary><envar>PGOPTIONS</envar></primary>"

#: libpq.xml:6897(para)
msgid ""
"<placeholder-1/> <envar>PGOPTIONS</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-options\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGOPTIONS</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-options\"/>."

#: libpq.xml:6908(indexterm)
msgid "<primary><envar>PGAPPNAME</envar></primary>"
msgstr "<primary><envar>PGAPPNAME</envar></primary>"

#: libpq.xml:6907(para)
msgid ""
"<placeholder-1/> <envar>PGAPPNAME</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-application-name\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGAPPNAME</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-application-name\"/>."

#: libpq.xml:6918(indexterm)
msgid "<primary><envar>PGSSLMODE</envar></primary>"
msgstr "<primary><envar>PGSSLMODE</envar></primary>"

#: libpq.xml:6917(para)
msgid ""
"<placeholder-1/> <envar>PGSSLMODE</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-sslmode\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGSSLMODE</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-sslmode\"/>."

#: libpq.xml:6928(indexterm)
msgid "<primary><envar>PGREQUIRESSL</envar></primary>"
msgstr "<primary><envar>PGREQUIRESSL</envar></primary>"

#: libpq.xml:6927(para)
msgid ""
"<placeholder-1/> <envar>PGREQUIRESSL</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-requiressl\"/> connection parameter. This "
"environment variable is deprecated in favor of the <envar>PGSSLMODE</envar> "
"variable; setting both variables suppresses the effect of this one."
msgstr ""
"<placeholder-1/> <envar>PGREQUIRESSL</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-requiressl\"/>. Эта переменная "
"окружения утратила актуальность с появлением переменной <envar>PGSSLMODE</"
"envar>; если установить обе переменные, значение данной не возымеет эффекта."

#: libpq.xml:6941(indexterm)
msgid "<primary><envar>PGSSLCOMPRESSION</envar></primary>"
msgstr "<primary><envar>PGSSLCOMPRESSION</envar></primary>"

#: libpq.xml:6940(para)
msgid ""
"<placeholder-1/> <envar>PGSSLCOMPRESSION</envar> behaves the same as the "
"<xref linkend=\"libpq-connect-sslcompression\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGSSLCOMPRESSION</envar> действует так же, как "
"параметр соединения <xref linkend=\"libpq-connect-sslcompression\"/>."

#: libpq.xml:6951(indexterm)
msgid "<primary><envar>PGSSLCERT</envar></primary>"
msgstr "<primary><envar>PGSSLCERT</envar></primary>"

#: libpq.xml:6950(para)
msgid ""
"<placeholder-1/> <envar>PGSSLCERT</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-sslcert\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGSSLCERT</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-sslcert\"/>."

#: libpq.xml:6961(indexterm)
msgid "<primary><envar>PGSSLKEY</envar></primary>"
msgstr "<primary><envar>PGSSLKEY</envar></primary>"

#: libpq.xml:6960(para)
msgid ""
"<placeholder-1/> <envar>PGSSLKEY</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-sslkey\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGSSLKEY</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-sslkey\"/>."

#: libpq.xml:6971(indexterm)
msgid "<primary><envar>PGSSLROOTCERT</envar></primary>"
msgstr "<primary><envar>PGSSLROOTCERT</envar></primary>"

#: libpq.xml:6970(para)
msgid ""
"<placeholder-1/> <envar>PGSSLROOTCERT</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-sslrootcert\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGSSLROOTCERT</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-sslrootcert\"/>."

#: libpq.xml:6981(indexterm)
msgid "<primary><envar>PGSSLCRL</envar></primary>"
msgstr "<primary><envar>PGSSLCRL</envar></primary>"

#: libpq.xml:6980(para)
msgid ""
"<placeholder-1/> <envar>PGSSLCRL</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-sslcrl\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGSSLCRL</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-sslcrl\"/>."

#: libpq.xml:6991(indexterm)
msgid "<primary><envar>PGREQUIREPEER</envar></primary>"
msgstr "<primary><envar>PGREQUIREPEER</envar></primary>"

#: libpq.xml:6990(para)
msgid ""
"<placeholder-1/> <envar>PGREQUIREPEER</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-requirepeer\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGREQUIREPEER</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-requirepeer\"/>."

#: libpq.xml:7001(indexterm)
msgid "<primary><envar>PGKRBSRVNAME</envar></primary>"
msgstr "<primary><envar>PGKRBSRVNAME</envar></primary>"

#: libpq.xml:7000(para)
msgid ""
"<placeholder-1/> <envar>PGKRBSRVNAME</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-krbsrvname\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGKRBSRVNAME</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-krbsrvname\"/>."

#: libpq.xml:7011(indexterm)
msgid "<primary><envar>PGGSSLIB</envar></primary>"
msgstr "<primary><envar>PGGSSLIB</envar></primary>"

#: libpq.xml:7010(para)
msgid ""
"<placeholder-1/> <envar>PGGSSLIB</envar> behaves the same as the <xref "
"linkend=\"libpq-connect-gsslib\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGGSSLIB</envar> действует так же, как параметр "
"соединения <xref linkend=\"libpq-connect-gsslib\"/>."

#: libpq.xml:7021(indexterm)
msgid "<primary><envar>PGCONNECT_TIMEOUT</envar></primary>"
msgstr "<primary><envar>PGCONNECT_TIMEOUT</envar></primary>"

#: libpq.xml:7020(para)
msgid ""
"<placeholder-1/> <envar>PGCONNECT_TIMEOUT</envar> behaves the same as the "
"<xref linkend=\"libpq-connect-connect-timeout\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGCONNECT_TIMEOUT</envar> действует так же, как "
"параметр соединения <xref linkend=\"libpq-connect-connect-timeout\"/>."

#: libpq.xml:7031(indexterm)
msgid "<primary><envar>PGCLIENTENCODING</envar></primary>"
msgstr "<primary><envar>PGCLIENTENCODING</envar></primary>"

#: libpq.xml:7030(para)
msgid ""
"<placeholder-1/> <envar>PGCLIENTENCODING</envar> behaves the same as the "
"<xref linkend=\"libpq-connect-client-encoding\"/> connection parameter."
msgstr ""
"<placeholder-1/> <envar>PGCLIENTENCODING</envar> действует так же, как "
"параметр соединения <xref linkend=\"libpq-connect-client-encoding\"/>."

#: libpq.xml:6787(para)
msgid ""
"The following environment variables can be used to select default connection "
"parameter values, which will be used by <function>PQconnectdb</function>, "
"<function>PQsetdbLogin</function> and <function>PQsetdb</function> if no "
"value is directly specified by the calling code. These are useful to avoid "
"hard-coding database connection information into simple client applications, "
"for example. <placeholder-1/>"
msgstr ""
"Воспользовавшись следующими переменными окружения, можно задать значения "
"параметров соединения по умолчанию, которые будут использоваться функциями "
"<function>PQconnectdb</function>, <function>PQsetdbLogin</function> и "
"<function>PQsetdb</function>, если никакое значение не будет задано "
"вызывающим кодом. В частности, используя их, можно обойтись без жёсткого "
"задания параметров соединения в простых клиентских приложениях. "
"<placeholder-1/>"

#: libpq.xml:7052(indexterm)
msgid "<primary><envar>PGDATESTYLE</envar></primary>"
msgstr "<primary><envar>PGDATESTYLE</envar></primary>"

#: libpq.xml:7051(para)
msgid ""
"<placeholder-1/> <envar>PGDATESTYLE</envar> sets the default style of date/"
"time representation. (Equivalent to <literal>SET datestyle TO ...</literal>.)"
msgstr ""
"<placeholder-1/> <envar>PGDATESTYLE</envar> устанавливает стиль "
"представления даты/времени по умолчанию. (Равносильно <literal>SET datestyle "
"TO ...</literal>.)"

#: libpq.xml:7063(indexterm)
msgid "<primary><envar>PGTZ</envar></primary>"
msgstr "<primary><envar>PGTZ</envar></primary>"

#: libpq.xml:7062(para)
msgid ""
"<placeholder-1/> <envar>PGTZ</envar> sets the default time zone. (Equivalent "
"to <literal>SET timezone TO ...</literal>.)"
msgstr ""
"<placeholder-1/> <envar>PGTZ</envar> устанавливает часовой пояс по "
"умолчанию. (Равносильно <literal>SET timezone TO ...</literal>.)"

#: libpq.xml:7073(indexterm)
msgid "<primary><envar>PGGEQO</envar></primary>"
msgstr "<primary><envar>PGGEQO</envar></primary>"

#: libpq.xml:7072(para)
msgid ""
"<placeholder-1/> <envar>PGGEQO</envar> sets the default mode for the genetic "
"query optimizer. (Equivalent to <literal>SET geqo TO ...</literal>.)"
msgstr ""
"<placeholder-1/> <envar>PGGEQO</envar> устанавливает режим по умолчанию для "
"генетического оптимизатора запросов. (Равносильно <literal>SET geqo TO ...</"
"literal>.)"

#: libpq.xml:7041(para)
msgid ""
"The following environment variables can be used to specify default behavior "
"for each <productname>PostgreSQL</productname> session. (See also the <xref "
"linkend=\"sql-alterrole\"/> and <xref linkend=\"sql-alterdatabase\"/> "
"commands for ways to set default behavior on a per-user or per-database "
"basis.) <placeholder-1/> Refer to the <acronym>SQL</acronym> command <xref "
"linkend=\"sql-set\"/> for information on correct values for these "
"environment variables."
msgstr ""
"Следующие переменные окружения позволяют задать поведение по умолчанию для "
"каждого отдельного сеанса <productname>PostgreSQL</productname>. (См. также "
"описание команд <xref linkend=\"sql-alterrole\"/> и <xref linkend=\"sql-"
"alterdatabase\"/>, позволяющих установить поведение по умолчанию для "
"отдельного пользователя или отдельной базы.) <placeholder-1/> Информацию о "
"корректных значениях этих переменных окружения можно найти в описании "
"<acronym>SQL</acronym>-команды <xref linkend=\"sql-set\"/>."

#: libpq.xml:7094(indexterm)
msgid "<primary><envar>PGSYSCONFDIR</envar></primary>"
msgstr "<primary><envar>PGSYSCONFDIR</envar></primary>"

#: libpq.xml:7093(para)
msgid ""
"<placeholder-1/> <envar>PGSYSCONFDIR</envar> sets the directory containing "
"the <filename>pg_service.conf</filename> file and in a future version "
"possibly other system-wide configuration files."
msgstr ""
"<placeholder-1/> <envar>PGSYSCONFDIR</envar> задаёт каталог, в котором "
"содержится файл <filename>pg_service.conf</filename>, а в будущем он может "
"содержать и другие общесистемные файлы конфигурации."

#: libpq.xml:7105(indexterm)
msgid "<primary><envar>PGLOCALEDIR</envar></primary>"
msgstr "<primary><envar>PGLOCALEDIR</envar></primary>"

#: libpq.xml:7104(para)
msgid ""
"<placeholder-1/> <envar>PGLOCALEDIR</envar> sets the directory containing "
"the <literal>locale</literal> files for message localization."
msgstr ""
"<placeholder-1/> <envar>PGLOCALEDIR</envar> задаёт каталог, содержащий файлы "
"<literal>locale</literal>, предназначенные для перевода сообщений."

#: libpq.xml:7087(para)
msgid ""
"The following environment variables determine internal behavior of "
"<application>libpq</application>; they override compiled-in defaults. "
"<placeholder-1/>"
msgstr ""
"Следующие переменные среды определяют внутреннее поведение "
"<application>libpq</application>; они переопределяют встроенные значения. "
"<placeholder-1/>"

#: libpq.xml:7119(title)
msgid "The Password File"
msgstr "Файл паролей"

#: libpq.xml:7121(indexterm)
msgid "<primary>password file</primary>"
msgstr "<primary>файл паролей</primary>"

#: libpq.xml:7124(indexterm)
msgid "<primary>.pgpass</primary>"
msgstr "<primary>.pgpass</primary>"

#: libpq.xml:7128(para)
msgid ""
"The file <filename>.pgpass</filename> in a user's home directory or the file "
"referenced by <envar>PGPASSFILE</envar> can contain passwords to be used if "
"the connection requires a password (and no password has been specified "
"otherwise). On Microsoft Windows the file is named <filename>%APPDATA%"
"\\postgresql\\pgpass.conf</filename> (where <filename>%APPDATA%</filename> "
"refers to the Application Data subdirectory in the user's profile)."
msgstr ""
"Файл <filename>.pgpass</filename> в домашнем каталоге пользователя или файл, "
"заданный в <envar>PGPASSFILE</envar>, может содержать пароли, которые будут "
"использоваться, если для подключения требуется пароль (и пароль не задаётся "
"другим способом). В Microsoft Windows этот файл называется <filename>%APPDATA"
"%\\postgresql\\pgpass.conf</filename> (где <filename>%APPDATA%</filename> "
"обозначает каталог данных приложений (Application Data) в профиле "
"пользователя)."

#: libpq.xml:7138(para)
msgid ""
"This file should contain lines of the following format: <synopsis>\n"
"<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:"
"<replaceable>database</replaceable>:<replaceable>username</replaceable>:"
"<replaceable>password</replaceable>\n"
"</synopsis> (You can add a reminder comment to the file by copying the line "
"above and preceding it with <literal>#</literal>.) Each of the first four "
"fields can be a literal value, or <literal>*</literal>, which matches "
"anything. The password field from the first line that matches the current "
"connection parameters will be used. (Therefore, put more-specific entries "
"first when you are using wildcards.) If an entry needs to contain <literal>:"
"</literal> or <literal>\\</literal>, escape this character with <literal>\\</"
"literal>. A host name of <literal>localhost</literal> matches both TCP (host "
"name <literal>localhost</literal>) and Unix domain socket (<literal>pghost</"
"literal> empty or the default socket directory) connections coming from the "
"local machine. In a standby server, a database name of <literal>replication</"
"literal> matches streaming replication connections made to the master "
"server. The <literal>database</literal> field is of limited usefulness "
"because users have the same password for all databases in the same cluster."
msgstr ""
"Этот файл должен содержать строки следующего формата: <synopsis>\n"
"<replaceable>сервер</replaceable>:<replaceable>порт</replaceable>:"
"<replaceable>база_данных</replaceable>:<replaceable>имя_пользователя</"
"replaceable>:<replaceable>пароль</replaceable>\n"
"</synopsis> (Вы можете вставить в этот файл комментарий-памятку, скопировав "
"показанную строку в него и добавив в начало <literal>#</literal>.) Первые "
"четыре поля могут содержать строковые значения, либо знак <literal>*</"
"literal>, соответствующий всему. Применяться будет пароль, указанный в "
"первой из строк, значения полей в которой соответствуют текущему соединению. "
"(Поэтому, если вы используете звёздочки, поместите более конкретные записи "
"первыми.) Если запись должна содержать символ <literal>:</literal> или "
"<literal>\\</literal>, добавьте перед ним <literal>\\</literal>. Имени "
"сервера <literal>localhost</literal> соответствуют локальные соединения и по "
"TCP (по имени компьютера <literal>localhost</literal>), и через доменный "
"сокет Unix (заданный в <literal>pghost</literal>, либо каталог сокетов по "
"умолчанию). На резервном сервере имя базы данных <literal>replication</"
"literal> соответствует подключениям потоковой репликации, которые "
"устанавливает ведущий. Поле <replaceable>база_данных</replaceable> имеет "
"ограниченную ценность, так как пользователи используют один пароль для всех "
"баз данных в кластере."

#: libpq.xml:7160(para)
msgid ""
"On Unix systems, the permissions on <filename>.pgpass</filename> must "
"disallow any access to world or group; achieve this by the command "
"<command>chmod 0600 ~/.pgpass</command>. If the permissions are less strict "
"than this, the file will be ignored. On Microsoft Windows, it is assumed "
"that the file is stored in a directory that is secure, so no special "
"permissions check is made."
msgstr ""
"В системах Unix разрешения <filename>.pgpass</filename> должны запрещать "
"чтение его всеми или группой; этого можно добиться командой <command>chmod "
"0600 ~/.pgpass</command>. Если разрешения будут менее строгими, этот файл не "
"будет прочитан. В Microsoft Windows предполагается, что файл хранится в "
"безопасном месте, и никакие дополнительные проверки не производятся."

#: libpq.xml:7172(title)
msgid "The Connection Service File"
msgstr "Файл соединений служб"

#: libpq.xml:7174(indexterm)
msgid "<primary>connection service file</primary>"
msgstr "<primary>файл соединений служб</primary>"

#: libpq.xml:7177(indexterm)
msgid "<primary>pg_service.conf</primary>"
msgstr "<primary>pg_service.conf</primary>"

#: libpq.xml:7180(indexterm)
msgid "<primary>.pg_service.conf</primary>"
msgstr "<primary>.pg_service.conf</primary>"

#: libpq.xml:7184(para)
msgid ""
"The connection service file allows libpq connection parameters to be "
"associated with a single service name. That service name can then be "
"specified by a libpq connection, and the associated settings will be used. "
"This allows connection parameters to be modified without requiring a "
"recompile of the libpq application. The service name can also be specified "
"using the <envar>PGSERVICE</envar> environment variable."
msgstr ""
"Файл соединений служб позволяет связать параметры соединений libpq с одним "
"именем службы. Затем это имя службы можно задать при подключении через libpq "
"и будут применены все связанные с ним параметры. Это позволяет "
"модифицировать параметры соединений, обходясь без перекомпиляции приложения "
"libpq. Имя службы можно также задать в переменной окружения "
"<envar>PGSERVICE</envar>."

#: libpq.xml:7193(para)
msgid ""
"The connection service file can be a per-user service file at <filename>~/."
"pg_service.conf</filename> or the location specified by the environment "
"variable <envar>PGSERVICEFILE</envar>, or it can be a system-wide file at "
"<filename>`pg_config --sysconfdir`/pg_service.conf</filename> or in the "
"directory specified by the environment variable <envar>PGSYSCONFDIR</envar>. "
"If service definitions with the same name exist in the user and the system "
"file, the user file takes precedence."
msgstr ""
"Файл соединений служб может быть личным файлом пользователя с путём "
"<filename>~/.pg_service.conf</filename> или задаваться переменной окружения "
"<envar>PGSERVICEFILE</envar>, либо это может быть системный файл с путём "
"<filename>`pg_config --sysconfdir`/pg_service.conf</filename> или в "
"каталоге, задаваемом переменной окружения <envar>PGSYSCONFDIR</envar>. Если "
"для одного имени службы существует определение и в системном файле, и в "
"файле пользователя, определение пользователя имеет приоритет."

#: libpq.xml:7210(programlisting)
#, no-wrap
msgid ""
"# comment\n"
"[mydb]\n"
"host=somehost\n"
"port=5433\n"
"user=admin"
msgstr ""
"# комментарий\n"
"[mydb]\n"
"host=somehost\n"
"port=5433\n"
"user=admin"

#: libpq.xml:7205(para)
msgid ""
"The file uses an <quote>INI file</quote> format where the section name is "
"the service name and the parameters are connection parameters; see <xref "
"linkend=\"libpq-paramkeywords\"/> for a list. For example: <placeholder-1/> "
"An example file is provided at <filename>share/pg_service.conf.sample</"
"filename>."
msgstr ""
"В этом файле используется формат <quote>INI-файлов</quote>, в котором имя "
"раздела задаёт имя службы, а параметры внутри — параметры соединения; их "
"список приведён в <xref remap=\"6\" linkend=\"libpq-paramkeywords\"/>. "
"Например: <placeholder-1/> Пример такого файла можно найти в <filename>share/"
"pg_service.conf.sample</filename>."

#: libpq.xml:7224(title)
msgid "LDAP Lookup of Connection Parameters"
msgstr "Получение параметров соединения через LDAP"

#: libpq.xml:7226(indexterm)
msgid "<primary>LDAP connection parameter lookup</primary>"
msgstr "<primary>получение параметров соединения через LDAP</primary>"

#: libpq.xml:7230(para)
msgid ""
"If <application>libpq</application> has been compiled with LDAP support "
"(option <literal><option>--with-ldap</option></literal> for "
"<command>configure</command>) it is possible to retrieve connection options "
"like <literal>host</literal> or <literal>dbname</literal> via LDAP from a "
"central server. The advantage is that if the connection parameters for a "
"database change, the connection information doesn't have to be updated on "
"all client machines."
msgstr ""
"Если библиотека <application>libpq</application> была собрана с поддержка "
"LDAP (<command>configure</command> передавался ключ <literal><option>--with-"
"ldap</option></literal>), такие параметры соединения, как <literal>host</"
"literal> и <literal>dbname</literal>, можно получить через LDAP с "
"центрального сервера. Преимущество такого подхода в том, что при изменении "
"параметров подключения к базе данных свойства соединения не придётся "
"изменять на всех клиентских компьютерах."

#: libpq.xml:7239(para)
msgid ""
"LDAP connection parameter lookup uses the connection service file "
"<filename>pg_service.conf</filename> (see <xref linkend=\"libpq-pgservice\"/"
">). A line in a <filename>pg_service.conf</filename> stanza that starts with "
"<literal>ldap://</literal> will be recognized as an LDAP URL and an LDAP "
"query will be performed. The result must be a list of <literal>keyword = "
"value</literal> pairs which will be used to set connection options. The URL "
"must conform to RFC 1959 and be of the form <synopsis>\n"
"ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</"
"replaceable>]]/<replaceable>search_base</replaceable>?"
"<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?"
"<replaceable>filter</replaceable>\n"
"</synopsis> where <replaceable>hostname</replaceable> defaults to "
"<literal>localhost</literal> and <replaceable>port</replaceable> defaults to "
"389."
msgstr ""
"Для получения параметров соединений через LDAP используется файл соединений "
"служб <filename>pg_service.conf</filename> (см. <xref remap=\"4\" linkend="
"\"libpq-pgservice\"/>). Строка в <filename>pg_service.conf</filename>, "
"начинающаяся с указания протокола <literal>ldap://</literal>, будет "
"воспринята как URL в LDAP и выполнится как запрос к LDAP. Результатом "
"запроса должен быть список пар <literal>keyword = value</literal>, которые и "
"будут задавать параметры соединений. Заданный URL должен соответствовать RFC "
"1959 и иметь следующий вид: <synopsis>\n"
"ldap://[<replaceable>имя_сервера</replaceable>[:<replaceable>порт</"
"replaceable>]]/<replaceable>база_поиска</replaceable>?<replaceable>атрибут</"
"replaceable>?<replaceable>область_поиска</replaceable>?<replaceable>фильтр</"
"replaceable>\n"
"</synopsis>; по умолчанию <replaceable>имя_сервера</replaceable> — "
"<literal>localhost</literal>, а <replaceable>порт</replaceable> — 389."

#: libpq.xml:7257(para)
msgid ""
"Processing of <filename>pg_service.conf</filename> is terminated after a "
"successful LDAP lookup, but is continued if the LDAP server cannot be "
"contacted. This is to provide a fallback with further LDAP URL lines that "
"point to different LDAP servers, classical <literal>keyword = value</"
"literal> pairs, or default connection options. If you would rather get an "
"error message in this case, add a syntactically incorrect line after the "
"LDAP URL."
msgstr ""
"Обработка <filename>pg_service.conf</filename> прекращается после удачного "
"поиска в LDAP, но если с сервером LDAP связаться не удаётся, обрабатываются "
"следующие строки этого файла. Так сделано для того, чтобы можно было "
"реализовать запасные варианты, добавив дополнительные строки с URL LDAP, "
"указывающими на другие серверы LDAP, или классические пары <literal>keyword "
"= value</literal>, либо используя параметры соединений по умолчанию. Если же "
"вы хотите получить ошибку в этой ситуации, добавьте после строки с URL-"
"адресом LDAP синтаксически некорректную строку."

#: libpq.xml:7269(programlisting)
#, no-wrap
msgid ""
"version:1\n"
"dn:cn=mydatabase,dc=mycompany,dc=com\n"
"changetype:add\n"
"objectclass:top\n"
"objectclass:device\n"
"cn:mydatabase\n"
"description:host=dbserver.mycompany.com\n"
"description:port=5439\n"
"description:dbname=mydb\n"
"description:user=mydb_user\n"
"description:sslmode=require"
msgstr ""
"version:1\n"
"dn:cn=mydatabase,dc=mycompany,dc=com\n"
"changetype:add\n"
"objectclass:top\n"
"objectclass:device\n"
"cn:mydatabase\n"
"description:host=dbserver.mycompany.com\n"
"description:port=5439\n"
"description:dbname=mydb\n"
"description:user=mydb_user\n"
"description:sslmode=require"

#: libpq.xml:7283(programlisting)
#, no-wrap
msgid "ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)"
msgstr "ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)"

#: libpq.xml:7267(para)
msgid ""
"A sample LDAP entry that has been created with the LDIF file <placeholder-1/"
"> might be queried with the following LDAP URL: <placeholder-2/>"
msgstr ""
"Простую запись LDAP, созданную из такого файла LDIF <placeholder-1/> можно "
"запросить из каталога LDAP, указав следующий URL: <placeholder-2/>"

#: libpq.xml:7292(programlisting)
#, no-wrap
msgid ""
"# only host and port are stored in LDAP, specify dbname and user explicitly\n"
"[customerdb]\n"
"dbname=customer\n"
"user=appuser\n"
"ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)"
msgstr ""
"# в LDAP хранится только имя и порт сервера; имя базы и пользователя нужно задать явно\n"
"[customerdb]\n"
"dbname=customer\n"
"user=appuser\n"
"ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)"

#: libpq.xml:7288(para)
msgid ""
"You can also mix regular service file entries with LDAP lookups. A complete "
"example for a stanza in <filename>pg_service.conf</filename> would be: "
"<placeholder-1/>"
msgstr ""
"Также возможно сочетать обычные записи в файле служб с поиском в LDAP. "
"Полный пример описания службы в <filename>pg_service.conf</filename> может "
"быть таким: <placeholder-1/>"

#: libpq.xml:7305(title)
msgid "SSL Support"
msgstr "Поддержка SSL"

#: libpq.xml:7307(indexterm)
msgid "<primary>SSL</primary>"
msgstr "<primary>SSL</primary>"

#: libpq.xml:7311(para)
msgid ""
"<productname>PostgreSQL</productname> has native support for using "
"<acronym>SSL</acronym> connections to encrypt client/server communications "
"for increased security. See <xref linkend=\"ssl-tcp\"/> for details about "
"the server-side <acronym>SSL</acronym> functionality."
msgstr ""
"<productname>PostgreSQL</productname> реализует собственную поддержку "
"<acronym>SSL</acronym>-подключений для шифрования клиент-серверного "
"взаимодействия в качестве меры безопасности. Подробнее функциональность "
"<acronym>SSL</acronym> на стороне сервера описывается в <xref remap=\"6\" "
"linkend=\"ssl-tcp\"/>."

#: libpq.xml:7318(para)
msgid ""
"<application>libpq</application> reads the system-wide <productname>OpenSSL</"
"productname> configuration file. By default, this file is named "
"<filename>openssl.cnf</filename> and is located in the directory reported by "
"<literal>openssl version -d</literal>. This default can be overridden by "
"setting environment variable <envar>OPENSSL_CONF</envar> to the name of the "
"desired configuration file."
msgstr ""
"Библиотека <application>libpq</application> читает системный файл "
"конфигурации <productname>OpenSSL</productname>. По умолчанию этот файл "
"называется <filename>openssl.cnf</filename> и находится в каталоге, который "
"сообщает команда <literal>openssl version -d</literal>. Если требуется "
"указать другое расположение файла конфигурации, его можно задать в "
"переменной окружения <envar>OPENSSL_CONF</envar>."

#: libpq.xml:7329(title)
msgid "Client Verification of Server Certificates"
msgstr "Проверка сертификатов сервера на стороне клиента"

#: libpq.xml:7331(para)
msgid ""
"By default, <productname>PostgreSQL</productname> will not perform any "
"verification of the server certificate. This means that it is possible to "
"spoof the server identity (for example by modifying a DNS record or by "
"taking over the server IP address) without the client knowing. In order to "
"prevent spoofing, <acronym>SSL</acronym> certificate verification must be "
"used."
msgstr ""
"По умолчанию <productname>PostgreSQL</productname> не выполняет никакие "
"проверки сертификата сервера. Это означает, что клиента можно ввести в "
"заблуждение, подменив сервер (например, изменив запись в DNS или заняв его "
"IP-адрес). Чтобы предотвратить подобную подмену, необходимо включить "
"проверку сертификатов <acronym>SSL</acronym>."

#: libpq.xml:7339(para)
msgid ""
"If the parameter <literal>sslmode</literal> is set to <literal>verify-ca</"
"literal>, libpq will verify that the server is trustworthy by checking the "
"certificate chain up to a trusted certificate authority (<acronym>CA</"
"acronym>). If <literal>sslmode</literal> is set to <literal>verify-full</"
"literal>, libpq will <emphasis>also</emphasis> verify that the server host "
"name matches its certificate. The SSL connection will fail if the server "
"certificate cannot be verified. <literal>verify-full</literal> is "
"recommended in most security-sensitive environments."
msgstr ""
"Если в <literal>sslmode</literal> выбран режим <literal>verify-ca</literal>, "
"libpq будет определять, можно ли доверять серверу, проверяя всю цепочку "
"сертификатов до доверенного центра сертификации (<acronym>ЦС</acronym>). "
"Если режим <literal>sslmode</literal> — <literal>verify-full</literal>, "
"libpq будет <emphasis>также</emphasis> проверять, соответствует ли имя "
"сервера имени в сертификате. Подключение SSL не будет установлено, если "
"проверить сертификат сервера не удастся. В максимально защищённых окружениях "
"рекомендуется использовать режим <literal>verify-full</literal>."

#: libpq.xml:7350(para)
msgid ""
"In <literal>verify-full</literal> mode, the host name is matched against the "
"certificate's Subject Alternative Name attribute(s), or against the Common "
"Name attribute if no Subject Alternative Name of type <literal>dNSName</"
"literal> is present. If the certificate's name attribute starts with an "
"asterisk (<literal>*</literal>), the asterisk will be treated as a wildcard, "
"which will match all characters <emphasis>except</emphasis> a dot (<literal>."
"</literal>). This means the certificate will not match subdomains. If the "
"connection is made using an IP address instead of a host name, the IP "
"address will be matched (without doing any DNS lookups)."
msgstr ""
"В режиме <literal>verify-full</literal> имя компьютера сверяется с атрибутом "
"(или атрибутами) Subject Alternative Name (Альтернативное имя субъекта) в "
"сертификате или с атрибутом Common Name (Общее имя), если в сертификате "
"отсутствует атрибут Subject Alternative Name типа <literal>dNSName</"
"literal>. Если атрибут имени сертификата начинается со звёздочки "
"(<literal>*</literal>), звёздочка воспринимается как подстановочный знак и "
"ей будут соответствовать все символы, <emphasis>кроме</emphasis> точки "
"(<literal>.</literal>). Это означает, что такой сертификат не будет "
"соответствовать поддоменам. Если подключение устанавливается по IP-адресу, а "
"не по имени компьютера, проверяться будет IP-адрес (без поиска в DNS)."

#: libpq.xml:7362(para)
msgid ""
"To allow server certificate verification, the certificate(s) of one or more "
"trusted <acronym>CA</acronym>s must be placed in the file <filename>~/."
"postgresql/root.crt</filename> in the user's home directory. If intermediate "
"<acronym>CA</acronym>s appear in <filename>root.crt</filename>, the file "
"must also contain certificate chains to their root <acronym>CA</acronym>s. "
"(On Microsoft Windows the file is named <filename>%APPDATA%\\postgresql"
"\\root.crt</filename>.)"
msgstr ""
"Чтобы можно было проверить сертификат сервера, файл <filename>~/.postgresql/"
"root.crt</filename> в домашнем каталоге пользователя должен содержать "
"сертификат(ы) одного или нескольких доверенных <acronym>ЦС</acronym>. Если "
"<filename>root.crt</filename> содержит сертификаты промежуточных "
"<acronym>ЦС</acronym>, он также должен содержать цепочки сертификатов до их "
"корневого <acronym>ЦС</acronym>. (В Microsoft Windows этот файл называется "
"<filename>%APPDATA%\\postgresql\\root.crt</filename>.)"

#: libpq.xml:7372(para)
msgid ""
"Certificate Revocation List (CRL) entries are also checked if the file "
"<filename>~/.postgresql/root.crl</filename> exists (<filename>%APPDATA%"
"\\postgresql\\root.crl</filename> on Microsoft Windows)."
msgstr ""
"Если существует файл <filename>~/.postgresql/root.crl</filename> (или "
"<filename>%APPDATA%\\postgresql\\root.crl</filename> в Microsoft Windows), "
"при проверке также учитывается содержащийся в нём список отозванных "
"сертификатов (CRL, Certificate Revocation List)."

#: libpq.xml:7379(para)
msgid ""
"The location of the root certificate file and the CRL can be changed by "
"setting the connection parameters <literal>sslrootcert</literal> and "
"<literal>sslcrl</literal> or the environment variables <envar>PGSSLROOTCERT</"
"envar> and <envar>PGSSLCRL</envar>."
msgstr ""
"Размещение файла корневых сертификатов и CRL можно поменять, задав параметры "
"соединения <literal>sslrootcert</literal> и <literal>sslcrl</literal> или "
"переменные окружения <envar>PGSSLROOTCERT</envar> и <envar>PGSSLCRL</envar>, "
"соответственно."

#: libpq.xml:7387(para)
msgid ""
"For backwards compatibility with earlier versions of PostgreSQL, if a root "
"CA file exists, the behavior of <literal>sslmode</literal>=<literal>require</"
"literal> will be the same as that of <literal>verify-ca</literal>, meaning "
"the server certificate is validated against the CA. Relying on this behavior "
"is discouraged, and applications that need certificate validation should "
"always use <literal>verify-ca</literal> or <literal>verify-full</literal>."
msgstr ""
"Для обратной совместимости с предыдущими версиями PostgreSQL, при наличии "
"файла с сертификатами корневых ЦС поведение режима <literal>sslmode</"
"literal>=<literal>require</literal> не отличается от режима <literal>verify-"
"ca</literal>, то есть сертификат сервера будет проверяться по сертификату "
"ЦС. Полагаться на это поведение не рекомендуется — приложения, которым нужно "
"проверять сертификат, должны всегда выбирать режим <literal>verify-ca</"
"literal> или <literal>verify-full</literal>."

#: libpq.xml:7400(title)
msgid "Client Certificates"
msgstr "Клиентские сертификаты"

#: libpq.xml:7402(para)
msgid ""
"If the server requests a trusted client certificate, <application>libpq</"
"application> will send the certificate stored in file <filename>~/."
"postgresql/postgresql.crt</filename> in the user's home directory. The "
"certificate must be signed by one of the certificate authorities "
"(<acronym>CA</acronym>) trusted by the server. A matching private key file "
"<filename>~/.postgresql/postgresql.key</filename> must also be present. The "
"private key file must not allow any access to world or group; achieve this "
"by the command <command>chmod 0600 ~/.postgresql/postgresql.key</command>. "
"On Microsoft Windows these files are named <filename>%APPDATA%\\postgresql"
"\\postgresql.crt</filename> and <filename>%APPDATA%\\postgresql\\postgresql."
"key</filename>, and there is no special permissions check since the "
"directory is presumed secure. The location of the certificate and key files "
"can be overridden by the connection parameters <literal>sslcert</literal> "
"and <literal>sslkey</literal> or the environment variables <envar>PGSSLCERT</"
"envar> and <envar>PGSSLKEY</envar>."
msgstr ""
"Если сервер запрашивает доверенный клиентский сертификат, "
"<application>libpq</application> передаёт ему сертификат из файла "
"<filename>~/.postgresql/postgresql.crt</filename> в домашнем каталоге "
"пользователя. Этот сертификат должен быть подписан одним из центров "
"сертификации (<acronym>ЦС</acronym>), доверенным для сервера. Также должен "
"присутствовать закрытый ключ в файле <filename>~/.postgresql/postgresql.key</"
"filename>. Файл закрытого ключа не должен быть доступен всем или группе; "
"этого можно добиться командой <command>chmod 0600 ~/.postgresql/postgresql."
"key</command>. В Microsoft Windows эти файлы называются <filename>%APPDATA%"
"\\postgresql\\postgresql.crt</filename> и <filename>%APPDATA%\\postgresql"
"\\postgresql.key</filename>, и никакие специальные проверки не производятся, "
"так как предполагается, что этот каталог безопасен. Размещение файлов "
"сертификата и ключа можно переопределить параметрами соединения "
"<literal>sslcert</literal> и <literal>sslkey</literal>, либо переменными "
"окружения <envar>PGSSLCERT</envar> и <envar>PGSSLKEY</envar>, соответственно."

#: libpq.xml:7421(para)
msgid ""
"In some cases, the client certificate might be signed by an "
"<quote>intermediate</quote> certificate authority, rather than one that is "
"directly trusted by the server. To use such a certificate, append the "
"certificate of the signing authority to the <filename>postgresql.crt</"
"filename> file, then its parent authority's certificate, and so on up to a "
"certificate authority, <quote>root</quote> or <quote>intermediate</quote>, "
"that is trusted by the server, i.e. signed by a certificate in the server's "
"<filename>root.crt</filename> file."
msgstr ""
"В некоторых случаях сертификат клиента может подписываться "
"<quote>промежуточным</quote> центром сертификации, сам сертификат не "
"обязательно должен быть доверенным для сервера. Чтобы использовать такой "
"сертификат, нужно добавить в файл <filename>postgresql.crt</filename> "
"сертификат выдавшего его центра сертификации, затем сертификат вышестоящего "
"центра и так далее, до сертификата <quote>корневого</quote> или "
"<quote>промежуточного</quote> центра, которому доверяет сервер. Сервер "
"считает сертификат доверенным, если он подписан сертификатом, содержащимся в "
"его собственном файле <filename>root.crt</filename>."

#: libpq.xml:7432(para)
msgid ""
"Note that the client's <filename>~/.postgresql/root.crt</filename> lists the "
"top-level CAs that are considered trusted for signing server certificates. "
"In principle it need not list the CA that signed the client's certificate, "
"though in most cases that CA would also be trusted for server certificates."
msgstr ""
"Заметьте, что файл <filename>~/.postgresql/root.crt</filename> на клиенте "
"содержит сертификаты центров сертификации верхнего уровня, которые считаются "
"доверенными для подписания серверных сертификатов. В принципе в нём может "
"отсутствовать сертификат ЦС, подписавшего сертификат клиента, хотя в "
"большинстве случаев этот ЦС также будет доверенным для клиентских "
"сертификатов."

#: libpq.xml:7442(title)
msgid "Protection Provided in Different Modes"
msgstr "Защита, обеспечиваемая в различных режимах"

#: libpq.xml:7451(term)
msgid "Eavesdropping"
msgstr "Прослушивание"

#: libpq.xml:7453(para)
msgid ""
"If a third party can examine the network traffic between the client and the "
"server, it can read both connection information (including the user name and "
"password) and the data that is passed. <acronym>SSL</acronym> uses "
"encryption to prevent this."
msgstr ""
"Если третья сторона может прослушивать сетевой трафик между клиентом и "
"сервером, она может получить как информацию соединения (включая имя "
"пользователя и пароль), так и передаваемые данные. Чтобы защититься от "
"этого, <acronym>SSL</acronym> шифрует трафик."

#: libpq.xml:7462(term)
msgid "Man in the middle (<acronym>MITM</acronym>)"
msgstr "Посредник (<acronym>MITM</acronym>)"

#: libpq.xml:7464(para)
msgid ""
"If a third party can modify the data while passing between the client and "
"server, it can pretend to be the server and therefore see and modify data "
"<emphasis>even if it is encrypted</emphasis>. The third party can then "
"forward the connection information and data to the original server, making "
"it impossible to detect this attack. Common vectors to do this include DNS "
"poisoning and address hijacking, whereby the client is directed to a "
"different server than intended. There are also several other attack methods "
"that can accomplish this. <acronym>SSL</acronym> uses certificate "
"verification to prevent this, by authenticating the server to the client."
msgstr ""
"Если третья сторона может модифицировать данные, передаваемые между клиентом "
"и сервером, она может представиться сервером и, таким образом, сможет видеть "
"и модифицировать данные, <emphasis>даже если они зашифрованы</emphasis>. "
"Третья сторона затем может воспроизводить характеристики соединения и данные "
"для подлинного сервера, что сделает невозможным обнаружение этой атаки. "
"Векторами такой атаки может быть &laquo;отравление&raquo; DNS и подмена "
"адресов, в результате чего клиент будет обращаться не к тому серверу, к "
"которому нужно. Также есть несколько других вариантов реализации этой атаки. "
"Для защиты в <acronym>SSL</acronym> применяется проверка сертификатов, в "
"результате которой сервер доказывает свою подлинность клиенту."

#: libpq.xml:7478(term)
msgid "Impersonation"
msgstr "Олицетворение"

#: libpq.xml:7480(para)
msgid ""
"If a third party can pretend to be an authorized client, it can simply "
"access data it should not have access to. Typically this can happen through "
"insecure password management. <acronym>SSL</acronym> uses client "
"certificates to prevent this, by making sure that only holders of valid "
"certificates can access the server."
msgstr ""
"Если третья сторона может представляться авторизованным клиентом, она может "
"просто обращаться к данным, к которым не должна иметь доступа. Обычно это "
"происходит вследствие небезопасного управления паролями. В <acronym>SSL</"
"acronym> для предотвращения этой угрозы используются клиентские сертификаты, "
"гарантирующие, что к серверу могут обращаться только владельцы "
"действительных сертификатов."

#: libpq.xml:7444(para)
msgid ""
"The different values for the <literal>sslmode</literal> parameter provide "
"different levels of protection. SSL can provide protection against three "
"types of attacks: <placeholder-1/>"
msgstr ""
"Разные значения параметра <literal>sslmode</literal> обеспечивают разные "
"уровни защиты. SSL позволяет защититься от следующих типов атак: "
"<placeholder-1/>"

#: libpq.xml:7491(para)
msgid ""
"For a connection to be known secure, SSL usage must be configured on "
"<emphasis>both the client and the server</emphasis> before the connection is "
"made. If it is only configured on the server, the client may end up sending "
"sensitive information (e.g. passwords) before it knows that the server "
"requires high security. In libpq, secure connections can be ensured by "
"setting the <literal>sslmode</literal> parameter to <literal>verify-full</"
"literal> or <literal>verify-ca</literal>, and providing the system with a "
"root certificate to verify against. This is analogous to using an "
"<literal>https</literal> <acronym>URL</acronym> for encrypted web browsing."
msgstr ""
"Чтобы соединение было гарантированно безопасным, SSL должен быть настроен "
"<emphasis>на клиенте и на сервере</emphasis>, прежде чем будет установлено "
"соединение. Если он настроен только на сервере, клиент может начать "
"передавать важную информацию (например, пароли), до того как поймёт, что "
"сервер требует высокого уровня безопасности. В libpq для установления "
"безопасных соединений нужно задать для параметра <literal>sslmode</literal> "
"значение <literal>verify-full</literal> или <literal>verify-ca</literal> и "
"предоставить системе корневой сертификат для проверки. В качестве аналогии "
"можно привести использование адреса с <literal>https</literal> для "
"безопасного просмотра веб-содержимого."

#: libpq.xml:7504(para)
msgid ""
"Once the server has been authenticated, the client can pass sensitive data. "
"This means that up until this point, the client does not need to know if "
"certificates will be used for authentication, making it safe to specify that "
"only in the server configuration."
msgstr ""
"Когда подлинность сервера подтверждена, клиент может передавать "
"конфиденциальные данные. Это значит, что до этого момента клиенту не нужно "
"знать, применяются ли сертификаты для аутентификации, так что настройка "
"использования сертификатов только на стороне сервера не угрожает "
"безопасности."

#: libpq.xml:7511(para)
msgid ""
"All <acronym>SSL</acronym> options carry overhead in the form of encryption "
"and key-exchange, so there is a trade-off that has to be made between "
"performance and security. <xref linkend=\"libpq-ssl-sslmode-statements\"/> "
"illustrates the risks the different <literal>sslmode</literal> values "
"protect against, and what statement they make about security and overhead."
msgstr ""
"Все варианты использования <acronym>SSL</acronym> подразумевают издержки "
"шифрования и обмена ключами, что порождает необходимость выбора между "
"производительностью и безопасностью. В <xref remap=\"6\" linkend=\"libpq-ssl-"
"sslmode-statements\"/> описываются риски, от которых защищают различные "
"варианты <literal>sslmode</literal>, и приводятся утверждения относительно "
"защиты и издержек."

#: libpq.xml:7520(title)
msgid "SSL Mode Descriptions"
msgstr "Описания режимов SSL"

#: libpq.xml:7525(entry)
msgid "Eavesdropping protection"
msgstr "Защита от прослушивания"

#: libpq.xml:7526(entry)
msgid "<acronym>MITM</acronym> protection"
msgstr "Защита от <acronym>MITM</acronym>"

#: libpq.xml:7527(entry)
msgid "Statement"
msgstr "Утверждение"

#: libpq.xml:7534(entry) libpq.xml:7535(entry) libpq.xml:7544(entry)
#: libpq.xml:7553(entry) libpq.xml:7562(entry)
msgid "No"
msgstr "Нет"

#: libpq.xml:7536(entry)
msgid ""
"I don't care about security, and I don't want to pay the overhead of "
"encryption."
msgstr ""
"Мне не важна безопасность и я не приемлю издержки, связанные с шифрованием."

#: libpq.xml:7543(entry) libpq.xml:7552(entry)
msgid "Maybe"
msgstr "Возможно"

#: libpq.xml:7545(entry)
msgid ""
"I don't care about security, but I will pay the overhead of encryption if "
"the server insists on it."
msgstr ""
"Мне не важна безопасность, но я приемлю издержки, связанные с шифрованием, "
"если на этом настаивает сервер."

#: libpq.xml:7551(literal)
msgid "prefer"
msgstr "prefer"

#: libpq.xml:7554(entry)
msgid ""
"I don't care about encryption, but I wish to pay the overhead of encryption "
"if the server supports it."
msgstr ""
"Мне не важна безопасность, но я предпочитаю шифрование (и приемлю связанные "
"издержки), если это поддерживает сервер."

#: libpq.xml:7561(entry) libpq.xml:7570(entry) libpq.xml:7579(entry)
#: libpq.xml:7580(entry)
msgid "Yes"
msgstr "Да"

#: libpq.xml:7563(entry)
msgid ""
"I want my data to be encrypted, and I accept the overhead. I trust that the "
"network will make sure I always connect to the server I want."
msgstr ""
"Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. Я "
"доверяю сети в том, что она обеспечивает подключение к нужному серверу."

#: libpq.xml:7571(entry)
msgid "<literal>Depends on CA</literal>-policy"
msgstr "Зависит от политики <acronym>ЦС</acronym>"

#: libpq.xml:7572(entry)
msgid ""
"I want my data encrypted, and I accept the overhead. I want to be sure that "
"I connect to a server that I trust."
msgstr ""
"Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. "
"Мне нужна уверенность в том, что я подключаюсь к доверенному серверу."

#: libpq.xml:7581(entry)
msgid ""
"I want my data encrypted, and I accept the overhead. I want to be sure that "
"I connect to a server I trust, and that it's the one I specify."
msgstr ""
"Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. "
"Мне нужна уверенность в том, что я подключаюсь к доверенному серверу и это "
"именно указанный мной сервер."

#: libpq.xml:7591(para)
msgid ""
"The difference between <literal>verify-ca</literal> and <literal>verify-"
"full</literal> depends on the policy of the root <acronym>CA</acronym>. If a "
"public <acronym>CA</acronym> is used, <literal>verify-ca</literal> allows "
"connections to a server that <emphasis>somebody else</emphasis> may have "
"registered with the <acronym>CA</acronym>. In this case, <literal>verify-"
"full</literal> should always be used. If a local <acronym>CA</acronym> is "
"used, or even a self-signed certificate, using <literal>verify-ca</literal> "
"often provides enough protection."
msgstr ""
"Различие вариантов <literal>verify-ca</literal> и <literal>verify-full</"
"literal> зависит от характера корневого <acronym>ЦС</acronym>. Если "
"используется публичный <acronym>ЦС</acronym>, режим <literal>verify-ca</"
"literal> допускает подключение к серверу с сертификатом, который получил "
"<emphasis>кто угодно</emphasis> в этом <acronym>ЦС</acronym>. В такой "
"ситуации нужно всегда использовать режим <literal>verify-full</literal>. "
"Если же используется локальный <acronym>ЦС</acronym> или даже "
"самоподписанный сертификат, режим <literal>verify-ca</literal> обычно "
"обеспечивает достаточную защиту."

#: libpq.xml:7601(para)
msgid ""
"The default value for <literal>sslmode</literal> is <literal>prefer</"
"literal>. As is shown in the table, this makes no sense from a security "
"point of view, and it only promises performance overhead if possible. It is "
"only provided as the default for backward compatibility, and is not "
"recommended in secure deployments."
msgstr ""
"По умолчанию параметр <literal>sslmode</literal> имеет значение "
"<literal>prefer</literal>. Как показано в этой таблице, он не имеет большого "
"смысла с точки зрения безопасности, и даёт только выигрыш в "
"производительности, если это возможно. Он выбран по умолчанию для обратной "
"совместимости и не рекомендуется для защищённых окружений."

#: libpq.xml:7611(title)
msgid "SSL Client File Usage"
msgstr "Файлы, используемые клиентом SSL"

#: libpq.xml:7613(para)
msgid ""
"<xref linkend=\"libpq-ssl-file-usage\"/> summarizes the files that are "
"relevant to the SSL setup on the client."
msgstr ""
"В <xref remap=\"6\" linkend=\"libpq-ssl-file-usage\"/> перечислены файлы, "
"имеющие отношение к настройке SSL на стороне клиента."

#: libpq.xml:7619(title)
msgid "Libpq/Client SSL File Usage"
msgstr "Файлы, используемые клиентом SSL/libpq"

#: libpq.xml:7623(entry)
msgid "File"
msgstr "Файл"

#: libpq.xml:7624(entry)
msgid "Contents"
msgstr "Содержимое"

#: libpq.xml:7625(entry)
msgid "Effect"
msgstr "Назначение"

#: libpq.xml:7632(filename)
msgid "~/.postgresql/postgresql.crt"
msgstr "~/.postgresql/postgresql.crt"

#: libpq.xml:7633(entry)
msgid "client certificate"
msgstr "сертификат клиента"

#: libpq.xml:7634(entry)
msgid "requested by server"
msgstr "запрашивается сервером"

#: libpq.xml:7638(filename)
msgid "~/.postgresql/postgresql.key"
msgstr "~/.postgresql/postgresql.key"

#: libpq.xml:7639(entry)
msgid "client private key"
msgstr "закрытый ключ клиента"

#: libpq.xml:7640(entry)
msgid ""
"proves client certificate sent by owner; does not indicate certificate owner "
"is trustworthy"
msgstr ""
"подтверждает клиентский сертификат, передаваемый владельцем; не гарантирует, "
"что владелец сертификата заслуживает доверия"

#: libpq.xml:7645(filename)
msgid "~/.postgresql/root.crt"
msgstr "~/.postgresql/root.crt"

#: libpq.xml:7646(entry)
msgid "trusted certificate authorities"
msgstr "сертификаты доверенных ЦС"

#: libpq.xml:7647(entry)
msgid ""
"checks that server certificate is signed by a trusted certificate authority"
msgstr ""
"позволяет проверить, что сертификат сервера подписан доверенным центром "
"сертификации"

#: libpq.xml:7652(filename)
msgid "~/.postgresql/root.crl"
msgstr "~/.postgresql/root.crl"

#: libpq.xml:7653(entry)
msgid "certificates revoked by certificate authorities"
msgstr "сертификаты, отозванные центрами сертификации"

#: libpq.xml:7654(entry)
msgid "server certificate must not be on this list"
msgstr "сертификат сервера должен отсутствовать в этом списке"

#: libpq.xml:7663(title)
msgid "SSL Library Initialization"
msgstr "Инициализация библиотеки SSL"

#: libpq.xml:7665(para)
msgid ""
"If your application initializes <literal>libssl</literal> and/or "
"<literal>libcrypto</literal> libraries and <application>libpq</application> "
"is built with <acronym>SSL</acronym> support, you should call "
"<function>PQinitOpenSSL</function> to tell <application>libpq</application> "
"that the <literal>libssl</literal> and/or <literal>libcrypto</literal> "
"libraries have been initialized by your application, so that "
"<application>libpq</application> will not also initialize those libraries. "
"See <ulink url=\"http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html"
"\"/> for details on the SSL API."
msgstr ""
"Если ваше приложение инициализирует библиотеку <literal>libssl</literal> и/"
"или <literal>libcrypto</literal>, и <application>libpq</application> собрана "
"с поддержкой <acronym>SSL</acronym>, вы должны вызвать "
"<function>PQinitOpenSSL</function>, чтобы сообщить <application>libpq</"
"application>, что библиотека <literal>libssl</literal> и/или "
"<literal>libcrypto</literal> уже инициализированы вашим приложением, чтобы "
"<application>libpq</application> не пыталась ещё раз инициализировать их. "
"Более подробно API SSL описано на странице <ulink url=\"http://h71000.www7."
"hp.com/doc/83final/ba554_90007/ch04.html\"/>."

#: libpq.xml:7683(function)
msgid "PQinitOpenSSL"
msgstr "PQinitOpenSSL"

#: libpq.xml:7684(indexterm)
msgid "<primary>PQinitOpenSSL</primary>"
msgstr "<primary>PQinitOpenSSL</primary>"

#: libpq.xml:7690(para)
msgid ""
"Allows applications to select which security libraries to initialize. "
"<synopsis>\n"
"void PQinitOpenSSL(int do_ssl, int do_crypto);\n"
"</synopsis>"
msgstr ""
"Позволяет приложениям выбрать, какие библиотеки безопасности нужно "
"инициализировать. <synopsis>\n"
"void PQinitOpenSSL(int do_ssl, int do_crypto);\n"
"</synopsis>"

#: libpq.xml:7697(para)
msgid ""
"When <parameter>do_ssl</parameter> is non-zero, <application>libpq</"
"application> will initialize the <application>OpenSSL</application> library "
"before first opening a database connection. When <parameter>do_crypto</"
"parameter> is non-zero, the <literal>libcrypto</literal> library will be "
"initialized. By default (if <function>PQinitOpenSSL</function> is not "
"called), both libraries are initialized. When SSL support is not compiled "
"in, this function is present but does nothing."
msgstr ""
"Когда параметр <parameter>do_ssl</parameter> отличен от нуля, "
"<application>libpq</application> будет инициализировать библиотеку "
"<application>OpenSSL</application> перед первым подключением к базе данных. "
"Когда параметр <parameter>do_crypto</parameter> не равен нулю, будет "
"инициализироваться библиотека <literal>libcrypto</literal>. По умолчанию "
"(если функция <function>PQinitOpenSSL</function> не вызывается) "
"инициализируются обе библиотеки. Если поддержка SSL не была скомпилирована, "
"эта функция присутствует, но ничего не делает."

#: libpq.xml:7707(para)
msgid ""
"If your application uses and initializes either <application>OpenSSL</"
"application> or its underlying <literal>libcrypto</literal> library, you "
"<emphasis>must</emphasis> call this function with zeroes for the appropriate "
"parameter(s) before first opening a database connection. Also be sure that "
"you have done that initialization before opening a database connection."
msgstr ""
"Если ваше приложение использует и инициализирует библиотеку "
"<application>OpenSSL</application> или её нижележащую библиотеку "
"<literal>libcrypto</literal>, вы <emphasis>должны</emphasis> вызвать эту "
"функцию, передав нули в соответствующих параметрах, перед первым "
"подключением к базе данных. Собственно инициализацию также важно произвести "
"перед установлением подключения."

#: libpq.xml:7719(function)
msgid "PQinitSSL"
msgstr "PQinitSSL"

#: libpq.xml:7720(indexterm)
msgid "<primary>PQinitSSL</primary>"
msgstr "<primary>PQinitSSL</primary>"

#: libpq.xml:7726(para)
msgid ""
"Allows applications to select which security libraries to initialize. "
"<synopsis>\n"
"void PQinitSSL(int do_ssl);\n"
"</synopsis>"
msgstr ""
"Позволяет приложениям выбрать, какие библиотеки безопасности нужно "
"инициализировать. <synopsis>\n"
"void PQinitSSL(int do_ssl);\n"
"</synopsis>"

#: libpq.xml:7733(para)
msgid ""
"This function is equivalent to <literal>PQinitOpenSSL(do_ssl, do_ssl)</"
"literal>. It is sufficient for applications that initialize both or neither "
"of <application>OpenSSL</application> and <literal>libcrypto</literal>."
msgstr ""
"Эта функция равнозначна вызову <literal>PQinitOpenSSL(do_ssl, do_ssl)</"
"literal>. Приложениям достаточно инициализировать или не инициализировать "
"обе библиотеки <application>OpenSSL</application> и <literal>libcrypto</"
"literal> одновременно."

#: libpq.xml:7740(para)
msgid ""
"<function>PQinitSSL</function> has been present since "
"<productname>PostgreSQL</productname> 8.0, while <function>PQinitOpenSSL</"
"function> was added in <productname>PostgreSQL</productname> 8.4, so "
"<function>PQinitSSL</function> might be preferable for applications that "
"need to work with older versions of <application>libpq</application>."
msgstr ""
"Функция <function>PQinitSSL</function> существует со времён "
"<productname>PostgreSQL</productname> 8.0, тогда как "
"<function>PQinitOpenSSL</function> появилась в <productname>PostgreSQL</"
"productname> 8.4, так что <function>PQinitSSL</function> может быть "
"предпочтительней для приложений, которым нужно работать с более старыми "
"версиями <application>libpq</application>."

#: libpq.xml:7757(title)
msgid "Behavior in Threaded Programs"
msgstr "Поведение в многопоточных программах"

#: libpq.xml:7759(indexterm)
msgid "<primary>threads</primary> <secondary>with libpq</secondary>"
msgstr "<primary>потоки</primary> <secondary>с libpq</secondary>"

#: libpq.xml:7764(para)
msgid ""
"<application>libpq</application> is reentrant and thread-safe by default. "
"You might need to use special compiler command-line options when you compile "
"your application code. Refer to your system's documentation for information "
"about how to build thread-enabled applications, or look in <filename>src/"
"Makefile.global</filename> for <literal>PTHREAD_CFLAGS</literal> and "
"<literal>PTHREAD_LIBS</literal>. This function allows the querying of "
"<application>libpq</application>'s thread-safe status:"
msgstr ""
"Библиотека <application>libpq</application> по умолчанию поддерживает "
"повторные вызовы и многопоточность. Для соответствующего варианта сборки "
"вашего приложения вам может понадобиться передать компилятору специальные "
"параметры командной строки. Чтобы узнать, как собрать многопоточное "
"приложение, обратитесь к документации вашей системы или поищите в файле "
"<filename>src/Makefile.global</filename> значения <literal>PTHREAD_CFLAGS</"
"literal> и <literal>PTHREAD_LIBS</literal>. Эта функция позволяет узнать, "
"поддерживает ли <application>libpq</application> многопоточность:"

#: libpq.xml:7778(function)
msgid "PQisthreadsafe"
msgstr "PQisthreadsafe"

#: libpq.xml:7779(indexterm)
msgid "<primary>PQisthreadsafe</primary>"
msgstr "<primary>PQisthreadsafe</primary>"

#: libpq.xml:7785(para)
msgid ""
"Returns the thread safety status of the <application>libpq</application> "
"library. <synopsis>\n"
"int PQisthreadsafe();\n"
"</synopsis>"
msgstr ""
"Возвращает состояние потокобезопасности в библиотеке <application>libpq</"
"application>. <synopsis>\n"
"int PQisthreadsafe();\n"
"</synopsis>"

#: libpq.xml:7793(para)
msgid ""
"Returns 1 if the <application>libpq</application> is thread-safe and 0 if it "
"is not."
msgstr ""
"Возвращает 1, если библиотека <application>libpq</application> "
"потокобезопасная, или 0 в противном случае."

#: libpq.xml:7801(para)
msgid ""
"One thread restriction is that no two threads attempt to manipulate the same "
"<structname>PGconn</structname> object at the same time. In particular, you "
"cannot issue concurrent commands from different threads through the same "
"connection object. (If you need to run concurrent commands, use multiple "
"connections.)"
msgstr ""
"Реализация многопоточности не лишена ограничений: два потока не должны "
"пытаться одновременно работать с одним объектом <structname>PGconn</"
"structname>. В частности, не допускается параллельное выполнение команд из "
"разных потоков через один объект соединения. (Если вам нужно выполнять "
"команды одновременно, используйте несколько соединений.)"

#: libpq.xml:7809(para)
msgid ""
"<structname>PGresult</structname> objects are normally read-only after "
"creation, and so can be passed around freely between threads. However, if "
"you use any of the <structname>PGresult</structname>-modifying functions "
"described in <xref linkend=\"libpq-misc\"/> or <xref linkend=\"libpq-events"
"\"/>, it's up to you to avoid concurrent operations on the same "
"<structname>PGresult</structname>, too."
msgstr ""
"Объекты <structname>PGresult</structname> после создания обычно доступны "
"только для чтения, и поэтому их можно свободно передавать между потоками. "
"Однако, если вы используете какую-либо из функций, изменяющих "
"<structname>PGresult</structname>, описанных в <xref remap=\"6\" linkend="
"\"libpq-misc\"/> или <xref remap=\"6\" linkend=\"libpq-events\"/>, вы должны "
"также избегать одновременных обращений к одному объекту "
"<structname>PGresult</structname>."

#: libpq.xml:7818(para)
msgid ""
"The deprecated functions <function>PQrequestCancel</function> and "
"<function>PQoidStatus</function> are not thread-safe and should not be used "
"in multithread programs. <function>PQrequestCancel</function> can be "
"replaced by <function>PQcancel</function>. <function>PQoidStatus</function> "
"can be replaced by <function>PQoidValue</function>."
msgstr ""
"Устаревшие функции <function>PQrequestCancel</function> и "
"<function>PQoidStatus</function> не являются потокобезопасными и не должны "
"применяться в многопоточных программах. Вместо <function>PQrequestCancel</"
"function> можно использовать <function>PQcancel</function>, а вместо "
"<function>PQoidStatus</function> — <function>PQoidValue</function>."

#: libpq.xml:7827(para)
msgid ""
"If you are using Kerberos inside your application (in addition to inside "
"<application>libpq</application>), you will need to do locking around "
"Kerberos calls because Kerberos functions are not thread-safe. See function "
"<function>PQregisterThreadLock</function> in the <application>libpq</"
"application> source code for a way to do cooperative locking between "
"<application>libpq</application> and your application."
msgstr ""
"Если вы применяете Kerberos в своём приложении (помимо возможного "
"использования внутри <application>libpq</application>), вы должны обеспечить "
"блокировку вокруг вызовов Kerberos, так как функции Kerberos не являются "
"потокобезопасными. Обратите внимание на функцию "
"<function>PQregisterThreadLock</function> в исходном коде "
"<application>libpq</application>, позволяющую организовать совместные "
"блокировки между <application>libpq</application> и вашим приложением."

#: libpq.xml:7836(para)
msgid ""
"If you experience problems with threaded applications, run the program in "
"<filename>src/tools/thread</filename> to see if your platform has thread-"
"unsafe functions. This program is run by <filename>configure</filename>, but "
"for binary distributions your library might not match the library used to "
"build the binaries."
msgstr ""
"Если вы сталкиваетесь с проблемами многопоточности в приложениях, запустите "
"программу <filename>src/tools/thread</filename>, чтобы понять, есть ли в "
"вашей системе небезопасные при многопоточности функции. Эта программа "
"запускается скриптом <filename>configure</filename>, но если вы "
"устанавливаете двоичный пакет, ваши библиотеки могут не соответствовать тем, "
"что использовались при сборке."

#: libpq.xml:7847(title)
msgid "Building <application>libpq</application> Programs"
msgstr "Сборка программ с <application>libpq</application>"

#: libpq.xml:7849(indexterm)
msgid "<primary>compiling</primary> <secondary>libpq applications</secondary>"
msgstr ""
"<primary>компиляция</primary> <secondary>приложений с libpq</secondary>"

#: libpq.xml:7863(programlisting)
#, no-wrap
msgid "#include &lt;libpq-fe.h&gt;"
msgstr "#include &lt;libpq-fe.h&gt;"

#: libpq.xml:7861(para)
msgid ""
"Include the <filename>libpq-fe.h</filename> header file: <placeholder-1/> If "
"you failed to do that then you will normally get error messages from your "
"compiler similar to: <screen>\n"
"foo.c: In function `main':\n"
"foo.c:34: `PGconn' undeclared (first use in this function)\n"
"foo.c:35: `PGresult' undeclared (first use in this function)\n"
"foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)\n"
"foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)\n"
"foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)\n"
"</screen>"
msgstr ""
"Включите заголовочный файл <filename>libpq-fe.h</filename>: <placeholder-1/> "
"Если вы не сделаете этого, обычно вас ждут примерно такие сообщения об "
"ошибках от компилятора: <screen>\n"
"foo.c: In function `main':\n"
"foo.c:34: `PGconn' undeclared (first use in this function)\n"
"foo.c:35: `PGresult' undeclared (first use in this function)\n"
"foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)\n"
"foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)\n"
"foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)\n"
"</screen>"

#: libpq.xml:7888(programlisting)
#, no-wrap
msgid "cc -c -I/usr/local/pgsql/include testprog.c"
msgstr "cc -c -I/usr/local/pgsql/include testprog.c"

#: libpq.xml:7893(programlisting)
#, no-wrap
msgid "CPPFLAGS += -I/usr/local/pgsql/include"
msgstr "CPPFLAGS += -I/usr/local/pgsql/include"

#: libpq.xml:7880(para)
msgid ""
"Point your compiler to the directory where the <productname>PostgreSQL</"
"productname> header files were installed, by supplying the <literal>-"
"I<replaceable>directory</replaceable></literal> option to your compiler. (In "
"some cases the compiler will look into the directory in question by default, "
"so you can omit this option.) For instance, your compile command line could "
"look like: <placeholder-1/> If you are using makefiles then add the option "
"to the <varname>CPPFLAGS</varname> variable: <placeholder-2/>"
msgstr ""
"Сообщите вашему компилятору каталог, в котором установлены заголовочные "
"файлы <productname>PostgreSQL</productname>, передав ему параметр <literal>-"
"I<replaceable>каталог</replaceable></literal>. (В некоторых случаях "
"компилятор сам может обращаться к нужному каталогу, так что этот параметр "
"можно опустить.) Например, ваша команда компиляции может быть такой: "
"<placeholder-1/> Если вы используете скрипты сборки Makefile, добавьте этот "
"параметр в переменную <varname>CPPFLAGS</varname>: <placeholder-2/>"

#: libpq.xml:7902(indexterm)
msgid ""
"<primary>pg_config</primary><secondary sortas=\"libpq\">with libpq</"
"secondary>"
msgstr ""
"<primary>pg_config</primary> <secondary sortas=\"libpq\">с libpq</secondary>"

#: libpq.xml:7898(para)
msgid ""
"If there is any chance that your program might be compiled by other users "
"then you should not hardcode the directory location like that. Instead, you "
"can run the utility <command>pg_config</command><placeholder-1/> to find out "
"where the header files are on the local system: <screen>\n"
"<prompt>$</prompt> pg_config --includedir\n"
"<computeroutput>/usr/local/include</computeroutput>\n"
"</screen>"
msgstr ""
"Если существует возможность, что вашу программу будут компилировать другие "
"пользователи, то путь к каталогу не следует жёстко задавать таким образом. "
"Вместо этого вы можете воспользоваться утилитой <command>pg_config</"
"command><placeholder-1/> и узнать, где в локальной системе находятся "
"заголовочные файлы, следующим образом: <screen>\n"
"<prompt>$</prompt> pg_config --includedir\n"
"<computeroutput>/usr/local/include</computeroutput>\n"
"</screen>"

#: libpq.xml:7913(indexterm)
msgid ""
"<primary>pkg-config</primary><secondary sortas=\"libpq\">with libpq</"
"secondary>"
msgstr ""
"<primary>pkg-config</primary> <secondary sortas=\"libpq\">с libpq</secondary>"

#: libpq.xml:7911(para)
msgid ""
"If you have <command>pkg-config</command><placeholder-1/> installed, you can "
"run instead: <screen>\n"
"<prompt>$</prompt> pkg-config --cflags libpq\n"
"<computeroutput>-I/usr/local/include</computeroutput>\n"
"</screen> Note that this will already include the <option>-I</option> in "
"front of the path."
msgstr ""
"Если у вас установлена программа <command>pkg-config</command><placeholder-1/"
">, вместо этого вы можете выполнить: <screen>\n"
"<prompt>$</prompt> pkg-config --cflags libpq\n"
"<computeroutput>-I/usr/local/include</computeroutput>\n"
"</screen> Заметьте, что при этом перед путём сразу будет добавлен ключ "
"<option>-I</option>."

#: libpq.xml:7923(para)
msgid ""
"Failure to specify the correct option to the compiler will result in an "
"error message such as: <screen>\n"
"testlibpq.c:8:22: libpq-fe.h: No such file or directory\n"
"</screen>"
msgstr ""
"Если требуемый параметр не будет передан компилятору, вы получите примерно "
"такое сообщение об ошибке: <screen>\n"
"testlibpq.c:8:22: libpq-fe.h: No such file or directory\n"
"</screen>"

#: libpq.xml:7943(programlisting)
#, no-wrap
msgid "cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq"
msgstr "cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq"

#: libpq.xml:7933(para)
msgid ""
"When linking the final program, specify the option <literal>-lpq</literal> "
"so that the <application>libpq</application> library gets pulled in, as well "
"as the option <literal>-L<replaceable>directory</replaceable></literal> to "
"point the compiler to the directory where the <application>libpq</"
"application> library resides. (Again, the compiler will search some "
"directories by default.) For maximum portability, put the <option>-L</"
"option> option before the <option>-lpq</option> option. For example: "
"<placeholder-1/>"
msgstr ""
"При компоновке окончательной программы добавьте параметр <literal>-lpq</"
"literal>, чтобы была подключена библиотека <application>libpq</application>, "
"а также параметр <literal>-L<replaceable>каталог</replaceable></literal>, "
"указывающий на каталог, в котором находится <application>libpq</"
"application>. (Опять же, компилятор будет просматривать определённые "
"каталоги по умолчанию.) Для максимальной переносимости указывайте ключ "
"<option>-L</option> перед параметром <option>-lpq</option>. Например: "
"<placeholder-1/>"

#: libpq.xml:7948(para)
msgid ""
"You can find out the library directory using <command>pg_config</command> as "
"well: <screen>\n"
"<prompt>$</prompt> pg_config --libdir\n"
"<computeroutput>/usr/local/pgsql/lib</computeroutput>\n"
"</screen>"
msgstr ""
"Каталог с библиотекой можно узнать, так же используя <command>pg_config</"
"command>: <screen>\n"
"<prompt>$</prompt> pg_config --libdir\n"
"<computeroutput>/usr/local/pgsql/lib</computeroutput>\n"
"</screen>"

#: libpq.xml:7957(para)
msgid ""
"Or again use <command>pkg-config</command>: <screen>\n"
"<prompt>$</prompt> pkg-config --libs libpq\n"
"<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>\n"
"</screen> Note again that this prints the full options, not only the path."
msgstr ""
"Или с помощью той же программы <command>pkg-config</command>: <screen>\n"
"<prompt>$</prompt> pkg-config --libs libpq\n"
"<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>\n"
"</screen> Заметьте, что и в этом случае выводится полностью сформированный "
"параметр, а не только путь."

#: libpq.xml:7966(para)
msgid ""
"Error messages that point to problems in this area could look like the "
"following: <screen>\n"
"testlibpq.o: In function `main':\n"
"testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'\n"
"testlibpq.o(.text+0x71): undefined reference to `PQstatus'\n"
"testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'\n"
"</screen> This means you forgot <option>-lpq</option>. <screen>\n"
"/usr/bin/ld: cannot find -lpq\n"
"</screen> This means you forgot the <option>-L</option> option or did not "
"specify the right directory."
msgstr ""
"В случае проблем в этой области возможны примерно такие сообщения об "
"ошибках: <screen>\n"
"testlibpq.o: In function `main':\n"
"testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'\n"
"testlibpq.o(.text+0x71): undefined reference to `PQstatus'\n"
"testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'\n"
"</screen> Они означают, что вы забыли добавить параметр <option>-lpq</"
"option>. <screen>\n"
"/usr/bin/ld: cannot find -lpq\n"
"</screen> Такая ошибка означает, что вы забыли добавить ключ <option>-L</"
"option> или не указали правильный каталог."

#: libpq.xml:7854(para)
msgid ""
"To build (i.e., compile and link) a program using <application>libpq</"
"application> you need to do all of the following things: <placeholder-1/>"
msgstr ""
"Чтобы собрать (то есть, скомпилировать и скомпоновать) программу, "
"использующую <application>libpq</application>, вы должны проделать следующие "
"действия: <placeholder-1/>"

#: libpq.xml:7990(title)
msgid "Example Programs"
msgstr "Примеры программ"

#: libpq.xml:7992(para)
msgid ""
"These examples and others can be found in the directory <filename>src/test/"
"examples</filename> in the source code distribution."
msgstr ""
"Эти и другие примеры можно найти в каталоге <filename>src/test/examples</"
"filename> в дистрибутиве исходного кода."

#: libpq.xml:7999(title)
msgid "<application>libpq</application> Example Program 1"
msgstr ""
"Первая программа, демонстрирующая использование <application>libpq</"
"application>"

#: libpq.xml:8126(title)
msgid "<application>libpq</application> Example Program 2"
msgstr ""
"Вторая программа, демонстрирующая использование <application>libpq</"
"application>"

#: libpq.xml:8269(title)
msgid "<application>libpq</application> Example Program 3"
msgstr ""
"Третья программа, демонстрирующая использование <application>libpq</"
"application>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: libpq.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid "<primary><envar>PGREALM</envar></primary>"
#~ msgstr "<primary><envar>PGREALM</envar></primary>"

#~ msgid ""
#~ "<placeholder-1/> <envar>PGREALM</envar> sets the Kerberos realm to use "
#~ "with <productname>PostgreSQL</productname>, if it is different from the "
#~ "local realm. If <envar>PGREALM</envar> is set, <application>libpq</"
#~ "application> applications will attempt authentication with servers for "
#~ "this realm and use separate ticket files to avoid conflicts with local "
#~ "ticket files. This environment variable is only used if GSSAPI "
#~ "authentication is selected by the server."
#~ msgstr ""
#~ "<placeholder-1/> <envar>PGREALM</envar> задаёт область Kerberos для "
#~ "<productname>PostgreSQL</productname>, если она отличается от локальной "
#~ "области. Если значение <envar>PGREALM</envar> установлено, приложения "
#~ "<application>libpq</application> будут аутентифицироваться на серверах, "
#~ "указывая эту область, и использовать отдельные файлы билетов во избежание "
#~ "конфликтов с локальными билетами. Эта переменная окружения используется, "
#~ "только если на сервере настроена проверка подлинности GSSAPI."

#~ msgid ""
#~ "<placeholder-1/> <envar>PGREQUIRESSL</envar> behaves the same as the "
#~ "<xref linkend=\"libpq-connect-requiressl\"/> connection parameter."
#~ msgstr ""
#~ "<placeholder-1/> <envar>PGREQUIRESSL</envar> действует так же, как "
#~ "параметр соединения <xref linkend=\"libpq-connect-requiressl\"/>."
