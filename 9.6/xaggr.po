# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-02-06 11:19+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: xaggr.xml:5(title)
msgid "User-defined Aggregates"
msgstr "Пользовательские агрегатные функции"

#: xaggr.xml:7(indexterm)
msgid ""
"<primary>aggregate function</primary> <secondary>user-defined</secondary>"
msgstr ""
"<primary>агрегатная функция</primary> <secondary>пользовательская</secondary>"

#: xaggr.xml:12(para)
msgid ""
"Aggregate functions in <productname>PostgreSQL</productname> are defined in "
"terms of <firstterm>state values</firstterm> and <firstterm>state transition "
"functions</firstterm>. That is, an aggregate operates using a state value "
"that is updated as each successive input row is processed. To define a new "
"aggregate function, one selects a data type for the state value, an initial "
"value for the state, and a state transition function. The state transition "
"function takes the previous state value and the aggregate's input value(s) "
"for the current row, and returns a new state value. A <firstterm>final "
"function</firstterm> can also be specified, in case the desired result of "
"the aggregate is different from the data that needs to be kept in the "
"running state value. The final function takes the ending state value and "
"returns whatever is wanted as the aggregate result. In principle, the "
"transition and final functions are just ordinary functions that could also "
"be used outside the context of the aggregate. (In practice, it's often "
"helpful for performance reasons to create specialized transition functions "
"that can only work when called as part of an aggregate.)"
msgstr ""
"Агрегатные функции в <productname>PostgreSQL</productname> определяются в "
"терминах <firstterm>значений состояния</firstterm> и <firstterm>функций "
"перехода состояния</firstterm>. То есть агрегатная функция работает со "
"значением состояния, которое меняется при обработке каждой последующей "
"строки. Чтобы определить агрегатную функцию, нужно выбрать тип данных для "
"значения состояния, начальное значение состояния и функцию перехода "
"состояния. Функция перехода состояния принимает предыдущее значение "
"состояния и входное агрегируемое значение для текущей строки и возвращает "
"новое значение состояния. Также можно указать <firstterm>функцию завершения</"
"firstterm>, на случай, если ожидаемый результат агрегатной функции "
"отличается от данных, которые сохраняются в изменяющемся значении состояния. "
"Функция завершения принимает конечное значение состояния и возвращает то, "
"что она хочет вернуть в виде результата агрегирования. В принципе, функции "
"перехода и завершения представляют собой просто обычные функции, которые "
"также могут применяться вне контекста агрегирования. (На практике для "
"большей производительности часто создаются специализированные функции "
"перехода, которые работают, только когда вызываются при агрегировании.)"

#: xaggr.xml:36(para)
msgid ""
"Thus, in addition to the argument and result data types seen by a user of "
"the aggregate, there is an internal state-value data type that might be "
"different from both the argument and result types."
msgstr ""
"Таким образом, помимо типов данных аргументов и результата, с которыми имеет "
"дело пользователь агрегатной функции, есть также тип данных внутреннего "
"состояния, который может отличаться от этих типов."

#: xaggr.xml:53(programlisting)
#, no-wrap
msgid ""
"CREATE AGGREGATE sum (complex)\n"
"(\n"
"    sfunc = complex_add,\n"
"    stype = complex,\n"
"    initcond = '(0,0)'\n"
");"
msgstr ""
"CREATE AGGREGATE sum (complex)\n"
"(\n"
"    sfunc = complex_add,\n"
"    stype = complex,\n"
"    initcond = '(0,0)'\n"
");"

#: xaggr.xml:64(programlisting)
#, no-wrap
msgid ""
"SELECT sum(a) FROM test_complex;\n"
"\n"
"   sum\n"
"-----------\n"
" (34,53.9)"
msgstr ""
"SELECT sum(a) FROM test_complex;\n"
"\n"
"   sum\n"
"-----------\n"
" (34,53.9)"

#: xaggr.xml:42(para)
msgid ""
"If we define an aggregate that does not use a final function, we have an "
"aggregate that computes a running function of the column values from each "
"row. <function>sum</function> is an example of this kind of aggregate. "
"<function>sum</function> starts at zero and always adds the current row's "
"value to its running total. For example, if we want to make a <function>sum</"
"function> aggregate to work on a data type for complex numbers, we only need "
"the addition function for that data type. The aggregate definition would be: "
"<placeholder-1/> which we might use like this: <placeholder-2/> (Notice that "
"we are relying on function overloading: there is more than one aggregate "
"named <function>sum</function>, but <productname>PostgreSQL</productname> "
"can figure out which kind of sum applies to a column of type <type>complex</"
"type>.)"
msgstr ""
"Если мы определяем агрегат, не использующий функцию завершения, наш агрегат "
"будет вычислять бегущее значение функции по столбцам каждой строки. Примером "
"такой агрегатной функции является <function>sum</function>. Вычисление "
"<function>sum</function> начинается с нуля, а затем к накапливаемой сумме "
"всегда прибавляется значение из текущей строки. Например, если мы хотим "
"сделать агрегатную функцию <function>sum</function> для комплексных чисел, "
"нам потребуется только функция сложения для такого типа данных. Такая "
"агрегатная функция может быть определена так: <placeholder-1/> Использовать "
"её можно будет так: <placeholder-2/> (Заметьте, что мы задействуем "
"перегрузку функций: в системе есть несколько агрегатных функций с именем "
"<function>sum</function>, но <productname>PostgreSQL</productname> может "
"определить, какая именно из них применима к столбцу типа <type>complex</"
"type>.)"

#: xaggr.xml:78(para)
msgid ""
"The above definition of <function>sum</function> will return zero (the "
"initial state value) if there are no nonnull input values. Perhaps we want "
"to return null in that case instead &mdash; the SQL standard expects "
"<function>sum</function> to behave that way. We can do this simply by "
"omitting the <literal>initcond</literal> phrase, so that the initial state "
"value is null. Ordinarily this would mean that the <literal>sfunc</literal> "
"would need to check for a null state-value input. But for <function>sum</"
"function> and some other simple aggregates like <function>max</function> and "
"<function>min</function>, it is sufficient to insert the first nonnull input "
"value into the state variable and then start applying the transition "
"function at the second nonnull input value. <productname>PostgreSQL</"
"productname> will do that automatically if the initial state value is null "
"and the transition function is marked <quote>strict</quote> (i.e., not to be "
"called for null inputs)."
msgstr ""
"Определённая выше функция <function>sum</function> вернёт ноль (начальное "
"значение состояния), если в наборе данных не окажется значений, отличных от "
"NULL. У нас может возникнуть желание вернуть NULL в этом случае &mdash; "
"стандарт SQL требует, чтобы <function>sum</function> работала так. Мы можем "
"добиться этого, просто опустив фразу <literal>initcond</literal>, так что "
"начальным значением состояния будет NULL. Обычно это будет означать, что в "
"<literal>sfunc</literal> придётся проверять входное значение состояния на "
"NULL. Но для <function>sum</function> и некоторых других простых агрегатных "
"функций, как <function>max</function> и <function>min</function>, достаточно "
"вставить в переменную состояния первое входное значение не NULL, а затем "
"начать применять функцию перехода со следующего значения не NULL. "
"<productname>PostgreSQL</productname> сделает это автоматически, если "
"начальное значение состояние равно NULL и функция перехода помечена как "
"<quote>strict</quote> (то есть не должна вызываться для аргументов NULL)."

#: xaggr.xml:96(para)
msgid ""
"Another bit of default behavior for a <quote>strict</quote> transition "
"function is that the previous state value is retained unchanged whenever a "
"null input value is encountered. Thus, null values are ignored. If you need "
"some other behavior for null inputs, do not declare your transition function "
"as strict; instead code it to test for null inputs and do whatever is needed."
msgstr ""
"Ещё одна особенность поведения по умолчанию <quote>строгой</quote> функции "
"перехода — предыдущее значение состояния остаётся без изменений, когда "
"встречается значение NULL. Другими словами, значения NULL игнорируются. Если "
"вам нужно другое поведение для входных значений NULL, не объявляйте свою "
"функцию перехода строгой (strict); вместо этого, проверьте в ней поступающие "
"значения на NULL и обработайте их, как требуется."

#: xaggr.xml:115(programlisting)
#, no-wrap
msgid ""
"CREATE AGGREGATE avg (float8)\n"
"(\n"
"    sfunc = float8_accum,\n"
"    stype = float8[],\n"
"    finalfunc = float8_avg,\n"
"    initcond = '{0,0,0}'\n"
");"
msgstr ""
"CREATE AGGREGATE avg (float8)\n"
"(\n"
"    sfunc = float8_accum,\n"
"    stype = float8[],\n"
"    finalfunc = float8_avg,\n"
"    initcond = '{0,0,0}'\n"
");"

#: xaggr.xml:105(para)
msgid ""
"<function>avg</function> (average) is a more complex example of an "
"aggregate. It requires two pieces of running state: the sum of the inputs "
"and the count of the number of inputs. The final result is obtained by "
"dividing these quantities. Average is typically implemented by using an "
"array as the state value. For example, the built-in implementation of "
"<function>avg(float8)</function> looks like: <placeholder-1/>"
msgstr ""
"Функция <function>avg</function> (вычисляющая среднее арифметическое) "
"представляет собой более сложный пример агрегатной функции. Ей необходимы "
"два компонента текущего состояния: сумма входных значений и их количество. "
"Окончательный результат получается как частное этих величин. При реализации "
"этой функции для значения состояния обычно используется массив. Например, "
"встроенная реализация <function>avg(float8)</function> выглядит так: "
"<placeholder-1/>"

#: xaggr.xml:127(para)
msgid ""
"<function>float8_accum</function> requires a three-element array, not just "
"two elements, because it accumulates the sum of squares as well as the sum "
"and count of the inputs. This is so that it can be used for some other "
"aggregates as well as <function>avg</function>."
msgstr ""
"Функция <function>float8_accum</function> принимает массив из трёх, а не "
"двух элементов, так как в дополнение к количеству и сумме значений она "
"подсчитывает ещё сумму их квадратов. Это сделано для того, чтобы её можно "
"было применять для <function>avg</function> и для некоторых других "
"агрегатных функций."

#: xaggr.xml:135(para)
msgid ""
"Aggregate function calls in SQL allow <literal>DISTINCT</literal> and "
"<literal>ORDER BY</literal> options that control which rows are fed to the "
"aggregate's transition function and in what order. These options are "
"implemented behind the scenes and are not the concern of the aggregate's "
"support functions."
msgstr ""
"Вызовы агрегатных функций SQL допускают указания <literal>DISTINCT</literal> "
"и <literal>ORDER BY</literal>, которые определяют, какие строки и в каком "
"порядке будут поступать в функцию перехода агрегата. Это реализовано на "
"заднем плане и непосредственно не затрагивает функции, поддерживающие работу "
"агрегата."

#: xaggr.xml:143(para)
msgid ""
"For further details see the <xref linkend=\"sql-createaggregate\"/> command."
msgstr ""
"За дополнительными подробностями обратитесь к описанию <xref linkend=\"sql-"
"createaggregate\"/>."

#: xaggr.xml:150(title)
msgid "Moving-Aggregate Mode"
msgstr "Режим движущегося агрегата"

#: xaggr.xml:152(indexterm)
msgid "<primary>moving-aggregate mode</primary>"
msgstr "<primary>режим движущегося агрегата</primary>"

#: xaggr.xml:156(indexterm)
msgid ""
"<primary>aggregate function</primary> <secondary>moving aggregate</secondary>"
msgstr ""
"<primary>агрегатная функция</primary> <secondary>движущийся агрегат</"
"secondary>"

#: xaggr.xml:161(para)
msgid ""
"Aggregate functions can optionally support <firstterm>moving-aggregate mode</"
"firstterm>, which allows substantially faster execution of aggregate "
"functions within windows with moving frame starting points. (See <xref "
"linkend=\"tutorial-window\"/> and <xref linkend=\"syntax-window-functions\"/"
"> for information about use of aggregate functions as window functions.) The "
"basic idea is that in addition to a normal <quote>forward</quote> transition "
"function, the aggregate provides an <firstterm>inverse transition function</"
"firstterm>, which allows rows to be removed from the aggregate's running "
"state value when they exit the window frame. For example a <function>sum</"
"function> aggregate, which uses addition as the forward transition function, "
"would use subtraction as the inverse transition function. Without an inverse "
"transition function, the window function mechanism must recalculate the "
"aggregate from scratch each time the frame starting point moves, resulting "
"in run time proportional to the number of input rows times the average frame "
"length. With an inverse transition function, the run time is only "
"proportional to the number of input rows."
msgstr ""
"Агрегатные функции могут дополнительно поддерживать <firstterm>режим "
"движущегося агрегата</firstterm>, который позволяет значительно быстрее "
"выполнять агрегатные функции в окнах со сдвигающимся началом рамки. (За "
"информацией об использовании агрегатных функций в качестве оконных "
"обратитесь к <xref remap=\"3\" linkend=\"tutorial-window\"/> и <xref remap="
"\"3\" linkend=\"syntax-window-functions\"/>.) Основная идея состоит в том, "
"что помимо добавления обычной функции перехода <quote>вперёд</quote>, для "
"агрегатной функции задаётся <firstterm>функция обратного перехода</"
"firstterm>, которая позволяет убирать строки из накапливаемого значения "
"состояния, когда они покидают рамку окна. Например, для <function>sum</"
"function> в качестве функции прямого перехода выполняется сложение, а в "
"качестве функции обратного перехода выполняется вычитание. Без функции "
"обратного перехода механизм оконных функций вынужден вычислять агрегат "
"заново при каждом перемещении начала рамки, в результате чего время "
"обработки оказывается пропорциональным количеству входных строк, "
"помноженному на средний размер рамки. С функцией обратного перехода это "
"время пропорционально только количеству входных строк."

#: xaggr.xml:182(para)
msgid ""
"The inverse transition function is passed the current state value and the "
"aggregate input value(s) for the earliest row included in the current state. "
"It must reconstruct what the state value would have been if the given input "
"row had never been aggregated, but only the rows following it. This "
"sometimes requires that the forward transition function keep more state than "
"is needed for plain aggregation mode. Therefore, the moving-aggregate mode "
"uses a completely separate implementation from the plain mode: it has its "
"own state data type, its own forward transition function, and its own final "
"function if needed. These can be the same as the plain mode's data type and "
"functions, if there is no need for extra state."
msgstr ""
"Функции обратного перехода передаётся текущее значение состояния и "
"агрегируемое входное значение(я) для строки, ранее учтённой в текущем "
"состоянии. Она должна восстановить то значение состояния, которое было бы "
"получено, если бы эта строка не агрегировалась, но агрегировались все "
"последующие. Иногда для этого нужно, чтобы функция обратного перехода "
"сохраняла больше информации о состоянии, чем это требуется для простого "
"режима агрегирования. Таким образом, для режима движущегося агрегата "
"используется реализация, отличная от простого режима: для него определяется "
"отдельный тип данных, отдельная функция прямого перехода и отдельная функция "
"завершения, при необходимости. Они могут совпадать с типом данных и "
"аналогичными функциями обычного режима, если в дополнительном состоянии "
"необходимости нет."

#: xaggr.xml:200(programlisting)
#, no-wrap
msgid ""
"CREATE AGGREGATE sum (complex)\n"
"(\n"
"    sfunc = complex_add,\n"
"    stype = complex,\n"
"    initcond = '(0,0)',\n"
"    msfunc = complex_add,\n"
"    minvfunc = complex_sub,\n"
"    mstype = complex,\n"
"    minitcond = '(0,0)'\n"
");"
msgstr ""
"CREATE AGGREGATE sum (complex)\n"
"(\n"
"    sfunc = complex_add,\n"
"    stype = complex,\n"
"    initcond = '(0,0)',\n"
"    msfunc = complex_add,\n"
"    minvfunc = complex_sub,\n"
"    mstype = complex,\n"
"    minitcond = '(0,0)'\n"
");"

#: xaggr.xml:196(para)
msgid ""
"As an example, we could extend the <function>sum</function> aggregate given "
"above to support moving-aggregate mode like this: <placeholder-1/> The "
"parameters whose names begin with <literal>m</literal> define the moving-"
"aggregate implementation. Except for the inverse transition function "
"<literal>minvfunc</literal>, they correspond to the plain-aggregate "
"parameters without <literal>m</literal>."
msgstr ""
"В качестве примера мы можем доработать показанную выше агрегатную функцию "
"<function>sum</function>, чтобы она поддерживала режим движущегося агрегата "
"так: <placeholder-1/> Параметры, имена которых начинаются с <literal>m</"
"literal>, определяют реализацию для движущегося агрегата. За исключением "
"функции обратного перехода, <literal>minvfunc</literal>, они соответствуют "
"параметрам обычного агрегата без <literal>m</literal>."

#: xaggr.xml:219(para)
msgid ""
"The forward transition function for moving-aggregate mode is not allowed to "
"return null as the new state value. If the inverse transition function "
"returns null, this is taken as an indication that the inverse function "
"cannot reverse the state calculation for this particular input, and so the "
"aggregate calculation will be redone from scratch for the current frame "
"starting position. This convention allows moving-aggregate mode to be used "
"in situations where there are some infrequent cases that are impractical to "
"reverse out of the running state value. The inverse transition function can "
"<quote>punt</quote> on these cases, and yet still come out ahead so long as "
"it can work for most cases. As an example, an aggregate working with "
"floating-point numbers might choose to punt when a <literal>NaN</literal> "
"(not a number) input has to be removed from the running state value."
msgstr ""
"Функции прямого перехода в режиме движущегося агрегата не разрешено "
"возвращать NULL в качестве нового значения состояния. Если функция обратного "
"перехода возвращает NULL, это воспринимается как признак того, что она не "
"может восстановить предыдущее состояние для полученных данных, и значит, "
"агрегатное вычисление нужно производить заново с текущей позиции начала "
"рамки. Это соглашение позволяет применять режим движущегося агрегата и в "
"ситуациях, когда прокручивать назад значение состояния непрактично. Функция "
"обратного перехода может <quote>спасовать</quote> в таких случаях, но "
"включаться в работу, насколько это возможно в большинстве случаев. Например, "
"агрегатная функция, работающая с числами с плавающей точкой, может "
"спасовать, когда от неё потребуется убрать значение <literal>NaN</literal> "
"(не число, not a number) из текущего значения состояния."

#: xaggr.xml:245(programlisting)
#, no-wrap
msgid ""
"CREATE AGGREGATE unsafe_sum (float8)\n"
"(\n"
"    stype = float8,\n"
"    sfunc = float8pl,\n"
"    mstype = float8,\n"
"    msfunc = float8pl,\n"
"    minvfunc = float8mi\n"
");"
msgstr ""
"CREATE AGGREGATE unsafe_sum (float8)\n"
"(\n"
"    stype = float8,\n"
"    sfunc = float8pl,\n"
"    mstype = float8,\n"
"    msfunc = float8pl,\n"
"    minvfunc = float8mi\n"
");"

#: xaggr.xml:259(programlisting)
#, no-wrap
msgid ""
"SELECT\n"
"  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)\n"
"FROM (VALUES (1, 1.0e20::float8),\n"
"             (2, 1.0::float8)) AS v (n,x);"
msgstr ""
"SELECT\n"
"  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)\n"
"FROM (VALUES (1, 1.0e20::float8),\n"
"             (2, 1.0::float8)) AS v (n,x);"

#: xaggr.xml:235(para)
msgid ""
"When writing moving-aggregate support functions, it is important to be sure "
"that the inverse transition function can reconstruct the correct state value "
"exactly. Otherwise there might be user-visible differences in results "
"depending on whether the moving-aggregate mode is used. An example of an "
"aggregate for which adding an inverse transition function seems easy at "
"first, yet where this requirement cannot be met is <function>sum</function> "
"over <type>float4</type> or <type>float8</type> inputs. A naive declaration "
"of <function>sum(<type>float8</type>)</function> could be <placeholder-1/> "
"This aggregate, however, can give wildly different results than it would "
"have without the inverse transition function. For example, consider "
"<placeholder-2/> This query returns <literal>0</literal> as its second "
"result, rather than the expected answer of <literal>1</literal>. The cause "
"is the limited precision of floating-point values: adding <literal>1</"
"literal> to <literal>1e20</literal> results in <literal>1e20</literal> "
"again, and so subtracting <literal>1e20</literal> from that yields "
"<literal>0</literal>, not <literal>1</literal>. Note that this is a "
"limitation of floating-point arithmetic in general, not a limitation of "
"<productname>PostgreSQL</productname>."
msgstr ""
"Разрабатывая функции, реализующие режим движущегося агрегата, важно, чтобы "
"функция обратного перехода могла восстановить в точности требуемое значение "
"состояния. В противном случае, в результатах могут проявляться различия, в "
"зависимости от того, использовался ли режим движущегося агрегата. Например, "
"на первый взгляд может показаться, что легко добавить функцию обратного "
"перехода для сложения, но заявленное требование не будет выполняться для "
"<function>sum</function> с типом <type>float4</type> или <type>float8</"
"type>. Наивное объявление <function>sum(<type>float8</type>)</function> "
"может быть таким: <placeholder-1/> Однако такой агрегат может выдавать "
"результаты, радикально отличающиеся от тех, что он выдавал бы без функции "
"обратного перехода. Например, рассмотрите запрос <placeholder-2/> Он "
"возвращает <literal>0</literal> в качестве второго результата, а не "
"ожидаемое значение <literal>1</literal>. Это связано с ограниченной "
"точностью значений с плавающей точкой: при добавлении <literal>1</literal> к "
"<literal>1e20</literal> снова получается <literal>1e20</literal>, а при "
"вычитании <literal>1e20</literal> из результата получается <literal>0</"
"literal>, а не <literal>1</literal>. Заметьте, что это принципиальное "
"ограничение арифметики чисел с плавающей точкой, а не недостаток "
"<productname>PostgreSQL</productname>."

#: xaggr.xml:278(title)
msgid "Polymorphic and Variadic Aggregates"
msgstr "Агрегатные функции с полиморфными и переменными аргументами"

#: xaggr.xml:280(indexterm)
msgid ""
"<primary>aggregate function</primary> <secondary>polymorphic</secondary>"
msgstr ""
"<primary>агрегатная функция</primary> <secondary>полиморфная</secondary>"

#: xaggr.xml:285(indexterm)
msgid "<primary>aggregate function</primary> <secondary>variadic</secondary>"
msgstr ""
"<primary>агрегатная функция</primary> <secondary>с переменными аргументами</"
"secondary>"

#: xaggr.xml:301(programlisting)
#, no-wrap
msgid ""
"CREATE AGGREGATE array_accum (anyelement)\n"
"(\n"
"    sfunc = array_append,\n"
"    stype = anyarray,\n"
"    initcond = '{}'\n"
");"
msgstr ""
"CREATE AGGREGATE array_accum (anyelement)\n"
"(\n"
"    sfunc = array_append,\n"
"    stype = anyarray,\n"
"    initcond = '{}'\n"
");"

#: xaggr.xml:290(para)
msgid ""
"Aggregate functions can use polymorphic state transition functions or final "
"functions, so that the same functions can be used to implement multiple "
"aggregates. See <xref linkend=\"extend-types-polymorphic\"/> for an "
"explanation of polymorphic functions. Going a step further, the aggregate "
"function itself can be specified with polymorphic input type(s) and state "
"type, allowing a single aggregate definition to serve for multiple input "
"data types. Here is an example of a polymorphic aggregate: <placeholder-1/> "
"Here, the actual state type for any given aggregate call is the array type "
"having the actual input type as elements. The behavior of the aggregate is "
"to concatenate all the inputs into an array of that type. (Note: the built-"
"in aggregate <function>array_agg</function> provides similar functionality, "
"with better performance than this definition would have.)"
msgstr ""
"Агрегатная функция может использовать полиморфные функции перехода состояния "
"или функции завершения, так что эти функции могут применяться для реализации "
"нескольких агрегатов. За объяснением полиморфных функций обратитесь к <xref "
"remap=\"3\" linkend=\"extend-types-polymorphic\"/>. Более того, сама "
"агрегатная функция может описываться с полиморфными типами входных данных и "
"состояния, так что одно определение агрегатной функции может служить для "
"использования с разными типами данных. Пример полиморфного агрегата: "
"<placeholder-1/> Здесь фактическим типом состояния для любого конкретного "
"агрегатного вызова будет массив, элементы которого будут иметь тип входных "
"данных. Действие данного агрегата заключается в накоплении всех входных "
"значений в массиве этого типа. (К вашему сведению: встроенная агрегатная "
"функция <function>array_agg</function> обеспечивает подобную "
"функциональность, но работает быстрее, чем могла бы функция с приведённым "
"определением.)"

#: xaggr.xml:320(programlisting)
#, no-wrap
msgid ""
"SELECT attrelid::regclass, array_accum(attname)\n"
"    FROM pg_attribute\n"
"    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass\n"
"    GROUP BY attrelid;\n"
"\n"
"   attrelid    |              array_accum              \n"
"---------------+---------------------------------------\n"
" pg_tablespace | {spcname,spcowner,spcacl,spcoptions}\n"
"(1 row)\n"
"\n"
"SELECT attrelid::regclass, array_accum(atttypid::regtype)\n"
"    FROM pg_attribute\n"
"    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass\n"
"    GROUP BY attrelid;\n"
"\n"
"   attrelid    |        array_accum        \n"
"---------------+---------------------------\n"
" pg_tablespace | {name,oid,aclitem[],text[]}\n"
"(1 row)"
msgstr ""
"SELECT attrelid::regclass, array_accum(attname)\n"
"    FROM pg_attribute\n"
"    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass\n"
"    GROUP BY attrelid;\n"
"\n"
"   attrelid    |              array_accum              \n"
"---------------+---------------------------------------\n"
" pg_tablespace | {spcname,spcowner,spcacl,spcoptions}\n"
"(1 row)\n"
"\n"
"SELECT attrelid::regclass, array_accum(atttypid::regtype)\n"
"    FROM pg_attribute\n"
"    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass\n"
"    GROUP BY attrelid;\n"
"\n"
"   attrelid    |        array_accum        \n"
"---------------+---------------------------\n"
" pg_tablespace | {name,oid,aclitem[],text[]}\n"
"(1 row)"

#: xaggr.xml:317(para)
msgid ""
"Here's the output using two different actual data types as arguments: "
"<placeholder-1/>"
msgstr ""
"Так будут выглядеть результаты с аргументами двух различных типов: "
"<placeholder-1/>"

#: xaggr.xml:362(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION array_agg_transfn(internal, anynonarray)\n"
"  RETURNS internal ...;\n"
"CREATE FUNCTION array_agg_finalfn(internal, anynonarray)\n"
"  RETURNS anyarray ...;\n"
"\n"
"CREATE AGGREGATE array_agg (anynonarray)\n"
"(\n"
"    sfunc = array_agg_transfn,\n"
"    stype = internal,\n"
"    finalfunc = array_agg_finalfn,\n"
"    finalfunc_extra\n"
");"
msgstr ""
"CREATE FUNCTION array_agg_transfn(internal, anynonarray)\n"
"  RETURNS internal ...;\n"
"CREATE FUNCTION array_agg_finalfn(internal, anynonarray)\n"
"  RETURNS anyarray ...;\n"
"\n"
"CREATE AGGREGATE array_agg (anynonarray)\n"
"(\n"
"    sfunc = array_agg_transfn,\n"
"    stype = internal,\n"
"    finalfunc = array_agg_finalfn,\n"
"    finalfunc_extra\n"
");"

#: xaggr.xml:343(para)
msgid ""
"Ordinarily, an aggregate function with a polymorphic result type has a "
"polymorphic state type, as in the above example. This is necessary because "
"otherwise the final function cannot be declared sensibly: it would need to "
"have a polymorphic result type but no polymorphic argument type, which "
"<command>CREATE FUNCTION</command> will reject on the grounds that the "
"result type cannot be deduced from a call. But sometimes it is inconvenient "
"to use a polymorphic state type. The most common case is where the aggregate "
"support functions are to be written in C and the state type should be "
"declared as <type>internal</type> because there is no SQL-level equivalent "
"for it. To address this case, it is possible to declare the final function "
"as taking extra <quote>dummy</quote> arguments that match the input "
"arguments of the aggregate. Such dummy arguments are always passed as null "
"values since no specific value is available when the final function is "
"called. Their only use is to allow a polymorphic final function's result "
"type to be connected to the aggregate's input type(s). For example, the "
"definition of the built-in aggregate <function>array_agg</function> is "
"equivalent to <placeholder-1/> Here, the <literal>finalfunc_extra</literal> "
"option specifies that the final function receives, in addition to the state "
"value, extra dummy argument(s) corresponding to the aggregate's input "
"argument(s). The extra <type>anynonarray</type> argument allows the "
"declaration of <function>array_agg_finalfn</function> to be valid."
msgstr ""
"Обычно агрегатная функция с полиморфным типом результата имеет и полиморфный "
"тип состояния, как в предыдущем примере. Это необходимо, так как иначе "
"нельзя будет объявить функцию завершения: она должна будет иметь полиморфный "
"тип результата, но не будет иметь полиморфного аргумента, что команда "
"<command>CREATE FUNCTION</command> не примет на основании того, что тип "
"результата нельзя будет определить при вызове. Но иметь полиморфный тип "
"состояния не всегда удобно. Чаще всего эта проблема возникает, когда функции "
"реализации агрегата пишутся на C и тип состояния должен объявляться как "
"<type>internal</type>, так как для него нет соответствующего типа на уровне "
"SQL. Чтобы решить эту проблему, можно объявить функцию завершения как "
"принимающую дополнительные фиктивные аргументы, соответствующие входным "
"аргументам агрегата. В этих фиктивных аргументах всегда передаются значения "
"NULL, так как при вызове функции завершения какое-либо определённое значение "
"отсутствует. Единственное их предназначение — позволить связать тип "
"результата полиморфной функции завершения с типом входных данных агрегата. "
"Например, определение встроенного агрегата <function>array_agg</function> "
"выглядит так: <placeholder-1/> Здесь параметр <literal>finalfunc_extra</"
"literal> указывает, что функция завершения помимо значения состояния получит "
"дополнительные фиктивные аргументы, соответствующие входным аргументам "
"агрегата. Дополнительный аргумент <type>anynonarray</type> позволяет сделать "
"объявление <function>array_agg_finalfn</function> допустимым."

#: xaggr.xml:384(para)
msgid ""
"An aggregate function can be made to accept a varying number of arguments by "
"declaring its last argument as a <literal>VARIADIC</literal> array, in much "
"the same fashion as for regular functions; see <xref linkend=\"xfunc-sql-"
"variadic-functions\"/>. The aggregate's transition function(s) must have the "
"same array type as their last argument. The transition function(s) typically "
"would also be marked <literal>VARIADIC</literal>, but this is not strictly "
"required."
msgstr ""
"Агрегатную функцию можно сделать принимающей переменное число аргументов, "
"объявив её последний аргумент как массив <literal>VARIADIC</literal>, в том "
"же ключе, как и обычную функцию; см. <xref remap=\"4\" linkend=\"xfunc-sql-"
"variadic-functions\"/>. При этом у функций перехода агрегата их последний "
"аргумент должен иметь тот же тип массива. Такие функции обычно также "
"объявляются как <literal>VARIADIC</literal>, но строго это не требуется."

#: xaggr.xml:402(programlisting)
#, no-wrap
msgid "SELECT myaggregate(a ORDER BY a, b, c) FROM ..."
msgstr "SELECT myaggregate(a ORDER BY a, b, c) FROM ..."

#: xaggr.xml:407(programlisting)
#, no-wrap
msgid "SELECT myaggregate(a, b, c ORDER BY a) FROM ..."
msgstr "SELECT myaggregate(a, b, c ORDER BY a) FROM ..."

#: xaggr.xml:395(para)
msgid ""
"Variadic aggregates are easily misused in connection with the <literal>ORDER "
"BY</literal> option (see <xref linkend=\"syntax-aggregates\"/>), since the "
"parser cannot tell whether the wrong number of actual arguments have been "
"given in such a combination. Keep in mind that everything to the right of "
"<literal>ORDER BY</literal> is a sort key, not an argument to the aggregate. "
"For example, in <placeholder-1/> the parser will see this as a single "
"aggregate function argument and three sort keys. However, the user might "
"have intended <placeholder-2/> If <literal>myaggregate</literal> is "
"variadic, both these calls could be perfectly valid."
msgstr ""
"Агрегатные функции с переменными аргументами легко допускают ошибочное "
"использование в сочетании с указанием <literal>ORDER BY</literal> (см. <xref "
"remap=\"4\" linkend=\"syntax-aggregates\"/>), так как анализатор запроса не "
"может определить, было ли передано нужное количество фактических параметров "
"в такой комбинации. Помните, что всё, находящееся справа от <literal>ORDER "
"BY</literal>, является ключом сортировки, а не аргументом агрегатной "
"функции. Например, в <placeholder-1/> анализатор запроса увидит один "
"агрегатный аргумент функции и три ключа сортировки. Однако пользователь мог "
"подразумевать и следующее: <placeholder-2/> Если функция "
"<literal>myaggregate</literal> принимает переменные аргументы, оба эти "
"вызова будут вполне допустимы."

#: xaggr.xml:414(para)
msgid ""
"For the same reason, it's wise to think twice before creating aggregate "
"functions with the same names and different numbers of regular arguments."
msgstr ""
"По этой же причине, стоит подумать дважды, прежде чем создавать агрегатные "
"функции с одинаковыми именами, но разным числом обычных аргументов."

#: xaggr.xml:423(title)
msgid "Ordered-Set Aggregates"
msgstr "Сортирующие агрегатные функции"

#: xaggr.xml:425(indexterm)
msgid ""
"<primary>aggregate function</primary> <secondary>ordered set</secondary>"
msgstr ""
"<primary>агрегатная функция</primary> <secondary>сортирующая</secondary>"

#: xaggr.xml:445(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION ordered_set_transition(internal, anyelement)\n"
"  RETURNS internal ...;\n"
"CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)\n"
"  RETURNS anyelement ...;\n"
"\n"
"CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)\n"
"(\n"
"    sfunc = ordered_set_transition,\n"
"    stype = internal,\n"
"    finalfunc = percentile_disc_final,\n"
"    finalfunc_extra\n"
");"
msgstr ""
"CREATE FUNCTION ordered_set_transition(internal, anyelement)\n"
"  RETURNS internal ...;\n"
"CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)\n"
"  RETURNS anyelement ...;\n"
"\n"
"CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)\n"
"(\n"
"    sfunc = ordered_set_transition,\n"
"    stype = internal,\n"
"    finalfunc = percentile_disc_final,\n"
"    finalfunc_extra\n"
");"

#: xaggr.xml:464(programlisting)
#, no-wrap
msgid ""
"SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;\n"
" percentile_disc\n"
"-----------------\n"
"           50489"
msgstr ""
"SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;\n"
" percentile_disc\n"
"-----------------\n"
"           50489"

#: xaggr.xml:430(para)
msgid ""
"The aggregates we have been describing so far are <quote>normal</quote> "
"aggregates. <productname>PostgreSQL</productname> also supports "
"<firstterm>ordered-set aggregates</firstterm>, which differ from normal "
"aggregates in two key ways. First, in addition to ordinary aggregated "
"arguments that are evaluated once per input row, an ordered-set aggregate "
"can have <quote>direct</quote> arguments that are evaluated only once per "
"aggregation operation. Second, the syntax for the ordinary aggregated "
"arguments specifies a sort ordering for them explicitly. An ordered-set "
"aggregate is usually used to implement a computation that depends on a "
"specific row ordering, for instance rank or percentile, so that the sort "
"ordering is a required aspect of any call. For example, the built-in "
"definition of <function>percentile_disc</function> is equivalent to: "
"<placeholder-1/> This aggregate takes a <type>float8</type> direct argument "
"(the percentile fraction) and an aggregated input that can be of any "
"sortable data type. It could be used to obtain a median household income "
"like this: <placeholder-2/> Here, <literal>0.5</literal> is a direct "
"argument; it would make no sense for the percentile fraction to be a value "
"varying across rows."
msgstr ""
"Описанные выше агрегатные функции были <quote>обычными</quote> агрегатами. "
"Но <productname>PostgreSQL</productname> также поддерживает "
"<firstterm>сортирующие агрегатные функции</firstterm>, которые имеют два "
"отличия от обычных. Во-первых, в дополнение к обычным агрегируемым "
"аргументам, вычисляемых для каждой входной строки, сортирующий агрегат может "
"иметь <quote>непосредственные</quote> аргументы, которые должны вычисляться "
"в операции агрегирования только один раз. Во-вторых, для обычных "
"агрегируемых аргументов порядок их сортировки задаётся явно, а сортирующий "
"агрегат обычно выполняет вычисления, зависящие от конкретного порядка строк, "
"например, вычисляет ранг или процентиль, так что порядок сортировки критичен "
"для каждого вызова. Например, встроенное определение функции "
"<function>percentile_disc</function> равнозначно следующему: <placeholder-1/"
"> Этот агрегат принимает непосредственный аргумент <type>float8</type> "
"(дробь процентиля) и агрегируемые данные, которые могут быть любого "
"упорядочиваемого типа. Используя его, можно рассчитать средний семейный "
"доход следующим образом: <placeholder-2/> В данном случае, <literal>0.5</"
"literal> — это непосредственный аргумент; если бы дробь процентиля менялась "
"от строки к строке, это не имело бы смысла."

#: xaggr.xml:475(para)
msgid ""
"Unlike the case for normal aggregates, the sorting of input rows for an "
"ordered-set aggregate is <emphasis>not</emphasis> done behind the scenes, "
"but is the responsibility of the aggregate's support functions. The typical "
"implementation approach is to keep a reference to a <quote>tuplesort</quote> "
"object in the aggregate's state value, feed the incoming rows into that "
"object, and then complete the sorting and read out the data in the final "
"function. This design allows the final function to perform special "
"operations such as injecting additional <quote>hypothetical</quote> rows "
"into the data to be sorted. While normal aggregates can often be implemented "
"with support functions written in <application>PL/pgSQL</application> or "
"another PL language, ordered-set aggregates generally have to be written in "
"C, since their state values aren't definable as any SQL data type. (In the "
"above example, notice that the state value is declared as type "
"<type>internal</type> &mdash; this is typical.)"
msgstr ""
"В отличие от случая с обычными агрегатами, сортировка входных строк для "
"сортирующего агрегата <emphasis>не</emphasis> выполняется на заднем плане, а "
"является задачей функций, реализующих агрегат. Обычный подход к такой "
"реализации заключается в сохранении ссылки на объект <quote>tuplesort</"
"quote> в значении состояния агрегата, загрузке поступающих строк в этот "
"объект, и собственно завершении сортировки и обработки данных в функции "
"завершения. Такая конструкция позволяет функции завершения выполнять "
"специальные операции, в частности, вставлять дополнительные "
"<quote>гипотетические</quote> строки в сортируемые данные. Тогда как обычные "
"агрегаты часто реализуются функциями, написанными на <application>PL/pgSQL</"
"application> или другом процедурном языке, сортирующие агрегатные функции "
"обычно должны быть написаны на C, так как их значение состояния нельзя "
"выразить каким-либо типом данных SQL. (Обратите внимание, что в приведённом "
"выше примере значение состояния объявлено как имеющее тип <type>internal</"
"type> &mdash; это типичный вариант.)"

#: xaggr.xml:493(para)
msgid ""
"The state transition function for an ordered-set aggregate receives the "
"current state value plus the aggregated input values for each row, and "
"returns the updated state value. This is the same definition as for normal "
"aggregates, but note that the direct arguments (if any) are not provided. "
"The final function receives the last state value, the values of the direct "
"arguments if any, and (if <literal>finalfunc_extra</literal> is specified) "
"null values corresponding to the aggregated input(s). As with normal "
"aggregates, <literal>finalfunc_extra</literal> is only really useful if the "
"aggregate is polymorphic; then the extra dummy argument(s) are needed to "
"connect the final function's result type to the aggregate's input type(s)."
msgstr ""
"Функция перехода состояния для сортирующего агрегата получает значение "
"текущего состояния плюс агрегируемые входные данные для каждой строки и "
"возвращает изменённое значение состояния. Это определение распространяется и "
"на обычные агрегаты, но заметьте, что непосредственные аргументы (если они "
"есть) при этом не передаются. Функция завершения же получает последнее "
"значение состояния и значения непосредственных аргументов (если они есть), а "
"также (если присутствует указание <literal>finalfunc_extra</literal>) "
"значения NULL, соответствующие агрегируемым данным. С обычными агрегатами "
"указание <literal>finalfunc_extra</literal> действительно полезно, только "
"если агрегат полиморфный; тогда дополнительные фиктивные аргументы "
"необходимы, чтобы связать тип результата функции завершения с типом(ами) "
"входных данных агрегата."

#: xaggr.xml:508(para)
msgid ""
"Currently, ordered-set aggregates cannot be used as window functions, and "
"therefore there is no need for them to support moving-aggregate mode."
msgstr ""
"В настоящее время сортирующие агрегаты не могут использоваться в качестве "
"оконных функций, поэтому от них поддержка режима движущегося агрегата не "
"требуется."

#: xaggr.xml:516(title)
msgid "Partial Aggregation"
msgstr "Частичное агрегирование"

#: xaggr.xml:518(indexterm)
msgid ""
"<primary>aggregate function</primary> <secondary>partial aggregation</"
"secondary>"
msgstr ""
"<primary>агрегатная функция</primary> <secondary>частичное агрегирования</"
"secondary>"

#: xaggr.xml:523(para)
msgid ""
"Optionally, an aggregate function can support <firstterm>partial "
"aggregation</firstterm>. The idea of partial aggregation is to run the "
"aggregate's state transition function over different subsets of the input "
"data independently, and then to combine the state values resulting from "
"those subsets to produce the same state value that would have resulted from "
"scanning all the input in a single operation. This mode can be used for "
"parallel aggregation by having different worker processes scan different "
"portions of a table. Each worker produces a partial state value, and at the "
"end those state values are combined to produce a final state value. (In the "
"future this mode might also be used for purposes such as combining "
"aggregations over local and remote tables; but that is not implemented yet.)"
msgstr ""
"Дополнительно агрегатная функция может поддерживать <firstterm>частичное "
"агрегирование</firstterm>. Идея такого агрегирования в том, чтобы вызывать "
"функции перехода состояния для различных подмножеств входных данных "
"независимо, а затем комбинировать значения состояния, вычисленные по этим "
"подмножествам, и получать тот же результат, что был бы получен при "
"сканировании сразу всех входных данных. Этот режим может применяться для "
"параллельного агрегирования, когда разные рабочие процессы сканируют "
"различные части таблицы. При этом каждый рабочий процесс выдаёт частичное "
"значение состояния, а в конце эти значения комбинируются вместе и получается "
"окончательное значение состояния. (В будущем этот режим может также "
"применяться, например для комбинированного агрегирования локальных и "
"удалённых таблиц, но пока это не реализовано.)"

#: xaggr.xml:538(para)
msgid ""
"To support partial aggregation, the aggregate definition must provide a "
"<firstterm>combine function</firstterm>, which takes two values of the "
"aggregate's state type (representing the results of aggregating over two "
"subsets of the input rows) and produces a new value of the state type, "
"representing what the state would have been after aggregating over the "
"combination of those sets of rows. It is unspecified what the relative order "
"of the input rows from the two sets would have been. This means that it's "
"usually impossible to define a useful combine function for aggregates that "
"are sensitive to input row order."
msgstr ""
"Для поддержки частичного агрегирования в определении агрегатной функции "
"должна задаваться <firstterm>комбинирующая функция</firstterm>, принимающая "
"два значения типа состояния агрегата (представляющие результаты "
"агрегирования по двум подмножествам входных строк) и выдающая новое значение "
"типа состояния, представляющее то состояние, которое было бы получено при "
"агрегировании совокупности этих подмножеств строк. При этом относительный "
"порядок входных строк в этих двух множествах не оговаривается. Это значит, "
"что для агрегатных функций, зависящих от порядка входных строк, обычно "
"невозможно определить осмысленную комбинирующую функцию."

#: xaggr.xml:550(para)
msgid ""
"As simple examples, <literal>MAX</literal> and <literal>MIN</literal> "
"aggregates can be made to support partial aggregation by specifying the "
"combine function as the same greater-of-two or lesser-of-two comparison "
"function that is used as their transition function. <literal>SUM</literal> "
"aggregates just need an addition function as combine function. (Again, this "
"is the same as their transition function, unless the state value is wider "
"than the input data type.)"
msgstr ""
"В качестве простого примера, частичное агрегирование могут поддерживать "
"функции <literal>MAX</literal> и <literal>MIN</literal>, если задать в "
"качестве комбинирующей соответственно функцию сравнения значений большее-из-"
"двух или меньшее-из-двух, ту же, что они используют и как функцию перехода. "
"Для <literal>SUM</literal> комбинирующей функцией будет просто функция "
"сложения. (И это опять же функция перехода, если только значение состояния "
"не выходит за рамки типа входных данных.)"

#: xaggr.xml:560(para)
msgid ""
"The combine function is treated much like a transition function that happens "
"to take a value of the state type, not of the underlying input type, as its "
"second argument. In particular, the rules for dealing with null values and "
"strict functions are similar. Also, if the aggregate definition specifies a "
"non-null <literal>initcond</literal>, keep in mind that that will be used "
"not only as the initial state for each partial aggregation run, but also as "
"the initial state for the combine function, which will be called to combine "
"each partial result into that state."
msgstr ""
"Комбинирующая функция задействуется практически так же, как функция "
"перехода, но принимает в качестве второго аргумента значение типа состояния, "
"а не нижележащего входного типа. В частности, на неё распространяются те же "
"правила строгости функции и передачи значений NULL. Также учтите, что если в "
"определении агрегатной функции задаётся отличное от NULL значение "
"<literal>initcond</literal>, оно будет задавать начальное состояние не "
"только для каждого прохода частичного агрегирования, но также и начальное "
"состояние для комбинирующей функции, которая будет вызываться для "
"комбинирования каждого частичного результата в этом состоянии."

#: xaggr.xml:571(para)
msgid ""
"If the aggregate's state type is declared as <type>internal</type>, it is "
"the combine function's responsibility that its result is allocated in the "
"correct memory context for aggregate state values. This means in particular "
"that when the first input is <literal>NULL</literal> it's invalid to simply "
"return the second input, as that value will be in the wrong context and will "
"not have sufficient lifespan."
msgstr ""
"Если типом состояния агрегатной функции выбран <type>internal</type>, "
"комбинирующая функция отвечает за то, чтобы её результат был помещён в "
"контекст памяти, подходящий для значений агрегатного состояния. В частности "
"это значит, что, получив в первом аргументе <literal>NULL</literal>, нельзя "
"просто возвратить второй аргумент, так как это значение окажется в неверном "
"контексте и не просуществует достаточное время."

#: xaggr.xml:580(para)
msgid ""
"When the aggregate's state type is declared as <type>internal</type>, it is "
"usually also appropriate for the aggregate definition to provide a "
"<firstterm>serialization function</firstterm> and a "
"<firstterm>deserialization function</firstterm>, which allow such a state "
"value to be copied from one process to another. Without these functions, "
"parallel aggregation cannot be performed, and future applications such as "
"local/remote aggregation will probably not work either."
msgstr ""
"Когда типом состояния агрегатной функции выбран <type>internal</type>, "
"обычно в определении агрегатной функции также уместно задать "
"<firstterm>функцию сериализации</firstterm> и <firstterm>функцию "
"десериализации</firstterm>, которые позволяют копировать значение состояния "
"из одного процесса в другой. Без этих функций параллельное агрегирование "
"невозможно, а также вероятно не будут работать такие будущие приложения, как "
"локальное/удалённое агрегирование."

#: xaggr.xml:590(para)
msgid ""
"A serialization function must take a single argument of type <type>internal</"
"type> and return a result of type <type>bytea</type>, which represents the "
"state value packaged up into a flat blob of bytes. Conversely, a "
"deserialization function reverses that conversion. It must take two "
"arguments of types <type>bytea</type> and <type>internal</type>, and return "
"a result of type <type>internal</type>. (The second argument is unused and "
"is always zero, but it is required for type-safety reasons.) The result of "
"the deserialization function should simply be allocated in the current "
"memory context, as unlike the combine function's result, it is not long-"
"lived."
msgstr ""
"Функция сериализации должна принимать один аргумент типа <type>internal</"
"type> и возвращать результат типа <type>bytea</type>, представляющий "
"значение состояния, упакованное в плоский набор байтов. Функция "
"десериализации, напротив, обращает это преобразование. Она должна принимать "
"два аргумента типов <type>bytea</type> и <type>internal</type> и возвращать "
"результат типа <type>internal</type>. (Второй её аргумент не используется и "
"всегда равен нулю, но он требуется из соображений типобезопасности.) "
"Результат функции десериализации следует просто разместить в текущем "
"контексте памяти, так как в отличие от результата комбинирующей функции он "
"недолговечен."

#: xaggr.xml:603(para)
msgid ""
"Worth noting also is that for an aggregate to be executed in parallel, the "
"aggregate itself must be marked <literal>PARALLEL SAFE</literal>. The "
"parallel-safety markings on its support functions are not consulted."
msgstr ""
"Также стоит заметить, что для выполнения агрегатной функции в параллельном "
"режиме она должна иметь характеристику <literal>PARALLEL SAFE</literal> "
"(безопасная для распараллеливания). Характеристики допустимости "
"распараллеливания её опорных функций значения не имеют."

#: xaggr.xml:612(title)
msgid "Support Functions for Aggregates"
msgstr "Вспомогательные функции для агрегатов"

#: xaggr.xml:614(indexterm)
msgid ""
"<primary>aggregate function</primary> <secondary>support functions for</"
"secondary>"
msgstr ""
"<primary>агрегатная функция</primary> <secondary>вспомогательные функции</"
"secondary>"

#: xaggr.xml:623(programlisting)
#, no-wrap
msgid "if (AggCheckCallContext(fcinfo, NULL))"
msgstr "if (AggCheckCallContext(fcinfo, NULL))"

#: xaggr.xml:619(para)
msgid ""
"A function written in C can detect that it is being called as an aggregate "
"support function by calling <function>AggCheckCallContext</function>, for "
"example: <placeholder-1/> One reason for checking this is that when it is "
"true for a transition function, the first input must be a temporary state "
"value and can therefore safely be modified in-place rather than allocating a "
"new copy. See <function>int8inc()</function> for an example. (This is the "
"<emphasis>only</emphasis> case where it is safe for a function to modify a "
"pass-by-reference input. In particular, final functions for normal "
"aggregates must not modify their inputs in any case, because in some cases "
"they will be re-executed on the same final state value.)"
msgstr ""
"Функция, написанная на C, может определить, была ли она вызвана как "
"вспомогательная функция агрегирования, вызвав <function>AggCheckCallContext</"
"function>, например, так: <placeholder-1/> Смысл такой проверки в том, что "
"для функции перехода (когда эта функция возвращает true) первым входным "
"аргументом является временное значение состояния, которое можно безопасно "
"модифицировать на месте, не создавая новую копию. Пример вы можете увидеть в "
"функции <function>int8inc()</function>. (Это <emphasis>единственный</"
"emphasis> случай, когда функция может безопасно изменять входные данные, "
"передаваемые по ссылке. В частности, функции завершения для обычных "
"агрегатов не должны изменять входные данные ни в коем случае, так как в "
"некоторых ситуациях они могут вызываться повторно с тем же конечным "
"значением состояния.)"

#: xaggr.xml:638(para)
msgid ""
"The second argument of <function>AggCheckCallContext</function> can be used "
"to retrieve the memory context in which aggregate state values are being "
"kept. This is useful for transition functions that wish to use "
"<quote>expanded</quote> objects (see <xref linkend=\"xtypes-toast\"/>) as "
"their state values. On first call, the transition function should return an "
"expanded object whose memory context is a child of the aggregate state "
"context, and then keep returning the same expanded object on subsequent "
"calls. See <function>array_append()</function> for an example. "
"(<function>array_append()</function> is not the transition function of any "
"built-in aggregate, but it is written to behave efficiently when used as "
"transition function of a custom aggregate.)"
msgstr ""
"Второй аргумент <function>AggCheckCallContext</function> можно использовать, "
"чтобы получить контекст памяти, в котором содержатся значения агрегатного "
"состояния. Это полезно для функций перехода, которые желают использовать "
"<quote>развёрнутые</quote> объёкты (см. <xref remap=\"4\" linkend=\"xtypes-"
"toast\"/>) в качестве значений состояния. При первом вызове такая функция "
"перехода должна возвратить развёрнутый объект в контексте памяти, "
"относящемся к контексту состояния агрегата, а затем продолжать возвращать "
"тот же объект при последующих вызовах. Например, эту логику можно увидеть в "
"функции <function>array_append()</function>. (Функция "
"<function>array_append()</function> не используется в качестве перехода "
"никаким встроенным агрегатом, но она написана так, чтобы работать эффективно "
"в таком качестве в дополнительном агрегате.)"

#: xaggr.xml:652(para)
msgid ""
"Another support routine available to aggregate functions written in C is "
"<function>AggGetAggref</function>, which returns the <literal>Aggref</"
"literal> parse node that defines the aggregate call. This is mainly useful "
"for ordered-set aggregates, which can inspect the substructure of the "
"<literal>Aggref</literal> node to find out what sort ordering they are "
"supposed to implement. Examples can be found in <filename>orderedsetaggs.c</"
"filename> in the <productname>PostgreSQL</productname> source code."
msgstr ""
"Ещё одна вспомогательная подпрограмма, предназначенная для агрегатных "
"функций, написанных на C, называется <function>AggGetAggref</function>. Эта "
"функция возвращает узел разбора <literal>Aggref</literal>, описывающий вызов "
"агрегата. Это в основном полезно для сортирующих агрегатов, которые могут "
"исследовать структуру узла <literal>Aggref</literal> и выяснить, какой "
"порядок сортировки они должны реализовать. Примеры использования можно найти "
"в <filename>orderedsetaggs.c</filename> в исходном коде "
"<productname>PostgreSQL</productname>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xaggr.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
