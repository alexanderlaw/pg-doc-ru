# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-02-06 11:19+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: xfunc.xml:5(title)
msgid "User-defined Functions"
msgstr "Пользовательские функции"

#: xfunc.xml:7(indexterm)
msgid "<primary>function</primary> <secondary>user-defined</secondary>"
msgstr ""
"<primary>функция</primary> <secondary>определяемая пользователем</secondary>"

#: xfunc.xml:18(para)
msgid ""
"query language functions (functions written in <acronym>SQL</acronym>) "
"(<xref linkend=\"xfunc-sql\"/>)"
msgstr ""
"функции на языке запросов (функции, написанные на <acronym>SQL</acronym>) "
"(<xref linkend=\"xfunc-sql\"/>)"

#: xfunc.xml:24(para)
msgid ""
"procedural language functions (functions written in, for example, "
"<application>PL/pgSQL</application> or <application>PL/Tcl</application>) "
"(<xref linkend=\"xfunc-pl\"/>)"
msgstr ""
"функции на процедурных языках (функции, написанные, например, на "
"<application>PL/pgSQL</application> или <application>PL/Tcl</application>) "
"(<xref linkend=\"xfunc-pl\"/>)"

#: xfunc.xml:31(para)
msgid "internal functions (<xref linkend=\"xfunc-internal\"/>)"
msgstr "внутренние функции (<xref linkend=\"xfunc-internal\"/>)"

#: xfunc.xml:36(para)
msgid "C-language functions (<xref linkend=\"xfunc-c\"/>)"
msgstr "функции на языке C (<xref linkend=\"xfunc-c\"/>)"

#: xfunc.xml:12(para)
msgid ""
"<productname>PostgreSQL</productname> provides four kinds of functions: "
"<placeholder-1/>"
msgstr ""
"В <productname>PostgreSQL</productname> представлены функции четырёх видов: "
"<placeholder-1/>"

#: xfunc.xml:43(para)
msgid ""
"Every kind of function can take base types, composite types, or combinations "
"of these as arguments (parameters). In addition, every kind of function can "
"return a base type or a composite type. Functions can also be defined to "
"return sets of base or composite values."
msgstr ""
"Функции любых видов могут принимать в качестве аргументов (параметров) "
"базовые типы, составные типы или их сочетания. Кроме того, любые функции "
"могут возвращать значения базового или составного типа. Также можно "
"определить функции, возвращающие наборы базовых или составных значений."

#: xfunc.xml:52(para)
msgid ""
"Many kinds of functions can take or return certain pseudo-types (such as "
"polymorphic types), but the available facilities vary. Consult the "
"description of each kind of function for more details."
msgstr ""
"Функции многих видов могут также принимать или возвращать определённые "
"псевдотипы (например, полиморфные типы), но доступные средства для работы с "
"ними различаются. За подробностями обратитесь к описанию конкретного вида "
"функций."

#: xfunc.xml:58(para)
msgid ""
"It's easiest to define <acronym>SQL</acronym> functions, so we'll start by "
"discussing those. Most of the concepts presented for <acronym>SQL</acronym> "
"functions will carry over to the other types of functions."
msgstr ""
"Проще всего определить функции на языке <acronym>SQL</acronym>, поэтому "
"сначала мы рассмотрим их. Многие концепции, касающиеся функций на "
"<acronym>SQL</acronym>, затем распространятся и на другие виды функций."

#: xfunc.xml:65(para)
msgid ""
"Throughout this chapter, it can be useful to look at the reference page of "
"the <xref linkend=\"sql-createfunction\"/> command to understand the "
"examples better. Some examples from this chapter can be found in "
"<filename>funcs.sql</filename> and <filename>funcs.c</filename> in the "
"<filename>src/tutorial</filename> directory in the <productname>PostgreSQL</"
"productname> source distribution."
msgstr ""
"Изучая эту главу, будет полезно обращаться к странице справки по команде "
"<xref linkend=\"sql-createfunction\"/>, чтобы лучше понимать примеры. "
"Некоторые примеры из этой главы можно найти в файлах <filename>funcs.sql</"
"filename> и <filename>funcs.c</filename> в каталоге <filename>src/tutorial</"
"filename> исходного кода <productname>PostgreSQL</productname>."

#: xfunc.xml:77(title)
msgid "Query Language (<acronym>SQL</acronym>) Functions"
msgstr "Функции на языке запросов (<acronym>SQL</acronym>)"

#: xfunc.xml:79(indexterm)
msgid ""
"<primary>function</primary> <secondary>user-defined</secondary> <tertiary>in "
"SQL</tertiary>"
msgstr ""
"<primary>функции</primary> <secondary>пользовательские</secondary> "
"<tertiary>на SQL</tertiary>"

#: xfunc.xml:85(para)
msgid ""
"SQL functions execute an arbitrary list of SQL statements, returning the "
"result of the last query in the list. In the simple (non-set) case, the "
"first row of the last query's result will be returned. (Bear in mind that "
"<quote>the first row</quote> of a multirow result is not well-defined unless "
"you use <literal>ORDER BY</literal>.) If the last query happens to return no "
"rows at all, the null value will be returned."
msgstr ""
"SQL-функции выполняют произвольный список операторов SQL и возвращают "
"результат последнего запроса в списке. В простом случае (не с множеством) "
"будет возвращена первая строка результата последнего запроса. (Помните, что "
"понятие <quote>первая строка</quote> в наборе результатов с несколькими "
"строками определено точно, только если присутствует <literal>ORDER BY</"
"literal>.) Если последний запрос вообще не вернёт строки, будет возвращено "
"значение NULL."

#: xfunc.xml:96(para)
msgid ""
"Alternatively, an SQL function can be declared to return a set (that is, "
"multiple rows) by specifying the function's return type as <literal>SETOF "
"<replaceable>sometype</replaceable></literal>, or equivalently by declaring "
"it as <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>. "
"In this case all rows of the last query's result are returned. Further "
"details appear below."
msgstr ""
"Кроме того, можно объявить SQL-функцию как возвращающую множество (то есть, "
"несколько строк), указав в качестве возвращаемого типа функции "
"<literal>SETOF <replaceable>некий_тип</replaceable></literal>, либо объявив "
"её с указанием <literal>RETURNS TABLE(<replaceable>столбцы</replaceable>)</"
"literal>. В этом случае будут возвращены все строки результата последнего "
"запроса. Подробнее это описывается ниже."

#: xfunc.xml:105(para)
msgid ""
"The body of an SQL function must be a list of SQL statements separated by "
"semicolons. A semicolon after the last statement is optional. Unless the "
"function is declared to return <type>void</type>, the last statement must be "
"a <command>SELECT</command>, or an <command>INSERT</command>, "
"<command>UPDATE</command>, or <command>DELETE</command> that has a "
"<literal>RETURNING</literal> clause."
msgstr ""
"Тело SQL-функции должно представлять собой список SQL-операторов, "
"разделённых точкой с запятой. Точка с запятой после последнего оператора "
"может отсутствовать. Если только функция не объявлена как возвращающая "
"<type>void</type>, последним оператором должен быть <command>SELECT</"
"command>, либо <command>INSERT</command>, <command>UPDATE</command> или "
"<command>DELETE</command> с предложением <literal>RETURNING</literal>."

#: xfunc.xml:114(para)
msgid ""
"Any collection of commands in the <acronym>SQL</acronym> language can be "
"packaged together and defined as a function. Besides <command>SELECT</"
"command> queries, the commands can include data modification queries "
"(<command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</"
"command>), as well as other SQL commands. (You cannot use transaction "
"control commands, e.g. <command>COMMIT</command>, <command>SAVEPOINT</"
"command>, and some utility commands, e.g. <literal>VACUUM</literal>, in "
"<acronym>SQL</acronym> functions.) However, the final command must be a "
"<command>SELECT</command> or have a <literal>RETURNING</literal> clause that "
"returns whatever is specified as the function's return type. Alternatively, "
"if you want to define a SQL function that performs actions but has no useful "
"value to return, you can define it as returning <type>void</type>. For "
"example, this function removes rows with negative salaries from the "
"<literal>emp</literal> table: <screen>\n"
"CREATE FUNCTION clean_emp() RETURNS void AS '\n"
"    DELETE FROM emp\n"
"        WHERE salary &lt; 0;\n"
"' LANGUAGE SQL;\n"
"\n"
"SELECT clean_emp();\n"
"\n"
" clean_emp\n"
"-----------\n"
"\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Любой набор команд на языке <acronym>SQL</acronym> можно скомпоновать вместе "
"и обозначить как функцию. Помимо запросов <command>SELECT</command>, эти "
"команды могут включать запросы, изменяющие данные (<command>INSERT</"
"command>, <command>UPDATE</command> и <command>DELETE</command>), а также "
"другие SQL-команды. (В <acronym>SQL</acronym>-функциях нельзя использовать "
"команды управления транзакциями, например <command>COMMIT</command>, "
"<command>SAVEPOINT</command>, и некоторые вспомогательные команды, в "
"частности <literal>VACUUM</literal>.) Однако последней командой должна быть "
"<command>SELECT</command> или команда с предложением <literal>RETURNING</"
"literal>, возвращающая результат с типом возврата функции. Если же вы хотите "
"определить функцию SQL, выполняющую действия, но не возвращающую полезное "
"значение, вы можете объявить её как возвращающую тип <type>void</type>. "
"Например, эта функция удаляет строки с отрицательным жалованьем из таблицы "
"<literal>emp</literal>: <screen>\n"
"CREATE FUNCTION clean_emp() RETURNS void AS '\n"
"    DELETE FROM emp\n"
"        WHERE salary &lt; 0;\n"
"' LANGUAGE SQL;\n"
"\n"
"SELECT clean_emp();\n"
"\n"
" clean_emp\n"
"-----------\n"
"\n"
"(1 row)\n"
"</screen>"

#: xfunc.xml:148(para)
msgid ""
"The entire body of a SQL function is parsed before any of it is executed. "
"While a SQL function can contain commands that alter the system catalogs (e."
"g., <command>CREATE TABLE</command>), the effects of such commands will not "
"be visible during parse analysis of later commands in the function. Thus, "
"for example, <literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</"
"literal> will not work as desired if packaged up into a single SQL function, "
"since <structname>foo</structname> won't exist yet when the <command>INSERT</"
"command> command is parsed. It's recommended to use <application>PL/PgSQL</"
"application> instead of a SQL function in this type of situation."
msgstr ""
"Прежде чем начинается выполнение команд, разбирается всё тело SQL-функции. "
"Когда SQL-функция содержит команды, модифицирующие системные каталоги "
"(например, <command>CREATE TABLE</command>), действие таких команд не будет "
"видимо на стадии анализа последующих команд этой функции. Так, например, "
"команды <literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</"
"literal> не будут работать, как ожидается, если их упаковать в одну SQL-"
"функцию, так как <structname>foo</structname> не будет существовать к "
"моменту разбору команды <command>INSERT</command>. В подобных ситуациях "
"вместо SQL-функции рекомендуется использовать <application>PL/PgSQL</"
"application>."

#: xfunc.xml:162(para)
msgid ""
"The syntax of the <command>CREATE FUNCTION</command> command requires the "
"function body to be written as a string constant. It is usually most "
"convenient to use dollar quoting (see <xref linkend=\"sql-syntax-dollar-"
"quoting\"/>) for the string constant. If you choose to use regular single-"
"quoted string constant syntax, you must double single quote marks "
"(<literal>'</literal>) and backslashes (<literal>\\</literal>) (assuming "
"escape string syntax) in the body of the function (see <xref linkend=\"sql-"
"syntax-strings\"/>)."
msgstr ""
"Синтаксис команды <command>CREATE FUNCTION</command> требует, чтобы тело "
"функции было записано как строковая константа. Обычно для этого удобнее "
"всего заключать строковую константу в доллары (см. <xref remap=\"4\" linkend="
"\"sql-syntax-dollar-quoting\"/>). Если вы решите использовать обычный "
"синтаксис с заключением строки в апострофы, вам придётся дублировать "
"апострофы (<literal>'</literal>) и обратную косую черту (<literal>\\</"
"literal>) (предполагается синтаксис спецпоследовательностей) в теле функции "
"(см. <xref remap=\"4\" linkend=\"sql-syntax-strings\"/>)."

#: xfunc.xml:174(title)
msgid "Arguments for <acronym>SQL</acronym> Functions"
msgstr "Аргументы <acronym>SQL</acronym>-функций"

#: xfunc.xml:176(indexterm)
msgid "<primary>function</primary> <secondary>named argument</secondary>"
msgstr "<primary>функция</primary> <secondary>именованный аргумент</secondary>"

#: xfunc.xml:181(para)
msgid ""
"Arguments of a SQL function can be referenced in the function body using "
"either names or numbers. Examples of both methods appear below."
msgstr ""
"К аргументам SQL-функции можно обращаться в теле функции по именам или "
"номерам. Ниже приведены примеры обоих вариантов."

#: xfunc.xml:187(para)
msgid ""
"To use a name, declare the function argument as having a name, and then just "
"write that name in the function body. If the argument name is the same as "
"any column name in the current SQL command within the function, the column "
"name will take precedence. To override this, qualify the argument name with "
"the name of the function itself, that is "
"<literal><replaceable>function_name</replaceable>."
"<replaceable>argument_name</replaceable></literal>. (If this would conflict "
"with a qualified column name, again the column name wins. You can avoid the "
"ambiguity by choosing a different alias for the table within the SQL "
"command.)"
msgstr ""
"Чтобы использовать имя, объявите аргумент функции как именованный, а затем "
"просто пишите это имя в теле функции. Если имя аргумента совпадает с именем "
"какого-либо столбца в текущей SQL-команде внутри функции, имя столбца будет "
"иметь приоритет. Чтобы всё же перекрыть имя столбца, дополните имя аргумента "
"именем самой функции, то есть запишите его в виде "
"<literal><replaceable>имя_функции</replaceable>.<replaceable>имя_аргумента</"
"replaceable></literal>. (Если и это имя будет конфликтовать с полным именем "
"столбца, снова выиграет имя столбца. Неоднозначности в этом случае вы можете "
"избежать, выбрав другой псевдоним для таблицы в SQL-команде.)"

#: xfunc.xml:199(para)
msgid ""
"In the older numeric approach, arguments are referenced using the syntax "
"<literal>$<replaceable>n</replaceable></literal>: <literal>$1</literal> "
"refers to the first input argument, <literal>$2</literal> to the second, and "
"so on. This will work whether or not the particular argument was declared "
"with a name."
msgstr ""
"Старый подход с нумерацией позволяет обращаться к аргументам, применяя "
"запись <literal>$<replaceable>n</replaceable></literal>: <literal>$1</"
"literal> обозначает первый аргумент, <literal>$2</literal> — второй и т. д. "
"Это будет работать и в том случае, если данному аргументу назначено имя."

#: xfunc.xml:206(para)
msgid ""
"If an argument is of a composite type, then the dot notation, e.g., "
"<literal><replaceable>argname</replaceable>.<replaceable>fieldname</"
"replaceable></literal> or <literal>$1.<replaceable>fieldname</replaceable></"
"literal>, can be used to access attributes of the argument. Again, you might "
"need to qualify the argument's name with the function name to make the form "
"with an argument name unambiguous."
msgstr ""
"Если аргумент имеет составной тип, то для обращения к его атрибутам можно "
"использовать запись с точкой, например: <literal><replaceable>аргумент</"
"replaceable>.<replaceable>поле</replaceable></literal> или <literal>$1."
"<replaceable>поле</replaceable></literal>. И опять же, при этом может "
"потребоваться дополнить имя аргумента именем функции, чтобы сделать имя "
"аргумента однозначным."

#: xfunc.xml:217(programlisting)
#, no-wrap
msgid "INSERT INTO mytable VALUES ($1);"
msgstr "INSERT INTO mytable VALUES ($1);"

#: xfunc.xml:221(programlisting)
#, no-wrap
msgid "INSERT INTO $1 VALUES (42);"
msgstr "INSERT INTO $1 VALUES (42);"

#: xfunc.xml:214(para)
msgid ""
"SQL function arguments can only be used as data values, not as identifiers. "
"Thus for example this is reasonable: <placeholder-1/> but this will not "
"work: <placeholder-2/>"
msgstr ""
"Аргументы SQL-функции могут использоваться только как значения данных, но не "
"как идентификаторы. Например, это приемлемо: <placeholder-1/> а это не будет "
"работать: <placeholder-2/>"

#: xfunc.xml:227(para)
msgid ""
"The ability to use names to reference SQL function arguments was added in "
"<productname>PostgreSQL</productname> 9.2. Functions to be used in older "
"servers must use the <literal>$<replaceable>n</replaceable></literal> "
"notation."
msgstr ""
"Возможность обращаться к аргументам SQL-функций по именам появилась в "
"<productname>PostgreSQL</productname> 9.2. В функциях, которые должны "
"работать со старыми серверами, необходимо применять запись <literal>"
"$<replaceable>n</replaceable></literal>."

#: xfunc.xml:236(title)
msgid "<acronym>SQL</acronym> Functions on Base Types"
msgstr "Функции <acronym>SQL</acronym> с базовыми типами"

#: xfunc.xml:238(para)
msgid ""
"The simplest possible <acronym>SQL</acronym> function has no arguments and "
"simply returns a base type, such as <type>integer</type>: <screen>\n"
"CREATE FUNCTION one() RETURNS integer AS $$\n"
"    SELECT 1 AS result;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"-- Alternative syntax for string literal:\n"
"CREATE FUNCTION one() RETURNS integer AS '\n"
"    SELECT 1 AS result;\n"
"' LANGUAGE SQL;\n"
"\n"
"SELECT one();\n"
"\n"
" one\n"
"-----\n"
"   1\n"
"</screen>"
msgstr ""
"Простейшая возможная функция <acronym>SQL</acronym> не имеет аргументов и "
"просто возвращает базовый тип, например <type>integer</type>: <screen>\n"
"CREATE FUNCTION one() RETURNS integer AS $$\n"
"    SELECT 1 AS result;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"-- Альтернативная запись строковой константы:\n"
"CREATE FUNCTION one() RETURNS integer AS '\n"
"    SELECT 1 AS result;\n"
"' LANGUAGE SQL;\n"
"\n"
"SELECT one();\n"
"\n"
" one\n"
"-----\n"
"   1\n"
"</screen>"

#: xfunc.xml:260(para)
msgid ""
"Notice that we defined a column alias within the function body for the "
"result of the function (with the name <literal>result</literal>), but this "
"column alias is not visible outside the function. Hence, the result is "
"labeled <literal>one</literal> instead of <literal>result</literal>."
msgstr ""
"Заметьте, что мы определили псевдоним столбца в теле функции для её "
"результата (дали ему имя <literal>result</literal>), но этот псевдоним не "
"виден снаружи функции. Вследствие этого, столбец результата получил имя "
"<literal>one</literal>, а не <literal>result</literal>."

#: xfunc.xml:267(para)
msgid ""
"It is almost as easy to define <acronym>SQL</acronym> functions that take "
"base types as arguments: <screen>\n"
"CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$\n"
"    SELECT x + y;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT add_em(1, 2) AS answer;\n"
"\n"
" answer\n"
"--------\n"
"      3\n"
"</screen>"
msgstr ""
"Практически так же легко определяются функции <acronym>SQL</acronym>, "
"которые принимают в аргументах базовые типы: <screen>\n"
"CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$\n"
"    SELECT x + y;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT add_em(1, 2) AS answer;\n"
"\n"
" answer\n"
"--------\n"
"      3\n"
"</screen>"

#: xfunc.xml:284(para)
msgid ""
"Alternatively, we could dispense with names for the arguments and use "
"numbers: <screen>\n"
"CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$\n"
"    SELECT $1 + $2;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT add_em(1, 2) AS answer;\n"
"\n"
" answer\n"
"--------\n"
"      3\n"
"</screen>"
msgstr ""
"Мы также можем отказаться от имён аргументов и обращаться к ним по номерам: "
"<screen>\n"
"CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$\n"
"    SELECT $1 + $2;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT add_em(1, 2) AS answer;\n"
"\n"
" answer\n"
"--------\n"
"      3\n"
"</screen>"

#: xfunc.xml:305(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$\n"
"    UPDATE bank\n"
"        SET balance = balance - debit\n"
"        WHERE accountno = tf1.accountno;\n"
"    SELECT 1;\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$\n"
"    UPDATE bank\n"
"        SET balance = balance - debit\n"
"        WHERE accountno = tf1.accountno;\n"
"    SELECT 1;\n"
"$$ LANGUAGE SQL;"

#: xfunc.xml:317(programlisting)
#, no-wrap
msgid "SELECT tf1(17, 100.0);"
msgstr "SELECT tf1(17, 100.0);"

#: xfunc.xml:301(para)
msgid ""
"Here is a more useful function, which might be used to debit a bank account: "
"<placeholder-1/> A user could execute this function to debit account 17 by "
"$100.00 as follows: <placeholder-2/>"
msgstr ""
"Вот более полезная функция, которую можно использовать, чтобы дебетовать "
"банковский счёт: <placeholder-1/> Пользователь может выполнить эту функцию, "
"чтобы дебетовать счёт 17 на 100 долларов, так: <placeholder-2/>"

#: xfunc.xml:322(para)
msgid ""
"In this example, we chose the name <literal>accountno</literal> for the "
"first argument, but this is the same as the name of a column in the "
"<literal>bank</literal> table. Within the <command>UPDATE</command> command, "
"<literal>accountno</literal> refers to the column <literal>bank.accountno</"
"literal>, so <literal>tf1.accountno</literal> must be used to refer to the "
"argument. We could of course avoid this by using a different name for the "
"argument."
msgstr ""
"В этом примере мы выбрали имя <literal>accountno</literal> для первого "
"аргумента, но это же имя имеет столбец в таблице <literal>bank</literal>. В "
"команде <command>UPDATE</command> имя <literal>accountno</literal> относится "
"к столбцу <literal>bank.accountno</literal>, так для обращения к аргументу "
"нужно записать <literal>tf1.accountno</literal>. Конечно, мы могли бы "
"избежать этого, выбрав другое имя для аргумента."

#: xfunc.xml:336(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$\n"
"    UPDATE bank\n"
"        SET balance = balance - debit\n"
"        WHERE accountno = tf1.accountno;\n"
"    SELECT balance FROM bank WHERE accountno = tf1.accountno;\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$\n"
"    UPDATE bank\n"
"        SET balance = balance - debit\n"
"        WHERE accountno = tf1.accountno;\n"
"    SELECT balance FROM bank WHERE accountno = tf1.accountno;\n"
"$$ LANGUAGE SQL;"

#: xfunc.xml:348(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$\n"
"    UPDATE bank\n"
"        SET balance = balance - debit\n"
"        WHERE accountno = tf1.accountno\n"
"    RETURNING balance;\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS integer AS $$\n"
"    UPDATE bank\n"
"        SET balance = balance - debit\n"
"        WHERE accountno = tf1.accountno\n"
"    RETURNING balance;\n"
"$$ LANGUAGE SQL;"

#: xfunc.xml:331(para)
msgid ""
"In practice one would probably like a more useful result from the function "
"than a constant 1, so a more likely definition is: <placeholder-1/> which "
"adjusts the balance and returns the new balance. The same thing could be "
"done in one command using <literal>RETURNING</literal>: <placeholder-2/>"
msgstr ""
"На практике обычно желательно получать от функции более полезный результат, "
"чем константу 1, поэтому более реалистично такое определение: <placeholder-1/"
"> Эта функция изменяет баланс и возвращает полученное значение. То же самое "
"можно сделать в одной команде, применив <literal>RETURNING</literal>: "
"<placeholder-2/>"

#: xfunc.xml:360(title)
msgid "<acronym>SQL</acronym> Functions on Composite Types"
msgstr "Функции <acronym>SQL</acronym> со сложными типами"

#: xfunc.xml:362(para)
msgid ""
"When writing functions with arguments of composite types, we must not only "
"specify which argument we want but also the desired attribute (field) of "
"that argument. For example, suppose that <type>emp</type> is a table "
"containing employee data, and therefore also the name of the composite type "
"of each row of the table. Here is a function <function>double_salary</"
"function> that computes what someone's salary would be if it were doubled: "
"<screen>\n"
"CREATE TABLE emp (\n"
"    name        text,\n"
"    salary      numeric,\n"
"    age         integer,\n"
"    cubicle     point\n"
");\n"
"\n"
"INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');\n"
"\n"
"CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$\n"
"    SELECT $1.salary * 2 AS salary;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT name, double_salary(emp.*) AS dream\n"
"    FROM emp\n"
"    WHERE emp.cubicle ~= point '(2,1)';\n"
"\n"
" name | dream\n"
"------+-------\n"
" Bill |  8400\n"
"</screen>"
msgstr ""
"В функциях с аргументами составных типов мы должны указывать не только, "
"какой аргумент, но и какой атрибут (поле) этого аргумента нам нужен. "
"Например, предположим, что <type>emp</type> — таблица, содержащая данные "
"работников, и это же имя составного типа, представляющего каждую строку "
"таблицы. Следующая функция <function>double_salary</function> вычисляет, "
"каким было бы чьё-либо жалование в случае увеличения вдвое: <screen>\n"
"CREATE TABLE emp (\n"
"    name        text,\n"
"    salary      numeric,\n"
"    age         integer,\n"
"    cubicle     point\n"
");\n"
"\n"
"INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');\n"
"\n"
"CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$\n"
"    SELECT $1.salary * 2 AS salary;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT name, double_salary(emp.*) AS dream\n"
"    FROM emp\n"
"    WHERE emp.cubicle ~= point '(2,1)';\n"
"\n"
" name | dream\n"
"------+-------\n"
" Bill |  8400\n"
"</screen>"

#: xfunc.xml:395(para)
msgid ""
"Notice the use of the syntax <literal>$1.salary</literal> to select one "
"field of the argument row value. Also notice how the calling "
"<command>SELECT</command> command uses <replaceable>table_name</"
"replaceable><literal>.*</literal> to select the entire current row of a "
"table as a composite value. The table row can alternatively be referenced "
"using just the table name, like this: <screen>\n"
"SELECT name, double_salary(emp) AS dream\n"
"    FROM emp\n"
"    WHERE emp.cubicle ~= point '(2,1)';\n"
"</screen> but this usage is deprecated since it's easy to get confused. (See "
"<xref linkend=\"rowtypes-usage\"/> for details about these two notations for "
"the composite value of a table row.)"
msgstr ""
"Обратите внимание на запись <literal>$1.salary</literal> позволяющую выбрать "
"одно поле из значения строки аргумента. Также заметьте, что в вызывающей "
"команде <command>SELECT</command> указание <replaceable>имя_таблицы</"
"replaceable><literal>.*</literal> выбирает всю текущую строку таблицы как "
"составное значение. На строку таблицы можно сослаться и просто по имени "
"таблицы, например так: <screen>\n"
"SELECT name, double_salary(emp) AS dream\n"
"    FROM emp\n"
"    WHERE emp.cubicle ~= point '(2,1)';\n"
"</screen> Однако это использование считается устаревшим, так как провоцирует "
"путаницу. (Подробнее эти две записи составных значений строки таблицы "
"описаны в <xref remap=\"6\" linkend=\"rowtypes-usage\"/>.)"

#: xfunc.xml:413(para)
msgid ""
"Sometimes it is handy to construct a composite argument value on-the-fly. "
"This can be done with the <literal>ROW</literal> construct. For example, we "
"could adjust the data being passed to the function: <screen>\n"
"SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream\n"
"    FROM emp;\n"
"</screen>"
msgstr ""
"Иногда бывает удобно образовать составное значение аргумента на лету. Это "
"позволяет сделать конструкция <literal>ROW</literal>. Например, так можно "
"изменить данные, передаваемые функции: <screen>\n"
"SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream\n"
"    FROM emp;\n"
"</screen>"

#: xfunc.xml:428(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION new_emp() RETURNS emp AS $$\n"
"    SELECT text 'None' AS name,\n"
"        1000.0 AS salary,\n"
"        25 AS age,\n"
"        point '(2,2)' AS cubicle;\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION new_emp() RETURNS emp AS $$\n"
"    SELECT text 'None' AS name,\n"
"        1000.0 AS salary,\n"
"        25 AS age,\n"
"        point '(2,2)' AS cubicle;\n"
"$$ LANGUAGE SQL;"

#: xfunc.xml:423(para)
msgid ""
"It is also possible to build a function that returns a composite type. This "
"is an example of a function that returns a single <type>emp</type> row: "
"<placeholder-1/> In this example we have specified each of the attributes "
"with a constant value, but any computation could have been substituted for "
"these constants."
msgstr ""
"Также возможно создать функцию, возвращающую составной тип. Например, эта "
"функция возвращает одну строку <type>emp</type>: <placeholder-1/> В этом "
"примере мы задали для каждого атрибута постоянное значение, но вместо этих "
"констант можно подставить любые вычисления."

#: xfunc.xml:447(para)
msgid ""
"The select list order in the query must be exactly the same as that in which "
"the columns appear in the table associated with the composite type. (Naming "
"the columns, as we did above, is irrelevant to the system.)"
msgstr ""
"Порядок в списке выборки внутреннего запроса должен в точности совпадать с "
"порядком следования столбцов в таблице, связанной с составным типом. (Имена "
"столбцов, как показывает пример выше, для системы значения не имеют.)"

#: xfunc.xml:455(para)
msgid ""
"You must typecast the expressions to match the definition of the composite "
"type, or you will get errors like this: <screen>\n"
"<computeroutput>\n"
"ERROR:  function declared to return emp returns varchar instead of text at "
"column 1\n"
"</computeroutput>\n"
"</screen>"
msgstr ""
"Вы должны привести выражения в соответствие с определением составного типа, "
"либо вы получите такие ошибки: <screen>\n"
"<computeroutput>\n"
"ERROR:  function declared to return emp returns varchar instead of text at "
"column 1\n"
"</computeroutput>\n"
"</screen>(ОШИБКА:  функция, объявленная как возвращающая emp, возвращает "
"varchar вместо text в столбце 1)"

#: xfunc.xml:442(para)
msgid "Note two important things about defining the function: <placeholder-1/>"
msgstr ""
"Учтите два важных требования относительно определения функции: "
"<placeholder-1/>"

#: xfunc.xml:471(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION new_emp() RETURNS emp AS $$\n"
"    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION new_emp() RETURNS emp AS $$\n"
"    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;\n"
"$$ LANGUAGE SQL;"

#: xfunc.xml:468(para)
msgid ""
"A different way to define the same function is: <placeholder-1/> Here we "
"wrote a <command>SELECT</command> that returns just a single column of the "
"correct composite type. This isn't really better in this situation, but it "
"is a handy alternative in some cases &mdash; for example, if we need to "
"compute the result by calling another function that returns the desired "
"composite value."
msgstr ""
"Ту же функцию можно определить другим способом: <placeholder-1/> Здесь мы "
"записали <command>SELECT</command>, который возвращает один столбец нужного "
"составного типа. В данной ситуации этот вариант на самом деле не лучше, но в "
"некоторых случаях он может быть удобной альтернативой &mdash; например, если "
"нам нужно вычислить результат, вызывая другую функцию, которая возвращает "
"нужное составное значение."

#: xfunc.xml:484(para)
msgid ""
"We could call this function directly either by using it in a value "
"expression: <screen>\n"
"SELECT new_emp();\n"
"\n"
"         new_emp\n"
"--------------------------\n"
" (None,1000.0,25,\"(2,2)\")\n"
"</screen> or by calling it as a table function: <screen>\n"
"SELECT * FROM new_emp();\n"
"\n"
" name | salary | age | cubicle\n"
"------+--------+-----+---------\n"
" None | 1000.0 |  25 | (2,2)\n"
"</screen> The second way is described more fully in <xref linkend=\"xfunc-"
"sql-table-functions\"/>."
msgstr ""
"Мы можем вызывать эту функцию напрямую, либо указав её в выражении значения: "
"<screen>\n"
"SELECT new_emp();\n"
"\n"
"         new_emp\n"
"--------------------------\n"
" (None,1000.0,25,\"(2,2)\")\n"
"</screen> либо обратившись к ней, как к табличной функции: <screen>\n"
"SELECT * FROM new_emp();\n"
"\n"
" name | salary | age | cubicle\n"
"------+--------+-----+---------\n"
" None | 1000.0 |  25 | (2,2)\n"
"</screen> Второй способ более подробно описан в <xref remap=\"6\" linkend="
"\"xfunc-sql-table-functions\"/>."

#: xfunc.xml:510(para)
msgid ""
"When you use a function that returns a composite type, you might want only "
"one field (attribute) from its result. You can do that with syntax like "
"this: <screen>\n"
"SELECT (new_emp()).name;\n"
"\n"
" name\n"
"------\n"
" None\n"
"</screen> The extra parentheses are needed to keep the parser from getting "
"confused. If you try to do it without them, you get something like this: "
"<screen>\n"
"SELECT new_emp().name;\n"
"ERROR:  syntax error at or near \".\"\n"
"LINE 1: SELECT new_emp().name;\n"
"                        ^\n"
"</screen>"
msgstr ""
"Когда используется функция, возвращающая составной тип, может возникнуть "
"желание получить из её результата только одно поле (атрибут). Это можно "
"сделать, применяя такую запись: <screen>\n"
"SELECT (new_emp()).name;\n"
"\n"
" name\n"
"------\n"
" None\n"
"</screen> Дополнительные скобки необходимы во избежание неоднозначности при "
"разборе запроса. Если вы попытаетесь выполнить запрос без них, вы получите "
"ошибку: <screen>\n"
"SELECT new_emp().name;\n"
"ERROR:  syntax error at or near \".\"\n"
"LINE 1: SELECT new_emp().name;\n"
"                        ^\n"
"</screen>\n"
"(ОШИБКА:  синтаксическая ошибка (примерное положение: \".\"))"

#: xfunc.xml:534(para)
msgid ""
"Another option is to use functional notation for extracting an attribute: "
"<screen>\n"
"SELECT name(new_emp());\n"
"\n"
" name\n"
"------\n"
" None\n"
"</screen> As explained in <xref linkend=\"rowtypes-usage\"/>, the field "
"notation and functional notation are equivalent."
msgstr ""
"Функциональную запись также можно использовать и для извлечения атрибутов: "
"<screen>\n"
"SELECT name(new_emp());\n"
"\n"
" name\n"
"------\n"
" None\n"
"</screen> Как рассказывалось в <xref remap=\"6\" linkend=\"rowtypes-usage\"/"
">, запись с указанием поля и функциональная запись являются равнозначными."

#: xfunc.xml:549(para)
msgid ""
"Another way to use a function returning a composite type is to pass the "
"result to another function that accepts the correct row type as input: "
"<screen>\n"
"CREATE FUNCTION getname(emp) RETURNS text AS $$\n"
"    SELECT $1.name;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT getname(new_emp());\n"
" getname\n"
"---------\n"
" None\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Ещё один вариант использования функции, возвращающей составной тип, "
"заключается в передаче её результата другой функции, которая принимает этот "
"тип строки на вход: <screen>\n"
"CREATE FUNCTION getname(emp) RETURNS text AS $$\n"
"    SELECT $1.name;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT getname(new_emp());\n"
" getname\n"
"---------\n"
" None\n"
"(1 row)\n"
"</screen>"

#: xfunc.xml:568(title)
msgid "<acronym>SQL</acronym> Functions with Output Parameters"
msgstr "Функции <acronym>SQL</acronym> с выходными параметрами"

#: xfunc.xml:570(indexterm)
msgid "<primary>function</primary> <secondary>output parameter</secondary>"
msgstr "<primary>функция</primary> <secondary>выходной параметр</secondary>"

#: xfunc.xml:575(para)
msgid ""
"An alternative way of describing a function's results is to define it with "
"<firstterm>output parameters</firstterm>, as in this example: <screen>\n"
"CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)\n"
"AS 'SELECT x + y'\n"
"LANGUAGE SQL;\n"
"\n"
"SELECT add_em(3,7);\n"
" add_em\n"
"--------\n"
"     10\n"
"(1 row)\n"
"</screen> This is not essentially different from the version of "
"<literal>add_em</literal> shown in <xref linkend=\"xfunc-sql-base-functions"
"\"/>. The real value of output parameters is that they provide a convenient "
"way of defining functions that return several columns. For example, "
"<screen>\n"
"CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)\n"
"AS 'SELECT x + y, x * y'\n"
"LANGUAGE SQL;\n"
"\n"
" SELECT * FROM sum_n_product(11,42);\n"
" sum | product\n"
"-----+---------\n"
"  53 |     462\n"
"(1 row)\n"
"</screen> What has essentially happened here is that we have created an "
"anonymous composite type for the result of the function. The above example "
"has the same end result as <screen>\n"
"CREATE TYPE sum_prod AS (sum int, product int);\n"
"\n"
"CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod\n"
"AS 'SELECT $1 + $2, $1 * $2'\n"
"LANGUAGE SQL;\n"
"</screen> but not having to bother with the separate composite type "
"definition is often handy. Notice that the names attached to the output "
"parameters are not just decoration, but determine the column names of the "
"anonymous composite type. (If you omit a name for an output parameter, the "
"system will choose a name on its own.)"
msgstr ""
"Альтернативный способ описать результаты функции — определить её с "
"<firstterm>выходными параметрами</firstterm>, как в этом примере: <screen>\n"
"CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)\n"
"AS 'SELECT x + y'\n"
"LANGUAGE SQL;\n"
"\n"
"SELECT add_em(3,7);\n"
" add_em\n"
"--------\n"
"     10\n"
"(1 row)\n"
"</screen> Это по сути не отличается от версии <literal>add_em</literal>, "
"показанной в <xref remap=\"6\" linkend=\"xfunc-sql-base-functions\"/>. "
"Действительная ценность выходных параметров в том, что они позволяют удобным "
"способом определить функции, возвращающие несколько столбцов. Например: "
"<screen>\n"
"CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)\n"
"AS 'SELECT x + y, x * y'\n"
"LANGUAGE SQL;\n"
"\n"
" SELECT * FROM sum_n_product(11,42);\n"
" sum | product\n"
"-----+---------\n"
"  53 |     462\n"
"(1 row)\n"
"</screen> Фактически здесь мы определили анонимный составной тип для "
"результата функции. Показанный выше пример даёт тот же конечный результат, "
"что и команды: <screen>\n"
"CREATE TYPE sum_prod AS (sum int, product int);\n"
"\n"
"CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod\n"
"AS 'SELECT $1 + $2, $1 * $2'\n"
"LANGUAGE SQL;\n"
"</screen> Но предыдущий вариант зачастую удобнее, так как он не требует "
"отдельно заниматься определением составного типа. Заметьте, что имена, "
"назначаемые выходным параметрам, не просто декоративные, а определяют имена "
"столбцов анонимного составного типа. (Если вы опустите имя выходного "
"параметра, система выберет имя сама.)"

#: xfunc.xml:627(para)
msgid ""
"Notice that output parameters are not included in the calling argument list "
"when invoking such a function from SQL. This is because "
"<productname>PostgreSQL</productname> considers only the input parameters to "
"define the function's calling signature. That means also that only the input "
"parameters matter when referencing the function for purposes such as "
"dropping it. We could drop the above function with either of <screen>\n"
"DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);\n"
"DROP FUNCTION sum_n_product (int, int);\n"
"</screen>"
msgstr ""
"Заметьте, что выходные параметры не включаются в список аргументов при "
"вызове такой функции из SQL. Это объясняется тем, что "
"<productname>PostgreSQL</productname> определяет сигнатуру вызова функции, "
"рассматривая только входные параметры. Это также значит, что при таких "
"операциях, как удаление функции, в ссылках на функцию учитываются только "
"типы входных параметров. Таким образом, удалить эту конкретную функцию можно "
"любой из этих команд: <screen>\n"
"DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);\n"
"DROP FUNCTION sum_n_product (int, int);\n"
"</screen>"

#: xfunc.xml:642(para)
msgid ""
"Parameters can be marked as <literal>IN</literal> (the default), "
"<literal>OUT</literal>, <literal>INOUT</literal>, or <literal>VARIADIC</"
"literal>. An <literal>INOUT</literal> parameter serves as both an input "
"parameter (part of the calling argument list) and an output parameter (part "
"of the result record type). <literal>VARIADIC</literal> parameters are input "
"parameters, but are treated specially as described next."
msgstr ""
"Параметры функции могут быть объявлены как <literal>IN</literal> (по "
"умолчанию), <literal>OUT</literal>, <literal>INOUT</literal> или "
"<literal>VARIADIC</literal>. Параметр <literal>INOUT</literal> действует как "
"входной (является частью списка аргументов при вызове) и как выходной (часть "
"типа записи результата). Параметры <literal>VARIADIC</literal> являются "
"входными, но обрабатывается специальным образом, как описано далее."

#: xfunc.xml:654(title)
msgid "<acronym>SQL</acronym> Functions with Variable Numbers of Arguments"
msgstr "Функции <acronym>SQL</acronym> с переменным числом аргументов"

#: xfunc.xml:656(indexterm)
msgid "<primary>function</primary> <secondary>variadic</secondary>"
msgstr "<primary>функция</primary> <secondary>переменные параметры</secondary>"

#: xfunc.xml:661(indexterm)
msgid "<primary>variadic function</primary>"
msgstr "<primary>функция с переменными параметрами</primary>"

#: xfunc.xml:665(para)
msgid ""
"<acronym>SQL</acronym> functions can be declared to accept variable numbers "
"of arguments, so long as all the <quote>optional</quote> arguments are of "
"the same data type. The optional arguments will be passed to the function as "
"an array. The function is declared by marking the last parameter as "
"<literal>VARIADIC</literal>; this parameter must be declared as being of an "
"array type. For example: <screen>\n"
"CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$\n"
"    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT mleast(10, -1, 5, 4.4);\n"
" mleast \n"
"--------\n"
"     -1\n"
"(1 row)\n"
"</screen> Effectively, all the actual arguments at or beyond the "
"<literal>VARIADIC</literal> position are gathered up into a one-dimensional "
"array, as if you had written <screen>\n"
"SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- doesn't work\n"
"</screen> You can't actually write that, though &mdash; or at least, it will "
"not match this function definition. A parameter marked <literal>VARIADIC</"
"literal> matches one or more occurrences of its element type, not of its own "
"type."
msgstr ""
"Функции <acronym>SQL</acronym> могут быть объявлены как принимающие "
"переменное число аргументов, с условием, что все <quote>необязательные</"
"quote> аргументы имеют один тип данных. Необязательные аргументы будут "
"переданы такой функции в виде массива. Для этого в объявлении функции "
"последний параметр помечается как <literal>VARIADIC</literal>; при этом он "
"должен иметь тип массива. Например: <screen>\n"
"CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$\n"
"    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT mleast(10, -1, 5, 4.4);\n"
" mleast \n"
"--------\n"
"     -1\n"
"(1 row)\n"
"</screen> По сути, все фактические аргументы, начиная с позиции "
"<literal>VARIADIC</literal>, собираются в одномерный массив, как если бы вы "
"написали <screen>\n"
"SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- это не будет работать\n"
"</screen> На самом деле так вызвать эту функцию нельзя, или, по крайней "
"мере, это не будет соответствовать определению функции. Параметру "
"<literal>VARIADIC</literal> соответствуют одно или несколько вхождений типа "
"его элемента, но не его собственного типа."

#: xfunc.xml:699(para)
msgid ""
"Sometimes it is useful to be able to pass an already-constructed array to a "
"variadic function; this is particularly handy when one variadic function "
"wants to pass on its array parameter to another one. You can do that by "
"specifying <literal>VARIADIC</literal> in the call: <screen>\n"
"SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);\n"
"</screen> This prevents expansion of the function's variadic parameter into "
"its element type, thereby allowing the array argument value to match "
"normally. <literal>VARIADIC</literal> can only be attached to the last "
"actual argument of a function call."
msgstr ""
"Но иногда бывает полезно передать функции с переменными параметрами уже "
"подготовленный массив; особенно когда одна функция с переменными параметрами "
"хочет передавать свой массив параметров другой. Это можно сделать, указав "
"<literal>VARIADIC</literal> в вызове: <screen>\n"
"SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);\n"
"</screen> Это предотвращает разворачивание переменного множества параметров "
"функции в базовый тип, что позволяет сопоставить с ним значение типа "
"массива. <literal>VARIADIC</literal> можно добавить только к последнему "
"фактическому аргументу вызова функции."

#: xfunc.xml:715(para)
msgid ""
"Specifying <literal>VARIADIC</literal> in the call is also the only way to "
"pass an empty array to a variadic function, for example: <screen>\n"
"SELECT mleast(VARIADIC ARRAY[]::numeric[]);\n"
"</screen> Simply writing <literal>SELECT mleast()</literal> does not work "
"because a variadic parameter must match at least one actual argument. (You "
"could define a second function also named <literal>mleast</literal>, with no "
"parameters, if you wanted to allow such calls.)"
msgstr ""
"Также указание <literal>VARIADIC</literal> даёт единственную возможность "
"передать пустой массив функции с переменными параметрами, например, так: "
"<screen>\n"
"SELECT mleast(VARIADIC ARRAY[]::numeric[]);\n"
"</screen> Простой вызов <literal>SELECT mleast()</literal> не будет "
"работать, так как переменным параметрам должен соответствовать минимум один "
"фактический аргумент. (Можно определить вторую функцию с таким же именем "
"<literal>mleast</literal>, но без параметров, если вы хотите выполнять такие "
"вызовы.)"

#: xfunc.xml:729(para)
msgid ""
"The array element parameters generated from a variadic parameter are treated "
"as not having any names of their own. This means it is not possible to call "
"a variadic function using named arguments (<xref linkend=\"sql-syntax-"
"calling-funcs\"/>), except when you specify <literal>VARIADIC</literal>. For "
"example, this will work: <screen>\n"
"SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);\n"
"</screen> but not these: <screen>\n"
"SELECT mleast(arr =&gt; 10);\n"
"SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);\n"
"</screen>"
msgstr ""
"Элементы массива, создаваемые из переменных параметров, считаются не "
"имеющими собственных имён. Это означает, что передать функции с переменными "
"параметрами именованные аргументы нельзя (см. <xref remap=\"4\" linkend="
"\"sql-syntax-calling-funcs\"/>), если только при вызове не добавлено "
"<literal>VARIADIC</literal>. Например, этот вариант будет работать: "
"<screen>\n"
"SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);\n"
"</screen> А эти варианты нет: <screen>\n"
"SELECT mleast(arr =&gt; 10);\n"
"SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);\n"
"</screen>"

#: xfunc.xml:750(title)
msgid "<acronym>SQL</acronym> Functions with Default Values for Arguments"
msgstr "Функции <acronym>SQL</acronym> со значениями аргументов по умолчанию"

#: xfunc.xml:752(indexterm)
msgid ""
"<primary>function</primary> <secondary>default values for arguments</"
"secondary>"
msgstr ""
"<primary>функция</primary> <secondary>значения аргументов по умолчанию</"
"secondary>"

#: xfunc.xml:757(para)
msgid ""
"Functions can be declared with default values for some or all input "
"arguments. The default values are inserted whenever the function is called "
"with insufficiently many actual arguments. Since arguments can only be "
"omitted from the end of the actual argument list, all parameters after a "
"parameter with a default value have to have default values as well. "
"(Although the use of named argument notation could allow this restriction to "
"be relaxed, it's still enforced so that positional argument notation works "
"sensibly.)"
msgstr ""
"Функции могут быть объявлены со значениями по умолчанию для некоторых или "
"всех входных аргументов. Значения по умолчанию подставляются, когда функция "
"вызывается с недостаточным количеством фактических аргументов. Так как "
"аргументы можно опускать только с конца списка фактических аргументов, все "
"параметры после параметра со значением по умолчанию также получат значения "
"по умолчанию. (Хотя запись с именованными аргументами могла бы ослабить это "
"ограничение, оно всё же остаётся в силе, чтобы позиционные ссылки на "
"аргументы оставались действительными.)"

#: xfunc.xml:768(para)
msgid ""
"For example: <screen>\n"
"CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)\n"
"RETURNS int\n"
"LANGUAGE SQL\n"
"AS $$\n"
"    SELECT $1 + $2 + $3;\n"
"$$;\n"
"\n"
"SELECT foo(10, 20, 30);\n"
" foo \n"
"-----\n"
"  60\n"
"(1 row)\n"
"\n"
"SELECT foo(10, 20);\n"
" foo \n"
"-----\n"
"  33\n"
"(1 row)\n"
"\n"
"SELECT foo(10);\n"
" foo \n"
"-----\n"
"  15\n"
"(1 row)\n"
"\n"
"SELECT foo();  -- fails since there is no default for the first argument\n"
"ERROR:  function foo() does not exist\n"
"</screen> The <literal>=</literal> sign can also be used in place of the key "
"word <literal>DEFAULT</literal>."
msgstr ""
"Например: <screen>\n"
"CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)\n"
"RETURNS int\n"
"LANGUAGE SQL\n"
"AS $$\n"
"    SELECT $1 + $2 + $3;\n"
"$$;\n"
"\n"
"SELECT foo(10, 20, 30);\n"
" foo \n"
"-----\n"
"  60\n"
"(1 row)\n"
"\n"
"SELECT foo(10, 20);\n"
" foo \n"
"-----\n"
"  33\n"
"(1 row)\n"
"\n"
"SELECT foo(10);\n"
" foo \n"
"-----\n"
"  15\n"
"(1 row)\n"
"\n"
"SELECT foo();  -- не работает из-за отсутствия значения по умолчанию для "
"первого аргумента\n"
"ERROR:  function foo() does not exist\n"
"</screen> (ОШИБКА: функция foo() не существует) Вместо ключевого слова "
"<literal>DEFAULT</literal> можно использовать знак <literal>=</literal>."

#: xfunc.xml:805(title)
msgid "<acronym>SQL</acronym> Functions as Table Sources"
msgstr "Функции <acronym>SQL</acronym>, порождающие таблицы"

#: xfunc.xml:807(para)
msgid ""
"All SQL functions can be used in the <literal>FROM</literal> clause of a "
"query, but it is particularly useful for functions returning composite "
"types. If the function is defined to return a base type, the table function "
"produces a one-column table. If the function is defined to return a "
"composite type, the table function produces a column for each attribute of "
"the composite type."
msgstr ""
"Все функции SQL можно использовать в предложении <literal>FROM</literal> "
"запросов, но наиболее полезно это для функций, возвращающих составные типы. "
"Если функция объявлена как возвращающая базовый тип, она возвращает таблицу "
"с одним столбцом. Если же функция объявлена как возвращающая составной тип, "
"она возвращает таблицу со столбцами для каждого атрибута составного типа."

#: xfunc.xml:816(para)
msgid ""
"Here is an example: <screen>\n"
"CREATE TABLE foo (fooid int, foosubid int, fooname text);\n"
"INSERT INTO foo VALUES (1, 1, 'Joe');\n"
"INSERT INTO foo VALUES (1, 2, 'Ed');\n"
"INSERT INTO foo VALUES (2, 1, 'Mary');\n"
"\n"
"CREATE FUNCTION getfoo(int) RETURNS foo AS $$\n"
"    SELECT * FROM foo WHERE fooid = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT *, upper(fooname) FROM getfoo(1) AS t1;\n"
"\n"
" fooid | foosubid | fooname | upper\n"
"-------+----------+---------+-------\n"
"     1 |        1 | Joe     | JOE\n"
"(1 row)\n"
"</screen> As the example shows, we can work with the columns of the "
"function's result just the same as if they were columns of a regular table."
msgstr ""
"Например: <screen>\n"
"CREATE TABLE foo (fooid int, foosubid int, fooname text);\n"
"INSERT INTO foo VALUES (1, 1, 'Joe');\n"
"INSERT INTO foo VALUES (1, 2, 'Ed');\n"
"INSERT INTO foo VALUES (2, 1, 'Mary');\n"
"\n"
"CREATE FUNCTION getfoo(int) RETURNS foo AS $$\n"
"    SELECT * FROM foo WHERE fooid = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT *, upper(fooname) FROM getfoo(1) AS t1;\n"
"\n"
" fooid | foosubid | fooname | upper\n"
"-------+----------+---------+-------\n"
"     1 |        1 | Joe     | JOE\n"
"(1 row)\n"
"</screen> Как показывает этот пример, мы можем работать со столбцами "
"результата функции так же, как если бы это были столбцы обычной таблицы."

#: xfunc.xml:841(para)
msgid ""
"Note that we only got one row out of the function. This is because we did "
"not use <literal>SETOF</literal>. That is described in the next section."
msgstr ""
"Заметьте, что мы получаем из данной функции только одну строку. Это "
"объясняется тем, что мы не использовали указание <literal>SETOF</literal>. "
"Оно описывается в следующем разделе."

#: xfunc.xml:848(title)
msgid "<acronym>SQL</acronym> Functions Returning Sets"
msgstr "Функции <acronym>SQL</acronym>, возвращающие множества"

#: xfunc.xml:850(indexterm)
msgid "<primary>function</primary> <secondary>with SETOF</secondary>"
msgstr "<primary>функция</primary> <secondary>с SETOF</secondary>"

#: xfunc.xml:855(para)
msgid ""
"When an SQL function is declared as returning <literal>SETOF "
"<replaceable>sometype</replaceable></literal>, the function's final query is "
"executed to completion, and each row it outputs is returned as an element of "
"the result set."
msgstr ""
"Когда SQL-функция объявляется как возвращающая <literal>SETOF "
"<replaceable>некий_тип</replaceable></literal>, конечный запрос функции "
"выполняется до завершения и каждая строка выводится как элемент "
"результирующего множества."

#: xfunc.xml:868(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n"
"    SELECT * FROM foo WHERE fooid = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM getfoo(1) AS t1;"
msgstr ""
"CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n"
"    SELECT * FROM foo WHERE fooid = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM getfoo(1) AS t1;"

#: xfunc.xml:862(para)
msgid ""
"This feature is normally used when calling the function in the "
"<literal>FROM</literal> clause. In this case each row returned by the "
"function becomes a row of the table seen by the query. For example, assume "
"that table <literal>foo</literal> has the same contents as above, and we "
"say: <placeholder-1/> Then we would get: <screen>\n"
" fooid | foosubid | fooname\n"
"-------+----------+---------\n"
"     1 |        1 | Joe\n"
"     1 |        2 | Ed\n"
"(2 rows)\n"
"</screen>"
msgstr ""
"Это обычно используется, когда функция вызывается в предложении "
"<literal>FROM</literal>. В этом случае каждая строка, возвращаемая функцией, "
"становится строкой таблицы, появляющейся в запросе. Например, в "
"предположении, что таблица <literal>foo</literal> имеет то же содержимое, "
"что и раньше, мы выполняем: <placeholder-1/> Тогда в ответ мы получим: "
"<screen>\n"
" fooid | foosubid | fooname\n"
"-------+----------+---------\n"
"     1 |        1 | Joe\n"
"     1 |        2 | Ed\n"
"(2 rows)\n"
"</screen>"

#: xfunc.xml:890(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE tab (y int, z int);\n"
"INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);\n"
"\n"
"CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)\n"
"RETURNS SETOF record\n"
"AS $$\n"
"    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM sum_n_product_with_tab(10);\n"
" sum | product\n"
"-----+---------\n"
"  11 |      10\n"
"  13 |      30\n"
"  15 |      50\n"
"  17 |      70\n"
"(4 rows)"
msgstr ""
"CREATE TABLE tab (y int, z int);\n"
"INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);\n"
"\n"
"CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)\n"
"RETURNS SETOF record\n"
"AS $$\n"
"    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM sum_n_product_with_tab(10);\n"
" sum | product\n"
"-----+---------\n"
"  11 |      10\n"
"  13 |      30\n"
"  15 |      50\n"
"  17 |      70\n"
"(4 rows)"

#: xfunc.xml:886(para)
msgid ""
"It is also possible to return multiple rows with the columns defined by "
"output parameters, like this: <placeholder-1/> The key point here is that "
"you must write <literal>RETURNS SETOF record</literal> to indicate that the "
"function returns multiple rows instead of just one. If there is only one "
"output parameter, write that parameter's type instead of <type>record</type>."
msgstr ""
"Также возможно выдать несколько строк со столбцами, определяемыми выходными "
"параметрами, следующим образом: <placeholder-1/> Здесь ключевая особенность "
"заключается в записи <literal>RETURNS SETOF record</literal>, показывающей, "
"что функция возвращает множество строк вместо одной. Если существует только "
"один выходной параметр, укажите тип этого параметра вместо <type>record</"
"type>."

#: xfunc.xml:916(para)
msgid ""
"It is frequently useful to construct a query's result by invoking a set-"
"returning function multiple times, with the parameters for each invocation "
"coming from successive rows of a table or subquery. The preferred way to do "
"this is to use the <literal>LATERAL</literal> key word, which is described "
"in <xref linkend=\"queries-lateral\"/>. Here is an example using a set-"
"returning function to enumerate elements of a tree structure: <screen>\n"
"SELECT * FROM nodes;\n"
"   name    | parent\n"
"-----------+--------\n"
" Top       |\n"
" Child1    | Top\n"
" Child2    | Top\n"
" Child3    | Top\n"
" SubChild1 | Child1\n"
" SubChild2 | Child1\n"
"(6 rows)\n"
"\n"
"CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$\n"
"    SELECT name FROM nodes WHERE parent = $1\n"
"$$ LANGUAGE SQL STABLE;\n"
"\n"
"SELECT * FROM listchildren('Top');\n"
" listchildren\n"
"--------------\n"
" Child1\n"
" Child2\n"
" Child3\n"
"(3 rows)\n"
"\n"
"SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;\n"
"  name  |   child\n"
"--------+-----------\n"
" Top    | Child1\n"
" Top    | Child2\n"
" Top    | Child3\n"
" Child1 | SubChild1\n"
" Child1 | SubChild2\n"
"(5 rows)\n"
"</screen> This example does not do anything that we couldn't have done with "
"a simple join, but in more complex calculations the option to put some of "
"the work into a function can be quite convenient."
msgstr ""
"Часто бывает полезно сконструировать результат запроса, вызывая функцию, "
"возвращающую множество, несколько раз, передавая при каждом вызове параметры "
"из очередных строк таблицы или подзапроса. Для этого рекомендуется применить "
"ключевое слово <literal>LATERAL</literal>, описываемое в <xref remap=\"6\" "
"linkend=\"queries-lateral\"/>. Ниже приведён пример использования функции, "
"возвращающей множество, для перечисления элементов древовидной структуры: "
"<screen>\n"
"SELECT * FROM nodes;\n"
"   name    | parent\n"
"-----------+--------\n"
" Top       |\n"
" Child1    | Top\n"
" Child2    | Top\n"
" Child3    | Top\n"
" SubChild1 | Child1\n"
" SubChild2 | Child1\n"
"(6 rows)\n"
"\n"
"CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$\n"
"    SELECT name FROM nodes WHERE parent = $1\n"
"$$ LANGUAGE SQL STABLE;\n"
"\n"
"SELECT * FROM listchildren('Top');\n"
" listchildren\n"
"--------------\n"
" Child1\n"
" Child2\n"
" Child3\n"
"(3 rows)\n"
"\n"
"SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;\n"
"  name  |   child\n"
"--------+-----------\n"
" Top    | Child1\n"
" Top    | Child2\n"
" Top    | Child3\n"
" Child1 | SubChild1\n"
" Child1 | SubChild2\n"
"(5 rows)\n"
"</screen> В этом примере не делается ничего такого, что мы не могли бы "
"сделать, применив простое соединение, но для более сложных вычислений "
"возможность поместить некоторую логику в функцию может быть весьма удобной."

#: xfunc.xml:965(para)
msgid ""
"Currently, functions returning sets can also be called in the select list of "
"a query. For each row that the query generates by itself, the function "
"returning set is invoked, and an output row is generated for each element of "
"the function's result set. Note, however, that this capability is deprecated "
"and might be removed in future releases. The previous example could also be "
"done with queries like these: <screen>\n"
"SELECT listchildren('Top');\n"
" listchildren\n"
"--------------\n"
" Child1\n"
" Child2\n"
" Child3\n"
"(3 rows)\n"
"\n"
"SELECT name, listchildren(name) FROM nodes;\n"
"  name  | listchildren\n"
"--------+--------------\n"
" Top    | Child1\n"
" Top    | Child2\n"
" Top    | Child3\n"
" Child1 | SubChild1\n"
" Child1 | SubChild2\n"
"(5 rows)\n"
"</screen> In the last <command>SELECT</command>, notice that no output row "
"appears for <literal>Child2</literal>, <literal>Child3</literal>, etc. This "
"happens because <function>listchildren</function> returns an empty set for "
"those arguments, so no result rows are generated. This is the same behavior "
"as we got from an inner join to the function result when using the "
"<literal>LATERAL</literal> syntax."
msgstr ""
"В настоящее время функции, возвращающие множества, могут также вызываться в "
"списке выборки запроса. Для каждой строки, которая генерируется самим "
"запросом, вызывается функция, возвращающая множество, и для каждого элемента "
"набора её результатов генерируется отдельная строка. Заметьте, однако, что "
"эта возможность считается устаревшей и может быть ликвидирована в будущих "
"выпусках. Предыдущий пример можно было бы также переписать с применением "
"запросов следующим образом: <screen>\n"
"SELECT listchildren('Top');\n"
" listchildren\n"
"--------------\n"
" Child1\n"
" Child2\n"
" Child3\n"
"(3 rows)\n"
"\n"
"SELECT name, listchildren(name) FROM nodes;\n"
"  name  | listchildren\n"
"--------+--------------\n"
" Top    | Child1\n"
" Top    | Child2\n"
" Top    | Child3\n"
" Child1 | SubChild1\n"
" Child1 | SubChild2\n"
"(5 rows)\n"
"</screen> Заметьте, что в последней команде <command>SELECT</command> для "
"<literal>Child2</literal>, <literal>Child3</literal> и т. д. строки не "
"выдаются. Это происходит потому, что <function>listchildren</function> "
"возвращает пустое множество для этих аргументов, так что строки результата "
"не генерируются. Это же поведение мы получаем при внутреннем соединении с "
"результатом функции с применением <literal>LATERAL</literal>."

#: xfunc.xml:1003(para)
msgid ""
"If a function's last command is <command>INSERT</command>, <command>UPDATE</"
"command>, or <command>DELETE</command> with <literal>RETURNING</literal>, "
"that command will always be executed to completion, even if the function is "
"not declared with <literal>SETOF</literal> or the calling query does not "
"fetch all the result rows. Any extra rows produced by the "
"<literal>RETURNING</literal> clause are silently dropped, but the commanded "
"table modifications still happen (and are all completed before returning "
"from the function)."
msgstr ""
"Если последняя команда функции — <command>INSERT</command>, <command>UPDATE</"
"command> или <command>DELETE</command> с <literal>RETURNING</literal>, эта "
"команда будет всегда выполняться до завершения, даже если функция не "
"объявлена с указанием <literal>SETOF</literal> или вызывающий запрос не "
"выбирает все строки результата. Все дополнительные строки, выданные "
"предложением <literal>RETURNING</literal>, просто игнорируются, но "
"соответствующие изменения в таблице всё равно произойдут (и будут завершены "
"до выхода из функции)."

#: xfunc.xml:1015(para)
msgid ""
"The key problem with using set-returning functions in the select list, "
"rather than the <literal>FROM</literal> clause, is that putting more than "
"one set-returning function in the same select list does not behave very "
"sensibly. (What you actually get if you do so is a number of output rows "
"equal to the least common multiple of the numbers of rows produced by each "
"set-returning function.) The <literal>LATERAL</literal> syntax produces less "
"surprising results when calling multiple set-returning functions, and should "
"usually be used instead."
msgstr ""
"Ключевая проблема использования функций, возвращающих множества, в списке "
"выборки, а не в предложении <literal>FROM</literal>, заключается в том, что "
"при вызове в одном списке выборки нескольких таких функций, результат будет "
"не вполне разумным. (На самом деле, если вы сделаете это, вы получите "
"выходные строки в количестве, равном наименьшему общему кратному чисел "
"строк, которые будут выданы всеми функциями, возвращающими множества.) "
"Синтаксис <literal>LATERAL</literal> даёт более ожидаемые результаты при "
"вызове нескольких таких функций и поэтому рекомендуется использовать его."

#: xfunc.xml:1029(title)
msgid "<acronym>SQL</acronym> Functions Returning <literal>TABLE</literal>"
msgstr ""
"Функции <acronym>SQL</acronym>, возвращающие таблицы (<literal>TABLE</"
"literal>)"

#: xfunc.xml:1031(indexterm)
msgid "<primary>function</primary> <secondary>RETURNS TABLE</secondary>"
msgstr "<primary>функция</primary> <secondary>RETURNS TABLE</secondary>"

#: xfunc.xml:1036(para)
msgid ""
"There is another way to declare a function as returning a set, which is to "
"use the syntax <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</"
"literal>. This is equivalent to using one or more <literal>OUT</literal> "
"parameters plus marking the function as returning <literal>SETOF record</"
"literal> (or <literal>SETOF</literal> a single output parameter's type, as "
"appropriate). This notation is specified in recent versions of the SQL "
"standard, and thus may be more portable than using <literal>SETOF</literal>."
msgstr ""
"Есть ещё один способ объявить функцию, возвращающую множества, — "
"использовать синтаксис <literal>RETURNS TABLE(<replaceable>столбцы</"
"replaceable>)</literal>. Это равнозначно использованию одного или нескольких "
"параметров <literal>OUT</literal> с объявлением функции как возвращающей "
"<literal>SETOF record</literal> (или <literal>SETOF</literal> тип "
"единственного параметра, если это применимо). Этот синтаксис описан в "
"последних версиях стандарта SQL, так что этот вариант может быть более "
"портируемым, чем <literal>SETOF</literal>."

#: xfunc.xml:1051(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION sum_n_product_with_tab (x int)\n"
"RETURNS TABLE(sum int, product int) AS $$\n"
"    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION sum_n_product_with_tab (x int)\n"
"RETURNS TABLE(sum int, product int) AS $$\n"
"    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n"
"$$ LANGUAGE SQL;"

#: xfunc.xml:1047(para)
msgid ""
"For example, the preceding sum-and-product example could also be done this "
"way: <placeholder-1/> It is not allowed to use explicit <literal>OUT</"
"literal> or <literal>INOUT</literal> parameters with the <literal>RETURNS "
"TABLE</literal> notation &mdash; you must put all the output columns in the "
"<literal>TABLE</literal> list."
msgstr ""
"Например, предыдущий пример с суммой и произведением можно также переписать "
"так: <placeholder-1/> Запись <literal>RETURNS TABLE</literal> не позволяет "
"явно указывать <literal>OUT</literal> и <literal>INOUT</literal> для "
"параметров &mdash; все выходные столбцы необходимо записать в списке "
"<literal>TABLE</literal>."

#: xfunc.xml:1065(title)
msgid "Polymorphic <acronym>SQL</acronym> Functions"
msgstr "Полиморфные функции <acronym>SQL</acronym>"

#: xfunc.xml:1067(para)
msgid ""
"<acronym>SQL</acronym> functions can be declared to accept and return the "
"polymorphic types <type>anyelement</type>, <type>anyarray</type>, "
"<type>anynonarray</type>, <type>anyenum</type>, and <type>anyrange</type>. "
"See <xref linkend=\"extend-types-polymorphic\"/> for a more detailed "
"explanation of polymorphic functions. Here is a polymorphic function "
"<function>make_array</function> that builds up an array from two arbitrary "
"data type elements: <screen>\n"
"CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$\n"
"    SELECT ARRAY[$1, $2];\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS "
"textarray;\n"
" intarray | textarray\n"
"----------+-----------\n"
" {1,2}    | {a,b}\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Функции <acronym>SQL</acronym> могут быть объявлены как принимающие и "
"возвращающие полиморфные типы <type>anyelement</type>, <type>anyarray</"
"type>, <type>anynonarray</type>, <type>anyenum</type> и <type>anyrange</"
"type>. За более подробным объяснением полиморфизма функций обратитесь к "
"<xref remap=\"3\" linkend=\"extend-types-polymorphic\"/>. В следующем "
"примере полиморфная функция <function>make_array</function> создаёт массив "
"из двух элементов произвольных типов: <screen>\n"
"CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$\n"
"    SELECT ARRAY[$1, $2];\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS "
"textarray;\n"
" intarray | textarray\n"
"----------+-----------\n"
" {1,2}    | {a,b}\n"
"(1 row)\n"
"</screen>"

#: xfunc.xml:1089(para)
msgid ""
"Notice the use of the typecast <literal>'a'::text</literal> to specify that "
"the argument is of type <type>text</type>. This is required if the argument "
"is just a string literal, since otherwise it would be treated as type "
"<type>unknown</type>, and array of <type>unknown</type> is not a valid type. "
"Without the typecast, you will get errors like this: <screen>\n"
"<computeroutput>\n"
"ERROR:  could not determine polymorphic type because input has type \"unknown"
"\"\n"
"</computeroutput>\n"
"</screen>"
msgstr ""
"Обратите внимание на приведение типа <literal>'a'::text</literal>, "
"определяющее, что аргумент имеет тип <type>text</type>. Оно необходимо, если "
"аргумент задаётся просто строковой константой, так как иначе он будет "
"воспринят как имеющий тип <type>unknown</type>, а массив типов "
"<type>unknown</type> является недопустимым. Без этого приведения вы получите "
"такую ошибку: <screen>\n"
"<computeroutput>\n"
"ERROR:  could not determine polymorphic type because input has type \"unknown"
"\"\n"
"</computeroutput>\n"
"</screen> (ОШИБКА:  не удалось определить полиморфный тип, так как входные "
"аргументы имеют тип \"unknown\")"

#: xfunc.xml:1104(para)
msgid ""
"It is permitted to have polymorphic arguments with a fixed return type, but "
"the converse is not. For example: <screen>\n"
"CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$\n"
"    SELECT $1 &gt; $2;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT is_greater(1, 2);\n"
" is_greater\n"
"------------\n"
" f\n"
"(1 row)\n"
"\n"
"CREATE FUNCTION invalid_func() RETURNS anyelement AS $$\n"
"    SELECT 1;\n"
"$$ LANGUAGE SQL;\n"
"ERROR:  cannot determine result data type\n"
"DETAIL:  A function returning a polymorphic type must have at least one "
"polymorphic argument.\n"
"</screen>"
msgstr ""
"Функция с полиморфными аргументами может иметь фиксированный тип результата, "
"однако обратное не допускается. Например: <screen>\n"
"CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$\n"
"    SELECT $1 &gt; $2;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT is_greater(1, 2);\n"
" is_greater\n"
"------------\n"
" f\n"
"(1 row)\n"
"\n"
"CREATE FUNCTION invalid_func() RETURNS anyelement AS $$\n"
"    SELECT 1;\n"
"$$ LANGUAGE SQL;\n"
"ERROR:  cannot determine result data type\n"
"DETAIL:  A function returning a polymorphic type must have at least one "
"polymorphic argument.\n"
"</screen> (ОШИБКА: не удалось определить тип результата; ПОДРОБНОСТИ: "
"Функция, возвращающая полиморфный тип, должна иметь минимум один полиморфный "
"аргумент.\")"

#: xfunc.xml:1126(para)
msgid ""
"Polymorphism can be used with functions that have output arguments. For "
"example: <screen>\n"
"CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)\n"
"AS 'select $1, array[$1,$1]' LANGUAGE SQL;\n"
"\n"
"SELECT * FROM dup(22);\n"
" f2 |   f3\n"
"----+---------\n"
" 22 | {22,22}\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Полиморфизм можно применять и с функциями, имеющими выходные аргументы. "
"Например: <screen>\n"
"CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)\n"
"AS 'select $1, array[$1,$1]' LANGUAGE SQL;\n"
"\n"
"SELECT * FROM dup(22);\n"
" f2 |   f3\n"
"----+---------\n"
" 22 | {22,22}\n"
"(1 row)\n"
"</screen>"

#: xfunc.xml:1141(para)
msgid ""
"Polymorphism can also be used with variadic functions. For example: "
"<screen>\n"
"CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$\n"
"    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT anyleast(10, -1, 5, 4);\n"
" anyleast \n"
"----------\n"
"       -1\n"
"(1 row)\n"
"\n"
"SELECT anyleast('abc'::text, 'def');\n"
" anyleast \n"
"----------\n"
" abc\n"
"(1 row)\n"
"\n"
"CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$\n"
"    SELECT array_to_string($2, $1);\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT concat_values('|', 1, 4, 2);\n"
" concat_values \n"
"---------------\n"
" 1|4|2\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Полиморфизм также можно применять с функциями с переменными параметрами. "
"Например: <screen>\n"
"CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$\n"
"    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT anyleast(10, -1, 5, 4);\n"
" anyleast \n"
"----------\n"
"       -1\n"
"(1 row)\n"
"\n"
"SELECT anyleast('abc'::text, 'def');\n"
" anyleast \n"
"----------\n"
" abc\n"
"(1 row)\n"
"\n"
"CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$\n"
"    SELECT array_to_string($2, $1);\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT concat_values('|', 1, 4, 2);\n"
" concat_values \n"
"---------------\n"
" 1|4|2\n"
"(1 row)\n"
"</screen>"

#: xfunc.xml:1175(title)
msgid "<acronym>SQL</acronym> Functions with Collations"
msgstr "Функции <acronym>SQL</acronym> с правилами сортировки"

#: xfunc.xml:1177(indexterm)
msgid "<primary>collation</primary> <secondary>in SQL functions</secondary>"
msgstr ""
"<primary>правила сортировки</primary> <secondary>в функциях SQL</secondary>"

#: xfunc.xml:1192(programlisting)
#, no-wrap
msgid "SELECT anyleast('abc'::text, 'ABC');"
msgstr "SELECT anyleast('abc'::text, 'ABC');"

#: xfunc.xml:1199(programlisting)
#, no-wrap
msgid "SELECT anyleast('abc'::text, 'ABC' COLLATE \"C\");"
msgstr "SELECT anyleast('abc'::text, 'ABC' COLLATE \"C\");"

#: xfunc.xml:1207(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$\n"
"    SELECT min($1[i] COLLATE \"en_US\") FROM generate_subscripts($1, 1) g(i);\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$\n"
"    SELECT min($1[i] COLLATE \"en_US\") FROM generate_subscripts($1, 1) g(i);\n"
"$$ LANGUAGE SQL;"

#: xfunc.xml:1182(para)
msgid ""
"When a SQL function has one or more parameters of collatable data types, a "
"collation is identified for each function call depending on the collations "
"assigned to the actual arguments, as described in <xref linkend=\"collation"
"\"/>. If a collation is successfully identified (i.e., there are no "
"conflicts of implicit collations among the arguments) then all the "
"collatable parameters are treated as having that collation implicitly. This "
"will affect the behavior of collation-sensitive operations within the "
"function. For example, using the <function>anyleast</function> function "
"described above, the result of <placeholder-1/> will depend on the "
"database's default collation. In <literal>C</literal> locale the result will "
"be <literal>ABC</literal>, but in many other locales it will be "
"<literal>abc</literal>. The collation to use can be forced by adding a "
"<literal>COLLATE</literal> clause to any of the arguments, for example "
"<placeholder-2/> Alternatively, if you wish a function to operate with a "
"particular collation regardless of what it is called with, insert "
"<literal>COLLATE</literal> clauses as needed in the function definition. "
"This version of <function>anyleast</function> would always use "
"<literal>en_US</literal> locale to compare strings: <placeholder-3/> But "
"note that this will throw an error if applied to a non-collatable data type."
msgstr ""
"Когда функция SQL принимает один или несколько параметров сортируемых типов "
"данных, правило сортировки определяется при каждом вызове функции, в "
"зависимости от правил сортировки, связанных с фактическими аргументами, как "
"описано в <xref remap=\"6\" linkend=\"collation\"/>. Если правило сортировки "
"определено успешно (то есть не возникло конфликтов между неявно "
"установленными правилами сортировки аргументов), оно неявно назначается для "
"всех сортируемых параметров. Выбранное правило будет определять поведение "
"операций, связанных с сортировкой, в данной функции. Например, для "
"показанной выше функции <function>anyleast</function>, результат "
"<placeholder-1/> будет зависеть от правила сортировки по умолчанию, "
"заданного в базе данных. С локалью <literal>C</literal> результатом будет "
"строка <literal>ABC</literal>, но со многими другими локалями это будет "
"<literal>abc</literal>. Нужное правило сортировки можно установить "
"принудительно, добавив предложение <literal>COLLATE</literal> к одному из "
"аргументов функции, например: <placeholder-2/> С другой стороны, если вы "
"хотите, чтобы функция работала с определённым правилом сортировки, вне "
"зависимости от того, с каким она была вызвана, вставьте предложения "
"<literal>COLLATE</literal> где требуется в определении функции. Эта версия "
"<function>anyleast</function> всегда будет сравнивать строки по правилам "
"локали <literal>en_US</literal>: <placeholder-3/> Но заметьте, что при "
"попытке применить правило к несортируемому типу данных, возникнет ошибка."

#: xfunc.xml:1216(para)
msgid ""
"If no common collation can be identified among the actual arguments, then a "
"SQL function treats its parameters as having their data types' default "
"collation (which is usually the database's default collation, but could be "
"different for parameters of domain types)."
msgstr ""
"Если для фактических аргументов не удаётся определить общее правило "
"сортировки, функция SQL считает, что им назначено правило сортировки по "
"умолчанию для их типа данных (обычно это то же правило сортировки, что "
"определено по умолчанию для базы данных, но оно может быть и другим для "
"параметров доменных типов)."

#: xfunc.xml:1223(para)
msgid ""
"The behavior of collatable parameters can be thought of as a limited form of "
"polymorphism, applicable only to textual data types."
msgstr ""
"Поведение сортируемых параметров можно воспринимать как ограниченную форму "
"полиморфизма, применимую только к текстовым типам данных."

#: xfunc.xml:1231(title)
msgid "Function Overloading"
msgstr "Перегрузка функций"

#: xfunc.xml:1233(indexterm)
msgid "<primary>overloading</primary> <secondary>functions</secondary>"
msgstr "<primary>перегрузка</primary> <secondary>функций</secondary>"

#: xfunc.xml:1238(para)
msgid ""
"More than one function can be defined with the same SQL name, so long as the "
"arguments they take are different. In other words, function names can be "
"<firstterm>overloaded</firstterm>. When a query is executed, the server will "
"determine which function to call from the data types and the number of the "
"provided arguments. Overloading can also be used to simulate functions with "
"a variable number of arguments, up to a finite maximum number."
msgstr ""
"Вы можете определить несколько функций с одним именем SQL, если эти функции "
"будут принимать разные аргументы. Другими словами, имена функций можно "
"<firstterm>перегружать</firstterm>. Когда выполняется запрос, сервер "
"определяет, какую именно функцию вызывать, по количеству и типам "
"представленных аргументов. Перегрузка может быть полезна для имитации "
"функций с переменным количеством аргументов, до какого-то конечного числа."

#: xfunc.xml:1252(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test(int, real) RETURNS ...\n"
"CREATE FUNCTION test(smallint, double precision) RETURNS ..."
msgstr ""
"CREATE FUNCTION test(int, real) RETURNS ...\n"
"CREATE FUNCTION test(smallint, double precision) RETURNS ..."

#: xfunc.xml:1248(para)
msgid ""
"When creating a family of overloaded functions, one should be careful not to "
"create ambiguities. For instance, given the functions: <placeholder-1/> it "
"is not immediately clear which function would be called with some trivial "
"input like <literal>test(1, 1.5)</literal>. The currently implemented "
"resolution rules are described in <xref linkend=\"typeconv\"/>, but it is "
"unwise to design a system that subtly relies on this behavior."
msgstr ""
"Создавая семейство перегруженных функций, необходимо не допускать "
"неоднозначности. Например, если созданы функции: <placeholder-1/> не вполне "
"понятно, какая функция будет вызвана с довольно простыми аргументами вроде "
"<literal>test(1, 1.5)</literal>. Реализованные в данный момент правила "
"разрешения типов описаны в <xref remap=\"6\" linkend=\"typeconv\"/>, но "
"разрабатывать систему, которая будет незаметно полагаться на такие "
"особенности, неразумно."

#: xfunc.xml:1263(para)
msgid ""
"A function that takes a single argument of a composite type should generally "
"not have the same name as any attribute (field) of that type. Recall that "
"<literal><replaceable>attribute</replaceable>(<replaceable>table</"
"replaceable>)</literal> is considered equivalent to "
"<literal><replaceable>table</replaceable>.<replaceable>attribute</"
"replaceable></literal>. In the case that there is an ambiguity between a "
"function on a composite type and an attribute of the composite type, the "
"attribute will always be used. It is possible to override that choice by "
"schema-qualifying the function name (that is, <literal><replaceable>schema</"
"replaceable>.<replaceable>func</replaceable>(<replaceable>table</"
"replaceable>) </literal>) but it's better to avoid the problem by not "
"choosing conflicting names."
msgstr ""
"Функции, принимающей один аргумент составного типа, обычно не следует давать "
"имя, совпадающее с именем какого-либо атрибута (поля) этого типа. Вспомните, "
"что запись <literal><replaceable>атрибут</replaceable>(<replaceable>таблица</"
"replaceable>)</literal> считается равнозначной "
"<literal><replaceable>таблица</replaceable>.<replaceable>атрибут</"
"replaceable></literal>. В случае, когда возникает неоднозначность между "
"функцией, принимающей составной тип, и атрибутом составного типа, всегда "
"будет выбираться атрибут. Этот выбор можно переопределить, дополнив имя "
"функции схемой (то есть, записав <literal><replaceable>схема</replaceable>."
"<replaceable>функция</replaceable>(<replaceable>таблица</replaceable>) </"
"literal>), но лучше избежать этой проблемы, подобрав разные имена."

#: xfunc.xml:1278(para)
msgid ""
"Another possible conflict is between variadic and non-variadic functions. "
"For instance, it is possible to create both <literal>foo(numeric)</literal> "
"and <literal>foo(VARIADIC numeric[])</literal>. In this case it is unclear "
"which one should be matched to a call providing a single numeric argument, "
"such as <literal>foo(10.1)</literal>. The rule is that the function "
"appearing earlier in the search path is used, or if the two functions are in "
"the same schema, the non-variadic one is preferred."
msgstr ""
"Другой тип конфликта возможен между обычными функциями и функциями с "
"переменными параметрами. Например, можно создать функции "
"<literal>foo(numeric)</literal> и <literal>foo(VARIADIC numeric[])</"
"literal>. В этом случае будет непонятно, какая функция должна выбираться при "
"передаче одного числового аргумента, например <literal>foo(10.1)</literal>. "
"При разрешении этого конфликта предпочтение отдаётся функции, найденной "
"первой по пути поиска, либо, если две функции находятся в одной схеме, "
"выбирается функция с постоянными аргументами."

#: xfunc.xml:1299(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test(int) RETURNS int\n"
"    AS '<replaceable>filename</replaceable>', 'test_1arg'\n"
"    LANGUAGE C;\n"
"CREATE FUNCTION test(int, int) RETURNS int\n"
"    AS '<replaceable>filename</replaceable>', 'test_2arg'\n"
"    LANGUAGE C;"
msgstr ""
"CREATE FUNCTION test(int) RETURNS int\n"
"    AS '<replaceable>имя_файла</replaceable>', 'test_1arg'\n"
"    LANGUAGE C;\n"
"CREATE FUNCTION test(int, int) RETURNS int\n"
"    AS '<replaceable>имя_файла</replaceable>', 'test_2arg'\n"
"    LANGUAGE C;"

#: xfunc.xml:1288(para)
msgid ""
"When overloading C-language functions, there is an additional constraint: "
"The C name of each function in the family of overloaded functions must be "
"different from the C names of all other functions, either internal or "
"dynamically loaded. If this rule is violated, the behavior is not portable. "
"You might get a run-time linker error, or one of the functions will get "
"called (usually the internal one). The alternative form of the <literal>AS</"
"literal> clause for the SQL <command>CREATE FUNCTION</command> command "
"decouples the SQL function name from the function name in the C source code. "
"For instance: <placeholder-1/> The names of the C functions here reflect one "
"of many possible conventions."
msgstr ""
"При перегрузке функций на языке C есть дополнительное ограничение: имя "
"уровня C каждой функции в семействе перегруженных функций должно отличаться "
"от имён уровня C всех других функций, как внутренних, так и загружаемых "
"динамически. Если это правило нарушается, поведение зависит от среды. Вы "
"можете получить ошибку компоновщика во время выполнения, либо будет вызвана "
"не та функция (обычно внутренняя). Альтернативная форма предложения "
"<literal>AS</literal> для SQL-команды <command>CREATE FUNCTION</command> "
"позволяет отвязать имя SQL-функции от имени, определённого в исходном коде "
"на C. Например: <placeholder-1/> Имена функций на C здесь следуют одному из "
"множества возможных соглашений."

#: xfunc.xml:1312(title)
msgid "Function Volatility Categories"
msgstr "Категории изменчивости функций"

#: xfunc.xml:1314(indexterm)
msgid "<primary>volatility</primary> <secondary>functions</secondary>"
msgstr "<primary>изменчивость</primary> <secondary>функций</secondary>"

#: xfunc.xml:1318(indexterm)
msgid "<primary>VOLATILE</primary>"
msgstr "<primary>VOLATILE</primary>"

#: xfunc.xml:1321(indexterm)
msgid "<primary>STABLE</primary>"
msgstr "<primary>STABLE</primary>"

#: xfunc.xml:1324(indexterm)
msgid "<primary>IMMUTABLE</primary>"
msgstr "<primary>IMMUTABLE</primary>"

#: xfunc.xml:1338(para)
msgid ""
"A <literal>VOLATILE</literal> function can do anything, including modifying "
"the database. It can return different results on successive calls with the "
"same arguments. The optimizer makes no assumptions about the behavior of "
"such functions. A query using a volatile function will re-evaluate the "
"function at every row where its value is needed."
msgstr ""
"Изменчивая функция (<literal>VOLATILE</literal>) может делать всё, что "
"угодно, в том числе, модифицировать базу данных. Она может возвращать "
"различные результаты при нескольких вызовах с одинаковыми аргументами. "
"Оптимизатор не делает никаких предположений о поведении таких функций. В "
"запросе, использующем изменчивую функцию, она будет вычисляться заново для "
"каждой строки, когда потребуется её результат."

#: xfunc.xml:1347(para)
msgid ""
"A <literal>STABLE</literal> function cannot modify the database and is "
"guaranteed to return the same results given the same arguments for all rows "
"within a single statement. This category allows the optimizer to optimize "
"multiple calls of the function to a single call. In particular, it is safe "
"to use an expression containing such a function in an index scan condition. "
"(Since an index scan will evaluate the comparison value only once, not once "
"at each row, it is not valid to use a <literal>VOLATILE</literal> function "
"in an index scan condition.)"
msgstr ""
"Стабильная функция (<literal>STABLE</literal>) не может модифицировать базу "
"данных и гарантированно возвращает одинаковый результат, получая одинаковые "
"аргументы, для всех строк в одном операторе. Эта характеристика позволяет "
"оптимизатору заменить множество вызовов этой функции одним. В частности, "
"выражение, содержащее такую функцию, можно безопасно использовать в условии "
"поиска по индексу. (Так как при поиске по индексу целевое значение "
"вычисляется только один раз, а не для каждой строки, использовать функцию с "
"характеристикой <literal>VOLATILE</literal> в условии поиска по индексу "
"нельзя.)"

#: xfunc.xml:1360(para)
msgid ""
"An <literal>IMMUTABLE</literal> function cannot modify the database and is "
"guaranteed to return the same results given the same arguments forever. This "
"category allows the optimizer to pre-evaluate the function when a query "
"calls it with constant arguments. For example, a query like "
"<literal>SELECT ... WHERE x = 2 + 2</literal> can be simplified on sight to "
"<literal>SELECT ... WHERE x = 4</literal>, because the function underlying "
"the integer addition operator is marked <literal>IMMUTABLE</literal>."
msgstr ""
"Постоянная функция (<literal>IMMUTABLE</literal>) не может модифицировать "
"базу данных и гарантированно всегда возвращает одинаковые результаты для "
"одних и тех же аргументов. Эта характеристика позволяет оптимизатору "
"предварительно вычислить функцию, когда она вызывается в запросе с "
"постоянными аргументами. Например, запрос вида <literal>SELECT ... WHERE x = "
"2 + 2</literal> можно упростить до <literal>SELECT ... WHERE x = 4</"
"literal>, так как нижележащая функция оператора сложения помечена как "
"<literal>IMMUTABLE</literal>."

#: xfunc.xml:1328(para)
msgid ""
"Every function has a <firstterm>volatility</firstterm> classification, with "
"the possibilities being <literal>VOLATILE</literal>, <literal>STABLE</"
"literal>, or <literal>IMMUTABLE</literal>. <literal>VOLATILE</literal> is "
"the default if the <xref linkend=\"sql-createfunction\"/> command does not "
"specify a category. The volatility category is a promise to the optimizer "
"about the behavior of the function: <placeholder-1/>"
msgstr ""
"Для каждой функции определяется характеристика <firstterm>изменчивости</"
"firstterm>, с возможными вариантами: <literal>VOLATILE</literal>, "
"<literal>STABLE</literal> и <literal>IMMUTABLE</literal>. Если эта "
"характеристика не задаётся явно в команде <xref linkend=\"sql-createfunction"
"\"/>, по умолчанию подразумевается <literal>VOLATILE</literal>. Категория "
"изменчивости представляет собой обещание некоторого поведения функции для "
"оптимизатора: <placeholder-1/>"

#: xfunc.xml:1373(para)
msgid ""
"For best optimization results, you should label your functions with the "
"strictest volatility category that is valid for them."
msgstr ""
"Для наилучших результатов оптимизации, функции следует назначать самую "
"строгую характеристику изменчивости, которой она соответствует."

#: xfunc.xml:1378(para)
msgid ""
"Any function with side-effects <emphasis>must</emphasis> be labeled "
"<literal>VOLATILE</literal>, so that calls to it cannot be optimized away. "
"Even a function with no side-effects needs to be labeled <literal>VOLATILE</"
"literal> if its value can change within a single query; some examples are "
"<literal>random()</literal>, <literal>currval()</literal>, "
"<literal>timeofday()</literal>."
msgstr ""
"Любая функция с побочными эффектами <emphasis>должна</emphasis> быть "
"помечена как <literal>VOLATILE</literal>, чтобы обращения к ней не "
"исключались при оптимизации. Даже если функция не имеет побочных эффектов, "
"её нужно пометить как <literal>VOLATILE</literal>, если её значение может "
"меняться при выполнении одного запроса; таковы функции <literal>random()</"
"literal>, <literal>currval()</literal> и <literal>timeofday()</literal>."

#: xfunc.xml:1387(para)
msgid ""
"Another important example is that the <function>current_timestamp</function> "
"family of functions qualify as <literal>STABLE</literal>, since their values "
"do not change within a transaction."
msgstr ""
"Другой важный пример представляет семейство функций "
"<function>current_timestamp</function>, которые имеют характеристику "
"<literal>STABLE</literal>, потому что их значения не меняются в рамках одной "
"транзакции."

#: xfunc.xml:1393(para)
msgid ""
"There is relatively little difference between <literal>STABLE</literal> and "
"<literal>IMMUTABLE</literal> categories when considering simple interactive "
"queries that are planned and immediately executed: it doesn't matter a lot "
"whether a function is executed once during planning or once during query "
"execution startup. But there is a big difference if the plan is saved and "
"reused later. Labeling a function <literal>IMMUTABLE</literal> when it "
"really isn't might allow it to be prematurely folded to a constant during "
"planning, resulting in a stale value being re-used during subsequent uses of "
"the plan. This is a hazard when using prepared statements or when using "
"function languages that cache plans (such as <application>PL/pgSQL</"
"application>)."
msgstr ""
"Характеристики <literal>STABLE</literal> и <literal>IMMUTABLE</literal> мало "
"различаются, когда речь идёт о простых интерактивных запросах, которые "
"планируются и сразу же выполняются; не имеет большого значения, будет ли "
"функция выполнена однократно на этапе планирования или в начале выполнения. "
"Существенное различие проявляется, когда план сохраняется и многократно "
"используется позже. Если функция помечена как <literal>IMMUTABLE</literal>, "
"тогда как на самом деле она не является постоянной, она может быть сведена к "
"константе во время планирования, так что при последующих выполнениях плана "
"вместо неё будет использоваться неактуальное значение. Это опасно при "
"использовании подготовленных операторов или языков функций, кеширующих планы "
"(например, <application>PL/pgSQL</application>)."

#: xfunc.xml:1407(para)
msgid ""
"For functions written in SQL or in any of the standard procedural languages, "
"there is a second important property determined by the volatility category, "
"namely the visibility of any data changes that have been made by the SQL "
"command that is calling the function. A <literal>VOLATILE</literal> function "
"will see such changes, a <literal>STABLE</literal> or <literal>IMMUTABLE</"
"literal> function will not. This behavior is implemented using the "
"snapshotting behavior of MVCC (see <xref linkend=\"mvcc\"/>): "
"<literal>STABLE</literal> and <literal>IMMUTABLE</literal> functions use a "
"snapshot established as of the start of the calling query, whereas "
"<literal>VOLATILE</literal> functions obtain a fresh snapshot at the start "
"of each query they execute."
msgstr ""
"У функций, написанных на SQL или на любом другом стандартном процедурном "
"языке, есть ещё одно важное свойство, определяемое характеристикой "
"изменчивости, а именно видимость изменений, произведённых командой SQL, "
"которая вызывает эту функцию. Функция <literal>VOLATILE</literal> будет "
"видеть такие изменения, тогда как <literal>STABLE</literal> и "
"<literal>IMMUTABLE</literal> — нет. Это поведение реализуется посредством "
"снимков в MVCC (см. <xref remap=\"4\" linkend=\"mvcc\"/>): <literal>STABLE</"
"literal> и <literal>IMMUTABLE</literal> используют снимок, полученный в "
"начале вызывающего запроса, тогда как функции <literal>VOLATILE</literal> "
"получают свежий снимок в начале каждого запроса, который они выполняют."

#: xfunc.xml:1422(para)
msgid ""
"Functions written in C can manage snapshots however they want, but it's "
"usually a good idea to make C functions work this way too."
msgstr ""
"Функции, написанные на C, могут работать со снимками как угодно, но обычно "
"лучше сделать так, чтобы они действовали аналогично."

#: xfunc.xml:1428(para)
msgid ""
"Because of this snapshotting behavior, a function containing only "
"<command>SELECT</command> commands can safely be marked <literal>STABLE</"
"literal>, even if it selects from tables that might be undergoing "
"modifications by concurrent queries. <productname>PostgreSQL</productname> "
"will execute all commands of a <literal>STABLE</literal> function using the "
"snapshot established for the calling query, and so it will see a fixed view "
"of the database throughout that query."
msgstr ""
"Вследствие такой организации работы со снимками, функцию, содержащую только "
"команды <command>SELECT</command>, можно безопасно пометить как "
"<literal>STABLE</literal>, даже если она выбирает данные из таблиц, которые "
"могут быть изменены параллельными запросами. <productname>PostgreSQL</"
"productname> выполнит все команды в функции <literal>STABLE</literal> со "
"снимком, полученным для вызывающего запроса, так что они будут видеть одно "
"представление базы данных на протяжении всего запроса."

#: xfunc.xml:1439(para)
msgid ""
"The same snapshotting behavior is used for <command>SELECT</command> "
"commands within <literal>IMMUTABLE</literal> functions. It is generally "
"unwise to select from database tables within an <literal>IMMUTABLE</literal> "
"function at all, since the immutability will be broken if the table contents "
"ever change. However, <productname>PostgreSQL</productname> does not enforce "
"that you do not do that."
msgstr ""
"То же самое поведение со снимками распространяется на команды "
"<command>SELECT</command> в функциях <literal>IMMUTABLE</literal>. Вообще в "
"функциях <literal>IMMUTABLE</literal> обычно неразумно выбирать данные из "
"таблиц, так как &laquo;постоянство&raquo; функции будет нарушено, если "
"содержимое таблиц изменится. Однако <productname>PostgreSQL</productname> не "
"принуждает вас явно отказаться от этого."

#: xfunc.xml:1448(para)
msgid ""
"A common error is to label a function <literal>IMMUTABLE</literal> when its "
"results depend on a configuration parameter. For example, a function that "
"manipulates timestamps might well have results that depend on the <xref "
"linkend=\"guc-timezone\"/> setting. For safety, such functions should be "
"labeled <literal>STABLE</literal> instead."
msgstr ""
"Одна из распространённых ошибок — помечать функцию как <literal>IMMUTABLE</"
"literal>, при том, что её результаты зависят от параметра конфигурации. "
"Например, функция, работающая с временем, может выдавать результаты, "
"зависящие от параметра <xref linkend=\"guc-timezone\"/>. Для надёжности "
"такие функции следует помечать как <literal>STABLE</literal>."

#: xfunc.xml:1457(para)
msgid ""
"<productname>PostgreSQL</productname> requires that <literal>STABLE</"
"literal> and <literal>IMMUTABLE</literal> functions contain no SQL commands "
"other than <command>SELECT</command> to prevent data modification. (This is "
"not a completely bulletproof test, since such functions could still call "
"<literal>VOLATILE</literal> functions that modify the database. If you do "
"that, you will find that the <literal>STABLE</literal> or "
"<literal>IMMUTABLE</literal> function does not notice the database changes "
"applied by the called function, since they are hidden from its snapshot.)"
msgstr ""
"<productname>PostgreSQL</productname> требует, чтобы функции "
"<literal>STABLE</literal> и <literal>IMMUTABLE</literal> не содержали SQL-"
"команд, кроме <command>SELECT</command>, для предотвращения модификации "
"данных. (Это не совсем непробиваемое ограничение, так как эти функции всё же "
"могут вызывать функции <literal>VOLATILE</literal>, способные модифицировать "
"базу данных. Если вы реализуете такую схему, вы увидите, что функция "
"<literal>STABLE</literal> и <literal>IMMUTABLE</literal> не замечает "
"изменений в базе данных, произведённых вызванной функцией, так как они не "
"проявляются в её снимке данных.)"

#: xfunc.xml:1471(title)
msgid "Procedural Language Functions"
msgstr "Функции на процедурных языках"

#: xfunc.xml:1473(para)
msgid ""
"<productname>PostgreSQL</productname> allows user-defined functions to be "
"written in other languages besides SQL and C. These other languages are "
"generically called <firstterm>procedural languages</firstterm> (<acronym>PL</"
"acronym>s). Procedural languages aren't built into the "
"<productname>PostgreSQL</productname> server; they are offered by loadable "
"modules. See <xref linkend=\"xplang\"/> and following chapters for more "
"information."
msgstr ""
"<productname>PostgreSQL</productname> позволяет разрабатывать собственные "
"функции и на языках, отличных от SQL и C. Эти другие языки в целом обычно "
"называются <firstterm>процедурными языками</firstterm> (<acronym>PL</"
"acronym>, Procedural Languages). Процедурные языки не встроены в сервер "
"<productname>PostgreSQL</productname>; они предлагаются загружаемыми "
"модулями. За дополнительной информацией обратитесь к <xref remap=\"3\" "
"linkend=\"xplang\"/> и следующим главам."

#: xfunc.xml:1487(title)
msgid "Internal Functions"
msgstr "Внутренние функции"

#: xfunc.xml:1489(indexterm)
msgid "<primary>function</primary><secondary>internal</secondary>"
msgstr "<primary>функция</primary> <secondary>внутренняя</secondary>"

#: xfunc.xml:1491(para)
msgid ""
"Internal functions are functions written in C that have been statically "
"linked into the <productname>PostgreSQL</productname> server. The "
"<quote>body</quote> of the function definition specifies the C-language name "
"of the function, which need not be the same as the name being declared for "
"SQL use. (For reasons of backward compatibility, an empty body is accepted "
"as meaning that the C-language function name is the same as the SQL name.)"
msgstr ""
"Внутренние функции — это функции, написанные на языке C, и статически "
"скомпонованные в исполняемый код сервера <productname>PostgreSQL</"
"productname>. В <quote>теле</quote> определения функции задаётся имя функции "
"на уровне C, которое не обязательно должно совпадать с именем, объявленным "
"для использования в SQL. (Обратной совместимости ради, тело функции может "
"быть пустым, что будет означать, что имя функции на уровне C совпадает с "
"именем в SQL.)"

#: xfunc.xml:1511(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION square_root(double precision) RETURNS double precision\n"
"    AS 'dsqrt'\n"
"    LANGUAGE internal\n"
"    STRICT;"
msgstr ""
"CREATE FUNCTION square_root(double precision) RETURNS double precision\n"
"    AS 'dsqrt'\n"
"    LANGUAGE internal\n"
"    STRICT;"

#: xfunc.xml:1502(para)
msgid ""
"Normally, all internal functions present in the server are declared during "
"the initialization of the database cluster (see <xref linkend=\"creating-"
"cluster\"/>), but a user could use <command>CREATE FUNCTION</command> to "
"create additional alias names for an internal function. Internal functions "
"are declared in <command>CREATE FUNCTION</command> with language name "
"<literal>internal</literal>. For instance, to create an alias for the "
"<function>sqrt</function> function: <placeholder-1/> (Most internal "
"functions expect to be declared <quote>strict</quote>.)"
msgstr ""
"Обычно все внутренние функции, представленные на сервере, объявляются в ходе "
"инициализации кластера баз данных (см. <xref remap=\"4\" linkend=\"creating-"
"cluster\"/>), но пользователь может воспользоваться командой <command>CREATE "
"FUNCTION</command> и добавить дополнительные псевдонимы для внутренней "
"функции. Внутренние функции объявляются в <command>CREATE FUNCTION</command> "
"с именем языка <literal>internal</literal>. Например, так можно создать "
"псевдоним для функции <function>sqrt</function>: <placeholder-1/> "
"(Большинство внутренних функций должны объявляться как <quote>strict</"
"quote>.)"

#: xfunc.xml:1521(para)
msgid ""
"Not all <quote>predefined</quote> functions are <quote>internal</quote> in "
"the above sense. Some predefined functions are written in SQL."
msgstr ""
"Не все <quote>предопределённые</quote> функции являются <quote>внутренними</"
"quote> в вышеописанном смысле. Некоторые предопределённые функции написаны "
"на SQL."

#: xfunc.xml:1530(title)
msgid "C-Language Functions"
msgstr "Функции на языке C"

#: xfunc.xml:1532(indexterm)
msgid ""
"<primary>function</primary> <secondary>user-defined</secondary> <tertiary>in "
"C</tertiary>"
msgstr ""
"<primary>функция</primary> <secondary>пользовательская</secondary> "
"<tertiary>на C</tertiary>"

#: xfunc.xml:1538(para)
msgid ""
"User-defined functions can be written in C (or a language that can be made "
"compatible with C, such as C++). Such functions are compiled into "
"dynamically loadable objects (also called shared libraries) and are loaded "
"by the server on demand. The dynamic loading feature is what distinguishes "
"<quote>C language</quote> functions from <quote>internal</quote> functions "
"&mdash; the actual coding conventions are essentially the same for both. "
"(Hence, the standard internal function library is a rich source of coding "
"examples for user-defined C functions.)"
msgstr ""
"Пользовательские функции могут быть написаны на C (или на языке, который "
"может быть совместим с C, например C++). Такие функции компилируются в "
"динамически загружаемые объекты (также называемые разделяемыми библиотеками) "
"и загружаются сервером по требованию. Именно метод динамической загрузки "
"отличает функции <quote>на языке C</quote> от <quote>внутренних</quote> "
"функций &mdash; правила написания кода по сути одни и те же. (Собственно, "
"поэтому стандартная библиотека внутренних функций может быть богатым "
"источником примеров для написания собственных функций на языке C.)"

#: xfunc.xml:1550(para)
msgid ""
"Two different calling conventions are currently used for C functions. The "
"newer <quote>version 1</quote> calling convention is indicated by writing a "
"<literal>PG_FUNCTION_INFO_V1()</literal> macro call for the function, as "
"illustrated below. Lack of such a macro indicates an old-style "
"(<quote>version 0</quote>) function. The language name specified in "
"<command>CREATE FUNCTION</command> is <literal>C</literal> in either case. "
"Old-style functions are now deprecated because of portability problems and "
"lack of functionality, but they are still supported for compatibility "
"reasons."
msgstr ""
"Для функций на C в настоящее время используются два различных соглашения о "
"вызовах. По новому соглашению <quote>версии 1</quote> для функции "
"записывается макрос <literal>PG_FUNCTION_INFO_V1()</literal>, как показано "
"ниже. Отсутствие такого макроса говорит о том, что это функция старого стиля "
"(<quote>версии 0</quote>). В качестве имени языка в <command>CREATE "
"FUNCTION</command> задаётся <literal>C</literal> в любом случае. Функции "
"старого стиля считаются устаревшими из-за проблем с переносимостью и "
"недостаточной функциональности, но они всё ещё поддерживаются для "
"совместимости."

#: xfunc.xml:1562(title)
msgid "Dynamic Loading"
msgstr "Динамическая загрузка"

#: xfunc.xml:1564(indexterm)
msgid "<primary>dynamic loading</primary>"
msgstr "<primary>динамическая загрузка</primary>"

#: xfunc.xml:1568(para)
msgid ""
"The first time a user-defined function in a particular loadable object file "
"is called in a session, the dynamic loader loads that object file into "
"memory so that the function can be called. The <command>CREATE FUNCTION</"
"command> for a user-defined C function must therefore specify two pieces of "
"information for the function: the name of the loadable object file, and the "
"C name (link symbol) of the specific function to call within that object "
"file. If the C name is not explicitly specified then it is assumed to be the "
"same as the SQL function name."
msgstr ""
"В первый раз, когда в сеансе вызывается пользовательская функция в "
"определённом внешнем объектном файле, загрузчик динамических модулей "
"загружает этот файл в память, чтобы можно было вызвать эту функцию. Таким "
"образом, в команде <command>CREATE FUNCTION</command>, объявляющей "
"пользовательскую функцию на языке C, необходимо определить две сущности для "
"функции: имя загружаемого объектного файла и имя уровня C (символ для "
"компоновки) заданной функции в этом объектном файле. Если имя уровня C не "
"указано явно, предполагается, что оно совпадает с именем функции в SQL."

#: xfunc.xml:1587(para)
msgid "If the name is an absolute path, the given file is loaded."
msgstr "Если имя задаётся абсолютным путём, загружается заданный файл."

#: xfunc.xml:1597(indexterm)
msgid "<primary>$libdir</primary>"
msgstr "<primary>$libdir</primary>"

#: xfunc.xml:1593(para)
msgid ""
"If the name starts with the string <literal>$libdir</literal>, that part is "
"replaced by the <productname>PostgreSQL</productname> package library "
"directory name, which is determined at build time.<placeholder-1/>"
msgstr ""
"Если имя начинается со строки <literal>$libdir</literal>, эта часть пути "
"заменяется путём к каталогу библиотек <productname>PostgreSQL</productname>, "
"который определяется во время сборки.<placeholder-1/>"

#: xfunc.xml:1605(indexterm)
msgid "<primary>dynamic_library_path</primary>"
msgstr "<primary>dynamic_library_path</primary>"

#: xfunc.xml:1602(para)
msgid ""
"If the name does not contain a directory part, the file is searched for in "
"the path specified by the configuration variable <xref linkend=\"guc-dynamic-"
"library-path\"/>.<placeholder-1/>"
msgstr ""
"Если в имени не указывается каталог, поиск файла производится по пути, "
"заданному конфигурационной переменной <xref linkend=\"guc-dynamic-library-"
"path\"/>.<placeholder-1/>"

#: xfunc.xml:1610(para)
msgid ""
"Otherwise (the file was not found in the path, or it contains a non-absolute "
"directory part), the dynamic loader will try to take the name as given, "
"which will most likely fail. (It is unreliable to depend on the current "
"working directory.)"
msgstr ""
"В противном случае (файл не был найден в пути поиска, или в его имени "
"указывается не абсолютный путь к каталогу), загрузчик попытается принять имя "
"как есть, что, скорее всего, не увенчается успехом. (Полагаться на текущий "
"рабочий каталог ненадёжно.)"

#: xfunc.xml:1580(para)
msgid ""
"The following algorithm is used to locate the shared object file based on "
"the name given in the <command>CREATE FUNCTION</command> command: "
"<placeholder-1/> If this sequence does not work, the platform-specific "
"shared library file name extension (often <filename>.so</filename>) is "
"appended to the given name and this sequence is tried again. If that fails "
"as well, the load will fail."
msgstr ""
"Для нахождения разделяемого объектного файла по имени, заданному в команде "
"<command>CREATE FUNCTION</command>, применяется следующий алгоритм: "
"<placeholder-1/> Если эта последовательность не даёт положительный "
"результат, к данному имени добавляется принятое на данной платформе "
"расширение файлов библиотек (часто <filename>.so</filename>) и "
"последовательность повторяется снова. Если и это не приводит к успеху, "
"происходит сбой загрузки."

#: xfunc.xml:1625(para)
msgid ""
"It is recommended to locate shared libraries either relative to <literal>"
"$libdir</literal> or through the dynamic library path. This simplifies "
"version upgrades if the new installation is at a different location. The "
"actual directory that <literal>$libdir</literal> stands for can be found out "
"with the command <literal>pg_config --pkglibdir</literal>."
msgstr ""
"Для поиска разделяемых библиотек рекомендуется задавать либо путь "
"относительно <literal>$libdir</literal>, либо путь динамических библиотек. "
"Это упрощает обновление версии при перемещении новой инсталляции в другое "
"место. Какой именно каталог подразумевается под <literal>$libdir</literal>, "
"можно узнать с помощью команды <literal>pg_config --pkglibdir</literal>."

#: xfunc.xml:1634(para)
msgid ""
"The user ID the <productname>PostgreSQL</productname> server runs as must be "
"able to traverse the path to the file you intend to load. Making the file or "
"a higher-level directory not readable and/or not executable by the "
"<systemitem>postgres</systemitem> user is a common mistake."
msgstr ""
"Пользователь, от имени которого работает сервер <productname>PostgreSQL</"
"productname>, должен иметь возможность пройти путь к файлу, который "
"требуется загрузить. Очень распространённая ошибка — когда сам файл или "
"каталог верхнего уровня оказывается недоступным для чтения и/или исполнения "
"для пользователя <systemitem>postgres</systemitem>."

#: xfunc.xml:1642(para)
msgid ""
"In any case, the file name that is given in the <command>CREATE FUNCTION</"
"command> command is recorded literally in the system catalogs, so if the "
"file needs to be loaded again the same procedure is applied."
msgstr ""
"В любом случае, имя файла, заданное в команде <command>CREATE FUNCTION</"
"command>, записывается в системные каталоги буквально, так что если этот "
"файл потребуется загрузить ещё раз, та же процедура будет проделана снова."

#: xfunc.xml:1650(para)
msgid ""
"<productname>PostgreSQL</productname> will not compile a C function "
"automatically. The object file must be compiled before it is referenced in a "
"<command>CREATE FUNCTION</command> command. See <xref linkend=\"dfunc\"/> "
"for additional information."
msgstr ""
"<productname>PostgreSQL</productname> не будет компилировать функцию на C "
"автоматически, поэтому прежде чем ссылаться на объектный файл в команде "
"<command>CREATE FUNCTION</command>, его нужно скомпилировать. За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"dfunc\"/"
">."

#: xfunc.xml:1659(indexterm)
msgid "<primary>magic block</primary>"
msgstr "<primary>отличительный блок</primary>"

#: xfunc.xml:1674(programlisting)
#, no-wrap
msgid ""
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif"
msgstr ""
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif"

#: xfunc.xml:1663(para)
msgid ""
"To ensure that a dynamically loaded object file is not loaded into an "
"incompatible server, <productname>PostgreSQL</productname> checks that the "
"file contains a <quote>magic block</quote> with the appropriate contents. "
"This allows the server to detect obvious incompatibilities, such as code "
"compiled for a different major version of <productname>PostgreSQL</"
"productname>. A magic block is required as of <productname>PostgreSQL</"
"productname> 8.2. To include a magic block, write this in one (and only one) "
"of the module source files, after having included the header <filename>fmgr."
"h</filename>: <placeholder-1/> The <literal>#ifdef</literal> test can be "
"omitted if the code doesn't need to compile against pre-8.2 "
"<productname>PostgreSQL</productname> releases."
msgstr ""
"Чтобы гарантировать, что динамически загружаемый объектный файл не будет "
"загружен несовместимым сервером, <productname>PostgreSQL</productname> "
"проверяет, содержит ли этот файл <quote>отличительный блок</quote> с "
"требуемым содержимым. Благодаря этому сервер может выявить очевидную "
"несовместимость, например, когда код скомпилирован для другой старшей версии "
"<productname>PostgreSQL</productname>. Отличительный блок стал обязательным, "
"начиная с версии <productname>PostgreSQL</productname> 8.2. Чтобы включить "
"его в свой модуль, напишите это в одном (и только одном) из исходных файлов "
"модуля, после включения заголовочного файла <filename>fmgr.h</filename>: "
"<placeholder-1/> Проверку <literal>#ifdef</literal> можно опустить, если "
"этот код не планируется компилировать для версий <productname>PostgreSQL</"
"productname> до 8.2."

#: xfunc.xml:1685(para)
msgid ""
"After it is used for the first time, a dynamically loaded object file is "
"retained in memory. Future calls in the same session to the function(s) in "
"that file will only incur the small overhead of a symbol table lookup. If "
"you need to force a reload of an object file, for example after recompiling "
"it, begin a fresh session."
msgstr ""
"После того, как он был использован первый раз, динамически загружаемый "
"объектный файл сохраняется в памяти. Следующие обращения в том же сеансе к "
"функциям в этом файле повлекут только небольшие издержки, связанные с "
"поиском в таблице символов. Если вам нужно принудительно перезагрузить "
"объектный файл, например, после перекомпиляции, начните новый сеанс."

#: xfunc.xml:1693(indexterm)
msgid "<primary>_PG_init</primary>"
msgstr "<primary>_PG_init</primary>"

#: xfunc.xml:1696(indexterm)
msgid "<primary>_PG_fini</primary>"
msgstr "<primary>_PG_fini</primary>"

#: xfunc.xml:1699(indexterm)
msgid "<primary>library initialization function</primary>"
msgstr "<primary>функция инициализации библиотеки</primary>"

#: xfunc.xml:1702(indexterm)
msgid "<primary>library finalization function</primary>"
msgstr "<primary>функция завершения работы библиотеки</primary>"

#: xfunc.xml:1706(para)
msgid ""
"Optionally, a dynamically loaded file can contain initialization and "
"finalization functions. If the file includes a function named "
"<function>_PG_init</function>, that function will be called immediately "
"after loading the file. The function receives no parameters and should "
"return void. If the file includes a function named <function>_PG_fini</"
"function>, that function will be called immediately before unloading the "
"file. Likewise, the function receives no parameters and should return void. "
"Note that <function>_PG_fini</function> will only be called during an unload "
"of the file, not during process termination. (Presently, unloads are "
"disabled and will never occur, but this may change in the future.)"
msgstr ""
"Динамически загружаемый файл может дополнительно содержать функции "
"инициализации и завершения работы библиотеки. Если в файле находится функция "
"с именем <function>_PG_init</function>, эта функция будет вызвана сразу "
"после загрузки файла. Эта функция не принимает параметры и не должна ничего "
"возвращать. Если в файле находится функция <function>_PG_fini</function>, "
"эта функция будет вызвана непосредственно перед выгрузкой файла. Эта функция "
"так же не принимает параметры и не должна ничего возвращать. Заметьте, что "
"<function>_PG_fini</function> будет вызываться только при выгрузке файла, но "
"не при завершении процесса. (В настоящее время выгрузка отключена и не "
"происходит никогда, но в будущем это может измениться.)"

#: xfunc.xml:1723(title)
msgid "Base Types in C-Language Functions"
msgstr "Базовые типы в функциях на языке C"

#: xfunc.xml:1725(indexterm)
msgid ""
"<primary>data type</primary> <secondary>internal organization</secondary>"
msgstr ""
"<primary>тип данных</primary> <secondary>внутренняя организация</secondary>"

#: xfunc.xml:1730(para)
msgid ""
"To know how to write C-language functions, you need to know how "
"<productname>PostgreSQL</productname> internally represents base data types "
"and how they can be passed to and from functions. Internally, "
"<productname>PostgreSQL</productname> regards a base type as a <quote>blob "
"of memory</quote>. The user-defined functions that you define over a type in "
"turn define the way that <productname>PostgreSQL</productname> can operate "
"on it. That is, <productname>PostgreSQL</productname> will only store and "
"retrieve the data from disk and use your user-defined functions to input, "
"process, and output the data."
msgstr ""
"Чтобы понимать, как написать функцию на языке C, вы должны знать, как внутри "
"<productname>PostgreSQL</productname> представляются базовые типы данных и "
"как их могут принимать и передавать функции. <productname>PostgreSQL</"
"productname> внутри воспринимает базовые типы как <quote>блоки памяти</"
"quote>. Пользовательские функции, устанавливаемые для типов, в свою очередь, "
"определяют, как <productname>PostgreSQL</productname> может работать с этими "
"типами. То есть, <productname>PostgreSQL</productname> только сохраняет и "
"загружает данные с диска, а для ввода, обработки и вывода данных он "
"использует определяемые вами функции."

#: xfunc.xml:1748(para)
msgid "pass by value, fixed-length"
msgstr "передаётся по значению, фиксированной длины"

#: xfunc.xml:1753(para)
msgid "pass by reference, fixed-length"
msgstr "передаётся по ссылке, фиксированной длины"

#: xfunc.xml:1758(para)
msgid "pass by reference, variable-length"
msgstr "передаётся по ссылке, переменной длины"

#: xfunc.xml:1743(para)
msgid "Base types can have one of three internal formats: <placeholder-1/>"
msgstr ""
"Базовые типы могут иметь один из трёх внутренних форматов: <placeholder-1/>"

#: xfunc.xml:1775(programlisting)
#, no-wrap
msgid ""
"/* 4-byte integer, passed by value */\n"
"typedef int int4;"
msgstr ""
"/* 4-байтное целое, передаётся по значению */\n"
"typedef int int4;"

#: xfunc.xml:1765(para)
msgid ""
"By-value types can only be 1, 2, or 4 bytes in length (also 8 bytes, if "
"<literal>sizeof(Datum)</literal> is 8 on your machine). You should be "
"careful to define your types such that they will be the same size (in bytes) "
"on all architectures. For example, the <literal>long</literal> type is "
"dangerous because it is 4 bytes on some machines and 8 bytes on others, "
"whereas <type>int</type> type is 4 bytes on most Unix machines. A reasonable "
"implementation of the <type>int4</type> type on Unix machines might be: "
"<placeholder-1/> (The actual PostgreSQL C code calls this type <type>int32</"
"type>, because it is a convention in C that <type>int<replaceable>XX</"
"replaceable></type> means <replaceable>XX</replaceable> <emphasis>bits</"
"emphasis>. Note therefore also that the C type <type>int8</type> is 1 byte "
"in size. The SQL type <type>int8</type> is called <type>int64</type> in C. "
"See also <xref linkend=\"xfunc-c-type-table\"/>.)"
msgstr ""
"Типы, передаваемые по значению, могут иметь размер только 1, 2 или 4 байта "
"(и 8 байт, если <literal>sizeof(Datum)</literal> равен 8 на вашей машине). "
"Определяя собственные типы, следует позаботиться о том, чтобы они имели "
"одинаковый размер (в байтах) во всех архитектурах. Например, тип "
"<literal>long</literal> опасен, так как он имеет размер 4 байта на одних "
"машинах, и 8 байт на других, тогда как тип <type>int</type> состоит из 4 "
"байт в большинстве систем Unix. Поэтому разумной реализацией типа "
"<type>int4</type> на платформе Unix может быть такая: <placeholder-1/> (В "
"коде собственно PostgreSQL этот тип называется <type>int32</type>, так как в "
"C принято соглашение, что <type>int<replaceable>XX</replaceable></type> "
"подразумевает <replaceable>XX</replaceable> <emphasis>бит</emphasis>. "
"Заметьте, что вследствие этого тип <type>int8</type> в C имеет размер 1 "
"байт. Тип <type>int8</type>, принятый в SQL, в C называется <type>int64</"
"type>. См. также <xref remap=\"4\" linkend=\"xfunc-c-type-table\"/>.)"

#: xfunc.xml:1793(programlisting)
#, no-wrap
msgid ""
"/* 16-byte structure, passed by reference */\n"
"typedef struct\n"
"{\n"
"    double  x, y;\n"
"} Point;"
msgstr ""
"/* 16-байтная структура, передаётся по ссылке */\n"
"typedef struct\n"
"{\n"
"    double  x, y;\n"
"} Point;"

#: xfunc.xml:1788(para)
msgid ""
"On the other hand, fixed-length types of any size can be passed by-"
"reference. For example, here is a sample implementation of a "
"<productname>PostgreSQL</productname> type: <placeholder-1/> Only pointers "
"to such types can be used when passing them in and out of "
"<productname>PostgreSQL</productname> functions. To return a value of such a "
"type, allocate the right amount of memory with <literal>palloc</literal>, "
"fill in the allocated memory, and return a pointer to it. (Also, if you just "
"want to return the same value as one of your input arguments that's of the "
"same data type, you can skip the extra <literal>palloc</literal> and just "
"return the pointer to the input value.)"
msgstr ""
"С другой стороны, типы фиксированной длины любого размера можно передавать "
"по ссылке. Например, взгляните на пример реализации типа "
"<productname>PostgreSQL</productname>: <placeholder-1/> В функции "
"<productname>PostgreSQL</productname> и из них могут передаваться только "
"указатели на такие типы. Чтобы вернуть значение такого типа, выделите для "
"него нужное количество памяти функцией <literal>palloc</literal>, заполните "
"выделенную память и верните указатель на неё. (Если вы захотите просто "
"вернуть то же значение, что было получено во входном аргументе этого же типа "
"данных, вы можете пропустить дополнительный вызов <literal>palloc</literal> "
"и просто вернуть указатель на это поступившее значение.)"

#: xfunc.xml:1811(para)
msgid ""
"Finally, all variable-length types must also be passed by reference. All "
"variable-length types must begin with an opaque length field of exactly 4 "
"bytes, which will be set by <symbol>SET_VARSIZE</symbol>; never set this "
"field directly! All data to be stored within that type must be located in "
"the memory immediately following that length field. The length field "
"contains the total length of the structure, that is, it includes the size of "
"the length field itself."
msgstr ""
"Наконец, все типы переменной длины также должны передаваться по ссылке. Все "
"типы переменной длины должны начинаться с обязательного поля длины размером "
"ровно 4 байта, которая будет задаваться макросом <symbol>SET_VARSIZE</"
"symbol>; никогда не устанавливайте это поле вручную! Все данные, которые "
"будут храниться в этом типе, должны размещаться в памяти непосредственно за "
"этим полем длины. Поле длины содержит полную длину структуры, то есть "
"включает размер самого поля длины."

#: xfunc.xml:1823(para)
msgid ""
"Another important point is to avoid leaving any uninitialized bits within "
"data type values; for example, take care to zero out any alignment padding "
"bytes that might be present in structs. Without this, logically-equivalent "
"constants of your data type might be seen as unequal by the planner, leading "
"to inefficient (though not incorrect) plans."
msgstr ""
"Ещё один важный момент — старайтесь не оставлять неинициализированных байт в "
"значениях данных; например, обнуляйте все возможные байты выравнивания, "
"которые могут присутствовать в структурах. Если этого не делать, логически "
"равные значения ваших данных могут представляться неравными планировщику, "
"что приведёт к построению неэффективных (хотя и корректных) планов."

#: xfunc.xml:1833(para)
msgid ""
"<emphasis>Never</emphasis> modify the contents of a pass-by-reference input "
"value. If you do so you are likely to corrupt on-disk data, since the "
"pointer you are given might point directly into a disk buffer. The sole "
"exception to this rule is explained in <xref linkend=\"xaggr\"/>."
msgstr ""
"<emphasis>Никогда</emphasis> не изменяйте содержимое, передаваемое на вход "
"по ссылке. Если вы сделаете это, вы скорее всего испортите данные на диске, "
"так как полученный вами указатель указывает непосредственно на место в "
"дисковом буфере. Единственное исключение из этого правила освещается в <xref "
"remap=\"6\" linkend=\"xaggr\"/>."

#: xfunc.xml:1846(programlisting)
#, no-wrap
msgid ""
"typedef struct {\n"
"    int32 length;\n"
"    char data[FLEXIBLE_ARRAY_MEMBER];\n"
"} text;"
msgstr ""
"typedef struct {\n"
"    int32 length;\n"
"    char data[FLEXIBLE_ARRAY_MEMBER];\n"
"} text;"

#: xfunc.xml:1842(para)
msgid ""
"As an example, we can define the type <type>text</type> as follows: "
"<placeholder-1/> The <literal>[FLEXIBLE_ARRAY_MEMBER]</literal> notation "
"means that the actual length of the data part is not specified by this "
"declaration."
msgstr ""
"В качестве примера мы можем определить тип <type>text</type> так: "
"<placeholder-1/> Запись <literal>[FLEXIBLE_ARRAY_MEMBER]</literal> означает, "
"что действительная длина массива данных в этом объявлении не указывается."

#: xfunc.xml:1857(para)
msgid ""
"When manipulating variable-length types, we must be careful to allocate the "
"correct amount of memory and set the length field correctly. For example, if "
"we wanted to store 40 bytes in a <structname>text</structname> structure, we "
"might use a code fragment like this: <placeholder-1/> <literal>VARHDRSZ</"
"literal> is the same as <literal>sizeof(int32)</literal>, but it's "
"considered good style to use the macro <literal>VARHDRSZ</literal> to refer "
"to the size of the overhead for a variable-length type. Also, the length "
"field <emphasis>must</emphasis> be set using the <literal>SET_VARSIZE</"
"literal> macro, not by simple assignment."
msgstr ""
"Работая с типами переменной длины, мы должны аккуратно выделить нужный объём "
"памяти и записать его размер в поле длины. Например, если нужно сохранить 40 "
"байт в структуре <structname>text</structname>, можно применить такой код: "
"<placeholder-1/> <literal>VARHDRSZ</literal> совпадает с "
"<literal>sizeof(int32)</literal>, но для получения размера заголовка типа "
"переменной длины хорошим стилем считается применять макрос "
"<literal>VARHDRSZ</literal>. Кроме того, поле длины <emphasis>должно</"
"emphasis> устанавливаться макросом <literal>SET_VARSIZE</literal>, а не "
"простым присваиванием."

#: xfunc.xml:1883(para)
msgid ""
"<xref linkend=\"xfunc-c-type-table\"/> specifies which C type corresponds to "
"which SQL type when writing a C-language function that uses a built-in type "
"of <productname>PostgreSQL</productname>. The <quote>Defined In</quote> "
"column gives the header file that needs to be included to get the type "
"definition. (The actual definition might be in a different file that is "
"included by the listed file. It is recommended that users stick to the "
"defined interface.) Note that you should always include <filename>postgres."
"h</filename> first in any source file, because it declares a number of "
"things that you will need anyway."
msgstr ""
"В <xref remap=\"6\" linkend=\"xfunc-c-type-table\"/> указано, какие типы "
"языка C соответствуют типам SQL при написании функций на C с использованием "
"встроенных типов <productname>PostgreSQL</productname>. В столбце "
"<quote>Определён в</quote> указывается, какой заголовочный файл необходимо "
"подключить, чтобы получить определение типа. (Фактическое определение может "
"быть в другом файле, который подключается из указанного, однако "
"рекомендуется придерживаться обозначенного интерфейса.) Заметьте, что в "
"любом исходном файле всегда необходимо первым включать <filename>postgres.h</"
"filename>, так как в нём объявляется ряд вещей, которые нужны в любом случае."

#: xfunc.xml:1897(title)
msgid "Equivalent C Types for Built-in SQL Types"
msgstr "Типы C, эквивалентные встроенным типам SQL"

#: xfunc.xml:1901(entry)
msgid "SQL Type"
msgstr "Тип SQL"

#: xfunc.xml:1904(entry)
msgid "C Type"
msgstr "Тип C"

#: xfunc.xml:1907(entry)
msgid "Defined In"
msgstr "Определён в"

#: xfunc.xml:1914(type)
msgid "abstime"
msgstr "abstime"

#: xfunc.xml:1915(type)
msgid "AbsoluteTime"
msgstr "AbsoluteTime"

#: xfunc.xml:1916(filename) xfunc.xml:2026(filename) xfunc.xml:2056(filename)
msgid "utils/nabstime.h"
msgstr "utils/nabstime.h"

#: xfunc.xml:1919(entry)
msgid "<type>bigint</type> (<type>int8</type>)"
msgstr "<type>bigint</type> (<type>int8</type>)"

#: xfunc.xml:1920(type)
msgid "int64"
msgstr "int64"

#: xfunc.xml:1921(filename) xfunc.xml:1936(filename) xfunc.xml:1946(filename)
#: xfunc.xml:1951(filename) xfunc.xml:1961(filename) xfunc.xml:1966(filename)
#: xfunc.xml:1971(filename) xfunc.xml:1976(filename) xfunc.xml:1981(filename)
#: xfunc.xml:1996(filename) xfunc.xml:2001(filename) xfunc.xml:2006(filename)
#: xfunc.xml:2021(filename) xfunc.xml:2031(filename) xfunc.xml:2061(filename)
#: xfunc.xml:2066(filename)
msgid "postgres.h"
msgstr "postgres.h"

#: xfunc.xml:1924(type)
msgid "boolean"
msgstr "boolean"

#: xfunc.xml:1925(type)
msgid "bool"
msgstr "bool"

#: xfunc.xml:1926(entry)
msgid "<filename>postgres.h</filename> (maybe compiler built-in)"
msgstr "<filename>postgres.h</filename> (может быть встроен в компиляторе)"

#: xfunc.xml:1929(type)
msgid "box"
msgstr "box"

#: xfunc.xml:1930(type)
msgid "BOX*"
msgstr "BOX*"

#: xfunc.xml:1931(filename) xfunc.xml:1991(filename) xfunc.xml:2011(filename)
#: xfunc.xml:2016(filename)
msgid "utils/geo_decls.h"
msgstr "utils/geo_decls.h"

#: xfunc.xml:1934(type)
msgid "bytea"
msgstr "bytea"

#: xfunc.xml:1935(type)
msgid "bytea*"
msgstr "bytea*"

#: xfunc.xml:1939(type)
msgid "\"char\""
msgstr "\"char\""

#: xfunc.xml:1940(type)
msgid "char"
msgstr "char"

#: xfunc.xml:1941(entry)
msgid "(compiler built-in)"
msgstr "(встроен в компиляторе)"

#: xfunc.xml:1944(type)
msgid "character"
msgstr "character"

#: xfunc.xml:1945(type)
msgid "BpChar*"
msgstr "BpChar*"

#: xfunc.xml:1949(type)
msgid "cid"
msgstr "cid"

#: xfunc.xml:1950(type)
msgid "CommandId"
msgstr "CommandId"

#: xfunc.xml:1954(type)
msgid "date"
msgstr "date"

#: xfunc.xml:1955(type)
msgid "DateADT"
msgstr "DateADT"

#: xfunc.xml:1956(filename) xfunc.xml:2041(filename) xfunc.xml:2046(filename)
msgid "utils/date.h"
msgstr "utils/date.h"

#: xfunc.xml:1959(entry)
msgid "<type>smallint</type> (<type>int2</type>)"
msgstr "<type>smallint</type> (<type>int2</type>)"

#: xfunc.xml:1960(type)
msgid "int16"
msgstr "int16"

#: xfunc.xml:1964(type)
msgid "int2vector"
msgstr "int2vector"

#: xfunc.xml:1965(type)
msgid "int2vector*"
msgstr "int2vector*"

#: xfunc.xml:1969(entry)
msgid "<type>integer</type> (<type>int4</type>)"
msgstr "<type>integer</type> (<type>int4</type>)"

#: xfunc.xml:1970(type)
msgid "int32"
msgstr "int32"

#: xfunc.xml:1974(entry)
msgid "<type>real</type> (<type>float4</type>)"
msgstr "<type>real</type> (<type>float4</type>)"

#: xfunc.xml:1975(type)
msgid "float4*"
msgstr "float4*"

#: xfunc.xml:1979(entry)
msgid "<type>double precision</type> (<type>float8</type>)"
msgstr "<type>double precision</type> (<type>float8</type>)"

#: xfunc.xml:1980(type)
msgid "float8*"
msgstr "float8*"

#: xfunc.xml:1984(type)
msgid "interval"
msgstr "interval"

#: xfunc.xml:1985(type)
msgid "Interval*"
msgstr "Interval*"

#: xfunc.xml:1986(filename) xfunc.xml:2051(filename)
msgid "datatype/timestamp.h"
msgstr "datatype/timestamp.h"

#: xfunc.xml:1989(type)
msgid "lseg"
msgstr "lseg"

#: xfunc.xml:1990(type)
msgid "LSEG*"
msgstr "LSEG*"

#: xfunc.xml:1994(type)
msgid "name"
msgstr "name"

#: xfunc.xml:1995(type)
msgid "Name"
msgstr "Name"

#: xfunc.xml:1999(type)
msgid "oid"
msgstr "oid"

#: xfunc.xml:2000(type)
msgid "Oid"
msgstr "Oid"

#: xfunc.xml:2004(type)
msgid "oidvector"
msgstr "oidvector"

#: xfunc.xml:2005(type)
msgid "oidvector*"
msgstr "oidvector*"

#: xfunc.xml:2009(type)
msgid "path"
msgstr "path"

#: xfunc.xml:2010(type)
msgid "PATH*"
msgstr "PATH*"

#: xfunc.xml:2014(type)
msgid "point"
msgstr "point"

#: xfunc.xml:2015(type)
msgid "POINT*"
msgstr "POINT*"

#: xfunc.xml:2019(type) xfunc.xml:2020(type)
msgid "regproc"
msgstr "regproc"

#: xfunc.xml:2024(type)
msgid "reltime"
msgstr "reltime"

#: xfunc.xml:2025(type)
msgid "RelativeTime"
msgstr "RelativeTime"

#: xfunc.xml:2029(type)
msgid "text"
msgstr "text"

#: xfunc.xml:2030(type)
msgid "text*"
msgstr "text*"

#: xfunc.xml:2034(type)
msgid "tid"
msgstr "tid"

#: xfunc.xml:2035(type)
msgid "ItemPointer"
msgstr "ItemPointer"

#: xfunc.xml:2036(filename)
msgid "storage/itemptr.h"
msgstr "storage/itemptr.h"

#: xfunc.xml:2039(type)
msgid "time"
msgstr "time"

#: xfunc.xml:2040(type)
msgid "TimeADT"
msgstr "TimeADT"

#: xfunc.xml:2044(type)
msgid "time with time zone"
msgstr "time with time zone"

#: xfunc.xml:2045(type)
msgid "TimeTzADT"
msgstr "TimeTzADT"

#: xfunc.xml:2049(type)
msgid "timestamp"
msgstr "timestamp"

#: xfunc.xml:2050(type)
msgid "Timestamp*"
msgstr "Timestamp*"

#: xfunc.xml:2054(type)
msgid "tinterval"
msgstr "tinterval"

#: xfunc.xml:2055(type)
msgid "TimeInterval"
msgstr "TimeInterval"

#: xfunc.xml:2059(type)
msgid "varchar"
msgstr "varchar"

#: xfunc.xml:2060(type)
msgid "VarChar*"
msgstr "VarChar*"

#: xfunc.xml:2064(type)
msgid "xid"
msgstr "xid"

#: xfunc.xml:2065(type)
msgid "TransactionId"
msgstr "TransactionId"

#: xfunc.xml:2072(para)
msgid ""
"Now that we've gone over all of the possible structures for base types, we "
"can show some examples of real functions."
msgstr ""
"Теперь, когда мы рассмотрели все возможные структуры для базовых типов, мы "
"можем перейти к примерам реальных функций."

#: xfunc.xml:2079(title)
msgid "Version 0 Calling Conventions"
msgstr "Соглашение о вызовах версии 0"

#: xfunc.xml:2081(para)
msgid ""
"We present the <quote>old style</quote> calling convention first &mdash; "
"although this approach is now deprecated, it's easier to get a handle on "
"initially. In the version-0 method, the arguments and result of the C "
"function are just declared in normal C style, but being careful to use the C "
"representation of each SQL data type as shown above."
msgstr ""
"Сначала мы представим соглашение о вызовах <quote>старого стиля</quote> "
"&mdash; хотя этот подход уже устарел, понять его сначала будет легче. По "
"методу версии 0 аргументы и результат функции C объявляются в обычном стиле "
"C, но при этом должны использоваться типы C, соответствующие типам данных "
"SQL, как показано выше."

#: xfunc.xml:2090(para)
msgid "Here are some examples: <placeholder-1/>"
msgstr "Несколько примеров функций: <placeholder-1/>"

#: xfunc.xml:2174(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION add_one(integer) RETURNS integer\n"
"     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"-- note overloading of SQL function name \"add_one\"\n"
"CREATE FUNCTION add_one(double precision) RETURNS double precision\n"
"     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"CREATE FUNCTION makepoint(point, point) RETURNS point\n"
"     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"CREATE FUNCTION copytext(text) RETURNS text\n"
"     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"CREATE FUNCTION concat_text(text, text) RETURNS text\n"
"     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'\n"
"     LANGUAGE C STRICT;"
msgstr ""
"CREATE FUNCTION add_one(integer) RETURNS integer\n"
"     AS '<replaceable>КАТАЛОГ</replaceable>/funcs', 'add_one'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"-- обратите внимание — это перегрузка SQL-функции \"add_one\"\n"
"CREATE FUNCTION add_one(double precision) RETURNS double precision\n"
"     AS '<replaceable>КАТАЛОГ</replaceable>/funcs', 'add_one_float8'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"CREATE FUNCTION makepoint(point, point) RETURNS point\n"
"     AS '<replaceable>КАТАЛОГ</replaceable>/funcs', 'makepoint'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"CREATE FUNCTION copytext(text) RETURNS text\n"
"     AS '<replaceable>КАТАЛОГ</replaceable>/funcs', 'copytext'\n"
"     LANGUAGE C STRICT;\n"
"\n"
"CREATE FUNCTION concat_text(text, text) RETURNS text\n"
"     AS '<replaceable>КАТАЛОГ</replaceable>/funcs', 'concat_text'\n"
"     LANGUAGE C STRICT;"

#: xfunc.xml:2168(para)
msgid ""
"Supposing that the above code has been prepared in file <filename>funcs.c</"
"filename> and compiled into a shared object, we could define the functions "
"to <productname>PostgreSQL</productname> with commands like this: "
"<placeholder-1/>"
msgstr ""
"В предположении, что приведённый выше код был подготовлен в файле "
"<filename>funcs.c</filename> и скомпилирован в разделяемый объект, мы можем "
"объявить эти функции в <productname>PostgreSQL</productname> следующими "
"командами: <placeholder-1/>"

#: xfunc.xml:2198(para)
msgid ""
"Here, <replaceable>DIRECTORY</replaceable> stands for the directory of the "
"shared library file (for instance the <productname>PostgreSQL</productname> "
"tutorial directory, which contains the code for the examples used in this "
"section). (Better style would be to use just <literal>'funcs'</literal> in "
"the <literal>AS</literal> clause, after having added <replaceable>DIRECTORY</"
"replaceable> to the search path. In any case, we can omit the system-"
"specific extension for a shared library, commonly <literal>.so</literal> or "
"<literal>.sl</literal>.)"
msgstr ""
"Здесь <replaceable>КАТАЛОГ</replaceable> — это путь к каталогу, в который "
"помещён разделяемый библиотечный файл (например, каталог учебных материалов "
"(tutorial) в исходном коде <productname>PostgreSQL</productname>, содержащий "
"код примеров, использованных в этом разделе). (Лучше было бы просто написать "
"<literal>'funcs'</literal> в предложении <literal>AS</literal>, "
"предварительно добавив <replaceable>КАТАЛОГ</replaceable> в путь поиска. В "
"любом случае, мы можем опустить принятое в системе расширение файлов "
"разделяемых библиотек, обычно <literal>.so</literal> или <literal>.sl</"
"literal>.)"

#: xfunc.xml:2211(para)
msgid ""
"Notice that we have specified the functions as <quote>strict</quote>, "
"meaning that the system should automatically assume a null result if any "
"input value is null. By doing this, we avoid having to check for null inputs "
"in the function code. Without this, we'd have to check for null values "
"explicitly, by checking for a null pointer for each pass-by-reference "
"argument. (For pass-by-value arguments, we don't even have a way to check!)"
msgstr ""
"Заметьте, что мы объявили эти функции как <quote>strict</quote> (строгие) — "
"это означает, что система будет автоматически подразумевать результат NULL, "
"если в одном из входных значений передаётся NULL. Благодаря этому, мы "
"избегаем необходимости проверять входные значения на NULL в коде функции. "
"Без такого объявления нам пришлось бы явно проверять параметры на NULL, "
"сравнивая указатель аргументов, передаваемых по ссылке, с NULL. (Для "
"аргументов, передаваемых по значению, мы даже не можем это проверить!)"

#: xfunc.xml:2222(para)
msgid ""
"Although this calling convention is simple to use, it is not very portable; "
"on some architectures there are problems with passing data types that are "
"smaller than <type>int</type> this way. Also, there is no simple way to "
"return a null result, nor to cope with null arguments in any way other than "
"making the function strict. The version-1 convention, presented next, "
"overcomes these objections."
msgstr ""
"Хотя это соглашение о вызовах легко использовать, оно плохо портируется; на "
"некоторых архитектурах возникали проблемы с передачей таким образом типов "
"данных размером меньше <type>int</type>. Кроме того, оно не позволяет "
"простым способом вернуть результат NULL, как и управиться с аргументами "
"NULL, кроме как объявив функцию строгой. В соглашении версии 1, "
"представленном далее, эти недостатки устранены."

#: xfunc.xml:2233(title)
msgid "Version 1 Calling Conventions"
msgstr "Соглашение о вызовах версии 1"

#: xfunc.xml:2239(programlisting)
#, no-wrap
msgid "Datum funcname(PG_FUNCTION_ARGS)"
msgstr "Datum funcname(PG_FUNCTION_ARGS)"

#: xfunc.xml:2243(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(funcname);"
msgstr "PG_FUNCTION_INFO_V1(funcname);"

#: xfunc.xml:2235(para)
msgid ""
"The version-1 calling convention relies on macros to suppress most of the "
"complexity of passing arguments and results. The C declaration of a "
"version-1 function is always: <placeholder-1/> In addition, the macro call: "
"<placeholder-2/> must appear in the same source file. (Conventionally, it's "
"written just before the function itself.) This macro call is not needed for "
"<literal>internal</literal>-language functions, since "
"<productname>PostgreSQL</productname> assumes that all internal functions "
"use the version-1 convention. It is, however, required for dynamically-"
"loaded functions."
msgstr ""
"Соглашение о вызовах версии 1 полагается на макросы, скрывающие основную "
"долю сложностей, связанных с передачей аргументов и результатов. По "
"соглашению версии 1 функция на C должна всегда определяться так: "
"<placeholder-1/> В дополнение к этому, в том же исходном файле должен "
"присутствовать вызов макроса: <placeholder-2/> (Обычно его принято "
"записывать непосредственно перед функцией.) Этот вызов макроса не нужен для "
"функций <literal>internal</literal>, так как <productname>PostgreSQL</"
"productname> предполагает, что все внутренние функции используют соглашении "
"версии 1. Однако для функций, загружаемых динамически, этот макрос необходим."

#: xfunc.xml:2254(para)
msgid ""
"In a version-1 function, each actual argument is fetched using a "
"<function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macro that "
"corresponds to the argument's data type, and the result is returned using a "
"<function>PG_RETURN_<replaceable>xxx</replaceable>()</function> macro for "
"the return type. <function>PG_GETARG_<replaceable>xxx</replaceable>()</"
"function> takes as its argument the number of the function argument to "
"fetch, where the count starts at 0. <function>PG_RETURN_<replaceable>xxx</"
"replaceable>()</function> takes as its argument the actual value to return."
msgstr ""
"В функции версии 1 каждый аргумент выбирается макросом "
"<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>, который "
"соответствует типу данных аргумента, а результат возвращается макросом "
"<function>PG_RETURN_<replaceable>xxx</replaceable>()</function> для "
"возвращаемого типа. <function>PG_GETARG_<replaceable>xxx</replaceable>()</"
"function> принимает в качестве параметра номер выбираемого аргумента функции "
"(нумерация начинается с 0). <function>PG_RETURN_<replaceable>xxx</"
"replaceable>()</function> принимает в качестве параметра фактическое "
"значение, которое нужно возвратить."

#: xfunc.xml:2268(para)
msgid ""
"Here we show the same functions as above, coded in version-1 style: "
"<placeholder-1/>"
msgstr ""
"Так выглядят те же функции, что были показаны выше, но реализованные в стиле "
"версии 1: <placeholder-1/>"

#: xfunc.xml:2364(para)
msgid ""
"The <command>CREATE FUNCTION</command> commands are the same as for the "
"version-0 equivalents."
msgstr ""
"Команды <command>CREATE FUNCTION</command> не отличаются от тех, что "
"объявляют функции версии 0."

#: xfunc.xml:2369(para)
msgid ""
"At first glance, the version-1 coding conventions might appear to be just "
"pointless obscurantism. They do, however, offer a number of improvements, "
"because the macros can hide unnecessary detail. An example is that in coding "
"<function>add_one_float8</function>, we no longer need to be aware that "
"<type>float8</type> is a pass-by-reference type. Another example is that the "
"<literal>GETARG</literal> macros for variable-length types allow for more "
"efficient fetching of <quote>toasted</quote> (compressed or out-of-line) "
"values."
msgstr ""
"На первый взгляд соглашение версии 1 может показаться всего лишь "
"бессмысленным мракобесием. Однако, оно приносит ряд усовершенствований, так "
"как макрос может скрыть лишние детали. Например, в реализации "
"<function>add_one_float8</function> мы больше не должны думать о том, что "
"тип <type>float8</type> передаётся по ссылке. Ещё один плюс состоит в том, "
"что макрос <literal>GETARG</literal> для типов переменной длины позволяет "
"эффективно выбирать значения в формате TOAST (сжатых или хранимых отдельно)."

#: xfunc.xml:2380(para)
msgid ""
"One big improvement in version-1 functions is better handling of null inputs "
"and results. The macro <function>PG_ARGISNULL(<replaceable>n</replaceable>)</"
"function> allows a function to test whether each input is null. (Of course, "
"doing this is only necessary in functions not declared <quote>strict</"
"quote>.) As with the <function>PG_GETARG_<replaceable>xxx</replaceable>()</"
"function> macros, the input arguments are counted beginning at zero. Note "
"that one should refrain from executing <function>PG_GETARG_<replaceable>xxx</"
"replaceable>()</function> until one has verified that the argument isn't "
"null. To return a null result, execute <function>PG_RETURN_NULL()</"
"function>; this works in both strict and nonstrict functions."
msgstr ""
"Важным усовершенствованием для функций версии 1 стало улучшение обработки "
"аргументов и результатов NULL. Такие функции могут проверить любое входное "
"значение на NULL, воспользовавшись макросом "
"<function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>. "
"(Разумеется, эти проверки нужны только в функциях, объявленных без "
"характеристики <quote>strict</quote>.) Как и с макросом "
"<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>, входные "
"аргументы нумеруются, начиная с нуля. Заметьте, что не следует обращаться к "
"макросу <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>, не "
"убедившись, что соответствующий аргумент не NULL. Чтобы возвратить NULL в "
"качестве результата, воспользуйтесь макросом <function>PG_RETURN_NULL()</"
"function>; это работает и со строгими, и с нестрогими функциями."

#: xfunc.xml:2395(para)
msgid ""
"Other options provided in the new-style interface are two variants of the "
"<function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macros. The "
"first of these, <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</"
"function>, guarantees to return a copy of the specified argument that is "
"safe for writing into. (The normal macros will sometimes return a pointer to "
"a value that is physically stored in a table, which must not be written to. "
"Using the <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</"
"function> macros guarantees a writable result.) The second variant consists "
"of the <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function> "
"macros which take three arguments. The first is the number of the function "
"argument (as above). The second and third are the offset and length of the "
"segment to be returned. Offsets are counted from zero, and a negative length "
"requests that the remainder of the value be returned. These macros provide "
"more efficient access to parts of large values in the case where they have "
"storage type <quote>external</quote>. (The storage type of a column can be "
"specified using <literal>ALTER TABLE <replaceable>tablename</replaceable> "
"ALTER COLUMN <replaceable>colname</replaceable> SET STORAGE "
"<replaceable>storagetype</replaceable></literal>. <replaceable>storagetype</"
"replaceable> is one of <literal>plain</literal>, <literal>external</"
"literal>, <literal>extended</literal>, or <literal>main</literal>.)"
msgstr ""
"Кроме того, в интерфейсе нового стиля появились две вариации макросов "
"<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>. Первая "
"вариация, <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</"
"function>, гарантированно возвращает копию указанного аргумента, которую "
"можно безопасно модифицировать. (Обычный макрос иногда возвращает указатель "
"на значение, которое физически хранится в таблице, в которую нельзя писать. "
"С макросом <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</"
"function> гарантированно получается результат, доступный для записи.) Вторая "
"вариация представлена макросом <function>PG_GETARG_<replaceable>xxx</"
"replaceable>_SLICE()</function>, принимающим три параметра. В первом "
"передаётся номер аргумента функции (как и раньше). Во втором и третьем "
"передаётся смещение и длина сегмента, который должен быть возвращён. "
"Смещение отсчитывается с нуля, а отрицательная длина указывает, что "
"запрашивается оставшаяся часть значения. Эти макросы дают более эффективный "
"доступ к частям больших значений, имеющим тип хранения <quote>external</"
"quote>. (Тип хранения столбца может задаваться командой <literal>ALTER TABLE "
"<replaceable>имя_таблицы</replaceable> ALTER COLUMN "
"<replaceable>имя_столбца</replaceable> SET STORAGE "
"<replaceable>тип_хранения</replaceable></literal>. Где "
"<replaceable>тип_хранения</replaceable> может быть <literal>plain</literal>, "
"<literal>external</literal>, <literal>extended</literal> или <literal>main</"
"literal>.)"

#: xfunc.xml:2423(para)
msgid ""
"Finally, the version-1 function call conventions make it possible to return "
"set results (<xref linkend=\"xfunc-c-return-set\"/>) and implement trigger "
"functions (<xref linkend=\"triggers\"/>) and procedural-language call "
"handlers (<xref linkend=\"plhandler\"/>). Version-1 code is also more "
"portable than version-0, because it does not break restrictions on function "
"call protocol in the C standard. For more details see <filename>src/backend/"
"utils/fmgr/README</filename> in the source distribution."
msgstr ""
"Наконец соглашение о вызовах версии 1 позволяет возвращать множества (<xref "
"linkend=\"xfunc-c-return-set\"/>) и реализовывать триггерные функции (<xref "
"linkend=\"triggers\"/>) и обработчики вызовов процедурных языков (<xref "
"linkend=\"plhandler\"/>). Код версии 1 также более портируемый, чем версии "
"0, так как он не нарушает установленных в стандарте C ограничений протокола "
"вызова функций. Дополнительные подробности можно найти в <filename>src/"
"backend/utils/fmgr/README</filename> в пакете исходного кода."

#: xfunc.xml:2437(title)
msgid "Writing Code"
msgstr "Написание кода"

#: xfunc.xml:2439(para)
msgid ""
"Before we turn to the more advanced topics, we should discuss some coding "
"rules for <productname>PostgreSQL</productname> C-language functions. While "
"it might be possible to load functions written in languages other than C "
"into <productname>PostgreSQL</productname>, this is usually difficult (when "
"it is possible at all) because other languages, such as C++, FORTRAN, or "
"Pascal often do not follow the same calling convention as C. That is, other "
"languages do not pass argument and return values between functions in the "
"same way. For this reason, we will assume that your C-language functions are "
"actually written in C."
msgstr ""
"Прежде чем перейти к более сложным темам, мы должны обсудить некоторые "
"правила написания кода функций на языке C для <productname>PostgreSQL</"
"productname>. Хотя принципиально можно загружать в <productname>PostgreSQL</"
"productname> функции, написанные на языках, отличных от C, обычно это "
"довольно сложно (когда вообще возможно), так как другие языки, например C++, "
"FORTRAN или Pascal часто не следуют соглашениям, принятым в C. То есть "
"другие языки могут передавать аргументы и возвращаемые значения между "
"функциями разными способами. Поэтому далее предполагается, что ваши функции "
"на языке C действительно написаны на C."

#: xfunc.xml:2460(indexterm)
msgid ""
"<primary>pg_config</primary><secondary>with user-defined C functions</"
"secondary>"
msgstr ""
"<primary>pg_config</primary> <secondary>для пользовательских функций на C</"
"secondary>"

#: xfunc.xml:2458(para)
msgid ""
"Use <literal>pg_config --includedir-server</literal><placeholder-1/> to find "
"out where the <productname>PostgreSQL</productname> server header files are "
"installed on your system (or the system that your users will be running on)."
msgstr ""
"Чтобы выяснить, где находятся заголовочные файлы сервера "
"<productname>PostgreSQL</productname>, установленные в вашей системе (или в "
"системе, с которой будут работать ваши пользователи), воспользуйтесь "
"командой <literal>pg_config --includedir-server</literal><placeholder-1/>."

#: xfunc.xml:2468(para)
msgid ""
"Compiling and linking your code so that it can be dynamically loaded into "
"<productname>PostgreSQL</productname> always requires special flags. See "
"<xref linkend=\"dfunc\"/> for a detailed explanation of how to do it for "
"your particular operating system."
msgstr ""
"Для компиляции и компоновки кода, который можно будет динамически загрузить "
"в <productname>PostgreSQL</productname>, требуется указать специальные "
"флаги. Чтобы конкретнее узнать, как это сделать в вашей конкретной "
"операционной системе, обратитесь к <xref remap=\"3\" linkend=\"dfunc\"/>."

#: xfunc.xml:2478(para)
msgid ""
"Remember to define a <quote>magic block</quote> for your shared library, as "
"described in <xref linkend=\"xfunc-c-dynload\"/>."
msgstr ""
"Не забудьте определить <quote>отличительный блок</quote> для вашей "
"разделяемой библиотеки, как описано в <xref remap=\"6\" linkend=\"xfunc-c-"
"dynload\"/>."

#: xfunc.xml:2488(indexterm)
msgid "<primary>palloc</primary>"
msgstr "<primary>palloc</primary>"

#: xfunc.xml:2488(indexterm)
msgid "<primary>pfree</primary>"
msgstr "<primary>pfree</primary>"

#: xfunc.xml:2485(para)
msgid ""
"When allocating memory, use the <productname>PostgreSQL</productname> "
"functions <function>palloc</function><placeholder-1/> and <function>pfree</"
"function><placeholder-2/> instead of the corresponding C library functions "
"<function>malloc</function> and <function>free</function>. The memory "
"allocated by <function>palloc</function> will be freed automatically at the "
"end of each transaction, preventing memory leaks."
msgstr ""
"Для выделения памяти используйте функцию <productname>PostgreSQL</"
"productname> <function>palloc</function><placeholder-1/>, а для освобождения "
"<function>pfree</function><placeholder-2/>, вместо соответствующих функций "
"библиотеки C <function>malloc</function> и <function>free</function>. "
"Память, выделяемая функцией <function>palloc</function>, будет автоматически "
"освобождаться в конце каждой транзакции, во избежание утечек памяти."

#: xfunc.xml:2498(para)
msgid ""
"Always zero the bytes of your structures using <function>memset</function> "
"(or allocate them with <function>palloc0</function> in the first place). "
"Even if you assign to each field of your structure, there might be alignment "
"padding (holes in the structure) that contain garbage values. Without this, "
"it's difficult to support hash indexes or hash joins, as you must pick out "
"only the significant bits of your data structure to compute a hash. The "
"planner also sometimes relies on comparing constants via bitwise equality, "
"so you can get undesirable planning results if logically-equivalent values "
"aren't bitwise equal."
msgstr ""
"Всегда обнуляйте байты ваших структур, применяя <function>memset</function> "
"(или сразу выделяйте память функцией <function>palloc0</function>). Даже "
"если вы присвоите значение каждому полю структуры, в ней могут оставаться "
"байты выравнивания (пустоты в структуре), содержащие случайные значения. "
"Если исключить это требование, будет сложно поддерживать индексы или "
"соединение по хешу, так как для вычисления хеша придётся выбирать только "
"значащие биты из вашей структуры данных. Планировщик также иногда полагается "
"на побитовое сравнение констант, так что результаты планирования могут "
"оказаться неожиданными, если логически равные значения окажутся неравными на "
"битовом уровне."

#: xfunc.xml:2513(para)
msgid ""
"Most of the internal <productname>PostgreSQL</productname> types are "
"declared in <filename>postgres.h</filename>, while the function manager "
"interfaces (<symbol>PG_FUNCTION_ARGS</symbol>, etc.) are in <filename>fmgr."
"h</filename>, so you will need to include at least these two files. For "
"portability reasons it's best to include <filename>postgres.h</filename> "
"<emphasis>first</emphasis>, before any other system or user header files. "
"Including <filename>postgres.h</filename> will also include <filename>elog."
"h</filename> and <filename>palloc.h</filename> for you."
msgstr ""
"Большинство внутренних типов <productname>PostgreSQL</productname> объявлены "
"в <filename>postgres.h</filename>, тогда как интерфейс менеджера функций "
"(<symbol>PG_FUNCTION_ARGS</symbol> и т. д.) определён в <filename>fmgr.h</"
"filename>, так что потребуется подключить как минимум два этих файла. По "
"соображениям портируемости, лучше включить <filename>postgres.h</filename> "
"<emphasis>первым</emphasis>, до каких-либо других системных или "
"пользовательских файлов заголовков. При подключении <filename>postgres.h</"
"filename> автоматически также будут подключены <filename>elog.h</filename> и "
"<filename>palloc.h</filename>."

#: xfunc.xml:2529(para)
msgid ""
"Symbol names defined within object files must not conflict with each other "
"or with symbols defined in the <productname>PostgreSQL</productname> server "
"executable. You will have to rename your functions or variables if you get "
"error messages to this effect."
msgstr ""
"Имена символов, определённые в объектных файлах, не должны конфликтовать "
"друг с другом или с именами других символов, определённых в исполняемых "
"файлах сервера <productname>PostgreSQL</productname>. Если вы столкнётесь с "
"ошибками, вызванными таким конфликтом, вам придётся переименовать ваши "
"функции или переменные."

#: xfunc.xml:2453(para)
msgid ""
"The basic rules for writing and building C functions are as follows: "
"<placeholder-1/>"
msgstr ""
"Основные правила написания и компиляции функций на C таковы: <placeholder-1/>"

#: xfunc.xml:2544(title)
msgid "Composite-type Arguments"
msgstr "Аргументы составного типа"

#: xfunc.xml:2546(para)
msgid ""
"Composite types do not have a fixed layout like C structures. Instances of a "
"composite type can contain null fields. In addition, composite types that "
"are part of an inheritance hierarchy can have different fields than other "
"members of the same inheritance hierarchy. Therefore, "
"<productname>PostgreSQL</productname> provides a function interface for "
"accessing fields of composite types from C."
msgstr ""
"Составные типы не имеют фиксированного макета данных, как структуры C. В "
"частности, экземпляры составного типа могут содержать поля NULL. Кроме того, "
"в контексте наследования составные типы могут иметь разные поля для разных "
"членов в одной иерархии наследования. Поэтому <productname>PostgreSQL</"
"productname> предоставляет функциям специальный интерфейс для обращения к "
"полям составных типов из C."

#: xfunc.xml:2559(programlisting)
#, no-wrap
msgid ""
"SELECT name, c_overpaid(emp, 1500) AS overpaid\n"
"    FROM emp\n"
"    WHERE name = 'Bill' OR name = 'Sam';"
msgstr ""
"SELECT name, c_overpaid(emp, 1500) AS overpaid\n"
"    FROM emp\n"
"    WHERE name = 'Bill' OR name = 'Sam';"

#: xfunc.xml:2556(para)
msgid ""
"Suppose we want to write a function to answer the query: <placeholder-1/> "
"Using call conventions version 0, we can define <function>c_overpaid</"
"function> as: <placeholder-2/> In version-1 coding, the above would look "
"like this: <placeholder-3/>"
msgstr ""
"Предположим, что мы хотим написать функцию, отвечающую на запрос: "
"<placeholder-1/> С соглашением о вызовах версии 0 мы можем определить "
"функцию <function>c_overpaid</function> так: <placeholder-2/> Для версии 1 "
"она будет выглядеть следующим образом: <placeholder-3/>"

#: xfunc.xml:2622(para)
msgid ""
"<function>GetAttributeByName</function> is the <productname>PostgreSQL</"
"productname> system function that returns attributes out of the specified "
"row. It has three arguments: the argument of type <type>HeapTupleHeader</"
"type> passed into the function, the name of the desired attribute, and a "
"return parameter that tells whether the attribute is null. "
"<function>GetAttributeByName</function> returns a <type>Datum</type> value "
"that you can convert to the proper data type by using the appropriate "
"<function>DatumGet<replaceable>XXX</replaceable>()</function> macro. Note "
"that the return value is meaningless if the null flag is set; always check "
"the null flag before trying to do anything with the result."
msgstr ""
"<function>GetAttributeByName</function> — это системная функция "
"<productname>PostgreSQL</productname>, которая возвращает атрибуты указанной "
"строки. Она принимает три параметра: аргумент типа <type>HeapTupleHeader</"
"type>, имя нужного атрибута и выходной параметр, устанавливаемый, если "
"значение атрибута — NULL. <function>GetAttributeByName</function> возвращает "
"значение <type>Datum</type>, которое вы можете привести к подходящему типу "
"данных, используя соответствующий макрос <function>DatumGet<replaceable>XXX</"
"replaceable>()</function>. Заметьте, что возвращаемое значение "
"недействительно, если установлен флаг null; всегда проверяйте этот флаг, "
"прежде чем что-либо делать с результатом."

#: xfunc.xml:2638(para)
msgid ""
"There is also <function>GetAttributeByNum</function>, which selects the "
"target attribute by column number instead of name."
msgstr ""
"Есть также функция <function>GetAttributeByNum</function>, которая выбирает "
"целевой атрибут не по имени, а по номеру столбца."

#: xfunc.xml:2647(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean\n"
"    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_overpaid'\n"
"    LANGUAGE C STRICT;"
msgstr ""
"CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean\n"
"    AS '<replaceable>КАТАЛОГ</replaceable>/funcs', 'c_overpaid'\n"
"    LANGUAGE C STRICT;"

#: xfunc.xml:2643(para)
msgid ""
"The following command declares the function <function>c_overpaid</function> "
"in SQL: <placeholder-1/> Notice we have used <literal>STRICT</literal> so "
"that we did not have to check whether the input arguments were NULL."
msgstr ""
"Следующая команда объявляет функцию <function>c_overpaid</function> в SQL: "
"<placeholder-1/> Заметьте, что мы использовали <literal>STRICT</literal>, "
"чтобы нам не пришлось проверять входные аргументы на равенство NULL."

#: xfunc.xml:2659(title)
msgid "Returning Rows (Composite Types)"
msgstr "Возврат строк (составных типов)"

#: xfunc.xml:2666(programlisting)
#, no-wrap
msgid "#include \"funcapi.h\""
msgstr "#include \"funcapi.h\""

#: xfunc.xml:2661(para)
msgid ""
"To return a row or composite-type value from a C-language function, you can "
"use a special API that provides macros and functions to hide most of the "
"complexity of building composite data types. To use this API, the source "
"file must include: <placeholder-1/>"
msgstr ""
"Чтобы вернуть строку или значение составного типа из функции на языке C, "
"можно использовать специальный API, предоставляющий макросы и функции, "
"скрывающие основную сложность формирования составных типов данных. Для "
"использования этого API необходимо включить в исходный файл: <placeholder-1/>"

#: xfunc.xml:2671(para)
msgid ""
"There are two ways you can build a composite data value (henceforth a "
"<quote>tuple</quote>): you can build it from an array of Datum values, or "
"from an array of C strings that can be passed to the input conversion "
"functions of the tuple's column data types. In either case, you first need "
"to obtain or construct a <structname>TupleDesc</structname> descriptor for "
"the tuple structure. When working with Datums, you pass the "
"<structname>TupleDesc</structname> to <function>BlessTupleDesc</function>, "
"and then call <function>heap_form_tuple</function> for each row. When "
"working with C strings, you pass the <structname>TupleDesc</structname> to "
"<function>TupleDescGetAttInMetadata</function>, and then call "
"<function>BuildTupleFromCStrings</function> for each row. In the case of a "
"function returning a set of tuples, the setup steps can all be done once "
"during the first call of the function."
msgstr ""
"Сформировать значение составного типа (далее <quote>кортеж</quote>) можно "
"двумя способами: его можно построить из массива значений Datum, или из "
"массива строк C, которые будут переданы функциям преобразования ввода для "
"типов столбцов кортежа. В любом случае, сначала нужно получить или "
"сконструировать дескриптор <structname>TupleDesc</structname> для структуры "
"кортежа. Работая со значениями Datum, вы передаёте <structname>TupleDesc</"
"structname> функции <function>BlessTupleDesc</function>, а затем вызываете "
"<function>heap_form_tuple</function> для каждой строки. Работая со строками "
"C, вы передаёте <structname>TupleDesc</structname> функции "
"<function>TupleDescGetAttInMetadata</function>, а затем для каждой строки "
"вызываете <function>BuildTupleFromCStrings</function>. В случае функции, "
"возвращающей множество кортежей, все подготовительные действия можно "
"выполнить один раз при первом вызове функции."

#: xfunc.xml:2691(programlisting)
#, no-wrap
msgid ""
"TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,\n"
"                                   Oid *resultTypeId,\n"
"                                   TupleDesc *resultTupleDesc)"
msgstr ""
"TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,\n"
"                                   Oid *resultTypeId,\n"
"                                   TupleDesc *resultTupleDesc)"

#: xfunc.xml:2687(para)
msgid ""
"Several helper functions are available for setting up the needed "
"<structname>TupleDesc</structname>. The recommended way to do this in most "
"functions returning composite values is to call: <placeholder-1/> passing "
"the same <literal>fcinfo</literal> struct passed to the calling function "
"itself. (This of course requires that you use the version-1 calling "
"conventions.) <varname>resultTypeId</varname> can be specified as "
"<literal>NULL</literal> or as the address of a local variable to receive the "
"function's result type OID. <varname>resultTupleDesc</varname> should be the "
"address of a local <structname>TupleDesc</structname> variable. Check that "
"the result is <literal>TYPEFUNC_COMPOSITE</literal>; if so, "
"<varname>resultTupleDesc</varname> has been filled with the needed "
"<structname>TupleDesc</structname>. (If it is not, you can report an error "
"along the lines of <quote>function returning record called in context that "
"cannot accept type record</quote>.)"
msgstr ""
"Для получения требуемого дескриптора <structname>TupleDesc</structname> "
"предлагается несколько дополнительных функций. Рекомендованный способ "
"возврата составных значений заключается в вызове функции: <placeholder-1/> "
"При этом в <literal>fcinfo</literal> должна передаваться та же структура, "
"что была передана самой вызывающей функции. (Для этого, конечно, необходимо "
"использовать соглашения о вызовах версии 1.) В <varname>resultTypeId</"
"varname> можно передать <literal>NULL</literal> или адрес локальной "
"переменной, в которую будет записан OID типа результата функции. В "
"<varname>resultTupleDesc</varname> должен передаваться адрес локальной "
"переменной <structname>TupleDesc</structname>. Убедить, что функция "
"возвратила результат <literal>TYPEFUNC_COMPOSITE</literal>; в этом случае, в "
"<varname>resultTupleDesc</varname> оказывается требуемая структура "
"<structname>TupleDesc</structname>. (Если получен другой результат, вы "
"можете выдать ошибку с сообщением <quote>функция, возвращающая запись, "
"вызвана в контексте, не допускающем этот тип</quote>.)"

#: xfunc.xml:2710(para)
msgid ""
"<function>get_call_result_type</function> can resolve the actual type of a "
"polymorphic function result; so it is useful in functions that return scalar "
"polymorphic results, not only functions that return composites. The "
"<varname>resultTypeId</varname> output is primarily useful for functions "
"returning polymorphic scalars."
msgstr ""
"<function>get_call_result_type</function> позволяет получить фактический тип "
"результата полиморфной функции, так что она полезна и в функциях, "
"возвращающих скалярные полиморфные результаты, не только в функциях, "
"возвращающих составные типы. Выходной параметр <varname>resultTypeId</"
"varname> полезен в первую очередь для полиморфных скалярных функций."

#: xfunc.xml:2720(para)
msgid ""
"<function>get_call_result_type</function> has a sibling "
"<function>get_expr_result_type</function>, which can be used to resolve the "
"expected output type for a function call represented by an expression tree. "
"This can be used when trying to determine the result type from outside the "
"function itself. There is also <function>get_func_result_type</function>, "
"which can be used when only the function's OID is available. However these "
"functions are not able to deal with functions declared to return "
"<structname>record</structname>, and <function>get_func_result_type</"
"function> cannot resolve polymorphic types, so you should preferentially use "
"<function>get_call_result_type</function>."
msgstr ""
"В дополнение к <function>get_call_result_type</function> есть схожая функция "
"<function>get_expr_result_type</function>, позволяющая получить ожидаемый "
"тип результата для вызова функции, представленного деревом выражения. Её "
"можно использовать, когда тип результата нужно определить извне самой "
"функции. Есть также функция <function>get_func_result_type</function>, "
"которую можно применять, когда известен только OID функции. Однако эти две "
"функции неспособны выдать тип результата функций, возвращающих "
"<structname>record</structname>, а <function>get_func_result_type</function> "
"неспособна разрешать полиморфные типы, так что вместо них лучше использовать "
"<function>get_call_result_type</function>."

#: xfunc.xml:2737(programlisting)
#, no-wrap
msgid "TupleDesc RelationNameGetTupleDesc(const char *relname)"
msgstr "TupleDesc RelationNameGetTupleDesc(const char *relname)"

#: xfunc.xml:2742(programlisting)
#, no-wrap
msgid "TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)"
msgstr "TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)"

#: xfunc.xml:2734(para)
msgid ""
"Older, now-deprecated functions for obtaining <structname>TupleDesc</"
"structname>s are: <placeholder-1/> to get a <structname>TupleDesc</"
"structname> for the row type of a named relation, and: <placeholder-2/> to "
"get a <structname>TupleDesc</structname> based on a type OID. This can be "
"used to get a <structname>TupleDesc</structname> for a base or composite "
"type. It will not work for a function that returns <structname>record</"
"structname>, however, and it cannot resolve polymorphic types."
msgstr ""
"Ранее для получения <structname>TupleDesc</structname> использовались теперь "
"уже устаревшие функции: <placeholder-1/> (возвращает <structname>TupleDesc</"
"structname> для типа строк указанного отношения) и: <placeholder-2/> "
"(возвращает <structname>TupleDesc</structname> для типа, задаваемого по "
"OID). Применяя её, можно получить <structname>TupleDesc</structname> для "
"базового или составного типа. Однако она не подойдёт для функции, "
"возвращающей тип <structname>record</structname>, и не сможет разрешить "
"полиморфные типы."

#: xfunc.xml:2754(programlisting)
#, no-wrap
msgid "TupleDesc BlessTupleDesc(TupleDesc tupdesc)"
msgstr "TupleDesc BlessTupleDesc(TupleDesc tupdesc)"

#: xfunc.xml:2758(programlisting)
#, no-wrap
msgid "AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)"
msgstr "AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)"

#: xfunc.xml:2752(para)
msgid ""
"Once you have a <structname>TupleDesc</structname>, call: <placeholder-1/> "
"if you plan to work with Datums, or: <placeholder-2/> if you plan to work "
"with C strings. If you are writing a function returning set, you can save "
"the results of these functions in the <structname>FuncCallContext</"
"structname> structure &mdash; use the <structfield>tuple_desc</structfield> "
"or <structfield>attinmeta</structfield> field respectively."
msgstr ""
"Получив <structname>TupleDesc</structname>, вызовите: <placeholder-1/> если "
"вы планируете работать со структурами Datum, либо: <placeholder-2/> если "
"планируете работать со строками C. Если вы разрабатываете функцию, "
"возвращающую набор данных, вы можете сохранить результаты этих функций в "
"структуре <structname>FuncCallContext</structname>, в поле "
"<structfield>tuple_desc</structfield> или <structfield>attinmeta</"
"structfield>, соответственно."

#: xfunc.xml:2770(programlisting)
#, no-wrap
msgid "HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)"
msgstr "HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)"

#: xfunc.xml:2768(para)
msgid ""
"When working with Datums, use: <placeholder-1/> to build a "
"<structname>HeapTuple</structname> given user data in Datum form."
msgstr ""
"Если вы работаете со структурами Datum, воспользуйтесь функцией: "
"<placeholder-1/> Она формирует <structname>HeapTuple</structname> из "
"переданных ей данных в форме Datum."

#: xfunc.xml:2778(programlisting)
#, no-wrap
msgid "HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)"
msgstr "HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)"

#: xfunc.xml:2776(para)
msgid ""
"When working with C strings, use: <placeholder-1/> to build a "
"<structname>HeapTuple</structname> given user data in C string form. "
"<parameter>values</parameter> is an array of C strings, one for each "
"attribute of the return row. Each C string should be in the form expected by "
"the input function of the attribute data type. In order to return a null "
"value for one of the attributes, the corresponding pointer in the "
"<parameter>values</parameter> array should be set to <symbol>NULL</symbol>. "
"This function will need to be called again for each row you return."
msgstr ""
"Если вы работаете со строками C, воспользуйтесь функцией: <placeholder-1/> "
"Она формирует <structname>HeapTuple</structname> из переданных ей данных в "
"виде строк C. В параметре <parameter>values</parameter> ей передаётся массив "
"строк C, по одной для каждого атрибута выходной строки. Каждая из этих строк "
"должна иметь формат, принимаемый функцией ввода типа данных атрибута. Чтобы "
"задать значение NULL для одного из этих атрибутов, вместо соответствующего "
"указателя в массиве <parameter>values</parameter> нужно передать "
"<symbol>NULL</symbol>. Эту функцию нужно вызывать для каждой строки, которую "
"вы будете возвращать."

#: xfunc.xml:2794(programlisting)
#, no-wrap
msgid "HeapTupleGetDatum(HeapTuple tuple)"
msgstr "HeapTupleGetDatum(HeapTuple tuple)"

#: xfunc.xml:2791(para)
msgid ""
"Once you have built a tuple to return from your function, it must be "
"converted into a <type>Datum</type>. Use: <placeholder-1/> to convert a "
"<structname>HeapTuple</structname> into a valid Datum. This <type>Datum</"
"type> can be returned directly if you intend to return just a single row, or "
"it can be used as the current return value in a set-returning function."
msgstr ""
"Получив кортеж, который вы будете возвращать из вашей функции, вы должны "
"преобразовать его в тип <type>Datum</type>. Чтобы преобразовать "
"<structname>HeapTuple</structname> в Datum, воспользуйтесь функцией: "
"<placeholder-1/> Полученный тип <type>Datum</type> можно вернуть "
"непосредственно, если должна возвращаться только одна строка, либо "
"использовать как текущее выдаваемое значение в функции, возвращающей набор "
"строк."

#: xfunc.xml:2803(para)
msgid "An example appears in the next section."
msgstr "Пример приведён в следующем разделе."

#: xfunc.xml:2810(title)
msgid "Returning Sets"
msgstr "Возврат множеств"

#: xfunc.xml:2812(para)
msgid ""
"There is also a special API that provides support for returning sets "
"(multiple rows) from a C-language function. A set-returning function must "
"follow the version-1 calling conventions. Also, source files must include "
"<filename>funcapi.h</filename>, as above."
msgstr ""
"Есть также специальный интерфейс, который позволяет функциям на C возвращать "
"множества (несколько строк). Функции, возвращающие множества, должны "
"следовать соглашению о вызовах версии 1. Кроме того, соответствующие "
"исходные файлы должны включать <filename>funcapi.h</filename>, как показано "
"выше."

#: xfunc.xml:2829(programlisting)
#, no-wrap
msgid ""
"typedef struct FuncCallContext\n"
"{\n"
"    /*\n"
"     * Number of times we've been called before\n"
"     *\n"
"     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and\n"
"     * incremented for you every time SRF_RETURN_NEXT() is called.\n"
"     */\n"
"    uint64 call_cntr;\n"
"\n"
"    /*\n"
"     * OPTIONAL maximum number of calls\n"
"     *\n"
"     * max_calls is here for convenience only and setting it is optional.\n"
"     * If not set, you must provide alternative means to know when the\n"
"     * function is done.\n"
"     */\n"
"    uint64 max_calls;\n"
"\n"
"    /*\n"
"     * OPTIONAL pointer to result slot\n"
"     *\n"
"     * This is obsolete and only present for backward compatibility, viz,\n"
"     * user-defined SRFs that use the deprecated TupleDescGetSlot().\n"
"     */\n"
"    TupleTableSlot *slot;\n"
"\n"
"    /*\n"
"     * OPTIONAL pointer to miscellaneous user-provided context information\n"
"     *\n"
"     * user_fctx is for use as a pointer to your own data to retain\n"
"     * arbitrary context information between calls of your function.\n"
"     */\n"
"    void *user_fctx;\n"
"\n"
"    /*\n"
"     * OPTIONAL pointer to struct containing attribute type input metadata\n"
"     *\n"
"     * attinmeta is for use when returning tuples (i.e., composite data types)\n"
"     * and is not used when returning base data types. It is only needed\n"
"     * if you intend to use BuildTupleFromCStrings() to create the return\n"
"     * tuple.\n"
"     */\n"
"    AttInMetadata *attinmeta;\n"
"\n"
"    /*\n"
"     * memory context used for structures that must live for multiple calls\n"
"     *\n"
"     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used\n"
"     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory\n"
"     * context for any memory that is to be reused across multiple calls\n"
"     * of the SRF.\n"
"     */\n"
"    MemoryContext multi_call_memory_ctx;\n"
"\n"
"    /*\n"
"     * OPTIONAL pointer to struct containing tuple description\n"
"     *\n"
"     * tuple_desc is for use when returning tuples (i.e., composite data types)\n"
"     * and is only needed if you are going to build the tuples with\n"
"     * heap_form_tuple() rather than with BuildTupleFromCStrings().  Note that\n"
"     * the TupleDesc pointer stored here should usually have been run through\n"
"     * BlessTupleDesc() first.\n"
"     */\n"
"    TupleDesc tuple_desc;\n"
"\n"
"} FuncCallContext;"
msgstr ""
"typedef struct FuncCallContext\n"
"{\n"
"    /*\n"
"     * Счётчик числа ранее выполненных вызовов\n"
"     *\n"
"     * call_cntr сбрасывается в 0 макросом SRF_FIRSTCALL_INIT() и\n"
"     * увеличивается на 1 каждый раз, когда вызывается SRF_RETURN_NEXT().\n"
"     */\n"
"    uint64 call_cntr;\n"
"\n"
"    /*\n"
"     * Максимальное число вызовов (может не использоваться)\n"
"     *\n"
"     * max_calls не является обязательным и присутствует здесь только для удобства.\n"
"     * Если это значение не задано, вы должны предоставить другую возможность определить,\n"
"     * когда функция завершила свою работу.\n"
"     */\n"
"    uint64 max_calls;\n"
"\n"
"    /*\n"
"     * Указатель на слот результата (может не использоваться)\n"
"     *\n"
"     * Это поле устарело и представлено только для обратной совместимости, а именно,\n"
"     * для пользовательских SRF, использующих устаревшую TupleDescGetSlot().\n"
"     */\n"
"    TupleTableSlot *slot;\n"
"\n"
"    /*\n"
"     * Указатель на разнообразную контекстную информацию,\n"
"     * представленную пользователем; (может не использоваться)\n"
"     *\n"
"     * user_fctx используется как указатель на ваши собственные данные,\n"
"     * позволяющий сохранить контекстную информацию между вызовами функции.\n"
"     */\n"
"    void *user_fctx;\n"
"\n"
"    /*\n"
"     * Указатель на структуру, содержащую метаданные ввода типа атрибута\n"
"     * (может не использоваться)\n"
"     *\n"
"     * attinmeta задействуется, когда возвращаются кортежи (т. е. составные типы данных),\n"
"     * и не применяется для возврата базовых типов. Он нужен, только если\n"
"     * вы планируете использовать BuildTupleFromCStrings() для формирования возвращаемого\n"
"     * кортежа.\n"
"     */\n"
"    AttInMetadata *attinmeta;\n"
"\n"
"    /*\n"
"     * Контекст памяти, нужный для структур, которые должны сохраняться при нескольких вызовах\n"
"     *\n"
"     * Поле multi_call_memory_ctx заполняется в SRF_FIRSTCALL_INIT() и используется\n"
"     * в SRF_RETURN_DONE() для очистки. Это наиболее подходящий контекст\n"
"     * для любых блоков памяти, которые должны многократно использоваться при\n"
"     * повторных вызовах SRF.\n"
"     */\n"
"    MemoryContext multi_call_memory_ctx;\n"
"\n"
"    /*\n"
"     * Указатель на структуру, содержащую описание кортежа (может не использоваться)\n"
"     *\n"
"     * tuple_desc задействуется, когда возвращаются кортежи (т. е. составные типы),\n"
"     * и нужен только, если вы планируете формировать кортежи с помощью функции\n"
"     * heap_form_tuple(), а не BuildTupleFromCStrings().  Заметьте, что сохраняемый\n"
"     * здесь указатель TupleDesc обычно должен сначала пройти через вызов\n"
"     * BlessTupleDesc().\n"
"     */\n"
"    TupleDesc tuple_desc;\n"
"\n"
"} FuncCallContext;"

#: xfunc.xml:2820(para)
msgid ""
"A set-returning function (<acronym>SRF</acronym>) is called once for each "
"item it returns. The <acronym>SRF</acronym> must therefore save enough state "
"to remember what it was doing and return the next item on each call. The "
"structure <structname>FuncCallContext</structname> is provided to help "
"control this process. Within a function, <literal>fcinfo-&gt;flinfo-&gt;"
"fn_extra</literal> is used to hold a pointer to <structname>FuncCallContext</"
"structname> across calls. <placeholder-1/>"
msgstr ""
"Функция, возвращающая множество (<acronym>SRF</acronym>, Set-Returning "
"Function), вызывается каждый раз для очередной записи. Таким образом, "
"<acronym>SRF</acronym> должна сохранять достаточно информации о состоянии, "
"чтобы понимать, что она делает, и выдать очередную запись при следующем "
"вызове. Для облегчения управления этим процессом представлена структура "
"<structname>FuncCallContext</structname>. Для кода функции указатель на эту "
"структуру <structname>FuncCallContext</structname> сохраняется между "
"вызовами в поле <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>. "
"<placeholder-1/>"

#: xfunc.xml:2904(programlisting)
#, no-wrap
msgid "SRF_IS_FIRSTCALL()"
msgstr "SRF_IS_FIRSTCALL()"

#: xfunc.xml:2909(programlisting)
#, no-wrap
msgid "SRF_FIRSTCALL_INIT()"
msgstr "SRF_FIRSTCALL_INIT()"

#: xfunc.xml:2914(programlisting)
#, no-wrap
msgid "SRF_PERCALL_SETUP()"
msgstr "SRF_PERCALL_SETUP()"

#: xfunc.xml:2900(para)
msgid ""
"An <acronym>SRF</acronym> uses several functions and macros that "
"automatically manipulate the <structname>FuncCallContext</structname> "
"structure (and expect to find it via <literal>fn_extra</literal>). Use: "
"<placeholder-1/> to determine if your function is being called for the first "
"or a subsequent time. On the first call (only) use: <placeholder-2/> to "
"initialize the <structname>FuncCallContext</structname>. On every function "
"call, including the first, use: <placeholder-3/> to properly set up for "
"using the <structname>FuncCallContext</structname> and clearing any "
"previously returned data left over from the previous pass."
msgstr ""
"В <acronym>SRF</acronym> применяются различные функции и макросы, "
"автоматически манипулирующие структурой <structname>FuncCallContext</"
"structname> (они обращаются к ней через <literal>fn_extra</literal>). В "
"частности, чтобы определить, была ли функция вызвана в первый или "
"последующий раз, используйте: <placeholder-1/> Чтобы инициализировать "
"<structname>FuncCallContext</structname> при первом вызове (и только), "
"используйте: <placeholder-2/> Чтобы подготовиться к использованию "
"<structname>FuncCallContext</structname> и очистить все ранее возвращённые "
"данные, оставшиеся после предыдущего прохода, при каждом вызове функции, в "
"том числе, первом, выполните: <placeholder-3/>"

#: xfunc.xml:2924(programlisting)
#, no-wrap
msgid "SRF_RETURN_NEXT(funcctx, result)"
msgstr "SRF_RETURN_NEXT(funcctx, result)"

#: xfunc.xml:2931(programlisting)
#, no-wrap
msgid "SRF_RETURN_DONE(funcctx)"
msgstr "SRF_RETURN_DONE(funcctx)"

#: xfunc.xml:2922(para)
msgid ""
"If your function has data to return, use: <placeholder-1/> to return it to "
"the caller. (<literal>result</literal> must be of type <type>Datum</type>, "
"either a single value or a tuple prepared as described above.) Finally, when "
"your function is finished returning data, use: <placeholder-2/> to clean up "
"and end the <acronym>SRF</acronym>."
msgstr ""
"Если у вашей функции есть данные, которые нужно возвратить, выполните: "
"<placeholder-1/> для того, чтобы выдать их вызывающему. (Переменная "
"<literal>result</literal> должна быть типа <type>Datum</type>, либо одним "
"значением, либо кортежем, подготовленным как описано выше.) Наконец, когда "
"ваша функция закончила возвращать данные, выполните: <placeholder-2/> для "
"того, чтобы провести очистку и завершить <acronym>SRF</acronym>."

#: xfunc.xml:2937(para)
msgid ""
"The memory context that is current when the <acronym>SRF</acronym> is called "
"is a transient context that will be cleared between calls. This means that "
"you do not need to call <function>pfree</function> on everything you "
"allocated using <function>palloc</function>; it will go away anyway. "
"However, if you want to allocate any data structures to live across calls, "
"you need to put them somewhere else. The memory context referenced by "
"<structfield>multi_call_memory_ctx</structfield> is a suitable location for "
"any data that needs to survive until the <acronym>SRF</acronym> is finished "
"running. In most cases, this means that you should switch into "
"<structfield>multi_call_memory_ctx</structfield> while doing the first-call "
"setup."
msgstr ""
"Контекст памяти, в котором вызывается <acronym>SRF</acronym>, временный, он "
"будет очищаться между вызовами. Это значит, что вам не нужно вызывать "
"<function>pfree</function> для всех блоков памяти, которые вы получили через "
"<function>palloc</function>; они всё равно будут освобождены. Однако, если "
"вы хотите выделить структуры данных и сохранить их между вызовами, вам нужно "
"разместить их где-то в другом месте. Для размещения таких данных, которые не "
"должны уничтожаться, пока <acronym>SRF</acronym> не закончит работу, "
"подходит контекст памяти, на который указывает "
"<structfield>multi_call_memory_ctx</structfield>. В большинстве случаев это "
"означает, что вы должны переключиться в контекст "
"<structfield>multi_call_memory_ctx</structfield> в коде подготовки при "
"первом вызове."

#: xfunc.xml:2951(para)
msgid ""
"While the actual arguments to the function remain unchanged between calls, "
"if you detoast the argument values (which is normally done transparently by "
"the <function>PG_GETARG_<replaceable>xxx</replaceable></function> macro) in "
"the transient context then the detoasted copies will be freed on each cycle. "
"Accordingly, if you keep references to such values in your "
"<structfield>user_fctx</structfield>, you must either copy them into the "
"<structfield>multi_call_memory_ctx</structfield> after detoasting, or ensure "
"that you detoast the values only in that context."
msgstr ""
"Тогда как фактические аргументы такой функции не меняются от вызова к "
"вызову, если вы распаковываете значения аргументов (что обычно прозрачно "
"делают макросы <function>PG_GETARG_<replaceable>xxx</replaceable></"
"function>) во временном контексте, распакованные копии будут освобождаться "
"при каждом вызове. Соответственно, если вы сохраните ссылки на такие "
"значения в своём контексте <structfield>user_fctx</structfield>, вы должны "
"либо скопировать эти значения в <structfield>multi_call_memory_ctx</"
"structfield> после распаковки, либо распаковывать значения только в этом "
"контексте."

#: xfunc.xml:2966(programlisting)
#, no-wrap
msgid ""
"Datum\n"
"my_set_returning_function(PG_FUNCTION_ARGS)\n"
"{\n"
"    FuncCallContext  *funcctx;\n"
"    Datum             result;\n"
"    <replaceable>further declarations as needed</replaceable>\n"
"\n"
"    if (SRF_IS_FIRSTCALL())\n"
"    {\n"
"        MemoryContext oldcontext;\n"
"\n"
"        funcctx = SRF_FIRSTCALL_INIT();\n"
"        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);\n"
"        /* One-time setup code appears here: */\n"
"        <replaceable>user code</replaceable>\n"
"        <replaceable>if returning composite</replaceable>\n"
"            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>\n"
"        <replaceable>endif returning composite</replaceable>\n"
"        <replaceable>user code</replaceable>\n"
"        MemoryContextSwitchTo(oldcontext);\n"
"    }\n"
"\n"
"    /* Each-time setup code appears here: */\n"
"    <replaceable>user code</replaceable>\n"
"    funcctx = SRF_PERCALL_SETUP();\n"
"    <replaceable>user code</replaceable>\n"
"\n"
"    /* this is just one way we might test whether we are done: */\n"
"    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)\n"
"    {\n"
"        /* Here we want to return another item: */\n"
"        <replaceable>user code</replaceable>\n"
"        <replaceable>obtain result Datum</replaceable>\n"
"        SRF_RETURN_NEXT(funcctx, result);\n"
"    }\n"
"    else\n"
"    {\n"
"        /* Here we are done returning items and just need to clean up: */\n"
"        <replaceable>user code</replaceable>\n"
"        SRF_RETURN_DONE(funcctx);\n"
"    }\n"
"}"
msgstr ""
"Datum\n"
"my_set_returning_function(PG_FUNCTION_ARGS)\n"
"{\n"
"    FuncCallContext  *funcctx;\n"
"    Datum             result;\n"
"    <replaceable>другие необходимые объявления</replaceable>\n"
"\n"
"    if (SRF_IS_FIRSTCALL())\n"
"    {\n"
"        MemoryContext oldcontext;\n"
"\n"
"        funcctx = SRF_FIRSTCALL_INIT();\n"
"        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);\n"
"        /* Здесь размещается код подготовки при первом вызове: */\n"
"        <replaceable>некоторый код</replaceable>\n"
"        <replaceable>если возвращается составной тип</replaceable>\n"
"            <replaceable>получить TupleDesc и, возможно, AttInMetadata</replaceable>\n"
"        <replaceable>конец ветвления для составного типа</replaceable>\n"
"        <replaceable>некоторый код</replaceable>\n"
"        MemoryContextSwitchTo(oldcontext);\n"
"    }\n"
"\n"
"    /* Здесь размещается код подготовки для каждого вызова: */\n"
"    <replaceable>некоторый код</replaceable>\n"
"    funcctx = SRF_PERCALL_SETUP();\n"
"    <replaceable>некоторый код</replaceable>\n"
"\n"
"    /* это только один способ определить, не пора ли закончить работу: */\n"
"    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)\n"
"    {\n"
"        /* Здесь мы хотим вернуть следующий результат: */\n"
"        <replaceable>некоторый код</replaceable>\n"
"        <replaceable>получить результирующий Datum</replaceable>\n"
"        SRF_RETURN_NEXT(funcctx, result);\n"
"    }\n"
"    else\n"
"    {\n"
"        /* Здесь мы заканчиваем выдавать результаты и нам нужно провести очистку: */\n"
"        <replaceable>некоторый код</replaceable>\n"
"        SRF_RETURN_DONE(funcctx);\n"
"    }\n"
"}"

#: xfunc.xml:2964(para)
msgid ""
"A complete pseudo-code example looks like the following: <placeholder-1/>"
msgstr "Полный пример с псевдокодом будет выглядеть так: <placeholder-1/>"

#: xfunc.xml:3108(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);\n"
"\n"
"CREATE OR REPLACE FUNCTION retcomposite(integer, integer)\n"
"    RETURNS SETOF __retcomposite\n"
"    AS '<replaceable>filename</replaceable>', 'retcomposite'\n"
"    LANGUAGE C IMMUTABLE STRICT;"
msgstr ""
"CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);\n"
"\n"
"CREATE OR REPLACE FUNCTION retcomposite(integer, integer)\n"
"    RETURNS SETOF __retcomposite\n"
"    AS '<replaceable>имя_файла</replaceable>', 'retcomposite'\n"
"    LANGUAGE C IMMUTABLE STRICT;"

#: xfunc.xml:3117(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,\n"
"    OUT f1 integer, OUT f2 integer, OUT f3 integer)\n"
"    RETURNS SETOF record\n"
"    AS '<replaceable>filename</replaceable>', 'retcomposite'\n"
"    LANGUAGE C IMMUTABLE STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,\n"
"    OUT f1 integer, OUT f2 integer, OUT f3 integer)\n"
"    RETURNS SETOF record\n"
"    AS '<replaceable>имя_файла</replaceable>', 'retcomposite'\n"
"    LANGUAGE C IMMUTABLE STRICT;"

#: xfunc.xml:3012(para)
msgid ""
"A complete example of a simple <acronym>SRF</acronym> returning a composite "
"type looks like: <placeholder-1/> One way to declare this function in SQL "
"is: <placeholder-2/> A different way is to use OUT parameters: "
"<placeholder-3/> Notice that in this method the output type of the function "
"is formally an anonymous <structname>record</structname> type."
msgstr ""
"Полный пример простой <acronym>SRF</acronym>-функции, возвращающей составной "
"тип, выглядит так: <placeholder-1/> В SQL её можно объявить следующим "
"образом: <placeholder-2/> Также её можно объявить с параметрами OUT: "
"<placeholder-3/> Заметьте, что при таком подходе выходным типом функции "
"формально является анонимный тип <structname>record</structname>."

#: xfunc.xml:3128(para)
msgid ""
"The directory <link linkend=\"tablefunc\">contrib/tablefunc</link> module in "
"the source distribution contains more examples of set-returning functions."
msgstr ""
"Каталог <link linkend=\"tablefunc\">contrib/tablefunc</link> в пакете "
"исходного кода содержит дополнительные примеры функций, возвращающих "
"множества."

#: xfunc.xml:3136(title)
msgid "Polymorphic Arguments and Return Types"
msgstr "Полиморфные типы аргументов и результата"

#: xfunc.xml:3138(para)
msgid ""
"C-language functions can be declared to accept and return the polymorphic "
"types <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</"
"type>, <type>anyenum</type>, and <type>anyrange</type>. See <xref linkend="
"\"extend-types-polymorphic\"/> for a more detailed explanation of "
"polymorphic functions. When function arguments or return types are defined "
"as polymorphic types, the function author cannot know in advance what data "
"type it will be called with, or need to return. There are two routines "
"provided in <filename>fmgr.h</filename> to allow a version-1 C function to "
"discover the actual data types of its arguments and the type it is expected "
"to return. The routines are called <literal>get_fn_expr_rettype(FmgrInfo "
"*flinfo)</literal> and <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int "
"argnum)</literal>. They return the result or argument type OID, or "
"<symbol>InvalidOid</symbol> if the information is not available. The "
"structure <literal>flinfo</literal> is normally accessed as <literal>fcinfo-"
"&gt;flinfo</literal>. The parameter <literal>argnum</literal> is zero based. "
"<function>get_call_result_type</function> can also be used as an alternative "
"to <function>get_fn_expr_rettype</function>. There is also "
"<function>get_fn_expr_variadic</function>, which can be used to find out "
"whether variadic arguments have been merged into an array. This is primarily "
"useful for <literal>VARIADIC \"any\"</literal> functions, since such merging "
"will always have occurred for variadic functions taking ordinary array types."
msgstr ""
"Функции на языке C могут быть объявлены как принимающие и возвращающие "
"полиморфные типы <type>anyelement</type>, <type>anyarray</type>, "
"<type>anynonarray</type>, <type>anyenum</type> и <type>anyrange</type>. За "
"более подробным объяснением полиморфных функций обратитесь к <xref remap="
"\"3\" linkend=\"extend-types-polymorphic\"/>. Когда типы аргументов или "
"результат определены как полиморфные, автор функции не может заранее знать, "
"с какими типами данных она будет вызываться и какой возвращать. Чтобы "
"функция на C в стиле версии 1 могла определить фактические типы данных своих "
"аргументов и тип, который она должна вернуть, в <filename>fmgr.h</filename> "
"предлагаются две функции. Они называются "
"<literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal> и "
"<literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal> и "
"возвращают соответственно OID типа результата и аргумента, либо "
"<symbol>InvalidOid</symbol>, если информация о типе отсутствует. Структуру "
"<literal>flinfo</literal> обычно можно получить по ссылке <literal>fcinfo-"
"&gt;flinfo</literal>. Номер аргумента <literal>argnum</literal> задаётся, "
"начиная с нуля. В качестве альтернативы <function>get_fn_expr_rettype</"
"function> также можно использовать функции <function>get_call_result_type</"
"function>. Кроме того, есть функция <function>get_fn_expr_variadic</"
"function>, позволяющая определить, были ли переменные аргументы объединены в "
"массив. Это полезно в основном для функций <literal>VARIADIC \"any\"</"
"literal>, так как такое объединение всегда имеет место для функций с "
"переменными аргументами, принимающих обычные типы."

#: xfunc.xml:3169(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(make_array);\n"
"Datum\n"
"make_array(PG_FUNCTION_ARGS)\n"
"{\n"
"    ArrayType  *result;\n"
"    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);\n"
"    Datum       element;\n"
"    bool        isnull;\n"
"    int16       typlen;\n"
"    bool        typbyval;\n"
"    char        typalign;\n"
"    int         ndims;\n"
"    int         dims[MAXDIM];\n"
"    int         lbs[MAXDIM];\n"
"\n"
"    if (!OidIsValid(element_type))\n"
"        elog(ERROR, \"could not determine data type of input\");\n"
"\n"
"    /* get the provided element, being careful in case it's NULL */\n"
"    isnull = PG_ARGISNULL(0);\n"
"    if (isnull)\n"
"        element = (Datum) 0;\n"
"    else\n"
"        element = PG_GETARG_DATUM(0);\n"
"\n"
"    /* we have one dimension */\n"
"    ndims = 1;\n"
"    /* and one element */\n"
"    dims[0] = 1;\n"
"    /* and lower bound is 1 */\n"
"    lbs[0] = 1;\n"
"\n"
"    /* get required info about the element type */\n"
"    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);\n"
"\n"
"    /* now build the array */\n"
"    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,\n"
"                                element_type, typlen, typbyval, typalign);\n"
"\n"
"    PG_RETURN_ARRAYTYPE_P(result);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(make_array);\n"
"Datum\n"
"make_array(PG_FUNCTION_ARGS)\n"
"{\n"
"    ArrayType  *result;\n"
"    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);\n"
"    Datum       element;\n"
"    bool        isnull;\n"
"    int16       typlen;\n"
"    bool        typbyval;\n"
"    char        typalign;\n"
"    int         ndims;\n"
"    int         dims[MAXDIM];\n"
"    int         lbs[MAXDIM];\n"
"\n"
"    if (!OidIsValid(element_type))\n"
"        elog(ERROR, \"could not determine data type of input\");\n"
"\n"
"    /* получить переданный элемент, учитывая, что это может быть NULL */\n"
"    isnull = PG_ARGISNULL(0);\n"
"    if (isnull)\n"
"        element = (Datum) 0;\n"
"    else\n"
"        element = PG_GETARG_DATUM(0);\n"
"\n"
"    /* мы имеем дело с одной размерностью */\n"
"    ndims = 1;\n"
"    /* и одним элементом */\n"
"    dims[0] = 1;\n"
"    /* с нижней границей, равной 1 */\n"
"    lbs[0] = 1;\n"
"\n"
"    /* получить требуемую информацию о типе элемента */\n"
"    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);\n"
"\n"
"    /* теперь создать массив */\n"
"    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,\n"
"                                element_type, typlen, typbyval, typalign);\n"
"\n"
"    PG_RETURN_ARRAYTYPE_P(result);\n"
"}"

#: xfunc.xml:3165(para)
msgid ""
"For example, suppose we want to write a function to accept a single element "
"of any type, and return a one-dimensional array of that type: <placeholder-1/"
">"
msgstr ""
"Например, предположим, что нам нужно написать функцию, принимающую один "
"элемент любого типа и возвращающую одномерный массив этого типа: "
"<placeholder-1/>"

#: xfunc.xml:3218(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION make_array(anyelement) RETURNS anyarray\n"
"    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'\n"
"    LANGUAGE C IMMUTABLE;"
msgstr ""
"CREATE FUNCTION make_array(anyelement) RETURNS anyarray\n"
"    AS '<replaceable>КАТАЛОГ</replaceable>/funcs', 'make_array'\n"
"    LANGUAGE C IMMUTABLE;"

#: xfunc.xml:3214(para)
msgid ""
"The following command declares the function <function>make_array</function> "
"in SQL: <placeholder-1/>"
msgstr ""
"Следующая команда объявляет функцию <function>make_array</function> в SQL: "
"<placeholder-1/>"

#: xfunc.xml:3225(para)
msgid ""
"There is a variant of polymorphism that is only available to C-language "
"functions: they can be declared to take parameters of type <literal>\"any\"</"
"literal>. (Note that this type name must be double-quoted, since it's also a "
"SQL reserved word.) This works like <type>anyelement</type> except that it "
"does not constrain different <literal>\"any\"</literal> arguments to be the "
"same type, nor do they help determine the function's result type. A C-"
"language function can also declare its final parameter to be "
"<literal>VARIADIC \"any\"</literal>. This will match one or more actual "
"arguments of any type (not necessarily the same type). These arguments will "
"<emphasis>not</emphasis> be gathered into an array as happens with normal "
"variadic functions; they will just be passed to the function separately. The "
"<function>PG_NARGS()</function> macro and the methods described above must "
"be used to determine the number of actual arguments and their types when "
"using this feature. Also, users of such a function might wish to use the "
"<literal>VARIADIC</literal> keyword in their function call, with the "
"expectation that the function would treat the array elements as separate "
"arguments. The function itself must implement that behavior if wanted, after "
"using <function>get_fn_expr_variadic</function> to detect that the actual "
"argument was marked with <literal>VARIADIC</literal>."
msgstr ""
"Существует один вариант полиморфизма, которым могут пользоваться только "
"функции на языке C: их можно объявить с параметрами типа <literal>\"any\"</"
"literal>. (Заметьте, что имя этого типа нужно заключать в двойные кавычки, "
"так как это также зарезервированное слово в SQL.) Он работает так же, как "
"<type>anyelement</type>, за исключением того, что он не требует, чтобы "
"аргументы <literal>\"any\"</literal> имели одинаковый тип, и не помогает "
"определить тип результата функции. Функцию на языке C можно также объявить с "
"последним параметром <literal>VARIADIC \"any\"</literal>. Ему будут "
"соответствовать один или более фактических аргументов любого типа (не "
"обязательно одинакового). Эти аргументы <emphasis>не</emphasis> будут "
"собираться в массив, как это происходит с обычными функциями с переменными "
"аргументами; они просто будут переданы функции по отдельности. Если "
"применяется этот вариант, то чтобы определить число фактических аргументов и "
"их типы, нужно использовать макрос <function>PG_NARGS()</function> и "
"функции, описанные выше. Пользователи такой функции также могут пожелать "
"использовать ключевое слово <literal>VARIADIC</literal> в вызове функции, "
"ожидая, что функция обработает элементы массива как отдельные аргументы. При "
"необходимости соответствующее поведение должна реализовывать сама функция, "
"определив с помощью <function>get_fn_expr_variadic</function>, был ли "
"фактический аргумент передан с указанием <literal>VARIADIC</literal>."

#: xfunc.xml:3249(title)
msgid "Transform Functions"
msgstr "Функции преобразования"

#: xfunc.xml:3251(para)
msgid ""
"Some function calls can be simplified during planning based on properties "
"specific to the function. For example, <literal>int4mul(n, 1)</literal> "
"could be simplified to just <literal>n</literal>. To define such function-"
"specific optimizations, write a <firstterm>transform function</firstterm> "
"and place its OID in the <structfield>protransform</structfield> field of "
"the primary function's <structname>pg_proc</structname> entry. The transform "
"function must have the SQL signature <literal>protransform(internal) RETURNS "
"internal</literal>. The argument, actually <type>FuncExpr *</type>, is a "
"dummy node representing a call to the primary function. If the transform "
"function's study of the expression tree proves that a simplified expression "
"tree can substitute for all possible concrete calls represented thereby, "
"build and return that simplified expression. Otherwise, return a "
"<literal>NULL</literal> pointer (<emphasis>not</emphasis> a SQL null)."
msgstr ""
"Некоторые вызовы функций можно упростить на стадии планирования, в "
"зависимости от особых свойств функции. Например, функцию умножения "
"(<literal>int4mul(n, 1)</literal>) можно упростить просто до <literal>n</"
"literal>. Чтобы определить такую оптимизацию, нужно написать "
"<firstterm>функцию преобразования</firstterm> и поместить её OID в поле "
"<structfield>protransform</structfield> записи основной функции в "
"<structname>pg_proc</structname>. Функция преобразования должна иметь в SQL "
"сигнатуру <literal>protransform(internal) RETURNS internal</literal>. В "
"аргументе, фактически имеющем тип <type>FuncExpr *</type>, передаётся "
"фиктивный узел, представляющий вызов основной функции. Если анализ дерева "
"выражения в функции преобразования показывает, что вместо всех возможных "
"конкретных вызовов может быть подставлено дерево упрощённого выражения, эта "
"функция должна построить и вернуть это упрощённое выражение. В противном "
"случае нужно вернуть указатель <literal>NULL</literal> (<emphasis>не</"
"emphasis> NULL языка SQL)."

#: xfunc.xml:3268(para)
msgid ""
"We make no guarantee that <productname>PostgreSQL</productname> will never "
"call the primary function in cases that the transform function could "
"simplify. Ensure rigorous equivalence between the simplified expression and "
"an actual call to the primary function."
msgstr ""
"Мы не гарантируем, что <productname>PostgreSQL</productname> никогда не "
"будет вызывать основную функцию во всех случаях, когда функция "
"преобразования может её упростить, поэтому важно, чтобы упрощённое выражение "
"строго соответствовало реальному вызову основной функции."

#: xfunc.xml:3275(para)
msgid ""
"Currently, this facility is not exposed to users at the SQL level because of "
"security concerns, so it is only practical to use for optimizing built-in "
"functions."
msgstr ""
"В настоящее время эта функциональность не предоставляется пользователям на "
"уровне SQL из соображений безопасности, так что на практике это можно "
"использовать только для оптимизации встроенных функций."

#: xfunc.xml:3283(title)
msgid "Shared Memory and LWLocks"
msgstr "Разделяемая память и лёгкие блокировки"

#: xfunc.xml:3289(indexterm)
msgid "<primary>shared_preload_libraries</primary>"
msgstr "<primary>shared_preload_libraries</primary>"

#: xfunc.xml:3291(programlisting)
#, no-wrap
msgid "void RequestAddinShmemSpace(int size)"
msgstr "void RequestAddinShmemSpace(int size)"

#: xfunc.xml:3285(para)
msgid ""
"Add-ins can reserve LWLocks and an allocation of shared memory on server "
"startup. The add-in's shared library must be preloaded by specifying it in "
"<xref linkend=\"guc-shared-preload-libraries\"/><placeholder-1/>. Shared "
"memory is reserved by calling: <placeholder-2/> from your "
"<function>_PG_init</function> function."
msgstr ""
"Модули расширений могут резервировать лёгкие блокировки и область в "
"разделяемой памяти при запуске сервера. Чтобы библиотека модуля "
"предварительно загружалась на этапе запуска сервера, нужно указать её в "
"<xref linkend=\"guc-shared-preload-libraries\"/><placeholder-1/>. Чтобы "
"зарезервировать разделяемую память, вызовите из вашей функции "
"<function>_PG_init</function> функцию: <placeholder-2/>"

#: xfunc.xml:3298(programlisting)
#, no-wrap
msgid "void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)"
msgstr "void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)"

#: xfunc.xml:3296(para)
msgid ""
"LWLocks are reserved by calling: <placeholder-1/> from <function>_PG_init</"
"function>. This will ensure that an array of <literal>num_lwlocks</literal> "
"LWLocks is available under the name <literal>tranche_name</literal>. Use "
"<function>GetNamedLWLockTranche</function> to get a pointer to this array."
msgstr ""
"Чтобы зарезервировать лёгкие блокировки, из <function>_PG_init</function> "
"нужно вызвать: <placeholder-1/> В результате будет сформирован массив из "
"<literal>num_lwlocks</literal> лёгких блокировок под именем "
"<literal>tranche_name</literal>. Чтобы получить указатель на этот массив, "
"воспользуйтесь функцией <function>GetNamedLWLockTranche</function>."

#: xfunc.xml:3310(programlisting)
#, no-wrap
msgid ""
"static mystruct *ptr = NULL;\n"
"\n"
"if (!ptr)\n"
"{\n"
"        bool    found;\n"
"\n"
"        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);\n"
"        ptr = ShmemInitStruct(\"my struct name\", size, &amp;found);\n"
"        if (!found)\n"
"        {\n"
"                initialize contents of shmem area;\n"
"                acquire any requested LWLocks using:\n"
"                ptr-&gt;locks = GetNamedLWLockTranche(\"my tranche name\");\n"
"        }\n"
"        LWLockRelease(AddinShmemInitLock);\n"
"}"
msgstr ""
"static mystruct *ptr = NULL;\n"
"\n"
"if (!ptr)\n"
"{\n"
"        bool    found;\n"
"\n"
"        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);\n"
"        ptr = ShmemInitStruct(\"my struct name\", size, &amp;found);\n"
"        if (!found)\n"
"        {\n"
"                /* инициализировать содержимое области разделяемой памяти; */\n"
"                /* получить все требуемые блокировки LWLocks:\n"
" */                ptr-&gt;locks = GetNamedLWLockTranche(\"my tranche name\");\n"
"        }\n"
"        LWLockRelease(AddinShmemInitLock);\n"
"}"

#: xfunc.xml:3306(para)
msgid ""
"To avoid possible race-conditions, each backend should use the LWLock "
"<function>AddinShmemInitLock</function> when connecting to and initializing "
"its allocation of shared memory, as shown here: <placeholder-1/>"
msgstr ""
"Во избежание возможных условий гонки каждый обслуживающий процесс должен "
"вызывать <function>AddinShmemInitLock</function> в момент подключения и при "
"инициализации разделяемой памяти, как показано здесь: <placeholder-1/>"

#: xfunc.xml:3332(title)
msgid "Using C++ for Extensibility"
msgstr "Использование C++ для расширяемости"

#: xfunc.xml:3334(indexterm)
msgid "<primary>C++</primary>"
msgstr "<primary>C++</primary>"

#: xfunc.xml:3345(para)
msgid ""
"All functions accessed by the backend must present a C interface to the "
"backend; these C functions can then call C++ functions. For example, "
"<literal>extern C</literal> linkage is required for backend-accessed "
"functions. This is also necessary for any functions that are passed as "
"pointers between the backend and C++ code."
msgstr ""
"Все функции, к которым будет обращаться сервер, должны предоставлять ему "
"интерфейс C; эти функции на C затем могут вызывать функции на языке C++. В "
"частности, для функций, доступных серверу, необходимо указать "
"<literal>extern C</literal>. Это также необходимо для всех функций, "
"указатели на которые передаются между кодом сервера и подключаемым кодом на C"
"++."

#: xfunc.xml:3355(para)
msgid ""
"Free memory using the appropriate deallocation method. For example, most "
"backend memory is allocated using <function>palloc()</function>, so use "
"<function>pfree()</function> to free it. Using C++ <function>delete</"
"function> in such cases will fail."
msgstr ""
"Освобождайте память, применяя для этого подходящий метод. Например, память "
"сервера в основном выделяется функцией <function>palloc()</function>, так "
"что освобождать её нужно, вызывая <function>pfree()</function>. Попытка "
"использовать в таких случаях принятую в C++ операцию <function>delete</"
"function> приведёт к ошибке."

#: xfunc.xml:3363(para)
msgid ""
"Prevent exceptions from propagating into the C code (use a catch-all block "
"at the top level of all <literal>extern C</literal> functions). This is "
"necessary even if the C++ code does not explicitly throw any exceptions, "
"because events like out-of-memory can still throw exceptions. Any exceptions "
"must be caught and appropriate errors passed back to the C interface. If "
"possible, compile C++ with <option>-fno-exceptions</option> to eliminate "
"exceptions entirely; in such cases, you must check for failures in your C++ "
"code, e.g. check for NULL returned by <function>new()</function>."
msgstr ""
"Не допускайте распространения исключений в код C (добавляйте блок, "
"перехватывающий все исключения, на верхнем уровне функций <literal>extern C</"
"literal>). Это необходимо, даже если код на C++ не генерирует исключения "
"явно, потому что исключения могут возникать, например, и при нехватке "
"памяти. Все исключения должны перехватываться, и в интерфейс C должны "
"передаваться соответствующие ошибки. Если возможно, скомпилируйте код C++ с "
"указанием <option>-fno-exceptions</option>, чтобы полностью отключить "
"исключения; в таких случаях вы должны будете выявлять исключительные "
"ситуации в коде C++, например, проверять на NULL адрес, возвращённый "
"<function>new()</function>."

#: xfunc.xml:3376(para)
msgid ""
"If calling backend functions from C++ code, be sure that the C++ call stack "
"contains only plain old data structures (<acronym>POD</acronym>). This is "
"necessary because backend errors generate a distant <function>longjmp()</"
"function> that does not properly unroll a C++ call stack with non-POD "
"objects."
msgstr ""
"Вызывая серверные функции из кода C++, убедитесь, что в стеке вызова C++ "
"содержатся только простые структуры данных. Это необходимо, потому что в "
"случае ошибки сервера выполняется функция <function>longjmp()</function>, а "
"она не отматывает стек вызовов C++ должным образом для объектов, отличных от "
"простых структур."

#: xfunc.xml:3338(para)
msgid ""
"Although the <productname>PostgreSQL</productname> backend is written in C, "
"it is possible to write extensions in C++ if these guidelines are followed: "
"<placeholder-1/>"
msgstr ""
"Хотя код сервера <productname>PostgreSQL</productname> написан на C, "
"расширения для него можно писать и на C++, если соблюдать эти правила: "
"<placeholder-1/>"

#: xfunc.xml:3387(para)
msgid ""
"In summary, it is best to place C++ code behind a wall of <literal>extern C</"
"literal> functions that interface to the backend, and avoid exception, "
"memory, and call stack leakage."
msgstr ""
"Резюмируя, лучше всего поместить код C++ за ограду из функций "
"<literal>extern C</literal>, которые будут доступны серверу и смогут "
"защитить от исключений, а также потери стека вызовов и утечки памяти."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xfunc.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "Another option is to use functional notation for extracting an attribute. "
#~ "The simple way to explain this is that we can use the notations "
#~ "<literal><replaceable>attribute</replaceable>(<replaceable>table</"
#~ "replaceable>)</literal> and <literal><replaceable>table</replaceable>."
#~ "<replaceable>attribute</replaceable></literal> interchangeably. <screen>\n"
#~ "SELECT name(new_emp());\n"
#~ "\n"
#~ " name\n"
#~ "------\n"
#~ " None\n"
#~ "</screen> <screen>\n"
#~ "-- This is the same as:\n"
#~ "-- SELECT emp.name AS youngster FROM emp WHERE emp.age &lt; 30;\n"
#~ "\n"
#~ "SELECT name(emp) AS youngster FROM emp WHERE age(emp) &lt; 30;\n"
#~ "\n"
#~ " youngster\n"
#~ "-----------\n"
#~ " Sam\n"
#~ " Andy\n"
#~ "</screen>"
#~ msgstr ""
#~ "В качестве ещё одного варианта можно использовать функциональную запись "
#~ "для извлечения атрибута. Проще всего это можно объяснить, отметив, что "
#~ "записи <literal><replaceable>атрибут</replaceable>(<replaceable>таблица</"
#~ "replaceable>)</literal> и <literal><replaceable>таблица</replaceable>."
#~ "<replaceable>атрибут</replaceable></literal> взаимозаменяемы. <screen>\n"
#~ "SELECT name(new_emp());\n"
#~ "\n"
#~ " name\n"
#~ "------\n"
#~ " None\n"
#~ "</screen> <screen>\n"
#~ "-- Это то же самое:\n"
#~ "-- SELECT emp.name AS youngster FROM emp WHERE emp.age &lt; 30;\n"
#~ "\n"
#~ "SELECT name(emp) AS youngster FROM emp WHERE age(emp) &lt; 30;\n"
#~ "\n"
#~ " youngster\n"
#~ "-----------\n"
#~ " Sam\n"
#~ " Andy\n"
#~ "</screen>"

#~ msgid "<primary>computed field</primary>"
#~ msgstr "<primary>вычисляемое поле</primary>"

#~ msgid "<primary>field</primary> <secondary>computed</secondary>"
#~ msgstr "<primary>поле</primary> <secondary>вычисляемое</secondary>"

#~ msgid ""
#~ "The equivalence between functional notation and attribute notation makes "
#~ "it possible to use functions on composite types to emulate "
#~ "<quote>computed fields</quote>. <placeholder-1/> <placeholder-2/> For "
#~ "example, using the previous definition for <literal>double_salary(emp)</"
#~ "literal>, we can write <screen>\n"
#~ "SELECT emp.name, emp.double_salary FROM emp;\n"
#~ "</screen> An application using this wouldn't need to be directly aware "
#~ "that <literal>double_salary</literal> isn't a real column of the table. "
#~ "(You can also emulate computed fields with views.)"
#~ msgstr ""
#~ "Равнозначность функциональной записи и записи с атрибутом позволяет "
#~ "использовать функции с составными типами для имитации <quote>вычисляемых "
#~ "полей</quote>. <placeholder-1/> <placeholder-2/> Например, используя "
#~ "предыдущее определение <literal>double_salary(emp)</literal>, мы можем "
#~ "записать <screen>\n"
#~ "SELECT emp.name, emp.double_salary FROM emp;\n"
#~ "</screen> Приложению, использующему такой запрос, не обязательно "
#~ "определённо знать, что <literal>double_salary</literal> — это не "
#~ "настоящий столбец таблицы. (Вычисляемые поля также можно имитировать в "
#~ "представлениях.)"

#~ msgid ""
#~ "Because of this behavior, it's unwise to give a function that takes a "
#~ "single composite-type argument the same name as any of the fields of that "
#~ "composite type."
#~ msgstr ""
#~ "Вследствие такого поведения, функции, которая принимает один аргумент "
#~ "составного типа, не стоит давать имя, совпадающее с именем одного из "
#~ "полей этого составного типа."

#~ msgid ""
#~ "Still another way to use a function that returns a composite type is to "
#~ "call it as a table function, as described in <xref linkend=\"xfunc-sql-"
#~ "table-functions\"/>."
#~ msgstr ""
#~ "И ещё один способ использовать функцию, возвращающую составной тип — "
#~ "вызвать её как табличную функцию, как описано в <xref remap=\"6\" linkend="
#~ "\"xfunc-sql-table-functions\"/>."
