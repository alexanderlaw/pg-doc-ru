# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-02-06 11:19+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: syntax.xml:5(title)
msgid "SQL Syntax"
msgstr "Синтаксис SQL"

#: syntax.xml:7(indexterm)
msgid "<primary>syntax</primary> <secondary>SQL</secondary>"
msgstr "<primary>синтаксис</primary> <secondary>SQL</secondary>"

#: syntax.xml:12(para)
msgid ""
"This chapter describes the syntax of SQL. It forms the foundation for "
"understanding the following chapters which will go into detail about how SQL "
"commands are applied to define and modify data."
msgstr ""
"В этой главе описывается синтаксис языка SQL. Тем самым закладывается "
"фундамент для следующих глав, где будет подробно рассмотрено, как с помощью "
"команд SQL описывать и изменять данные."

#: syntax.xml:18(para)
msgid ""
"We also advise users who are already familiar with SQL to read this chapter "
"carefully because it contains several rules and concepts that are "
"implemented inconsistently among SQL databases or that are specific to "
"<productname>PostgreSQL</productname>."
msgstr ""
"Мы советуем прочитать эту главу и тем, кто уже знаком SQL, так как в ней "
"описываются несколько правил и концепций, которые реализованы в разных базах "
"данных SQL по-разному или относятся только к <productname>PostgreSQL</"
"productname>."

#: syntax.xml:26(title)
msgid "Lexical Structure"
msgstr "Лексическая структура"

#: syntax.xml:28(indexterm)
msgid "<primary>token</primary>"
msgstr "<primary>компонент</primary>"

#: syntax.xml:32(para)
msgid ""
"SQL input consists of a sequence of <firstterm>commands</firstterm>. A "
"command is composed of a sequence of <firstterm>tokens</firstterm>, "
"terminated by a semicolon (<quote>;</quote>). The end of the input stream "
"also terminates a command. Which tokens are valid depends on the syntax of "
"the particular command."
msgstr ""
"SQL-программа состоит из последовательности <firstterm>команд</firstterm>. "
"Команда, в свою очередь, представляет собой последовательность "
"<firstterm>компонентов</firstterm>, оканчивающуюся точкой с запятой (<quote>;"
"</quote>). Конец входного потока также считается концом команды. Какие "
"именно компоненты допустимы для конкретной команды, зависит от её синтаксиса."

#: syntax.xml:41(para)
msgid ""
"A token can be a <firstterm>key word</firstterm>, an <firstterm>identifier</"
"firstterm>, a <firstterm>quoted identifier</firstterm>, a "
"<firstterm>literal</firstterm> (or constant), or a special character symbol. "
"Tokens are normally separated by whitespace (space, tab, newline), but need "
"not be if there is no ambiguity (which is generally only the case if a "
"special character is adjacent to some other token type)."
msgstr ""
"Компонентом команды может быть <firstterm>ключевое слово</firstterm>, "
"<firstterm>идентификатор</firstterm>, <firstterm>идентификатор в кавычках</"
"firstterm>, <firstterm>строка</firstterm> (или константа) или специальный "
"символ. Компоненты обычно разделяются пробельными символами (пробел, "
"табуляция, перевод строки), но это не требуется, если нет неоднозначности "
"(например, когда спецсимвол оказывается рядом с компонентом другого типа)."

#: syntax.xml:53(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM MY_TABLE;\n"
"UPDATE MY_TABLE SET A = 5;\n"
"INSERT INTO MY_TABLE VALUES (3, 'hi there');"
msgstr ""
"SELECT * FROM MY_TABLE;\n"
"UPDATE MY_TABLE SET A = 5;\n"
"INSERT INTO MY_TABLE VALUES (3, 'hi there');"

#: syntax.xml:51(para)
msgid ""
"For example, the following is (syntactically) valid SQL input: "
"<placeholder-1/> This is a sequence of three commands, one per line "
"(although this is not required; more than one command can be on a line, and "
"commands can usefully be split across lines)."
msgstr ""
"Например, следующий текст является правильной (синтаксически) SQL-"
"программой: <placeholder-1/> Это последовательность трёх команд, по одной в "
"строке (хотя их можно было разместить и в одну строку или наоборот, "
"разделить команды на несколько строк)."

#: syntax.xml:63(para)
msgid ""
"Additionally, <firstterm>comments</firstterm> can occur in SQL input. They "
"are not tokens, they are effectively equivalent to whitespace."
msgstr ""
"Кроме этого, SQL-программы могут содержать <firstterm>комментарии</"
"firstterm>. Они не являются компонентами команд, а по сути равносильны "
"пробельным символам."

#: syntax.xml:69(para)
msgid ""
"The SQL syntax is not very consistent regarding what tokens identify "
"commands and which are operands or parameters. The first few tokens are "
"generally the command name, so in the above example we would usually speak "
"of a <quote>SELECT</quote>, an <quote>UPDATE</quote>, and an <quote>INSERT</"
"quote> command. But for instance the <command>UPDATE</command> command "
"always requires a <token>SET</token> token to appear in a certain position, "
"and this particular variation of <command>INSERT</command> also requires a "
"<token>VALUES</token> in order to be complete. The precise syntax rules for "
"each command are described in <xref linkend=\"reference\"/>."
msgstr ""
"Синтаксис SQL не очень строго определяет, какие компоненты идентифицируют "
"команды, а какие &mdash; их операнды или параметры. Первые несколько "
"компонентов обычно содержат имя команды, так что в данном примере мы можем "
"говорить о командах <quote>SELECT</quote>, <quote>UPDATE</quote> и "
"<quote>INSERT</quote>. Но например, команда <command>UPDATE</command> "
"требует, чтобы также в определённом положении всегда стоял компонент "
"<token>SET</token>, а <command>INSERT</command> в приведённом виде требует "
"наличия компонента <token>VALUES</token>. Точные синтаксические правила для "
"каждой команды описаны в <xref remap=\"6\" linkend=\"reference\"/>."

#: syntax.xml:83(title)
msgid "Identifiers and Key Words"
msgstr "Идентификаторы и ключевые слова"

#: syntax.xml:85(indexterm)
msgid "<primary>identifier</primary> <secondary>syntax of</secondary>"
msgstr "<primary>идентификатор</primary> <secondary>синтаксис</secondary>"

#: syntax.xml:90(indexterm)
msgid "<primary>name</primary> <secondary>syntax of</secondary>"
msgstr "<primary>имя</primary> <secondary>синтаксис</secondary>"

#: syntax.xml:95(indexterm)
msgid "<primary>key word</primary> <secondary>syntax of</secondary>"
msgstr "<primary>ключевое слово</primary> <secondary>синтаксис</secondary>"

#: syntax.xml:100(para)
msgid ""
"Tokens such as <token>SELECT</token>, <token>UPDATE</token>, or "
"<token>VALUES</token> in the example above are examples of <firstterm>key "
"words</firstterm>, that is, words that have a fixed meaning in the SQL "
"language. The tokens <token>MY_TABLE</token> and <token>A</token> are "
"examples of <firstterm>identifiers</firstterm>. They identify names of "
"tables, columns, or other database objects, depending on the command they "
"are used in. Therefore they are sometimes simply called <quote>names</"
"quote>. Key words and identifiers have the same lexical structure, meaning "
"that one cannot know whether a token is an identifier or a key word without "
"knowing the language. A complete list of key words can be found in <xref "
"linkend=\"sql-keywords-appendix\"/>."
msgstr ""
"Показанные выше команды содержали компоненты <token>SELECT</token>, "
"<token>UPDATE</token> и <token>VALUES</token>, которые являются примерами "
"<firstterm>ключевых слов</firstterm>, то есть слов, имеющих фиксированное "
"значение в языке SQL. Компоненты <token>MY_TABLE</token> и <token>A</token> "
"являются примерами <firstterm>идентификаторов</firstterm>. Они "
"идентифицируют имена таблиц, столбцов или других объектов баз данных, в "
"зависимости от того, где они используются. Поэтому иногда их называют просто "
"<quote>именами</quote>. Ключевые слова и идентификаторы имеют одинаковую "
"лексическую структуру, то есть, не зная языка, нельзя определить, является "
"ли некоторый компонент ключевым словом или идентификатором. Полный список "
"ключевых слов приведён в <xref remap=\"6\" linkend=\"sql-keywords-appendix\"/"
">."

#: syntax.xml:116(para)
msgid ""
"SQL identifiers and key words must begin with a letter (<literal>a</literal>-"
"<literal>z</literal>, but also letters with diacritical marks and non-Latin "
"letters) or an underscore (<literal>_</literal>). Subsequent characters in "
"an identifier or key word can be letters, underscores, digits (<literal>0</"
"literal>-<literal>9</literal>), or dollar signs (<literal>$</literal>). Note "
"that dollar signs are not allowed in identifiers according to the letter of "
"the SQL standard, so their use might render applications less portable. The "
"SQL standard will not define a key word that contains digits or starts or "
"ends with an underscore, so identifiers of this form are safe against "
"possible conflict with future extensions of the standard."
msgstr ""
"Идентификаторы и ключевые слова SQL должны начинаться с буквы (<literal>a</"
"literal>-<literal>z</literal>, хотя допускаются также не латинские буквы и "
"буквы с диакритическими знаками) или подчёркивания (<literal>_</literal>). "
"Последующими символами в идентификаторе или ключевом слове могут быть буквы, "
"цифры (<literal>0</literal>-<literal>9</literal>), знаки доллара (<literal>"
"$</literal>) или подчёркивания. Заметьте, что строго следуя букве стандарта "
"SQL, знаки доллара нельзя использовать в идентификаторах, так что их "
"использование вредит переносимости приложений. В стандарте SQL "
"гарантированно не будет ключевых слов с цифрами и начинающихся или "
"заканчивающихся подчёркиванием, так что идентификаторы такого вида защищены "
"от возможных конфликтов с будущими расширениями стандарта."

#: syntax.xml:133(indexterm)
msgid "<primary>identifier</primary><secondary>length</secondary>"
msgstr "<primary>идентификатор</primary> <secondary>длина</secondary>"

#: syntax.xml:132(para)
msgid ""
"<placeholder-1/> The system uses no more than <symbol>NAMEDATALEN</symbol>-1 "
"bytes of an identifier; longer names can be written in commands, but they "
"will be truncated. By default, <symbol>NAMEDATALEN</symbol> is 64 so the "
"maximum identifier length is 63 bytes. If this limit is problematic, it can "
"be raised by changing the <symbol>NAMEDATALEN</symbol> constant in "
"<filename>src/include/pg_config_manual.h</filename>."
msgstr ""
"<placeholder-1/> Система выделяет для идентификатора не более "
"<symbol>NAMEDATALEN</symbol>-1 байт, а более длинные имена усекаются. По "
"умолчанию <symbol>NAMEDATALEN</symbol> равно 64, так что максимальная длина "
"идентификатора равна 63 байтам. Если этого недостаточно, этот предел можно "
"увеличить, изменив константу <symbol>NAMEDATALEN</symbol> в файле "
"<filename>src/include/pg_config_manual.h</filename>."

#: syntax.xml:144(indexterm)
msgid ""
"<primary>case sensitivity</primary> <secondary>of SQL commands</secondary>"
msgstr ""
"<primary>чувствительность к регистру</primary> <secondary>в командах SQL</"
"secondary>"

#: syntax.xml:149(programlisting)
#, no-wrap
msgid "UPDATE MY_TABLE SET A = 5;"
msgstr "UPDATE MY_TABLE SET A = 5;"

#: syntax.xml:153(programlisting)
#, no-wrap
msgid "uPDaTE my_TabLE SeT a = 5;"
msgstr "uPDaTE my_TabLE SeT a = 5;"

#: syntax.xml:158(programlisting)
#, no-wrap
msgid "UPDATE my_table SET a = 5;"
msgstr "UPDATE my_table SET a = 5;"

#: syntax.xml:143(para)
msgid ""
"<placeholder-1/> Key words and unquoted identifiers are case insensitive. "
"Therefore: <placeholder-2/> can equivalently be written as: <placeholder-3/> "
"A convention often used is to write key words in upper case and names in "
"lower case, e.g.: <placeholder-4/>"
msgstr ""
"<placeholder-1/> Ключевые слова и идентификаторы без кавычек воспринимаются "
"системой без учёта регистра. Таким образом: <placeholder-2/> равносильно "
"записи: <placeholder-3/> Часто используется неформальное соглашение "
"записывать ключевые слова заглавными буквами, а имена строчными, например: "
"<placeholder-4/>"

#: syntax.xml:164(indexterm)
msgid ""
"<primary>quotation marks</primary> <secondary>and identifiers</secondary>"
msgstr "<primary>кавычки</primary> <secondary>и идентификаторы</secondary>"

#: syntax.xml:180(programlisting)
#, no-wrap
msgid "UPDATE \"my_table\" SET \"a\" = 5;"
msgstr "UPDATE \"my_table\" SET \"a\" = 5;"

#: syntax.xml:163(para)
msgid ""
"<placeholder-1/> There is a second kind of identifier: the "
"<firstterm>delimited identifier</firstterm> or <firstterm>quoted identifier</"
"firstterm>. It is formed by enclosing an arbitrary sequence of characters in "
"double-quotes (<literal>\"</literal>). A delimited identifier is always an "
"identifier, never a key word. So <literal>\"select\"</literal> could be used "
"to refer to a column or table named <quote>select</quote>, whereas an "
"unquoted <literal>select</literal> would be taken as a key word and would "
"therefore provoke a parse error when used where a table or column name is "
"expected. The example can be written with quoted identifiers like this: "
"<placeholder-2/>"
msgstr ""
"<placeholder-1/> Есть и другой тип идентификаторов: <firstterm>отделённые "
"идентификаторы</firstterm> или <firstterm>идентификаторы в кавычках</"
"firstterm>. Они образуются при заключении обычного набора символов в двойные "
"кавычки (<literal>\"</literal>). Такие идентификаторы всегда будут считаться "
"идентификаторами, но не ключевыми словами. Так <literal>\"select\"</literal> "
"можно использовать для обозначения столбца или таблицы <quote>select</"
"quote>, тогда как <literal>select</literal> без кавычек будет воспринят как "
"ключевое слово и приведёт к ошибке разбора команды в месте, где ожидается "
"имя таблицы или столбца. Тот же пример можно переписать с идентификаторами в "
"кавычках следующим образом: <placeholder-2/>"

#: syntax.xml:185(para)
msgid ""
"Quoted identifiers can contain any character, except the character with code "
"zero. (To include a double quote, write two double quotes.) This allows "
"constructing table or column names that would otherwise not be possible, "
"such as ones containing spaces or ampersands. The length limitation still "
"applies."
msgstr ""
"Идентификаторы в кавычках могут содержать любые символы, за исключением "
"символа с кодом 0. (Чтобы включить в такой идентификатор кавычки, "
"продублируйте их.) Это позволяет создавать таблицы и столбцы с именами, "
"которые иначе были бы невозможны, например, с пробелами или амперсандами. "
"Ограничение длины при этом сохраняется."

#: syntax.xml:193(indexterm)
msgid "<primary>Unicode escape</primary> <secondary>in identifiers</secondary>"
msgstr ""
"<primary>Символы Unicode</primary> <secondary>в идентификаторах</secondary>"

#: syntax.xml:213(programlisting)
#, no-wrap
msgid "U&amp;\"d\\0061t\\+000061\""
msgstr "U&amp;\"d\\0061t\\+000061\""

#: syntax.xml:218(programlisting)
#, no-wrap
msgid "U&amp;\"\\0441\\043B\\043E\\043D\""
msgstr "U&amp;\"\\0441\\043B\\043E\\043D\""

#: syntax.xml:198(para)
msgid ""
"A variant of quoted identifiers allows including escaped Unicode characters "
"identified by their code points. This variant starts with <literal>U&amp;</"
"literal> (upper or lower case U followed by ampersand) immediately before "
"the opening double quote, without any spaces in between, for example "
"<literal>U&amp;\"foo\"</literal>. (Note that this creates an ambiguity with "
"the operator <literal>&amp;</literal>. Use spaces around the operator to "
"avoid this problem.) Inside the quotes, Unicode characters can be specified "
"in escaped form by writing a backslash followed by the four-digit "
"hexadecimal code point number or alternatively a backslash followed by a "
"plus sign followed by a six-digit hexadecimal code point number. For "
"example, the identifier <literal>\"data\"</literal> could be written as "
"<placeholder-1/> The following less trivial example writes the Russian word "
"<quote>slon</quote> (elephant) in Cyrillic letters: <placeholder-2/>"
msgstr ""
"Ещё один вариант идентификаторов в кавычках позволяет использовать символы "
"Unicode по их кодам. Такой идентификатор начинается с <literal>U&amp;</"
"literal> (строчная или заглавная U и амперсанд), а затем сразу без пробелов "
"идёт двойная кавычка, например <literal>U&amp;\"foo\"</literal>. (Заметьте, "
"что при этом возникает неоднозначность с оператором <literal>&amp;</"
"literal>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в "
"кавычках можно записывать символы Unicode двумя способами: обратная косая "
"черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная "
"косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. "
"Например, идентификатор <literal>\"data\"</literal> можно записать так: "
"<placeholder-1/> В следующем менее тривиальном примере закодировано русское "
"слово <quote>слон</quote>, записанное кириллицей: <placeholder-2/>"

#: syntax.xml:226(indexterm) syntax.xml:517(indexterm)
msgid "<primary>UESCAPE</primary>"
msgstr "<primary>UESCAPE</primary>"

#: syntax.xml:228(programlisting)
#, no-wrap
msgid "U&amp;\"d!0061t!+000061\" UESCAPE '!'"
msgstr "U&amp;\"d!0061t!+000061\" UESCAPE '!'"

#: syntax.xml:223(para)
msgid ""
"If a different escape character than backslash is desired, it can be "
"specified using the <literal>UESCAPE</literal><placeholder-1/> clause after "
"the string, for example: <placeholder-2/> The escape character can be any "
"single character other than a hexadecimal digit, the plus sign, a single "
"quote, a double quote, or a whitespace character. Note that the escape "
"character is written in single quotes, not double quotes."
msgstr ""
"Если вы хотите использовать не обратную косую черту, а другой спецсимвол, "
"его можно указать, добавив <literal>UESCAPE</literal> <placeholder-1/> после "
"строки, например: <placeholder-2/> В качестве спецсимвола можно выбрать "
"любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки "
"или пробельного символа. Заметьте, что спецсимвол заключается не в двойные "
"кавычки, а в апострофы."

#: syntax.xml:237(para)
msgid ""
"To include the escape character in the identifier literally, write it twice."
msgstr "Чтобы сделать спецсимволом знак апострофа, напишите его дважды."

#: syntax.xml:242(para)
msgid ""
"The Unicode escape syntax works only when the server encoding is "
"<literal>UTF8</literal>. When other server encodings are used, only code "
"points in the ASCII range (up to <literal>\\007F</literal>) can be "
"specified. Both the 4-digit and the 6-digit form can be used to specify "
"UTF-16 surrogate pairs to compose characters with code points larger than U"
"+FFFF, although the availability of the 6-digit form technically makes this "
"unnecessary. (Surrogate pairs are not stored directly, but combined into a "
"single code point that is then encoded in UTF-8.)"
msgstr ""
"Unicode-формат полностью поддерживается только при использовании на сервере "
"кодировки <literal>UTF8</literal>. Когда используются другие кодировки, "
"допускается указание только ASCII-символов (с кодами до <literal>\\007F</"
"literal>). И в четырёх, и в шестизначной форме можно записывать суррогатные "
"пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF, "
"хотя наличие шестизначной формы технически делает это ненужным. (Суррогатные "
"пары не сохраняются непосредственно, а объединяются в один символ, который "
"затем кодируется в UTF-8.)"

#: syntax.xml:254(para)
msgid ""
"Quoting an identifier also makes it case-sensitive, whereas unquoted names "
"are always folded to lower case. For example, the identifiers <literal>FOO</"
"literal>, <literal>foo</literal>, and <literal>\"foo\"</literal> are "
"considered the same by <productname>PostgreSQL</productname>, but <literal>"
"\"Foo\"</literal> and <literal>\"FOO\"</literal> are different from these "
"three and each other. (The folding of unquoted names to lower case in "
"<productname>PostgreSQL</productname> is incompatible with the SQL standard, "
"which says that unquoted names should be folded to upper case. Thus, "
"<literal>foo</literal> should be equivalent to <literal>\"FOO\"</literal> "
"not <literal>\"foo\"</literal> according to the standard. If you want to "
"write portable applications you are advised to always quote a particular "
"name or never quote it.)"
msgstr ""
"Идентификатор, заключённый в кавычки, становится зависимым от регистра, "
"тогда как идентификаторы без кавычек всегда переводятся в нижний регистр. "
"Например, идентификаторы <literal>FOO</literal>, <literal>foo</literal> и "
"<literal>\"foo\"</literal> считаются одинаковыми в <productname>PostgreSQL</"
"productname>, но <literal>\"Foo\"</literal> и <literal>\"FOO\"</literal> "
"отличны друг от друга и от предыдущих трёх. (Приведение имён без кавычек к "
"нижнему регистру, как это делает <productname>PostgreSQL</productname>, "
"несовместимо со стандартом SQL, который говорит о том, что имена должны "
"приводиться к верхнему регистру. То есть, согласно стандарту <literal>foo</"
"literal> должно быть эквивалентно <literal>\"FOO\"</literal>, а не <literal>"
"\"foo\"</literal>. Поэтому при создании переносимых приложений рекомендуется "
"либо всегда заключать определённое имя в кавычки, либо не заключать никогда.)"

#: syntax.xml:274(title)
msgid "Constants"
msgstr "Константы"

#: syntax.xml:276(indexterm)
msgid "<primary>constant</primary>"
msgstr "<primary>константа</primary>"

#: syntax.xml:280(para)
msgid ""
"There are three kinds of <firstterm>implicitly-typed constants</firstterm> "
"in <productname>PostgreSQL</productname>: strings, bit strings, and numbers. "
"Constants can also be specified with explicit types, which can enable more "
"accurate representation and more efficient handling by the system. These "
"alternatives are discussed in the following subsections."
msgstr ""
"В <productname>PostgreSQL</productname> есть три типа констант "
"<firstterm>подразумеваемых типов</firstterm>: строки, битовые строки и "
"числа. Константы можно также записывать, указывая типы явно, что позволяет "
"представить их более точно и обработать более эффективно. Эти варианты "
"рассматриваются в следующих подразделах."

#: syntax.xml:291(title)
msgid "String Constants"
msgstr "Строковые константы"

#: syntax.xml:293(indexterm)
msgid "<primary>character string</primary> <secondary>constant</secondary>"
msgstr "<primary>текстовая строка</primary> <secondary>константа</secondary>"

#: syntax.xml:299(indexterm)
msgid "<primary>quotation marks</primary> <secondary>escaping</secondary>"
msgstr "<primary>кавычки</primary> <secondary>спецсимволы</secondary>"

#: syntax.xml:298(para)
msgid ""
"<placeholder-1/> A string constant in SQL is an arbitrary sequence of "
"characters bounded by single quotes (<literal>'</literal>), for example "
"<literal>'This is a string'</literal>. To include a single-quote character "
"within a string constant, write two adjacent single quotes, e.g., "
"<literal>'Dianne''s horse'</literal>. Note that this is <emphasis>not</"
"emphasis> the same as a double-quote character (<literal>\"</literal>)."
msgstr ""
"<placeholder-1/> Строковая константа в SQL &mdash; это обычная "
"последовательность символов, заключённая в апострофы (<literal>'</literal>), "
"например: <literal>'Это строка'</literal>. Чтобы включить апостроф в строку, "
"напишите в ней два апострофа рядом, например: <literal>'Жанна д''Арк'</"
"literal>. Заметьте, это <emphasis>не</emphasis> то же самое, что двойная "
"кавычка (<literal>\"</literal>)."

#: syntax.xml:318(programlisting)
#, no-wrap
msgid ""
"SELECT 'foo'\n"
"'bar';"
msgstr ""
"SELECT 'foo'\n"
"'bar';"

#: syntax.xml:323(programlisting)
#, no-wrap
msgid "SELECT 'foobar';"
msgstr "SELECT 'foobar';"

#: syntax.xml:327(programlisting)
#, no-wrap
msgid "SELECT 'foo'      'bar';"
msgstr "SELECT 'foo'      'bar';"

#: syntax.xml:313(para)
msgid ""
"Two string constants that are only separated by whitespace <emphasis>with at "
"least one newline</emphasis> are concatenated and effectively treated as if "
"the string had been written as one constant. For example: <placeholder-1/> "
"is equivalent to: <placeholder-2/> but: <placeholder-3/> is not valid "
"syntax. (This slightly bizarre behavior is specified by <acronym>SQL</"
"acronym>; <productname>PostgreSQL</productname> is following the standard.)"
msgstr ""
"Две строковые константы, разделённые пробельными символами <emphasis>и "
"минимум одним переводом строки</emphasis>, объединяются в одну и "
"обрабатываются, как если бы строка была записана в одной константе. "
"Например: <placeholder-1/> эквивалентно: <placeholder-2/> но эта запись: "
"<placeholder-3/> считается синтаксической ошибкой. (Это несколько странное "
"поведение определено в стандарте <acronym>SQL</acronym>, "
"<productname>PostgreSQL</productname> просто следует ему.)"

#: syntax.xml:337(title)
msgid "String Constants with C-style Escapes"
msgstr "Строковые константы со спецпоследовательностями в стиле C"

#: syntax.xml:339(indexterm)
msgid "<primary>escape string syntax</primary>"
msgstr "<primary>синтаксис спецпоследовательностей</primary>"

#: syntax.xml:342(indexterm)
msgid "<primary>backslash escapes</primary>"
msgstr "<primary>спецсимвол обратная косая черта</primary>"

#: syntax.xml:346(para)
msgid ""
"<productname>PostgreSQL</productname> also accepts <quote>escape</quote> "
"string constants, which are an extension to the SQL standard. An escape "
"string constant is specified by writing the letter <literal>E</literal> "
"(upper or lower case) just before the opening single quote, e.g., "
"<literal>E'foo'</literal>. (When continuing an escape string constant across "
"lines, write <literal>E</literal> only before the first opening quote.) "
"Within an escape string, a backslash character (<literal>\\</literal>) "
"begins a C-like <firstterm>backslash escape</firstterm> sequence, in which "
"the combination of backslash and following character(s) represent a special "
"byte value, as shown in <xref linkend=\"sql-backslash-table\"/>."
msgstr ""
"<productname>PostgreSQL</productname> также принимает "
"<quote>спецпоследовательности</quote>, что является расширением стандарта "
"SQL. Строка со спецпоследовательностями начинается с буквы <literal>E</"
"literal> (заглавной или строчной), стоящей непосредственно перед апострофом, "
"например: <literal>E'foo'</literal>. (Когда константа со "
"спецпоследовательностью разбивается на несколько строк, букву <literal>E</"
"literal> нужно поставить только перед первым открывающим апострофом.) Внутри "
"таких строк символ обратной косой черты (<literal>\\</literal>) начинает C-"
"подобные <firstterm>спецпоследовательности</firstterm>, в которых сочетание "
"обратной косой черты со следующим символом(ами) даёт определённое байтовое "
"значение, как показано в <xref remap=\"6\" linkend=\"sql-backslash-table\"/>."

#: syntax.xml:361(title)
msgid "Backslash Escape Sequences"
msgstr "Спецпоследовательности"

#: syntax.xml:365(entry)
msgid "Backslash Escape Sequence"
msgstr "Спецпоследовательность"

#: syntax.xml:366(entry)
msgid "Interpretation"
msgstr "Интерпретация"

#: syntax.xml:372(literal)
msgid "\\b"
msgstr "\\b"

#: syntax.xml:373(entry)
msgid "backspace"
msgstr "символ &laquo;забой&raquo;"

#: syntax.xml:376(literal)
msgid "\\f"
msgstr "\\f"

#: syntax.xml:377(entry)
msgid "form feed"
msgstr "подача формы"

#: syntax.xml:380(literal)
msgid "\\n"
msgstr "\\n"

#: syntax.xml:381(entry)
msgid "newline"
msgstr "новая строка"

#: syntax.xml:384(literal)
msgid "\\r"
msgstr "\\r"

#: syntax.xml:385(entry)
msgid "carriage return"
msgstr "возврат каретки"

#: syntax.xml:388(literal)
msgid "\\t"
msgstr "\\t"

#: syntax.xml:389(entry)
msgid "tab"
msgstr "табуляция"

#: syntax.xml:392(entry)
msgid ""
"<literal>\\<replaceable>o</replaceable></literal>, <literal>"
"\\<replaceable>oo</replaceable></literal>, <literal>\\<replaceable>ooo</"
"replaceable></literal> (<replaceable>o</replaceable> = 0 - 7)"
msgstr ""
"<literal>\\<replaceable>o</replaceable></literal>, <literal>"
"\\<replaceable>oo</replaceable></literal>, <literal>\\<replaceable>ooo</"
"replaceable></literal> (<replaceable>o</replaceable> = 0 - 7)"

#: syntax.xml:398(entry)
msgid "octal byte value"
msgstr "восьмеричное значение байта"

#: syntax.xml:401(entry)
msgid ""
"<literal>\\x<replaceable>h</replaceable></literal>, <literal>"
"\\x<replaceable>hh</replaceable></literal> (<replaceable>h</replaceable> = 0 "
"- 9, A - F)"
msgstr ""
"<literal>\\x<replaceable>h</replaceable></literal>, <literal>"
"\\x<replaceable>hh</replaceable></literal> (<replaceable>h</replaceable> = 0 "
"— 9, A — F)"

#: syntax.xml:406(entry)
msgid "hexadecimal byte value"
msgstr "шестнадцатеричное значение байта"

#: syntax.xml:409(entry)
msgid ""
"<literal>\\u<replaceable>xxxx</replaceable></literal>, <literal>"
"\\U<replaceable>xxxxxxxx</replaceable></literal> (<replaceable>x</"
"replaceable> = 0 - 9, A - F)"
msgstr ""
"<literal>\\u<replaceable>xxxx</replaceable></literal>, <literal>"
"\\U<replaceable>xxxxxxxx</replaceable></literal> (<replaceable>x</"
"replaceable> = 0 — 9, A — F)"

#: syntax.xml:414(entry)
msgid "16 or 32-bit hexadecimal Unicode character value"
msgstr "16- или 32-битный шестнадцатеричный код символа Unicode"

#: syntax.xml:420(para)
msgid ""
"Any other character following a backslash is taken literally. Thus, to "
"include a backslash character, write two backslashes (<literal>\\\\</"
"literal>). Also, a single quote can be included in an escape string by "
"writing <literal>\\'</literal>, in addition to the normal way of "
"<literal>''</literal>."
msgstr ""
"Любой другой символ, идущий после обратной косой черты, воспринимается "
"буквально. Таким образом, чтобы включить в строку обратную косую черту, "
"нужно написать две косых черты (<literal>\\\\</literal>). Так же можно "
"включить в строку апостроф, написав <literal>\\'</literal>, в дополнение к "
"обычному способу <literal>''</literal>."

#: syntax.xml:428(para)
msgid ""
"It is your responsibility that the byte sequences you create, especially "
"when using the octal or hexadecimal escapes, compose valid characters in the "
"server character set encoding. When the server encoding is UTF-8, then the "
"Unicode escapes or the alternative Unicode escape syntax, explained in <xref "
"linkend=\"sql-syntax-strings-uescape\"/>, should be used instead. (The "
"alternative would be doing the UTF-8 encoding by hand and writing out the "
"bytes, which would be very cumbersome.)"
msgstr ""
"Вы должны позаботиться, чтобы байтовые последовательности, которые вы "
"создаёте таким образом, особенно в восьмеричной и шестнадцатеричной записи, "
"образовывали допустимые символы в серверной кодировке. Когда сервер работает "
"с кодировкой UTF-8, вместо такой записи байт следует использовать "
"спецпоследовательности Unicode или альтернативный синтаксис Unicode, "
"описанный в <xref remap=\"6\" linkend=\"sql-syntax-strings-uescape\"/>. (В "
"противном случае придётся кодировать символы UTF-8 вручную и выписывать их "
"по байтам, что очень неудобно.)"

#: syntax.xml:439(para)
msgid ""
"The Unicode escape syntax works fully only when the server encoding is "
"<literal>UTF8</literal>. When other server encodings are used, only code "
"points in the ASCII range (up to <literal>\\u007F</literal>) can be "
"specified. Both the 4-digit and the 8-digit form can be used to specify "
"UTF-16 surrogate pairs to compose characters with code points larger than U"
"+FFFF, although the availability of the 8-digit form technically makes this "
"unnecessary. (When surrogate pairs are used when the server encoding is "
"<literal>UTF8</literal>, they are first combined into a single code point "
"that is then encoded in UTF-8.)"
msgstr ""
"Спецпоследовательности с Unicode полностью поддерживаются только при "
"использовании на сервере кодировки <literal>UTF8</literal>. Когда "
"используются другие кодировки, допускается указание только ASCII-символов (с "
"кодами до <literal>\\u007F</literal>). И в четырёх, и в восьмизначной форме "
"можно записывать суррогатные пары UTF-16 и таким образом составлять символы "
"с кодами больше чем U+FFFF, хотя наличие восьмизначной формы технически "
"делает это ненужным. (Когда суррогатные пары используются с серверной "
"кодировкой <literal>UTF8</literal>, они сначала объединяются в один символ, "
"который затем кодируется в UTF-8.)"

#: syntax.xml:453(para)
msgid ""
"If the configuration parameter <xref linkend=\"guc-standard-conforming-"
"strings\"/> is <literal>off</literal>, then <productname>PostgreSQL</"
"productname> recognizes backslash escapes in both regular and escape string "
"constants. However, as of <productname>PostgreSQL</productname> 9.1, the "
"default is <literal>on</literal>, meaning that backslash escapes are "
"recognized only in escape string constants. This behavior is more standards-"
"compliant, but might break applications which rely on the historical "
"behavior, where backslash escapes were always recognized. As a workaround, "
"you can set this parameter to <literal>off</literal>, but it is better to "
"migrate away from using backslash escapes. If you need to use a backslash "
"escape to represent a special character, write the string constant with an "
"<literal>E</literal>."
msgstr ""
"Если параметр конфигурации <xref linkend=\"guc-standard-conforming-strings\"/"
"> имеет значение <literal>off</literal>, <productname>PostgreSQL</"
"productname> распознаёт обратную косую черту как спецсимвол и в обычных "
"строках, и в строках со спецпоследовательностями. Однако в версии "
"<productname>PostgreSQL</productname> 9.1 по умолчанию принято значение "
"<literal>on</literal>, и в этом случае обратная косая черта распознаётся "
"только в спецстроках. Это поведение больше соответствует стандарту, хотя "
"может нарушить работу приложений, рассчитанных на предыдущий режим, когда "
"обратная косая черта распознавалась везде. В качестве временного решения вы "
"можете изменить этот параметр на <literal>off</literal>, но лучше уйти от "
"такой практики. Если вам нужно, чтобы обратная косая черта представляла "
"специальный символ, задайте строковую константу с <literal>E</literal>."

#: syntax.xml:468(para)
msgid ""
"In addition to <varname>standard_conforming_strings</varname>, the "
"configuration parameters <xref linkend=\"guc-escape-string-warning\"/> and "
"<xref linkend=\"guc-backslash-quote\"/> govern treatment of backslashes in "
"string constants."
msgstr ""
"В дополнение к <varname>standard_conforming_strings</varname> поведением "
"обратной косой черты в строковых константах управляют параметры <xref "
"linkend=\"guc-escape-string-warning\"/> и <xref linkend=\"guc-backslash-quote"
"\"/>."

#: syntax.xml:476(para)
msgid "The character with the code zero cannot be in a string constant."
msgstr "Строковая константа не может включать символ с кодом 0."

#: syntax.xml:482(title)
msgid "String Constants with Unicode Escapes"
msgstr "Строковые константы со спецпоследовательностями Unicode"

#: syntax.xml:484(indexterm)
msgid ""
"<primary>Unicode escape</primary> <secondary>in string constants</secondary>"
msgstr ""
"<primary>Спецкоды Unicode</primary> <secondary>в строковых константах</"
"secondary>"

#: syntax.xml:504(programlisting)
#, no-wrap
msgid "U&amp;'d\\0061t\\+000061'"
msgstr "U&amp;'d\\0061t\\+000061'"

#: syntax.xml:509(programlisting)
#, no-wrap
msgid "U&amp;'\\0441\\043B\\043E\\043D'"
msgstr "U&amp;'\\0441\\043B\\043E\\043D'"

#: syntax.xml:489(para)
msgid ""
"<productname>PostgreSQL</productname> also supports another type of escape "
"syntax for strings that allows specifying arbitrary Unicode characters by "
"code point. A Unicode escape string constant starts with <literal>U&amp;</"
"literal> (upper or lower case letter U followed by ampersand) immediately "
"before the opening quote, without any spaces in between, for example "
"<literal>U&amp;'foo'</literal>. (Note that this creates an ambiguity with "
"the operator <literal>&amp;</literal>. Use spaces around the operator to "
"avoid this problem.) Inside the quotes, Unicode characters can be specified "
"in escaped form by writing a backslash followed by the four-digit "
"hexadecimal code point number or alternatively a backslash followed by a "
"plus sign followed by a six-digit hexadecimal code point number. For "
"example, the string <literal>'data'</literal> could be written as "
"<placeholder-1/> The following less trivial example writes the Russian word "
"<quote>slon</quote> (elephant) in Cyrillic letters: <placeholder-2/>"
msgstr ""
"<productname>PostgreSQL</productname> также поддерживает ещё один вариант "
"спецпоследовательностей, позволяющий включать в строки символы Unicode по их "
"кодам. Строковая константа со спецпоследовательностями Unicode начинается с "
"<literal>U&amp;</literal> (строчная или заглавная U и амперсанд), а затем "
"сразу без пробелов идёт апостроф, например <literal>U&amp;'foo'</literal>. "
"(Заметьте, что при этом возникает неоднозначность с оператором <literal>&amp;"
"</literal>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в "
"апострофах можно записывать символы Unicode двумя способами: обратная косая "
"черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная "
"косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. "
"Например, строку <literal>'data'</literal> можно записать так:<placeholder-1/"
"> В следующем менее тривиальном примере закодировано русское слово "
"<quote>слон</quote>, записанное кириллицей: <placeholder-2/>"

#: syntax.xml:519(programlisting)
#, no-wrap
msgid "U&amp;'d!0061t!+000061' UESCAPE '!'"
msgstr "U&amp;'d!0061t!+000061' UESCAPE '!'"

#: syntax.xml:514(para)
msgid ""
"If a different escape character than backslash is desired, it can be "
"specified using the <literal>UESCAPE</literal><placeholder-1/> clause after "
"the string, for example: <placeholder-2/> The escape character can be any "
"single character other than a hexadecimal digit, the plus sign, a single "
"quote, a double quote, or a whitespace character."
msgstr ""
"Если вы хотите использовать не обратную косую черту, а другой спецсимвол, "
"его можно указать, добавив <literal>UESCAPE</literal><placeholder-1/> после "
"строки, например: <placeholder-2/> В качестве спецсимвола можно выбрать "
"любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки "
"или пробельного символа."

#: syntax.xml:527(para)
msgid ""
"The Unicode escape syntax works only when the server encoding is "
"<literal>UTF8</literal>. When other server encodings are used, only code "
"points in the ASCII range (up to <literal>\\007F</literal>) can be "
"specified. Both the 4-digit and the 6-digit form can be used to specify "
"UTF-16 surrogate pairs to compose characters with code points larger than U"
"+FFFF, although the availability of the 6-digit form technically makes this "
"unnecessary. (When surrogate pairs are used when the server encoding is "
"<literal>UTF8</literal>, they are first combined into a single code point "
"that is then encoded in UTF-8.)"
msgstr ""
"Спецпоследовательности с Unicode поддерживаются только при использовании на "
"сервере кодировки <literal>UTF8</literal>. Когда используются другие "
"кодировки, допускается указание только ASCII-символов (с кодами до <literal>"
"\\007F</literal>). И в четырёх, и в шестизначной форме можно записывать "
"суррогатные пары UTF-16 и таким образом составлять символы с кодами больше "
"чем U+FFFF, хотя наличие шестизначной формы технически делает это ненужным. "
"(Когда суррогатные пары используются с серверной кодировкой <literal>UTF8</"
"literal>, они сначала объединяются в один символ, который затем кодируется в "
"UTF-8.)"

#: syntax.xml:540(para)
msgid ""
"Also, the Unicode escape syntax for string constants only works when the "
"configuration parameter <xref linkend=\"guc-standard-conforming-strings\"/> "
"is turned on. This is because otherwise this syntax could confuse clients "
"that parse the SQL statements to the point that it could lead to SQL "
"injections and similar security issues. If the parameter is set to off, this "
"syntax will be rejected with an error message."
msgstr ""
"Также заметьте, что спецпоследовательности Unicode в строковых константах "
"работают, только когда параметр конфигурации <xref linkend=\"guc-standard-"
"conforming-strings\"/> равен <literal>on</literal>. Это объясняется тем, что "
"иначе клиентские программы, проверяющие SQL-операторы, можно будет ввести в "
"заблуждение и эксплуатировать это как уязвимость, например, для SQL-"
"инъекций. Если этот параметр имеет значение <literal>off</literal>, эти "
"спецпоследовательности будут вызывать ошибку."

#: syntax.xml:551(para)
msgid ""
"To include the escape character in the string literally, write it twice."
msgstr "Чтобы включить спецсимвол в строку буквально, напишите его дважды."

#: syntax.xml:558(title)
msgid "Dollar-quoted String Constants"
msgstr "Строковые константы, заключённые в доллары"

#: syntax.xml:560(indexterm)
msgid "<primary>dollar quoting</primary>"
msgstr "<primary>заключение строк в доллары</primary>"

#: syntax.xml:579(programlisting)
#, no-wrap
msgid ""
"$$Dianne's horse$$\n"
"$SomeTag$Dianne's horse$SomeTag$"
msgstr ""
"$$Жанна д'Арк$$\n"
"$SomeTag$Жанна д'Арк$SomeTag$"

#: syntax.xml:564(para)
msgid ""
"While the standard syntax for specifying string constants is usually "
"convenient, it can be difficult to understand when the desired string "
"contains many single quotes or backslashes, since each of those must be "
"doubled. To allow more readable queries in such situations, "
"<productname>PostgreSQL</productname> provides another way, called "
"<quote>dollar quoting</quote>, to write string constants. A dollar-quoted "
"string constant consists of a dollar sign (<literal>$</literal>), an "
"optional <quote>tag</quote> of zero or more characters, another dollar sign, "
"an arbitrary sequence of characters that makes up the string content, a "
"dollar sign, the same tag that began this dollar quote, and a dollar sign. "
"For example, here are two different ways to specify the string "
"<quote>Dianne's horse</quote> using dollar quoting: <placeholder-1/> Notice "
"that inside the dollar-quoted string, single quotes can be used without "
"needing to be escaped. Indeed, no characters inside a dollar-quoted string "
"are ever escaped: the string content is always written literally. "
"Backslashes are not special, and neither are dollar signs, unless they are "
"part of a sequence matching the opening tag."
msgstr ""
"Хотя стандартный синтаксис для строковых констант обычно достаточно удобен, "
"он может плохо читаться, когда строка содержит много апострофов или обратных "
"косых черт, так как каждый такой символ приходится дублировать. Чтобы и в "
"таких случаях запросы оставались читаемыми, <productname>PostgreSQL</"
"productname> предлагает ещё один способ записи строковых констант &mdash; "
"<quote>заключение строк в доллары</quote>. Строковая константа, заключённая "
"в доллары, начинается со знака доллара (<literal>$</literal>), "
"необязательного <quote>тега</quote> из нескольких символов и ещё одного "
"знака доллара, затем содержит обычную последовательность символов, "
"составляющую строку, и оканчивается знаком доллара, тем же тегом и "
"замыкающим знаком доллара. Например, строку <quote>Жанна д'Арк</quote> можно "
"записать в долларах двумя способами: <placeholder-1/> Заметьте, что внутри "
"такой строки апострофы не нужно записывать особым образом. На самом деле, в "
"строке, заключённой в доллары, все символы можно записывать в чистом виде: "
"содержимое строки всегда записывается буквально. Ни обратная косая черта, ни "
"даже знак доллара не являются спецсимволами, если только они не образуют "
"последовательность, соответствующую открывающему тегу."

#: syntax.xml:595(programlisting)
#, no-wrap
msgid ""
"$function$\n"
"BEGIN\n"
"    RETURN ($1 ~ $q$[\\t\\r\\n\\v\\\\]$q$);\n"
"END;\n"
"$function$"
msgstr ""
"$function$\n"
"BEGIN\n"
"    RETURN ($1 ~ $q$[\\t\\r\\n\\v\\\\]$q$);\n"
"END;\n"
"$function$"

#: syntax.xml:591(para)
msgid ""
"It is possible to nest dollar-quoted string constants by choosing different "
"tags at each nesting level. This is most commonly used in writing function "
"definitions. For example: <placeholder-1/> Here, the sequence <literal>$q"
"$[\\t\\r\\n\\v\\\\]$q$</literal> represents a dollar-quoted literal string "
"<literal>[\\t\\r\\n\\v\\\\]</literal>, which will be recognized when the "
"function body is executed by <productname>PostgreSQL</productname>. But "
"since the sequence does not match the outer dollar quoting delimiter "
"<literal>$function$</literal>, it is just some more characters within the "
"constant so far as the outer string is concerned."
msgstr ""
"Строковые константы в долларах можно вкладывать друг в друга, выбирая на "
"разных уровнях вложенности разные теги. Чаще всего это используется при "
"написании определений функций. Например: <placeholder-1/> Здесь "
"последовательность <literal>$q$[\\t\\r\\n\\v\\\\]$q$</literal> представляет "
"в долларах текстовую строку <literal>[\\t\\r\\n\\v\\\\]</literal>, которая "
"будет обработана, когда <productname>PostgreSQL</productname> будет "
"выполнять эту функцию. Но так как эта последовательность не соответствует "
"внешнему тегу в долларах (<literal>$function$</literal>), с точки зрения "
"внешней строки это просто обычные символы внутри константы."

#: syntax.xml:611(para)
msgid ""
"The tag, if any, of a dollar-quoted string follows the same rules as an "
"unquoted identifier, except that it cannot contain a dollar sign. Tags are "
"case sensitive, so <literal>$tag$String content$tag$</literal> is correct, "
"but <literal>$TAG$String content$tag$</literal> is not."
msgstr ""
"Тег строки в долларах, если он присутствует, должен соответствовать "
"правилам, определённым для идентификаторов без кавычек, и к тому же не "
"должен содержать знак доллара. Теги регистрозависимы, так что <literal>$tag"
"$String content$tag$</literal> &mdash; правильная строка, а <literal>$TAG"
"$String content$tag$</literal> &mdash; нет."

#: syntax.xml:618(para)
msgid ""
"A dollar-quoted string that follows a keyword or identifier must be "
"separated from it by whitespace; otherwise the dollar quoting delimiter "
"would be taken as part of the preceding identifier."
msgstr ""
"Строка в долларах, следующая за ключевым словом или идентификатором, должна "
"отделяться от него пробельными символами, иначе доллар будет считаться "
"продолжением предыдущего идентификатора."

#: syntax.xml:624(para)
msgid ""
"Dollar quoting is not part of the SQL standard, but it is often a more "
"convenient way to write complicated string literals than the standard-"
"compliant single quote syntax. It is particularly useful when representing "
"string constants inside other constants, as is often needed in procedural "
"function definitions. With single-quote syntax, each backslash in the above "
"example would have to be written as four backslashes, which would be reduced "
"to two backslashes in parsing the original string constant, and then to one "
"when the inner string constant is re-parsed during function execution."
msgstr ""
"Заключение строк в доллары не является частью стандарта SQL, но часто это "
"более удобный способ записывать сложные строки, чем стандартный вариант с "
"апострофами. Он особенно полезен, когда нужно представить строковую "
"константу внутри другой строки, что часто требуется в определениях "
"процедурных функций. Ограничившись только апострофами, каждую обратную косую "
"черту в приведённом примере пришлось бы записывать четырьмя такими "
"символами, которые бы затем уменьшились до двух при разборе внешней строки, "
"и наконец до одного при обработке внутренней строки во время выполнения "
"функции."

#: syntax.xml:638(title)
msgid "Bit-string Constants"
msgstr "Битовые строковые константы"

#: syntax.xml:640(indexterm)
msgid "<primary>bit string</primary> <secondary>constant</secondary>"
msgstr "<primary>битовая строковая</primary> <secondary>константа</secondary>"

#: syntax.xml:645(para)
msgid ""
"Bit-string constants look like regular string constants with a <literal>B</"
"literal> (upper or lower case) immediately before the opening quote (no "
"intervening whitespace), e.g., <literal>B'1001'</literal>. The only "
"characters allowed within bit-string constants are <literal>0</literal> and "
"<literal>1</literal>."
msgstr ""
"Битовые строковые константы похожи на обычные с дополнительной буквой "
"<literal>B</literal> (заглавной или строчной), добавленной непосредственно "
"перед открывающим апострофом (без промежуточных пробелов), например: "
"<literal>B'1001'</literal>. В битовых строковых константах допускаются лишь "
"символы <literal>0</literal> и <literal>1</literal>."

#: syntax.xml:654(para)
msgid ""
"Alternatively, bit-string constants can be specified in hexadecimal "
"notation, using a leading <literal>X</literal> (upper or lower case), e.g., "
"<literal>X'1FF'</literal>. This notation is equivalent to a bit-string "
"constant with four binary digits for each hexadecimal digit."
msgstr ""
"Битовые константы могут быть записаны и по-другому, в шестнадцатеричном "
"виде, с начальной буквой <literal>X</literal> (заглавной или строчной), "
"например: <literal>X'1FF'</literal>. Такая запись эквивалентна двоичной, "
"только четыре двоичных цифры заменяются одной шестнадцатеричной."

#: syntax.xml:661(para)
msgid ""
"Both forms of bit-string constant can be continued across lines in the same "
"way as regular string constants. Dollar quoting cannot be used in a bit-"
"string constant."
msgstr ""
"Обе формы записи допускают перенос строк так же, как и обычные строковые "
"константы. Однако заключать в доллары битовые строки нельзя."

#: syntax.xml:669(title)
msgid "Numeric Constants"
msgstr "Числовые константы"

#: syntax.xml:671(indexterm)
msgid "<primary>number</primary> <secondary>constant</secondary>"
msgstr "<primary>числовые</primary> <secondary>константы</secondary>"

#: syntax.xml:676(para)
msgid ""
"Numeric constants are accepted in these general forms: <synopsis>\n"
"<replaceable>digits</replaceable>\n"
"<replaceable>digits</replaceable>.<optional><replaceable>digits</"
"replaceable></optional><optional>e<optional>+-</"
"optional><replaceable>digits</replaceable></optional>\n"
"<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</"
"replaceable><optional>e<optional>+-</optional><replaceable>digits</"
"replaceable></optional>\n"
"<replaceable>digits</replaceable>e<optional>+-</"
"optional><replaceable>digits</replaceable>\n"
"</synopsis> where <replaceable>digits</replaceable> is one or more decimal "
"digits (0 through 9). At least one digit must be before or after the decimal "
"point, if one is used. At least one digit must follow the exponent marker "
"(<literal>e</literal>), if one is present. There cannot be any spaces or "
"other characters embedded in the constant. Note that any leading plus or "
"minus sign is not actually considered part of the constant; it is an "
"operator applied to the constant."
msgstr ""
"Числовые константы могут быть заданы в следующем общем виде: <synopsis>\n"
"<replaceable>цифры</replaceable>\n"
"<replaceable>цифры</replaceable>.<optional><replaceable>цифры</replaceable></"
"optional><optional>e<optional>+-</optional><replaceable>цифры</replaceable></"
"optional>\n"
"<optional><replaceable>цифры</replaceable></optional>.<replaceable>цифры</"
"replaceable><optional>e<optional>+-</optional><replaceable>цифры</"
"replaceable></optional>\n"
"<replaceable>цифры</replaceable>e<optional>+-</optional><replaceable>цифры</"
"replaceable>\n"
"</synopsis> где <replaceable>цифры</replaceable> &mdash; это одна или "
"несколько десятичных цифр (0..9). До или после десятичной точки (при её "
"наличии) должна быть минимум одна цифра. Как минимум одна цифра должна "
"следовать за обозначением экспоненты (<literal>e</literal>), если оно "
"присутствует. В числовой константе не может быть пробелов или других "
"символов. Заметьте, что любой знак минус или плюс в начале строки не "
"считается частью числа; это оператор, применённый к константе."

#: syntax.xml:694(para)
msgid ""
"These are some examples of valid numeric constants: <literallayout>\n"
"42\n"
"3.5\n"
"4.\n"
".001\n"
"5e2\n"
"1.925e-3\n"
"</literallayout>"
msgstr ""
"Несколько примеров допустимых числовых констант: <literallayout>\n"
"42\n"
"3.5\n"
"4.\n"
".001\n"
"5e2\n"
"1.925e-3\n"
"</literallayout>"

#: syntax.xml:707(indexterm)
msgid "<primary>integer</primary>"
msgstr "<primary>integer</primary>"

#: syntax.xml:708(indexterm)
msgid "<primary>bigint</primary>"
msgstr "<primary>bigint</primary>"

#: syntax.xml:709(indexterm)
msgid "<primary>numeric</primary>"
msgstr "<primary>numeric</primary>"

#: syntax.xml:706(para)
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> A numeric constant that "
"contains neither a decimal point nor an exponent is initially presumed to be "
"type <type>integer</type> if its value fits in type <type>integer</type> (32 "
"bits); otherwise it is presumed to be type <type>bigint</type> if its value "
"fits in type <type>bigint</type> (64 bits); otherwise it is taken to be type "
"<type>numeric</type>. Constants that contain decimal points and/or exponents "
"are always initially presumed to be type <type>numeric</type>."
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> Числовая константа, не "
"содержащая точки и экспоненты, изначально рассматривается как константа типа "
"<type>integer</type>, если её значение умещается в 32-битный тип "
"<type>integer</type>; затем как константа типа <type>bigint</type>, если её "
"значение умещается в 64-битный <type>bigint</type>; в противном случае она "
"принимает тип <type>numeric</type>. Константы, содержащие десятичные точки и/"
"или экспоненты, всегда считаются константами типа <type>numeric</type>."

#: syntax.xml:726(indexterm) syntax.xml:1964(indexterm)
msgid "<primary>type cast</primary>"
msgstr "<primary>приведение типа</primary>"

#: syntax.xml:730(programlisting)
#, no-wrap
msgid ""
"REAL '1.23'  -- string style\n"
"1.23::REAL   -- PostgreSQL (historical) style"
msgstr ""
"REAL '1.23'  -- строковый стиль\n"
"1.23::REAL   -- стиль PostgreSQL (исторический)"

#: syntax.xml:720(para)
msgid ""
"The initially assigned data type of a numeric constant is just a starting "
"point for the type resolution algorithms. In most cases the constant will be "
"automatically coerced to the most appropriate type depending on context. "
"When necessary, you can force a numeric value to be interpreted as a "
"specific data type by casting it.<placeholder-1/> For example, you can force "
"a numeric value to be treated as type <type>real</type> (<type>float4</"
"type>) by writing: <placeholder-2/> These are actually just special cases of "
"the general casting notations discussed next."
msgstr ""
"Изначально назначенный тип данных числовой константы это только отправная "
"точка для алгоритмов определения типа. В большинстве случаев константа будет "
"автоматически приведена к наиболее подходящему типу для данного контекста. "
"При необходимости вы можете принудительно интерпретировать числовое значение "
"как значение определённого типа, приведя его тип к нужному.<placeholder-1/> "
"Например, вы можете сделать, чтобы числовое значение рассматривалось как "
"имеющее тип <type>real</type> (<type>float4</type>), написав: <placeholder-2/"
"> На самом деле это только частные случаи синтаксиса приведения типов, "
"который будет рассматриваться далее."

#: syntax.xml:741(title)
msgid "Constants of Other Types"
msgstr "Константы других типов"

#: syntax.xml:743(indexterm)
msgid "<primary>data type</primary> <secondary>constant</secondary>"
msgstr "<primary>типы данных</primary> <secondary>константы</secondary>"

#: syntax.xml:748(para)
msgid ""
"A constant of an <emphasis>arbitrary</emphasis> type can be entered using "
"any one of the following notations: <synopsis>\n"
"<replaceable>type</replaceable> '<replaceable>string</replaceable>'\n"
"'<replaceable>string</replaceable>'::<replaceable>type</replaceable>\n"
"CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</"
"replaceable> )\n"
"</synopsis> The string constant's text is passed to the input conversion "
"routine for the type called <replaceable>type</replaceable>. The result is a "
"constant of the indicated type. The explicit type cast can be omitted if "
"there is no ambiguity as to the type the constant must be (for example, when "
"it is assigned directly to a table column), in which case it is "
"automatically coerced."
msgstr ""
"Константу <emphasis>обычного</emphasis> типа можно ввести одним из следующих "
"способов: <synopsis>\n"
"<replaceable>type</replaceable> '<replaceable>string</replaceable>'\n"
"'<replaceable>string</replaceable>'::<replaceable>type</replaceable>\n"
"CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</"
"replaceable> )\n"
"</synopsis> Текст строковой константы передаётся процедуре преобразования "
"ввода для типа, обозначенного здесь <replaceable>type</replaceable>. "
"Результатом становится константа указанного типа. Явное приведение типа "
"можно опустить, если нужный тип константы определяется однозначно (например, "
"когда она присваивается непосредственно столбцу таблицы), так как в этом "
"случае приведение происходит автоматически."

#: syntax.xml:764(para)
msgid ""
"The string constant can be written using either regular SQL notation or "
"dollar-quoting."
msgstr ""
"Строковую константу можно записать, используя как обычный синтаксис SQL, так "
"и формат с долларами."

#: syntax.xml:769(para)
msgid ""
"It is also possible to specify a type coercion using a function-like syntax: "
"<synopsis>\n"
"<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )\n"
"</synopsis> but not all type names can be used in this way; see <xref "
"linkend=\"sql-syntax-type-casts\"/> for details."
msgstr ""
"Также можно записать приведение типов, используя синтаксис функций: "
"<synopsis>\n"
"<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )\n"
"</synopsis>но это работает не для всех имён типов; подробнее об этом "
"написано в <xref remap=\"6\" linkend=\"sql-syntax-type-casts\"/>."

#: syntax.xml:779(para)
msgid ""
"The <literal>::</literal>, <literal>CAST()</literal>, and function-call "
"syntaxes can also be used to specify run-time type conversions of arbitrary "
"expressions, as discussed in <xref linkend=\"sql-syntax-type-casts\"/>. To "
"avoid syntactic ambiguity, the <literal><replaceable>type</replaceable> "
"'<replaceable>string</replaceable>'</literal> syntax can only be used to "
"specify the type of a simple literal constant. Another restriction on the "
"<literal><replaceable>type</replaceable> '<replaceable>string</"
"replaceable>'</literal> syntax is that it does not work for array types; use "
"<literal>::</literal> or <literal>CAST()</literal> to specify the type of an "
"array constant."
msgstr ""
"Конструкцию <literal>::</literal>, <literal>CAST()</literal> и синтаксис "
"вызова функции можно также использовать для преобразования типов обычных "
"выражений во время выполнения, как описано в <xref remap=\"6\" linkend=\"sql-"
"syntax-type-casts\"/>. Во избежание синтаксической неопределённости, запись "
"<literal><replaceable>тип</replaceable> '<replaceable>строка</replaceable>'</"
"literal> можно использовать только для указания типа простой текстовой "
"константы. Ещё одно ограничение записи <literal><replaceable>тип</"
"replaceable> '<replaceable>строка</replaceable>'</literal>: она не работает "
"для массивов; для таких констант следует использовать <literal>::</literal> "
"или <literal>CAST()</literal>."

#: syntax.xml:792(para)
msgid ""
"The <literal>CAST()</literal> syntax conforms to SQL. The "
"<literal><replaceable>type</replaceable> '<replaceable>string</"
"replaceable>'</literal> syntax is a generalization of the standard: SQL "
"specifies this syntax only for a few data types, but "
"<productname>PostgreSQL</productname> allows it for all types. The syntax "
"with <literal>::</literal> is historical <productname>PostgreSQL</"
"productname> usage, as is the function-call syntax."
msgstr ""
"Синтаксис <literal>CAST()</literal> соответствует SQL, а запись "
"<literal><replaceable>type</replaceable> '<replaceable>string</"
"replaceable>'</literal> является обобщением стандарта: в SQL такой синтаксис "
"поддерживает только некоторые типы данных, но <productname>PostgreSQL</"
"productname> позволяет использовать его для всех. Синтаксис с <literal>::</"
"literal> имеет исторические корни в <productname>PostgreSQL</productname>, "
"как и запись в виде вызова функции."

#: syntax.xml:805(title)
msgid "Operators"
msgstr "Операторы"

#: syntax.xml:807(indexterm)
msgid "<primary>operator</primary> <secondary>syntax</secondary>"
msgstr "<primary>оператор</primary> <secondary>синтаксис</secondary>"

#: syntax.xml:822(para)
msgid ""
"<literal>--</literal> and <literal>/*</literal> cannot appear anywhere in an "
"operator name, since they will be taken as the start of a comment."
msgstr ""
"Сочетания символов <literal>--</literal> и <literal>/*</literal> не могут "
"присутствовать в имени оператора, так как они будут обозначать начало "
"комментария."

#: syntax.xml:830(para)
msgid ""
"A multiple-character operator name cannot end in <literal>+</literal> or "
"<literal>-</literal>, unless the name also contains at least one of these "
"characters: <literallayout>\n"
"~ ! @ # % ^ &amp; | ` ?\n"
"</literallayout> For example, <literal>@-</literal> is an allowed operator "
"name, but <literal>*-</literal> is not. This restriction allows "
"<productname>PostgreSQL</productname> to parse SQL-compliant queries without "
"requiring spaces between tokens."
msgstr ""
"Многосимвольное имя оператора не может заканчиваться знаком <literal>+</"
"literal> или <literal>-</literal>, если только оно не содержит также один из "
"этих символов: <literallayout>\n"
"~ ! @ # % ^ &amp; | ` ?\n"
"</literallayout> Например, <literal>@-</literal> &mdash; допустимое имя "
"оператора, а <literal>*-</literal> &mdash; нет. Благодаря этому ограничению, "
"<productname>PostgreSQL</productname> может разбирать корректные SQL-запросы "
"без пробелов между компонентами."

#: syntax.xml:812(para)
msgid ""
"An operator name is a sequence of up to <symbol>NAMEDATALEN</symbol>-1 (63 "
"by default) characters from the following list: <literallayout>\n"
"+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?\n"
"</literallayout> There are a few restrictions on operator names, however: "
"<placeholder-1/>"
msgstr ""
"Имя оператора образует последовательность не более чем <symbol>NAMEDATALEN</"
"symbol>-1 (по умолчанию 63) символов из следующего списка: <literallayout>\n"
"+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?\n"
"</literallayout> Однако для имён операторов есть ещё несколько ограничений: "
"<placeholder-1/>"

#: syntax.xml:845(para)
msgid ""
"When working with non-SQL-standard operator names, you will usually need to "
"separate adjacent operators with spaces to avoid ambiguity. For example, if "
"you have defined a left unary operator named <literal>@</literal>, you "
"cannot write <literal>X*@Y</literal>; you must write <literal>X* @Y</"
"literal> to ensure that <productname>PostgreSQL</productname> reads it as "
"two operator names not one."
msgstr ""
"Записывая нестандартные SQL-операторы, обычно нужно отделять имена соседних "
"операторов пробелами для однозначности. Например, если вы определили левый "
"унарный оператор с именем <literal>@</literal>, вы не можете написать "
"<literal>X*@Y</literal>, а должны написать <literal>X* @Y</literal>, чтобы "
"<productname>PostgreSQL</productname> однозначно прочитал это как два "
"оператора, а не один."

#: syntax.xml:857(title)
msgid "Special Characters"
msgstr "Специальные знаки"

#: syntax.xml:868(para)
msgid ""
"A dollar sign (<literal>$</literal>) followed by digits is used to represent "
"a positional parameter in the body of a function definition or a prepared "
"statement. In other contexts the dollar sign can be part of an identifier or "
"a dollar-quoted string constant."
msgstr ""
"Знак доллара (<literal>$</literal>), предваряющий число, используется для "
"представления позиционного параметра в теле определения функции или "
"подготовленного оператора. В других контекстах знак доллара может быть "
"частью идентификатора или строковой константы, заключённой в доллары."

#: syntax.xml:878(para)
msgid ""
"Parentheses (<literal>()</literal>) have their usual meaning to group "
"expressions and enforce precedence. In some cases parentheses are required "
"as part of the fixed syntax of a particular SQL command."
msgstr ""
"Круглые скобки (<literal>()</literal>) имеют обычное значение и применяются "
"для группировки выражений и повышения приоритета операций. В некоторых "
"случаях скобки &mdash; это необходимая часть синтаксиса определённых SQL-"
"команд."

#: syntax.xml:887(para)
msgid ""
"Brackets (<literal>[]</literal>) are used to select the elements of an "
"array. See <xref linkend=\"arrays\"/> for more information on arrays."
msgstr ""
"Квадратные скобки (<literal>[]</literal>) применяются для выделения "
"элементов массива. Подробнее массивы рассматриваются в <xref remap=\"6\" "
"linkend=\"arrays\"/>."

#: syntax.xml:895(para)
msgid ""
"Commas (<literal>,</literal>) are used in some syntactical constructs to "
"separate the elements of a list."
msgstr ""
"Запятые (<literal>,</literal>) используются в некоторых синтаксических "
"конструкциях для разделения элементов списка."

#: syntax.xml:902(para)
msgid ""
"The semicolon (<literal>;</literal>) terminates an SQL command. It cannot "
"appear anywhere within a command, except within a string constant or quoted "
"identifier."
msgstr ""
"Точка с запятой (<literal>;</literal>) завершает команду SQL. Она не может "
"находиться нигде внутри команды, за исключением строковых констант или "
"идентификаторов в кавычках."

#: syntax.xml:910(para)
msgid ""
"The colon (<literal>:</literal>) is used to select <quote>slices</quote> "
"from arrays. (See <xref linkend=\"arrays\"/>.) In certain SQL dialects (such "
"as Embedded SQL), the colon is used to prefix variable names."
msgstr ""
"Двоеточие (<literal>:</literal>) применяется для выборки <quote>срезов</"
"quote> массивов (см. <xref remap=\"4\" linkend=\"arrays\"/>.) В некоторых "
"диалектах SQL (например, в Embedded SQL) двоеточие может быть префиксом в "
"имени переменной."

#: syntax.xml:919(para)
msgid ""
"The asterisk (<literal>*</literal>) is used in some contexts to denote all "
"the fields of a table row or composite value. It also has a special meaning "
"when used as the argument of an aggregate function, namely that the "
"aggregate does not require any explicit parameter."
msgstr ""
"Звёздочка (<literal>*</literal>) используется в некоторых контекстах как "
"обозначение всех полей строки или составного значения. Она также имеет "
"специальное значение, когда используется как аргумент некоторых агрегатных "
"функций, а именно функций, которым не нужны явные параметры."

#: syntax.xml:929(para)
msgid ""
"The period (<literal>.</literal>) is used in numeric constants, and to "
"separate schema, table, and column names."
msgstr ""
"Точка (<literal>.</literal>) используется в числовых константах, а также для "
"отделения имён схемы, таблицы и столбца."

#: syntax.xml:859(para)
msgid ""
"Some characters that are not alphanumeric have a special meaning that is "
"different from being an operator. Details on the usage can be found at the "
"location where the respective syntax element is described. This section only "
"exists to advise the existence and summarize the purposes of these "
"characters. <placeholder-1/>"
msgstr ""
"Некоторые не алфавитно-цифровые символы имеют специальное значение, но при "
"этом не являются операторами. Подробнее их использование будет рассмотрено "
"при описании соответствующего элемента синтаксиса. Здесь они упоминаются "
"только для сведения и обобщения их предназначения. <placeholder-1/>"

#: syntax.xml:940(title)
msgid "Comments"
msgstr "Комментарии"

#: syntax.xml:942(indexterm)
msgid "<primary>comment</primary> <secondary sortas=\"SQL\">in SQL</secondary>"
msgstr ""
"<primary>комментарий</primary> <secondary sortas=\"SQL\">в SQL</secondary>"

#: syntax.xml:950(programlisting)
#, no-wrap
msgid "-- This is a standard SQL comment"
msgstr "-- Это стандартный комментарий SQL"

#: syntax.xml:947(para)
msgid ""
"A comment is a sequence of characters beginning with double dashes and "
"extending to the end of the line, e.g.: <placeholder-1/>"
msgstr ""
"Комментарий &mdash; это последовательность символов, которая начинается с "
"двух минусов и продолжается до конца строки, например: <placeholder-1/>"

#: syntax.xml:957(programlisting)
#, no-wrap
msgid ""
"/* multiline comment\n"
" * with nesting: /* nested block comment */\n"
" */"
msgstr ""
"/* многострочный комментарий\n"
" * с вложенностью: /* вложенный блок комментария */\n"
" */"

#: syntax.xml:955(para)
msgid ""
"Alternatively, C-style block comments can be used: <placeholder-1/> where "
"the comment begins with <literal>/*</literal> and extends to the matching "
"occurrence of <literal>*/</literal>. These block comments nest, as specified "
"in the SQL standard but unlike C, so that one can comment out larger blocks "
"of code that might contain existing block comments."
msgstr ""
"Кроме этого, блочные комментарии можно записывать в стиле C: <placeholder-1/"
"> где комментарий начинается с <literal>/*</literal> и продолжается до "
"соответствующего вхождения <literal>*/</literal>. Блочные комментарии можно "
"вкладывать друг в друга, как разрешено по стандарту SQL (но не разрешено в "
"C), так что вы можете комментировать большие блоки кода, которые при этом "
"уже могут содержать блоки комментариев."

#: syntax.xml:969(para)
msgid ""
"A comment is removed from the input stream before further syntax analysis "
"and is effectively replaced by whitespace."
msgstr ""
"Комментарий удаляется из входного потока в начале синтаксического анализа и "
"фактически заменяется пробелом."

#: syntax.xml:976(title)
msgid "Operator Precedence"
msgstr "Приоритеты операторов"

#: syntax.xml:978(indexterm)
msgid "<primary>operator</primary> <secondary>precedence</secondary>"
msgstr "<primary>оператор</primary> <secondary>приоритеты</secondary>"

#: syntax.xml:983(para)
msgid ""
"<xref linkend=\"sql-precedence-table\"/> shows the precedence and "
"associativity of the operators in <productname>PostgreSQL</productname>. "
"Most operators have the same precedence and are left-associative. The "
"precedence and associativity of the operators is hard-wired into the parser."
msgstr ""
"В <xref remap=\"6\" linkend=\"sql-precedence-table\"/> показаны приоритеты и "
"очерёдность операторов, действующие в <productname>PostgreSQL</productname>. "
"Большинство операторов имеют одинаковый приоритет и вычисляются слева "
"направо. Приоритет и очерёдность операторов жёстко фиксированы в "
"синтаксическом анализаторе."

#: syntax.xml:995(programlisting)
#, no-wrap
msgid "SELECT 5 ! - 6;"
msgstr "SELECT 5 ! - 6;"

#: syntax.xml:999(programlisting)
#, no-wrap
msgid "SELECT 5 ! (- 6);"
msgstr "SELECT 5 ! (- 6);"

#: syntax.xml:1006(programlisting)
#, no-wrap
msgid "SELECT (5 !) - 6;"
msgstr "SELECT (5 !) - 6;"

#: syntax.xml:991(para)
msgid ""
"You will sometimes need to add parentheses when using combinations of binary "
"and unary operators. For instance: <placeholder-1/> will be parsed as: "
"<placeholder-2/> because the parser has no idea &mdash; until it is too late "
"&mdash; that <token>!</token> is defined as a postfix operator, not an infix "
"one. To get the desired behavior in this case, you must write: "
"<placeholder-3/> This is the price one pays for extensibility."
msgstr ""
"Иногда вам потребуется добавлять скобки, когда вы комбинируете унарные и "
"бинарные операторы. Например, выражение: <placeholder-1/> будет разобрано "
"как: <placeholder-2/> так как анализатор до последнего не знает, что "
"оператор <token>!</token> определён как постфиксный, а не инфиксный "
"(внутренний). Чтобы получить желаемый результат в этом случае, нужно "
"написать: <placeholder-3/> Такова цена расширяемости."

#: syntax.xml:1013(title)
msgid "Operator Precedence (highest to lowest)"
msgstr "Приоритет операторов (от большего к меньшему)"

#: syntax.xml:1018(entry)
msgid "Operator/Element"
msgstr "Оператор/элемент"

#: syntax.xml:1019(entry)
msgid "Associativity"
msgstr "Очерёдность"

#: syntax.xml:1020(entry)
msgid "Description"
msgstr "Описание"

#: syntax.xml:1026(token)
msgid "."
msgstr "."

# TODO: отделить это вхождение от других
#: syntax.xml:1027(entry) syntax.xml:1033(entry) syntax.xml:1039(entry)
#: syntax.xml:1051(entry) syntax.xml:1057(entry) syntax.xml:1063(entry)
#: syntax.xml:1069(entry) syntax.xml:1101(entry) syntax.xml:1107(entry)
msgid "left"
msgstr "слева-направо"

#: syntax.xml:1028(entry)
msgid "table/column name separator"
msgstr "разделитель имён таблицы и столбца"

#: syntax.xml:1032(token)
msgid "::"
msgstr "::"

#: syntax.xml:1034(entry)
msgid "<productname>PostgreSQL</productname>-style typecast"
msgstr "приведение типов в стиле <productname>PostgreSQL</productname>"

#: syntax.xml:1038(token)
msgid "["
msgstr "["

#: syntax.xml:1038(token)
msgid "]"
msgstr "]"

#: syntax.xml:1040(entry)
msgid "array element selection"
msgstr "выбор элемента массива"

#: syntax.xml:1044(token) syntax.xml:1062(token)
msgid "+"
msgstr "+"

#: syntax.xml:1044(token) syntax.xml:1062(token)
msgid "-"
msgstr "-"

# TODO: отделить это вхождение от других
#: syntax.xml:1045(entry) syntax.xml:1095(entry)
msgid "right"
msgstr "справа-налево"

#: syntax.xml:1046(entry)
msgid "unary plus, unary minus"
msgstr "унарный плюс, унарный минус"

#: syntax.xml:1050(token)
msgid "^"
msgstr "^"

#: syntax.xml:1052(entry)
msgid "exponentiation"
msgstr "возведение в степень"

#: syntax.xml:1056(token)
msgid "*"
msgstr "*"

#: syntax.xml:1056(token)
msgid "/"
msgstr "/"

#: syntax.xml:1056(token)
msgid "%"
msgstr "%"

#: syntax.xml:1058(entry)
msgid "multiplication, division, modulo"
msgstr "умножение, деление, остаток от деления"

#: syntax.xml:1064(entry)
msgid "addition, subtraction"
msgstr "сложение, вычитание"

#: syntax.xml:1068(entry)
msgid "(any other operator)"
msgstr "(любой другой оператор)"

#: syntax.xml:1070(entry)
msgid "all other native and user-defined operators"
msgstr "все другие встроенные и пользовательские операторы"

#: syntax.xml:1074(token)
msgid "BETWEEN"
msgstr "BETWEEN"

#: syntax.xml:1074(token)
msgid "IN"
msgstr "IN"

#: syntax.xml:1074(token)
msgid "LIKE"
msgstr "LIKE"

#: syntax.xml:1074(token)
msgid "ILIKE"
msgstr "ILIKE"

#: syntax.xml:1074(token)
msgid "SIMILAR"
msgstr "SIMILAR"

#: syntax.xml:1076(entry)
msgid "range containment, set membership, string matching"
msgstr "проверка диапазона, проверка членства, сравнение строк"

#: syntax.xml:1080(token)
msgid "&lt;"
msgstr "&lt;"

#: syntax.xml:1080(token)
msgid "&gt;"
msgstr "&gt;"

#: syntax.xml:1080(token)
msgid "="
msgstr "="

#: syntax.xml:1080(token)
msgid "&lt;="
msgstr "&lt;="

#: syntax.xml:1080(token)
msgid "&gt;="
msgstr "&gt;="

#: syntax.xml:1080(token)
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#: syntax.xml:1083(entry)
msgid "comparison operators"
msgstr "операторы сравнения"

#: syntax.xml:1087(token)
msgid "IS"
msgstr "IS"

#: syntax.xml:1087(token)
msgid "ISNULL"
msgstr "ISNULL"

#: syntax.xml:1087(token)
msgid "NOTNULL"
msgstr "NOTNULL"

#: syntax.xml:1089(entry)
msgid ""
"<literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS NULL</"
"literal>, <literal>IS DISTINCT FROM</literal>, etc"
msgstr ""
"<literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS NULL</"
"literal>, <literal>IS DISTINCT FROM</literal> и т. д."

#: syntax.xml:1094(token)
msgid "NOT"
msgstr "NOT"

#: syntax.xml:1096(entry)
msgid "logical negation"
msgstr "логическое отрицание"

#: syntax.xml:1100(token)
msgid "AND"
msgstr "AND"

#: syntax.xml:1102(entry)
msgid "logical conjunction"
msgstr "логическая конъюнкция"

#: syntax.xml:1106(token)
msgid "OR"
msgstr "OR"

#: syntax.xml:1108(entry)
msgid "logical disjunction"
msgstr "логическая дизъюнкция"

#: syntax.xml:1114(para)
msgid ""
"Note that the operator precedence rules also apply to user-defined operators "
"that have the same names as the built-in operators mentioned above. For "
"example, if you define a <quote>+</quote> operator for some custom data type "
"it will have the same precedence as the built-in <quote>+</quote> operator, "
"no matter what yours does."
msgstr ""
"Заметьте, что правила приоритета операторов также применяются к операторам, "
"определённым пользователем с теми же именами, что и вышеперечисленные "
"встроенные операторы. Например, если вы определите оператор <quote>+</quote> "
"для некоторого нестандартного типа данных, он будет иметь тот же приоритет, "
"что и встроенный оператор <quote>+</quote>, независимо от того, что он у вас "
"делает."

#: syntax.xml:1126(programlisting)
#, no-wrap
msgid "SELECT 3 OPERATOR(pg_catalog.+) 4;"
msgstr "SELECT 3 OPERATOR(pg_catalog.+) 4;"

#: syntax.xml:1123(para)
msgid ""
"When a schema-qualified operator name is used in the <literal>OPERATOR</"
"literal> syntax, as for example in: <placeholder-1/> the <literal>OPERATOR</"
"literal> construct is taken to have the default precedence shown in <xref "
"linkend=\"sql-precedence-table\"/> for <quote>any other operator</quote>. "
"This is true no matter which specific operator appears inside "
"<literal>OPERATOR()</literal>."
msgstr ""
"Когда в конструкции <literal>OPERATOR</literal> используется имя оператора "
"со схемой, например так: <placeholder-1/> тогда <literal>OPERATOR</literal> "
"имеет приоритет по умолчанию, соответствующий в <xref remap=\"6\" linkend="
"\"sql-precedence-table\"/> строке <quote>любой другой оператор</quote>. Это "
"не зависит от того, какие именно операторы находятся в конструкции "
"<literal>OPERATOR()</literal>."

#: syntax.xml:1136(para)
msgid ""
"<productname>PostgreSQL</productname> versions before 9.5 used slightly "
"different operator precedence rules. In particular, <token>&lt;=</token> "
"<token>&gt;=</token> and <token>&lt;&gt;</token> used to be treated as "
"generic operators; <literal>IS</literal> tests used to have higher priority; "
"and <literal>NOT BETWEEN</literal> and related constructs acted "
"inconsistently, being taken in some cases as having the precedence of "
"<literal>NOT</literal> rather than <literal>BETWEEN</literal>. These rules "
"were changed for better compliance with the SQL standard and to reduce "
"confusion from inconsistent treatment of logically equivalent constructs. In "
"most cases, these changes will result in no behavioral change, or perhaps in "
"<quote>no such operator</quote> failures which can be resolved by adding "
"parentheses. However there are corner cases in which a query might change "
"behavior without any parsing error being reported. If you are concerned "
"about whether these changes have silently broken something, you can test "
"your application with the configuration parameter <xref linkend=\"guc-"
"operator-precedence-warning\"/> turned on to see if any warnings are logged."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 9.5 действовали немного "
"другие правила приоритета операторов. В частности, операторы <token>&lt;=</"
"token>, <token>&gt;=</token> и <token>&lt;&gt;</token> обрабатывались по "
"общему правилу; проверки <literal>IS</literal> имели более высокий "
"приоритет; а <literal>NOT BETWEEN</literal> и связанные конструкции работали "
"несогласованно — в некоторых случаях приоритетнее оказывался оператор "
"<literal>NOT</literal>, а не <literal>BETWEEN</literal>. Эти правила были "
"изменены для лучшего соответствия стандарту SQL и для уменьшения путаницы из-"
"за несогласованной обработки логически равнозначных конструкций. В "
"большинстве случаев эти изменения никак не проявятся, либо могут привести к "
"ошибкам типа <quote>нет такого оператора</quote>, которые можно разрешить, "
"добавив скобки. Однако, возможны особые случаи, когда запрос будет разобран "
"без ошибки, но его поведение может измениться. Если вас беспокоит, не "
"нарушают ли эти изменения незаметно работу вашего приложения, вы можете "
"проверить это, включив конфигурационный параметр <xref linkend=\"guc-"
"operator-precedence-warning\"/> и пронаблюдав, не появятся ли предупреждения "
"в журнале."

#: syntax.xml:1160(title)
msgid "Value Expressions"
msgstr "Выражения значения"

#: syntax.xml:1162(indexterm)
msgid "<primary>expression</primary> <secondary>syntax</secondary>"
msgstr "<primary>выражение</primary> <secondary>синтаксис</secondary>"

#: syntax.xml:1167(indexterm)
msgid "<primary>value expression</primary>"
msgstr "<primary>выражение значения</primary>"

#: syntax.xml:1171(indexterm)
msgid "<primary>scalar</primary> <see>expression</see>"
msgstr "<primary>скаляр</primary> <see>выражение</see>"

#: syntax.xml:1176(para)
msgid ""
"Value expressions are used in a variety of contexts, such as in the target "
"list of the <command>SELECT</command> command, as new column values in "
"<command>INSERT</command> or <command>UPDATE</command>, or in search "
"conditions in a number of commands. The result of a value expression is "
"sometimes called a <firstterm>scalar</firstterm>, to distinguish it from the "
"result of a table expression (which is a table). Value expressions are "
"therefore also called <firstterm>scalar expressions</firstterm> (or even "
"simply <firstterm>expressions</firstterm>). The expression syntax allows the "
"calculation of values from primitive parts using arithmetic, logical, set, "
"and other operations."
msgstr ""
"Выражения значения применяются в самых разных контекстах, например в списке "
"результатов команды <command>SELECT</command>, в значениях столбцов в "
"<command>INSERT</command> или <command>UPDATE</command> или в условиях "
"поиска во многих командах. Результат такого выражения иногда называют "
"<firstterm>скаляром</firstterm>, чтобы отличить его от результата табличного "
"выражения (который представляет собой таблицу). А сами выражения значения "
"часто называют <firstterm>скалярными</firstterm> (или просто "
"<firstterm>выражениями</firstterm>). Синтаксис таких выражений позволяет "
"вычислять значения из примитивных частей, используя арифметические, "
"логические и другие операции."

#: syntax.xml:1195(para)
msgid "A constant or literal value"
msgstr "Константа или непосредственное значение"

#: syntax.xml:1201(para)
msgid "A column reference"
msgstr "Ссылка на столбец"

#: syntax.xml:1207(para)
msgid ""
"A positional parameter reference, in the body of a function definition or "
"prepared statement"
msgstr ""
"Ссылка на позиционный параметр в теле определения функции или "
"подготовленного оператора"

#: syntax.xml:1214(para)
msgid "A subscripted expression"
msgstr "Выражение с индексом"

#: syntax.xml:1220(para)
msgid "A field selection expression"
msgstr "Выражение выбора поля"

#: syntax.xml:1226(para)
msgid "An operator invocation"
msgstr "Применение оператора"

#: syntax.xml:1232(para)
msgid "A function call"
msgstr "Вызов функции"

#: syntax.xml:1238(para)
msgid "An aggregate expression"
msgstr "Агрегатное выражение"

#: syntax.xml:1244(para)
msgid "A window function call"
msgstr "Вызов оконной функции"

#: syntax.xml:1250(para)
msgid "A type cast"
msgstr "Приведение типов"

#: syntax.xml:1256(para)
msgid "A collation expression"
msgstr "Применение правил сортировки"

#: syntax.xml:1262(para)
msgid "A scalar subquery"
msgstr "Скалярный подзапрос"

#: syntax.xml:1268(para)
msgid "An array constructor"
msgstr "Конструктор массива"

#: syntax.xml:1274(para)
msgid "A row constructor"
msgstr "Конструктор табличной строки"

#: syntax.xml:1283(indexterm)
msgid "<primary>parenthesis</primary>"
msgstr "<primary>скобки</primary>"

#: syntax.xml:1280(para)
msgid ""
"Another value expression in parentheses (used to group subexpressions and "
"override precedence<placeholder-1/>)"
msgstr ""
"Кроме того, выражением значения являются скобки (предназначенные для "
"группировки подвыражений и переопределения приоритета <placeholder-1/>)"

#: syntax.xml:1190(para)
msgid "A value expression is one of the following: <placeholder-1/>"
msgstr "Выражениями значения являются: <placeholder-1/>"

#: syntax.xml:1289(para)
msgid ""
"In addition to this list, there are a number of constructs that can be "
"classified as an expression but do not follow any general syntax rules. "
"These generally have the semantics of a function or operator and are "
"explained in the appropriate location in <xref linkend=\"functions\"/>. An "
"example is the <literal>IS NULL</literal> clause."
msgstr ""
"В дополнение к этому списку есть ещё несколько конструкций, которые можно "
"классифицировать как выражения, хотя они не соответствуют общим "
"синтаксическим правилам. Они обычно имеют вид функции или оператора и будут "
"рассмотрены в соответствующем разделе <xref remap=\"2\" linkend=\"functions"
"\"/>. Пример такой конструкции &mdash; предложение <literal>IS NULL</"
"literal>."

#: syntax.xml:1298(para)
msgid ""
"We have already discussed constants in <xref linkend=\"sql-syntax-constants"
"\"/>. The following sections discuss the remaining options."
msgstr ""
"Мы уже обсудили константы в <xref remap=\"6\" linkend=\"sql-syntax-constants"
"\"/>. В следующих разделах рассматриваются остальные варианты."

#: syntax.xml:1305(title)
msgid "Column References"
msgstr "Ссылки на столбцы"

#: syntax.xml:1307(indexterm)
msgid "<primary>column reference</primary>"
msgstr "<primary>ссылка на столбец</primary>"

#: syntax.xml:1311(para)
msgid ""
"A column can be referenced in the form: <synopsis>\n"
"<replaceable>correlation</replaceable>.<replaceable>columnname</"
"replaceable>\n"
"</synopsis>"
msgstr ""
"Ссылку на столбец можно записать в форме: <synopsis>\n"
"<replaceable>отношение</replaceable>.<replaceable>имя_столбца</replaceable>\n"
"</synopsis>"

#: syntax.xml:1318(para)
msgid ""
"<replaceable>correlation</replaceable> is the name of a table (possibly "
"qualified with a schema name), or an alias for a table defined by means of a "
"<literal>FROM</literal> clause. The correlation name and separating dot can "
"be omitted if the column name is unique across all the tables being used in "
"the current query. (See also <xref linkend=\"queries\"/>.)"
msgstr ""
"Здесь <replaceable>отношение</replaceable> &mdash; имя таблицы (возможно, "
"полное, с именем схемы) или её псевдоним, определённый в предложении "
"<literal>FROM</literal>. Это имя и разделяющую точку можно опустить, если "
"имя столбца уникально среди всех таблиц, задействованных в текущем запросе. "
"(См. также <xref remap=\"4\" linkend=\"queries\"/>.)"

#: syntax.xml:1328(title)
msgid "Positional Parameters"
msgstr "Позиционные параметры"

#: syntax.xml:1330(indexterm)
msgid "<primary>parameter</primary> <secondary>syntax</secondary>"
msgstr "<primary>параметр</primary> <secondary>синтаксис</secondary>"

#: syntax.xml:1335(indexterm)
msgid "<primary>$</primary>"
msgstr "<primary>$</primary>"

#: syntax.xml:1339(para)
msgid ""
"A positional parameter reference is used to indicate a value that is "
"supplied externally to an SQL statement. Parameters are used in SQL function "
"definitions and in prepared queries. Some client libraries also support "
"specifying data values separately from the SQL command string, in which case "
"parameters are used to refer to the out-of-line data values. The form of a "
"parameter reference is: <synopsis>\n"
"$<replaceable>number</replaceable>\n"
"</synopsis>"
msgstr ""
"Ссылка на позиционный параметр применяется для обращения к значению, "
"переданному в SQL-оператор извне. Параметры используются в определениях SQL-"
"функций и подготовленных операторов. Некоторые клиентские библиотеки также "
"поддерживают передачу значений данных отдельно от самой SQL-команды, и в "
"этом случае параметры позволяют ссылаться на такие значения. Ссылка на "
"параметр записывается в следующей форме: <synopsis>\n"
"$<replaceable>число</replaceable>\n"
"</synopsis>"

#: syntax.xml:1356(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION dept(text) RETURNS dept\n"
"    AS $$ SELECT * FROM dept WHERE name = $1 $$\n"
"    LANGUAGE SQL;"
msgstr ""
"CREATE FUNCTION dept(text) RETURNS dept\n"
"    AS $$ SELECT * FROM dept WHERE name = $1 $$\n"
"    LANGUAGE SQL;"

#: syntax.xml:1352(para)
msgid ""
"For example, consider the definition of a function, <function>dept</"
"function>, as: <placeholder-1/> Here the <literal>$1</literal> references "
"the value of the first function argument whenever the function is invoked."
msgstr ""
"Например, рассмотрим следующее определение функции <function>dept</"
"function>: <placeholder-1/> Здесь <literal>$1</literal> всегда будет "
"ссылаться на значение первого аргумента функции."

#: syntax.xml:1368(title)
msgid "Subscripts"
msgstr "Индексы элементов"

#: syntax.xml:1370(indexterm)
msgid "<primary>subscript</primary>"
msgstr "<primary>индекс элемента</primary>"

#: syntax.xml:1374(para)
msgid ""
"If an expression yields a value of an array type, then a specific element of "
"the array value can be extracted by writing <synopsis>\n"
"<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]\n"
"</synopsis> or multiple adjacent elements (an <quote>array slice</quote>) "
"can be extracted by writing <synopsis>\n"
"<replaceable>expression</replaceable>[<replaceable>lower_subscript</"
"replaceable>:<replaceable>upper_subscript</replaceable>]\n"
"</synopsis> (Here, the brackets <literal>[ ]</literal> are meant to appear "
"literally.) Each <replaceable>subscript</replaceable> is itself an "
"expression, which must yield an integer value."
msgstr ""
"Если в выражении вы имеете дело с массивом, то можно извлечь определённый "
"его элемент, написав: <synopsis>\n"
"<replaceable>выражение</replaceable>[<replaceable>индекс</replaceable>]\n"
"</synopsis> или несколько соседних элементов (<quote>срез массива</quote>): "
"<synopsis>\n"
"<replaceable>выражение</replaceable>[<replaceable>нижний_индекс</"
"replaceable>:<replaceable>верхний_индекс</replaceable>]\n"
"</synopsis> (Здесь квадратные скобки <literal>[ ]</literal> должны быть в "
"явном виде.) Каждый <replaceable>индекс</replaceable> сам по себе является "
"выражением, результатом которого должно быть целое число."

#: syntax.xml:1398(programlisting)
#, no-wrap
msgid ""
"mytable.arraycolumn[4]\n"
"mytable.two_d_column[17][34]\n"
"$1[10:42]\n"
"(arrayfunction(a,b))[42]"
msgstr ""
"моя_таблица.столбец_массив[4]\n"
"моя_таблица.столбец_массив_2d[17][34]\n"
"$1[10:42]\n"
"(функция_массив(a,b))[42]"

#: syntax.xml:1390(para)
msgid ""
"In general the array <replaceable>expression</replaceable> must be "
"parenthesized, but the parentheses can be omitted when the expression to be "
"subscripted is just a column reference or positional parameter. Also, "
"multiple subscripts can be concatenated when the original array is "
"multidimensional. For example: <placeholder-1/> The parentheses in the last "
"example are required. See <xref linkend=\"arrays\"/> for more about arrays."
msgstr ""
"В общем случае <replaceable>выражение</replaceable> массива должно "
"заключаться в круглые скобки, но их можно опустить, когда выражение с "
"индексом &mdash; это просто ссылка на столбец или позиционный параметр. "
"Кроме того, можно соединить несколько индексов, если исходный массив "
"многомерный. Например: <placeholder-1/> В последней строке круглые скобки "
"необходимы. Подробнее массивы рассматриваются в <xref remap=\"6\" linkend="
"\"arrays\"/>."

#: syntax.xml:1411(title)
msgid "Field Selection"
msgstr "Выбор поля"

#: syntax.xml:1413(indexterm)
msgid "<primary>field selection</primary>"
msgstr "<primary>выбор поля</primary>"

#: syntax.xml:1417(para)
msgid ""
"If an expression yields a value of a composite type (row type), then a "
"specific field of the row can be extracted by writing <synopsis>\n"
"<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>\n"
"</synopsis>"
msgstr ""
"Если результат выражения &mdash; значение составного типа (строка таблицы), "
"тогда определённое поле этой строки можно извлечь, написав:<synopsis>\n"
"<replaceable>выражение</replaceable>.<replaceable>имя_поля</replaceable>\n"
"</synopsis>"

#: syntax.xml:1431(programlisting)
#, no-wrap
msgid ""
"mytable.mycolumn\n"
"$1.somecolumn\n"
"(rowfunction(a,b)).col3"
msgstr ""
"моя_таблица.столбец\n"
"$1.столбец\n"
"(функция_кортеж(a,b)).стол3"

#: syntax.xml:1441(programlisting)
#, no-wrap
msgid ""
"(compositecol).somefield\n"
"(mytable.compositecol).somefield"
msgstr ""
"(составной_столбец).поле\n"
"(моя_таблица.составной_столбец).поле"

#: syntax.xml:1425(para)
msgid ""
"In general the row <replaceable>expression</replaceable> must be "
"parenthesized, but the parentheses can be omitted when the expression to be "
"selected from is just a table reference or positional parameter. For "
"example: <placeholder-1/> (Thus, a qualified column reference is actually "
"just a special case of the field selection syntax.) An important special "
"case is extracting a field from a table column that is of a composite type: "
"<placeholder-2/> The parentheses are required here to show that "
"<structfield>compositecol</structfield> is a column name not a table name, "
"or that <structname>mytable</structname> is a table name not a schema name "
"in the second case."
msgstr ""
"В общем случае <replaceable>выражение</replaceable> такого типа должно "
"заключаться в круглые скобки, но их можно опустить, когда это ссылка на "
"таблицу или позиционный параметр. Например: <placeholder-1/> (Таким образом, "
"полная ссылка на столбец &mdash; это просто частный случай выбора поля.) "
"Важный особый случай здесь &mdash; извлечение поля из столбца составного "
"типа: <placeholder-2/> Здесь скобки нужны, чтобы показать, что "
"<structfield>составной_столбец</structfield> &mdash; это имя столбца, а не "
"таблицы, и что <structname>моя_таблица</structname> &mdash; имя таблицы, а "
"не схемы."

#: syntax.xml:1455(programlisting)
#, no-wrap
msgid "(compositecol).*"
msgstr "(составной_столбец).*"

#: syntax.xml:1452(para)
msgid ""
"You can ask for all fields of a composite value by writing <literal>.*</"
"literal>: <placeholder-1/> This notation behaves differently depending on "
"context; see <xref linkend=\"rowtypes-usage\"/> for details."
msgstr ""
"Вы можете запросить все поля составного значения, написав <literal>.*</"
"literal>: <placeholder-1/> Эта запись действует по-разному в зависимости от "
"контекста; подробнее об этом говорится в <xref remap=\"6\" linkend="
"\"rowtypes-usage\"/>."

#: syntax.xml:1464(title)
msgid "Operator Invocations"
msgstr "Применение оператора"

#: syntax.xml:1466(indexterm)
msgid "<primary>operator</primary> <secondary>invocation</secondary>"
msgstr "<primary>оператор</primary> <secondary>вызов</secondary>"

#: syntax.xml:1474(replaceable) syntax.xml:1475(replaceable)
#: syntax.xml:1476(replaceable)
msgid "expression"
msgstr "выражение"

#: syntax.xml:1474(replaceable) syntax.xml:1475(replaceable)
#: syntax.xml:1476(replaceable)
msgid "operator"
msgstr "оператор"

#: syntax.xml:1474(member)
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> (binary infix operator)"
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> (бинарный инфиксный "
"оператор)"

#: syntax.xml:1475(member)
msgid "<placeholder-1/> <placeholder-2/> (unary prefix operator)"
msgstr "<placeholder-1/> <placeholder-2/> (унарный префиксный оператор)"

#: syntax.xml:1476(member)
msgid "<placeholder-1/> <placeholder-2/> (unary postfix operator)"
msgstr "<placeholder-1/> <placeholder-2/> (унарный постфиксный оператор)"

#: syntax.xml:1471(para)
msgid ""
"There are three possible syntaxes for an operator invocation: <placeholder-1/"
"> where the <replaceable>operator</replaceable> token follows the syntax "
"rules of <xref linkend=\"sql-syntax-operators\"/>, or is one of the key "
"words <token>AND</token>, <token>OR</token>, and <token>NOT</token>, or is a "
"qualified operator name in the form: <synopsis>\n"
"<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</"
"literal><replaceable>operatorname</replaceable><literal>)</literal>\n"
"</synopsis> Which particular operators exist and whether they are unary or "
"binary depends on what operators have been defined by the system or the "
"user. <xref linkend=\"functions\"/> describes the built-in operators."
msgstr ""
"Существуют три возможных синтаксиса применения операторов: <placeholder-1/"
">где <replaceable>оператор</replaceable> соответствует синтаксическим "
"правилам, описанным в <xref remap=\"6\" linkend=\"sql-syntax-operators\"/>, "
"либо это одно из ключевых слов <token>AND</token>, <token>OR</token> и "
"<token>NOT</token>, либо полное имя оператора в форме: <synopsis>\n"
"<literal>OPERATOR(</literal><replaceable>схема</replaceable><literal>.</"
"literal><replaceable>имя_оператора</replaceable><literal>)</literal>\n"
"</synopsis> Существование конкретных операторов и их тип (унарный или "
"бинарный) зависит от того, как и какие операторы определены системой и "
"пользователем. Встроенные операторы описаны в <xref remap=\"6\" linkend="
"\"functions\"/>."

#: syntax.xml:1493(title)
msgid "Function Calls"
msgstr "Вызовы функций"

#: syntax.xml:1495(indexterm)
msgid "<primary>function</primary> <secondary>invocation</secondary>"
msgstr "<primary>функция</primary> <secondary>вызов</secondary>"

#: syntax.xml:1500(para)
msgid ""
"The syntax for a function call is the name of a function (possibly qualified "
"with a schema name), followed by its argument list enclosed in parentheses: "
"<synopsis>\n"
"<replaceable>function_name</replaceable> (<optional><replaceable>expression</"
"replaceable> <optional>, <replaceable>expression</replaceable> ... </"
"optional></optional> )\n"
"</synopsis>"
msgstr ""
"Вызов функции записывается просто как имя функции (возможно, дополненное "
"именем схемы) и список аргументов в скобках: <synopsis>\n"
"<replaceable>имя_функции</replaceable> (<optional><replaceable>выражение</"
"replaceable> <optional>, <replaceable>выражение</replaceable> ... </"
"optional></optional>)\n"
"</synopsis>"

#: syntax.xml:1512(programlisting)
#, no-wrap
msgid "sqrt(2)"
msgstr "sqrt(2)"

#: syntax.xml:1510(para)
msgid ""
"For example, the following computes the square root of 2: <placeholder-1/>"
msgstr "Например, так вычисляется квадратный корень из 2: <placeholder-1/>"

#: syntax.xml:1517(para)
msgid ""
"The list of built-in functions is in <xref linkend=\"functions\"/>. Other "
"functions can be added by the user."
msgstr ""
"Список встроенных функций приведён в <xref remap=\"6\" linkend=\"functions\"/"
">. Пользователь также может определить и другие функции."

#: syntax.xml:1522(para)
msgid ""
"The arguments can optionally have names attached. See <xref linkend=\"sql-"
"syntax-calling-funcs\"/> for details."
msgstr ""
"Аргументам могут быть присвоены необязательные имена. Подробнее об этом см. "
"<xref remap=\"4\" linkend=\"sql-syntax-calling-funcs\"/>."

#: syntax.xml:1528(para)
msgid ""
"A function that takes a single argument of composite type can optionally be "
"called using field-selection syntax, and conversely field selection can be "
"written in functional style. That is, the notations <literal>col(table)</"
"literal> and <literal>table.col</literal> are interchangeable. This behavior "
"is not SQL-standard but is provided in <productname>PostgreSQL</productname> "
"because it allows use of functions to emulate <quote>computed fields</"
"quote>. For more information see <xref linkend=\"rowtypes-usage\"/>."
msgstr ""
"Функцию, принимающую один аргумент составного типа, можно также вызывать, "
"используя синтаксис выбора поля, и наоборот, выбор поля можно записать в "
"функциональном стиле. То есть записи <literal>col(table)</literal> и "
"<literal>table.col</literal> равносильны и взаимозаменяемы. Это поведение не "
"оговорено стандартом SQL, но реализовано в <productname>PostgreSQL</"
"productname>, так как это позволяет использовать функции для эмуляции "
"<quote>вычисляемых полей</quote>. Подробнее это описано в <xref remap=\"6\" "
"linkend=\"rowtypes-usage\"/>."

#: syntax.xml:1542(title)
msgid "Aggregate Expressions"
msgstr "Агрегатные выражения"

#: syntax.xml:1544(indexterm)
msgid "<primary>aggregate function</primary> <secondary>invocation</secondary>"
msgstr "<primary>агрегатная функция</primary> <secondary>вызов</secondary>"

#: syntax.xml:1549(indexterm)
msgid "<primary>ordered-set aggregate</primary>"
msgstr "<primary>сортирующая агрегатная функция</primary>"

#: syntax.xml:1553(indexterm)
msgid "<primary>WITHIN GROUP</primary>"
msgstr "<primary>WITHIN GROUP</primary>"

#: syntax.xml:1557(indexterm)
msgid "<primary>FILTER</primary>"
msgstr "<primary>FILTER</primary>"

#: syntax.xml:1561(para)
msgid ""
"An <firstterm>aggregate expression</firstterm> represents the application of "
"an aggregate function across the rows selected by a query. An aggregate "
"function reduces multiple inputs to a single output value, such as the sum "
"or average of the inputs. The syntax of an aggregate expression is one of "
"the following: <synopsis>\n"
"<replaceable>aggregate_name</replaceable> (<replaceable>expression</"
"replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) "
"[ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]\n"
"<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</"
"replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) "
"[ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]\n"
"<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</"
"replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) "
"[ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]\n"
"<replaceable>aggregate_name</replaceable> ( * ) [ FILTER ( WHERE "
"<replaceable>filter_clause</replaceable> ) ]\n"
"<replaceable>aggregate_name</replaceable> ( [ <replaceable>expression</"
"replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>order_by_clause</"
"replaceable> ) [ FILTER ( WHERE <replaceable>filter_clause</"
"replaceable> ) ]\n"
"</synopsis> where <replaceable>aggregate_name</replaceable> is a previously "
"defined aggregate (possibly qualified with a schema name) and "
"<replaceable>expression</replaceable> is any value expression that does not "
"itself contain an aggregate expression or a window function call. The "
"optional <replaceable>order_by_clause</replaceable> and "
"<replaceable>filter_clause</replaceable> are described below."
msgstr ""
"<firstterm>Агрегатное выражение</firstterm> представляет собой применение "
"агрегатной функции к строкам, выбранным запросом. Агрегатная функция сводит "
"множество входных значений к одному выходному, как например, сумма или "
"среднее. Агрегатное выражение может записываться следующим образом: "
"<synopsis>\n"
"<replaceable>агрегатная_функция</replaceable> (<replaceable>выражение</"
"replaceable> [ , ... ] [ <replaceable>предложение_order_by</replaceable> ] ) "
"[ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ]\n"
"<replaceable>агрегатная_функция</replaceable> (ALL <replaceable>выражение</"
"replaceable> [ , ... ] [ <replaceable>предложение_order_by</replaceable> ] ) "
"[ FILTER ( WHERE <replaceable>условие_фильтра</replaceable> ) ]\n"
"<replaceable>агрегатная_функция</replaceable> (DISTINCT "
"<replaceable>выражение</replaceable> [ , ... ] "
"[ <replaceable>предложение_order_by</replaceable> ] ) [ FILTER ( WHERE "
"<replaceable>условие_фильтра</replaceable> ) ]\n"
"<replaceable>агрегатная_функция</replaceable> ( * ) [ FILTER ( WHERE "
"<replaceable>условие_фильтра</replaceable> ) ]\n"
"<replaceable>агрегатная_функция</replaceable> ( [ <replaceable>выражение</"
"replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>предложение_order_by</"
"replaceable> ) [ FILTER ( WHERE <replaceable>условие_фильтра</"
"replaceable> ) ]\n"
"</synopsis> Здесь <replaceable>агрегатная_функция</replaceable> &mdash; имя "
"ранее определённой агрегатной функции (возможно, дополненное именем схемы), "
"<replaceable>выражение</replaceable> &mdash; любое выражение значения, не "
"содержащее в себе агрегатного выражения или вызова оконной функции. "
"Необязательные предложения <replaceable>предложение_order_by</replaceable> и "
"<replaceable>условие_фильтра</replaceable> описываются ниже."

#: syntax.xml:1585(para)
msgid ""
"The first form of aggregate expression invokes the aggregate once for each "
"input row. The second form is the same as the first, since <literal>ALL</"
"literal> is the default. The third form invokes the aggregate once for each "
"distinct value of the expression (or distinct set of values, for multiple "
"expressions) found in the input rows. The fourth form invokes the aggregate "
"once for each input row; since no particular input value is specified, it is "
"generally only useful for the <function>count(*)</function> aggregate "
"function. The last form is used with <firstterm>ordered-set</firstterm> "
"aggregate functions, which are described below."
msgstr ""
"В первой форме агрегатного выражения агрегатная функция вызывается для "
"каждой строки. Вторая форма эквивалентна первой, так как указание "
"<literal>ALL</literal> подразумевается по умолчанию. В третьей форме "
"агрегатная функция вызывается для всех различных значений выражения (или "
"набора различных значений, для нескольких выражений), выделенных во входных "
"данных. В четвёртой форме агрегатная функция вызывается для каждой строки, "
"так как никакого конкретного значения не указано (обычно это имеет смысл "
"только для функции <function>count(*)</function>). В последней форме "
"используются <firstterm>сортирующие</firstterm> агрегатные функции, которые "
"будут описаны ниже."

#: syntax.xml:1600(para)
msgid ""
"Most aggregate functions ignore null inputs, so that rows in which one or "
"more of the expression(s) yield null are discarded. This can be assumed to "
"be true, unless otherwise specified, for all built-in aggregates."
msgstr ""
"Большинство агрегатных функций игнорируют значения NULL, так что строки, для "
"которых выражения выдают одно или несколько значений NULL, отбрасываются. "
"Это можно считать истинным для всех встроенных операторов, если явно не "
"говорится об обратном."

#: syntax.xml:1607(para)
msgid ""
"For example, <literal>count(*)</literal> yields the total number of input "
"rows; <literal>count(f1)</literal> yields the number of input rows in which "
"<literal>f1</literal> is non-null, since <function>count</function> ignores "
"nulls; and <literal>count(distinct f1)</literal> yields the number of "
"distinct non-null values of <literal>f1</literal>."
msgstr ""
"Например, <literal>count(*)</literal> подсчитает общее количество строк, а "
"<literal>count(f1)</literal> только количество строк, в которых <literal>f1</"
"literal> не NULL (так как <function>count</function> игнорирует NULL), а "
"<literal>count(distinct f1)</literal> подсчитает число различных и отличных "
"от NULL значений столбца <literal>f1</literal>."

#: syntax.xml:1629(programlisting)
#, no-wrap
msgid "SELECT array_agg(a ORDER BY b DESC) FROM table;"
msgstr "SELECT array_agg(a ORDER BY b DESC) FROM table;"

#: syntax.xml:1616(para)
msgid ""
"Ordinarily, the input rows are fed to the aggregate function in an "
"unspecified order. In many cases this does not matter; for example, "
"<function>min</function> produces the same result no matter what order it "
"receives the inputs in. However, some aggregate functions (such as "
"<function>array_agg</function> and <function>string_agg</function>) produce "
"results that depend on the ordering of the input rows. When using such an "
"aggregate, the optional <replaceable>order_by_clause</replaceable> can be "
"used to specify the desired ordering. The <replaceable>order_by_clause</"
"replaceable> has the same syntax as for a query-level <literal>ORDER BY</"
"literal> clause, as described in <xref linkend=\"queries-order\"/>, except "
"that its expressions are always just expressions and cannot be output-column "
"names or numbers. For example: <placeholder-1/>"
msgstr ""
"Обычно строки данных передаются агрегатной функции в неопределённом порядке "
"и во многих случаях это не имеет значения, например функция <function>min</"
"function> выдаёт один и тот же результат независимо от порядка поступающих "
"данных. Однако некоторые агрегатные функции (такие как <function>array_agg</"
"function> и <function>string_agg</function>) выдают результаты, зависящие от "
"порядка данных. Для таких агрегатных функций можно добавить "
"<replaceable>предложение_order_by</replaceable> и задать нужный порядок. Это "
"<replaceable>предложение_order_by</replaceable> имеет тот же синтаксис, что "
"и предложение <literal>ORDER BY</literal> на уровне запроса, как описано в "
"<xref remap=\"6\" linkend=\"queries-order\"/>, за исключением того, что его "
"выражения должны быть просто выражениями, а не именами результирующих "
"столбцов или числами. Например: <placeholder-1/>"

#: syntax.xml:1638(programlisting)
#, no-wrap
msgid "SELECT string_agg(a, ',' ORDER BY a) FROM table;"
msgstr "SELECT string_agg(a, ',' ORDER BY a) FROM table;"

#: syntax.xml:1642(programlisting)
#, no-wrap
msgid "SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect"
msgstr "SELECT string_agg(a ORDER BY a, ',') FROM table;  -- неправильно"

#: syntax.xml:1634(para)
msgid ""
"When dealing with multiple-argument aggregate functions, note that the "
"<literal>ORDER BY</literal> clause goes after all the aggregate arguments. "
"For example, write this: <placeholder-1/> not this: <placeholder-2/> The "
"latter is syntactically valid, but it represents a call of a single-argument "
"aggregate function with two <literal>ORDER BY</literal> keys (the second one "
"being rather useless since it's a constant)."
msgstr ""
"Заметьте, что при использовании агрегатных функций с несколькими "
"аргументами, предложение <literal>ORDER BY</literal> идёт после всех "
"аргументов. Например, надо писать так: <placeholder-1/> а не так: "
"<placeholder-2/> Последний вариант синтаксически допустим, но он "
"представляет собой вызов агрегатной функции одного аргумента с двумя ключами "
"<literal>ORDER BY</literal> (при этом второй не имеет смысла, так как это "
"константа)."

#: syntax.xml:1650(para)
msgid ""
"If <literal>DISTINCT</literal> is specified in addition to an "
"<replaceable>order_by_clause</replaceable>, then all the <literal>ORDER BY</"
"literal> expressions must match regular arguments of the aggregate; that is, "
"you cannot sort on an expression that is not included in the "
"<literal>DISTINCT</literal> list."
msgstr ""
"Если <replaceable>предложение_order_by</replaceable> дополнено указанием "
"<literal>DISTINCT</literal>, тогда все выражения <literal>ORDER BY</literal> "
"должны соответствовать обычным аргументам агрегатной функции; то есть вы не "
"можете сортировать строки по выражению, не включённому в список "
"<literal>DISTINCT</literal>."

#: syntax.xml:1659(para)
msgid ""
"The ability to specify both <literal>DISTINCT</literal> and <literal>ORDER "
"BY</literal> in an aggregate function is a <productname>PostgreSQL</"
"productname> extension."
msgstr ""
"Возможность указывать и <literal>DISTINCT</literal>, и <literal>ORDER BY</"
"literal> в агрегатной функции &mdash; это расширение "
"<productname>PostgreSQL</productname>."

#: syntax.xml:1665(para)
msgid ""
"Placing <literal>ORDER BY</literal> within the aggregate's regular argument "
"list, as described so far, is used when ordering the input rows for a "
"<quote>normal</quote> aggregate for which ordering is optional. There is a "
"subclass of aggregate functions called <firstterm>ordered-set aggregates</"
"firstterm> for which an <replaceable>order_by_clause</replaceable> is "
"<emphasis>required</emphasis>, usually because the aggregate's computation "
"is only sensible in terms of a specific ordering of its input rows. Typical "
"examples of ordered-set aggregates include rank and percentile calculations. "
"For an ordered-set aggregate, the <replaceable>order_by_clause</replaceable> "
"is written inside <literal>WITHIN GROUP (...)</literal>, as shown in the "
"final syntax alternative above. The expressions in the "
"<replaceable>order_by_clause</replaceable> are evaluated once per input row "
"just like normal aggregate arguments, sorted as per the "
"<replaceable>order_by_clause</replaceable>'s requirements, and fed to the "
"aggregate function as input arguments. (This is unlike the case for a non-"
"<literal>WITHIN GROUP</literal> <replaceable>order_by_clause</replaceable>, "
"which is not treated as argument(s) to the aggregate function.) The argument "
"expressions preceding <literal>WITHIN GROUP</literal>, if any, are called "
"<firstterm>direct arguments</firstterm> to distinguish them from the "
"<firstterm>aggregated arguments</firstterm> listed in the "
"<replaceable>order_by_clause</replaceable>. Unlike normal aggregate "
"arguments, direct arguments are evaluated only once per aggregate call, not "
"once per input row. This means that they can contain variables only if those "
"variables are grouped by <literal>GROUP BY</literal>; this restriction is "
"the same as if the direct arguments were not inside an aggregate expression "
"at all. Direct arguments are typically used for things like percentile "
"fractions, which only make sense as a single value per aggregation "
"calculation. The direct argument list can be empty; in this case, write just "
"<literal>()</literal> not <literal>(*)</literal>. (<productname>PostgreSQL</"
"productname> will actually accept either spelling, but only the first way "
"conforms to the SQL standard.)"
msgstr ""
"При добавлении <literal>ORDER BY</literal> в обычный список аргументов "
"агрегатной функции, описанном до этого, выполняется сортировка строк для "
"<quote>обычной</quote> агрегатной функции, для которой сортировка "
"необязательна. Но есть подмножество агрегатных функций, "
"<firstterm>сортирующие агрегатные функции</firstterm>, для которых "
"<replaceable>предложение_order</replaceable> является "
"<emphasis>обязательным</emphasis>, обычно потому, что вычисление этой "
"функции имеет смысл только при определённой сортировке входных строк. "
"Типичными примерами сортирующих агрегатных функций являются вычисления ранга "
"и процентиля. Для сортирующей агрегатной функции "
"<replaceable>предложение_order_by</replaceable> записывается внутри "
"<literal>WITHIN GROUP (...)</literal>, что иллюстрирует последний пример, "
"приведённый выше. Выражения в <replaceable>предложении_order_by</"
"replaceable> вычисляются однократно для каждой входной строки как аргументы "
"обычной агрегатной функции, сортируемые в соответствии с требованием "
"<replaceable>предложения_order_by</replaceable>, и поступают в агрегатную "
"функции как входящие аргументы. (Если же <replaceable>предложение_order_by</"
"replaceable> находится не в <literal>WITHIN GROUP</literal>, оно не "
"передаётся как аргумент(ы) агрегатной функции.) Выражения-аргументы, "
"предшествующие <literal>WITHIN GROUP</literal>, (если они есть), называются "
"<firstterm>непосредственными аргументами</firstterm>, а выражения, указанные "
"в <replaceable>предложении_order_by</replaceable> &mdash; "
"<firstterm>агрегируемыми аргументами</firstterm>. В отличие от аргументов "
"обычной агрегатной функции, непосредственные аргументы вычисляются "
"однократно для каждого вызова функции, а не для каждой строки. Это значит, "
"что они могут содержать переменные, только если эти переменные сгруппированы "
"в <literal>GROUP BY</literal>; это суть то же ограничение, что действовало "
"бы, будь эти непосредственные аргументы вне агрегатного выражения. "
"Непосредственные аргументы обычно используются, например, для указания "
"значения процентиля, которое имеет смысл, только если это конкретное число "
"для всего расчёта агрегатной функции. Список непосредственных аргументов "
"может быть пуст; в этом случае запишите просто <literal>()</literal>, но не "
"<literal>(*)</literal>. (На самом деле <productname>PostgreSQL</productname> "
"примет обе записи, но только первая соответствует стандарту SQL.)"

#: syntax.xml:1701(indexterm)
msgid "<primary>median</primary>"
msgstr "<primary>медиана</primary>"

#: syntax.xml:1704(indexterm)
msgid "<primary>median</primary> <seealso>percentile</seealso>"
msgstr "<primary>медиана</primary> <seealso>процентиль</seealso>"

#: syntax.xml:1710(programlisting)
#, no-wrap
msgid ""
"SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;\n"
" percentile_cont\n"
"-----------------\n"
"           50489"
msgstr ""
"SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;\n"
" percentile_cont\n"
"-----------------\n"
"           50489"

#: syntax.xml:1700(para)
msgid ""
"<placeholder-1/> <placeholder-2/> An example of an ordered-set aggregate "
"call is: <placeholder-3/> which obtains the 50th percentile, or median, "
"value of the <structfield>income</structfield> column from table "
"<structname>households</structname>. Here, <literal>0.5</literal> is a "
"direct argument; it would make no sense for the percentile fraction to be a "
"value varying across rows."
msgstr ""
"<placeholder-1/> <placeholder-2/> Пример вызова сортирующей агрегатной "
"функции: <placeholder-3/> она получает 50-ый процентиль, или медиану, "
"значения столбца <structfield>income</structfield> из таблицы "
"<structname>households</structname>. В данном случае, <literal>0.5</literal> "
"— это непосредственный аргумент; если бы дробь процентиля менялась от строки "
"к строке, это не имело бы смысла."

#: syntax.xml:1728(programlisting)
#, no-wrap
msgid ""
"SELECT\n"
"    count(*) AS unfiltered,\n"
"    count(*) FILTER (WHERE i &lt; 5) AS filtered\n"
"FROM generate_series(1,10) AS s(i);\n"
" unfiltered | filtered\n"
"------------+----------\n"
"         10 |        4\n"
"(1 row)"
msgstr ""
"SELECT\n"
"    count(*) AS unfiltered,\n"
"    count(*) FILTER (WHERE i &lt; 5) AS filtered\n"
"FROM generate_series(1,10) AS s(i);\n"
" unfiltered | filtered\n"
"------------+----------\n"
"         10 |        4\n"
"(1 row)"

#: syntax.xml:1723(para)
msgid ""
"If <literal>FILTER</literal> is specified, then only the input rows for "
"which the <replaceable>filter_clause</replaceable> evaluates to true are fed "
"to the aggregate function; other rows are discarded. For example: "
"<placeholder-1/>"
msgstr ""
"Если добавлено предложение <literal>FILTER</literal>, агрегатной функции "
"подаются только те входные строки, для которых <replaceable>условие_фильтра</"
"replaceable> вычисляется как истинное; другие строки отбрасываются. "
"Например: <placeholder-1/>"

#: syntax.xml:1740(para)
msgid ""
"The predefined aggregate functions are described in <xref linkend="
"\"functions-aggregate\"/>. Other aggregate functions can be added by the "
"user."
msgstr ""
"Предопределённые агрегатные функции описаны в <xref remap=\"6\" linkend="
"\"functions-aggregate\"/>. Пользователь также может определить другие "
"агрегатные функции."

#: syntax.xml:1746(para)
msgid ""
"An aggregate expression can only appear in the result list or "
"<literal>HAVING</literal> clause of a <command>SELECT</command> command. It "
"is forbidden in other clauses, such as <literal>WHERE</literal>, because "
"those clauses are logically evaluated before the results of aggregates are "
"formed."
msgstr ""
"Агрегатное выражение может фигурировать только в списке результатов или в "
"предложении <literal>HAVING</literal> команды <command>SELECT</command>. Во "
"всех остальных предложениях, например <literal>WHERE</literal>, они "
"запрещены, так как эти предложения логически вычисляются до того, как "
"формируются результаты агрегатных функций."

#: syntax.xml:1754(para)
msgid ""
"When an aggregate expression appears in a subquery (see <xref linkend=\"sql-"
"syntax-scalar-subqueries\"/> and <xref linkend=\"functions-subquery\"/>), "
"the aggregate is normally evaluated over the rows of the subquery. But an "
"exception occurs if the aggregate's arguments (and "
"<replaceable>filter_clause</replaceable> if any) contain only outer-level "
"variables: the aggregate then belongs to the nearest such outer level, and "
"is evaluated over the rows of that query. The aggregate expression as a "
"whole is then an outer reference for the subquery it appears in, and acts as "
"a constant over any one evaluation of that subquery. The restriction about "
"appearing only in the result list or <literal>HAVING</literal> clause "
"applies with respect to the query level that the aggregate belongs to."
msgstr ""
"Когда агрегатное выражение используется в подзапросе (см. <xref remap=\"4\" "
"linkend=\"sql-syntax-scalar-subqueries\"/> и <xref remap=\"4\" linkend="
"\"functions-subquery\"/>), оно обычно вычисляется для всех строк подзапроса. "
"Но если в аргументах (или в <replaceable>условии_filter</replaceable>) "
"агрегатной функции есть только переменные внешнего уровня, агрегатная "
"функция относится к ближайшему внешнему уровню и вычисляется для всех строк "
"соответствующего запроса. Такое агрегатное выражение в целом является "
"внешней ссылкой для своего подзапроса и на каждом вычислении считается "
"константой. При этом допустимое положение агрегатной функции ограничивается "
"списком результатов и предложением <literal>HAVING</literal> на том уровне "
"запросов, где она находится."

#: syntax.xml:1772(title)
msgid "Window Function Calls"
msgstr "Вызовы оконных функций"

#: syntax.xml:1774(indexterm)
msgid "<primary>window function</primary> <secondary>invocation</secondary>"
msgstr "<primary>оконная функция</primary> <secondary>вызов</secondary>"

#: syntax.xml:1779(indexterm)
msgid "<primary>OVER clause</primary>"
msgstr "<primary>предложение OVER</primary>"

#: syntax.xml:1783(para)
msgid ""
"A <firstterm>window function call</firstterm> represents the application of "
"an aggregate-like function over some portion of the rows selected by a "
"query. Unlike regular aggregate function calls, this is not tied to grouping "
"of the selected rows into a single output row &mdash; each row remains "
"separate in the query output. However the window function is able to scan "
"all the rows that would be part of the current row's group according to the "
"grouping specification (<literal>PARTITION BY</literal> list) of the window "
"function call. The syntax of a window function call is one of the following: "
"<synopsis>\n"
"<replaceable>function_name</replaceable> (<optional><replaceable>expression</"
"replaceable> <optional>, <replaceable>expression</replaceable> ... </"
"optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</"
"replaceable> ) ] OVER <replaceable>window_name</replaceable>\n"
"<replaceable>function_name</replaceable> (<optional><replaceable>expression</"
"replaceable> <optional>, <replaceable>expression</replaceable> ... </"
"optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</"
"replaceable> ) ] OVER ( <replaceable class=\"parameter\">window_definition</"
"replaceable> )\n"
"<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE "
"<replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</"
"replaceable>\n"
"<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE "
"<replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="
"\"parameter\">window_definition</replaceable> )\n"
"</synopsis> where <replaceable class=\"parameter\">window_definition</"
"replaceable> has the syntax <synopsis>\n"
"[ <replaceable class=\"parameter\">existing_window_name</replaceable> ]\n"
"[ PARTITION BY <replaceable class=\"parameter\">expression</replaceable> "
"[, ...] ]\n"
"[ ORDER BY <replaceable class=\"parameter\">expression</replaceable> [ ASC | "
"DESC | USING <replaceable class=\"parameter\">operator</replaceable> ] "
"[ NULLS { FIRST | LAST } ] [, ...] ]\n"
"[ <replaceable class=\"parameter\">frame_clause</replaceable> ]\n"
"</synopsis> and the optional <replaceable class=\"parameter\">frame_clause</"
"replaceable> can be one of <synopsis>\n"
"{ RANGE | ROWS } <replaceable>frame_start</replaceable>\n"
"{ RANGE | ROWS } BETWEEN <replaceable>frame_start</replaceable> AND "
"<replaceable>frame_end</replaceable>\n"
"</synopsis> where <replaceable>frame_start</replaceable> and "
"<replaceable>frame_end</replaceable> can be one of <synopsis>\n"
"UNBOUNDED PRECEDING\n"
"<replaceable>value</replaceable> PRECEDING\n"
"CURRENT ROW\n"
"<replaceable>value</replaceable> FOLLOWING\n"
"UNBOUNDED FOLLOWING\n"
"</synopsis>"
msgstr ""
"<firstterm>Вызов оконной функции</firstterm> представляет собой применение "
"функции, подобной агрегатной, к некоторому набору строк, выбранному "
"запросом. В отличие от обычных агрегатных функций, оконные функции не "
"связаны с группировкой выбранных строк в одну &mdash; каждая строка остаётся "
"отдельной в результате запроса. Однако оконная функция может просканировать "
"все строки, вошедшие в группу текущей строки согласно указанию (списку "
"<literal>PARTITION BY</literal>) при вызове оконной функции. Вызов оконной "
"функции может иметь следующие формы: <synopsis>\n"
"<replaceable>имя_функции</replaceable> (<optional><replaceable>выражение</"
"replaceable> <optional>, <replaceable>выражение</replaceable> ... </"
"optional></optional>) [ FILTER ( WHERE <replaceable>условие_фильтра</"
"replaceable> ) ] OVER <replaceable>имя_окна</replaceable>\n"
"<replaceable>имя_функции</replaceable> (<optional><replaceable>выражение</"
"replaceable> <optional>, <replaceable>выражение</replaceable> ... </"
"optional></optional>) [ FILTER ( WHERE <replaceable>условие_фильтра</"
"replaceable> ) ] OVER ( <replaceable class=\"parameter\">определение_окна</"
"replaceable> )\n"
"<replaceable>имя_функции</replaceable> ( * ) [ FILTER ( WHERE "
"<replaceable>условие_фильтра</replaceable> ) ] OVER <replaceable>имя_окна</"
"replaceable>\n"
"<replaceable>имя_функции</replaceable> ( * ) [ FILTER ( WHERE "
"<replaceable>условие_фильтра</replaceable> ) ] OVER ( <replaceable class="
"\"parameter\">определение_окна</replaceable> )\n"
"</synopsis> Здесь <replaceable class=\"parameter\">определение_окна</"
"replaceable> записывается в виде: <synopsis>\n"
"[ <replaceable class=\"parameter\">имя_существующего_окна</replaceable> ]\n"
"[ PARTITION BY <replaceable class=\"parameter\">выражение</replaceable> "
"[, ...] ]\n"
"[ ORDER BY <replaceable class=\"parameter\">выражение</replaceable> [ ASC | "
"DESC | USING <replaceable class=\"parameter\">оператор</replaceable> ] "
"[ NULLS { FIRST | LAST } ] [, ...] ]\n"
"[ <replaceable class=\"parameter\">определение_рамки</replaceable> ]\n"
"</synopsis> и необязательное <replaceable class=\"parameter"
"\">определение_рамки</replaceable> может иметь вид: <synopsis>\n"
"{ RANGE | ROWS } <replaceable>начало_рамки</replaceable>\n"
"{ RANGE | ROWS } BETWEEN <replaceable>начало_рамки</replaceable> AND "
"<replaceable>конец_рамки</replaceable>\n"
"</synopsis> Здесь <replaceable>начало_рамки</replaceable> и "
"<replaceable>конец_рамки</replaceable> задаются одним из следующих способов: "
"<synopsis>\n"
"UNBOUNDED PRECEDING\n"
"<replaceable>значение</replaceable> PRECEDING\n"
"CURRENT ROW\n"
"<replaceable>значение</replaceable> FOLLOWING\n"
"UNBOUNDED FOLLOWING\n"
"</synopsis>"

#: syntax.xml:1825(para)
msgid ""
"Here, <replaceable>expression</replaceable> represents any value expression "
"that does not itself contain window function calls."
msgstr ""
"Здесь <replaceable>выражение</replaceable> &mdash; это любое выражение "
"значения, не содержащее вызовов оконных функций."

#: syntax.xml:1830(para)
msgid ""
"<replaceable>window_name</replaceable> is a reference to a named window "
"specification defined in the query's <literal>WINDOW</literal> clause. "
"Alternatively, a full <replaceable>window_definition</replaceable> can be "
"given within parentheses, using the same syntax as for defining a named "
"window in the <literal>WINDOW</literal> clause; see the <xref linkend=\"sql-"
"select\"/> reference page for details. It's worth pointing out that "
"<literal>OVER wname</literal> is not exactly equivalent to <literal>OVER "
"(wname)</literal>; the latter implies copying and modifying the window "
"definition, and will be rejected if the referenced window specification "
"includes a frame clause."
msgstr ""
"<replaceable>имя_окна</replaceable> &mdash; ссылка на именованное окно, "
"определённое предложением <literal>WINDOW</literal> в данном запросе. Также "
"возможно написать в скобках полное <replaceable>определение_окна</"
"replaceable>, используя тот же синтаксис определения именованного окна в "
"предложении <literal>WINDOW</literal>; подробнее это описано в справке по "
"<xref linkend=\"sql-select\"/>. Стоит отметить, что запись <literal>OVER "
"имя_окна</literal> не полностью равнозначна <literal>OVER (имя_окна)</"
"literal>; последний вариант подразумевает копирование и изменение "
"определения окна и не будет допустимым, если определение этого окна включает "
"определение рамки."

#: syntax.xml:1843(para)
msgid ""
"The <literal>PARTITION BY</literal> option groups the rows of the query into "
"<firstterm>partitions</firstterm>, which are processed separately by the "
"window function. <literal>PARTITION BY</literal> works similarly to a query-"
"level <literal>GROUP BY</literal> clause, except that its expressions are "
"always just expressions and cannot be output-column names or numbers. "
"Without <literal>PARTITION BY</literal>, all rows produced by the query are "
"treated as a single partition. The <literal>ORDER BY</literal> option "
"determines the order in which the rows of a partition are processed by the "
"window function. It works similarly to a query-level <literal>ORDER BY</"
"literal> clause, but likewise cannot use output-column names or numbers. "
"Without <literal>ORDER BY</literal>, rows are processed in an unspecified "
"order."
msgstr ""
"Указание <literal>PARTITION BY</literal> группирует строки запроса в "
"<firstterm>разделы</firstterm>, которые затем обрабатываются оконной "
"функцией независимо друг от друга. <literal>PARTITION BY</literal> работает "
"подобно предложению <literal>GROUP BY</literal> на уровне запроса, за "
"исключением того, что его аргументы всегда просто выражения, а не имена "
"выходных столбцов или числа. Без <literal>PARTITION BY</literal> все строки, "
"выдаваемые запросом, рассматриваются как один раздел. Указание "
"<literal>ORDER BY</literal> определяет порядок, в котором оконная функция "
"обрабатывает строки раздела. Оно так же подобно предложению <literal>ORDER "
"BY</literal> на уровне запроса и так же не принимает имена выходных столбцов "
"или числа. Без <literal>ORDER BY</literal> строки обрабатываются в "
"неопределённом порядке."

#: syntax.xml:1858(para)
msgid ""
"The <replaceable class=\"parameter\">frame_clause</replaceable> specifies "
"the set of rows constituting the <firstterm>window frame</firstterm>, which "
"is a subset of the current partition, for those window functions that act on "
"the frame instead of the whole partition. The frame can be specified in "
"either <literal>RANGE</literal> or <literal>ROWS</literal> mode; in either "
"case, it runs from the <replaceable>frame_start</replaceable> to the "
"<replaceable>frame_end</replaceable>. If <replaceable>frame_end</"
"replaceable> is omitted, it defaults to <literal>CURRENT ROW</literal>."
msgstr ""
"<replaceable class=\"parameter\">определение_рамки</replaceable> задаёт "
"набор строк, образующих <firstterm>рамку окна</firstterm>, которая "
"представляет собой подмножество строк текущего раздела и используется для "
"оконных функций, работающих с рамкой, а не со всем разделом. Рамку можно "
"указать в режимах <literal>RANGE</literal> или <literal>ROWS</literal>; в "
"любом случае она начинается с положения <replaceable>начало_рамки</"
"replaceable> и заканчивается положением <replaceable>конец_рамки</"
"replaceable>. Если <replaceable>конец_рамки</replaceable> опущен, "
"подразумевается <literal>CURRENT ROW</literal> (текущая строка)."

#: syntax.xml:1869(para)
msgid ""
"A <replaceable>frame_start</replaceable> of <literal>UNBOUNDED PRECEDING</"
"literal> means that the frame starts with the first row of the partition, "
"and similarly a <replaceable>frame_end</replaceable> of <literal>UNBOUNDED "
"FOLLOWING</literal> means that the frame ends with the last row of the "
"partition."
msgstr ""
"Если <replaceable>начало_рамки</replaceable> задано как <literal>UNBOUNDED "
"PRECEDING</literal>, рамка начинается с первой строки раздела, а если "
"<replaceable>конец_рамки</replaceable> определён как <literal>UNBOUNDED "
"FOLLOWING</literal>, рамка заканчивается последней строкой раздела."

#: syntax.xml:1876(para)
msgid ""
"In <literal>RANGE</literal> mode, a <replaceable>frame_start</replaceable> "
"of <literal>CURRENT ROW</literal> means the frame starts with the current "
"row's first <firstterm>peer</firstterm> row (a row that <literal>ORDER BY</"
"literal> considers equivalent to the current row), while a "
"<replaceable>frame_end</replaceable> of <literal>CURRENT ROW</literal> means "
"the frame ends with the last equivalent <literal>ORDER BY</literal> peer. In "
"<literal>ROWS</literal> mode, <literal>CURRENT ROW</literal> simply means "
"the current row."
msgstr ""
"В режиме <literal>RANGE</literal> <replaceable>начало_рамки</replaceable>, "
"заданное как <literal>CURRENT ROW</literal>, определяет в качестве начала "
"первую <firstterm>родственную</firstterm> строку (строку, которую "
"<literal>ORDER BY</literal> считает равной текущей), тогда как "
"<replaceable>конец_рамки</replaceable>, заданный как <literal>CURRENT ROW</"
"literal>, определяет концом рамки последнюю родственную (для <literal>ORDER "
"BY</literal>) строку. В режиме <literal>ROWS</literal> вариант "
"<literal>CURRENT ROW</literal> просто обозначает текущую строку."

#: syntax.xml:1886(para)
msgid ""
"The <replaceable>value</replaceable> <literal>PRECEDING</literal> and "
"<replaceable>value</replaceable> <literal>FOLLOWING</literal> cases are "
"currently only allowed in <literal>ROWS</literal> mode. They indicate that "
"the frame starts or ends the specified number of rows before or after the "
"current row. <replaceable>value</replaceable> must be an integer expression "
"not containing any variables, aggregate functions, or window functions. The "
"value must not be null or negative; but it can be zero, which just selects "
"the current row."
msgstr ""
"Варианты <replaceable>значение</replaceable> <literal>PRECEDING</literal> и "
"<replaceable>значение</replaceable> <literal>FOLLOWING</literal> допускаются "
"только в режиме <literal>ROWS</literal>. Они указывают, что рамка начинается "
"или заканчивается со сдвигом на заданное число строк перед или после "
"заданной строки. Здесь <replaceable>значение</replaceable> должно быть "
"целочисленным выражением, не содержащим переменные, агрегатные или оконные "
"функции, и может быть нулевым, что будет означать выбор текущей строки."

#: syntax.xml:1897(para)
msgid ""
"The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>, "
"which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT "
"ROW</literal>. With <literal>ORDER BY</literal>, this sets the frame to be "
"all rows from the partition start up through the current row's last "
"<literal>ORDER BY</literal> peer. Without <literal>ORDER BY</literal>, all "
"rows of the partition are included in the window frame, since all rows "
"become peers of the current row."
msgstr ""
"По умолчанию рамка определяется как <literal>RANGE UNBOUNDED PRECEDING</"
"literal>, что равносильно расширенному определению <literal>RANGE BETWEEN "
"UNBOUNDED PRECEDING AND CURRENT ROW</literal>. С указанием <literal>ORDER "
"BY</literal> это означает, что рамка будет включать все строки от начала "
"раздела до последней строки, родственной текущей (для <literal>ORDER BY</"
"literal>). Без <literal>ORDER BY</literal> в рамку включаются все строки "
"раздела, так как все они считаются родственными текущей."

#: syntax.xml:1907(para)
msgid ""
"Restrictions are that <replaceable>frame_start</replaceable> cannot be "
"<literal>UNBOUNDED FOLLOWING</literal>, <replaceable>frame_end</replaceable> "
"cannot be <literal>UNBOUNDED PRECEDING</literal>, and the "
"<replaceable>frame_end</replaceable> choice cannot appear earlier in the "
"above list than the <replaceable>frame_start</replaceable> choice &mdash; "
"for example <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</"
"replaceable> PRECEDING</literal> is not allowed."
msgstr ""
"Действуют также ограничения: <replaceable>начало_рамки</replaceable> не "
"может определяться как <literal>UNBOUNDED FOLLOWING</literal>, а "
"<replaceable>конец_рамки</replaceable> &mdash; <literal>UNBOUNDED PRECEDING</"
"literal>, и <replaceable>конец_рамки</replaceable> не может определяться "
"раньше, чем <replaceable>начало_рамки</replaceable> &mdash; например, запись "
"<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>значение</replaceable> "
"PRECEDING</literal> недопустима."

#: syntax.xml:1917(para)
msgid ""
"If <literal>FILTER</literal> is specified, then only the input rows for "
"which the <replaceable>filter_clause</replaceable> evaluates to true are fed "
"to the window function; other rows are discarded. Only window functions that "
"are aggregates accept a <literal>FILTER</literal> clause."
msgstr ""
"Если добавлено предложение <literal>FILTER</literal>, оконной функции "
"подаются только те входные строки, для которых <replaceable>условие_фильтра</"
"replaceable> вычисляется как истинное; другие строки отбрасываются. "
"Предложение <literal>FILTER</literal> допускается только для агрегирующих "
"оконных функций."

#: syntax.xml:1925(para)
msgid ""
"The built-in window functions are described in <xref linkend=\"functions-"
"window-table\"/>. Other window functions can be added by the user. Also, any "
"built-in or user-defined normal aggregate function can be used as a window "
"function. Ordered-set aggregates presently cannot be used as window "
"functions, however."
msgstr ""
"Встроенные оконные функции описаны в <xref remap=\"6\" linkend=\"functions-"
"window-table\"/>, но этот набор можно расширить, создавая собственные "
"функции. Кроме того, в качестве оконных функций можно использовать любые "
"встроенные или пользовательские обычные агрегатные функции (сортирующие "
"агрегатные функции использовать в качестве оконных нельзя)."

#: syntax.xml:1933(para)
msgid ""
"The syntaxes using <literal>*</literal> are used for calling parameter-less "
"aggregate functions as window functions, for example <literal>count(*) OVER "
"(PARTITION BY x ORDER BY y)</literal>. The asterisk (<literal>*</literal>) "
"is customarily not used for non-aggregate window functions. Aggregate window "
"functions, unlike normal aggregate functions, do not allow "
"<literal>DISTINCT</literal> or <literal>ORDER BY</literal> to be used within "
"the function argument list."
msgstr ""
"Запись со звёздочкой (<literal>*</literal>) применяется при вызове "
"агрегатных функций в качестве оконных, например <literal>count(*) OVER "
"(PARTITION BY x ORDER BY y)</literal>. Звёздочка (<literal>*</literal>) "
"обычно не применяется для не агрегатных оконных функций. Агрегатные оконные "
"функции, в отличие от обычных агрегатных функций, не допускают использования "
"<literal>DISTINCT</literal> и <literal>ORDER BY</literal> в списке "
"аргументов."

#: syntax.xml:1943(para)
msgid ""
"Window function calls are permitted only in the <literal>SELECT</literal> "
"list and the <literal>ORDER BY</literal> clause of the query."
msgstr ""
"Вызовы оконных функций разрешены в запросах только в списке <literal>SELECT</"
"literal> и в предложении <literal>ORDER BY</literal>."

#: syntax.xml:1948(para)
msgid ""
"More information about window functions can be found in <xref linkend="
"\"tutorial-window\"/>, <xref linkend=\"functions-window\"/>, and <xref "
"linkend=\"queries-window\"/>."
msgstr ""
"Дополнительно об оконных функциях можно узнать в <xref remap=\"6\" linkend="
"\"tutorial-window\"/>, <xref remap=\"6\" linkend=\"functions-window\"/> и "
"<xref remap=\"6\" linkend=\"queries-window\"/>."

#: syntax.xml:1957(title)
msgid "Type Casts"
msgstr "Приведения типов"

#: syntax.xml:1959(indexterm)
msgid "<primary>data type</primary> <secondary>type cast</secondary>"
msgstr "<primary>тип данных</primary> <secondary>приведение типа</secondary>"

#: syntax.xml:1968(indexterm)
msgid "<primary>::</primary>"
msgstr "<primary>::</primary>"

#: syntax.xml:1972(para)
msgid ""
"A type cast specifies a conversion from one data type to another. "
"<productname>PostgreSQL</productname> accepts two equivalent syntaxes for "
"type casts: <synopsis>\n"
"CAST ( <replaceable>expression</replaceable> AS <replaceable>type</"
"replaceable> )\n"
"<replaceable>expression</replaceable>::<replaceable>type</replaceable>\n"
"</synopsis> The <literal>CAST</literal> syntax conforms to SQL; the syntax "
"with <literal>::</literal> is historical <productname>PostgreSQL</"
"productname> usage."
msgstr ""
"Приведение типа определяет преобразование данных из одного типа в другой. "
"<productname>PostgreSQL</productname> воспринимает две равносильные записи "
"приведения типов: <synopsis>\n"
"CAST ( <replaceable>выражение</replaceable> AS <replaceable>тип</"
"replaceable> )\n"
"<replaceable>выражение</replaceable>::<replaceable>тип</replaceable>\n"
"</synopsis> Запись с <literal>CAST</literal> соответствует стандарту SQL, "
"тогда как вариант с <literal>::</literal> &mdash; историческое наследие "
"<productname>PostgreSQL</productname>."

#: syntax.xml:1985(para)
msgid ""
"When a cast is applied to a value expression of a known type, it represents "
"a run-time type conversion. The cast will succeed only if a suitable type "
"conversion operation has been defined. Notice that this is subtly different "
"from the use of casts with constants, as shown in <xref linkend=\"sql-syntax-"
"constants-generic\"/>. A cast applied to an unadorned string literal "
"represents the initial assignment of a type to a literal constant value, and "
"so it will succeed for any type (if the contents of the string literal are "
"acceptable input syntax for the data type)."
msgstr ""
"Когда приведению подвергается значение выражения известного типа, происходит "
"преобразование типа во время выполнения. Это приведение будет успешным, "
"только если определён подходящий оператор преобразования типов. Обратите "
"внимание на небольшое отличие от приведения констант, описанного в <xref "
"remap=\"6\" linkend=\"sql-syntax-constants-generic\"/>. Приведение строки в "
"чистом виде представляет собой начальное присваивание строковой константы и "
"оно будет успешным для любого типа (конечно, если строка содержит значение, "
"приемлемое для данного типа данных)."

#: syntax.xml:1997(para)
msgid ""
"An explicit type cast can usually be omitted if there is no ambiguity as to "
"the type that a value expression must produce (for example, when it is "
"assigned to a table column); the system will automatically apply a type cast "
"in such cases. However, automatic casting is only done for casts that are "
"marked <quote>OK to apply implicitly</quote> in the system catalogs. Other "
"casts must be invoked with explicit casting syntax. This restriction is "
"intended to prevent surprising conversions from being applied silently."
msgstr ""
"Неявное приведение типа можно опустить, если возможно однозначно определить, "
"какой тип должно иметь выражение (например, когда оно присваивается столбцу "
"таблицы); в таких случаях система автоматически преобразует тип. Однако "
"автоматическое преобразование выполняется только для приведений с пометкой "
"<quote>допускается неявное применение</quote> в системных каталогах. Все "
"остальные приведения должны записываться явно. Это ограничение позволяет "
"избежать сюрпризов с неявным преобразованием."

#: syntax.xml:2008(para)
msgid ""
"It is also possible to specify a type cast using a function-like syntax: "
"<synopsis>\n"
"<replaceable>typename</replaceable> ( <replaceable>expression</"
"replaceable> )\n"
"</synopsis> However, this only works for types whose names are also valid as "
"function names. For example, <literal>double precision</literal> cannot be "
"used this way, but the equivalent <literal>float8</literal> can. Also, the "
"names <literal>interval</literal>, <literal>time</literal>, and "
"<literal>timestamp</literal> can only be used in this fashion if they are "
"double-quoted, because of syntactic conflicts. Therefore, the use of the "
"function-like cast syntax leads to inconsistencies and should probably be "
"avoided."
msgstr ""
"Также можно записать приведение типа как вызов функции: <synopsis>\n"
"<replaceable>имя_типа</replaceable> ( <replaceable>выражение</"
"replaceable> )\n"
"</synopsis> Однако это будет работать только для типов, имена которых "
"являются также допустимыми именами функций. Например, <literal>double "
"precision</literal> так использовать нельзя, а <literal>float8</literal> "
"(альтернативное название того же типа) &mdash; можно. Кроме того, имена "
"типов <literal>interval</literal>, <literal>time</literal> и "
"<literal>timestamp</literal> из-за синтаксического конфликта можно "
"использовать в такой записи только в кавычках. Таким образом, запись "
"приведения типа в виде вызова функции провоцирует несоответствия и, "
"возможно, лучше будет её не применять."

#: syntax.xml:2025(para)
msgid ""
"The function-like syntax is in fact just a function call. When one of the "
"two standard cast syntaxes is used to do a run-time conversion, it will "
"internally invoke a registered function to perform the conversion. By "
"convention, these conversion functions have the same name as their output "
"type, and thus the <quote>function-like syntax</quote> is nothing more than "
"a direct invocation of the underlying conversion function. Obviously, this "
"is not something that a portable application should rely on. For further "
"details see <xref linkend=\"sql-createcast\"/>."
msgstr ""
"Приведение типа, представленное в виде вызова функции, на самом деле "
"соответствует внутреннему механизму. Даже при использовании двух стандартных "
"типов записи внутри происходит вызов зарегистрированной функции, выполняющей "
"преобразование. По соглашению именем такой функции преобразования является "
"имя выходного типа, и таким образом запись <quote>в виде вызова функции</"
"quote> есть не что иное, как прямой вызов нижележащей функции "
"преобразования. При создании переносимого приложения на это поведение, "
"конечно, не следует рассчитывать. Подробнее это описано в справке <xref "
"linkend=\"sql-createcast\"/>."

#: syntax.xml:2040(title)
msgid "Collation Expressions"
msgstr "Применение правил сортировки"

#: syntax.xml:2042(indexterm)
msgid "<primary>COLLATE</primary>"
msgstr "<primary>COLLATE</primary>"

#: syntax.xml:2046(para)
msgid ""
"The <literal>COLLATE</literal> clause overrides the collation of an "
"expression. It is appended to the expression it applies to: <synopsis>\n"
"<replaceable>expr</replaceable> COLLATE <replaceable>collation</"
"replaceable>\n"
"</synopsis> where <replaceable>collation</replaceable> is a possibly schema-"
"qualified identifier. The <literal>COLLATE</literal> clause binds tighter "
"than operators; parentheses can be used when necessary."
msgstr ""
"Предложение <literal>COLLATE</literal> переопределяет правило сортировки "
"выражения. Оно добавляется после выражения: <synopsis>\n"
"<replaceable>выражение</replaceable> COLLATE "
"<replaceable>правило_сортировки</replaceable>\n"
"</synopsis> где <replaceable>правило_сортировки</replaceable> &mdash; "
"идентификатор правила, возможно дополненный именем схемы. Предложение "
"<literal>COLLATE</literal> связывает выражение сильнее, чем операторы, так "
"что при необходимости следует использовать скобки."

#: syntax.xml:2058(para)
msgid ""
"If no collation is explicitly specified, the database system either derives "
"a collation from the columns involved in the expression, or it defaults to "
"the default collation of the database if no column is involved in the "
"expression."
msgstr ""
"Если правило сортировки не определено явно, система либо выбирает его по "
"столбцам, которые используются в выражении, либо, если таких столбцов нет, "
"переключается на установленное для базы данных правило сортировки по "
"умолчанию."

#: syntax.xml:2069(programlisting)
#, no-wrap
msgid "SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE \"C\";"
msgstr "SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE \"C\";"

#: syntax.xml:2074(programlisting)
#, no-wrap
msgid "SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE \"C\";"
msgstr "SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE \"C\";"

#: syntax.xml:2087(programlisting)
#, no-wrap
msgid "SELECT * FROM tbl WHERE a COLLATE \"C\" &gt; 'foo';"
msgstr "SELECT * FROM tbl WHERE a COLLATE \"C\" &gt; 'foo';"

#: syntax.xml:2091(programlisting)
#, no-wrap
msgid "SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE \"C\";"
msgstr "SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE \"C\";"

#: syntax.xml:2065(para)
msgid ""
"The two common uses of the <literal>COLLATE</literal> clause are overriding "
"the sort order in an <literal>ORDER BY</literal> clause, for example: "
"<placeholder-1/> and overriding the collation of a function or operator call "
"that has locale-sensitive results, for example: <placeholder-2/> Note that "
"in the latter case the <literal>COLLATE</literal> clause is attached to an "
"input argument of the operator we wish to affect. It doesn't matter which "
"argument of the operator or function call the <literal>COLLATE</literal> "
"clause is attached to, because the collation that is applied by the operator "
"or function is derived by considering all arguments, and an explicit "
"<literal>COLLATE</literal> clause will override the collations of all other "
"arguments. (Attaching non-matching <literal>COLLATE</literal> clauses to "
"more than one argument, however, is an error. For more details see <xref "
"linkend=\"collation\"/>.) Thus, this gives the same result as the previous "
"example: <placeholder-3/> But this is an error: <placeholder-4/> because it "
"attempts to apply a collation to the result of the <literal>&gt;</literal> "
"operator, which is of the non-collatable data type <type>boolean</type>."
msgstr ""
"Предложение <literal>COLLATE</literal> имеет два распространённых "
"применения: переопределение порядка сортировки в предложении <literal>ORDER "
"BY</literal>, например: <placeholder-1/> и переопределение правил сортировки "
"при вызове функций или операторов, возвращающих языкозависимые результаты, "
"например: <placeholder-2/> Заметьте, что в последнем случае предложение "
"<literal>COLLATE</literal> добавлено к аргументу оператора, на действие "
"которого мы хотим повлиять. При этом не имеет значения, к какому именно "
"аргументу оператора или функции добавляется <literal>COLLATE</literal>, так "
"как правило сортировки, применяемое к оператору или функции, выбирается при "
"рассмотрении всех аргументов, а явное предложение <literal>COLLATE</literal> "
"переопределяет правила сортировки для всех других аргументов. (Однако "
"добавление разных предложений <literal>COLLATE</literal> к нескольким "
"аргументам будет ошибкой. Подробнее об этом см. <xref remap=\"4\" linkend="
"\"collation\"/>.) Таким образом, эта команда выдаст тот же результат: "
"<placeholder-3/> Но это будет ошибкой: <placeholder-4/> здесь правило "
"сортировки нельзя применить к результату оператора <literal>&gt;</literal>, "
"который имеет несравниваемый тип данных <type>boolean</type>."

#: syntax.xml:2101(title)
msgid "Scalar Subqueries"
msgstr "Скалярные подзапросы"

#: syntax.xml:2103(indexterm)
msgid "<primary>subquery</primary>"
msgstr "<primary>подзапрос</primary>"

#: syntax.xml:2107(para)
msgid ""
"A scalar subquery is an ordinary <command>SELECT</command> query in "
"parentheses that returns exactly one row with one column. (See <xref linkend="
"\"queries\"/> for information about writing queries.) The <command>SELECT</"
"command> query is executed and the single returned value is used in the "
"surrounding value expression. It is an error to use a query that returns "
"more than one row or more than one column as a scalar subquery. (But if, "
"during a particular execution, the subquery returns no rows, there is no "
"error; the scalar result is taken to be null.) The subquery can refer to "
"variables from the surrounding query, which will act as constants during any "
"one evaluation of the subquery. See also <xref linkend=\"functions-subquery"
"\"/> for other expressions involving subqueries."
msgstr ""
"Скалярный подзапрос &mdash; это обычный запрос <command>SELECT</command> в "
"скобках, который возвращает ровно одну строку и один столбец. (Написание "
"запросов освещается в <xref remap=\"6\" linkend=\"queries\"/>.) После "
"выполнения запроса <command>SELECT</command> его единственный результат "
"используется в окружающем его выражении. В качестве скалярного подзапроса "
"нельзя использовать запросы, возвращающие более одной строки или столбца. "
"(Но если в результате выполнения подзапрос не вернёт строк, скалярный "
"результат считается равным NULL.) В подзапросе можно ссылаться на переменные "
"из окружающего запроса; в процессе одного вычисления подзапроса они будут "
"считаться константами. Другие выражения с подзапросами описаны в <xref remap="
"\"6\" linkend=\"functions-subquery\"/>."

#: syntax.xml:2125(programlisting)
#, no-wrap
msgid ""
"SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)\n"
"    FROM states;"
msgstr ""
"SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)\n"
"    FROM states;"

#: syntax.xml:2122(para)
msgid ""
"For example, the following finds the largest city population in each state: "
"<placeholder-1/>"
msgstr ""
"Например, следующий запрос находит самый населённый город в каждом штате: "
"<placeholder-1/>"

#: syntax.xml:2133(title)
msgid "Array Constructors"
msgstr "Конструкторы массивов"

#: syntax.xml:2135(indexterm)
msgid "<primary>array</primary> <secondary>constructor</secondary>"
msgstr "<primary>массив</primary> <secondary>конструктор</secondary>"

#: syntax.xml:2140(indexterm)
msgid "<primary>ARRAY</primary>"
msgstr "<primary>ARRAY</primary>"

#: syntax.xml:2152(programlisting)
#, no-wrap
msgid ""
"SELECT ARRAY[1,2,3+4];\n"
"  array\n"
"---------\n"
" {1,2,7}\n"
"(1 row)"
msgstr ""
"SELECT ARRAY[1,2,3+4];\n"
"  array\n"
"---------\n"
" {1,2,7}\n"
"(1 row)"

#: syntax.xml:2165(programlisting)
#, no-wrap
msgid ""
"SELECT ARRAY[1,2,22.7]::integer[];\n"
"  array\n"
"----------\n"
" {1,2,23}\n"
"(1 row)"
msgstr ""
"SELECT ARRAY[1,2,22.7]::integer[];\n"
"  array\n"
"----------\n"
" {1,2,23}\n"
"(1 row)"

#: syntax.xml:2144(para)
msgid ""
"An array constructor is an expression that builds an array value using "
"values for its member elements. A simple array constructor consists of the "
"key word <literal>ARRAY</literal>, a left square bracket <literal>[</"
"literal>, a list of expressions (separated by commas) for the array element "
"values, and finally a right square bracket <literal>]</literal>. For "
"example: <placeholder-1/> By default, the array element type is the common "
"type of the member expressions, determined using the same rules as for "
"<literal>UNION</literal> or <literal>CASE</literal> constructs (see <xref "
"linkend=\"typeconv-union-case\"/>). You can override this by explicitly "
"casting the array constructor to the desired type, for example: "
"<placeholder-2/> This has the same effect as casting each expression to the "
"array element type individually. For more on casting, see <xref linkend="
"\"sql-syntax-type-casts\"/>."
msgstr ""
"Конструктор массива &mdash; это выражение, которое создаёт массив, определяя "
"значения его элементов. Конструктор простого массива состоит из ключевого "
"слова <literal>ARRAY</literal>, открывающей квадратной скобки <literal>[</"
"literal>, списка выражений (разделённых запятыми), задающих значения "
"элементов массива, и закрывающей квадратной скобки <literal>]</literal>. "
"Например: <placeholder-1/> По умолчанию типом элементов массива считается "
"общий тип для всех выражений, определённый по правилам, действующим и для "
"конструкций <literal>UNION</literal> и <literal>CASE</literal> (см. <xref "
"remap=\"4\" linkend=\"typeconv-union-case\"/>). Вы можете переопределить его "
"явно, приведя конструктор массива к требуемому типу, например: "
"<placeholder-2/> Это равносильно тому, что привести к нужному типу каждое "
"выражение по отдельности. Подробнее приведение типов описано в <xref remap="
"\"6\" linkend=\"sql-syntax-type-casts\"/>."

#: syntax.xml:2183(programlisting)
#, no-wrap
msgid ""
"SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];\n"
"     array\n"
"---------------\n"
" {{1,2},{3,4}}\n"
"(1 row)\n"
"\n"
"SELECT ARRAY[[1,2],[3,4]];\n"
"     array\n"
"---------------\n"
" {{1,2},{3,4}}\n"
"(1 row)"
msgstr ""
"SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];\n"
"     array\n"
"---------------\n"
" {{1,2},{3,4}}\n"
"(1 row)\n"
"\n"
"SELECT ARRAY[[1,2],[3,4]];\n"
"     array\n"
"---------------\n"
" {{1,2},{3,4}}\n"
"(1 row)"

#: syntax.xml:2177(para)
msgid ""
"Multidimensional array values can be built by nesting array constructors. In "
"the inner constructors, the key word <literal>ARRAY</literal> can be "
"omitted. For example, these produce the same result: <placeholder-1/> Since "
"multidimensional arrays must be rectangular, inner constructors at the same "
"level must produce sub-arrays of identical dimensions. Any cast applied to "
"the outer <literal>ARRAY</literal> constructor propagates automatically to "
"all the inner constructors."
msgstr ""
"Многомерные массивы можно образовывать, вкладывая конструкторы массивов. При "
"этом во внутренних конструкторах слово <literal>ARRAY</literal> можно "
"опускать. Например, результат работы этих конструкторов одинаков: "
"<placeholder-1/> Многомерные массивы должны быть прямоугольными, и поэтому "
"внутренние конструкторы одного уровня должны создавать вложенные массивы "
"одинаковой размерности. Любое приведение типа, применённое к внешнему "
"конструктору <literal>ARRAY</literal>, автоматически распространяется на все "
"внутренние."

#: syntax.xml:2207(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE arr(f1 int[], f2 int[]);\n"
"\n"
"INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);\n"
"\n"
"SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;\n"
"                     array\n"
"------------------------------------------------\n"
" {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}\n"
"(1 row)"
msgstr ""
"CREATE TABLE arr(f1 int[], f2 int[]);\n"
"\n"
"INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);\n"
"\n"
"SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;\n"
"                     array\n"
"------------------------------------------------\n"
" {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}\n"
"(1 row)"

#: syntax.xml:2203(para)
msgid ""
"Multidimensional array constructor elements can be anything yielding an "
"array of the proper kind, not only a sub-<literal>ARRAY</literal> construct. "
"For example: <placeholder-1/>"
msgstr ""
"Элементы многомерного массива можно создавать не только вложенными "
"конструкторами <literal>ARRAY</literal>, но и другими способами, "
"позволяющими получить массивы нужного типа. Например: <placeholder-1/>"

#: syntax.xml:2224(programlisting)
#, no-wrap
msgid ""
"SELECT ARRAY[]::integer[];\n"
" array\n"
"-------\n"
" {}\n"
"(1 row)"
msgstr ""
"SELECT ARRAY[]::integer[];\n"
" array\n"
"-------\n"
" {}\n"
"(1 row)"

#: syntax.xml:2220(para)
msgid ""
"You can construct an empty array, but since it's impossible to have an array "
"with no type, you must explicitly cast your empty array to the desired type. "
"For example: <placeholder-1/>"
msgstr ""
"Вы можете создать и пустой массив, но так как массив не может быть не "
"типизированным, вы должны явно привести пустой массив к нужному типу. "
"Например: <placeholder-1/>"

#: syntax.xml:2238(programlisting)
#, no-wrap
msgid ""
"SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');\n"
"                                 array\n"
"-----------------------------------------------------------------------\n"
" {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}\n"
"(1 row)\n"
"\n"
"SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));\n"
"              array\n"
"----------------------------------\n"
" {{1,2},{2,4},{3,6},{4,8},{5,10}}\n"
"(1 row)"
msgstr ""
"SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');\n"
"                                 array\n"
"-----------------------------------------------------------------------\n"
" {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}\n"
"(1 row)\n"
"\n"
"SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));\n"
"              array\n"
"----------------------------------\n"
" {{1,2},{2,4},{3,6},{4,8},{5,10}}\n"
"(1 row)"

#: syntax.xml:2233(para)
msgid ""
"It is also possible to construct an array from the results of a subquery. In "
"this form, the array constructor is written with the key word "
"<literal>ARRAY</literal> followed by a parenthesized (not bracketed) "
"subquery. For example: <placeholder-1/> The subquery must return a single "
"column. If the subquery's output column is of a non-array type, the "
"resulting one-dimensional array will have an element for each row in the "
"subquery result, with an element type matching that of the subquery's output "
"column. If the subquery's output column is of an array type, the result will "
"be an array of the same type but one higher dimension; in this case all the "
"subquery rows must yield arrays of identical dimensionality, else the result "
"would not be rectangular."
msgstr ""
"Также возможно создать массив из результатов подзапроса. В этом случае "
"конструктор массива записывается так же с ключевым словом <literal>ARRAY</"
"literal>, за которым в круглых скобках следует подзапрос. Например: "
"<placeholder-1/> Такой подзапрос должен возвращать один столбец. Если этот "
"столбец имеет тип, отличный от массива, результирующий одномерный массив "
"будет включать элементы для каждой строки-результата подзапроса и типом "
"элемента будет тип столбца результата. Если же тип столбца — массив, будет "
"создан массив того же типа, но большей размерности; в любом случае во всех "
"строках подзапроса должны выдаваться массивы одинаковой размерности, чтобы "
"можно было получить прямоугольный результат."

#: syntax.xml:2262(para)
msgid ""
"The subscripts of an array value built with <literal>ARRAY</literal> always "
"begin with one. For more information about arrays, see <xref linkend=\"arrays"
"\"/>."
msgstr ""
"Индексы массива, созданного конструктором <literal>ARRAY</literal>, всегда "
"начинаются с одного. Подробнее о массивах вы узнаете в <xref remap=\"6\" "
"linkend=\"arrays\"/>."

#: syntax.xml:2271(title)
msgid "Row Constructors"
msgstr "Конструкторы табличных строк"

#: syntax.xml:2273(indexterm)
msgid "<primary>composite type</primary> <secondary>constructor</secondary>"
msgstr "<primary>составной тип</primary> <secondary>конструктор</secondary>"

#: syntax.xml:2278(indexterm)
msgid "<primary>row type</primary> <secondary>constructor</secondary>"
msgstr ""
"<primary>тип табличной строки</primary> <secondary>конструктор</secondary>"

#: syntax.xml:2283(indexterm)
msgid "<primary>ROW</primary>"
msgstr "<primary>ROW</primary>"

#: syntax.xml:2294(programlisting)
#, no-wrap
msgid "SELECT ROW(1,2.5,'this is a test');"
msgstr "SELECT ROW(1,2.5,'this is a test');"

#: syntax.xml:2287(para)
msgid ""
"A row constructor is an expression that builds a row value (also called a "
"composite value) using values for its member fields. A row constructor "
"consists of the key word <literal>ROW</literal>, a left parenthesis, zero or "
"more expressions (separated by commas) for the row field values, and finally "
"a right parenthesis. For example: <placeholder-1/> The key word "
"<literal>ROW</literal> is optional when there is more than one expression in "
"the list."
msgstr ""
"Конструктор табличной строки &mdash; это выражение, создающее строку или "
"кортеж (или составное значение) из значений его аргументов-полей. "
"Конструктор строки состоит из ключевого слова <literal>ROW</literal>, "
"открывающей круглой скобки, нуля или нескольких выражений (разделённых "
"запятыми), определяющих значения полей, и закрывающей скобки. Например: "
"<placeholder-1/> Если в списке более одного выражения, ключевое слово "
"<literal>ROW</literal> можно опустить."

#: syntax.xml:2309(programlisting)
#, no-wrap
msgid ""
"SELECT ROW(t.*, 42) FROM t;\n"
"SELECT ROW(t.f1, t.f2, 42) FROM t;"
msgstr ""
"SELECT ROW(t.*, 42) FROM t;\n"
"SELECT ROW(t.f1, t.f2, 42) FROM t;"

#: syntax.xml:2301(para)
msgid ""
"A row constructor can include the syntax <replaceable>rowvalue</"
"replaceable><literal>.*</literal>, which will be expanded to a list of the "
"elements of the row value, just as occurs when the <literal>.*</literal> "
"syntax is used at the top level of a <command>SELECT</command> list (see "
"<xref linkend=\"rowtypes-usage\"/>). For example, if table <literal>t</"
"literal> has columns <literal>f1</literal> and <literal>f2</literal>, these "
"are the same: <placeholder-1/>"
msgstr ""
"Конструктор строки поддерживает запись <replaceable>составное_значение</"
"replaceable><literal>.*</literal>, при этом данное значение будет развёрнуто "
"в список элементов, так же, как в записи <literal>.*</literal> на верхнем "
"уровне списка <command>SELECT</command> (см. <xref remap=\"4\" linkend="
"\"rowtypes-usage\"/>). Например, если таблица <literal>t</literal> содержит "
"столбцы <literal>f1</literal> и <literal>f2</literal>, эти записи "
"равнозначны: <placeholder-1/>"

#: syntax.xml:2316(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.2, the <literal>.*</literal> "
"syntax was not expanded in row constructors, so that writing <literal>ROW(t."
"*, 42)</literal> created a two-field row whose first field was another row "
"value. The new behavior is usually more useful. If you need the old behavior "
"of nested row values, write the inner row value without <literal>.*</"
"literal>, for instance <literal>ROW(t, 42)</literal>."
msgstr ""
"До версии <productname>PostgreSQL</productname> 8.2 запись <literal>.*</"
"literal> не разворачивалась в конструкторах строк, так что выражение "
"<literal>ROW(t.*, 42)</literal> создавало составное значение из двух полей, "
"в котором первое поле так же было составным. Новое поведение обычно более "
"полезно. Если вам нужно получить прежнее поведение, чтобы одно значение "
"строки было вложено в другое, напишите внутреннее значение без <literal>.*</"
"literal>, например: <literal>ROW(t, 42)</literal>."

#: syntax.xml:2333(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE mytable(f1 int, f2 float, f3 text);\n"
"\n"
"CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n"
"\n"
"-- No cast needed since only one getf1() exists\n"
"SELECT getf1(ROW(1,2.5,'this is a test'));\n"
" getf1\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);\n"
"\n"
"CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n"
"\n"
"-- Now we need a cast to indicate which function to call:\n"
"SELECT getf1(ROW(1,2.5,'this is a test'));\n"
"ERROR:  function getf1(record) is not unique\n"
"\n"
"SELECT getf1(ROW(1,2.5,'this is a test')::mytable);\n"
" getf1\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));\n"
" getf1\n"
"-------\n"
"    11\n"
"(1 row)"
msgstr ""
"CREATE TABLE mytable(f1 int, f2 float, f3 text);\n"
"\n"
"CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n"
"\n"
"-- Приведение не требуется, так как существует только одна getf1()\n"
"SELECT getf1(ROW(1,2.5,'this is a test'));\n"
" getf1\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);\n"
"\n"
"CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;\n"
"\n"
"-- Теперь приведение необходимо для однозначного выбора функции:\n"
"SELECT getf1(ROW(1,2.5,'this is a test'));\n"
"ОШИБКА:  функция getf1(record) не уникальна\n"
"\n"
"SELECT getf1(ROW(1,2.5,'this is a test')::mytable);\n"
" getf1\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));\n"
" getf1\n"
"-------\n"
"    11\n"
"(1 row)"

#: syntax.xml:2327(para)
msgid ""
"By default, the value created by a <literal>ROW</literal> expression is of "
"an anonymous record type. If necessary, it can be cast to a named composite "
"type &mdash; either the row type of a table, or a composite type created "
"with <command>CREATE TYPE AS</command>. An explicit cast might be needed to "
"avoid ambiguity. For example: <placeholder-1/>"
msgstr ""
"По умолчанию значение, созданное выражением <literal>ROW</literal>, имеет "
"тип анонимной записи. Если необходимо, его можно привести к именованному "
"составному типу &mdash; либо к типу строки таблицы, либо составному типу, "
"созданному оператором <command>CREATE TYPE AS</command>. Явное приведение "
"может потребоваться для достижения однозначности. Например: <placeholder-1/>"

#: syntax.xml:2373(programlisting)
#, no-wrap
msgid ""
"SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');\n"
"\n"
"SELECT ROW(table.*) IS NULL FROM table;  -- detect all-null rows"
msgstr ""
"SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');\n"
"\n"
"  -- выбрать все строки, содержащие только NULL\n"
"SELECT ROW(table.*) IS NULL FROM table;"

#: syntax.xml:2367(para)
msgid ""
"Row constructors can be used to build composite values to be stored in a "
"composite-type table column, or to be passed to a function that accepts a "
"composite parameter. Also, it is possible to compare two row values or test "
"a row with <literal>IS NULL</literal> or <literal>IS NOT NULL</literal>, for "
"example: <placeholder-1/> For more detail see <xref linkend=\"functions-"
"comparisons\"/>. Row constructors can also be used in connection with "
"subqueries, as discussed in <xref linkend=\"functions-subquery\"/>."
msgstr ""
"Используя конструктор строк (кортежей), можно создавать составное значение "
"для сохранения в столбце составного типа или для передачи функции, "
"принимающей составной параметр. Также вы можете сравнить два составных "
"значения или проверить их с помощью <literal>IS NULL</literal> или "
"<literal>IS NOT NULL</literal>, например: <placeholder-1/> Подробнее см. "
"<xref remap=\"4\" linkend=\"functions-comparisons\"/>. Конструкторы строк "
"также могут использоваться в сочетании с подзапросами, как описано в <xref "
"remap=\"6\" linkend=\"functions-subquery\"/>."

#: syntax.xml:2386(title)
msgid "Expression Evaluation Rules"
msgstr "Правила вычисления выражений"

#: syntax.xml:2388(indexterm)
msgid ""
"<primary>expression</primary> <secondary>order of evaluation</secondary>"
msgstr "<primary>выражение</primary> <secondary>порядок вычисления</secondary>"

#: syntax.xml:2393(para)
msgid ""
"The order of evaluation of subexpressions is not defined. In particular, the "
"inputs of an operator or function are not necessarily evaluated left-to-"
"right or in any other fixed order."
msgstr ""
"Порядок вычисления подвыражений не определён. В частности, аргументы "
"оператора или функции не обязательно вычисляются слева направо или в любом "
"другом фиксированном порядке."

#: syntax.xml:2403(programlisting)
#, no-wrap
msgid "SELECT true OR somefunc();"
msgstr "SELECT true OR somefunc();"

#: syntax.xml:2408(programlisting)
#, no-wrap
msgid "SELECT somefunc() OR true;"
msgstr "SELECT somefunc() OR true;"

#: syntax.xml:2399(para)
msgid ""
"Furthermore, if the result of an expression can be determined by evaluating "
"only some parts of it, then other subexpressions might not be evaluated at "
"all. For instance, if one wrote: <placeholder-1/> then <literal>somefunc()</"
"literal> would (probably) not be called at all. The same would be the case "
"if one wrote: <placeholder-2/> Note that this is not the same as the left-to-"
"right <quote>short-circuiting</quote> of Boolean operators that is found in "
"some programming languages."
msgstr ""
"Более того, если результат выражения можно получить, вычисляя только "
"некоторые его части, тогда другие подвыражения не будут вычисляться вовсе. "
"Например, если написать: <placeholder-1/> тогда функция <literal>somefunc()</"
"literal> не будет вызываться (возможно). То же самое справедливо для записи: "
"<placeholder-2/> Заметьте, что это отличается от <quote>оптимизации</quote> "
"вычисления логических операторов слева направо, реализованной в некоторых "
"языках программирования."

#: syntax.xml:2416(para)
msgid ""
"As a consequence, it is unwise to use functions with side effects as part of "
"complex expressions. It is particularly dangerous to rely on side effects or "
"evaluation order in <literal>WHERE</literal> and <literal>HAVING</literal> "
"clauses, since those clauses are extensively reprocessed as part of "
"developing an execution plan. Boolean expressions (<literal>AND</literal>/"
"<literal>OR</literal>/<literal>NOT</literal> combinations) in those clauses "
"can be reorganized in any manner allowed by the laws of Boolean algebra."
msgstr ""
"Как следствие, в сложных выражениях не стоит использовать функции с "
"побочными эффектами. Особенно опасно рассчитывать на порядок вычисления или "
"побочные эффекты в предложениях <literal>WHERE</literal> и <literal>HAVING</"
"literal>, так как эти предложения тщательно оптимизируются при построении "
"плана выполнения. Логические выражения (сочетания <literal>AND</literal>/"
"<literal>OR</literal>/<literal>NOT</literal>) в этих предложениях могут быть "
"видоизменены любым способом, допустимым законами Булевой алгебры."

#: syntax.xml:2431(programlisting)
#, no-wrap
msgid "SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;"
msgstr "SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;"

#: syntax.xml:2435(programlisting)
#, no-wrap
msgid "SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;"
msgstr "SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;"

#: syntax.xml:2426(para)
msgid ""
"When it is essential to force evaluation order, a <literal>CASE</literal> "
"construct (see <xref linkend=\"functions-conditional\"/>) can be used. For "
"example, this is an untrustworthy way of trying to avoid division by zero in "
"a <literal>WHERE</literal> clause: <placeholder-1/> But this is safe: "
"<placeholder-2/> A <literal>CASE</literal> construct used in this fashion "
"will defeat optimization attempts, so it should only be done when necessary. "
"(In this particular example, it would be better to sidestep the problem by "
"writing <literal>y &gt; 1.5*x</literal> instead.)"
msgstr ""
"Когда порядок вычисления важен, его можно зафиксировать с помощью "
"конструкции <literal>CASE</literal> (см. <xref remap=\"4\" linkend="
"\"functions-conditional\"/>). Например, такой способ избежать деления на "
"ноль в предложении <literal>WHERE</literal> ненадёжен: <placeholder-1/> "
"Безопасный вариант: <placeholder-2/> Применяемая так конструкция "
"<literal>CASE</literal> защищает выражение от оптимизации, поэтому "
"использовать её нужно только при необходимости. (В данном случае было бы "
"лучше решить проблему, переписав условие как <literal>y &gt; 1.5*x</"
"literal>.)"

#: syntax.xml:2451(programlisting)
#, no-wrap
msgid "SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;"
msgstr "SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;"

#: syntax.xml:2444(para)
msgid ""
"<literal>CASE</literal> is not a cure-all for such issues, however. One "
"limitation of the technique illustrated above is that it does not prevent "
"early evaluation of constant subexpressions. As described in <xref linkend="
"\"xfunc-volatility\"/>, functions and operators marked <literal>IMMUTABLE</"
"literal> can be evaluated when the query is planned rather than when it is "
"executed. Thus for example <placeholder-1/> is likely to result in a "
"division-by-zero failure due to the planner trying to simplify the constant "
"subexpression, even if every row in the table has <literal>x &gt; 0</"
"literal> so that the <literal>ELSE</literal> arm would never be entered at "
"run time."
msgstr ""
"Однако, <literal>CASE</literal> не всегда спасает в подобных случаях. "
"Показанный выше приём плох тем, что не предотвращает раннее вычисление "
"константных подвыражений. Как описано в <xref remap=\"6\" linkend=\"xfunc-"
"volatility\"/>, функции и операторы, помеченные как <literal>IMMUTABLE</"
"literal>, могут вычисляться при планировании, а не выполнении запроса. "
"Поэтому в примере <placeholder-1/>, скорее всего, произойдёт деление на ноль "
"из-за того, что планировщик попытается упростить константное подвыражение, "
"даже если во всех строках в таблице <literal>x &gt; 0</literal>, а значит во "
"время выполнения ветвь <literal>ELSE</literal> никогда не будет выполняться."

#: syntax.xml:2460(para)
msgid ""
"While that particular example might seem silly, related cases that don't "
"obviously involve constants can occur in queries executed within functions, "
"since the values of function arguments and local variables can be inserted "
"into queries as constants for planning purposes. Within <application>PL/"
"pgSQL</application> functions, for example, using an <literal>IF</literal>-"
"<literal>THEN</literal>-<literal>ELSE</literal> statement to protect a risky "
"computation is much safer than just nesting it in a <literal>CASE</literal> "
"expression."
msgstr ""
"Хотя этот конкретный пример может показаться надуманным, похожие ситуации, в "
"которых неявно появляются константы, могут возникать и в запросах внутри "
"функций, так как значения аргументов функции и локальных переменных при "
"планировании могут быть заменены константами. Поэтому например, в функциях "
"<application>PL/pgSQL</application> гораздо безопаснее для защиты от "
"рискованных вычислений использовать конструкцию <literal>IF</literal>-"
"<literal>THEN</literal>-<literal>ELSE</literal>, чем выражение "
"<literal>CASE</literal>."

#: syntax.xml:2478(programlisting)
#, no-wrap
msgid ""
"SELECT CASE WHEN min(employees) &gt; 0\n"
"            THEN avg(expenses / employees)\n"
"       END\n"
"    FROM departments;"
msgstr ""
"SELECT CASE WHEN min(employees) &gt; 0\n"
"            THEN avg(expenses / employees)\n"
"       END\n"
"    FROM departments;"

#: syntax.xml:2471(para)
msgid ""
"Another limitation of the same kind is that a <literal>CASE</literal> cannot "
"prevent evaluation of an aggregate expression contained within it, because "
"aggregate expressions are computed before other expressions in a "
"<literal>SELECT</literal> list or <literal>HAVING</literal> clause are "
"considered. For example, the following query can cause a division-by-zero "
"error despite seemingly having protected against it: <placeholder-1/> The "
"<function>min()</function> and <function>avg()</function> aggregates are "
"computed concurrently over all the input rows, so if any row has "
"<structfield>employees</structfield> equal to zero, the division-by-zero "
"error will occur before there is any opportunity to test the result of "
"<function>min()</function>. Instead, use a <literal>WHERE</literal> or "
"<literal>FILTER</literal> clause to prevent problematic input rows from "
"reaching an aggregate function in the first place."
msgstr ""
"Ещё один подобный недостаток этого подхода в том, что <literal>CASE</"
"literal> не может предотвратить вычисление заключённого в нём агрегатного "
"выражения, так как агрегатные выражения вычисляются перед всеми остальными в "
"списке <literal>SELECT</literal> или предложении <literal>HAVING</literal>. "
"Например, в следующем запросе может возникнуть ошибка деления на ноль, "
"несмотря на то, что он вроде бы защищён от неё: <placeholder-1/> Агрегатные "
"функции <function>min()</function> и <function>avg()</function> вычисляются "
"независимо по всем входным строкам, так что если в какой-то строке поле "
"<structfield>employees</structfield> окажется равным нулю, деление на ноль "
"произойдёт раньше, чем станет возможным проверить результат функции "
"<function>min()</function>. Поэтому, чтобы проблемные входные строки "
"изначально не попали в агрегатную функцию, следует воспользоваться "
"предложениями <literal>WHERE</literal> или <literal>FILTER</literal>."

#: syntax.xml:2496(title)
msgid "Calling Functions"
msgstr "Вызов функций"

#: syntax.xml:2498(indexterm)
msgid "<primary>notation</primary> <secondary>functions</secondary>"
msgstr "<primary>запись</primary> <secondary>функций</secondary>"

#: syntax.xml:2503(para)
msgid ""
"<productname>PostgreSQL</productname> allows functions that have named "
"parameters to be called using either <firstterm>positional</firstterm> or "
"<firstterm>named</firstterm> notation. Named notation is especially useful "
"for functions that have a large number of parameters, since it makes the "
"associations between parameters and actual arguments more explicit and "
"reliable. In positional notation, a function call is written with its "
"argument values in the same order as they are defined in the function "
"declaration. In named notation, the arguments are matched to the function "
"parameters by name and can be written in any order."
msgstr ""
"<productname>PostgreSQL</productname> позволяет вызывать функции с "
"именованными параметрами, используя запись с <firstterm>позиционной</"
"firstterm> или <firstterm>именной</firstterm> передачей аргументов. Именная "
"передача особенно полезна для функций со множеством параметров, так как она "
"делает связь параметров и аргументов более явной и надёжной. В позиционной "
"записи значения аргументов функции указываются в том же порядке, в каком они "
"описаны в определении функции. При именной передаче аргументы сопоставляются "
"с параметрами функции по именам и указывать их можно в любом порядке."

#: syntax.xml:2516(para)
msgid ""
"In either notation, parameters that have default values given in the "
"function declaration need not be written in the call at all. But this is "
"particularly useful in named notation, since any combination of parameters "
"can be omitted; while in positional notation parameters can only be omitted "
"from right to left."
msgstr ""
"При записи любым способом параметры, для которых в определении функции "
"заданы значения по умолчанию, можно вовсе не указывать. Но это особенно "
"полезно при именной передаче, так как опустить можно любой набор параметров, "
"тогда как при позиционной параметры можно опускать только последовательно, "
"справа налево."

#: syntax.xml:2524(para)
msgid ""
"<productname>PostgreSQL</productname> also supports <firstterm>mixed</"
"firstterm> notation, which combines positional and named notation. In this "
"case, positional parameters are written first and named parameters appear "
"after them."
msgstr ""
"<productname>PostgreSQL</productname> также поддерживает "
"<firstterm>смешанную</firstterm> передачу, когда параметры передаются и по "
"именам, и по позиции. В этом случае позиционные параметры должны идти перед "
"параметрами, передаваемыми по именам."

#: syntax.xml:2534(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)\n"
"RETURNS text\n"
"AS\n"
"$$\n"
" SELECT CASE\n"
"        WHEN $3 THEN UPPER($1 || ' ' || $2)\n"
"        ELSE LOWER($1 || ' ' || $2)\n"
"        END;\n"
"$$\n"
"LANGUAGE SQL IMMUTABLE STRICT;"
msgstr ""
"CREATE FUNCTION concat_lower_or_upper(a text, b text,\n"
"  uppercase boolean DEFAULT false)\n"
"RETURNS text\n"
"AS\n"
"$$\n"
" SELECT CASE\n"
"        WHEN $3 THEN UPPER($1 || ' ' || $2)\n"
"        ELSE LOWER($1 || ' ' || $2)\n"
"        END;\n"
"$$\n"
"LANGUAGE SQL IMMUTABLE STRICT;"

#: syntax.xml:2531(para)
msgid ""
"The following examples will illustrate the usage of all three notations, "
"using the following function definition: <placeholder-1/> Function "
"<function>concat_lower_or_upper</function> has two mandatory parameters, "
"<literal>a</literal> and <literal>b</literal>. Additionally there is one "
"optional parameter <literal>uppercase</literal> which defaults to "
"<literal>false</literal>. The <literal>a</literal> and <literal>b</literal> "
"inputs will be concatenated, and forced to either upper or lower case "
"depending on the <literal>uppercase</literal> parameter. The remaining "
"details of this function definition are not important here (see <xref "
"linkend=\"extend\"/> for more information)."
msgstr ""
"Мы рассмотрим все три варианта записи на примере следующей функции: "
"<placeholder-1/> Функция <function>concat_lower_or_upper</function> имеет "
"два обязательных параметра: <literal>a</literal> и <literal>b</literal>. "
"Кроме того, есть один необязательный параметр <literal>uppercase</literal>, "
"который по умолчанию имеет значение <literal>false</literal>. Аргументы "
"<literal>a</literal> и <literal>b</literal> будут сложены вместе и "
"переведены в верхний или нижний регистр, в зависимости от параметра "
"<literal>uppercase</literal>. Остальные тонкости реализации функции сейчас "
"не важны (подробнее о них рассказано в <xref remap=\"6\" linkend=\"extend\"/"
">)."

#: syntax.xml:2558(title)
msgid "Using Positional Notation"
msgstr "Позиционная передача"

#: syntax.xml:2560(indexterm)
msgid "<primary>function</primary> <secondary>positional notation</secondary>"
msgstr "<primary>функция</primary> <secondary>позиционная запись</secondary>"

#: syntax.xml:2565(para)
msgid ""
"Positional notation is the traditional mechanism for passing arguments to "
"functions in <productname>PostgreSQL</productname>. An example is: <screen>\n"
"SELECT concat_lower_or_upper('Hello', 'World', true);\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen> All arguments are specified in order. The result is upper case "
"since <literal>uppercase</literal> is specified as <literal>true</literal>. "
"Another example is: <screen>\n"
"SELECT concat_lower_or_upper('Hello', 'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" hello world\n"
"(1 row)\n"
"</screen> Here, the <literal>uppercase</literal> parameter is omitted, so it "
"receives its default value of <literal>false</literal>, resulting in lower "
"case output. In positional notation, arguments can be omitted from right to "
"left so long as they have defaults."
msgstr ""
"Позиционная передача &mdash; это традиционный механизм передачи аргументов "
"функции в <productname>PostgreSQL</productname>. Пример такой записи: "
"<screen>\n"
"SELECT concat_lower_or_upper('Hello', 'World', true);\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen> Все аргументы указаны в заданном порядке. Результат возвращён в "
"верхнем регистре, так как параметр <literal>uppercase</literal> имеет "
"значение <literal>true</literal>. Ещё один пример: <screen>\n"
"SELECT concat_lower_or_upper('Hello', 'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" hello world\n"
"(1 row)\n"
"</screen> Здесь параметр <literal>uppercase</literal> опущен, и поэтому он "
"принимает значение по умолчанию (<literal>false</literal>), и результат "
"переводится в нижний регистр. В позиционной записи любые аргументы с "
"определённым значением по умолчанию можно опускать справа налево."

#: syntax.xml:2593(title)
msgid "Using Named Notation"
msgstr "Именная передача"

#: syntax.xml:2595(indexterm)
msgid "<primary>function</primary> <secondary>named notation</secondary>"
msgstr "<primary>функция</primary> <secondary>именная передача</secondary>"

#: syntax.xml:2600(para)
msgid ""
"In named notation, each argument's name is specified using <literal>=&gt;</"
"literal> to separate it from the argument expression. For example: <screen>\n"
"SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" hello world\n"
"(1 row)\n"
"</screen> Again, the argument <literal>uppercase</literal> was omitted so it "
"is set to <literal>false</literal> implicitly. One advantage of using named "
"notation is that the arguments may be specified in any order, for example: "
"<screen>\n"
"SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World', uppercase "
"=&gt; true);\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"\n"
"SELECT concat_lower_or_upper(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; "
"'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen>"
msgstr ""
"При именной передаче для аргумента добавляется имя, которое отделяется от "
"выражения значения знаками <literal>=&gt;</literal>. Например: <screen>\n"
"SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" hello world\n"
"(1 row)\n"
"</screen> Здесь аргумент <literal>uppercase</literal> был так же опущен, так "
"что он неявно получил значение <literal>false</literal>. Преимуществом такой "
"записи является возможность записывать аргументы в любом порядке, например: "
"<screen>\n"
"SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World', uppercase "
"=&gt; true);\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"\n"
"SELECT concat_lower_or_upper(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; "
"'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen>"

#: syntax.xml:2630(para)
msgid ""
"An older syntax based on \":=\" is supported for backward compatibility: "
"<screen>\n"
"SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := "
"'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Для обратной совместимости поддерживается и старый синтаксис с \":=\": "
"<screen>\n"
"SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := "
"'World');\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen>"

#: syntax.xml:2643(title)
msgid "Using Mixed Notation"
msgstr "Смешанная передача"

#: syntax.xml:2645(indexterm)
msgid "<primary>function</primary> <secondary>mixed notation</secondary>"
msgstr "<primary>функция</primary> <secondary>смешанная запись</secondary>"

#: syntax.xml:2650(para)
msgid ""
"The mixed notation combines positional and named notation. However, as "
"already mentioned, named arguments cannot precede positional arguments. For "
"example: <screen>\n"
"SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen> In the above query, the arguments <literal>a</literal> and "
"<literal>b</literal> are specified positionally, while <literal>uppercase</"
"literal> is specified by name. In this example, that adds little except "
"documentation. With a more complex function having numerous parameters that "
"have default values, named or mixed notation can save a great deal of "
"writing and reduce chances for error."
msgstr ""
"При смешанной передаче параметры передаются и по именам, и по позиции. "
"Однако, как уже было сказано, именованные аргументы не могут стоять перед "
"позиционными. Например: <screen>\n"
"SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);\n"
" concat_lower_or_upper \n"
"-----------------------\n"
" HELLO WORLD\n"
"(1 row)\n"
"</screen> В данном запросе аргументы <literal>a</literal> и <literal>b</"
"literal> передаются по позиции, а <literal>uppercase</literal> &mdash; по "
"имени. Единственное обоснование такого вызова здесь &mdash; он стал чуть "
"более читаемым. Однако для более сложных функций с множеством аргументов, "
"часть из которых имеют значения по умолчанию, именная или смешанная передача "
"позволяют записать вызов эффективнее и уменьшить вероятность ошибок."

#: syntax.xml:2670(para)
msgid ""
"Named and mixed call notations currently cannot be used when calling an "
"aggregate function (but they do work when an aggregate function is used as a "
"window function)."
msgstr ""
"Именная и смешанная передача в настоящий момент не может использоваться при "
"вызове агрегатной функции (но они допускаются, если агрегатная функция "
"используется в качестве оконной)."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: syntax.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "In a select list (see <xref linkend=\"queries-select-lists\"/>), you can "
#~ "ask for all fields of a composite value by writing <literal>.*</literal>: "
#~ "<placeholder-1/>"
#~ msgstr ""
#~ "В списке выборки (см. <xref remap=\"4\" linkend=\"queries-select-lists\"/"
#~ ">) вы можете запросить все поля составного значения, написав <literal>.*</"
#~ "literal>: <placeholder-1/>"
