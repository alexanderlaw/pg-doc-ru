# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-02-06 11:19+0300\n"
"PO-Revision-Date: 2017-05-12 15:25+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"

#: ref/copy.xml:9(indexterm)
msgid "<primary>COPY</primary>"
msgstr "<primary>COPY</primary>"

#: ref/copy.xml:14(refentrytitle)
msgctxt "refentrytitle"
msgid "COPY"
msgstr "COPY"

#: ref/copy.xml:15(manvolnum)
msgid "7"
msgstr "7"

#: ref/copy.xml:16(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#: ref/copy.xml:20(refname)
msgctxt "refname"
msgid "COPY"
msgstr "COPY"

#: ref/copy.xml:21(refpurpose)
msgid "copy data between a file and a table"
msgstr "копировать данные между файлом и таблицей"

#: ref/copy.xml:26(replaceable) ref/copy.xml:30(replaceable)
#: ref/copy.xml:94(replaceable)
msgid "table_name"
msgstr "имя_таблицы"

#: ref/copy.xml:26(replaceable) ref/copy.xml:30(replaceable)
#: ref/copy.xml:44(replaceable) ref/copy.xml:45(replaceable)
#: ref/copy.xml:46(replaceable) ref/copy.xml:103(replaceable)
msgid "column_name"
msgstr "имя_столбца"

#: ref/copy.xml:27(replaceable) ref/copy.xml:31(replaceable)
#: ref/copy.xml:132(replaceable)
msgid "filename"
msgstr "имя_файла"

#: ref/copy.xml:27(replaceable) ref/copy.xml:31(replaceable)
msgid "command"
msgstr "команда"

#: ref/copy.xml:28(replaceable) ref/copy.xml:32(replaceable)
#: ref/copy.xml:34(replaceable)
msgid "option"
msgstr "параметр"

#: ref/copy.xml:30(replaceable) ref/copy.xml:113(replaceable)
msgid "query"
msgstr "запрос"

#: ref/copy.xml:34(phrase)
msgid "where <placeholder-1/> can be one of:"
msgstr "Здесь допускается <placeholder-1/>:"

#: ref/copy.xml:36(replaceable)
msgid "format_name"
msgstr "имя_формата"

#: ref/copy.xml:37(replaceable) ref/copy.xml:38(replaceable)
#: ref/copy.xml:41(replaceable) ref/copy.xml:181(replaceable)
msgid "boolean"
msgstr "boolean"

#: ref/copy.xml:39(replaceable)
msgid "delimiter_character"
msgstr "символ_разделитель"

#: ref/copy.xml:40(replaceable)
msgid "null_string"
msgstr "маркер_NULL"

#: ref/copy.xml:42(replaceable)
msgid "quote_character"
msgstr "символ_кавычек"

#: ref/copy.xml:43(replaceable)
msgid "escape_character"
msgstr "символ_экранирования"

#: ref/copy.xml:47(replaceable)
msgid "encoding_name"
msgstr "имя_кодировки"

#: ref/copy.xml:25(synopsis)
#, no-wrap
msgid ""
"COPY <placeholder-1/> [ ( <placeholder-2/> [, ...] ) ]\n"
"    FROM { '<placeholder-3/>' | PROGRAM '<placeholder-4/>' | STDIN }\n"
"    [ [ WITH ] ( <placeholder-5/> [, ...] ) ]\n"
"\n"
"COPY { <placeholder-6/> [ ( <placeholder-7/> [, ...] ) ] | ( <placeholder-8/> ) }\n"
"    TO { '<placeholder-9/>' | PROGRAM '<placeholder-10/>' | STDOUT }\n"
"    [ [ WITH ] ( <placeholder-11/> [, ...] ) ]\n"
"\n"
"<placeholder-12/>\n"
"\n"
"    FORMAT <placeholder-13/>\n"
"    OIDS [ <placeholder-14/> ]\n"
"    FREEZE [ <placeholder-15/> ]\n"
"    DELIMITER '<placeholder-16/>'\n"
"    NULL '<placeholder-17/>'\n"
"    HEADER [ <placeholder-18/> ]\n"
"    QUOTE '<placeholder-19/>'\n"
"    ESCAPE '<placeholder-20/>'\n"
"    FORCE_QUOTE { ( <placeholder-21/> [, ...] ) | * }\n"
"    FORCE_NOT_NULL ( <placeholder-22/> [, ...] )\n"
"    FORCE_NULL ( <placeholder-23/> [, ...] )\n"
"    ENCODING '<placeholder-24/>'"
msgstr ""
"COPY <placeholder-1/> [ ( <placeholder-2/> [, ...] ) ]\n"
"    FROM { '<placeholder-3/>' | PROGRAM '<placeholder-4/>' | STDIN }\n"
"    [ [ WITH ] ( <placeholder-5/> [, ...] ) ]\n"
"\n"
"COPY { <placeholder-6/> [ ( <placeholder-7/> [, ...] ) ] | ( <placeholder-8/> ) }\n"
"    TO { '<placeholder-9/>' | PROGRAM '<placeholder-10/>' | STDOUT }\n"
"    [ [ WITH ] ( <placeholder-11/> [, ...] ) ]\n"
"\n"
"<placeholder-12/>\n"
"\n"
"    FORMAT <placeholder-13/>\n"
"    OIDS [ <placeholder-14/> ]\n"
"    FREEZE [ <placeholder-15/> ]\n"
"    DELIMITER '<placeholder-16/>'\n"
"    NULL '<placeholder-17/>'\n"
"    HEADER [ <placeholder-18/> ]\n"
"    QUOTE '<placeholder-19/>'\n"
"    ESCAPE '<placeholder-20/>'\n"
"    FORCE_QUOTE { ( <placeholder-21/> [, ...] ) | * }\n"
"    FORCE_NOT_NULL ( <placeholder-22/> [, ...] )\n"
"    FORCE_NULL ( <placeholder-23/> [, ...] )\n"
"    ENCODING '<placeholder-24/>'"

#: ref/copy.xml:52(title)
msgid "Description"
msgstr "Описание"

#: ref/copy.xml:54(para)
msgid ""
"<command>COPY</command> moves data between <productname>PostgreSQL</"
"productname> tables and standard file-system files. <command>COPY TO</"
"command> copies the contents of a table <emphasis>to</emphasis> a file, "
"while <command>COPY FROM</command> copies data <emphasis>from</emphasis> a "
"file to a table (appending the data to whatever is in the table already). "
"<command>COPY TO</command> can also copy the results of a <command>SELECT</"
"command> query."
msgstr ""
"<command>COPY</command> перемещает данные между таблицами "
"<productname>PostgreSQL</productname> и традиционными файлами. <command>COPY "
"TO</command> копирует содержимое таблицы <emphasis>в</emphasis> файл, а "
"<command>COPY FROM</command> — <emphasis>из</emphasis> файла в таблицу "
"(добавляет данные к тем, что уже содержались в таблице). <command>COPY TO</"
"command> может также скопировать результаты запроса <command>SELECT</"
"command>."

#: ref/copy.xml:64(para)
msgid ""
"If a list of columns is specified, <command>COPY</command> will only copy "
"the data in the specified columns to or from the file. If there are any "
"columns in the table that are not in the column list, <command>COPY FROM</"
"command> will insert the default values for those columns."
msgstr ""
"Если указывается список столбцов, <command>COPY</command> скопирует только "
"данные указанных столбцов. Если в таблице есть столбцы, отсутствующие в этом "
"списке, <command>COPY FROM</command> заполнит эти столбцы значениями по "
"умолчанию."

#: ref/copy.xml:72(para)
msgid ""
"<command>COPY</command> with a file name instructs the "
"<productname>PostgreSQL</productname> server to directly read from or write "
"to a file. The file must be accessible by the <productname>PostgreSQL</"
"productname> user (the user ID the server runs as) and the name must be "
"specified from the viewpoint of the server. When <literal>PROGRAM</literal> "
"is specified, the server executes the given command and reads from the "
"standard output of the program, or writes to the standard input of the "
"program. The command must be specified from the viewpoint of the server, and "
"be executable by the <productname>PostgreSQL</productname> user. When "
"<literal>STDIN</literal> or <literal>STDOUT</literal> is specified, data is "
"transmitted via the connection between the client and the server."
msgstr ""
"<command>COPY</command> с именем файла указывает серверу "
"<productname>PostgreSQL</productname> читать или записывать непосредственно "
"этот файл. Заданный файл должен быть доступен пользователю "
"<productname>PostgreSQL</productname> (тому пользователю, от имени которого "
"работает сервер), и путь к файлу должен задаваться с точки зрения сервера. "
"Когда указывается параметр <literal>PROGRAM</literal>, сервер выполняет "
"заданную команду и читает данные из стандартного вывода программы, либо "
"записывает их в стандартный ввод. Команда должна определяться с точки зрения "
"сервера и быть доступной для исполнения пользователю "
"<productname>PostgreSQL</productname>. Когда указывается <literal>STDIN</"
"literal> или <literal>STDOUT</literal>, данные передаются через соединение "
"клиента с сервером."

#: ref/copy.xml:90(title)
msgid "Parameters"
msgstr "Параметры"

#: ref/copy.xml:96(para)
msgid "The name (optionally schema-qualified) of an existing table."
msgstr "Имя (возможно, дополненное схемой) существующей таблицы."

#: ref/copy.xml:105(para)
msgid ""
"An optional list of columns to be copied. If no column list is specified, "
"all columns of the table will be copied."
msgstr ""
"Необязательный список столбцов, данные которых будут копироваться. Если этот "
"список отсутствует, копируются все столбцы таблицы."

#: ref/copy.xml:115(para)
msgid ""
"A <xref linkend=\"sql-select\"/>, <xref linkend=\"sql-values\"/>, <xref "
"linkend=\"sql-insert\"/>, <xref linkend=\"sql-update\"/> or <xref linkend="
"\"sql-delete\"/> command whose results are to be copied. Note that "
"parentheses are required around the query."
msgstr ""
"Команда <xref linkend=\"sql-select\"/>, <xref linkend=\"sql-values\"/>, "
"<xref linkend=\"sql-insert\"/>, <xref linkend=\"sql-update\"/> или <xref "
"linkend=\"sql-delete\"/>, результаты которой будут скопированы. Заметьте, "
"что запрос должен заключаться в скобки."

#: ref/copy.xml:121(para)
msgid ""
"For <command>INSERT</command>, <command>UPDATE</command> and "
"<command>DELETE</command> queries a RETURNING clause must be provided, and "
"the target relation must not have a conditional rule, nor an <literal>ALSO</"
"literal> rule, nor an <literal>INSTEAD</literal> rule that expands to "
"multiple statements."
msgstr ""
"Для запросов <command>INSERT</command>, <command>UPDATE</command> и "
"<command>DELETE</command> должно задаваться предложение RETURNING и в "
"целевом отношении не должно быть условного правила, правила <literal>ALSO</"
"literal> или правила <literal>INSTEAD</literal>, разворачивающегося в "
"несколько операторов."

#: ref/copy.xml:134(para)
msgid ""
"The path name of the input or output file. An input file name can be an "
"absolute or relative path, but an output file name must be an absolute path. "
"Windows users might need to use an <literal>E''</literal> string and double "
"any backslashes used in the path name."
msgstr ""
"Путь входного или выходного файла. Путь входного файла может быть абсолютным "
"или относительным, но путь выходного должен быть только абсолютным. "
"Пользователям Windows следует использовать формат <literal>E''</literal> и "
"продублировать каждую обратную черту в пути файла."

#: ref/copy.xml:144(literal)
msgid "PROGRAM"
msgstr "PROGRAM"

#: ref/copy.xml:146(para)
msgid ""
"A command to execute. In <command>COPY FROM</command>, the input is read "
"from standard output of the command, and in <command>COPY TO</command>, the "
"output is written to the standard input of the command."
msgstr ""
"Выполняемая команда. <command>COPY FROM</command> читает стандартный вывод "
"команды, а <command>COPY TO</command> записывает в её стандартный ввод."

#: ref/copy.xml:151(para)
msgid ""
"Note that the command is invoked by the shell, so if you need to pass any "
"arguments to shell command that come from an untrusted source, you must be "
"careful to strip or escape any special characters that might have a special "
"meaning for the shell. For security reasons, it is best to use a fixed "
"command string, or at least avoid passing any user input in it."
msgstr ""
"Заметьте, что команда запускается через командную оболочку, так что если "
"требуется передать этой команде какие-либо аргументы, поступающие из "
"недоверенного источника, необходимо аккуратно избавиться от всех "
"спецсимволов, имеющих особое значение в оболочке, либо экранировать их. По "
"соображениям безопасности лучше ограничиться фиксированной строкой команды "
"или как минимум не позволять пользователям вводить в неё произвольное "
"содержимое."

#: ref/copy.xml:163(literal)
msgid "STDIN"
msgstr "STDIN"

#: ref/copy.xml:165(para)
msgid "Specifies that input comes from the client application."
msgstr "Указывает, что данные будут поступать из клиентского приложения."

#: ref/copy.xml:172(literal)
msgid "STDOUT"
msgstr "STDOUT"

#: ref/copy.xml:174(para)
msgid "Specifies that output goes to the client application."
msgstr "Указывает, что данные будут выдаваться клиентскому приложению."

#: ref/copy.xml:183(para)
msgid ""
"Specifies whether the selected option should be turned on or off. You can "
"write <literal>TRUE</literal>, <literal>ON</literal>, or <literal>1</"
"literal> to enable the option, and <literal>FALSE</literal>, <literal>OFF</"
"literal>, or <literal>0</literal> to disable it. The <replaceable class="
"\"parameter\">boolean</replaceable> value can also be omitted, in which case "
"<literal>TRUE</literal> is assumed."
msgstr ""
"Включает или отключает заданный параметр. Для включения параметра можно "
"написать <literal>TRUE</literal>, <literal>ON</literal> или <literal>1</"
"literal>, а для отключения — <literal>FALSE</literal>, <literal>OFF</"
"literal> или <literal>0</literal>. Значение <replaceable class=\"parameter"
"\">boolean</replaceable> можно опустить, в этом случае подразумевается "
"<literal>TRUE</literal>."

#: ref/copy.xml:195(literal)
msgid "FORMAT"
msgstr "FORMAT"

#: ref/copy.xml:197(para)
msgid ""
"Selects the data format to be read or written: <literal>text</literal>, "
"<literal>csv</literal> (Comma Separated Values), or <literal>binary</"
"literal>. The default is <literal>text</literal>."
msgstr ""
"Выбирает формат чтения или записи данных: <literal>text</literal> "
"(текстовый), <literal>csv</literal> (значения, разделённые запятыми, Comma "
"Separated Values) или <literal>binary</literal> (двоичный). По умолчанию "
"выбирается формат <literal>text</literal>."

#: ref/copy.xml:208(literal)
msgid "OIDS"
msgstr "OIDS"

#: ref/copy.xml:210(para)
msgid ""
"Specifies copying the OID for each row. (An error is raised if "
"<literal>OIDS</literal> is specified for a table that does not have OIDs, or "
"in the case of copying a <replaceable class=\"parameter\">query</"
"replaceable>.)"
msgstr ""
"Копирует OID каждой строки. (Если присутствует указание <literal>OIDS</"
"literal>, но таблица не содержит столбец oid, либо копируется <replaceable "
"class=\"parameter\">запрос</replaceable>, возникнет ошибка.)"

#: ref/copy.xml:220(literal)
msgid "FREEZE"
msgstr "FREEZE"

#: ref/copy.xml:222(para)
msgid ""
"Requests copying the data with rows already frozen, just as they would be "
"after running the <command>VACUUM FREEZE</command> command. This is intended "
"as a performance option for initial data loading. Rows will be frozen only "
"if the table being loaded has been created or truncated in the current "
"subtransaction, there are no cursors open and there are no older snapshots "
"held by this transaction."
msgstr ""
"Запросы копируют данные с уже замороженными строками, как после выполнения "
"команды <command>VACUUM FREEZE</command>. Это позволяет увеличить "
"производительность при начальном добавлении данных. Строки будут "
"замораживаться, только если загружаемая таблица была создана или опустошена "
"в текущей подтранзакции, с ней не связаны открытые курсоры и в данной "
"транзакции нет других снимков."

#: ref/copy.xml:230(para)
msgid ""
"Note that all other sessions will immediately be able to see the data once "
"it has been successfully loaded. This violates the normal rules of MVCC "
"visibility and users specifying should be aware of the potential problems "
"this might cause."
msgstr ""
"Заметьте, что все другие сеансы будут немедленно видеть данные, как только "
"они будут успешно загружены. Это нарушает принятые правила видимости MVCC, "
"так что пользователи, включающие этот режим, должны понимать, какие проблемы "
"это может вызвать."

#: ref/copy.xml:240(literal)
msgid "DELIMITER"
msgstr "DELIMITER"

#: ref/copy.xml:242(para)
msgid ""
"Specifies the character that separates columns within each row (line) of the "
"file. The default is a tab character in text format, a comma in "
"<literal>CSV</literal> format. This must be a single one-byte character. "
"This option is not allowed when using <literal>binary</literal> format."
msgstr ""
"Задаёт символ, разделяющий столбцы в строках файла. По умолчанию это символ "
"табуляции в текстовом формате и запятая в формате <literal>CSV</literal>. "
"Задаваемый символ должен быть однобайтовым. Для формата <literal>binary</"
"literal> этот параметр не допускается."

#: ref/copy.xml:253(literal)
msgid "NULL"
msgstr "NULL"

#: ref/copy.xml:255(para)
msgid ""
"Specifies the string that represents a null value. The default is <literal>"
"\\N</literal> (backslash-N) in text format, and an unquoted empty string in "
"<literal>CSV</literal> format. You might prefer an empty string even in text "
"format for cases where you don't want to distinguish nulls from empty "
"strings. This option is not allowed when using <literal>binary</literal> "
"format."
msgstr ""
"Определяет строку, задающую значение NULL. По умолчанию в текстовом формате "
"это <literal>\\N</literal> (обратная косая черта и N), а в формате "
"<literal>CSV</literal> — пустая строка без кавычек. Пустую строку можно "
"использовать и в текстовом формате, если не требуется различать пустые "
"строки и NULL. Для формата <literal>binary</literal> этот параметр не "
"допускается."

#: ref/copy.xml:265(para)
msgid ""
"When using <command>COPY FROM</command>, any data item that matches this "
"string will be stored as a null value, so you should make sure that you use "
"the same string as you used with <command>COPY TO</command>."
msgstr ""
"При выполнении <command>COPY FROM</command> любые значения, совпадающие с "
"этой строкой, сохраняются как значение NULL, так что при переносе данных "
"важно убедиться в том, что это та же строка, что применялась в <command>COPY "
"TO</command>."

#: ref/copy.xml:277(literal)
msgid "HEADER"
msgstr "HEADER"

#: ref/copy.xml:279(para)
msgid ""
"Specifies that the file contains a header line with the names of each column "
"in the file. On output, the first line contains the column names from the "
"table, and on input, the first line is ignored. This option is allowed only "
"when using <literal>CSV</literal> format."
msgstr ""
"Указывает, что файл содержит строку заголовка с именами столбцов. При выводе "
"первая строка файла будет содержать имена столбцов таблицы, а при вводе "
"первая строка просто игнорируется. Этот параметр допускается только для "
"формата <literal>CSV</literal>."

#: ref/copy.xml:289(literal)
msgid "QUOTE"
msgstr "QUOTE"

#: ref/copy.xml:291(para)
msgid ""
"Specifies the quoting character to be used when a data value is quoted. The "
"default is double-quote. This must be a single one-byte character. This "
"option is allowed only when using <literal>CSV</literal> format."
msgstr ""
"Указывает символ кавычек, используемый для заключения данных в кавычки. По "
"умолчанию это символ двойных кавычек. Задаваемый символ должен быть "
"однобайтовым. Этот параметр поддерживается только для формата <literal>CSV</"
"literal>."

#: ref/copy.xml:301(literal)
msgid "ESCAPE"
msgstr "ESCAPE"

#: ref/copy.xml:303(para)
msgid ""
"Specifies the character that should appear before a data character that "
"matches the <literal>QUOTE</literal> value. The default is the same as the "
"<literal>QUOTE</literal> value (so that the quoting character is doubled if "
"it appears in the data). This must be a single one-byte character. This "
"option is allowed only when using <literal>CSV</literal> format."
msgstr ""
"Задаёт символ, который будет выводиться перед символом данных, совпавшим со "
"значением <literal>QUOTE</literal>. По умолчанию это тот же символ, что и "
"<literal>QUOTE</literal> (то есть, при появлении в данных кавычек, они "
"дублируются). Задаваемый символ должен быть однобайтовым. Этот параметр "
"допускается только для режима <literal>CSV</literal>."

#: ref/copy.xml:315(literal)
msgid "FORCE_QUOTE"
msgstr "FORCE_QUOTE"

#: ref/copy.xml:317(para)
msgid ""
"Forces quoting to be used for all non-<literal>NULL</literal> values in each "
"specified column. <literal>NULL</literal> output is never quoted. If "
"<literal>*</literal> is specified, non-<literal>NULL</literal> values will "
"be quoted in all columns. This option is allowed only in <command>COPY TO</"
"command>, and only when using <literal>CSV</literal> format."
msgstr ""
"Принудительно заключает в кавычки все значения не <literal>NULL</literal> в "
"указанных столбцах. Выводимое значение <literal>NULL</literal> никогда не "
"заключается в кавычки. Если указано <literal>*</literal>, в кавычки будут "
"заключаться значения не <literal>NULL</literal> во всех столбцах. Этот "
"параметр принимает только команда <command>COPY TO</command> и только для "
"формата <literal>CSV</literal>."

#: ref/copy.xml:329(literal)
msgid "FORCE_NOT_NULL"
msgstr "FORCE_NOT_NULL"

#: ref/copy.xml:331(para)
msgid ""
"Do not match the specified columns' values against the null string. In the "
"default case where the null string is empty, this means that empty values "
"will be read as zero-length strings rather than nulls, even when they are "
"not quoted. This option is allowed only in <command>COPY FROM</command>, and "
"only when using <literal>CSV</literal> format."
msgstr ""
"Не сопоставлять значения в указанных столбцах с маркером NULL. По умолчанию, "
"когда маркер пуст, это означает, что пустые значения будут считаны как "
"строки нулевой длины, а не NULL, даже когда они не заключены в кавычки. Этот "
"параметр допускается только в команде <command>COPY FROM</command> и только "
"для формата <literal>CSV</literal>."

#: ref/copy.xml:343(literal)
msgid "FORCE_NULL"
msgstr "FORCE_NULL"

#: ref/copy.xml:345(para)
msgid ""
"Match the specified columns' values against the null string, even if it has "
"been quoted, and if a match is found set the value to <literal>NULL</"
"literal>. In the default case where the null string is empty, this converts "
"a quoted empty string into NULL. This option is allowed only in "
"<command>COPY FROM</command>, and only when using <literal>CSV</literal> "
"format."
msgstr ""
"Сопоставлять значения в указанных столбцах с маркером NULL, даже если они "
"заключены в кавычки, и в случае совпадения устанавливать значение "
"<literal>NULL</literal>. По умолчанию, когда этот маркер пуст, пустая строка "
"в кавычках будет преобразовываться в NULL. Этот параметр допускается только "
"в команде <command>COPY FROM</command> и только для формата <literal>CSV</"
"literal>."

#: ref/copy.xml:357(literal)
msgid "ENCODING"
msgstr "ENCODING"

#: ref/copy.xml:359(para)
msgid ""
"Specifies that the file is encoded in the <replaceable class=\"parameter"
"\">encoding_name</replaceable>. If this option is omitted, the current "
"client encoding is used. See the Notes below for more details."
msgstr ""
"Указывает, что файл имеет кодировку <replaceable class=\"parameter"
"\">имя_кодировки</replaceable>. Если этот параметр опущен, выбирается "
"текущая кодировка клиента. Подробнее об этом говорится ниже, в примечаниях."

#: ref/copy.xml:372(title)
msgid "Outputs"
msgstr "Выводимая информация"

#: ref/copy.xml:374(para)
msgid ""
"On successful completion, a <command>COPY</command> command returns a "
"command tag of the form <screen>\n"
"COPY <replaceable class=\"parameter\">count</replaceable>\n"
"</screen> The <replaceable class=\"parameter\">count</replaceable> is the "
"number of rows copied."
msgstr ""
"В случае успешного завершения, <command>COPY</command> возвращает метку "
"команды в виде <screen>\n"
"COPY <replaceable class=\"parameter\">число</replaceable>\n"
"</screen> Здесь <replaceable class=\"parameter\">число</replaceable> — "
"количество скопированных записей."

#: ref/copy.xml:385(para)
msgid ""
"<application>psql</application> will print this command tag only if the "
"command was not <literal>COPY ... TO STDOUT</literal>, or the equivalent "
"<application>psql</application> meta-command <literal>\\copy ... to stdout</"
"literal>. This is to prevent confusing the command tag with the data that "
"was just printed."
msgstr ""
"<application>psql</application> выводит эту метку, только если выполнялась "
"не команда <literal>COPY ... TO STDOUT</literal> или её аналог в "
"<application>psql</application>, метакоманда <literal>\\copy ... to stdout</"
"literal>. Это сделано для того, чтобы метка команды не смешалась с данными, "
"выведенными перед ней."

#: ref/copy.xml:396(title)
msgid "Notes"
msgstr "Замечания"

#: ref/copy.xml:398(para)
msgid ""
"<command>COPY</command> can only be used with plain tables, not with views. "
"However, you can write <literal>COPY (SELECT * FROM <replaceable class="
"\"parameter\">viewname</replaceable>) TO ...</literal>."
msgstr ""
"<command>COPY</command> может использоваться только с обычными таблицами, но "
"не с представлениями. Однако, при необходимости можно скопировать "
"представление так: <literal>COPY (SELECT * FROM <replaceable class="
"\"parameter\">имя_представления</replaceable>) TO ...</literal>."

#: ref/copy.xml:404(para)
msgid ""
"<command>COPY</command> only deals with the specific table named; it does "
"not copy data to or from child tables. Thus for example <literal>COPY "
"<replaceable class=\"parameter\">table</replaceable> TO</literal> shows the "
"same data as <literal>SELECT * FROM ONLY <replaceable class=\"parameter"
"\">table</replaceable></literal>. But <literal>COPY (SELECT * FROM "
"<replaceable class=\"parameter\">table</replaceable>) TO ...</literal> can "
"be used to dump all of the data in an inheritance hierarchy."
msgstr ""
"<command>COPY</command> обрабатывает только явно заданную таблицу, дочерние "
"таблицы при копировании данных не затрагиваются. Поэтому, например "
"<literal>COPY <replaceable class=\"parameter\">таблица</replaceable> TO</"
"literal> выводит те же данные, что и запрос <literal>SELECT * FROM ONLY "
"<replaceable class=\"parameter\">table</replaceable></literal>. Для выгрузки "
"всех данных в иерархии наследования можно применить <literal>COPY (SELECT * "
"FROM <replaceable class=\"parameter\">table</replaceable>) TO ...</literal>."

#: ref/copy.xml:414(para)
msgid ""
"You must have select privilege on the table whose values are read by "
"<command>COPY TO</command>, and insert privilege on the table into which "
"values are inserted by <command>COPY FROM</command>. It is sufficient to "
"have column privileges on the column(s) listed in the command."
msgstr ""
"В таблице, данные которой читает команда <command>COPY TO</command>, "
"требуется иметь право на выборку данных, а в таблице, куда вставляет "
"значения <command>COPY FROM</command>, требуется право на добавление. При "
"этом, если в команде перечисляются избранные столбцы, достаточно иметь права "
"только для них."

#: ref/copy.xml:422(para)
msgid ""
"If row-level security is enabled for the table, the relevant "
"<command>SELECT</command> policies will apply to <literal>COPY <replaceable "
"class=\"parameter\">table</replaceable> TO</literal> statements. Currently, "
"<command>COPY FROM</command> is not supported for tables with row-level "
"security. Use equivalent <command>INSERT</command> statements instead."
msgstr ""
"Если для таблицы включена защита на уровне строк, соответствующие политики "
"<command>SELECT</command> будут применяться и к операторам <literal>COPY "
"<replaceable class=\"parameter\">таблица</replaceable> TO</literal>. "
"Операторы <command>COPY FROM</command> для таблиц с защитой строк в "
"настоящее время не поддерживаются. Вместо них следует использовать "
"равнозначные операторы <command>INSERT</command>."

#: ref/copy.xml:431(para)
msgid ""
"Files named in a <command>COPY</command> command are read or written "
"directly by the server, not by the client application. Therefore, they must "
"reside on or be accessible to the database server machine, not the client. "
"They must be accessible to and readable or writable by the "
"<productname>PostgreSQL</productname> user (the user ID the server runs as), "
"not the client. Similarly, the command specified with <literal>PROGRAM</"
"literal> is executed directly by the server, not by the client application, "
"must be executable by the <productname>PostgreSQL</productname> user. "
"<command>COPY</command> naming a file or command is only allowed to database "
"superusers, since it allows reading or writing any file that the server has "
"privileges to access."
msgstr ""
"Файлы, указанные в команде <command>COPY</command>, читаются или "
"записываются непосредственно сервером, не клиентским приложением. Поэтому "
"они должны располагаться на сервере или быть доступными серверу, а не "
"клиенту. Они должны быть доступны на чтение или запись пользователю "
"<productname>PostgreSQL</productname> (пользователю, от имени которого "
"работает сервер), не клиенту. Аналогично, команда, указанная параметром "
"<literal>PROGRAM</literal>, выполняется непосредственно сервером, а не "
"клиентским приложением, и должна быть доступна на выполнение пользователю "
"<productname>PostgreSQL</productname>. Выполнять команду <command>COPY</"
"command> с файлом (или командой) разрешено только суперпользователям базы "
"данных, так как она позволяет прочитать и записать любой файл, к которому "
"имеет доступ сервер."

#: ref/copy.xml:446(para)
msgid ""
"Do not confuse <command>COPY</command> with the <application>psql</"
"application> instruction <command><link linkend=\"app-psql-meta-commands-copy"
"\">\\copy</link></command>. <command>\\copy</command> invokes <command>COPY "
"FROM STDIN</command> or <command>COPY TO STDOUT</command>, and then fetches/"
"stores the data in a file accessible to the <application>psql</application> "
"client. Thus, file accessibility and access rights depend on the client "
"rather than the server when <command>\\copy</command> is used."
msgstr ""
"Не путайте команду <command>COPY</command> с реализованной в "
"<application>psql</application> метакомандой <command><link linkend=\"app-"
"psql-meta-commands-copy\">\\copy</link></command>. Метакоманда <command>"
"\\copy</command> вызывает <command>COPY FROM STDIN</command> или "
"<command>COPY TO STDOUT</command>, а затем работает с данными в файле, "
"доступном клиенту <application>psql</application>. Таким образом, когда "
"применяется команда <command>\\copy</command>, доступность файла и права "
"доступа зависят от клиента, а не от сервера."

#: ref/copy.xml:457(para)
msgid ""
"It is recommended that the file name used in <command>COPY</command> always "
"be specified as an absolute path. This is enforced by the server in the case "
"of <command>COPY TO</command>, but for <command>COPY FROM</command> you do "
"have the option of reading from a file specified by a relative path. The "
"path will be interpreted relative to the working directory of the server "
"process (normally the cluster's data directory), not the client's working "
"directory."
msgstr ""
"Путь файла, указываемый в <command>COPY</command>, рекомендуется всегда "
"задавать как абсолютный, а не относительный. Это обязательное условие для "
"команды <command>COPY TO</command>, но <command>COPY FROM</command> "
"позволяет прочитать файл, заданный и относительным путём. Такой путь будет "
"интерпретироваться относительно рабочего каталога серверного процесса "
"(обычно это каталог данных кластера), а не рабочего каталога клиента."

#: ref/copy.xml:467(para)
msgid ""
"Executing a command with <literal>PROGRAM</literal> might be restricted by "
"the operating system's access control mechanisms, such as SELinux."
msgstr ""
"Выполнение команды в <literal>PROGRAM</literal> может быть ограничено и "
"другими работающими в ОС механизмами контроля доступа, например SELinux."

#: ref/copy.xml:472(para)
msgid ""
"<command>COPY FROM</command> will invoke any triggers and check constraints "
"on the destination table. However, it will not invoke rules."
msgstr ""
"<command>COPY FROM</command> вызывает все триггеры и обрабатывает все "
"ограничения-проверки в целевой таблице. Однако правила при загрузке данных "
"не вызываются."

#: ref/copy.xml:477(para)
msgid ""
"<command>COPY</command> input and output is affected by <varname>DateStyle</"
"varname>. To ensure portability to other <productname>PostgreSQL</"
"productname> installations that might use non-default <varname>DateStyle</"
"varname> settings, <varname>DateStyle</varname> should be set to "
"<literal>ISO</literal> before using <command>COPY TO</command>. It is also a "
"good idea to avoid dumping data with <varname>IntervalStyle</varname> set to "
"<literal>sql_standard</literal>, because negative interval values might be "
"misinterpreted by a server that has a different setting for "
"<varname>IntervalStyle</varname>."
msgstr ""
"При вводе и выводе данных <command>COPY</command> учитывается "
"<varname>DateStyle</varname>. Для обеспечения переносимости на другие "
"инсталляции <productname>PostgreSQL</productname>, в которых могут "
"использоваться нестандартные значения <varname>DateStyle</varname>, значение "
"<varname>DateStyle</varname> следует установить равным <literal>ISO</"
"literal> до вызова <command>COPY TO</command>. Также рекомендуется не "
"выгружать данные с <varname>IntervalStyle</varname> равным "
"<literal>sql_standard</literal>, так как сервер с другим значением "
"<varname>IntervalStyle</varname> может неправильно воспринимать "
"отрицательные интервалы в таких данных."

#: ref/copy.xml:490(para)
msgid ""
"Input data is interpreted according to <literal>ENCODING</literal> option or "
"the current client encoding, and output data is encoded in "
"<literal>ENCODING</literal> or the current client encoding, even if the data "
"does not pass through the client but is read from or written to a file "
"directly by the server."
msgstr ""
"Входные данные интерпретируются согласно кодировке, заданной параметром "
"<literal>ENCODING</literal>, или текущей кодировке клиента, а выходные "
"кодируются в кодировке <literal>ENCODING</literal> или текущей кодировке "
"клиента, даже если данные не проходят через клиента, а считываются или "
"записываются в файл непосредственно сервером."

#: ref/copy.xml:498(para)
msgid ""
"<command>COPY</command> stops operation at the first error. This should not "
"lead to problems in the event of a <command>COPY TO</command>, but the "
"target table will already have received earlier rows in a <command>COPY "
"FROM</command>. These rows will not be visible or accessible, but they still "
"occupy disk space. This might amount to a considerable amount of wasted disk "
"space if the failure happened well into a large copy operation. You might "
"wish to invoke <command>VACUUM</command> to recover the wasted space."
msgstr ""
"<command>COPY</command> прекращает операцию при первой ошибке. Это не должно "
"приводить к проблемам в случае с <command>COPY TO</command>, но после "
"<command>COPY FROM</command> в целевой таблице остаются ранее полученные "
"строки. Эти строки не будут видимыми и доступными, но будут занимать место "
"на диске. Если сбой происходит при копировании большого объёма данных, это "
"может приводить к значительным потерям дискового пространства. При желании "
"вернуть потерянный объём, это можно сделать с помощью команды "
"<command>VACUUM</command>."

#: ref/copy.xml:509(para)
msgid ""
"<literal>FORCE_NULL</literal> and <literal>FORCE_NOT_NULL</literal> can be "
"used simultaneously on the same column. This results in converting quoted "
"null strings to null values and unquoted null strings to empty strings."
msgstr ""
"<literal>FORCE_NULL</literal> и <literal>FORCE_NOT_NULL</literal> можно "
"применить одновременно к одному столбцу. В результате NULL-значения в "
"кавычках будут преобразованы в NULL, а NULL-значения без кавычек — в пустые "
"строки."

#: ref/copy.xml:518(title)
msgid "File Formats"
msgstr "Форматы файлов"

#: ref/copy.xml:521(title)
msgid "Text Format"
msgstr "Текстовый формат"

#: ref/copy.xml:523(para)
msgid ""
"When the <literal>text</literal> format is used, the data read or written is "
"a text file with one line per table row. Columns in a row are separated by "
"the delimiter character. The column values themselves are strings generated "
"by the output function, or acceptable to the input function, of each "
"attribute's data type. The specified null string is used in place of columns "
"that are null. <command>COPY FROM</command> will raise an error if any line "
"of the input file contains more or fewer columns than are expected. If "
"<literal>OIDS</literal> is specified, the OID is read or written as the "
"first column, preceding the user data columns."
msgstr ""
"Когда применяется формат <literal>text</literal>, читаемые или записываемые "
"данные представляют собой текстовый файл, строка в котором соответствует "
"строке таблицы. Столбцы в строке разделяются символом-разделителем. Значения "
"самих столбцов — строки, выдаваемые функцией вывода, либо воспринимаемые "
"функцией ввода, соответствующей типу данных столбца. Заданный маркер NULL "
"выводится и считывается вместо столбцов со значением NULL. <command>COPY "
"FROM</command> выдаёт ошибку, если в любой из строк во входном файле "
"оказывается больше или меньше столбцов, чем ожидается. С указанием "
"<literal>OIDS</literal> значение OID считывается или записывается в первом "
"столбце, предшествующем столбцам с основными данными."

#: ref/copy.xml:537(para)
msgid ""
"End of data can be represented by a single line containing just backslash-"
"period (<literal>\\.</literal>). An end-of-data marker is not necessary when "
"reading from a file, since the end of file serves perfectly well; it is "
"needed only when copying data to or from client applications using pre-3.0 "
"client protocol."
msgstr ""
"Конец данных может обозначаться одной строкой, содержащей только обратную "
"косую и точку (<literal>\\.</literal>). Маркер конца данных не требуется при "
"чтении из файла, так как его роль вполне выполняет конец файла; он необходим "
"только при передаче данных в/из клиентского приложения по протоколу обмена "
"до версии 3.0."

#: ref/copy.xml:545(para)
msgid ""
"Backslash characters (<literal>\\</literal>) can be used in the "
"<command>COPY</command> data to quote data characters that might otherwise "
"be taken as row or column delimiters. In particular, the following "
"characters <emphasis>must</emphasis> be preceded by a backslash if they "
"appear as part of a column value: backslash itself, newline, carriage "
"return, and the current delimiter character."
msgstr ""
"Символы обратной косой черты (<literal>\\</literal>) в данных <command>COPY</"
"command> позволяют экранировать символы данных, которые без них считались бы "
"разделителями строк или столбцов. В частности, предваряться обратной косой "
"<emphasis>должны</emphasis> следующие символы, когда они оказываются в "
"значении столбца: сама обратная косая черта, перевод строки, возврат каретки "
"и текущий разделитель."

#: ref/copy.xml:554(para)
msgid ""
"The specified null string is sent by <command>COPY TO</command> without "
"adding any backslashes; conversely, <command>COPY FROM</command> matches the "
"input against the null string before removing backslashes. Therefore, a null "
"string such as <literal>\\N</literal> cannot be confused with the actual "
"data value <literal>\\N</literal> (which would be represented as <literal>\\"
"\\N</literal>)."
msgstr ""
"Маркер NULL передаётся команде <command>COPY TO</command> как есть, без "
"добавления обратной косой; <command>COPY FROM</command>, со своей стороны, "
"ищет во вводимых данных маркеры NULL до удаления обратных косых. Таким "
"образом, маркер NULL, например такой как <literal>\\N</literal>, отличается "
"от значения <literal>\\N</literal> в данных (оно должно представляться в "
"виде <literal>\\\\N</literal>)."

#: ref/copy.xml:571(entry)
msgid "Sequence"
msgstr "Последовательность"

#: ref/copy.xml:572(entry)
msgid "Represents"
msgstr "Представляет"

#: ref/copy.xml:578(literal)
msgid "\\b"
msgstr "\\b"

#: ref/copy.xml:579(entry)
msgid "Backspace (ASCII 8)"
msgstr "Забой (ASCII 8)"

#: ref/copy.xml:582(literal)
msgid "\\f"
msgstr "\\f"

#: ref/copy.xml:583(entry)
msgid "Form feed (ASCII 12)"
msgstr "Подача формы (ASCII 12)"

#: ref/copy.xml:586(literal)
msgid "\\n"
msgstr "\\n"

#: ref/copy.xml:587(entry)
msgid "Newline (ASCII 10)"
msgstr "Новая строка (ASCII 10)"

#: ref/copy.xml:590(literal)
msgid "\\r"
msgstr "\\r"

#: ref/copy.xml:591(entry)
msgid "Carriage return (ASCII 13)"
msgstr "Возврат каретки (ASCII 13)"

#: ref/copy.xml:594(literal)
msgid "\\t"
msgstr "\\t"

#: ref/copy.xml:595(entry)
msgid "Tab (ASCII 9)"
msgstr "Табуляция (ASCII 9)"

#: ref/copy.xml:598(literal)
msgid "\\v"
msgstr "\\v"

#: ref/copy.xml:599(entry)
msgid "Vertical tab (ASCII 11)"
msgstr "Вертикальная табуляция (ASCII 11)"

#: ref/copy.xml:602(literal)
msgid "\\"
msgstr "\\"

#: ref/copy.xml:602(replaceable) ref/copy.xml:607(replaceable)
msgid "digits"
msgstr "цифры"

#: ref/copy.xml:603(entry)
msgid ""
"Backslash followed by one to three octal digits specifies the character with "
"that numeric code"
msgstr ""
"Обратная косая с последующими 1-3 восьмеричными цифрами представляет символ "
"с заданным числовым кодом"

#: ref/copy.xml:607(literal)
msgid "\\x"
msgstr "\\x"

#: ref/copy.xml:608(entry)
msgid ""
"Backslash <literal>x</literal> followed by one or two hex digits specifies "
"the character with that numeric code"
msgstr ""
"Обратная косая с последующим <literal>x</literal> и 1-2 шестнадцатеричными "
"цифрами представляет символ с заданным числовым кодом"

#: ref/copy.xml:563(para)
msgid ""
"The following special backslash sequences are recognized by <command>COPY "
"FROM</command>: <placeholder-1/> Presently, <command>COPY TO</command> will "
"never emit an octal or hex-digits backslash sequence, but it does use the "
"other sequences listed above for those control characters."
msgstr ""
"Команда <command>COPY FROM</command> распознаёт следующие "
"спецпоследовательности: <placeholder-1/> В настоящее время <command>COPY TO</"
"command> никогда не выводит спецпоследовательности с восьмеричными или "
"шестнадцатеричными кодами, однако выводит другие вышеперечисленные "
"спецпоследовательности вместо управляющих символов."

#: ref/copy.xml:620(para)
msgid ""
"Any other backslashed character that is not mentioned in the above table "
"will be taken to represent itself. However, beware of adding backslashes "
"unnecessarily, since that might accidentally produce a string matching the "
"end-of-data marker (<literal>\\.</literal>) or the null string (<literal>"
"\\N</literal> by default). These strings will be recognized before any other "
"backslash processing is done."
msgstr ""
"Любой другой символ после обратной косой, отсутствующий в приведённой выше "
"таблице, будет представлять себя. Однако опасайтесь излишнего добавления "
"обратных косых, так как это может привести к случайному образованию строки, "
"обозначающей маркер конца данных (<literal>\\.</literal>) или маркер NULL "
"(<literal>\\N</literal> по умолчанию). Эти строки будут восприняты прежде, "
"чем обработаются спецпоследовательности с обратной косой."

#: ref/copy.xml:629(para)
msgid ""
"It is strongly recommended that applications generating <command>COPY</"
"command> data convert data newlines and carriage returns to the <literal>"
"\\n</literal> and <literal>\\r</literal> sequences respectively. At present "
"it is possible to represent a data carriage return by a backslash and "
"carriage return, and to represent a data newline by a backslash and newline. "
"However, these representations might not be accepted in future releases. "
"They are also highly vulnerable to corruption if the <command>COPY</command> "
"file is transferred across different machines (for example, from Unix to "
"Windows or vice versa)."
msgstr ""
"В приложениях, генерирующих данные для <command>COPY</command>, настоятельно "
"рекомендуется преобразовать символы новой строки и возврата каретки в "
"последовательности <literal>\\n</literal> и <literal>\\r</literal>, "
"соответственно. В настоящее время можно представить возврат каретки в данных "
"как обратная косая и возврат каретки, а перевод строки как обратная косая и "
"перевод строки, однако это может не поддерживаться в будущих версиях. Такие "
"символы также подвержены искажениям, если файл с выводом <command>COPY</"
"command> переносится между разными системами (например, с Unix в Windows и "
"наоборот)."

#: ref/copy.xml:641(para)
msgid ""
"<command>COPY TO</command> will terminate each row with a Unix-style newline "
"(<quote><literal>\\n</literal></quote>). Servers running on Microsoft "
"Windows instead output carriage return/newline (<quote><literal>\\r\\n</"
"literal></quote>), but only for <command>COPY</command> to a server file; "
"for consistency across platforms, <command>COPY TO STDOUT</command> always "
"sends <quote><literal>\\n</literal></quote> regardless of server platform. "
"<command>COPY FROM</command> can handle lines ending with newlines, carriage "
"returns, or carriage return/newlines. To reduce the risk of error due to un-"
"backslashed newlines or carriage returns that were meant as data, "
"<command>COPY FROM</command> will complain if the line endings in the input "
"are not all alike."
msgstr ""
"<command>COPY TO</command> завершает каждую строку символом новой строки в "
"стиле Unix (<quote><literal>\\n</literal></quote>). Серверы, работающие в "
"Microsoft Windows, вместо этого выводят символы возврат каретки/новая строка "
"(<quote><literal>\\r\\n</literal></quote>), но только при выводе "
"<command>COPY</command> в файл на сервере; для согласованности на разных "
"платформах, <command>COPY TO STDOUT</command> всегда передаёт "
"<quote><literal>\\n</literal></quote>, вне зависимости от платформы сервера. "
"<command>COPY FROM</command> может воспринимать строки, завершающиеся "
"символами новая строка, перевод каретки, либо возврат каретки+новая строка. "
"Чтобы уменьшить риск ошибки из-за неэкранированных символов новой строки и "
"возврата каретки, которые должны были быть данными, <command>COPY FROM</"
"command> сигнализирует о проблеме, если концы строк во входных данных "
"различаются."

#: ref/copy.xml:657(title)
msgid "CSV Format"
msgstr "Формат CSV"

#: ref/copy.xml:659(para)
msgid ""
"This format option is used for importing and exporting the Comma Separated "
"Value (<literal>CSV</literal>) file format used by many other programs, such "
"as spreadsheets. Instead of the escaping rules used by "
"<productname>PostgreSQL</productname>'s standard text format, it produces "
"and recognizes the common CSV escaping mechanism."
msgstr ""
"Этот формат применяется для импорта и экспорта данных в виде списка "
"значений, разделённых запятыми (<literal>CSV</literal>), с которым могут "
"работать многие другие программы, например электронные таблицы. Вместо "
"правил экранирования значений, введённых в <productname>PostgreSQL</"
"productname> для текстового формата, этот формат использует стандартный "
"механизм экранирования CSV."

#: ref/copy.xml:667(para)
msgid ""
"The values in each record are separated by the <literal>DELIMITER</literal> "
"character. If the value contains the delimiter character, the "
"<literal>QUOTE</literal> character, the <literal>NULL</literal> string, a "
"carriage return, or line feed character, then the whole value is prefixed "
"and suffixed by the <literal>QUOTE</literal> character, and any occurrence "
"within the value of a <literal>QUOTE</literal> character or the "
"<literal>ESCAPE</literal> character is preceded by the escape character. You "
"can also use <literal>FORCE_QUOTE</literal> to force quotes when outputting "
"non-<literal>NULL</literal> values in specific columns."
msgstr ""
"Значения в каждой записи разделяются символами <literal>DELIMITER</literal>. "
"Если значение содержит символ разделителя, символ <literal>QUOTE</literal>, "
"маркер <literal>NULL</literal>, символ возврата каретки или перевода строки, "
"то всё значение дополнятся спереди и сзади символами <literal>QUOTE</"
"literal>, а любое вхождение символа <literal>QUOTE</literal> или спецсимвола "
"(<literal>ESCAPE</literal>) в данных предваряется спецсимволом. С указанием "
"<literal>FORCE_QUOTE</literal> в кавычки будут принудительно заключаться "
"любые значения не <literal>NULL</literal> в указанных столбцах."

#: ref/copy.xml:679(para)
msgid ""
"The <literal>CSV</literal> format has no standard way to distinguish a "
"<literal>NULL</literal> value from an empty string. <productname>PostgreSQL</"
"productname>'s <command>COPY</command> handles this by quoting. A "
"<literal>NULL</literal> is output as the <literal>NULL</literal> parameter "
"string and is not quoted, while a non-<literal>NULL</literal> value matching "
"the <literal>NULL</literal> parameter string is quoted. For example, with "
"the default settings, a <literal>NULL</literal> is written as an unquoted "
"empty string, while an empty string data value is written with double quotes "
"(<literal>\"\"</literal>). Reading values follows similar rules. You can use "
"<literal>FORCE_NOT_NULL</literal> to prevent <literal>NULL</literal> input "
"comparisons for specific columns. You can also use <literal>FORCE_NULL</"
"literal> to convert quoted null string data values to <literal>NULL</"
"literal>."
msgstr ""
"В формате <literal>CSV</literal> отсутствует стандартный способ отличить "
"значение <literal>NULL</literal> от пустой строки. В "
"<productname>PostgreSQL</productname> команда <command>COPY</command> решает "
"это с помощью кавычек. Значение <literal>NULL</literal> выводится в виде "
"строки, задаваемой параметром <literal>NULL</literal>, и не заключается в "
"кавычки, тогда как значение не <literal>NULL</literal>, со строкой, "
"задаваемой параметром <literal>NULL</literal>, заключается. Например, с "
"параметрами по умолчанию <literal>NULL</literal> записывается в виде пустой "
"строки без кавычек, тогда как пустая строка записывается в двойных кавычках "
"(<literal>\"\"</literal>). При чтении значений действуют похожие правила. "
"Указание <literal>FORCE_NOT_NULL</literal> позволяет избежать сравнений на "
"<literal>NULL</literal> во входных данных в заданных столбцах, а "
"<literal>FORCE_NULL</literal> — преобразовывать в <literal>NULL</literal> "
"маркеры NULL, даже заключённые в кавычки."

#: ref/copy.xml:695(para)
msgid ""
"Because backslash is not a special character in the <literal>CSV</literal> "
"format, <literal>\\.</literal>, the end-of-data marker, could also appear as "
"a data value. To avoid any misinterpretation, a <literal>\\.</literal> data "
"value appearing as a lone entry on a line is automatically quoted on output, "
"and on input, if quoted, is not interpreted as the end-of-data marker. If "
"you are loading a file created by another application that has a single "
"unquoted column and might have a value of <literal>\\.</literal>, you might "
"need to quote that value in the input file."
msgstr ""
"Так как обратная косая черта не является спецсимволом в формате "
"<literal>CSV</literal>, маркер конца данных <literal>\\.</literal> может "
"быть и значением данных. Во избежание ошибок интерпретации данные <literal>"
"\\.</literal>, выводимые в виде единственного элемента строки, автоматически "
"заключаются в кавычки при выводе, а при вводе этот маркер, заключённый в "
"кавычки, не воспринимается как маркер конца данных. При загрузке файла, "
"созданного другой программой, в котором в единственном столбце без кавычек "
"оказалось значение <literal>\\.</literal>, потребуется дополнительно "
"заключить это значение в кавычки."

#: ref/copy.xml:708(para)
msgid ""
"In <literal>CSV</literal> format, all characters are significant. A quoted "
"value surrounded by white space, or any characters other than "
"<literal>DELIMITER</literal>, will include those characters. This can cause "
"errors if you import data from a system that pads <literal>CSV</literal> "
"lines with white space out to some fixed width. If such a situation arises "
"you might need to preprocess the <literal>CSV</literal> file to remove the "
"trailing white space, before importing the data into "
"<productname>PostgreSQL</productname>."
msgstr ""
"В формате <literal>CSV</literal> все символы являются значимыми. Заключённое "
"в кавычки значение, дополненное пробелами или любыми другими символами, "
"кроме <literal>DELIMITER</literal>, будет включать и эти символы. Это может "
"приводить к ошибкам при импорте данных из системы, дополняющей строки "
"<literal>CSV</literal> пробельными символами до некоторой фиксированной "
"ширины. В случае возникновения такой проблемы необходимо обработать файл "
"<literal>CSV</literal> и удалить из него замыкающие пробельные символы, "
"прежде чем загружать данные из него в <productname>PostgreSQL</productname>."

#: ref/copy.xml:721(para)
msgid ""
"CSV format will both recognize and produce CSV files with quoted values "
"containing embedded carriage returns and line feeds. Thus the files are not "
"strictly one line per table row like text-format files."
msgstr ""
"Обработчик формата CSV воспринимает и генерирует файлы CSV со значениями в "
"кавычках, которые могут содержать символы возврата каретки и перевода "
"строки. Таким образом, число строк в этих файлах не строго равно числу строк "
"в таблице, как в файлах текстового формата."

#: ref/copy.xml:730(para)
msgid ""
"Many programs produce strange and occasionally perverse CSV files, so the "
"file format is more a convention than a standard. Thus you might encounter "
"some files that cannot be imported using this mechanism, and <command>COPY</"
"command> might produce files that other programs cannot process."
msgstr ""
"Многие программы генерируют странные и иногда неприемлемые файлы CSV, так "
"что этот формат используется скорее по соглашению, чем по стандарту. Поэтому "
"вам могут встретиться файлы, которые невозможно импортировать, используя "
"этот механизм, а <command>COPY</command> может сформировать такие файлы, что "
"их не смогут обработать другие программы."

#: ref/copy.xml:742(title)
msgid "Binary Format"
msgstr "Двоичный формат"

#: ref/copy.xml:744(para)
msgid ""
"The <literal>binary</literal> format option causes all data to be stored/"
"read as binary format rather than as text. It is somewhat faster than the "
"text and <literal>CSV</literal> formats, but a binary-format file is less "
"portable across machine architectures and <productname>PostgreSQL</"
"productname> versions. Also, the binary format is very data type specific; "
"for example it will not work to output binary data from a <type>smallint</"
"type> column and read it into an <type>integer</type> column, even though "
"that would work fine in text format."
msgstr ""
"При выборе формата <literal>binary</literal> все данные сохраняются/"
"считываются в двоичном, а не текстовом виде. Иногда этот формат "
"обрабатывается быстрее, чем текстовый и <literal>CSV</literal>, но он может "
"оказаться непереносимым между разными машинными архитектурами и версиями "
"<productname>PostgreSQL</productname>. Кроме того, двоичный формат сильно "
"зависит от типов данных; например, он не позволяет вывести данные из столбца "
"<type>smallint</type>, а затем прочитать их в столбец <type>integer</type>, "
"хотя с текстовым форматом это вполне возможно."

#: ref/copy.xml:756(para)
msgid ""
"The <literal>binary</literal> file format consists of a file header, zero or "
"more tuples containing the row data, and a file trailer. Headers and data "
"are in network byte order."
msgstr ""
"Формат <literal>binary</literal> включает заголовок файла, ноль или более "
"записей, содержащих данные строк, и окончание файла. Для заголовков и данных "
"принят сетевой порядок байт."

#: ref/copy.xml:763(para)
msgid ""
"<productname>PostgreSQL</productname> releases before 7.4 used a different "
"binary file format."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 7.4 использовался другой "
"двоичный формат."

#: ref/copy.xml:770(title)
msgid "File Header"
msgstr "Заголовок файла"

#: ref/copy.xml:778(term)
msgid "Signature"
msgstr "Сигнатура"

#: ref/copy.xml:780(para)
msgid ""
"11-byte sequence <literal>PGCOPY\\n\\377\\r\\n\\0</literal> &mdash; note "
"that the zero byte is a required part of the signature. (The signature is "
"designed to allow easy identification of files that have been munged by a "
"non-8-bit-clean transfer. This signature will be changed by end-of-line-"
"translation filters, dropped zero bytes, dropped high bits, or parity "
"changes.)"
msgstr ""
"Последовательность из 11 байт <literal>PGCOPY\\n\\377\\r\\n\\0</literal> "
"&mdash; заметьте, что нулевой байт является обязательной частью сигнатуры. "
"(Эта сигнатура позволяет легко выявить файлы, испорченные при передаче, не "
"сохраняющей все 8 бит данных. Она изменится при прохождении через фильтры, "
"меняющие концы строк, отбрасывающие нулевые байты или старшие биты, либо "
"добавляющие чётность.)"

#: ref/copy.xml:791(term)
msgid "Flags field"
msgstr "Поле флагов"

#: ref/copy.xml:805(term)
msgid "Bit 16"
msgstr "Бит 16"

#: ref/copy.xml:807(para)
msgid "if 1, OIDs are included in the data; if 0, not"
msgstr "При 1 в данные включается OID; при 0 — нет"

#: ref/copy.xml:793(para)
msgid ""
"32-bit integer bit mask to denote important aspects of the file format. Bits "
"are numbered from 0 (<acronym>LSB</acronym>) to 31 (<acronym>MSB</acronym>). "
"Note that this field is stored in network byte order (most significant byte "
"first), as are all the integer fields used in the file format. Bits 16-31 "
"are reserved to denote critical file format issues; a reader should abort if "
"it finds an unexpected bit set in this range. Bits 0-15 are reserved to "
"signal backwards-compatible format issues; a reader should simply ignore any "
"unexpected bits set in this range. Currently only one flag bit is defined, "
"and the rest must be zero: <placeholder-1/>"
msgstr ""
"Маска из 32 бит, обозначающая важные аспекты формата файла. Биты нумеруются "
"от 0 (<acronym>LSB</acronym>) до 31 (<acronym>MSB</acronym>). Учтите, что "
"это поле хранится в сетевом порядке байт (наиболее значащий байт первый), "
"как и все целочисленные поля в этом формате. Биты 16-31 зарезервированы для "
"обозначения критичных особенностей формата; обработчик должен прервать "
"чтение, встретив любой неожиданный бит в этом диапазоне. Биты 0-15 "
"зарезервированы для обозначения особенностей, связанных с обратной "
"совместимостью; обработчик может просто игнорировать любые неожиданные биты "
"в этом диапазоне. В настоящее время определён только один битовый флаг, "
"остальные должны быть равны 0: <placeholder-1/>"

#: ref/copy.xml:817(term)
msgid "Header extension area length"
msgstr "Длина области расширения заголовка"

#: ref/copy.xml:819(para)
msgid ""
"32-bit integer, length in bytes of remainder of header, not including self. "
"Currently, this is zero, and the first tuple follows immediately. Future "
"changes to the format might allow additional data to be present in the "
"header. A reader should silently skip over any header extension data it does "
"not know what to do with."
msgstr ""
"Целое 32-битное число, определяющее длину в байтах остального заголовка, не "
"включая само это значение. В настоящее время содержит 0, и сразу за ним "
"следует первая запись. При будущих изменениях формата в заголовок могут быть "
"добавлены дополнительные данные. Обработчик должен просто пропускать все "
"расширенные данные заголовка, о которых ему ничего не известно."

#: ref/copy.xml:772(para)
msgid ""
"The file header consists of 15 bytes of fixed fields, followed by a variable-"
"length header extension area. The fixed fields are: <placeholder-1/>"
msgstr ""
"Заголовок файла содержит 15 байт фиксированных полей, за которыми следует "
"область расширения заголовка переменной длины. Фиксированные поля: "
"<placeholder-1/>"

#: ref/copy.xml:831(para)
msgid ""
"The header extension area is envisioned to contain a sequence of self-"
"identifying chunks. The flags field is not intended to tell readers what is "
"in the extension area. Specific design of header extension contents is left "
"for a later release."
msgstr ""
"Область расширения заголовка предусмотрена для размещения последовательности "
"самоопределяемых блоков. Поле флагов не должно содержать указаний о том, что "
"содержится в области расширения. Точное содержимое области расширения может "
"быть определено в будущих версиях."

#: ref/copy.xml:838(para)
msgid ""
"This design allows for both backwards-compatible header additions (add "
"header extension chunks, or set low-order flag bits) and non-backwards-"
"compatible changes (set high-order flag bits to signal such changes, and add "
"supporting data to the extension area if needed)."
msgstr ""
"При таком подходе возможно как обратно-совместимое дополнение заголовка "
"(добавить блоки расширения заголовка или установить младшие биты флагов), "
"так и не обратно-совместимое (установить старшие биты флагов, "
"сигнализирующие о подобном изменении, и добавить вспомогательные данные в "
"область расширения, если это потребуется)."

#: ref/copy.xml:847(title)
msgid "Tuples"
msgstr "Записи"

#: ref/copy.xml:848(para)
msgid ""
"Each tuple begins with a 16-bit integer count of the number of fields in the "
"tuple. (Presently, all tuples in a table will have the same count, but that "
"might not always be true.) Then, repeated for each field in the tuple, there "
"is a 32-bit length word followed by that many bytes of field data. (The "
"length word does not include itself, and can be zero.) As a special case, -1 "
"indicates a NULL field value. No value bytes follow in the NULL case."
msgstr ""
"Каждая запись начинается с 16-битного целого числа, определяющего количество "
"полей в записи. (В настоящее время во всех записях должно быть одинаковое "
"число полей, но так может быть не всегда.) Затем, для каждого поля в записи "
"указывается 32-битная длина поля, за которой следует это количество байт с "
"данными поля. (Значение длины не включает свой размер, и может быть равно "
"нулю.) В качестве особого варианта, -1 обозначает, что в поле содержится "
"NULL. В случае с NULL за длиной не следуют байты данных."

#: ref/copy.xml:857(para)
msgid "There is no alignment padding or any other extra data between fields."
msgstr ""
"Выравнивание или какие-либо дополнительные данные между полями не "
"вставляются."

#: ref/copy.xml:861(para)
msgid ""
"Presently, all data values in a binary-format file are assumed to be in "
"binary format (format code one). It is anticipated that a future extension "
"might add a header field that allows per-column format codes to be specified."
msgstr ""
"В настоящее время предполагается, что все значения данных в файле двоичного "
"формата содержатся в двоичном формате (формате под кодом 1). Возможно, в "
"будущем расширении в заголовок будет добавлено поле, позволяющее задавать "
"другие коды форматов для разных столбцов."

#: ref/copy.xml:868(para)
msgid ""
"To determine the appropriate binary format for the actual tuple data you "
"should consult the <productname>PostgreSQL</productname> source, in "
"particular the <function>*send</function> and <function>*recv</function> "
"functions for each column's data type (typically these functions are found "
"in the <filename>src/backend/utils/adt/</filename> directory of the source "
"distribution)."
msgstr ""
"Чтобы определить подходящий двоичный формат для фактических данных, "
"обратитесь к исходному коду <productname>PostgreSQL</productname>, в "
"частности, к функциям <function>*send</function> и <function>*recv</"
"function> для типов данных каждого столбца (обычно эти функции находятся в "
"каталоге <filename>src/backend/utils/adt/</filename> в дереве исходного "
"кода)."

#: ref/copy.xml:877(para)
msgid ""
"If OIDs are included in the file, the OID field immediately follows the "
"field-count word. It is a normal field except that it's not included in the "
"field-count. In particular it has a length word &mdash; this will allow "
"handling of 4-byte vs. 8-byte OIDs without too much pain, and will allow "
"OIDs to be shown as null if that ever proves desirable."
msgstr ""
"Если в файл включается OID, поле OID следует немедленно за числом, "
"определяющим количество полей. Это поле не отличается от других ничем, кроме "
"того, что оно не учитывается в количестве полей. В частности, для него также "
"задаётся длина &mdash; это позволяет обрабатывать и четырёх- и "
"восьмибайтовые OID без особых сложностей, и даже вывести OID, равный NULL, "
"если возникнет потребность в этом."

#: ref/copy.xml:887(title)
msgid "File Trailer"
msgstr "Окончание файла"

#: ref/copy.xml:889(para)
msgid ""
"The file trailer consists of a 16-bit integer word containing -1. This is "
"easily distinguished from a tuple's field-count word."
msgstr ""
"Окончание файла состоит из 16-битного целого, содержащего -1. Это позволяет "
"легко отличить его от счётчика полей в записи."

#: ref/copy.xml:894(para)
msgid ""
"A reader should report an error if a field-count word is neither -1 nor the "
"expected number of columns. This provides an extra check against somehow "
"getting out of sync with the data."
msgstr ""
"Обработчик, читающий файл, должен выдать ошибку, если число полей в записи "
"не равно -1 или ожидаемому числу столбцов. Это обеспечивает дополнительную "
"проверку синхронизации данных."

#: ref/copy.xml:904(title)
msgid "Examples"
msgstr "Примеры"

#: ref/copy.xml:909(programlisting)
#, no-wrap
msgid "COPY country TO STDOUT (DELIMITER '|');"
msgstr "COPY country TO STDOUT (DELIMITER '|');"

#: ref/copy.xml:906(para)
msgid ""
"The following example copies a table to the client using the vertical bar "
"(<literal>|</literal>) as the field delimiter: <placeholder-1/>"
msgstr ""
"В следующем примере таблица передаётся клиенту с разделителем полей "
"«вертикальная черта» (<literal>|</literal>): <placeholder-1/>"

#: ref/copy.xml:916(programlisting)
#, no-wrap
msgid "COPY country FROM '/usr1/proj/bray/sql/country_data';"
msgstr "COPY country FROM '/usr1/proj/bray/sql/country_data';"

#: ref/copy.xml:914(para)
msgid ""
"To copy data from a file into the <literal>country</literal> table: "
"<placeholder-1/>"
msgstr ""
"Копирование данных из файла в таблицу <literal>country</literal>: "
"<placeholder-1/>"

#: ref/copy.xml:923(programlisting)
#, no-wrap
msgid "COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';"
msgstr "COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';"

#: ref/copy.xml:921(para)
msgid ""
"To copy into a file just the countries whose names start with 'A': "
"<placeholder-1/>"
msgstr ""
"Копирование в файл только данных стран, название которых начинается с 'A': "
"<placeholder-1/>"

#: ref/copy.xml:931(programlisting)
#, no-wrap
msgid "COPY country TO PROGRAM 'gzip &gt; /usr1/proj/bray/sql/country_data.gz';"
msgstr "COPY country TO PROGRAM 'gzip &gt; /usr1/proj/bray/sql/country_data.gz';"

#: ref/copy.xml:928(para)
msgid ""
"To copy into a compressed file, you can pipe the output through an external "
"compression program: <placeholder-1/>"
msgstr ""
"Для копирования данных в сжатый файл можно направить вывод через внешнюю "
"программу сжатия: <placeholder-1/>"

#: ref/copy.xml:939(programlisting)
#, no-wrap
msgid ""
"AF      AFGHANISTAN\n"
"AL      ALBANIA\n"
"DZ      ALGERIA\n"
"ZM      ZAMBIA\n"
"ZW      ZIMBABWE"
msgstr ""
"AF      AFGHANISTAN\n"
"AL      ALBANIA\n"
"DZ      ALGERIA\n"
"ZM      ZAMBIA\n"
"ZW      ZIMBABWE"

#: ref/copy.xml:936(para)
msgid ""
"Here is a sample of data suitable for copying into a table from "
"<literal>STDIN</literal>: <placeholder-1/> Note that the white space on each "
"line is actually a tab character."
msgstr ""
"Пример данных, подходящих для копирования в таблицу из <literal>STDIN</"
"literal>: <placeholder-1/> Примечание: пробелы в каждой строке на самом деле "
"обозначают символы табуляции."

#: ref/copy.xml:956(programlisting)
#, no-wrap
msgid ""
"0000000   P   G   C   O   P   Y  \\n 377  \\r  \\n  \\0  \\0  \\0  \\0  \\0  \\0\n"
"0000020  \\0  \\0  \\0  \\0 003  \\0  \\0  \\0 002   A   F  \\0  \\0  \\0 013   A\n"
"0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \\0 003\n"
"0000060  \\0  \\0  \\0 002   A   L  \\0  \\0  \\0 007   A   L   B   A   N   I\n"
"0000100   A 377 377 377 377  \\0 003  \\0  \\0  \\0 002   D   Z  \\0  \\0  \\0\n"
"0000120 007   A   L   G   E   R   I   A 377 377 377 377  \\0 003  \\0  \\0\n"
"0000140  \\0 002   Z   M  \\0  \\0  \\0 006   Z   A   M   B   I   A 377 377\n"
"0000160 377 377  \\0 003  \\0  \\0  \\0 002   Z   W  \\0  \\0  \\0  \\b   Z   I\n"
"0000200   M   B   A   B   W   E 377 377 377 377 377 377"
msgstr ""
"0000000   P   G   C   O   P   Y  \\n 377  \\r  \\n  \\0  \\0  \\0  \\0  \\0  \\0\n"
"0000020  \\0  \\0  \\0  \\0 003  \\0  \\0  \\0 002   A   F  \\0  \\0  \\0 013   A\n"
"0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \\0 003\n"
"0000060  \\0  \\0  \\0 002   A   L  \\0  \\0  \\0 007   A   L   B   A   N   I\n"
"0000100   A 377 377 377 377  \\0 003  \\0  \\0  \\0 002   D   Z  \\0  \\0  \\0\n"
"0000120 007   A   L   G   E   R   I   A 377 377 377 377  \\0 003  \\0  \\0\n"
"0000140  \\0 002   Z   M  \\0  \\0  \\0 006   Z   A   M   B   I   A 377 377\n"
"0000160 377 377  \\0 003  \\0  \\0  \\0 002   Z   W  \\0  \\0  \\0  \\b   Z   I\n"
"0000200   M   B   A   B   W   E 377 377 377 377 377 377"

#: ref/copy.xml:949(para)
msgid ""
"The following is the same data, output in binary format. The data is shown "
"after filtering through the Unix utility <command>od -c</command>. The table "
"has three columns; the first has type <type>char(2)</type>, the second has "
"type <type>text</type>, and the third has type <type>integer</type>. All the "
"rows have a null value in the third column. <placeholder-1/>"
msgstr ""
"Ниже приведены те же данные, но выведенные в двоичном формате. Данные "
"показаны после обработки Unix-утилитой <command>od -c</command>. Таблица "
"содержит три столбца; первый имеет тип <type>char(2)</type>, второй — "
"<type>text</type>, а третий — <type>integer</type>. Последний столбец во "
"всех строках содержит NULL. <placeholder-1/>"

#: ref/copy.xml:970(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ref/copy.xml:972(para)
msgid "There is no <command>COPY</command> statement in the SQL standard."
msgstr "Оператор <command>COPY</command> отсутствует в стандарте SQL."

#: ref/copy.xml:976(para)
msgid ""
"The following syntax was used before <productname>PostgreSQL</productname> "
"version 9.0 and is still supported: <synopsis>\n"
"COPY <replaceable class=\"parameter\">table_name</replaceable> "
"[ ( <replaceable class=\"parameter\">column_name</replaceable> [, ...] ) ]\n"
"    FROM { '<replaceable class=\"parameter\">filename</replaceable>' | "
"STDIN }\n"
"    [ [ WITH ]\n"
"          [ BINARY ]\n"
"          [ OIDS ]\n"
"          [ DELIMITER [ AS ] '<replaceable class=\"parameter\">delimiter</"
"replaceable>' ]\n"
"          [ NULL [ AS ] '<replaceable class=\"parameter\">null string</"
"replaceable>' ]\n"
"          [ CSV [ HEADER ]\n"
"                [ QUOTE [ AS ] '<replaceable class=\"parameter\">quote</"
"replaceable>' ]\n"
"                [ ESCAPE [ AS ] '<replaceable class=\"parameter\">escape</"
"replaceable>' ]\n"
"                [ FORCE NOT NULL <replaceable class=\"parameter"
"\">column_name</replaceable> [, ...] ] ] ]\n"
"\n"
"COPY { <replaceable class=\"parameter\">table_name</replaceable> "
"[ ( <replaceable class=\"parameter\">column_name</replaceable> [, ...] ) ] | "
"( <replaceable class=\"parameter\">query</replaceable> ) }\n"
"    TO { '<replaceable class=\"parameter\">filename</replaceable>' | "
"STDOUT }\n"
"    [ [ WITH ]\n"
"          [ BINARY ]\n"
"          [ OIDS ]\n"
"          [ DELIMITER [ AS ] '<replaceable class=\"parameter\">delimiter</"
"replaceable>' ]\n"
"          [ NULL [ AS ] '<replaceable class=\"parameter\">null string</"
"replaceable>' ]\n"
"          [ CSV [ HEADER ]\n"
"                [ QUOTE [ AS ] '<replaceable class=\"parameter\">quote</"
"replaceable>' ]\n"
"                [ ESCAPE [ AS ] '<replaceable class=\"parameter\">escape</"
"replaceable>' ]\n"
"                [ FORCE QUOTE { <replaceable class=\"parameter"
"\">column_name</replaceable> [, ...] | * } ] ] ]\n"
"</synopsis> Note that in this syntax, <literal>BINARY</literal> and "
"<literal>CSV</literal> are treated as independent keywords, not as arguments "
"of a <literal>FORMAT</literal> option."
msgstr ""
"До версии <productname>PostgreSQL</productname> 9.0 использовался и по-"
"прежнему поддерживается следующий синтаксис: <synopsis>\n"
"COPY <replaceable class=\"parameter\">имя_таблицы</replaceable> "
"[ ( <replaceable class=\"parameter\">имя_столбца</replaceable> [, ...] ) ]\n"
"    FROM { '<replaceable class=\"parameter\">имя_файла</replaceable>' | "
"STDIN }\n"
"    [ [ WITH ]\n"
"          [ BINARY ]\n"
"          [ OIDS ]\n"
"          [ DELIMITER [ AS ] '<replaceable class=\"parameter\">разделитель</"
"replaceable>' ]\n"
"          [ NULL [ AS ] '<replaceable class=\"parameter\">маркер_null</"
"replaceable>' ]\n"
"          [ CSV [ HEADER ]\n"
"                [ QUOTE [ AS ] '<replaceable class=\"parameter\">кавычки</"
"replaceable>' ]\n"
"                [ ESCAPE [ AS ] '<replaceable class=\"parameter"
"\">спецсимвол</replaceable>' ]\n"
"                [ FORCE NOT NULL <replaceable class=\"parameter"
"\">имя_столбца</replaceable> [, ...] ] ] ]\n"
"\n"
"COPY { <replaceable class=\"parameter\">имя_таблицы</replaceable> "
"[ ( <replaceable class=\"parameter\">имя_столбца</replaceable> [, ...] ) ] | "
"( <replaceable class=\"parameter\">запрос</replaceable> ) }\n"
"    TO { '<replaceable class=\"parameter\">имя_файла</replaceable>' | "
"STDOUT }\n"
"    [ [ WITH ]\n"
"          [ BINARY ]\n"
"          [ OIDS ]\n"
"          [ DELIMITER [ AS ] '<replaceable class=\"parameter\">разделитель</"
"replaceable>' ]\n"
"          [ NULL [ AS ] '<replaceable class=\"parameter\">маркер_null</"
"replaceable>' ]\n"
"          [ CSV [ HEADER ]\n"
"                [ QUOTE [ AS ] '<replaceable class=\"parameter\">кавычки</"
"replaceable>' ]\n"
"                [ ESCAPE [ AS ] '<replaceable class=\"parameter"
"\">спецсимвол</replaceable>' ]\n"
"                [ FORCE QUOTE { <replaceable class=\"parameter"
"\">имя_столбца</replaceable> [, ...] | * } ] ] ]\n"
"</synopsis> Заметьте, что в этом синтаксисе ключевые слова <literal>BINARY</"
"literal> и <literal>CSV</literal> обрабатываются как независимые, а не как "
"аргументы параметра <literal>FORMAT</literal>."

#: ref/copy.xml:1011(para)
msgid ""
"The following syntax was used before <productname>PostgreSQL</productname> "
"version 7.3 and is still supported: <synopsis>\n"
"COPY [ BINARY ] <replaceable class=\"parameter\">table_name</replaceable> "
"[ WITH OIDS ]\n"
"    FROM { '<replaceable class=\"parameter\">filename</replaceable>' | "
"STDIN }\n"
"    [ [USING] DELIMITERS '<replaceable class=\"parameter\">delimiter</"
"replaceable>' ]\n"
"    [ WITH NULL AS '<replaceable class=\"parameter\">null string</"
"replaceable>' ]\n"
"\n"
"COPY [ BINARY ] <replaceable class=\"parameter\">table_name</replaceable> "
"[ WITH OIDS ]\n"
"    TO { '<replaceable class=\"parameter\">filename</replaceable>' | "
"STDOUT }\n"
"    [ [USING] DELIMITERS '<replaceable class=\"parameter\">delimiter</"
"replaceable>' ]\n"
"    [ WITH NULL AS '<replaceable class=\"parameter\">null string</"
"replaceable>' ]\n"
"</synopsis>"
msgstr ""
"До версии <productname>PostgreSQL</productname> 7.3 использовался и по-"
"прежнему поддерживается следующий синтаксис: <synopsis>\n"
"COPY [ BINARY ] <replaceable class=\"parameter\">table_name</replaceable> "
"[ WITH OIDS ]\n"
"    FROM { '<replaceable class=\"parameter\">имя_файла</replaceable>' | "
"STDIN }\n"
"    [ [USING] DELIMITERS '<replaceable class=\"parameter\">разделитель</"
"replaceable>' ]\n"
"    [ WITH NULL AS '<replaceable class=\"parameter\">маркер_null</"
"replaceable>' ]\n"
"\n"
"COPY [ BINARY ] <replaceable class=\"parameter\">имя_таблицы</replaceable> "
"[ WITH OIDS ]\n"
"    TO { '<replaceable class=\"parameter\">имя_файла</replaceable>' | "
"STDOUT }\n"
"    [ [USING] DELIMITERS '<replaceable class=\"parameter\">разделитель</"
"replaceable>' ]\n"
"    [ WITH NULL AS '<replaceable class=\"parameter\">маркер_null</"
"replaceable>' ]\n"
"</synopsis>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ref/copy.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
