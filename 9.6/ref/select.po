# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-08-09 16:01+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ref/select.xml:8(indexterm)
msgid "<primary>SELECT</primary>"
msgstr "<primary>SELECT</primary>"

#: ref/select.xml:12(indexterm)
msgid "<primary>TABLE command</primary>"
msgstr "<primary>команда TABLE</primary>"

#: ref/select.xml:16(indexterm)
msgid "<primary>WITH</primary> <secondary>in SELECT</secondary>"
msgstr "<primary>WITH</primary> <secondary>внутри SELECT</secondary>"

#: ref/select.xml:22(refentrytitle)
msgctxt "refentrytitle"
msgid "SELECT"
msgstr "SELECT"

#: ref/select.xml:23(manvolnum)
msgid "7"
msgstr "7"

#: ref/select.xml:24(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#: ref/select.xml:28(refname)
msgctxt "refname"
msgid "SELECT"
msgstr "SELECT"

#: ref/select.xml:29(refname)
msgid "TABLE"
msgstr "TABLE"

#: ref/select.xml:30(refname)
msgid "WITH"
msgstr "WITH"

#: ref/select.xml:31(refpurpose)
msgid "retrieve rows from a table or view"
msgstr "получить строки из таблицы или представления"

#: ref/select.xml:36(replaceable) ref/select.xml:74(replaceable)
msgid "with_query"
msgstr "запрос_WITH"

#: ref/select.xml:37(replaceable) ref/select.xml:38(replaceable)
#: ref/select.xml:45(replaceable) ref/select.xml:68(replaceable)
#: ref/select.xml:69(replaceable) ref/select.xml:70(replaceable)
#: ref/select.xml:71(replaceable)
msgid "expression"
msgstr "выражение"

#: ref/select.xml:38(replaceable)
msgid "output_name"
msgstr "имя_результата"

#: ref/select.xml:39(replaceable) ref/select.xml:51(replaceable)
#: ref/select.xml:63(replaceable)
msgid "from_item"
msgstr "элемент_FROM"

#: ref/select.xml:40(replaceable) ref/select.xml:42(replaceable)
msgid "condition"
msgstr "условие"

#: ref/select.xml:41(replaceable) ref/select.xml:65(replaceable)
#: ref/select.xml:72(replaceable)
msgid "grouping_element"
msgstr "элемент_группирования"

#: ref/select.xml:43(replaceable)
msgid "window_name"
msgstr "имя_окна"

#: ref/select.xml:43(replaceable)
msgid "window_definition"
msgstr "определение_окна"

#: ref/select.xml:44(replaceable) ref/select.xml:55(replaceable)
#: ref/select.xml:76(replaceable) ref/select.xml:404(replaceable)
msgid "select"
msgstr "выборка"

#: ref/select.xml:45(replaceable)
msgid "operator"
msgstr "оператор"

#: ref/select.xml:46(replaceable) ref/select.xml:48(replaceable)
msgid "count"
msgstr "число"

#: ref/select.xml:47(replaceable)
msgid "start"
msgstr "начало"

#: ref/select.xml:49(replaceable) ref/select.xml:53(replaceable)
#: ref/select.xml:78(replaceable) ref/select.xml:317(replaceable)
msgid "table_name"
msgstr "имя_таблицы"

#: ref/select.xml:51(phrase)
msgid "where <placeholder-1/> can be one of:"
msgstr "Здесь допускается <placeholder-1/>:"

#: ref/select.xml:53(replaceable) ref/select.xml:55(replaceable)
#: ref/select.xml:56(replaceable) ref/select.xml:58(replaceable)
#: ref/select.xml:59(replaceable) ref/select.xml:62(replaceable)
#: ref/select.xml:331(replaceable)
msgid "alias"
msgstr "псевдоним"

#: ref/select.xml:53(replaceable) ref/select.xml:55(replaceable)
#: ref/select.xml:56(replaceable) ref/select.xml:58(replaceable)
#: ref/select.xml:62(replaceable)
msgid "column_alias"
msgstr "псевдоним_столбца"

#: ref/select.xml:54(replaceable) ref/select.xml:349(replaceable)
msgid "sampling_method"
msgstr "метод_выборки"

#: ref/select.xml:54(replaceable) ref/select.xml:57(replaceable)
#: ref/select.xml:59(replaceable) ref/select.xml:60(replaceable)
#: ref/select.xml:61(replaceable) ref/select.xml:349(replaceable)
msgid "argument"
msgstr "аргумент"

#: ref/select.xml:54(replaceable) ref/select.xml:349(replaceable)
msgid "seed"
msgstr "затравка"

#: ref/select.xml:56(replaceable) ref/select.xml:76(replaceable)
#: ref/select.xml:421(replaceable)
msgid "with_query_name"
msgstr "имя_запроса_WITH"

#: ref/select.xml:57(replaceable) ref/select.xml:59(replaceable)
#: ref/select.xml:60(replaceable) ref/select.xml:61(replaceable)
#: ref/select.xml:436(replaceable)
msgid "function_name"
msgstr "имя_функции"

#: ref/select.xml:59(replaceable) ref/select.xml:60(replaceable)
#: ref/select.xml:61(replaceable)
msgid "column_definition"
msgstr "определение_столбца"

#: ref/select.xml:63(replaceable) ref/select.xml:498(replaceable)
msgid "join_type"
msgstr "тип_соединения"

#: ref/select.xml:63(replaceable) ref/select.xml:579(replaceable)
msgid "join_condition"
msgstr "условие_соединения"

#: ref/select.xml:63(replaceable) ref/select.xml:591(replaceable)
msgid "join_column"
msgstr "столбец_соединения"

#: ref/select.xml:65(phrase)
msgid "and <placeholder-1/> can be one of:"
msgstr "и <placeholder-1/> может быть следующим:"

#: ref/select.xml:74(phrase)
msgid "and <placeholder-1/> is:"
msgstr "и <placeholder-1/>:"

#: ref/select.xml:76(replaceable)
msgid "column_name"
msgstr "имя_столбца"

#: ref/select.xml:76(replaceable)
msgid "values"
msgstr "values"

#: ref/select.xml:76(replaceable)
msgid "insert"
msgstr "insert"

#: ref/select.xml:76(replaceable)
msgid "update"
msgstr "update"

#: ref/select.xml:76(replaceable)
msgid "delete"
msgstr "delete"

#: ref/select.xml:35(synopsis)
#, no-wrap
msgid ""
"[ WITH [ RECURSIVE ] <placeholder-1/> [, ...] ]\n"
"SELECT [ ALL | DISTINCT [ ON ( <placeholder-2/> [, ...] ) ] ]\n"
"    [ * | <placeholder-3/> [ [ AS ] <placeholder-4/> ] [, ...] ]\n"
"    [ FROM <placeholder-5/> [, ...] ]\n"
"    [ WHERE <placeholder-6/> ]\n"
"    [ GROUP BY <placeholder-7/> [, ...] ]\n"
"    [ HAVING <placeholder-8/> [, ...] ]\n"
"    [ WINDOW <placeholder-9/> AS ( <placeholder-10/> ) [, ...] ]\n"
"    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <placeholder-11/> ]\n"
"    [ ORDER BY <placeholder-12/> [ ASC | DESC | USING <placeholder-13/> ] [ NULLS { FIRST | LAST } ] [, ...] ]\n"
"    [ LIMIT { <placeholder-14/> | ALL } ]\n"
"    [ OFFSET <placeholder-15/> [ ROW | ROWS ] ]\n"
"    [ FETCH { FIRST | NEXT } [ <placeholder-16/> ] { ROW | ROWS } ONLY ]\n"
"    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <placeholder-17/> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n"
"\n"
"<placeholder-18/>\n"
"\n"
"    [ ONLY ] <placeholder-19/> [ * ] [ [ AS ] <placeholder-20/> [ ( <placeholder-21/> [, ...] ) ] ]\n"
"                [ TABLESAMPLE <placeholder-22/> ( <placeholder-23/> [, ...] ) [ REPEATABLE ( <placeholder-24/> ) ] ]\n"
"    [ LATERAL ] ( <placeholder-25/> ) [ AS ] <placeholder-26/> [ ( <placeholder-27/> [, ...] ) ]\n"
"    <placeholder-28/> [ [ AS ] <placeholder-29/> [ ( <placeholder-30/> [, ...] ) ] ]\n"
"    [ LATERAL ] <placeholder-31/> ( [ <placeholder-32/> [, ...] ] )\n"
"                [ WITH ORDINALITY ] [ [ AS ] <placeholder-33/> [ ( <placeholder-34/> [, ...] ) ] ]\n"
"    [ LATERAL ] <placeholder-35/> ( [ <placeholder-36/> [, ...] ] ) [ AS ] <placeholder-37/> ( <placeholder-38/> [, ...] )\n"
"    [ LATERAL ] <placeholder-39/> ( [ <placeholder-40/> [, ...] ] ) AS ( <placeholder-41/> [, ...] )\n"
"    [ LATERAL ] ROWS FROM( <placeholder-42/> ( [ <placeholder-43/> [, ...] ] ) [ AS ( <placeholder-44/> [, ...] ) ] [, ...] )\n"
"                [ WITH ORDINALITY ] [ [ AS ] <placeholder-45/> [ ( <placeholder-46/> [, ...] ) ] ]\n"
"    <placeholder-47/> [ NATURAL ] <placeholder-48/> <placeholder-49/> [ ON <placeholder-50/> | USING ( <placeholder-51/> [, ...] ) ]\n"
"\n"
"<placeholder-52/>\n"
"\n"
"    ( )\n"
"    <placeholder-53/>\n"
"    ( <placeholder-54/> [, ...] )\n"
"    ROLLUP ( { <placeholder-55/> | ( <placeholder-56/> [, ...] ) } [, ...] )\n"
"    CUBE ( { <placeholder-57/> | ( <placeholder-58/> [, ...] ) } [, ...] )\n"
"    GROUPING SETS ( <placeholder-59/> [, ...] )\n"
"\n"
"<placeholder-60/>\n"
"\n"
"    <placeholder-61/> [ ( <placeholder-62/> [, ...] ) ] AS ( <placeholder-63/> | <placeholder-64/> | <placeholder-65/> | <placeholder-66/> | <placeholder-67/> )\n"
"\n"
"TABLE [ ONLY ] <placeholder-68/> [ * ]"
msgstr ""
"[ WITH [ RECURSIVE ] <placeholder-1/> [, ...] ]\n"
"SELECT [ ALL | DISTINCT [ ON ( <placeholder-2/> [, ...] ) ] ]\n"
"    [ * | <placeholder-3/> [ [ AS ] <placeholder-4/> ] [, ...] ]\n"
"    [ FROM <placeholder-5/> [, ...] ]\n"
"    [ WHERE <placeholder-6/> ]\n"
"    [ GROUP BY <placeholder-7/> [, ...] ]\n"
"    [ HAVING <placeholder-8/> [, ...] ]\n"
"    [ WINDOW <placeholder-9/> AS ( <placeholder-10/> ) [, ...] ]\n"
"    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <placeholder-11/> ]\n"
"    [ ORDER BY <placeholder-12/> [ ASC | DESC | USING <placeholder-13/> ] [ NULLS { FIRST | LAST } ] [, ...] ]\n"
"    [ LIMIT { <placeholder-14/> | ALL } ]\n"
"    [ OFFSET <placeholder-15/> [ ROW | ROWS ] ]\n"
"    [ FETCH { FIRST | NEXT } [ <placeholder-16/> ] { ROW | ROWS } ONLY ]\n"
"    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <placeholder-17/> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n"
"\n"
"<placeholder-18/>\n"
"\n"
"    [ ONLY ] <placeholder-19/> [ * ] [ [ AS ] <placeholder-20/> [ ( <placeholder-21/> [, ...] ) ] ]\n"
"                [ TABLESAMPLE <placeholder-22/> ( <placeholder-23/> [, ...] ) [ REPEATABLE ( <placeholder-24/> ) ] ]\n"
"    [ LATERAL ] ( <placeholder-25/> ) [ AS ] <placeholder-26/> [ ( <placeholder-27/> [, ...] ) ]\n"
"    <placeholder-28/> [ [ AS ] <placeholder-29/> [ ( <placeholder-30/> [, ...] ) ] ]\n"
"    [ LATERAL ] <placeholder-31/> ( [ <placeholder-32/> [, ...] ] )\n"
"                [ WITH ORDINALITY ] [ [ AS ] <placeholder-33/> [ ( <placeholder-34/> [, ...] ) ] ]\n"
"    [ LATERAL ] <placeholder-35/> ( [ <placeholder-36/> [, ...] ] ) [ AS ] <placeholder-37/> ( <placeholder-38/> [, ...] )\n"
"    [ LATERAL ] <placeholder-39/> ( [ <placeholder-40/> [, ...] ] ) AS ( <placeholder-41/> [, ...] )\n"
"    [ LATERAL ] ROWS FROM( <placeholder-42/> ( [ <placeholder-43/> [, ...] ] ) [ AS ( <placeholder-44/> [, ...] ) ] [, ...] )\n"
"                [ WITH ORDINALITY ] [ [ AS ] <placeholder-45/> [ ( <placeholder-46/> [, ...] ) ] ]\n"
"    <placeholder-47/> [ NATURAL ] <placeholder-48/> <placeholder-49/> [ ON <placeholder-50/> | USING ( <placeholder-51/> [, ...] ) ]\n"
"\n"
"<placeholder-52/>\n"
"\n"
"    ( )\n"
"    <placeholder-53/>\n"
"    ( <placeholder-54/> [, ...] )\n"
"    ROLLUP ( { <placeholder-55/> | ( <placeholder-56/> [, ...] ) } [, ...] )\n"
"    CUBE ( { <placeholder-57/> | ( <placeholder-58/> [, ...] ) } [, ...] )\n"
"    GROUPING SETS ( <placeholder-59/> [, ...] )\n"
"\n"
"<placeholder-60/>\n"
"\n"
"    <placeholder-61/> [ ( <placeholder-62/> [, ...] ) ] AS ( <placeholder-63/> | <placeholder-64/> | <placeholder-65/> | <placeholder-66/> | <placeholder-67/> )\n"
"\n"
"TABLE [ ONLY ] <placeholder-68/> [ * ]"

#: ref/select.xml:84(title)
msgid "Description"
msgstr "Описание"

#: ref/select.xml:92(para)
msgid ""
"All queries in the <literal>WITH</literal> list are computed. These "
"effectively serve as temporary tables that can be referenced in the "
"<literal>FROM</literal> list. A <literal>WITH</literal> query that is "
"referenced more than once in <literal>FROM</literal> is computed only once. "
"(See <xref linkend=\"sql-with\" endterm=\"sql-with-title\"/> below.)"
msgstr ""
"Выполняются все запросы в списке <literal>WITH</literal>. По сути они "
"формируют временные таблицы, к которым затем можно обращаться в списке "
"<literal>FROM</literal>. Запрос в <literal>WITH</literal> выполняется только "
"один раз, даже если он фигурирует в списке <literal>FROM</literal> "
"неоднократно. (См. <xref remap=\"4\" linkend=\"sql-with\" endterm=\"sql-with-"
"title\"/> ниже.)"

#: ref/select.xml:103(para)
msgid ""
"All elements in the <literal>FROM</literal> list are computed. (Each element "
"in the <literal>FROM</literal> list is a real or virtual table.) If more "
"than one element is specified in the <literal>FROM</literal> list, they are "
"cross-joined together. (See <xref linkend=\"sql-from\" endterm=\"sql-from-"
"title\"/> below.)"
msgstr ""
"Вычисляются все элементы в списке <literal>FROM</literal>. (Каждый элемент в "
"списке <literal>FROM</literal> представляет собой реальную или виртуальную "
"таблицу.) Если список <literal>FROM</literal> содержит несколько элементов, "
"они объединяются перекрёстным соединением. (См. <xref remap=\"4\" linkend="
"\"sql-from\" endterm=\"sql-from-title\"/> ниже.)"

#: ref/select.xml:113(para)
msgid ""
"If the <literal>WHERE</literal> clause is specified, all rows that do not "
"satisfy the condition are eliminated from the output. (See <xref linkend="
"\"sql-where\" endterm=\"sql-where-title\"/> below.)"
msgstr ""
"Если указано предложение <literal>WHERE</literal>, все строки, не "
"удовлетворяющие условию, исключаются из результата. (См. <xref remap=\"4\" "
"linkend=\"sql-where\" endterm=\"sql-where-title\"/> ниже.)"

#: ref/select.xml:122(para)
msgid ""
"If the <literal>GROUP BY</literal> clause is specified, or if there are "
"aggregate function calls, the output is combined into groups of rows that "
"match on one or more values, and the results of aggregate functions are "
"computed. If the <literal>HAVING</literal> clause is present, it eliminates "
"groups that do not satisfy the given condition. (See <xref linkend=\"sql-"
"groupby\" endterm=\"sql-groupby-title\"/> and <xref linkend=\"sql-having\" "
"endterm=\"sql-having-title\"/> below.)"
msgstr ""
"Если присутствует указание <literal>GROUP BY</literal>, либо в запросе "
"вызываются агрегатные функции, вывод разделяется по группам строк, "
"соответствующим одному или нескольким значениям, а затем вычисляются "
"результаты агрегатных функций. Если добавлено предложение <literal>HAVING</"
"literal>, оно исключает группы, не удовлетворяющие заданному условию. (См. "
"<xref remap=\"4\" linkend=\"sql-groupby\" endterm=\"sql-groupby-title\"/> и "
"<xref remap=\"4\" linkend=\"sql-having\" endterm=\"sql-having-title\"/> "
"ниже.)"

#: ref/select.xml:135(para)
msgid ""
"The actual output rows are computed using the <command>SELECT</command> "
"output expressions for each selected row or row group. (See <xref linkend="
"\"sql-select-list\" endterm=\"sql-select-list-title\"/> below.)"
msgstr ""
"Вычисляются фактические выходные строки по заданным в <command>SELECT</"
"command> выражениям для каждой выбранной строки или группы строк. (См. <xref "
"remap=\"4\" linkend=\"sql-select-list\" endterm=\"sql-select-list-title\"/> "
"ниже.)"

#: ref/select.xml:145(para)
msgid ""
"<literal>SELECT DISTINCT</literal> eliminates duplicate rows from the "
"result. <literal>SELECT DISTINCT ON</literal> eliminates rows that match on "
"all the specified expressions. <literal>SELECT ALL</literal> (the default) "
"will return all candidate rows, including duplicates. (See <xref linkend="
"\"sql-distinct\" endterm=\"sql-distinct-title\"/> below.)"
msgstr ""
"<literal>SELECT DISTINCT</literal> исключает из результата повторяющиеся "
"строки. <literal>SELECT DISTINCT ON</literal> исключает строки, совпадающие "
"по всем указанным выражениям. <literal>SELECT ALL</literal> (по умолчанию) "
"возвращает все строки результата, включая дубликаты. (См. <xref remap=\"4\" "
"linkend=\"sql-distinct\" endterm=\"sql-distinct-title\"/> ниже.)"

#: ref/select.xml:155(para)
msgid ""
"Using the operators <literal>UNION</literal>, <literal>INTERSECT</literal>, "
"and <literal>EXCEPT</literal>, the output of more than one <command>SELECT</"
"command> statement can be combined to form a single result set. The "
"<literal>UNION</literal> operator returns all rows that are in one or both "
"of the result sets. The <literal>INTERSECT</literal> operator returns all "
"rows that are strictly in both result sets. The <literal>EXCEPT</literal> "
"operator returns the rows that are in the first result set but not in the "
"second. In all three cases, duplicate rows are eliminated unless "
"<literal>ALL</literal> is specified. The noise word <literal>DISTINCT</"
"literal> can be added to explicitly specify eliminating duplicate rows. "
"Notice that <literal>DISTINCT</literal> is the default behavior here, even "
"though <literal>ALL</literal> is the default for <command>SELECT</command> "
"itself. (See <xref linkend=\"sql-union\" endterm=\"sql-union-title\"/>, "
"<xref linkend=\"sql-intersect\" endterm=\"sql-intersect-title\"/>, and <xref "
"linkend=\"sql-except\" endterm=\"sql-except-title\"/> below.)"
msgstr ""
"Операторы <literal>UNION</literal>, <literal>INTERSECT</literal> и "
"<literal>EXCEPT</literal> объединяют вывод нескольких команд "
"<command>SELECT</command> в один результирующий набор. Оператор "
"<literal>UNION</literal> возвращает все строки, представленные в одном, либо "
"обоих наборах результатов. Оператор <literal>INTERSECT</literal> возвращает "
"все строки, представленные строго в обоих наборах. Оператор <literal>EXCEPT</"
"literal> возвращает все строки, представленные в первом наборе, но не во "
"втором. Во всех трёх случаях повторяющиеся строки исключаются из результата, "
"если явно не указано <literal>ALL</literal>. Чтобы явно обозначить, что "
"выдаваться должны только неповторяющиеся строки, можно добавить избыточное "
"слово <literal>DISTINCT</literal>. Заметьте, что в данном контексте по "
"умолчанию подразумевается <literal>DISTINCT</literal>, хотя в самом "
"<command>SELECT</command> по умолчанию подразумевается <literal>ALL</"
"literal>. (См. <xref remap=\"4\" linkend=\"sql-union\" endterm=\"sql-union-"
"title\"/>, <xref remap=\"4\" linkend=\"sql-intersect\" endterm=\"sql-"
"intersect-title\"/> и <xref remap=\"4\" linkend=\"sql-except\" endterm=\"sql-"
"except-title\"/> ниже.)"

#: ref/select.xml:178(para)
msgid ""
"If the <literal>ORDER BY</literal> clause is specified, the returned rows "
"are sorted in the specified order. If <literal>ORDER BY</literal> is not "
"given, the rows are returned in whatever order the system finds fastest to "
"produce. (See <xref linkend=\"sql-orderby\" endterm=\"sql-orderby-title\"/> "
"below.)"
msgstr ""
"Если присутствует предложение <literal>ORDER BY</literal>, возвращаемые "
"строки сортируются в указанном порядке. В отсутствие <literal>ORDER BY</"
"literal> строки возвращаются в том порядке, в каком системе будет проще их "
"выдать. (См. <xref remap=\"4\" linkend=\"sql-orderby\" endterm=\"sql-orderby-"
"title\"/> ниже.)"

#: ref/select.xml:188(para)
msgid ""
"If the <literal>LIMIT</literal> (or <literal>FETCH FIRST</literal>) or "
"<literal>OFFSET</literal> clause is specified, the <command>SELECT</command> "
"statement only returns a subset of the result rows. (See <xref linkend=\"sql-"
"limit\" endterm=\"sql-limit-title\"/> below.)"
msgstr ""
"Если указано предложение <literal>LIMIT</literal> (или <literal>FETCH FIRST</"
"literal>) либо <literal>OFFSET</literal>, оператор <command>SELECT</command> "
"возвращает только подмножество строк результата. (См. <xref remap=\"4\" "
"linkend=\"sql-limit\" endterm=\"sql-limit-title\"/> ниже.)"

#: ref/select.xml:197(para)
msgid ""
"If <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR SHARE</literal> or <literal>FOR KEY SHARE</literal> is "
"specified, the <command>SELECT</command> statement locks the selected rows "
"against concurrent updates. (See <xref linkend=\"sql-for-update-share\" "
"endterm=\"sql-for-update-share-title\"/> below.)"
msgstr ""
"Если указано <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</"
"literal>, <literal>FOR SHARE</literal> или <literal>FOR KEY SHARE</literal>, "
"оператор <command>SELECT</command> блокирует выбранные строки, защищая их от "
"одновременных изменений. (См. <xref remap=\"4\" linkend=\"sql-for-update-"
"share\" endterm=\"sql-for-update-share-title\"/> ниже.)"

#: ref/select.xml:86(para)
msgid ""
"<command>SELECT</command> retrieves rows from zero or more tables. The "
"general processing of <command>SELECT</command> is as follows: "
"<placeholder-1/>"
msgstr ""
"<command>SELECT</command> получает строки из множества таблиц (возможно, "
"пустого). Общая процедура выполнения <command>SELECT</command> следующая: "
"<placeholder-1/>"

#: ref/select.xml:209(para)
msgid ""
"You must have <literal>SELECT</literal> privilege on each column used in a "
"<command>SELECT</command> command. The use of <literal>FOR NO KEY UPDATE</"
"literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> or "
"<literal>FOR KEY SHARE</literal> requires <literal>UPDATE</literal> "
"privilege as well (for at least one column of each table so selected)."
msgstr ""
"Для всех столбцов, задействованных в команде <command>SELECT</command>, "
"необходимо иметь право <literal>SELECT</literal>. Применение блокировок "
"<literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, "
"<literal>FOR SHARE</literal> или <literal>FOR KEY SHARE</literal> требует "
"также права <literal>UPDATE</literal> (как минимум для одного столбца в "
"каждой выбранной для блокировки таблице)."

#: ref/select.xml:220(title)
msgid "Parameters"
msgstr "Параметры"

#: ref/select.xml:223(title)
msgid "<literal>WITH</literal> Clause"
msgstr "Предложение <literal>WITH</literal>"

#: ref/select.xml:225(para)
msgid ""
"The <literal>WITH</literal> clause allows you to specify one or more "
"subqueries that can be referenced by name in the primary query. The "
"subqueries effectively act as temporary tables or views for the duration of "
"the primary query. Each subquery can be a <command>SELECT</command>, "
"<command>TABLE</command>, <command>VALUES</command>, <command>INSERT</"
"command>, <command>UPDATE</command> or <command>DELETE</command> statement. "
"When writing a data-modifying statement (<command>INSERT</command>, "
"<command>UPDATE</command> or <command>DELETE</command>) in <literal>WITH</"
"literal>, it is usual to include a <literal>RETURNING</literal> clause. It "
"is the output of <literal>RETURNING</literal>, <emphasis>not</emphasis> the "
"underlying table that the statement modifies, that forms the temporary table "
"that is read by the primary query. If <literal>RETURNING</literal> is "
"omitted, the statement is still executed, but it produces no output so it "
"cannot be referenced as a table by the primary query."
msgstr ""
"Предложение <literal>WITH</literal> позволяет задать один или несколько "
"подзапросов, к которым затем можно обратиться по имени в основном запросе. "
"Эти подзапросы по сути действуют как временные таблицы или представления в "
"процессе выполнения главного запроса. Каждый подзапрос может представлять "
"собой оператор <command>SELECT</command>, <command>TABLE</command>, "
"<command>VALUES</command>, <command>INSERT</command>, <command>UPDATE</"
"command> или <command>DELETE</command>. При использовании в <literal>WITH</"
"literal> оператора, изменяющего данные, (<command>INSERT</command>, "
"<command>UPDATE</command> или <command>DELETE</command>) обычно добавляется "
"предложение <literal>RETURNING</literal>. Заметьте, что именно результат "
"<literal>RETURNING</literal>, а <emphasis>не</emphasis> нижележащая таблица, "
"изменяемая запросом, формирует временную таблицу, которую затем читает "
"основной запрос. Если <literal>RETURNING</literal> опущено, оператор, тем не "
"менее, выполняется, но не выдаёт никакого результата, так что на него нельзя "
"сослаться как на таблицу в основном запросе."

#: ref/select.xml:243(para)
msgid ""
"A name (without schema qualification) must be specified for each "
"<literal>WITH</literal> query. Optionally, a list of column names can be "
"specified; if this is omitted, the column names are inferred from the "
"subquery."
msgstr ""
"Имя (без схемы) должно быть указано для каждого запроса <literal>WITH</"
"literal>. Также можно задать необязательный список с именами столбцов; если "
"он опущен, имена столбцов формируются из результата подзапроса."

#: ref/select.xml:250(para)
msgid ""
"If <literal>RECURSIVE</literal> is specified, it allows a <command>SELECT</"
"command> subquery to reference itself by name. Such a subquery must have the "
"form <synopsis>\n"
"<replaceable class=\"parameter\">non_recursive_term</replaceable> UNION "
"[ ALL | DISTINCT ] <replaceable class=\"parameter\">recursive_term</"
"replaceable>\n"
"</synopsis> where the recursive self-reference must appear on the right-hand "
"side of the <literal>UNION</literal>. Only one recursive self-reference is "
"permitted per query. Recursive data-modifying statements are not supported, "
"but you can use the results of a recursive <command>SELECT</command> query "
"in a data-modifying statement. See <xref linkend=\"queries-with\"/> for an "
"example."
msgstr ""
"Если указано <literal>RECURSIVE</literal>, подзапрос <command>SELECT</"
"command> может ссылаться сам на себя по имени. Такой подзапрос должен иметь "
"форму <synopsis>\n"
"<replaceable class=\"parameter\">нерекурсивная_часть</replaceable> UNION "
"[ ALL | DISTINCT ] <replaceable class=\"parameter\">рекурсивная_часть</"
"replaceable>\n"
"</synopsis>, где рекурсивная ссылка на сам запрос может находиться только "
"справа от <literal>UNION</literal>. Для одного запроса допускается только "
"одна рекурсивная ссылка на него же. Операторы, изменяющие данные, не могут "
"быть рекурсивными, но результат рекурсивного запроса <command>SELECT</"
"command> в таких операторах можно использовать. За примером обратитесь к "
"<xref remap=\"3\" linkend=\"queries-with\"/>."

#: ref/select.xml:266(para)
msgid ""
"Another effect of <literal>RECURSIVE</literal> is that <literal>WITH</"
"literal> queries need not be ordered: a query can reference another one that "
"is later in the list. (However, circular references, or mutual recursion, "
"are not implemented.) Without <literal>RECURSIVE</literal>, <literal>WITH</"
"literal> queries can only reference sibling <literal>WITH</literal> queries "
"that are earlier in the <literal>WITH</literal> list."
msgstr ""
"Ещё одна особенность <literal>RECURSIVE</literal> в том, что запросы "
"<literal>WITH</literal> могут быть неупорядоченными: запрос может ссылаться "
"на другой, идущий в списке после него. (Однако циклические ссылки или "
"взаимная рекурсия не поддерживаются.) Без <literal>RECURSIVE</literal> "
"запрос в <literal>WITH</literal> может ссылаться только на запросы того же "
"уровня в <literal>WITH</literal>, предшествующие ему в списке <literal>WITH</"
"literal>."

#: ref/select.xml:276(para)
msgid ""
"A key property of <literal>WITH</literal> queries is that they are evaluated "
"only once per execution of the primary query, even if the primary query "
"refers to them more than once. In particular, data-modifying statements are "
"guaranteed to be executed once and only once, regardless of whether the "
"primary query reads all or any of their output."
msgstr ""
"Ключевое свойство запросов <literal>WITH</literal> состоит в том, что они "
"вычисляются один раз для всего основного запроса, даже если в основном "
"запросе содержатся несколько ссылок на них. В частности, гарантируется, что "
"операторы, изменяющие данные, будут выполняться ровно один раз, вне "
"зависимости от того, будет ли их результат прочитан основным запросом и в "
"каком объёме."

#: ref/select.xml:285(para)
msgid ""
"The primary query and the <literal>WITH</literal> queries are all "
"(notionally) executed at the same time. This implies that the effects of a "
"data-modifying statement in <literal>WITH</literal> cannot be seen from "
"other parts of the query, other than by reading its <literal>RETURNING</"
"literal> output. If two such data-modifying statements attempt to modify the "
"same row, the results are unspecified."
msgstr ""
"Основной запрос и все запросы <literal>WITH</literal>, условно говоря, "
"выполняются одновременно. Это значит, что действие оператора, изменяющего "
"данные в <literal>WITH</literal>, не будут видеть другие части запроса, "
"кроме как прочитав его вывод <literal>RETURNING</literal>. Если два таких "
"оператора попытаются изменить одну строку, результат будет неопределённым."

#: ref/select.xml:294(para)
msgid "See <xref linkend=\"queries-with\"/> for additional information."
msgstr ""
"За дополнительными сведениями обратитесь к <xref remap=\"3\" linkend="
"\"queries-with\"/>."

#: ref/select.xml:300(title)
msgid "<literal>FROM</literal> Clause"
msgstr "Предложение <literal>FROM</literal>"

#: ref/select.xml:302(para)
msgid ""
"The <literal>FROM</literal> clause specifies one or more source tables for "
"the <command>SELECT</command>. If multiple sources are specified, the result "
"is the Cartesian product (cross join) of all the sources. But usually "
"qualification conditions are added (via <literal>WHERE</literal>) to "
"restrict the returned rows to a small subset of the Cartesian product."
msgstr ""
"В предложении <literal>FROM</literal> перечисляются одна или несколько "
"таблиц, служащих источниками данных для <command>SELECT</command>. Если "
"указано несколько источников, результатом будет декартово произведение "
"(перекрёстное соединение) всех их строк. Но обычно в запрос добавляются "
"уточняющие условия (в предложении <literal>WHERE</literal>), которые "
"ограничивают набор строк небольшим подмножеством этого произведения."

#: ref/select.xml:319(para)
msgid ""
"The name (optionally schema-qualified) of an existing table or view. If "
"<literal>ONLY</literal> is specified before the table name, only that table "
"is scanned. If <literal>ONLY</literal> is not specified, the table and all "
"its descendant tables (if any) are scanned. Optionally, <literal>*</literal> "
"can be specified after the table name to explicitly indicate that descendant "
"tables are included."
msgstr ""
"Имя (возможно, дополненное схемой) существующей таблицы или представления. "
"Если перед именем таблицы указано <literal>ONLY</literal>, считывается "
"только заданная таблица. Без <literal>ONLY</literal> считывается и заданная "
"таблица, и все её потомки (если таковые есть). После имени таблицы можно "
"также добавить необязательное указание <literal>*</literal>, чтобы явно "
"обозначить, что блокировка затрагивает и все дочерние таблицы."

#: ref/select.xml:333(para)
msgid ""
"A substitute name for the <literal>FROM</literal> item containing the alias. "
"An alias is used for brevity or to eliminate ambiguity for self-joins (where "
"the same table is scanned multiple times). When an alias is provided, it "
"completely hides the actual name of the table or function; for example given "
"<literal>FROM foo AS f</literal>, the remainder of the <command>SELECT</"
"command> must refer to this <literal>FROM</literal> item as <literal>f</"
"literal> not <literal>foo</literal>. If an alias is written, a column alias "
"list can also be written to provide substitute names for one or more columns "
"of the table."
msgstr ""
"Альтернативное имя для элемента списка <literal>FROM</literal>. Этот "
"псевдоним используется для краткости или для исключения неоднозначности с "
"замкнутыми соединениями (когда одна таблица читается неоднократно). Когда "
"задаётся псевдоним, он полностью скрывает настоящее имя таблицы или функции; "
"например, при записи <literal>FROM foo AS f</literal>, в продолжении запроса "
"<command>SELECT</command> к этому элементу <literal>FROM</literal> нужно "
"обращаться по имени <literal>f</literal>, а не <literal>foo</literal>. Если "
"задан псевдоним таблицы, за ним можно также написать список псевдонимов "
"столбцов, который определит альтернативные имена для столбцов таблицы."

#: ref/select.xml:349(literal)
msgid ""
"TABLESAMPLE <placeholder-1/> ( <placeholder-2/> [, ...] ) [ REPEATABLE "
"( <placeholder-3/> ) ]"
msgstr ""
"TABLESAMPLE <placeholder-1/> ( <placeholder-2/> [, ...] ) [ REPEATABLE "
"( <placeholder-3/> ) ]"

#: ref/select.xml:351(para)
msgid ""
"A <literal>TABLESAMPLE</literal> clause after a <replaceable class="
"\"parameter\">table_name</replaceable> indicates that the specified "
"<replaceable class=\"parameter\">sampling_method</replaceable> should be "
"used to retrieve a subset of the rows in that table. This sampling precedes "
"the application of any other filters such as <literal>WHERE</literal> "
"clauses. The standard <productname>PostgreSQL</productname> distribution "
"includes two sampling methods, <literal>BERNOULLI</literal> and "
"<literal>SYSTEM</literal>, and other sampling methods can be installed in "
"the database via extensions."
msgstr ""
"Предложение <literal>TABLESAMPLE</literal>, сопровождающее <replaceable "
"class=\"parameter\">имя_таблицы</replaceable>, показывает, что для получения "
"подмножества строк в этой таблице должен применяться указанный <replaceable "
"class=\"parameter\">метод_выборки</replaceable>. Эта выборка предшествует "
"применению любых других фильтров, например, в предложении <literal>WHERE</"
"literal>. В стандартный дистрибутив <productname>PostgreSQL</productname> "
"включены два метода выборки, <literal>BERNOULLI</literal> и <literal>SYSTEM</"
"literal>; другие методы выборки можно установить в базу данных через "
"расширения."

#: ref/select.xml:364(para)
msgid ""
"The <literal>BERNOULLI</literal> and <literal>SYSTEM</literal> sampling "
"methods each accept a single <replaceable class=\"parameter\">argument</"
"replaceable> which is the fraction of the table to sample, expressed as a "
"percentage between 0 and 100. This argument can be any <type>real</type>-"
"valued expression. (Other sampling methods might accept more or different "
"arguments.) These two methods each return a randomly-chosen sample of the "
"table that will contain approximately the specified percentage of the "
"table's rows. The <literal>BERNOULLI</literal> method scans the whole table "
"and selects or ignores individual rows independently with the specified "
"probability. The <literal>SYSTEM</literal> method does block-level sampling "
"with each block having the specified chance of being selected; all rows in "
"each selected block are returned. The <literal>SYSTEM</literal> method is "
"significantly faster than the <literal>BERNOULLI</literal> method when small "
"sampling percentages are specified, but it may return a less-random sample "
"of the table as a result of clustering effects."
msgstr ""
"Методы выборки <literal>BERNOULLI</literal> и <literal>SYSTEM</literal> "
"принимают единственный <replaceable class=\"parameter\">аргумент</"
"replaceable>, определяющий, какой процент таблицы должен попасть в выборку, "
"от 0 до 100. Этот аргумент может задаваться любым выражением со значением "
"типа <type>real</type>. (Другие методы выборки могут принимать "
"дополнительные или другие параметры.) Оба этих метода возвращают случайную "
"выборку таблицы, содержащую примерно указанный процент строк таблицы. Метод "
"<literal>BERNOULLI</literal> сканирует всю таблицу и выбирает или игнорирует "
"отдельные строки независимо, с заданной вероятностью. Метод <literal>SYSTEM</"
"literal> строит выборку на уровне блоков, определяя для каждого блока шанс "
"его задействовать, и возвращает все строки из каждого задействуемого блока. "
"Метод <literal>SYSTEM</literal> работает значительно быстрее "
"<literal>BERNOULLI</literal>, когда выбирается небольшой процент строк, но "
"он может выдавать менее случайную выборку таблицу из-за эффектов кучности."

#: ref/select.xml:385(para)
msgid ""
"The optional <literal>REPEATABLE</literal> clause specifies a <replaceable "
"class=\"parameter\">seed</replaceable> number or expression to use for "
"generating random numbers within the sampling method. The seed value can be "
"any non-null floating-point value. Two queries that specify the same seed "
"and <replaceable class=\"parameter\">argument</replaceable> values will "
"select the same sample of the table, if the table has not been changed "
"meanwhile. But different seed values will usually produce different samples. "
"If <literal>REPEATABLE</literal> is not given then a new random sample is "
"selected for each query, based upon a system-generated seed. Note that some "
"add-on sampling methods do not accept <literal>REPEATABLE</literal>, and "
"will always produce new samples on each use."
msgstr ""
"В необязательном предложении <literal>REPEATABLE</literal> задаётся "
"<replaceable class=\"parameter\">затравка</replaceable> — число или "
"выражение, задающее отправное значение для генератора случайных чисел в "
"методе выборки. Значением затравки может быть любое отличное от NULL число с "
"плавающей точкой. Два запроса, в которых указаны одинаковые значения "
"затравки и <replaceable class=\"parameter\">аргумента</replaceable>, выдадут "
"одну и ту же выборку таблицы при условии неизменности содержимого таблицы. "
"Но с разными значениями затравки выборки обычно получаются разными. В "
"отсутствие предложения <literal>REPEATABLE</literal> для каждого запроса "
"выдаётся новая случайная выборка, в зависимости от затравки, сгенерированной "
"системой. Заметьте, что некоторые дополнительные методы выборки не принимают "
"предложение <literal>REPEATABLE</literal> и выдают разные выборки при каждом "
"использовании."

#: ref/select.xml:406(para)
msgid ""
"A sub-<command>SELECT</command> can appear in the <literal>FROM</literal> "
"clause. This acts as though its output were created as a temporary table for "
"the duration of this single <command>SELECT</command> command. Note that the "
"sub-<command>SELECT</command> must be surrounded by parentheses, and an "
"alias <emphasis>must</emphasis> be provided for it. A <xref linkend=\"sql-"
"values\"/> command can also be used here."
msgstr ""
"Предложение <literal>FROM</literal> может содержать вложенный запрос "
"<command>SELECT</command>. Можно считать, что из его результата создаётся "
"временная таблица на время выполнения основной команды <command>SELECT</"
"command>. Заметьте, что вложенный запрос <command>SELECT</command> должен "
"заключаться в скобки и для него <emphasis>должен</emphasis> задаваться "
"псевдоним. Здесь также можно использовать команду <xref linkend=\"sql-values"
"\"/>."

#: ref/select.xml:423(para)
msgid ""
"A <literal>WITH</literal> query is referenced by writing its name, just as "
"though the query's name were a table name. (In fact, the <literal>WITH</"
"literal> query hides any real table of the same name for the purposes of the "
"primary query. If necessary, you can refer to a real table of the same name "
"by schema-qualifying the table's name.) An alias can be provided in the same "
"way as for a table."
msgstr ""
"На запрос <literal>WITH</literal> можно ссылаться по имени, как если бы имя "
"запроса представляло имя таблицы. (На самом деле запрос <literal>WITH</"
"literal> скрывает любую реальную таблицу с тем же именем для основного "
"запроса. Если необходимо обратиться к одноимённой реальной таблице, можно "
"дополнить имя этой таблицы именем схемы.) Для этого имени можно задать "
"псевдоним, так же, как и для имени таблицы."

#: ref/select.xml:438(para)
msgid ""
"Function calls can appear in the <literal>FROM</literal> clause. (This is "
"especially useful for functions that return result sets, but any function "
"can be used.) This acts as though the function's output were created as a "
"temporary table for the duration of this single <command>SELECT</command> "
"command. When the optional <command>WITH ORDINALITY</command> clause is "
"added to the function call, a new column is appended after all the "
"function's output columns with numbering for each row."
msgstr ""
"В предложении <literal>FROM</literal> могут содержаться вызовы функций. (Это "
"особенно полезно для функций, возвращающих множества, но в принципе можно "
"использовать любые функции.) Можно считать, что из результата функции "
"создаётся временная таблица на время выполнения основной команды "
"<command>SELECT</command>. Если вызов функции сопровождается необязательным "
"предложением <command>WITH ORDINALITY</command>, после всех выдаваемых "
"функцией столбцов в вывод добавляется ещё один столбец с номерами строк."

#: ref/select.xml:449(para)
msgid ""
"An alias can be provided in the same way as for a table. If an alias is "
"written, a column alias list can also be written to provide substitute names "
"for one or more attributes of the function's composite return type, "
"including the column added by <literal>ORDINALITY</literal> if present."
msgstr ""
"Псевдоним для функции можно задать так же, как и для таблицы. Если этот "
"псевдоним задан, за ним можно также написать список псевдонимов столбцов, "
"который определит альтернативные имена для атрибутов составного типа "
"результата функции, включая имя столбца, который может быть добавлен "
"предложением <literal>ORDINALITY</literal>."

#: ref/select.xml:458(para)
msgid ""
"Multiple function calls can be combined into a single <literal>FROM</"
"literal>-clause item by surrounding them with <literal>ROWS FROM( ... )</"
"literal>. The output of such an item is the concatenation of the first row "
"from each function, then the second row from each function, etc. If some of "
"the functions produce fewer rows than others, null values are substituted "
"for the missing data, so that the total number of rows returned is always "
"the same as for the function that produced the most rows."
msgstr ""
"Несколько вызовов функций можно объединить в одном элементе предложения "
"<literal>FROM</literal>, заключив их в конструкцию <literal>ROWS "
"FROM( ... )</literal>. Выводом такого элемента будет соединение первых строк "
"всех функций, затем вторых строк и т. д. Если одни функции выдают меньше "
"строк, чем другие, недостающие данные заменяются значениями NULL, так что "
"общее число возвращаемых строк всегда будет равняться максимальному числу "
"строк из возвращённых всеми функциями."

#: ref/select.xml:469(para)
msgid ""
"If the function has been defined as returning the <type>record</type> data "
"type, then an alias or the key word <literal>AS</literal> must be present, "
"followed by a column definition list in the form <literal>( <replaceable "
"class=\"parameter\">column_name</replaceable> <replaceable class=\"parameter"
"\">data_type</replaceable> <optional>, ... </optional>)</literal>. The "
"column definition list must match the actual number and types of columns "
"returned by the function."
msgstr ""
"Если функция определена как возвращающая тип данных <type>record</type>, для "
"неё нужно указать псевдоним или ключевое слово <literal>AS</literal>, за "
"которым должен идти список определений столбцов в форме "
"<literal>( <replaceable class=\"parameter\">имя_столбца</replaceable> "
"<replaceable class=\"parameter\">тип_данных</replaceable> <optional>, ... </"
"optional>)</literal>. Список определений столбцов должен соответствовать "
"фактическому количеству и типу столбцов, возвращаемых функцией."

#: ref/select.xml:480(para)
msgid ""
"When using the <literal>ROWS FROM( ... )</literal> syntax, if one of the "
"functions requires a column definition list, it's preferred to put the "
"column definition list after the function call inside <literal>ROWS "
"FROM( ... )</literal>. A column definition list can be placed after the "
"<literal>ROWS FROM( ... )</literal> construct only if there's just a single "
"function and no <literal>WITH ORDINALITY</literal> clause."
msgstr ""
"Если при использовании синтаксиса <literal>ROWS FROM( ... )</literal> одна "
"из функций требует наличия списка определений столбцов, этот список лучше "
"разместить после вызова функции внутри <literal>ROWS FROM( ... )</literal>. "
"Список определений столбцов можно поместить после конструкции <literal>ROWS "
"FROM( ... )</literal>, только если вызывается всего одна функция, а "
"предложение <literal>WITH ORDINALITY</literal> отсутствует."

#: ref/select.xml:489(para)
msgid ""
"To use <literal>ORDINALITY</literal> together with a column definition list, "
"you must use the <literal>ROWS FROM( ... )</literal> syntax and put the "
"column definition list inside <literal>ROWS FROM( ... )</literal>."
msgstr ""
"Чтобы использовать <literal>ORDINALITY</literal> со списком определений "
"столбцов, необходимо применить запись <literal>ROWS FROM( ... )</literal> и "
"поместить список с определениями столбцов внутрь <literal>ROWS FROM( ... )</"
"literal>."

#: ref/select.xml:504(literal)
msgid "[ INNER ] JOIN"
msgstr "[ INNER ] JOIN"

#: ref/select.xml:507(literal)
msgid "LEFT [ OUTER ] JOIN"
msgstr "LEFT [ OUTER ] JOIN"

#: ref/select.xml:510(literal)
msgid "RIGHT [ OUTER ] JOIN"
msgstr "RIGHT [ OUTER ] JOIN"

#: ref/select.xml:513(literal)
msgid "FULL [ OUTER ] JOIN"
msgstr "FULL [ OUTER ] JOIN"

#: ref/select.xml:516(literal)
msgid "CROSS JOIN"
msgstr "CROSS JOIN"

#: ref/select.xml:500(para)
msgid ""
"One of <placeholder-1/> For the <literal>INNER</literal> and <literal>OUTER</"
"literal> join types, a join condition must be specified, namely exactly one "
"of <literal>NATURAL</literal>, <literal>ON <replaceable class=\"parameter"
"\">join_condition</replaceable></literal>, or <literal>USING (<replaceable "
"class=\"parameter\">join_column</replaceable> [, ...])</literal>. See below "
"for the meaning. For <literal>CROSS JOIN</literal>, none of these clauses "
"can appear."
msgstr ""
"Один из следующих вариантов: <placeholder-1/> Для типов соединений "
"<literal>INNER</literal> и <literal>OUTER</literal> необходимо указать "
"условие соединения, а именно одно из предложений <literal>NATURAL</literal>, "
"<literal>ON <replaceable class=\"parameter\">условие_соединения</"
"replaceable></literal> или <literal>USING (<replaceable class=\"parameter"
"\">столбец_соединения</replaceable> [, ...])</literal>. Эти предложения "
"описываются ниже. Для <literal>CROSS JOIN</literal> ни одно из этих "
"предложений не допускается."

#: ref/select.xml:530(para)
msgid ""
"A <literal>JOIN</literal> clause combines two <literal>FROM</literal> items, "
"which for convenience we will refer to as <quote>tables</quote>, though in "
"reality they can be any type of <literal>FROM</literal> item. Use "
"parentheses if necessary to determine the order of nesting. In the absence "
"of parentheses, <literal>JOIN</literal>s nest left-to-right. In any case "
"<literal>JOIN</literal> binds more tightly than the commas separating "
"<literal>FROM</literal>-list items."
msgstr ""
"Предложение <literal>JOIN</literal> объединяет два элемента списка "
"<literal>FROM</literal>, которые мы для простоты дальше будем называть "
"<quote>таблицами</quote>, хотя на самом деле это может быть любой объект, "
"допустимый в качестве элемента <literal>FROM</literal>. Для определения "
"порядка вложенности при необходимости следует использовать скобки. В "
"отсутствие скобок предложения <literal>JOIN</literal> обрабатывается слева "
"направо. В любом случае, <literal>JOIN</literal> связывает элементы сильнее, "
"чем запятые, разделяющие элементы в списке <literal>FROM</literal>."

#: ref/select.xml:540(para)
msgid ""
"<literal>CROSS JOIN</literal> and <literal>INNER JOIN</literal> produce a "
"simple Cartesian product, the same result as you get from listing the two "
"tables at the top level of <literal>FROM</literal>, but restricted by the "
"join condition (if any). <literal>CROSS JOIN</literal> is equivalent to "
"<literal>INNER JOIN ON (TRUE)</literal>, that is, no rows are removed by "
"qualification. These join types are just a notational convenience, since "
"they do nothing you couldn't do with plain <literal>FROM</literal> and "
"<literal>WHERE</literal>."
msgstr ""
"<literal>CROSS JOIN</literal> и <literal>INNER JOIN</literal> формируют "
"простое декартово произведение, то же, что можно получить, указав две "
"таблицы на верхнем уровне <literal>FROM</literal>, но ограниченное возможным "
"условием соединения. Предложение <literal>CROSS JOIN</literal> равнозначно "
"<literal>INNER JOIN ON (TRUE)</literal>, то есть, никакие строки по условию "
"не удаляются. Эти типы соединений введены исключительно для удобства записи, "
"они не дают ничего такого, что нельзя было бы получить, используя просто "
"<literal>FROM</literal> и <literal>WHERE</literal>."

#: ref/select.xml:551(para)
msgid ""
"<literal>LEFT OUTER JOIN</literal> returns all rows in the qualified "
"Cartesian product (i.e., all combined rows that pass its join condition), "
"plus one copy of each row in the left-hand table for which there was no "
"right-hand row that passed the join condition. This left-hand row is "
"extended to the full width of the joined table by inserting null values for "
"the right-hand columns. Note that only the <literal>JOIN</literal> clause's "
"own condition is considered while deciding which rows have matches. Outer "
"conditions are applied afterwards."
msgstr ""
"<literal>LEFT OUTER JOIN</literal> возвращает все строки ограниченного "
"декартова произведения (т. е. все объединённые строки, удовлетворяющие "
"условию соединения) плюс все строки в таблице слева, для которых не "
"находится строк в таблице справа, удовлетворяющих условию. Строка, взятая из "
"таблицы слева, дополняется до полной ширины объединённой таблицы значениями "
"NULL в столбцах таблицы справа. Заметьте, что для определения, какие строки "
"двух таблиц соответствуют друг другу, проверяется только условие самого "
"предложения <literal>JOIN</literal>. Внешние условия проверяются позже."

#: ref/select.xml:562(para)
msgid ""
"Conversely, <literal>RIGHT OUTER JOIN</literal> returns all the joined rows, "
"plus one row for each unmatched right-hand row (extended with nulls on the "
"left). This is just a notational convenience, since you could convert it to "
"a <literal>LEFT OUTER JOIN</literal> by switching the left and right tables."
msgstr ""
"<literal>RIGHT OUTER JOIN</literal>, напротив, возвращает все соединённые "
"строки плюс одну строку для каждой строки справа, не имеющей соответствия "
"слева (эта строка дополняется значениями NULL влево). Это предложение "
"введено исключительно для удобства записи, так как его можно легко свести к "
"<literal>LEFT OUTER JOIN</literal>, поменяв левую и правую таблицы местами."

#: ref/select.xml:570(para)
msgid ""
"<literal>FULL OUTER JOIN</literal> returns all the joined rows, plus one row "
"for each unmatched left-hand row (extended with nulls on the right), plus "
"one row for each unmatched right-hand row (extended with nulls on the left)."
msgstr ""
"<literal>FULL OUTER JOIN</literal> возвращает все соединённые строки плюс "
"все строки слева, не имеющие соответствия справа, (дополненные значениями "
"NULL вправо) плюс все строки справа, не имеющие соответствия слева "
"(дополненные значениями NULL влево)."

#: ref/select.xml:579(literal)
msgid "ON <placeholder-1/>"
msgstr "ON <placeholder-1/>"

#: ref/select.xml:581(para)
msgid ""
"<replaceable class=\"parameter\">join_condition</replaceable> is an "
"expression resulting in a value of type <type>boolean</type> (similar to a "
"<literal>WHERE</literal> clause) that specifies which rows in a join are "
"considered to match."
msgstr ""
"Задаваемое <replaceable class=\"parameter\">условие_соединения</replaceable> "
"представляет собой выражение, выдающее значение типа <type>boolean</type> "
"(как в предложении <literal>WHERE</literal>), которое определяет, какие "
"строки считаются соответствующими при соединении."

#: ref/select.xml:591(literal)
msgid "USING ( <placeholder-1/> [, ...] )"
msgstr "USING ( <placeholder-1/> [, ...] )"

#: ref/select.xml:593(para)
msgid ""
"A clause of the form <literal>USING ( a, b, ... )</literal> is shorthand for "
"<literal>ON left_table.a = right_table.a AND left_table.b = right_table.b ..."
"</literal>. Also, <literal>USING</literal> implies that only one of each "
"pair of equivalent columns will be included in the join output, not both."
msgstr ""
"Предложение вида <literal>USING ( a, b, ... )</literal> представляет собой "
"сокращённую форму записи <literal>ON таблица_слева.a = таблица_справа.a AND "
"таблица_слева.b = таблица_справа.b ...</literal>. Кроме того, "
"<literal>USING</literal> подразумевает, что в результат соединения будет "
"включён только один из пары равных столбцов, но не оба."

#: ref/select.xml:605(literal)
msgid "NATURAL"
msgstr "NATURAL"

#: ref/select.xml:607(para)
#, fuzzy
msgid ""
"<literal>NATURAL</literal> is shorthand for a <literal>USING</literal> list "
"that mentions all columns in the two tables that have matching names. If "
"there are no common column names, <literal>NATURAL</literal> is equivalent "
"to <literal>ON TRUE</literal>."
msgstr ""
"<literal>NATURAL</literal> представляет собой краткую запись <literal>USING</"
"literal> со списком, в котором перечисляются все столбцы двух таблиц, "
"имеющие одинаковые имена."

#: ref/select.xml:618(literal)
msgid "LATERAL"
msgstr "LATERAL"

#: ref/select.xml:620(para)
msgid ""
"The <literal>LATERAL</literal> key word can precede a sub-<command>SELECT</"
"command> <literal>FROM</literal> item. This allows the sub-<command>SELECT</"
"command> to refer to columns of <literal>FROM</literal> items that appear "
"before it in the <literal>FROM</literal> list. (Without <literal>LATERAL</"
"literal>, each sub-<command>SELECT</command> is evaluated independently and "
"so cannot cross-reference any other <literal>FROM</literal> item.)"
msgstr ""
"Ключевое слово <literal>LATERAL</literal> может предварять вложенный запрос "
"<command>SELECT</command> в списке <literal>FROM</literal>. Оно позволяет "
"обращаться в этом вложенном <command>SELECT</command> к столбцам элементов "
"<literal>FROM</literal>, предшествующим ему в списке <literal>FROM</"
"literal>. (Без <literal>LATERAL</literal> все вложенные подзапросы "
"<command>SELECT</command> обрабатываются независимо и не могут ссылаться на "
"другие элементы списка <literal>FROM</literal>.)"

#: ref/select.xml:630(para)
msgid ""
"<literal>LATERAL</literal> can also precede a function-call <literal>FROM</"
"literal> item, but in this case it is a noise word, because the function "
"expression can refer to earlier <literal>FROM</literal> items in any case."
msgstr ""
"Слово <literal>LATERAL</literal> можно также добавить перед вызовом функции "
"в списке <literal>FROM</literal>, но в этом случае оно будет избыточным, так "
"как выражения с функциями могут ссылаться на предыдущие элементы списка "
"<literal>FROM</literal> в любом случае."

#: ref/select.xml:636(para)
msgid ""
"A <literal>LATERAL</literal> item can appear at top level in the "
"<literal>FROM</literal> list, or within a <literal>JOIN</literal> tree. In "
"the latter case it can also refer to any items that are on the left-hand "
"side of a <literal>JOIN</literal> that it is on the right-hand side of."
msgstr ""
"Элемент <literal>LATERAL</literal> может находиться на верхнем уровне списка "
"<literal>FROM</literal> или в дереве <literal>JOIN</literal>. В последнем "
"случае он может также ссылаться на любые элементы в левой части "
"<literal>JOIN</literal>, справа от которого он находится."

#: ref/select.xml:643(para)
msgid ""
"When a <literal>FROM</literal> item contains <literal>LATERAL</literal> "
"cross-references, evaluation proceeds as follows: for each row of the "
"<literal>FROM</literal> item providing the cross-referenced column(s), or "
"set of rows of multiple <literal>FROM</literal> items providing the columns, "
"the <literal>LATERAL</literal> item is evaluated using that row or row set's "
"values of the columns. The resulting row(s) are joined as usual with the "
"rows they were computed from. This is repeated for each row or set of rows "
"from the column source table(s)."
msgstr ""
"Когда элемент <literal>FROM</literal> содержит ссылки <literal>LATERAL</"
"literal>, запрос выполняется следующим образом: сначала для строки элемента "
"<literal>FROM</literal> с целевыми столбцами, или набора строк из нескольких "
"элементов <literal>FROM</literal>, содержащих целевые столбцы, вычисляется "
"элемент <literal>LATERAL</literal> со значениями этих столбцов. Затем "
"результирующие строки обычным образом соединяются со строками, из которых "
"они были вычислены. Эта процедура повторяется для всех строк исходных таблиц."

#: ref/select.xml:654(para)
msgid ""
"The column source table(s) must be <literal>INNER</literal> or "
"<literal>LEFT</literal> joined to the <literal>LATERAL</literal> item, else "
"there would not be a well-defined set of rows from which to compute each set "
"of rows for the <literal>LATERAL</literal> item. Thus, although a construct "
"such as <literal><replaceable>X</replaceable> RIGHT JOIN LATERAL "
"<replaceable>Y</replaceable></literal> is syntactically valid, it is not "
"actually allowed for <replaceable>Y</replaceable> to reference "
"<replaceable>X</replaceable>."
msgstr ""
"Таблица, служащая источником столбцов, должна быть связана с элементом "
"<literal>LATERAL</literal> соединением <literal>INNER</literal> или "
"<literal>LEFT</literal>, в противном случае не образуется однозначно "
"определяемый набор строк, из которого можно будет получать наборы строк для "
"элемента <literal>LATERAL</literal>. Таким образом, хотя конструкция "
"<literal><replaceable>X</replaceable> RIGHT JOIN LATERAL <replaceable>Y</"
"replaceable></literal> синтаксически правильная, <replaceable>Y</"
"replaceable> в ней не может обращаться к <replaceable>X</replaceable>."

#: ref/select.xml:311(para)
msgid ""
"The <literal>FROM</literal> clause can contain the following elements: "
"<placeholder-1/>"
msgstr ""
"Предложение <literal>FROM</literal> может содержать следующие элементы: "
"<placeholder-1/>"

#: ref/select.xml:671(title)
msgid "<literal>WHERE</literal> Clause"
msgstr "Предложение <literal>WHERE</literal>"

#: ref/select.xml:673(para)
msgid ""
"The optional <literal>WHERE</literal> clause has the general form "
"<synopsis>\n"
"WHERE <replaceable class=\"parameter\">condition</replaceable>\n"
"</synopsis> where <replaceable class=\"parameter\">condition</replaceable> "
"is any expression that evaluates to a result of type <type>boolean</type>. "
"Any row that does not satisfy this condition will be eliminated from the "
"output. A row satisfies the condition if it returns true when the actual row "
"values are substituted for any variable references."
msgstr ""
"Необязательное предложение <literal>WHERE</literal> имеет общую форму "
"<synopsis>\n"
"WHERE <replaceable class=\"parameter\">условие</replaceable>\n"
"</synopsis>, где <replaceable class=\"parameter\">условие</replaceable> — "
"любое выражение, выдающее результат типа <type>boolean</type>. Любая строка, "
"не удовлетворяющая этому условию, исключается из результата. Строка "
"удовлетворяет условию, если оно возвращает true при подстановке вместо "
"ссылок на переменные фактических значений из этой строки."

#: ref/select.xml:688(title)
msgid "<literal>GROUP BY</literal> Clause"
msgstr "Предложение <literal>GROUP BY</literal>"

#: ref/select.xml:690(para)
msgid ""
"The optional <literal>GROUP BY</literal> clause has the general form "
"<synopsis>\n"
"GROUP BY <replaceable class=\"parameter\">grouping_element</replaceable> "
"[, ...]\n"
"</synopsis>"
msgstr ""
"Необязательное предложение <literal>GROUP BY</literal> имеет общую форму "
"<synopsis>\n"
"GROUP BY <replaceable class=\"parameter\">элемент_группирования</"
"replaceable> [, ...]\n"
"</synopsis>"

#: ref/select.xml:697(para)
msgid ""
"<literal>GROUP BY</literal> will condense into a single row all selected "
"rows that share the same values for the grouped expressions. An <replaceable "
"class=\"parameter\">expression</replaceable> used inside a <replaceable "
"class=\"parameter\">grouping_element</replaceable> can be an input column "
"name, or the name or ordinal number of an output column (<command>SELECT</"
"command> list item), or an arbitrary expression formed from input-column "
"values. In case of ambiguity, a <literal>GROUP BY</literal> name will be "
"interpreted as an input-column name rather than an output column name."
msgstr ""
"<literal>GROUP BY</literal> собирает в одну строку все выбранные строки, "
"выдающие одинаковые значения для выражений группировки. В качестве "
"<replaceable class=\"parameter\">выражения</replaceable> внутри <replaceable "
"class=\"parameter\">элемента_группирования</replaceable> может выступать имя "
"входного столбца, либо имя или порядковый номер выходного столбца (из списка "
"элементов <command>SELECT</command>), либо произвольное значение, "
"вычисляемое по значениям входных столбцов. В случае неоднозначности имя в "
"<literal>GROUP BY</literal> будет восприниматься как имя входного, а не "
"выходного столбца."

#: ref/select.xml:710(para)
msgid ""
"If any of <literal>GROUPING SETS</literal>, <literal>ROLLUP</literal> or "
"<literal>CUBE</literal> are present as grouping elements, then the "
"<literal>GROUP BY</literal> clause as a whole defines some number of "
"independent <replaceable>grouping sets</replaceable>. The effect of this is "
"equivalent to constructing a <literal>UNION ALL</literal> between subqueries "
"with the individual grouping sets as their <literal>GROUP BY</literal> "
"clauses. For further details on the handling of grouping sets see <xref "
"linkend=\"queries-grouping-sets\"/>."
msgstr ""
"Если в элементе группирования задаётся <literal>GROUPING SETS</literal>, "
"<literal>ROLLUP</literal> или <literal>CUBE</literal>, предложение "
"<literal>GROUP BY</literal> в целом определяет некоторое число независимых "
"<replaceable>наборов группирования</replaceable>. Это даёт тот же эффект, "
"что и объединение подзапросов (с <literal>UNION ALL</literal>) с отдельными "
"наборами группирования в их предложениях <literal>GROUP BY</literal>. "
"Подробнее использование наборов группирования описывается в <xref remap="
"\"6\" linkend=\"queries-grouping-sets\"/>."

#: ref/select.xml:721(para)
msgid ""
"Aggregate functions, if any are used, are computed across all rows making up "
"each group, producing a separate value for each group. (If there are "
"aggregate functions but no <literal>GROUP BY</literal> clause, the query is "
"treated as having a single group comprising all the selected rows.) The set "
"of rows fed to each aggregate function can be further filtered by attaching "
"a <literal>FILTER</literal> clause to the aggregate function call; see <xref "
"linkend=\"syntax-aggregates\"/> for more information. When a "
"<literal>FILTER</literal> clause is present, only those rows matching it are "
"included in the input to that aggregate function."
msgstr ""
"Агрегатные функции, если они используются, вычисляются по всем строкам, "
"составляющим каждую группу, и в итоге выдают отдельное значение для каждой "
"группы. (Если агрегатные функции используются без предложения <literal>GROUP "
"BY</literal>, запрос выполняется как с одной группой, включающей все "
"выбранные строки.) Набор строк, поступающих в каждую агрегатную функцию, "
"можно дополнительно отфильтровать, добавив предложение <literal>FILTER</"
"literal> к вызову агрегатной функции; за дополнительными сведениями "
"обратитесь к <xref remap=\"3\" linkend=\"syntax-aggregates\"/>. С "
"предложением <literal>FILTER</literal> на вход агрегатной функции поступают "
"только те строки, которые соответствуют заданному фильтру."

#: ref/select.xml:734(para)
msgid ""
"When <literal>GROUP BY</literal> is present, or any aggregate functions are "
"present, it is not valid for the <command>SELECT</command> list expressions "
"to refer to ungrouped columns except within aggregate functions or when the "
"ungrouped column is functionally dependent on the grouped columns, since "
"there would otherwise be more than one possible value to return for an "
"ungrouped column. A functional dependency exists if the grouped columns (or "
"a subset thereof) are the primary key of the table containing the ungrouped "
"column."
msgstr ""
"Когда в запросе присутствует предложение <literal>GROUP BY</literal> или "
"какая-либо агрегатная функция, выражения в списке <command>SELECT</command> "
"не могут обращаться к негруппируемым столбцам, кроме как в агрегатных "
"функциях или в случае функциональной зависимости, так как иначе в "
"негруппируемом столбце нужно было бы вернуть более одного возможного "
"значения. Функциональная зависимость образуется, если группируемые столбцы "
"(или их подмножество) составляют первичный ключ таблицы, содержащей "
"негруппируемый столбец."

#: ref/select.xml:746(para)
msgid ""
"Keep in mind that all aggregate functions are evaluated before evaluating "
"any <quote>scalar</quote> expressions in the <literal>HAVING</literal> "
"clause or <literal>SELECT</literal> list. This means that, for example, a "
"<literal>CASE</literal> expression cannot be used to skip evaluation of an "
"aggregate function; see <xref linkend=\"syntax-express-eval\"/>."
msgstr ""
"Имейте в виду, что все агрегатные функции вычисляются перед "
"<quote>скалярными</quote> выражениями в предложении <literal>HAVING</"
"literal> или списке <literal>SELECT</literal>. Это значит, что например, с "
"помощью выражения <literal>CASE</literal> нельзя обойти вычисление "
"агрегатной функции; см. <xref remap=\"4\" linkend=\"syntax-express-eval\"/>."

#: ref/select.xml:754(para)
msgid ""
"Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</"
"literal>, <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> "
"cannot be specified with <literal>GROUP BY</literal>."
msgstr ""
"В настоящее время указания <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> и <literal>FOR "
"KEY SHARE</literal> нельзя задать вместе с <literal>GROUP BY</literal>."

#: ref/select.xml:762(title)
msgid "<literal>HAVING</literal> Clause"
msgstr "Предложение <literal>HAVING</literal>"

#: ref/select.xml:764(para)
msgid ""
"The optional <literal>HAVING</literal> clause has the general form "
"<synopsis>\n"
"HAVING <replaceable class=\"parameter\">condition</replaceable>\n"
"</synopsis> where <replaceable class=\"parameter\">condition</replaceable> "
"is the same as specified for the <literal>WHERE</literal> clause."
msgstr ""
"Необязательное предложение <literal>HAVING</literal> имеет общую форму "
"<synopsis>\n"
"HAVING <replaceable class=\"parameter\">условие</replaceable>\n"
"</synopsis> Здесь <replaceable class=\"parameter\">условие</replaceable> "
"задаётся так же, как и для предложения <literal>WHERE</literal>."

#: ref/select.xml:773(para)
msgid ""
"<literal>HAVING</literal> eliminates group rows that do not satisfy the "
"condition. <literal>HAVING</literal> is different from <literal>WHERE</"
"literal>: <literal>WHERE</literal> filters individual rows before the "
"application of <literal>GROUP BY</literal>, while <literal>HAVING</literal> "
"filters group rows created by <literal>GROUP BY</literal>. Each column "
"referenced in <replaceable class=\"parameter\">condition</replaceable> must "
"unambiguously reference a grouping column, unless the reference appears "
"within an aggregate function or the ungrouped column is functionally "
"dependent on the grouping columns."
msgstr ""
"<literal>HAVING</literal> исключает из результата строки групп, не "
"удовлетворяющих условию. <literal>HAVING</literal> отличается от "
"<literal>WHERE</literal>: <literal>WHERE</literal> фильтрует отдельные "
"строки до применения <literal>GROUP BY</literal>, а <literal>HAVING</"
"literal> фильтрует строки групп, созданных предложением <literal>GROUP BY</"
"literal>. Каждый столбец, фигурирующий в <replaceable class=\"parameter"
"\">условии</replaceable>, должен однозначно ссылаться на группируемый "
"столбец, за исключением случаев, когда эта ссылка находится внутри "
"агрегатной функции или негруппируемый столбец функционально зависит от "
"группируемых."

#: ref/select.xml:786(para)
msgid ""
"The presence of <literal>HAVING</literal> turns a query into a grouped query "
"even if there is no <literal>GROUP BY</literal> clause. This is the same as "
"what happens when the query contains aggregate functions but no "
"<literal>GROUP BY</literal> clause. All the selected rows are considered to "
"form a single group, and the <command>SELECT</command> list and "
"<literal>HAVING</literal> clause can only reference table columns from "
"within aggregate functions. Such a query will emit a single row if the "
"<literal>HAVING</literal> condition is true, zero rows if it is not true."
msgstr ""
"В присутствие <literal>HAVING</literal> запрос превращается в группируемый, "
"даже если <literal>GROUP BY</literal> отсутствует. То же самое происходит, "
"когда запрос содержит агрегатные функции, но не предложение <literal>GROUP "
"BY</literal>. Все выбранные строки считаются формирующими одну группу, а в "
"списке <command>SELECT</command> и предложении <literal>HAVING</literal> "
"можно обращаться к столбцам таблицы только из агрегатных функций. Такой "
"запрос будет выдавать единственную строку, если результат условия "
"<literal>HAVING</literal> — true, и ноль строк в противном случае."

#: ref/select.xml:797(para)
msgid ""
"Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</"
"literal>, <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> "
"cannot be specified with <literal>HAVING</literal>."
msgstr ""
"В настоящее время указания <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> и <literal>FOR "
"KEY SHARE</literal> нельзя задать вместе с <literal>HAVING</literal>."

#: ref/select.xml:805(title)
msgid "<literal>WINDOW</literal> Clause"
msgstr "Предложение <literal>WINDOW</literal>"

#: ref/select.xml:807(para)
msgid ""
"The optional <literal>WINDOW</literal> clause has the general form "
"<synopsis>\n"
"WINDOW <replaceable class=\"parameter\">window_name</replaceable> AS "
"( <replaceable class=\"parameter\">window_definition</replaceable> ) "
"[, ...]\n"
"</synopsis> where <replaceable class=\"parameter\">window_name</replaceable> "
"is a name that can be referenced from <literal>OVER</literal> clauses or "
"subsequent window definitions, and <replaceable class=\"parameter"
"\">window_definition</replaceable> is <synopsis>\n"
"[ <replaceable class=\"parameter\">existing_window_name</replaceable> ]\n"
"[ PARTITION BY <replaceable class=\"parameter\">expression</replaceable> "
"[, ...] ]\n"
"[ ORDER BY <replaceable class=\"parameter\">expression</replaceable> [ ASC | "
"DESC | USING <replaceable class=\"parameter\">operator</replaceable> ] "
"[ NULLS { FIRST | LAST } ] [, ...] ]\n"
"[ <replaceable class=\"parameter\">frame_clause</replaceable> ]\n"
"</synopsis>"
msgstr ""
"Необязательное предложение <literal>WINDOW</literal> имеет общую форму "
"<synopsis>\n"
"WINDOW <replaceable class=\"parameter\">имя_окна</replaceable> AS "
"( <replaceable class=\"parameter\">определение_окна</replaceable> ) [, ...]\n"
"</synopsis> Здесь <replaceable class=\"parameter\">имя_окна</replaceable> — "
"это имя, на которое можно ссылаться из предложений <literal>OVER</literal> "
"или последующих определений окон, а <replaceable class=\"parameter"
"\">определение_окна</replaceable> имеет следующий вид: <synopsis>\n"
"[ <replaceable class=\"parameter\">имя_существующего_окна</replaceable> ]\n"
"[ PARTITION BY <replaceable class=\"parameter\">выражение</replaceable> "
"[, ...] ]\n"
"[ ORDER BY <replaceable class=\"parameter\">выражение</replaceable> [ ASC | "
"DESC | USING <replaceable class=\"parameter\">оператор</replaceable> ] "
"[ NULLS { FIRST | LAST } ] [, ...] ]\n"
"[ <replaceable class=\"parameter\">предложение_рамки</replaceable> ]\n"
"</synopsis>"

#: ref/select.xml:824(para)
msgid ""
"If an <replaceable class=\"parameter\">existing_window_name</replaceable> is "
"specified it must refer to an earlier entry in the <literal>WINDOW</literal> "
"list; the new window copies its partitioning clause from that entry, as well "
"as its ordering clause if any. In this case the new window cannot specify "
"its own <literal>PARTITION BY</literal> clause, and it can specify "
"<literal>ORDER BY</literal> only if the copied window does not have one. The "
"new window always uses its own frame clause; the copied window must not "
"specify a frame clause."
msgstr ""
"Если указано <replaceable class=\"parameter\">имя_существующего_окна</"
"replaceable>, оно должно ссылаться на предшествующую запись в списке "
"<literal>WINDOW</literal>; новое окно копирует предложение разбиения из этой "
"записи, а также предложение сортировки, если оно присутствует. В этом случае "
"для нового окна нельзя задать собственное предложение <literal>PARTITION BY</"
"literal>, а <literal>ORDER BY</literal> можно указать, только если его не "
"было у копируемого окна. Новое окно всегда использует собственное "
"предложение рамки; в копируемом окне оно задаваться не должно."

#: ref/select.xml:835(para)
msgid ""
"The elements of the <literal>PARTITION BY</literal> list are interpreted in "
"much the same fashion as elements of a <xref linkend=\"sql-groupby\" endterm="
"\"sql-groupby-title\"/>, except that they are always simple expressions and "
"never the name or number of an output column. Another difference is that "
"these expressions can contain aggregate function calls, which are not "
"allowed in a regular <literal>GROUP BY</literal> clause. They are allowed "
"here because windowing occurs after grouping and aggregation."
msgstr ""
"Элементы списка <literal>PARTITION BY</literal> интерпретируется во многом "
"так же, как и элементы <xref remap=\"2\" linkend=\"sql-groupby\" endterm="
"\"sql-groupby-title\"/>, за исключением того, что это всегда простые "
"выражения, но не имя или номер выходного столбца. Другое различие состоит в "
"том, что эти выражения могут содержать вызовы агрегатных функций, которые не "
"допускаются в обычном предложении <literal>GROUP BY</literal>. Здесь они "
"допускаются потому, что формирование окна происходит после группировки и "
"агрегирования."

#: ref/select.xml:847(para)
msgid ""
"Similarly, the elements of the <literal>ORDER BY</literal> list are "
"interpreted in much the same fashion as elements of an <xref linkend=\"sql-"
"orderby\" endterm=\"sql-orderby-title\"/>, except that the expressions are "
"always taken as simple expressions and never the name or number of an output "
"column."
msgstr ""
"Подобным образом, элементы списка <literal>ORDER BY</literal> "
"интерпретируются во многом так же, как и элементы <xref remap=\"2\" linkend="
"\"sql-orderby\" endterm=\"sql-orderby-title\"/>, за исключением того, что "
"выражения в нём всегда принимаются как простые выражения, но не как имя или "
"номер выходного столбца."

#: ref/select.xml:855(para)
msgid ""
"The optional <replaceable class=\"parameter\">frame_clause</replaceable> "
"defines the <firstterm>window frame</firstterm> for window functions that "
"depend on the frame (not all do). The window frame is a set of related rows "
"for each row of the query (called the <firstterm>current row</firstterm>). "
"The <replaceable class=\"parameter\">frame_clause</replaceable> can be one "
"of <synopsis>\n"
"{ RANGE | ROWS } <replaceable>frame_start</replaceable>\n"
"{ RANGE | ROWS } BETWEEN <replaceable>frame_start</replaceable> AND "
"<replaceable>frame_end</replaceable>\n"
"</synopsis> where <replaceable>frame_start</replaceable> and "
"<replaceable>frame_end</replaceable> can be one of <synopsis>\n"
"UNBOUNDED PRECEDING\n"
"<replaceable>value</replaceable> PRECEDING\n"
"CURRENT ROW\n"
"<replaceable>value</replaceable> FOLLOWING\n"
"UNBOUNDED FOLLOWING\n"
"</synopsis> If <replaceable>frame_end</replaceable> is omitted it defaults "
"to <literal>CURRENT ROW</literal>. Restrictions are that "
"<replaceable>frame_start</replaceable> cannot be <literal>UNBOUNDED "
"FOLLOWING</literal>, <replaceable>frame_end</replaceable> cannot be "
"<literal>UNBOUNDED PRECEDING</literal>, and the <replaceable>frame_end</"
"replaceable> choice cannot appear earlier in the above list than the "
"<replaceable>frame_start</replaceable> choice &mdash; for example "
"<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</replaceable> "
"PRECEDING</literal> is not allowed."
msgstr ""
"Необязательное <replaceable class=\"parameter\">предложение_рамки</"
"replaceable> определяет <firstterm>рамку окна</firstterm> для оконных "
"функций, которые зависят от рамки (не все функции таковы). Рамка окна — это "
"набор связанных строк для каждой строки запроса (называемой "
"<firstterm>текущей строкой</firstterm>). В качестве <replaceable class="
"\"parameter\">предложения_рамки</replaceable> может задаваться <synopsis>\n"
"{ RANGE | ROWS } <replaceable>начало_рамки</replaceable>\n"
"{ RANGE | ROWS } BETWEEN <replaceable>начало_рамки</replaceable> AND "
"<replaceable>конец_рамки</replaceable>\n"
"</synopsis> Здесь <replaceable>начало_рамки</replaceable> и "
"<replaceable>конец_рамки</replaceable> может задаваться как <synopsis>\n"
"UNBOUNDED PRECEDING\n"
"<replaceable>значение</replaceable> PRECEDING\n"
"CURRENT ROW\n"
"<replaceable>значение</replaceable> FOLLOWING\n"
"UNBOUNDED FOLLOWING\n"
"</synopsis> Если <replaceable>конец_рамки</replaceable> опущен, по умолчанию "
"подразумевается <literal>CURRENT ROW</literal>. В качестве "
"<replaceable>начала_рамки</replaceable> нельзя задать <literal>UNBOUNDED "
"FOLLOWING</literal>, а в качестве <replaceable>конца_рамки</replaceable> — "
"<literal>UNBOUNDED PRECEDING</literal>, к тому же выбранный вариант "
"<replaceable>конца_рамки</replaceable> не может стоять в приведённом списке "
"выше варианта <replaceable>начала_рамки</replaceable> &mdash; например, "
"комбинация <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>значение</"
"replaceable> PRECEDING</literal> не допускается."

#: ref/select.xml:888(para)
msgid ""
"The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>, "
"which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT "
"ROW</literal>; it sets the frame to be all rows from the partition start up "
"through the current row's last peer (a row that <literal>ORDER BY</literal> "
"considers equivalent to the current row, or all rows if there is no "
"<literal>ORDER BY</literal>). In general, <literal>UNBOUNDED PRECEDING</"
"literal> means that the frame starts with the first row of the partition, "
"and similarly <literal>UNBOUNDED FOLLOWING</literal> means that the frame "
"ends with the last row of the partition (regardless of <literal>RANGE</"
"literal> or <literal>ROWS</literal> mode). In <literal>ROWS</literal> mode, "
"<literal>CURRENT ROW</literal> means that the frame starts or ends with the "
"current row; but in <literal>RANGE</literal> mode it means that the frame "
"starts or ends with the current row's first or last peer in the "
"<literal>ORDER BY</literal> ordering. The <replaceable>value</replaceable> "
"<literal>PRECEDING</literal> and <replaceable>value</replaceable> "
"<literal>FOLLOWING</literal> cases are currently only allowed in "
"<literal>ROWS</literal> mode. They indicate that the frame starts or ends "
"with the row that many rows before or after the current row. "
"<replaceable>value</replaceable> must be an integer expression not "
"containing any variables, aggregate functions, or window functions. The "
"value must not be null or negative; but it can be zero, which selects the "
"current row itself."
msgstr ""
"По умолчанию рамка образуется предложением <literal>RANGE UNBOUNDED "
"PRECEDING</literal>, что по сути то же, что <literal>RANGE BETWEEN UNBOUNDED "
"PRECEDING AND CURRENT ROW</literal>; оно устанавливает рамку так, что она "
"включает все строки от начала раздела до последней строки, родственной "
"текущей (строки, которую <literal>ORDER BY</literal> считает равной "
"текущей), либо все строки раздела, если <literal>ORDER BY</literal> "
"отсутствует. Вообще <literal>UNBOUNDED PRECEDING</literal> означает, что "
"рамка начинается с первой строки раздела, а <literal>UNBOUNDED FOLLOWING</"
"literal> означает, что рамка заканчивается на последней строке раздела (вне "
"зависимости от режима <literal>RANGE</literal> или <literal>ROWS</literal>). "
"В режиме <literal>ROWS</literal> указание <literal>CURRENT ROW</literal> "
"означает, что рамка начинается или заканчивается текущей строкой; но в "
"режиме <literal>RANGE</literal> оно означает, что рамка начинается или "
"заканчивается первой или последней строкой, родственной текущей, согласно "
"порядку <literal>ORDER BY</literal>. Варианты <replaceable>значение</"
"replaceable> <literal>PRECEDING</literal> и <replaceable>значение</"
"replaceable> <literal>FOLLOWING</literal> в настоящее время допускаются "
"только в режиме <literal>ROWS</literal>. Они показывают, что рамка "
"начинается или заканчивается со сдвигом на заданное количество строк назад "
"или вперёд от текущей. Здесь <replaceable>значение</replaceable> должно быть "
"целочисленным выражением, не содержащим никакие переменные, агрегатные или "
"оконные функции. Это значение не может быть отрицательным или равным NULL, "
"но может быть равно 0 (при этом выбирается текущая строка)."

#: ref/select.xml:913(para)
msgid ""
"Beware that the <literal>ROWS</literal> options can produce unpredictable "
"results if the <literal>ORDER BY</literal> ordering does not order the rows "
"uniquely. The <literal>RANGE</literal> options are designed to ensure that "
"rows that are peers in the <literal>ORDER BY</literal> ordering are treated "
"alike; all peer rows will be in the same frame."
msgstr ""
"Учтите, что варианты <literal>ROWS</literal> могут выдавать непредсказуемые "
"результаты, если согласно порядку, заданному в <literal>ORDER BY</literal>, "
"строки сортируются неоднозначно. Варианты <literal>RANGE</literal> "
"предусмотрены для того, чтобы строки, являющиеся родственными в порядке "
"<literal>ORDER BY</literal>, обрабатывались одинаково; все родственные "
"строки будут находиться в одной рамке."

#: ref/select.xml:921(para)
msgid ""
"The purpose of a <literal>WINDOW</literal> clause is to specify the behavior "
"of <firstterm>window functions</firstterm> appearing in the query's <xref "
"linkend=\"sql-select-list\" endterm=\"sql-select-list-title\"/> or <xref "
"linkend=\"sql-orderby\" endterm=\"sql-orderby-title\"/>. These functions can "
"reference the <literal>WINDOW</literal> clause entries by name in their "
"<literal>OVER</literal> clauses. A <literal>WINDOW</literal> clause entry "
"does not have to be referenced anywhere, however; if it is not used in the "
"query it is simply ignored. It is possible to use window functions without "
"any <literal>WINDOW</literal> clause at all, since a window function call "
"can specify its window definition directly in its <literal>OVER</literal> "
"clause. However, the <literal>WINDOW</literal> clause saves typing when the "
"same window definition is needed for more than one window function."
msgstr ""
"Предложение <literal>WINDOW</literal> применяется для управления поведением "
"<firstterm>оконных функций</firstterm>, фигурирующих в запросе, в <xref "
"remap=\"6\" linkend=\"sql-select-list\" endterm=\"sql-select-list-title\"/> "
"или <xref remap=\"6\" linkend=\"sql-orderby\" endterm=\"sql-orderby-title\"/"
">. Эти функции могут обращаться к элементам <literal>WINDOW</literal> по "
"именам в своих предложениях <literal>OVER</literal>. При этом элементы "
"<literal>WINDOW</literal> не обязательно задействовать в запросе; если они "
"не используются, они просто игнорируются. Оконные функции можно использовать "
"вовсе без элементов <literal>WINDOW</literal>, так как в вызове оконной "
"функции можно задать определение окна непосредственно в предложении "
"<literal>OVER</literal>. Однако предложение <literal>WINDOW</literal> "
"позволяет сократить текст запроса, когда одно и то же определение окна "
"применяется при вызове нескольких оконных функций."

#: ref/select.xml:937(para)
msgid ""
"Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</"
"literal>, <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> "
"cannot be specified with <literal>WINDOW</literal>."
msgstr ""
"В настоящее время указания <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> и <literal>FOR "
"KEY SHARE</literal> нельзя задать вместе с <literal>WINDOW</literal>."

#: ref/select.xml:943(para)
msgid ""
"Window functions are described in detail in <xref linkend=\"tutorial-window"
"\"/>, <xref linkend=\"syntax-window-functions\"/>, and <xref linkend="
"\"queries-window\"/>."
msgstr ""
"Оконные функции подробно описываются в <xref remap=\"6\" linkend=\"tutorial-"
"window\"/>, <xref remap=\"6\" linkend=\"syntax-window-functions\"/> и <xref "
"remap=\"6\" linkend=\"queries-window\"/>."

#: ref/select.xml:952(title)
msgid "<command>SELECT</command> List"
msgstr "Список <command>SELECT</command>"

#: ref/select.xml:954(para)
msgid ""
"The <command>SELECT</command> list (between the key words <literal>SELECT</"
"literal> and <literal>FROM</literal>) specifies expressions that form the "
"output rows of the <command>SELECT</command> statement. The expressions can "
"(and usually do) refer to columns computed in the <literal>FROM</literal> "
"clause."
msgstr ""
"Список <command>SELECT</command> (между ключевыми словами <literal>SELECT</"
"literal> и <literal>FROM</literal>) содержит выражения, которые формируют "
"выходные строки оператора <command>SELECT</command>. Эти выражения могут "
"обращаться (и обычно обращаются) к столбцам, вычисленным в предложении "
"<literal>FROM</literal>."

#: ref/select.xml:962(para)
msgid ""
"Just as in a table, every output column of a <command>SELECT</command> has a "
"name. In a simple <command>SELECT</command> this name is just used to label "
"the column for display, but when the <command>SELECT</command> is a sub-"
"query of a larger query, the name is seen by the larger query as the column "
"name of the virtual table produced by the sub-query. To specify the name to "
"use for an output column, write <literal>AS</literal> <replaceable class="
"\"parameter\">output_name</replaceable> after the column's expression. (You "
"can omit <literal>AS</literal>, but only if the desired output name does not "
"match any <productname>PostgreSQL</productname> keyword (see <xref linkend="
"\"sql-keywords-appendix\"/>). For protection against possible future keyword "
"additions, it is recommended that you always either write <literal>AS</"
"literal> or double-quote the output name.) If you do not specify a column "
"name, a name is chosen automatically by <productname>PostgreSQL</"
"productname>. If the column's expression is a simple column reference then "
"the chosen name is the same as that column's name. In more complex cases a "
"function or type name may be used, or the system may fall back on a "
"generated name such as <literal>?column?</literal>."
msgstr ""
"Так же, как в таблице, каждый выходной столбец <command>SELECT</command> "
"имеет имя. В простом предложении <command>SELECT</command> это имя просто "
"помечает столбец при выводе, но когда <command>SELECT</command> представляет "
"собой подзапрос большого запроса, это имя большой запрос видит как имя "
"столбца виртуальной таблицы, созданной подзапросом. Чтобы задать имя для "
"выходного столбца, нужно написать <literal>AS</literal> <replaceable class="
"\"parameter\">выходное_имя</replaceable> после выражения столбца. (Слово "
"<literal>AS</literal> можно опустить, но только если желаемое выходное имя "
"не совпадает с каким-либо ключевым словом <productname>PostgreSQL</"
"productname> (см. <xref remap=\"4\" linkend=\"sql-keywords-appendix\"/>). "
"Чтобы не зависеть от появления новых ключевых слов в будущем, рекомендуется "
"всегда писать <literal>AS</literal>, либо заключать имя в двойные кавычки.) "
"Если имя столбца не задать, <productname>PostgreSQL</productname> выберет "
"его автоматически. Если выражение столбца представляет собой просто ссылку "
"на столбец, то выбранное таким образом имя будет совпадать с именем столбца. "
"В более сложных случаях может использоваться имя функции или типа, либо в "
"отсутствие других вариантов система может сгенерировать имя вроде <literal>?"
"column?</literal>."

#: ref/select.xml:984(para)
msgid ""
"An output column's name can be used to refer to the column's value in "
"<literal>ORDER BY</literal> and <literal>GROUP BY</literal> clauses, but not "
"in the <literal>WHERE</literal> or <literal>HAVING</literal> clauses; there "
"you must write out the expression instead."
msgstr ""
"По имени выходного столбца можно обратиться к его значению в предложениях "
"<literal>ORDER BY</literal> и <literal>GROUP BY</literal>, но не в "
"<literal>WHERE</literal> или <literal>HAVING</literal>; в них вместо имени "
"надо записывать всё выражение."

#: ref/select.xml:991(para)
msgid ""
"Instead of an expression, <literal>*</literal> can be written in the output "
"list as a shorthand for all the columns of the selected rows. Also, you can "
"write <literal><replaceable class=\"parameter\">table_name</replaceable>.*</"
"literal> as a shorthand for the columns coming from just that table. In "
"these cases it is not possible to specify new names with <literal>AS</"
"literal>; the output column names will be the same as the table columns' "
"names."
msgstr ""
"Вместо выражения в выходном списке можно указать <literal>*</literal>, что "
"будет обозначать все столбцы выбранных строк. Кроме того, можно записать "
"<literal><replaceable class=\"parameter\">имя_таблицы</replaceable>.*</"
"literal> как краткое обозначение всех столбцов, получаемых из данной "
"таблицы. В этих случаях нельзя задать новые имена столбцов с помощью "
"<literal>AS</literal>; именами выходных столбцов будут имена столбцов в "
"таблице."

#: ref/select.xml:1001(para)
msgid ""
"According to the SQL standard, the expressions in the output list should be "
"computed before applying <literal>DISTINCT</literal>, <literal>ORDER BY</"
"literal>, or <literal>LIMIT</literal>. This is obviously necessary when "
"using <literal>DISTINCT</literal>, since otherwise it's not clear what "
"values are being made distinct. However, in many cases it is convenient if "
"output expressions are computed after <literal>ORDER BY</literal> and "
"<literal>LIMIT</literal>; particularly if the output list contains any "
"volatile or expensive functions. With that behavior, the order of function "
"evaluations is more intuitive and there will not be evaluations "
"corresponding to rows that never appear in the output. "
"<productname>PostgreSQL</productname> will effectively evaluate output "
"expressions after sorting and limiting, so long as those expressions are not "
"referenced in <literal>DISTINCT</literal>, <literal>ORDER BY</literal> or "
"<literal>GROUP BY</literal>. (As a counterexample, <literal>SELECT f(x) FROM "
"tab ORDER BY 1</literal> clearly must evaluate <function>f(x)</function> "
"before sorting.) Output expressions that contain set-returning functions are "
"effectively evaluated after sorting and before limiting, so that "
"<literal>LIMIT</literal> will act to cut off the output from a set-returning "
"function."
msgstr ""
"Согласно стандарту SQL, выражения в выходном списке должны вычисляться до "
"применения <literal>DISTINCT</literal>, <literal>ORDER BY</literal> или "
"<literal>LIMIT</literal>. Это, очевидно, необходимо для <literal>DISTINCT</"
"literal>, так как иначе не будет ясно, какие значения должны выдаваться как "
"уникальные. Однако во многих случаях выходные выражения удобнее вычислять "
"после <literal>ORDER BY</literal> и <literal>LIMIT</literal>; в частности, "
"если в выходном списке содержатся изменчивые или дорогостоящие функции. В "
"этом случае порядок вычисления функций оказывается более интуитивным, а для "
"строк, которые не попадут в результат, не будут производиться вычисления. "
"<productname>PostgreSQL</productname> фактически будет вычислять выходные "
"выражения после сортировки и ограничения их количества, если эти выражения "
"не фигурируют в <literal>DISTINCT</literal>, <literal>ORDER BY</literal> или "
"<literal>GROUP BY</literal>. (Например, в запросе <literal>SELECT f(x) FROM "
"tab ORDER BY 1</literal> функция <function>f(x)</function>, несомненно, "
"должна вычисляться перед сортировкой.) Выходные выражения, содержащие "
"функции, возвращающие множества, фактически вычисляются после сортировки и "
"до ограничения количества строк, так что <literal>LIMIT</literal> будет "
"отбрасывать строки, выдаваемые функцией, возвращающей множество."

#: ref/select.xml:1024(para)
msgid ""
"<productname>PostgreSQL</productname> versions before 9.6 did not provide "
"any guarantees about the timing of evaluation of output expressions versus "
"sorting and limiting; it depended on the form of the chosen query plan."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 9.6 никакой порядок "
"вычисления выходных выражений по отношению к сортировке или ограничениям "
"количества не гарантировался; он зависел от формы выбранного плана запроса."

#: ref/select.xml:1033(title)
msgid "<literal>DISTINCT</literal> Clause"
msgstr "Предложение <literal>DISTINCT</literal>"

#: ref/select.xml:1035(para)
msgid ""
"If <literal>SELECT DISTINCT</literal> is specified, all duplicate rows are "
"removed from the result set (one row is kept from each group of duplicates). "
"<literal>SELECT ALL</literal> specifies the opposite: all rows are kept; "
"that is the default."
msgstr ""
"Если указано <literal>SELECT DISTINCT</literal>, все повторяющиеся строки "
"исключаются из результирующего набора (из каждой группы дубликатов остаётся "
"одна строка). <literal>SELECT ALL</literal> делает противоположное: "
"сохраняет все строки; это поведение по умолчанию."

#: ref/select.xml:1052(programlisting)
#, no-wrap
msgid ""
"SELECT DISTINCT ON (location) location, time, report\n"
"    FROM weather_reports\n"
"    ORDER BY location, time DESC;"
msgstr ""
"SELECT DISTINCT ON (location) location, time, report\n"
"    FROM weather_reports\n"
"    ORDER BY location, time DESC;"

#: ref/select.xml:1042(para)
msgid ""
"<literal>SELECT DISTINCT ON ( <replaceable class=\"parameter\">expression</"
"replaceable> [, ...] )</literal> keeps only the first row of each set of "
"rows where the given expressions evaluate to equal. The <literal>DISTINCT "
"ON</literal> expressions are interpreted using the same rules as for "
"<literal>ORDER BY</literal> (see above). Note that the <quote>first row</"
"quote> of each set is unpredictable unless <literal>ORDER BY</literal> is "
"used to ensure that the desired row appears first. For example: "
"<placeholder-1/> retrieves the most recent weather report for each location. "
"But if we had not used <literal>ORDER BY</literal> to force descending order "
"of time values for each location, we'd have gotten a report from an "
"unpredictable time for each location."
msgstr ""
"<literal>SELECT DISTINCT ON ( <replaceable class=\"parameter\">выражение</"
"replaceable> [, ...] )</literal> сохраняет только первую строку из каждого "
"набора строк, для которого данное выражение даёт одинаковые значения. "
"Выражения <literal>DISTINCT ON</literal> обрабатываются по тем же правилам, "
"что и выражения <literal>ORDER BY</literal> (см. выше). Заметьте, что "
"<quote>первая строка</quote> каждого набора непредсказуема, если только не "
"применяется предложение <literal>ORDER BY</literal>, определяющее, какие "
"строки должны быть первыми. Например: <placeholder-1/> возвращает самую "
"последнюю сводку погоды для каждого местоположения. Но если бы мы не "
"добавили <literal>ORDER BY</literal>, чтобы значения времени убывали, мы бы "
"получили сводки по местоположениям от непредсказуемого времени."

#: ref/select.xml:1063(para)
msgid ""
"The <literal>DISTINCT ON</literal> expression(s) must match the leftmost "
"<literal>ORDER BY</literal> expression(s). The <literal>ORDER BY</literal> "
"clause will normally contain additional expression(s) that determine the "
"desired precedence of rows within each <literal>DISTINCT ON</literal> group."
msgstr ""
"Выражения <literal>DISTINCT ON</literal> должны соответствовать самым левым "
"выражениям в <literal>ORDER BY</literal>. Предложение <literal>ORDER BY</"
"literal> обычно содержит и другие выражения, которые определяют желаемый "
"порядок строк в каждой группе <literal>DISTINCT ON</literal>."

#: ref/select.xml:1070(para)
msgid ""
"Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</"
"literal>, <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> "
"cannot be specified with <literal>DISTINCT</literal>."
msgstr ""
"В настоящее время указания <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> и <literal>FOR "
"KEY SHARE</literal> нельзя задать вместе с <literal>DISTINCT</literal>."

#: ref/select.xml:1078(title)
msgid "<literal>UNION</literal> Clause"
msgstr "Предложение <literal>UNION</literal>+"

#: ref/select.xml:1080(para)
msgid ""
"The <literal>UNION</literal> clause has this general form: <synopsis>\n"
"<replaceable class=\"parameter\">select_statement</replaceable> UNION [ ALL "
"| DISTINCT ] <replaceable class=\"parameter\">select_statement</"
"replaceable>\n"
"</synopsis><replaceable class=\"parameter\">select_statement</replaceable> "
"is any <command>SELECT</command> statement without an <literal>ORDER BY</"
"literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal>, or <literal>FOR "
"KEY SHARE</literal> clause. (<literal>ORDER BY</literal> and <literal>LIMIT</"
"literal> can be attached to a subexpression if it is enclosed in "
"parentheses. Without parentheses, these clauses will be taken to apply to "
"the result of the <literal>UNION</literal>, not to its right-hand input "
"expression.)"
msgstr ""
"Предложение <literal>UNION</literal> имеет следующую общую форму: "
"<synopsis>\n"
"<replaceable class=\"parameter\">оператор_SELECT</replaceable> UNION [ ALL | "
"DISTINCT ] <replaceable class=\"parameter\">оператор_SELECT</replaceable>\n"
"</synopsis> Здесь <replaceable class=\"parameter\">оператор_SELECT</"
"replaceable> — это любой подзапрос <command>SELECT</command> без предложений "
"<literal>ORDER BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY "
"UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</"
"literal> и <literal>FOR KEY SHARE</literal>. (<literal>ORDER BY</literal> и "
"<literal>LIMIT</literal> можно добавить к вложенному выражению, если оно "
"заключено в скобки. Без скобок эти предложения будут восприняты как "
"применяемые к результату <literal>UNION</literal>, а не к выражению в его "
"правой части.)"

#: ref/select.xml:1095(para)
msgid ""
"The <literal>UNION</literal> operator computes the set union of the rows "
"returned by the involved <command>SELECT</command> statements. A row is in "
"the set union of two result sets if it appears in at least one of the result "
"sets. The two <command>SELECT</command> statements that represent the direct "
"operands of the <literal>UNION</literal> must produce the same number of "
"columns, and corresponding columns must be of compatible data types."
msgstr ""
"Оператор <literal>UNION</literal> вычисляет объединение множеств всех строк, "
"возвращённых заданными запросами <command>SELECT</command>. Строка "
"оказывается в объединении двух наборов результатов, если она присутствует "
"минимум в одном наборе. Два оператора <command>SELECT</command>, "
"представляющие прямые операнды <literal>UNION</literal>, должны выдавать "
"одинаковое число столбцов, а типы соответствующих столбцов должны быть "
"совместимыми."

#: ref/select.xml:1106(para)
msgid ""
"The result of <literal>UNION</literal> does not contain any duplicate rows "
"unless the <literal>ALL</literal> option is specified. <literal>ALL</"
"literal> prevents elimination of duplicates. (Therefore, <literal>UNION ALL</"
"literal> is usually significantly quicker than <literal>UNION</literal>; use "
"<literal>ALL</literal> when you can.) <literal>DISTINCT</literal> can be "
"written to explicitly specify the default behavior of eliminating duplicate "
"rows."
msgstr ""
"Результат <literal>UNION</literal> не будет содержать повторяющихся строк, "
"если не указан параметр <literal>ALL</literal>. <literal>ALL</literal> "
"предотвращает исключение дубликатов. (Таким образом, <literal>UNION ALL</"
"literal> обычно работает значительно быстрее, чем <literal>UNION</literal>; "
"поэтому, везде, где возможно, следует указывать <literal>ALL</literal>.) "
"<literal>DISTINCT</literal> можно записать явно, чтобы обозначить, что "
"дублирующиеся строки должны удаляться (это поведение по умолчанию)."

#: ref/select.xml:1116(para)
msgid ""
"Multiple <literal>UNION</literal> operators in the same <command>SELECT</"
"command> statement are evaluated left to right, unless otherwise indicated "
"by parentheses."
msgstr ""
"При использовании в одном запросе <command>SELECT</command> нескольких "
"операторов <literal>UNION</literal> они вычисляются слева направо, если иной "
"порядок не определяется скобками."

#: ref/select.xml:1122(para)
msgid ""
"Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</"
"literal>, <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> "
"cannot be specified either for a <literal>UNION</literal> result or for any "
"input of a <literal>UNION</literal>."
msgstr ""
"В настоящее время указания <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> и <literal>FOR "
"KEY SHARE</literal> нельзя задать ни для результата <literal>UNION</"
"literal>, ни для любого из подзапросов <literal>UNION</literal>."

#: ref/select.xml:1131(title)
msgid "<literal>INTERSECT</literal> Clause"
msgstr "Предложение <literal>INTERSECT</literal>"

#: ref/select.xml:1133(para)
msgid ""
"The <literal>INTERSECT</literal> clause has this general form: <synopsis>\n"
"<replaceable class=\"parameter\">select_statement</replaceable> INTERSECT "
"[ ALL | DISTINCT ] <replaceable class=\"parameter\">select_statement</"
"replaceable>\n"
"</synopsis><replaceable class=\"parameter\">select_statement</replaceable> "
"is any <command>SELECT</command> statement without an <literal>ORDER BY</"
"literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal>, or <literal>FOR "
"KEY SHARE</literal> clause."
msgstr ""
"Предложение <literal>INTERSECT</literal> имеет следующую общую форму: "
"<synopsis>\n"
"<replaceable class=\"parameter\">оператор_SELECT</replaceable> INTERSECT "
"[ ALL | DISTINCT ] <replaceable class=\"parameter\">оператор_SELECT</"
"replaceable>\n"
"</synopsis> Здесь <replaceable class=\"parameter\">оператор_SELECT</"
"replaceable> — это любой подзапрос <command>SELECT</command> без предложений "
"<literal>ORDER BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY "
"UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</"
"literal> и <literal>FOR KEY SHARE</literal>."

#: ref/select.xml:1143(para)
msgid ""
"The <literal>INTERSECT</literal> operator computes the set intersection of "
"the rows returned by the involved <command>SELECT</command> statements. A "
"row is in the intersection of two result sets if it appears in both result "
"sets."
msgstr ""
"Оператор <literal>INTERSECT</literal> вычисляет пересечение множеств всех "
"строк, возвращённых заданными запросами <command>SELECT</command>. Строка "
"оказывается в пересечении двух наборов результатов, если она присутствует в "
"обоих наборах."

#: ref/select.xml:1150(para)
msgid ""
"The result of <literal>INTERSECT</literal> does not contain any duplicate "
"rows unless the <literal>ALL</literal> option is specified. With "
"<literal>ALL</literal>, a row that has <replaceable>m</replaceable> "
"duplicates in the left table and <replaceable>n</replaceable> duplicates in "
"the right table will appear min(<replaceable>m</replaceable>,<replaceable>n</"
"replaceable>) times in the result set. <literal>DISTINCT</literal> can be "
"written to explicitly specify the default behavior of eliminating duplicate "
"rows."
msgstr ""
"Результат <literal>INTERSECT</literal> не будет содержать повторяющихся "
"строк, если не указан параметр <literal>ALL</literal>. С параметром "
"<literal>ALL</literal> строка, повторяющаяся <replaceable>m</replaceable> "
"раз в левой таблице и <replaceable>n</replaceable> раз в правой, будет "
"выдана в результирующем наборе min(<replaceable>m</replaceable>,"
"<replaceable>n</replaceable>) раз. <literal>DISTINCT</literal> можно "
"записать явно, чтобы обозначить, что дублирующиеся строки должны удаляться "
"(это поведение по умолчанию)."

#: ref/select.xml:1160(para)
msgid ""
"Multiple <literal>INTERSECT</literal> operators in the same <command>SELECT</"
"command> statement are evaluated left to right, unless parentheses dictate "
"otherwise. <literal>INTERSECT</literal> binds more tightly than "
"<literal>UNION</literal>. That is, <literal>A UNION B INTERSECT C</literal> "
"will be read as <literal>A UNION (B INTERSECT C)</literal>."
msgstr ""
"При использовании в одном запросе <command>SELECT</command> нескольких "
"операторов <literal>INTERSECT</literal> они вычисляются слева направо, если "
"иной порядок не диктуется скобками. <literal>INTERSECT</literal> связывает "
"свои подзапросы сильнее, чем <literal>UNION</literal>. Другими словами, "
"<literal>A UNION B INTERSECT C</literal> будет восприниматься как <literal>A "
"UNION (B INTERSECT C)</literal>."

#: ref/select.xml:1170(para)
msgid ""
"Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</"
"literal>, <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> "
"cannot be specified either for an <literal>INTERSECT</literal> result or for "
"any input of an <literal>INTERSECT</literal>."
msgstr ""
"В настоящее время указания <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> и <literal>FOR "
"KEY SHARE</literal> нельзя задать ни для результата <literal>INTERSECT</"
"literal>, ни для любого из подзапросов <literal>INTERSECT</literal>."

#: ref/select.xml:1179(title)
msgid "<literal>EXCEPT</literal> Clause"
msgstr "Предложение <literal>EXCEPT</literal>"

#: ref/select.xml:1181(para)
msgid ""
"The <literal>EXCEPT</literal> clause has this general form: <synopsis>\n"
"<replaceable class=\"parameter\">select_statement</replaceable> EXCEPT [ ALL "
"| DISTINCT ] <replaceable class=\"parameter\">select_statement</"
"replaceable>\n"
"</synopsis><replaceable class=\"parameter\">select_statement</replaceable> "
"is any <command>SELECT</command> statement without an <literal>ORDER BY</"
"literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal>, or <literal>FOR "
"KEY SHARE</literal> clause."
msgstr ""
"Предложение <literal>EXCEPT</literal> имеет следующую общую форму: "
"<synopsis>\n"
"<replaceable class=\"parameter\">оператор_SELECT</replaceable> EXCEPT [ ALL "
"| DISTINCT ] <replaceable class=\"parameter\">оператор_SELECT</replaceable>\n"
"</synopsis> Здесь <replaceable class=\"parameter\">оператор_SELECT</"
"replaceable> — это любой подзапрос <command>SELECT</command> без предложений "
"<literal>ORDER BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY "
"UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</"
"literal> и <literal>FOR KEY SHARE</literal>."

#: ref/select.xml:1191(para)
msgid ""
"The <literal>EXCEPT</literal> operator computes the set of rows that are in "
"the result of the left <command>SELECT</command> statement but not in the "
"result of the right one."
msgstr ""
"Оператор <literal>EXCEPT</literal> вычисляет набор строк, которые "
"присутствуют в результате левого запроса <command>SELECT</command>, но "
"отсутствуют в результате правого."

#: ref/select.xml:1197(para)
msgid ""
"The result of <literal>EXCEPT</literal> does not contain any duplicate rows "
"unless the <literal>ALL</literal> option is specified. With <literal>ALL</"
"literal>, a row that has <replaceable>m</replaceable> duplicates in the left "
"table and <replaceable>n</replaceable> duplicates in the right table will "
"appear max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) "
"times in the result set. <literal>DISTINCT</literal> can be written to "
"explicitly specify the default behavior of eliminating duplicate rows."
msgstr ""
"Результат <literal>EXCEPT</literal> не будет содержать повторяющихся строк, "
"если не указан параметр <literal>ALL</literal>. С параметром <literal>ALL</"
"literal> строка, повторяющаяся <replaceable>m</replaceable> раз в левой "
"таблице и <replaceable>n</replaceable> раз в правой, будет выдана в "
"результирующем наборе max(<replaceable>m</replaceable>-<replaceable>n</"
"replaceable>,0) раз. <literal>DISTINCT</literal> можно записать явно, чтобы "
"обозначить, что дублирующиеся строки должны удаляться (это поведение по "
"умолчанию)."

#: ref/select.xml:1207(para)
msgid ""
"Multiple <literal>EXCEPT</literal> operators in the same <command>SELECT</"
"command> statement are evaluated left to right, unless parentheses dictate "
"otherwise. <literal>EXCEPT</literal> binds at the same level as "
"<literal>UNION</literal>."
msgstr ""
"При использовании в одном запросе <command>SELECT</command> нескольких "
"операторов <literal>EXCEPT</literal> они вычисляются слева направо, если "
"иной порядок не диктуется скобками. <literal>EXCEPT</literal> связывает свои "
"подзапросы так же сильно, как <literal>UNION</literal>."

#: ref/select.xml:1214(para)
msgid ""
"Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</"
"literal>, <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> "
"cannot be specified either for an <literal>EXCEPT</literal> result or for "
"any input of an <literal>EXCEPT</literal>."
msgstr ""
"В настоящее время указания <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> и <literal>FOR "
"KEY SHARE</literal> нельзя задать ни для результата <literal>EXCEPT</"
"literal>, ни для любого из подзапросов <literal>EXCEPT</literal>."

#: ref/select.xml:1223(title)
msgid "<literal>ORDER BY</literal> Clause"
msgstr "Предложение <literal>ORDER BY</literal>"

#: ref/select.xml:1225(para)
msgid ""
"The optional <literal>ORDER BY</literal> clause has this general form: "
"<synopsis>\n"
"ORDER BY <replaceable class=\"parameter\">expression</replaceable> [ ASC | "
"DESC | USING <replaceable class=\"parameter\">operator</replaceable> ] "
"[ NULLS { FIRST | LAST } ] [, ...]\n"
"</synopsis> The <literal>ORDER BY</literal> clause causes the result rows to "
"be sorted according to the specified expression(s). If two rows are equal "
"according to the leftmost expression, they are compared according to the "
"next expression and so on. If they are equal according to all specified "
"expressions, they are returned in an implementation-dependent order."
msgstr ""
"Необязательное предложение <literal>ORDER BY</literal> имеет следующую общую "
"форму: <synopsis>\n"
"ORDER BY <replaceable class=\"parameter\">выражение</replaceable> [ ASC | "
"DESC | USING <replaceable class=\"parameter\">оператор</replaceable> ] "
"[ NULLS { FIRST | LAST } ] [, ...]\n"
"</synopsis> Предложение <literal>ORDER BY</literal> указывает, что строки "
"результата должны сортироваться согласно заданным выражениям. Если две "
"строки дают равные значения для самого левого выражения, проверяется "
"следующее выражение и т. д. Если их значения оказываются равными для всех "
"заданных выражений, строки возвращаются в порядке, определяемом реализацией."

#: ref/select.xml:1238(para)
msgid ""
"Each <replaceable class=\"parameter\">expression</replaceable> can be the "
"name or ordinal number of an output column (<command>SELECT</command> list "
"item), or it can be an arbitrary expression formed from input-column values."
msgstr ""
"В качестве <replaceable class=\"parameter\">выражения</replaceable> может "
"задаваться имя или порядковый номер выходного столбца (элемента списка "
"<command>SELECT</command>), либо произвольное выражение со значениями "
"входных столбцов."

#: ref/select.xml:1245(para)
msgid ""
"The ordinal number refers to the ordinal (left-to-right) position of the "
"output column. This feature makes it possible to define an ordering on the "
"basis of a column that does not have a unique name. This is never absolutely "
"necessary because it is always possible to assign a name to an output column "
"using the <literal>AS</literal> clause."
msgstr ""
"Порядковым номером в данном случае считается последовательный номер (при "
"нумерации слева направо) позиции выходного столбца. Возможность указать "
"порядковый номер позволяет выполнить сортировку по столбцу, не имеющему "
"уникального имени. В принципе это не абсолютно необходимо, так как выходному "
"столбцу всегда можно присвоить имя, воспользовавшись предложением "
"<literal>AS</literal>."

#: ref/select.xml:1259(programlisting)
#, no-wrap
msgid "SELECT name FROM distributors ORDER BY code;"
msgstr "SELECT name FROM distributors ORDER BY code;"

#: ref/select.xml:1254(para)
msgid ""
"It is also possible to use arbitrary expressions in the <literal>ORDER BY</"
"literal> clause, including columns that do not appear in the "
"<command>SELECT</command> output list. Thus the following statement is "
"valid: <placeholder-1/> A limitation of this feature is that an "
"<literal>ORDER BY</literal> clause applying to the result of a "
"<literal>UNION</literal>, <literal>INTERSECT</literal>, or <literal>EXCEPT</"
"literal> clause can only specify an output column name or number, not an "
"expression."
msgstr ""
"В предложении <literal>ORDER BY</literal> также можно использовать "
"произвольные выражения, в том числе, и со столбцами, отсутствующими в списке "
"результатов <command>SELECT</command>. Таким образом, следующий оператор "
"вполне корректен: <placeholder-1/> Однако, если <literal>ORDER BY</literal> "
"применяется к результату <literal>UNION</literal>, <literal>INTERSECT</"
"literal> или <literal>EXCEPT</literal>, в нём можно задать только имя или "
"номер выходного столбца, но не выражение."

#: ref/select.xml:1268(para)
msgid ""
"If an <literal>ORDER BY</literal> expression is a simple name that matches "
"both an output column name and an input column name, <literal>ORDER BY</"
"literal> will interpret it as the output column name. This is the opposite "
"of the choice that <literal>GROUP BY</literal> will make in the same "
"situation. This inconsistency is made to be compatible with the SQL standard."
msgstr ""
"Если в качестве выражения <literal>ORDER BY</literal> задано простое имя, "
"которому соответствует и выходной, и входной столбец, то <literal>ORDER BY</"
"literal> будет воспринимать его как имя выходного столбца. Этот выбор "
"противоположен тому, что делает <literal>GROUP BY</literal> в такой же "
"ситуации. Такая несогласованность допущена для соответствия стандарту SQL."

#: ref/select.xml:1277(para)
msgid ""
"Optionally one can add the key word <literal>ASC</literal> (ascending) or "
"<literal>DESC</literal> (descending) after any expression in the "
"<literal>ORDER BY</literal> clause. If not specified, <literal>ASC</literal> "
"is assumed by default. Alternatively, a specific ordering operator name can "
"be specified in the <literal>USING</literal> clause. An ordering operator "
"must be a less-than or greater-than member of some B-tree operator family. "
"<literal>ASC</literal> is usually equivalent to <literal>USING &lt;</"
"literal> and <literal>DESC</literal> is usually equivalent to <literal>USING "
"&gt;</literal>. (But the creator of a user-defined data type can define "
"exactly what the default sort ordering is, and it might correspond to "
"operators with other names.)"
msgstr ""
"Дополнительно после любого выражения в предложении <literal>ORDER BY</"
"literal> можно добавить ключевое слово <literal>ASC</literal> (по "
"возрастанию) или <literal>DESC</literal> (по убыванию). По умолчанию "
"подразумевается <literal>ASC</literal>. Кроме того, можно задать имя "
"специфического оператора сортировки в предложении <literal>USING</literal>. "
"Оператор сортировки должен быть членом &laquo;меньше&raquo; или &laquo;"
"больше&raquo; некоторого семейства операторов B-дерева. <literal>ASC</"
"literal> обычно равнозначно <literal>USING &lt;</literal> и <literal>DESC</"
"literal> обычно равнозначно <literal>USING &gt;</literal>. (Хотя создатель "
"нестандартного типа данных может определить по-другому порядок сортировки по "
"умолчанию и поставить ему в соответствие операторы с другими именами.)"

#: ref/select.xml:1292(para)
msgid ""
"If <literal>NULLS LAST</literal> is specified, null values sort after all "
"non-null values; if <literal>NULLS FIRST</literal> is specified, null values "
"sort before all non-null values. If neither is specified, the default "
"behavior is <literal>NULLS LAST</literal> when <literal>ASC</literal> is "
"specified or implied, and <literal>NULLS FIRST</literal> when <literal>DESC</"
"literal> is specified (thus, the default is to act as though nulls are "
"larger than non-nulls). When <literal>USING</literal> is specified, the "
"default nulls ordering depends on whether the operator is a less-than or "
"greater-than operator."
msgstr ""
"Если указано <literal>NULLS LAST</literal>, значения NULL при сортировке "
"оказываются после значений не NULL; с указанием <literal>NULLS FIRST</"
"literal> значения NULL оказываются перед значениями не NULL. Если не указано "
"ни то, ни другое, по умолчанию подразумевается <literal>NULLS LAST</literal> "
"при явно или неявно выбранном порядке <literal>ASC</literal>, либо "
"<literal>NULLS FIRST</literal> при порядке <literal>DESC</literal> (то есть "
"по умолчанию считается, что значения NULL больше значений не NULL). С "
"предложением <literal>USING</literal> порядок NULL по умолчанию зависит от "
"того, является ли указанный оператор оператором &laquo;меньше&raquo; или "
"&laquo;больше&raquo;."

#: ref/select.xml:1303(para)
msgid ""
"Note that ordering options apply only to the expression they follow; for "
"example <literal>ORDER BY x, y DESC</literal> does not mean the same thing "
"as <literal>ORDER BY x DESC, y DESC</literal>."
msgstr ""
"Заметьте, что параметры сортировки применяются только к тому выражению, за "
"которым они следуют; в частности, <literal>ORDER BY x, y DESC</literal> "
"означает не то же самое, что <literal>ORDER BY x DESC, y DESC</literal>."

#: ref/select.xml:1309(para)
msgid ""
"Character-string data is sorted according to the collation that applies to "
"the column being sorted. That can be overridden at need by including a "
"<literal>COLLATE</literal> clause in the <replaceable class=\"parameter"
"\">expression</replaceable>, for example <literal>ORDER BY mycolumn COLLATE "
"\"en_US\"</literal>. For more information see <xref linkend=\"sql-syntax-"
"collate-exprs\"/> and <xref linkend=\"collation\"/>."
msgstr ""
"Данные символьных строк сортируются согласно правилу сортировки, "
"установленному для сортируемого столбца. При необходимости это правило можно "
"переопределить, добавив предложение <literal>COLLATE</literal> в "
"<replaceable class=\"parameter\">выражение</replaceable>, например так: "
"<literal>ORDER BY mycolumn COLLATE \"en_US\"</literal>. За дополнительными "
"сведениями обратитесь к <xref remap=\"3\" linkend=\"sql-syntax-collate-exprs"
"\"/> и <xref remap=\"3\" linkend=\"collation\"/>."

#: ref/select.xml:1321(title)
msgid "<literal>LIMIT</literal> Clause"
msgstr "Предложение <literal>LIMIT</literal>"

#: ref/select.xml:1323(para)
msgid ""
"The <literal>LIMIT</literal> clause consists of two independent sub-clauses: "
"<synopsis>\n"
"LIMIT { <replaceable class=\"parameter\">count</replaceable> | ALL }\n"
"OFFSET <replaceable class=\"parameter\">start</replaceable>\n"
"</synopsis> <replaceable class=\"parameter\">count</replaceable> specifies "
"the maximum number of rows to return, while <replaceable class=\"parameter"
"\">start</replaceable> specifies the number of rows to skip before starting "
"to return rows. When both are specified, <replaceable class=\"parameter"
"\">start</replaceable> rows are skipped before starting to count the "
"<replaceable class=\"parameter\">count</replaceable> rows to be returned."
msgstr ""
"Предложение <literal>LIMIT</literal> состоит из двух независимых вложенных "
"предложений: <synopsis>\n"
"LIMIT { <replaceable class=\"parameter\">число</replaceable> | ALL }\n"
"OFFSET <replaceable class=\"parameter\">начало</replaceable>\n"
"</synopsis> Здесь <replaceable class=\"parameter\">число</replaceable> "
"определяет максимальное количество строк, которое должно быть выдано, тогда "
"как <replaceable class=\"parameter\">начало</replaceable> определяет, "
"сколько строк нужно пропустить, прежде чем начать выдавать строки. Когда "
"указаны оба значения, сначала строки пропускаются в количестве, заданном "
"значением <replaceable class=\"parameter\">начало</replaceable>, а затем "
"следующие строки выдаются в количестве, не превышающем значения <replaceable "
"class=\"parameter\">число</replaceable>."

#: ref/select.xml:1339(para)
msgid ""
"If the <replaceable class=\"parameter\">count</replaceable> expression "
"evaluates to NULL, it is treated as <literal>LIMIT ALL</literal>, i.e., no "
"limit. If <replaceable class=\"parameter\">start</replaceable> evaluates to "
"NULL, it is treated the same as <literal>OFFSET 0</literal>."
msgstr ""
"Если результатом выражения <replaceable class=\"parameter\">число</"
"replaceable> оказывается NULL, предложение воспринимается как <literal>LIMIT "
"ALL</literal>, т. е. число строк не ограничивается. Если <replaceable class="
"\"parameter\">начало</replaceable> принимает значение NULL, предложение "
"воспринимается как <literal>OFFSET 0</literal>."

#: ref/select.xml:1346(para)
msgid ""
"SQL:2008 introduced a different syntax to achieve the same result, which "
"<productname>PostgreSQL</productname> also supports. It is: <synopsis>\n"
"OFFSET <replaceable class=\"parameter\">start</replaceable> { ROW | ROWS }\n"
"FETCH { FIRST | NEXT } [ <replaceable class=\"parameter\">count</"
"replaceable> ] { ROW | ROWS } ONLY\n"
"</synopsis> In this syntax, to write anything except a simple integer "
"constant for <replaceable class=\"parameter\">start</replaceable> or "
"<replaceable class=\"parameter\">count</replaceable>, you must write "
"parentheses around it. If <replaceable class=\"parameter\">count</"
"replaceable> is omitted in a <literal>FETCH</literal> clause, it defaults to "
"1. <literal>ROW</literal> and <literal>ROWS</literal> as well as "
"<literal>FIRST</literal> and <literal>NEXT</literal> are noise words that "
"don't influence the effects of these clauses. According to the standard, the "
"<literal>OFFSET</literal> clause must come before the <literal>FETCH</"
"literal> clause if both are present; but <productname>PostgreSQL</"
"productname> is laxer and allows either order."
msgstr ""
"SQL:2008 вводит другой синтаксис для получения того же результата, и его так "
"же поддерживает <productname>PostgreSQL</productname>. Он выглядит так: "
"<synopsis>\n"
"OFFSET <replaceable class=\"parameter\">начало</replaceable> { ROW | ROWS }\n"
"FETCH { FIRST | NEXT } [ <replaceable class=\"parameter\">число</"
"replaceable> ] { ROW | ROWS } ONLY\n"
"</synopsis> В этом синтаксисе, чтобы подставить в <replaceable class="
"\"parameter\">начало</replaceable> или <replaceable class=\"parameter"
"\">число</replaceable> что-либо сложнее простой целочисленной константы, "
"необходимо заключить это выражение в скобки. Если <replaceable class="
"\"parameter\">число</replaceable> опускается в предложении <literal>FETCH</"
"literal>, оно принимает значение 1. <literal>ROW</literal> и <literal>ROWS</"
"literal> так же, как и <literal>FIRST</literal> и <literal>NEXT</literal> "
"являются избыточными словами, которые не влияют не действие этих "
"предложений. Согласно стандарту, предложение <literal>OFFSET</literal> "
"должно предшествовать предложению <literal>FETCH</literal>, если "
"присутствуют они оба; но <productname>PostgreSQL</productname> менее строг и "
"допускает любой порядок."

#: ref/select.xml:1368(para)
msgid ""
"When using <literal>LIMIT</literal>, it is a good idea to use an "
"<literal>ORDER BY</literal> clause that constrains the result rows into a "
"unique order. Otherwise you will get an unpredictable subset of the query's "
"rows &mdash; you might be asking for the tenth through twentieth rows, but "
"tenth through twentieth in what ordering? You don't know what ordering "
"unless you specify <literal>ORDER BY</literal>."
msgstr ""
"Применяя <literal>LIMIT</literal>, имеет смысл использовать также "
"предложение <literal>ORDER BY</literal>, чтобы строки результата выдавались "
"в определённом порядке. Иначе будут возвращаться непредсказуемые "
"подмножества строк запроса &mdash; вы можете запросить строки с десятой по "
"двадцатую, но какой порядок вы имеете в виду? Порядок будет неизвестен, если "
"не добавить <literal>ORDER BY</literal>."

#: ref/select.xml:1377(para)
msgid ""
"The query planner takes <literal>LIMIT</literal> into account when "
"generating a query plan, so you are very likely to get different plans "
"(yielding different row orders) depending on what you use for "
"<literal>LIMIT</literal> and <literal>OFFSET</literal>. Thus, using "
"different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to "
"select different subsets of a query result <emphasis>will give inconsistent "
"results</emphasis> unless you enforce a predictable result ordering with "
"<literal>ORDER BY</literal>. This is not a bug; it is an inherent "
"consequence of the fact that SQL does not promise to deliver the results of "
"a query in any particular order unless <literal>ORDER BY</literal> is used "
"to constrain the order."
msgstr ""
"Планировщик запроса учитывает ограничение <literal>LIMIT</literal>, строя "
"план выполнения запроса, поэтому, вероятнее всего, планы (а значит и порядок "
"строк) будут меняться при разных <literal>LIMIT</literal> и <literal>OFFSET</"
"literal>. Таким образом, различные значения <literal>LIMIT</literal>/"
"<literal>OFFSET</literal>, выбирающие разные подмножества результатов "
"запроса, <emphasis>приведут к несогласованности результатов</emphasis>, если "
"не установить предсказуемую сортировку с помощью <literal>ORDER BY</"
"literal>. Это не ошибка, а неизбежное следствие того, что SQL не гарантирует "
"вывод результатов запроса в некотором порядке, если порядок не определён "
"явно предложением <literal>ORDER BY</literal>."

#: ref/select.xml:1391(para)
msgid ""
"It is even possible for repeated executions of the same <literal>LIMIT</"
"literal> query to return different subsets of the rows of a table, if there "
"is not an <literal>ORDER BY</literal> to enforce selection of a "
"deterministic subset. Again, this is not a bug; determinism of the results "
"is simply not guaranteed in such a case."
msgstr ""
"Возможно даже, что при повторном выполнении одного и того же запроса с "
"<literal>LIMIT</literal> будут получены разные подмножества строк таблицы, "
"если предложение <literal>ORDER BY</literal> не диктует выбор определённого "
"подмножества. Опять же, это не ошибка; в данном случае детерминированность "
"результата просто не гарантируется."

#: ref/select.xml:1401(title)
msgid "The Locking Clause"
msgstr "Предложение блокировки"

#: ref/select.xml:1403(para)
msgid ""
"<literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>, "
"<literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> are "
"<firstterm>locking clauses</firstterm>; they affect how <literal>SELECT</"
"literal> locks rows as they are obtained from the table."
msgstr ""
"<firstterm>Предложения блокировки</firstterm> включают в себя <literal>FOR "
"UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</"
"literal> и <literal>FOR KEY SHARE</literal>; они влияют на то, как "
"<literal>SELECT</literal> блокирует строки, получаемые из таблицы."

#: ref/select.xml:1410(para)
msgid ""
"The locking clause has the general form <synopsis>\n"
"FOR <replaceable>lock_strength</replaceable> [ OF <replaceable class="
"\"parameter\">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ]\n"
"</synopsis> where <replaceable>lock_strength</replaceable> can be one of "
"<synopsis>\n"
"UPDATE\n"
"NO KEY UPDATE\n"
"SHARE\n"
"KEY SHARE\n"
"</synopsis>"
msgstr ""
"Предложение блокировки имеет следующую общую форму: <synopsis>\n"
"FOR <replaceable>вариант_блокировки</replaceable> [ OF <replaceable class="
"\"parameter\">имя_таблицы</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ]\n"
"</synopsis> Здесь <replaceable>вариант_блокировки</replaceable> может быть "
"следующим: <synopsis>\n"
"UPDATE\n"
"NO KEY UPDATE\n"
"SHARE\n"
"KEY SHARE\n"
"</synopsis>"

#: ref/select.xml:1427(para)
msgid ""
"For more information on each row-level lock mode, refer to <xref linkend="
"\"locking-rows\"/>."
msgstr ""
"Подробнее о каждом режиме блокировки на уровне строк можно узнать в <xref "
"remap=\"6\" linkend=\"locking-rows\"/>."

#: ref/select.xml:1432(para)
msgid ""
"To prevent the operation from waiting for other transactions to commit, use "
"either the <literal>NOWAIT</literal> or <literal>SKIP LOCKED</literal> "
"option. With <literal>NOWAIT</literal>, the statement reports an error, "
"rather than waiting, if a selected row cannot be locked immediately. With "
"<literal>SKIP LOCKED</literal>, any selected rows that cannot be immediately "
"locked are skipped. Skipping locked rows provides an inconsistent view of "
"the data, so this is not suitable for general purpose work, but can be used "
"to avoid lock contention with multiple consumers accessing a queue-like "
"table. Note that <literal>NOWAIT</literal> and <literal>SKIP LOCKED</"
"literal> apply only to the row-level lock(s) &mdash; the required "
"<literal>ROW SHARE</literal> table-level lock is still taken in the ordinary "
"way (see <xref linkend=\"mvcc\"/>). You can use <xref linkend=\"sql-lock\"/> "
"with the <literal>NOWAIT</literal> option first, if you need to acquire the "
"table-level lock without waiting."
msgstr ""
"Чтобы операция не ждала завершения других транзакций, к блокировке можно "
"добавить указание <literal>NOWAIT</literal> или <literal>SKIP LOCKED</"
"literal>. С <literal>NOWAIT</literal> оператор выдаёт ошибку, а не ждёт, "
"если выбранную строку нельзя заблокировать немедленно. С указанием "
"<literal>SKIP LOCKED</literal> выбранные строки, которые нельзя "
"заблокировать немедленно, пропускаются. При этом формируется несогласованное "
"представление данных, так что этот вариант не подходит для общего "
"применения, но может использоваться для исключения блокировок при обращении "
"множества потребителей к таблице типа очереди. Заметьте, что указания "
"<literal>NOWAIT</literal> и <literal>SKIP LOCKED</literal> применяются "
"только к блокировкам на уровне строк &mdash; необходимая блокировка "
"<literal>ROW SHARE</literal> уровня таблицы запрашивается обычным способом "
"(см. <xref remap=\"4\" linkend=\"mvcc\"/>). Если требуется запросить "
"блокировку уровня таблицы без ожидания, можно сначала выполнить <xref "
"linkend=\"sql-lock\"/> с указанием <literal>NOWAIT</literal>."

#: ref/select.xml:1451(para)
msgid ""
"If specific tables are named in a locking clause, then only rows coming from "
"those tables are locked; any other tables used in the <command>SELECT</"
"command> are simply read as usual. A locking clause without a table list "
"affects all tables used in the statement. If a locking clause is applied to "
"a view or sub-query, it affects all tables used in the view or sub-query. "
"However, these clauses do not apply to <literal>WITH</literal> queries "
"referenced by the primary query. If you want row locking to occur within a "
"<literal>WITH</literal> query, specify a locking clause within the "
"<literal>WITH</literal> query."
msgstr ""
"Если в предложении блокировки указаны определённые таблицы, блокироваться "
"будут только строки, получаемые из этих таблиц; другие таблицы, "
"задействованные в <command>SELECT</command>, будут прочитаны как обычно. "
"Предложение блокировки без списка таблиц затрагивает все таблицы, "
"задействованные в этом операторе. Если предложение блокировки применяется к "
"представлению или подзапросу, оно затрагивает все таблицы, которые "
"используются в представлении или подзапросе. Однако эти предложения не "
"применяются к запросам <literal>WITH</literal>, к которым обращается "
"основной запрос. Если требуется установить блокировку строк в запросе "
"<literal>WITH</literal>, предложение блокировки нужно указать "
"непосредственно в этом запросе <literal>WITH</literal>."

#: ref/select.xml:1466(para)
msgid ""
"Multiple locking clauses can be written if it is necessary to specify "
"different locking behavior for different tables. If the same table is "
"mentioned (or implicitly affected) by more than one locking clause, then it "
"is processed as if it was only specified by the strongest one. Similarly, a "
"table is processed as <literal>NOWAIT</literal> if that is specified in any "
"of the clauses affecting it. Otherwise, it is processed as <literal>SKIP "
"LOCKED</literal> if that is specified in any of the clauses affecting it."
msgstr ""
"В случае необходимости задать для разных таблиц разное поведение блокировки, "
"в запрос можно добавить несколько предложений. Если при этом одна и та же "
"таблица упоминается (или неявно затрагивается) в нескольких предложениях "
"блокировки, блокировка устанавливается так, как если бы было указано только "
"одно, самое сильное из них. Подобным образом, если в одном из предложений "
"указано <literal>NOWAIT</literal>, для этой таблицы блокировка будет "
"запрашиваться без ожидания. В противном случае она будет обработана в режиме "
"<literal>SKIP LOCKED</literal>, если он выбран в любом из затрагивающих её "
"предложений."

#: ref/select.xml:1479(para)
msgid ""
"The locking clauses cannot be used in contexts where returned rows cannot be "
"clearly identified with individual table rows; for example they cannot be "
"used with aggregation."
msgstr ""
"Предложения блокировки не могут применяться в контекстах, где возвращаемые "
"строки нельзя чётко связать с отдельными строками таблицы; например, "
"блокировка неприменима при агрегировании."

#: ref/select.xml:1485(para)
msgid ""
"When a locking clause appears at the top level of a <command>SELECT</"
"command> query, the rows that are locked are exactly those that are returned "
"by the query; in the case of a join query, the rows locked are those that "
"contribute to returned join rows. In addition, rows that satisfied the query "
"conditions as of the query snapshot will be locked, although they will not "
"be returned if they were updated after the snapshot and no longer satisfy "
"the query conditions. If a <literal>LIMIT</literal> is used, locking stops "
"once enough rows have been returned to satisfy the limit (but note that rows "
"skipped over by <literal>OFFSET</literal> will get locked). Similarly, if a "
"locking clause is used in a cursor's query, only rows actually fetched or "
"stepped past by the cursor will be locked."
msgstr ""
"Когда предложение блокировки находится на верхнем уровне запроса "
"<command>SELECT</command>, блокируются именно те строки, которые "
"возвращаются запросом; в случае с запросом объединения, блокировке подлежат "
"строки, из которых составляются возвращаемые строки объединения. В "
"дополнение к этому, заблокированы будут строки, удовлетворяющие условиям "
"запроса на момент создания снимка запроса, хотя они не будут возвращены, "
"если с момента снимка они изменятся и перестанут удовлетворять условиям. "
"Если применяется <literal>LIMIT</literal>, блокировка прекращается, как "
"только будет получено достаточное количество строк для удовлетворения лимита "
"(но заметьте, что строки, пропускаемые указанием <literal>OFFSET</literal>, "
"будут блокироваться). Подобным образом, если предложение блокировки "
"применяется в запросе курсора, блокироваться будут только строки, фактически "
"полученные или пройденные курсором."

#: ref/select.xml:1509(programlisting)
#, no-wrap
msgid "SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;"
msgstr "SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;"

#: ref/select.xml:1502(para)
msgid ""
"When a locking clause appears in a sub-<command>SELECT</command>, the rows "
"locked are those returned to the outer query by the sub-query. This might "
"involve fewer rows than inspection of the sub-query alone would suggest, "
"since conditions from the outer query might be used to optimize execution of "
"the sub-query. For example, <placeholder-1/> will lock only rows having "
"<literal>col1 = 5</literal>, even though that condition is not textually "
"within the sub-query."
msgstr ""
"Когда предложение блокировки находится в подзапросе <command>SELECT</"
"command>, блокировке подлежат те строки, которые будет получены внешним "
"запросом от подзапроса. Таких строк может оказаться меньше, чем можно было "
"бы предположить, проанализировав только сам подзапрос, так как условия из "
"внешнего запроса могут способствовать оптимизации выполнения подзапроса. "
"Например, запрос <placeholder-1/> заблокирует только строки, в которых "
"<literal>col1 = 5</literal>, при том, что в такой записи условие не "
"относится к подзапросу."

#: ref/select.xml:1519(programlisting)
#, no-wrap
msgid ""
"BEGIN;\n"
"SELECT * FROM mytable WHERE key = 1 FOR UPDATE;\n"
"SAVEPOINT s;\n"
"UPDATE mytable SET ... WHERE key = 1;\n"
"ROLLBACK TO s;"
msgstr ""
"BEGIN;\n"
"SELECT * FROM mytable WHERE key = 1 FOR UPDATE;\n"
"SAVEPOINT s;\n"
"UPDATE mytable SET ... WHERE key = 1;\n"
"ROLLBACK TO s;"

#: ref/select.xml:1516(para)
msgid ""
"Previous releases failed to preserve a lock which is upgraded by a later "
"savepoint. For example, this code: <placeholder-1/> would fail to preserve "
"the <literal>FOR UPDATE</literal> lock after the <command>ROLLBACK TO</"
"command>. This has been fixed in release 9.3."
msgstr ""
"Предыдущие версии не могли сохранить блокировку, которая была повышена "
"последующей точкой сохранения. Например, этот код: <placeholder-1/> не мог "
"сохранить блокировку <literal>FOR UPDATE</literal> после <command>ROLLBACK "
"TO</command>. Это было исправлено в версии 9.3."

#: ref/select.xml:1543(programlisting)
#, no-wrap
msgid "SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;"
msgstr "SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;"

#: ref/select.xml:1531(para)
msgid ""
"It is possible for a <command>SELECT</command> command running at the "
"<literal>READ COMMITTED</literal> transaction isolation level and using "
"<literal>ORDER BY</literal> and a locking clause to return rows out of "
"order. This is because <literal>ORDER BY</literal> is applied first. The "
"command sorts the result, but might then block trying to obtain a lock on "
"one or more of the rows. Once the <literal>SELECT</literal> unblocks, some "
"of the ordering column values might have been modified, leading to those "
"rows appearing to be out of order (though they are in order in terms of the "
"original column values). This can be worked around at need by placing the "
"<literal>FOR UPDATE/SHARE</literal> clause in a sub-query, for example "
"<placeholder-1/> Note that this will result in locking all rows of "
"<structname>mytable</structname>, whereas <literal>FOR UPDATE</literal> at "
"the top level would lock only the actually returned rows. This can make for "
"a significant performance difference, particularly if the <literal>ORDER BY</"
"literal> is combined with <literal>LIMIT</literal> or other restrictions. So "
"this technique is recommended only if concurrent updates of the ordering "
"columns are expected and a strictly sorted result is required."
msgstr ""
"Возможно, что команда <command>SELECT</command>, работающая на уровне "
"изоляции <literal>READ COMMITTED</literal> и применяющая предложение "
"<literal>ORDER BY</literal> вместе с блокировкой, будет возвращать строки не "
"по порядку. Это связано с тем, что <literal>ORDER BY</literal> выполняется в "
"первую очередь. Эта команда отсортирует результат, но затем может быть "
"заблокирована, пытаясь получить блокировку одной или нескольких строк. К "
"моменту, когда блокировка <literal>SELECT</literal> будет снята, некоторые "
"из сортируемых столбцов могут уже измениться, в результате чего их порядок "
"может быть нарушен (хотя они были упорядочены для исходных значений). При "
"необходимости обойти эту проблему, можно поместить <literal>FOR UPDATE/"
"SHARE</literal> в подзапрос, например так: <placeholder-1/> Заметьте, что в "
"результате это приведёт к блокированию всех строк в <structname>mytable</"
"structname>, тогда как указание <literal>FOR UPDATE</literal> на верхнем "
"уровне могло бы заблокировать только фактически возвращаемые строки. Это "
"может значительно повлиять на производительность, особенно в сочетании "
"<literal>ORDER BY</literal> с <literal>LIMIT</literal> или другими "
"ограничениями. Таким образом, этот приём рекомендуется, только если "
"ожидается параллельное изменение сортируемых столбцов, а результат должен "
"быть строго отсортирован."

#: ref/select.xml:1555(para)
msgid ""
"At the <literal>REPEATABLE READ</literal> or <literal>SERIALIZABLE</literal> "
"transaction isolation level this would cause a serialization failure (with a "
"<literal>SQLSTATE</literal> of <literal>'40001'</literal>), so there is no "
"possibility of receiving rows out of order under these isolation levels."
msgstr ""
"На уровнях изоляции <literal>REPEATABLE READ</literal> и "
"<literal>SERIALIZABLE</literal> это приведёт к ошибке сериализации (с "
"<literal>SQLSTATE</literal> равным <literal>'40001'</literal>), так что на "
"этих уровнях получить строки не по порядку невозможно."

#: ref/select.xml:1565(title)
msgid "<literal>TABLE</literal> Command"
msgstr "Команда <literal>TABLE</literal>"

#: ref/select.xml:1569(programlisting)
#, no-wrap
msgid "TABLE <replaceable class=\"parameter\">name</replaceable>"
msgstr "TABLE <replaceable class=\"parameter\">имя</replaceable>"

#: ref/select.xml:1573(programlisting)
#, no-wrap
msgid "SELECT * FROM <replaceable class=\"parameter\">name</replaceable>"
msgstr "SELECT * FROM <replaceable class=\"parameter\">имя</replaceable>"

#: ref/select.xml:1567(para)
msgid ""
"The command <placeholder-1/> is equivalent to <placeholder-2/> It can be "
"used as a top-level command or as a space-saving syntax variant in parts of "
"complex queries. Only the <literal>WITH</literal>, <literal>UNION</literal>, "
"<literal>INTERSECT</literal>, <literal>EXCEPT</literal>, <literal>ORDER BY</"
"literal>, <literal>LIMIT</literal>, <literal>OFFSET</literal>, "
"<literal>FETCH</literal> and <literal>FOR</literal> locking clauses can be "
"used with <command>TABLE</command>; the <literal>WHERE</literal> clause and "
"any form of aggregation cannot be used."
msgstr ""
"Команда <placeholder-1/> равнозначна <placeholder-2/> Её можно применять в "
"качестве команды верхнего уровня или как более краткую запись внутри сложных "
"запросов. С командой <command>TABLE</command> могут использоваться только "
"предложения <literal>WITH</literal>, <literal>UNION</literal>, "
"<literal>INTERSECT</literal>, <literal>EXCEPT</literal>, <literal>ORDER BY</"
"literal>, <literal>LIMIT</literal>, <literal>OFFSET</literal>, "
"<literal>FETCH</literal> и предложения блокировки <literal>FOR</literal>; "
"предложение <literal>WHERE</literal> и какие-либо формы агрегирования не "
"поддерживаются."

#: ref/select.xml:1589(title)
msgid "Examples"
msgstr "Примеры"

#: ref/select.xml:1595(programlisting)
#, no-wrap
msgid ""
"SELECT f.title, f.did, d.name, f.date_prod, f.kind\n"
"    FROM distributors d, films f\n"
"    WHERE f.did = d.did\n"
"\n"
"       title       | did |     name     | date_prod  |   kind\n"
"-------------------+-----+--------------+------------+----------\n"
" The Third Man     | 101 | British Lion | 1949-12-23 | Drama\n"
" The African Queen | 101 | British Lion | 1951-08-11 | Romantic\n"
" ..."
msgstr ""
"SELECT f.title, f.did, d.name, f.date_prod, f.kind\n"
"    FROM distributors d, films f\n"
"    WHERE f.did = d.did\n"
"\n"
"       title       | did |     name     | date_prod  |   kind\n"
"-------------------+-----+--------------+------------+----------\n"
" The Third Man     | 101 | British Lion | 1949-12-23 | Drama\n"
" The African Queen | 101 | British Lion | 1951-08-11 | Romantic\n"
" ..."

#: ref/select.xml:1591(para)
msgid ""
"To join the table <literal>films</literal> with the table "
"<literal>distributors</literal>: <placeholder-1/>"
msgstr ""
"Соединение таблицы <literal>films</literal> с таблицей "
"<literal>distributors</literal>: <placeholder-1/>"

#: ref/select.xml:1612(programlisting)
#, no-wrap
msgid ""
"SELECT kind, sum(len) AS total FROM films GROUP BY kind;\n"
"\n"
"   kind   | total\n"
"----------+-------\n"
" Action   | 07:34\n"
" Comedy   | 02:58\n"
" Drama    | 14:28\n"
" Musical  | 06:42\n"
" Romantic | 04:38"
msgstr ""
"SELECT kind, sum(len) AS total FROM films GROUP BY kind;\n"
"\n"
"   kind   | total\n"
"----------+-------\n"
" Action   | 07:34\n"
" Comedy   | 02:58\n"
" Drama    | 14:28\n"
" Musical  | 06:42\n"
" Romantic | 04:38"

#: ref/select.xml:1608(para)
msgid ""
"To sum the column <literal>len</literal> of all films and group the results "
"by <literal>kind</literal>: <placeholder-1/>"
msgstr ""
"Суммирование значений столбца <literal>len</literal> (продолжительность) для "
"всех фильмов и группирование результатов по столбцу <literal>kind</literal> "
"(типу фильма): <placeholder-1/>"

#: ref/select.xml:1630(programlisting)
#, no-wrap
msgid ""
"SELECT kind, sum(len) AS total\n"
"    FROM films\n"
"    GROUP BY kind\n"
"    HAVING sum(len) &lt; interval '5 hours';\n"
"\n"
"   kind   | total\n"
"----------+-------\n"
" Comedy   | 02:58\n"
" Romantic | 04:38"
msgstr ""
"SELECT kind, sum(len) AS total\n"
"    FROM films\n"
"    GROUP BY kind\n"
"    HAVING sum(len) &lt; interval '5 hours';\n"
"\n"
"   kind   | total\n"
"----------+-------\n"
" Comedy   | 02:58\n"
" Romantic | 04:38"

#: ref/select.xml:1625(para)
msgid ""
"To sum the column <literal>len</literal> of all films, group the results by "
"<literal>kind</literal> and show those group totals that are less than 5 "
"hours: <placeholder-1/>"
msgstr ""
"Суммирование значений столбца <literal>len</literal> для всех фильмов, "
"группирование результатов по столбцу <literal>kind</literal> и вывод только "
"тех групп, общая продолжительность которых меньше 5 часов: <placeholder-1/>"

#: ref/select.xml:1648(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM distributors ORDER BY name;\n"
"SELECT * FROM distributors ORDER BY 2;\n"
"\n"
" did |       name\n"
"-----+------------------\n"
" 109 | 20th Century Fox\n"
" 110 | Bavaria Atelier\n"
" 101 | British Lion\n"
" 107 | Columbia\n"
" 102 | Jean Luc Godard\n"
" 113 | Luso films\n"
" 104 | Mosfilm\n"
" 103 | Paramount\n"
" 106 | Toho\n"
" 105 | United Artists\n"
" 111 | Walt Disney\n"
" 112 | Warner Bros.\n"
" 108 | Westward"
msgstr ""
"SELECT * FROM distributors ORDER BY name;\n"
"SELECT * FROM distributors ORDER BY 2;\n"
"\n"
" did |       name\n"
"-----+------------------\n"
" 109 | 20th Century Fox\n"
" 110 | Bavaria Atelier\n"
" 101 | British Lion\n"
" 107 | Columbia\n"
" 102 | Jean Luc Godard\n"
" 113 | Luso films\n"
" 104 | Mosfilm\n"
" 103 | Paramount\n"
" 106 | Toho\n"
" 105 | United Artists\n"
" 111 | Walt Disney\n"
" 112 | Warner Bros.\n"
" 108 | Westward"

#: ref/select.xml:1643(para)
msgid ""
"The following two examples are identical ways of sorting the individual "
"results according to the contents of the second column (<literal>name</"
"literal>): <placeholder-1/>"
msgstr ""
"Следующие два запроса демонстрируют равнозначные способы сортировки "
"результатов по содержимому второго столбца (<literal>name</literal>): "
"<placeholder-1/>"

#: ref/select.xml:1677(programlisting)
#, no-wrap
msgid ""
"distributors:               actors:\n"
" did |     name              id |     name\n"
"-----+--------------        ----+----------------\n"
" 108 | Westward               1 | Woody Allen\n"
" 111 | Walt Disney            2 | Warren Beatty\n"
" 112 | Warner Bros.           3 | Walter Matthau\n"
" ...                         ...\n"
"\n"
"SELECT distributors.name\n"
"    FROM distributors\n"
"    WHERE distributors.name LIKE 'W%'\n"
"UNION\n"
"SELECT actors.name\n"
"    FROM actors\n"
"    WHERE actors.name LIKE 'W%';\n"
"\n"
"      name\n"
"----------------\n"
" Walt Disney\n"
" Walter Matthau\n"
" Warner Bros.\n"
" Warren Beatty\n"
" Westward\n"
" Woody Allen"
msgstr ""
"distributors:               actors:\n"
" did |     name              id |     name\n"
"-----+--------------        ----+----------------\n"
" 108 | Westward               1 | Woody Allen\n"
" 111 | Walt Disney            2 | Warren Beatty\n"
" 112 | Warner Bros.           3 | Walter Matthau\n"
" ...                         ...\n"
"\n"
"SELECT distributors.name\n"
"    FROM distributors\n"
"    WHERE distributors.name LIKE 'W%'\n"
"UNION\n"
"SELECT actors.name\n"
"    FROM actors\n"
"    WHERE actors.name LIKE 'W%';\n"
"\n"
"      name\n"
"----------------\n"
" Walt Disney\n"
" Walter Matthau\n"
" Warner Bros.\n"
" Warren Beatty\n"
" Westward\n"
" Woody Allen"

#: ref/select.xml:1670(para)
msgid ""
"The next example shows how to obtain the union of the tables "
"<literal>distributors</literal> and <literal>actors</literal>, restricting "
"the results to those that begin with the letter W in each table. Only "
"distinct rows are wanted, so the key word <literal>ALL</literal> is omitted. "
"<placeholder-1/>"
msgstr ""
"Следующий пример показывает объединение таблиц <literal>distributors</"
"literal> и <literal>actors</literal>, ограниченное именами, начинающимися с "
"буквы W в каждой таблице. Интерес представляют только неповторяющиеся "
"строки, поэтому ключевое слово <literal>ALL</literal> опущено. "
"<placeholder-1/>"

#: ref/select.xml:1709(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$\n"
"    SELECT * FROM distributors WHERE did = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM distributors(111);\n"
" did |    name\n"
"-----+-------------\n"
" 111 | Walt Disney\n"
"\n"
"CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$\n"
"    SELECT * FROM distributors WHERE did = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM distributors_2(111) AS (f1 int, f2 text);\n"
" f1  |     f2\n"
"-----+-------------\n"
" 111 | Walt Disney"
msgstr ""
"CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$\n"
"    SELECT * FROM distributors WHERE did = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM distributors(111);\n"
" did |    name\n"
"-----+-------------\n"
" 111 | Walt Disney\n"
"\n"
"CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$\n"
"    SELECT * FROM distributors WHERE did = $1;\n"
"$$ LANGUAGE SQL;\n"
"\n"
"SELECT * FROM distributors_2(111) AS (f1 int, f2 text);\n"
" f1  |     f2\n"
"-----+-------------\n"
" 111 | Walt Disney"

#: ref/select.xml:1705(para)
msgid ""
"This example shows how to use a function in the <literal>FROM</literal> "
"clause, both with and without a column definition list: <placeholder-1/>"
msgstr ""
"Этот пример показывает, как использовать функцию в предложении "
"<literal>FROM</literal>, со списком определений столбцов и без него: "
"<placeholder-1/>"

#: ref/select.xml:1733(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;\n"
" unnest | ordinality\n"
"--------+----------\n"
" a      |        1\n"
" b      |        2\n"
" c      |        3\n"
" d      |        4\n"
" e      |        5\n"
" f      |        6\n"
"(6 rows)"
msgstr ""
"SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;\n"
" unnest | ordinality\n"
"--------+----------\n"
" a      |        1\n"
" b      |        2\n"
" c      |        3\n"
" d      |        4\n"
" e      |        5\n"
" f      |        6\n"
"(6 rows)"

#: ref/select.xml:1730(para)
msgid ""
"Here is an example of a function with an ordinality column added: "
"<placeholder-1/>"
msgstr "Пример функции с добавленным столбцом нумерации: <placeholder-1/>"

#: ref/select.xml:1750(programlisting)
#, no-wrap
msgid ""
"WITH t AS (\n"
"    SELECT random() as x FROM generate_series(1, 3)\n"
"  )\n"
"SELECT * FROM t\n"
"UNION ALL\n"
"SELECT * FROM t\n"
"\n"
"         x          \n"
"--------------------\n"
"  0.534150459803641\n"
"  0.520092216785997\n"
" 0.0735620250925422\n"
"  0.534150459803641\n"
"  0.520092216785997\n"
" 0.0735620250925422"
msgstr ""
"WITH t AS (\n"
"    SELECT random() as x FROM generate_series(1, 3)\n"
"  )\n"
"SELECT * FROM t\n"
"UNION ALL\n"
"SELECT * FROM t\n"
"\n"
"         x          \n"
"--------------------\n"
"  0.534150459803641\n"
"  0.520092216785997\n"
" 0.0735620250925422\n"
"  0.534150459803641\n"
"  0.520092216785997\n"
" 0.0735620250925422"

#: ref/select.xml:1747(para)
msgid ""
"This example shows how to use a simple <literal>WITH</literal> clause: "
"<placeholder-1/> Notice that the <literal>WITH</literal> query was evaluated "
"only once, so that we got two sets of the same three random values."
msgstr ""
"Этот пример показывает, как использовать простое предложение <literal>WITH</"
"literal>: <placeholder-1/> Заметьте, что запрос <literal>WITH</literal> "
"выполняется всего один раз, поэтому мы получаем два одинаковых набора по три "
"случайных значения."

#: ref/select.xml:1778(programlisting)
#, no-wrap
msgid ""
"WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (\n"
"    SELECT 1, employee_name, manager_name\n"
"    FROM employee\n"
"    WHERE manager_name = 'Mary'\n"
"  UNION ALL\n"
"    SELECT er.distance + 1, e.employee_name, e.manager_name\n"
"    FROM employee_recursive er, employee e\n"
"    WHERE er.employee_name = e.manager_name\n"
"  )\n"
"SELECT distance, employee_name FROM employee_recursive;"
msgstr ""
"WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (\n"
"    SELECT 1, employee_name, manager_name\n"
"    FROM employee\n"
"    WHERE manager_name = 'Mary'\n"
"  UNION ALL\n"
"    SELECT er.distance + 1, e.employee_name, e.manager_name\n"
"    FROM employee_recursive er, employee e\n"
"    WHERE er.employee_name = e.manager_name\n"
"  )\n"
"SELECT distance, employee_name FROM employee_recursive;"

#: ref/select.xml:1772(para)
msgid ""
"This example uses <literal>WITH RECURSIVE</literal> to find all subordinates "
"(direct or indirect) of the employee Mary, and their level of indirectness, "
"from a table that shows only direct subordinates: <placeholder-1/> Notice "
"the typical form of recursive queries: an initial condition, followed by "
"<literal>UNION</literal>, followed by the recursive part of the query. Be "
"sure that the recursive part of the query will eventually return no tuples, "
"or else the query will loop indefinitely. (See <xref linkend=\"queries-with"
"\"/> for more examples.)"
msgstr ""
"В этом примере <literal>WITH RECURSIVE</literal> применяется для поиска всех "
"подчинённых Мери (непосредственных или косвенных) и вывода их уровня "
"косвенности в таблице с информацией только о непосредственных подчинённых: "
"<placeholder-1/> Заметьте, что это типичная форма рекурсивных запросов: "
"начальное условие, последующий <literal>UNION</literal>, а затем рекурсивная "
"часть запроса. Убедитесь в том, что рекурсивная часть запроса в конце концов "
"перестанет возвращать строки, иначе запрос окажется в бесконечном цикле. (За "
"другими примерами обратитесь к <xref remap=\"3\" linkend=\"queries-with\"/>.)"

#: ref/select.xml:1804(programlisting)
#, no-wrap
msgid ""
"SELECT m.name AS mname, pname\n"
"FROM manufacturers m, LATERAL get_product_names(m.id) pname;"
msgstr ""
"SELECT m.name AS mname, pname\n"
"FROM manufacturers m, LATERAL get_product_names(m.id) pname;"

#: ref/select.xml:1813(programlisting)
#, no-wrap
msgid ""
"SELECT m.name AS mname, pname\n"
"FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;"
msgstr ""
"SELECT m.name AS mname, pname\n"
"FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;"

#: ref/select.xml:1799(para)
msgid ""
"This example uses <literal>LATERAL</literal> to apply a set-returning "
"function <function>get_product_names()</function> for each row of the "
"<structname>manufacturers</structname> table: <placeholder-1/> Manufacturers "
"not currently having any products would not appear in the result, since it "
"is an inner join. If we wished to include the names of such manufacturers in "
"the result, we could do: <placeholder-2/>"
msgstr ""
"В этом примере используется <literal>LATERAL</literal> для применения "
"функции <function>get_product_names()</function>, возвращающей множество, "
"для каждой строки таблицы <structname>manufacturers</structname>: "
"<placeholder-1/> Производители, с которыми в данный момент не связаны "
"никакие продукты, не попадут в результат, так как это внутреннее соединение. "
"Если бы мы захотели включить названия и этих производителей, мы могли бы "
"сделать так: <placeholder-2/>"

#: ref/select.xml:1820(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ref/select.xml:1822(para)
msgid ""
"Of course, the <command>SELECT</command> statement is compatible with the "
"SQL standard. But there are some extensions and some missing features."
msgstr ""
"Разумеется, оператор <command>SELECT</command> совместим со стандартом SQL. "
"Однако не все описанные в стандарте возможности реализованы, а некоторые, "
"наоборот, являются расширениями."

#: ref/select.xml:1829(title)
msgid "Omitted <literal>FROM</literal> Clauses"
msgstr "Необязательное предложение <literal>FROM</literal>"

#: ref/select.xml:1835(programlisting)
#, no-wrap
msgid ""
"SELECT 2+2;\n"
"\n"
" ?column?\n"
"----------\n"
"        4"
msgstr ""
"SELECT 2+2;\n"
"\n"
" ?column?\n"
"----------\n"
"        4"

#: ref/select.xml:1831(para)
msgid ""
"<productname>PostgreSQL</productname> allows one to omit the <literal>FROM</"
"literal> clause. It has a straightforward use to compute the results of "
"simple expressions: <placeholder-1/> Some other <acronym>SQL</acronym> "
"databases cannot do this except by introducing a dummy one-row table from "
"which to do the <command>SELECT</command>."
msgstr ""
"<productname>PostgreSQL</productname> разрешает опустить предложение "
"<literal>FROM</literal>. Это позволяет очень легко вычислять результаты "
"простых выражений: <placeholder-1/> Некоторые другие базы данных "
"<acronym>SQL</acronym> не допускают этого, требуя задействовать в "
"<command>SELECT</command> фиктивную таблицу с одной строкой."

#: ref/select.xml:1851(programlisting)
#, no-wrap
msgid "SELECT distributors.* WHERE distributors.name = 'Westward';"
msgstr "SELECT distributors.* WHERE distributors.name = 'Westward';"

#: ref/select.xml:1847(para)
msgid ""
"Note that if a <literal>FROM</literal> clause is not specified, the query "
"cannot reference any database tables. For example, the following query is "
"invalid: <placeholder-1/> <productname>PostgreSQL</productname> releases "
"prior to 8.1 would accept queries of this form, and add an implicit entry to "
"the query's <literal>FROM</literal> clause for each table referenced by the "
"query. This is no longer allowed."
msgstr ""
"Заметьте, что если предложение <literal>FROM</literal> не указано, запрос не "
"может обращаться ни к каким таблицам базы данных. Например, следующий запрос "
"недопустим: <placeholder-1/> До версии 8.1 <productname>PostgreSQL</"
"productname> мог принимать запросы такого вида, неявно добавляя каждую "
"таблицу, задействованную в запросе, в предложение <literal>FROM</literal> "
"этого запроса. Теперь это не допускается."

#: ref/select.xml:1862(title)
msgid "Empty <literal>SELECT</literal> Lists"
msgstr "Пустые списки <literal>SELECT</literal>"

#: ref/select.xml:1864(para)
msgid ""
"The list of output expressions after <literal>SELECT</literal> can be empty, "
"producing a zero-column result table. This is not valid syntax according to "
"the SQL standard. <productname>PostgreSQL</productname> allows it to be "
"consistent with allowing zero-column tables. However, an empty list is not "
"allowed when <literal>DISTINCT</literal> is used."
msgstr ""
"Список выходных выражений после <literal>SELECT</literal> может быть пустым, "
"что в результате даст таблицу без столбцов. Стандарт SQL не считает такой "
"синтаксис допустимым, но <productname>PostgreSQL</productname> допускает "
"его, так как это согласуется с возможностью иметь таблицы с нулём столбцов. "
"Однако, когда используется <literal>DISTINCT</literal>, пустой список не "
"допускается."

#: ref/select.xml:1875(title)
msgid "Omitting the <literal>AS</literal> Key Word"
msgstr "Необязательное ключевое слово <literal>AS</literal>"

#: ref/select.xml:1877(para)
msgid ""
"In the SQL standard, the optional key word <literal>AS</literal> can be "
"omitted before an output column name whenever the new column name is a valid "
"column name (that is, not the same as any reserved keyword). "
"<productname>PostgreSQL</productname> is slightly more restrictive: "
"<literal>AS</literal> is required if the new column name matches any keyword "
"at all, reserved or not. Recommended practice is to use <literal>AS</"
"literal> or double-quote output column names, to prevent any possible "
"conflict against future keyword additions."
msgstr ""
"В стандарте SQL необязательное ключевое слово <literal>AS</literal> можно "
"опустить перед именем выходного столбца, если это имя является допустимым "
"именем столбца (то есть не совпадает с каким-либо зарезервированным ключевым "
"словом). <productname>PostgreSQL</productname> несколько более строг: "
"<literal>AS</literal> требуется, если имя столбца совпадает с любым ключевым "
"словом, зарезервированным или нет. Тем не менее, рекомендуется использовать "
"<literal>AS</literal> или заключать имена выходных столбцов в кавычки, во "
"избежание конфликтов, возможных при появлении в будущем новых ключевых слов."

#: ref/select.xml:1888(para)
msgid ""
"In <literal>FROM</literal> items, both the standard and "
"<productname>PostgreSQL</productname> allow <literal>AS</literal> to be "
"omitted before an alias that is an unreserved keyword. But this is "
"impractical for output column names, because of syntactic ambiguities."
msgstr ""
"В списке <literal>FROM</literal> и стандарт, и <productname>PostgreSQL</"
"productname> позволяют опускать <literal>AS</literal> перед псевдонимом, "
"который является незарезервированным ключевым словом. Но для имён выходных "
"столбцов это не подходит из-за синтаксической неоднозначности."

#: ref/select.xml:1898(title)
msgid "<literal>ONLY</literal> and Inheritance"
msgstr "<literal>ONLY</literal> и наследование"

#: ref/select.xml:1900(para)
msgid ""
"The SQL standard requires parentheses around the table name when writing "
"<literal>ONLY</literal>, for example <literal>SELECT * FROM ONLY (tab1), "
"ONLY (tab2) WHERE ...</literal>. <productname>PostgreSQL</productname> "
"considers these parentheses to be optional."
msgstr ""
"Стандарт SQL требует заключать в скобки имя таблицы после <literal>ONLY</"
"literal>, например <literal>SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ..."
"</literal>. <productname>PostgreSQL</productname> считает эти скобки "
"необязательными."

#: ref/select.xml:1907(para)
msgid ""
"<productname>PostgreSQL</productname> allows a trailing <literal>*</literal> "
"to be written to explicitly specify the non-<literal>ONLY</literal> behavior "
"of including child tables. The standard does not allow this."
msgstr ""
"<productname>PostgreSQL</productname> позволяет добавлять в конце "
"<literal>*</literal>, чтобы явно обозначить, что дочерние таблицы включаются "
"в рассмотрение, в отличие от поведения с <literal>ONLY</literal>. Стандарт "
"не позволяет этого."

#: ref/select.xml:1913(para)
msgid ""
"(These points apply equally to all SQL commands supporting the "
"<literal>ONLY</literal> option.)"
msgstr ""
"(Эти соображения в равной степени касаются всех SQL-команд, поддерживающих "
"параметр <literal>ONLY</literal>.)"

#: ref/select.xml:1920(title)
msgid "<literal>TABLESAMPLE</literal> Clause Restrictions"
msgstr "Ограничения предложения <literal>TABLESAMPLE</literal>"

#: ref/select.xml:1922(para)
msgid ""
"The <literal>TABLESAMPLE</literal> clause is currently accepted only on "
"regular tables and materialized views. According to the SQL standard it "
"should be possible to apply it to any <literal>FROM</literal> item."
msgstr ""
"Предложение <literal>TABLESAMPLE</literal> в настоящий момент принимается "
"только для обычных таблиц и материализованных представлений. Однако согласно "
"стандарту SQL оно должно применяться к любым элементам списка <literal>FROM</"
"literal>."

#: ref/select.xml:1930(title)
msgid "Function Calls in <literal>FROM</literal>"
msgstr "Вызовы функций в предложении <literal>FROM</literal>"

#: ref/select.xml:1932(para)
msgid ""
"<productname>PostgreSQL</productname> allows a function call to be written "
"directly as a member of the <literal>FROM</literal> list. In the SQL "
"standard it would be necessary to wrap such a function call in a sub-"
"<command>SELECT</command>; that is, the syntax <literal>FROM "
"<replaceable>func</replaceable>(...) <replaceable>alias</replaceable></"
"literal> is approximately equivalent to <literal>FROM LATERAL (SELECT "
"<replaceable>func</replaceable>(...)) <replaceable>alias</replaceable></"
"literal>. Note that <literal>LATERAL</literal> is considered to be implicit; "
"this is because the standard requires <literal>LATERAL</literal> semantics "
"for an <literal>UNNEST()</literal> item in <literal>FROM</literal>. "
"<productname>PostgreSQL</productname> treats <literal>UNNEST()</literal> the "
"same as other set-returning functions."
msgstr ""
"<productname>PostgreSQL</productname> позволяет записать вызов функции "
"непосредственно в виде элемента списка <literal>FROM</literal>. В стандарте "
"SQL такой вызов функции требуется помещать во вложенный <command>SELECT</"
"command>; то есть, запись <literal>FROM <replaceable>функция</"
"replaceable>(...) <replaceable>псевдоним</replaceable></literal> примерно "
"равнозначна записи <literal>FROM LATERAL (SELECT <replaceable>функция</"
"replaceable>(...)) <replaceable>псевдоним</replaceable></literal>. Заметьте, "
"что указание <literal>LATERAL</literal> считается неявным; это связано с "
"тем, что стандарт требует поведения <literal>LATERAL</literal> для элемента "
"<literal>UNNEST()</literal> в предложении <literal>FROM</literal>. "
"<productname>PostgreSQL</productname> обрабатывает <literal>UNNEST()</"
"literal> так же, как и другие функции, возвращающие множества."

#: ref/select.xml:1949(title)
msgid ""
"Namespace Available to <literal>GROUP BY</literal> and <literal>ORDER BY</"
"literal>"
msgstr ""
"Пространства имён в <literal>GROUP BY</literal> и <literal>ORDER BY</literal>"

#: ref/select.xml:1951(para)
msgid ""
"In the SQL-92 standard, an <literal>ORDER BY</literal> clause can only use "
"output column names or numbers, while a <literal>GROUP BY</literal> clause "
"can only use expressions based on input column names. "
"<productname>PostgreSQL</productname> extends each of these clauses to allow "
"the other choice as well (but it uses the standard's interpretation if there "
"is ambiguity). <productname>PostgreSQL</productname> also allows both "
"clauses to specify arbitrary expressions. Note that names appearing in an "
"expression will always be taken as input-column names, not as output-column "
"names."
msgstr ""
"В стандарте SQL-92 предложение <literal>ORDER BY</literal> может содержать "
"ссылки только на выходные столбцы по именам или номерам, тогда как "
"<literal>GROUP BY</literal> может содержать выражения с именами только "
"входных столбцов. <productname>PostgreSQL</productname> расширяет оба эти "
"предложения, позволяя также применять другие варианты (но если возникает "
"неоднозначность, он разрешает её согласно стандарту). "
"<productname>PostgreSQL</productname> также позволяет задавать произвольные "
"выражения в обоих предложениях. Заметьте, что имена, фигурирующие в "
"выражениях, всегда будут восприниматься как имена входных, а не выходных "
"столбцов."

#: ref/select.xml:1964(para)
msgid ""
"SQL:1999 and later use a slightly different definition which is not entirely "
"upward compatible with SQL-92. In most cases, however, "
"<productname>PostgreSQL</productname> will interpret an <literal>ORDER BY</"
"literal> or <literal>GROUP BY</literal> expression the same way SQL:1999 "
"does."
msgstr ""
"В SQL:1999 и более поздних стандартах введено несколько другое определение, "
"которое не полностью совместимо с SQL-92. Однако в большинстве случаев "
"<productname>PostgreSQL</productname> будет интерпретировать выражение "
"<literal>ORDER BY</literal> или <literal>GROUP BY</literal> так, как требует "
"SQL:1999."

#: ref/select.xml:1974(title)
msgid "Functional Dependencies"
msgstr "Функциональные зависимости"

#: ref/select.xml:1976(para)
msgid ""
"<productname>PostgreSQL</productname> recognizes functional dependency "
"(allowing columns to be omitted from <literal>GROUP BY</literal>) only when "
"a table's primary key is included in the <literal>GROUP BY</literal> list. "
"The SQL standard specifies additional conditions that should be recognized."
msgstr ""
"<productname>PostgreSQL</productname> распознаёт функциональную зависимость "
"(что позволяет опускать столбцы в <literal>GROUP BY</literal>), только когда "
"первичный ключ таблицы присутствует в списке <literal>GROUP BY</literal>. В "
"стандарте SQL оговариваются дополнительные условия, которые следует "
"учитывать."

#: ref/select.xml:1986(title)
msgid "<literal>WINDOW</literal> Clause Restrictions"
msgstr "Ограничения предложения <literal>WINDOW</literal>"

#: ref/select.xml:1988(para)
msgid ""
"The SQL standard provides additional options for the window <replaceable "
"class=\"parameter\">frame_clause</replaceable>. <productname>PostgreSQL</"
"productname> currently supports only the options listed above."
msgstr ""
"Стандарт SQL предоставляет дополнительные возможности для указания "
"<replaceable class=\"parameter\">предложения_рамки</replaceable> окна. "
"<productname>PostgreSQL</productname> в настоящее время поддерживает только "
"варианты, описанные выше."

#: ref/select.xml:1997(title)
msgid "<literal>LIMIT</literal> and <literal>OFFSET</literal>"
msgstr "<literal>LIMIT</literal> и <literal>OFFSET</literal>"

#: ref/select.xml:1999(para)
msgid ""
"The clauses <literal>LIMIT</literal> and <literal>OFFSET</literal> are "
"<productname>PostgreSQL</productname>-specific syntax, also used by "
"<productname>MySQL</productname>. The SQL:2008 standard has introduced the "
"clauses <literal>OFFSET ... FETCH {FIRST|NEXT} ...</literal> for the same "
"functionality, as shown above in <xref linkend=\"sql-limit\" endterm=\"sql-"
"limit-title\"/>. This syntax is also used by <productname>IBM DB2</"
"productname>. (Applications written for <productname>Oracle</productname> "
"frequently use a workaround involving the automatically generated "
"<literal>rownum</literal> column, which is not available in PostgreSQL, to "
"implement the effects of these clauses.)"
msgstr ""
"Предложения <literal>LIMIT</literal> и <literal>OFFSET</literal> относятся к "
"специфическим особенностям <productname>PostgreSQL</productname> и "
"поддерживаются также в <productname>MySQL</productname>. В стандарте "
"SQL:2008 для той же цели вводятся предложения <literal>OFFSET ... FETCH "
"{FIRST|NEXT} ...</literal>, рассмотренные ранее в <xref remap=\"6\" linkend="
"\"sql-limit\" endterm=\"sql-limit-title\"/>. Этот синтаксис также "
"используется в <productname>IBM DB2</productname>. (Приложения, написанные "
"для <productname>Oracle</productname>, часто применяют обходной способ и "
"получают эффект этих предложений, задействуя автоматически генерируемый "
"столбец <literal>rownum</literal>, который отсутствует в PostgreSQL.)"

#: ref/select.xml:2015(title)
msgid ""
"<literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, "
"<literal>FOR SHARE</literal>, <literal>FOR KEY SHARE</literal>"
msgstr ""
"<literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, "
"<literal>FOR SHARE</literal>, <literal>FOR KEY SHARE</literal>"

#: ref/select.xml:2017(para)
msgid ""
"Although <literal>FOR UPDATE</literal> appears in the SQL standard, the "
"standard allows it only as an option of <command>DECLARE CURSOR</command>. "
"<productname>PostgreSQL</productname> allows it in any <command>SELECT</"
"command> query as well as in sub-<command>SELECT</command>s, but this is an "
"extension. The <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</"
"literal> and <literal>FOR KEY SHARE</literal> variants, as well as the "
"<literal>NOWAIT</literal> and <literal>SKIP LOCKED</literal> options, do not "
"appear in the standard."
msgstr ""
"Хотя указание <literal>FOR UPDATE</literal> есть в стандарте SQL, стандарт "
"позволяет использовать его только в предложении <command>DECLARE CURSOR</"
"command>. <productname>PostgreSQL</productname> допускает его использование "
"в любом запросе <command>SELECT</command>, а также в подзапросах "
"<command>SELECT</command>, но это является расширением. Варианты "
"<literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</literal> и "
"<literal>FOR KEY SHARE</literal>, а также указания <literal>NOWAIT</literal> "
"и <literal>SKIP LOCKED</literal> в стандарте отсутствуют."

#: ref/select.xml:2030(title)
msgid "Data-Modifying Statements in <literal>WITH</literal>"
msgstr "Изменение данных в <literal>WITH</literal>"

#: ref/select.xml:2032(para)
msgid ""
"<productname>PostgreSQL</productname> allows <command>INSERT</command>, "
"<command>UPDATE</command>, and <command>DELETE</command> to be used as "
"<literal>WITH</literal> queries. This is not found in the SQL standard."
msgstr ""
"<productname>PostgreSQL</productname> разрешает использовать "
"<command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</"
"command> в качестве запросов <literal>WITH</literal>. Стандарт SQL этого не "
"предусматривает."

#: ref/select.xml:2040(title)
msgid "Nonstandard Clauses"
msgstr "Нестандартные предложения"

#: ref/select.xml:2042(para)
msgid ""
"<literal>DISTINCT ON ( ... )</literal> is an extension of the SQL standard."
msgstr "<literal>DISTINCT ON ( ... )</literal> — расширение стандарта SQL."

#: ref/select.xml:2047(para)
msgid ""
"<literal>ROWS FROM( ... )</literal> is an extension of the SQL standard."
msgstr "<literal>ROWS FROM( ... )</literal> — расширение стандарта SQL."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ref/select.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
