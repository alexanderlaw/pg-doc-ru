# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-02-06 11:18+0300\n"
"PO-Revision-Date: 2017-06-28 22:09+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"

#: datatype.xml:5(title) datatype.xml:33(title)
msgid "Data Types"
msgstr "Типы данных"

#: datatype.xml:7(indexterm)
msgid "<primary>data type</primary>"
msgstr "<primary>тип данных</primary>"

#: datatype.xml:11(indexterm)
msgid "<primary>type</primary> <see>data type</see>"
msgstr "<primary>тип</primary> <see>тип данных</see>"

#: datatype.xml:16(para)
msgid ""
"<productname>PostgreSQL</productname> has a rich set of native data types "
"available to users. Users can add new types to <productname>PostgreSQL</"
"productname> using the <xref linkend=\"sql-createtype\"/> command."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет пользователям богатый "
"ассортимент встроенных типов данных. Кроме того, пользователи могут "
"создавать свои типы в <productname>PostgreSQL</productname>, используя "
"команду <xref linkend=\"sql-createtype\"/>."

#: datatype.xml:23(para)
msgid ""
"<xref linkend=\"datatype-table\"/> shows all the built-in general-purpose "
"data types. Most of the alternative names listed in the <quote>Aliases</"
"quote> column are the names used internally by <productname>PostgreSQL</"
"productname> for historical reasons. In addition, some internally used or "
"deprecated types are available, but are not listed here."
msgstr ""
"<xref linkend=\"datatype-table\"/> содержит все встроенные типы данных "
"общего пользования. Многие из альтернативных имён, приведённых в столбце "
"<quote>Псевдонимы</quote>, используются внутри <productname>PostgreSQL</"
"productname> по историческим причинам. В этот список не включены некоторые "
"устаревшие типы и типы для внутреннего применения."

#: datatype.xml:37(entry) datatype.xml:343(entry) datatype.xml:933(entry)
#: datatype.xml:1026(entry) datatype.xml:1219(entry) datatype.xml:1262(entry)
#: datatype.xml:1569(entry) datatype.xml:2875(entry) datatype.xml:3113(entry)
#: datatype.xml:3439(entry) datatype.xml:4415(entry) datatype.xml:4685(entry)
msgid "Name"
msgstr "Имя"

#: datatype.xml:38(entry)
msgid "Aliases"
msgstr "Псевдонимы"

#: datatype.xml:39(entry) datatype.xml:345(entry) datatype.xml:935(entry)
#: datatype.xml:1027(entry) datatype.xml:1221(entry) datatype.xml:1264(entry)
#: datatype.xml:1380(entry) datatype.xml:1471(entry) datatype.xml:1571(entry)
#: datatype.xml:1786(entry) datatype.xml:1907(entry) datatype.xml:1969(entry)
#: datatype.xml:2147(entry) datatype.xml:2249(entry) datatype.xml:2723(entry)
#: datatype.xml:2877(entry) datatype.xml:3115(entry) datatype.xml:3441(entry)
#: datatype.xml:4417(entry) datatype.xml:4686(entry)
msgid "Description"
msgstr "Описание"

#: datatype.xml:45(type) datatype.xml:364(type)
msgid "bigint"
msgstr "bigint"

#: datatype.xml:46(type)
msgid "int8"
msgstr "int8"

#: datatype.xml:47(entry)
msgid "signed eight-byte integer"
msgstr "знаковое целое из 8 байт"

#: datatype.xml:51(type) datatype.xml:411(type)
msgid "bigserial"
msgstr "bigserial"

#: datatype.xml:52(type)
msgid "serial8"
msgstr "serial8"

#: datatype.xml:53(entry)
msgid "autoincrementing eight-byte integer"
msgstr "восьмибайтное целое с автоувеличением"

#: datatype.xml:57(replaceable) datatype.xml:63(replaceable)
#: datatype.xml:87(replaceable) datatype.xml:88(replaceable)
#: datatype.xml:93(replaceable) datatype.xml:94(replaceable)
msgid "n"
msgstr "n"

#: datatype.xml:57(type)
msgid "bit [ (<placeholder-1/>) ]"
msgstr "bit [ (<placeholder-1/>) ]"

#: datatype.xml:59(entry)
msgid "fixed-length bit string"
msgstr "битовая строка фиксированной длины"

#: datatype.xml:63(type)
msgid "bit varying [ (<placeholder-1/>) ]"
msgstr "bit varying [ (<placeholder-1/>) ]"

#: datatype.xml:64(type)
msgid "varbit"
msgstr "varbit"

#: datatype.xml:65(entry)
msgid "variable-length bit string"
msgstr "битовая строка переменной длины"

#: datatype.xml:69(type) datatype.xml:2882(type)
msgid "boolean"
msgstr "boolean"

#: datatype.xml:70(type)
msgid "bool"
msgstr "bool"

#: datatype.xml:71(entry)
msgid "logical Boolean (true/false)"
msgstr "логическое значение (true/false)"

#: datatype.xml:75(type) datatype.xml:3139(type)
msgid "box"
msgstr "box"

#: datatype.xml:77(entry)
msgid "rectangular box on a plane"
msgstr "прямоугольник в плоскости"

#: datatype.xml:81(type) datatype.xml:1269(type)
msgid "bytea"
msgstr "bytea"

#: datatype.xml:83(entry)
msgid "binary data (<quote>byte array</quote>)"
msgstr "двоичные данные (<quote>массив байт</quote>)"

#: datatype.xml:87(type)
msgid "character [ (<placeholder-1/>) ]"
msgstr "character [ (<placeholder-1/>) ]"

#: datatype.xml:88(type)
msgid "char [ (<placeholder-1/>) ]"
msgstr "char [ (<placeholder-1/>) ]"

#: datatype.xml:89(entry)
msgid "fixed-length character string"
msgstr "символьная строка фиксированной длины"

#: datatype.xml:93(type)
msgid "character varying [ (<placeholder-1/>) ]"
msgstr "character varying [ (<placeholder-1/>) ]"

#: datatype.xml:94(type)
msgid "varchar [ (<placeholder-1/>) ]"
msgstr "varchar [ (<placeholder-1/>) ]"

#: datatype.xml:95(entry) datatype.xml:235(entry)
msgid "variable-length character string"
msgstr "символьная строка переменной длины"

#: datatype.xml:99(type) datatype.xml:3447(type) datatype.xml:3514(type)
#: datatype.xml:3547(type)
msgid "cidr"
msgstr "cidr"

#: datatype.xml:101(entry)
msgid "IPv4 or IPv6 network address"
msgstr "сетевой адрес IPv4 или IPv6"

#: datatype.xml:105(type) datatype.xml:3163(type)
msgid "circle"
msgstr "circle"

#: datatype.xml:107(entry)
msgid "circle on a plane"
msgstr "круг в плоскости"

#: datatype.xml:111(type) datatype.xml:1595(type)
msgid "date"
msgstr "date"

#: datatype.xml:113(entry)
msgid "calendar date (year, month, day)"
msgstr "календарная дата (год, месяц, день)"

#: datatype.xml:117(type) datatype.xml:390(type)
msgid "double precision"
msgstr "double precision"

#: datatype.xml:118(type)
msgid "float8"
msgstr "float8"

#: datatype.xml:119(entry)
msgid "double precision floating-point number (8 bytes)"
msgstr "число двойной точности с плавающей точкой (8 байт)"

#: datatype.xml:123(type) datatype.xml:3453(type) datatype.xml:3477(type)
msgid "inet"
msgstr "inet"

#: datatype.xml:125(entry)
msgid "IPv4 or IPv6 host address"
msgstr "адрес узла IPv4 или IPv6"

#: datatype.xml:129(type) datatype.xml:358(type)
msgctxt "type"
msgid "integer"
msgstr "integer"

#: datatype.xml:130(entry)
msgid "<type>int</type>, <type>int4</type>"
msgstr "<type>int</type>, <type>int4</type>"

#: datatype.xml:131(entry)
msgid "signed four-byte integer"
msgstr "знаковое четырёхбайтное целое"

#: datatype.xml:135(replaceable) datatype.xml:1619(replaceable)
msgid "fields"
msgstr "поля"

#: datatype.xml:135(replaceable) datatype.xml:177(replaceable)
#: datatype.xml:179(replaceable) datatype.xml:239(replaceable)
#: datatype.xml:245(replaceable) datatype.xml:251(replaceable)
#: datatype.xml:257(replaceable) datatype.xml:1579(replaceable)
#: datatype.xml:1587(replaceable) datatype.xml:1603(replaceable)
#: datatype.xml:1611(replaceable) datatype.xml:1619(replaceable)
msgid "p"
msgstr "p"

#: datatype.xml:135(type) datatype.xml:1619(type)
msgid "interval [ <placeholder-1/> ] [ (<placeholder-2/>) ]"
msgstr "interval [ <placeholder-1/> ] [ (<placeholder-2/>) ]"

#: datatype.xml:137(entry)
msgid "time span"
msgstr "интервал времени"

#: datatype.xml:141(type)
msgid "json"
msgstr "json"

#: datatype.xml:143(entry)
msgid "textual JSON data"
msgstr "текстовые данные JSON"

#: datatype.xml:147(type)
msgid "jsonb"
msgstr "jsonb"

#: datatype.xml:149(entry)
msgid "binary JSON data, decomposed"
msgstr "двоичные данные JSON, разобранные"

#: datatype.xml:153(type) datatype.xml:3127(type)
msgid "line"
msgstr "line"

#: datatype.xml:155(entry)
msgid "infinite line on a plane"
msgstr "прямая в плоскости"

#: datatype.xml:159(type) datatype.xml:3133(type)
msgid "lseg"
msgstr "lseg"

#: datatype.xml:161(entry)
msgid "line segment on a plane"
msgstr "отрезок в плоскости"

#: datatype.xml:165(type) datatype.xml:3459(type) datatype.xml:3655(type)
msgid "macaddr"
msgstr "macaddr"

#: datatype.xml:167(entry)
msgid "MAC (Media Access Control) address"
msgstr "MAC-адрес"

#: datatype.xml:171(type)
msgctxt "type"
msgid "money"
msgstr "money"

#: datatype.xml:173(entry) datatype.xml:943(entry)
msgid "currency amount"
msgstr "денежная сумма"

#: datatype.xml:178(replaceable) datatype.xml:180(replaceable)
msgid "s"
msgstr "s"

#: datatype.xml:177(type)
msgid "numeric [ (<placeholder-1/>, <placeholder-2/>) ]"
msgstr "numeric [ (<placeholder-1/>, <placeholder-2/>) ]"

#: datatype.xml:179(type)
msgid "decimal [ (<placeholder-1/>, <placeholder-2/>) ]"
msgstr "decimal [ (<placeholder-1/>, <placeholder-2/>) ]"

#: datatype.xml:181(entry)
msgid "exact numeric of selectable precision"
msgstr "вещественное число заданной точности"

#: datatype.xml:185(type) datatype.xml:3145(type) datatype.xml:3151(type)
msgid "path"
msgstr "path"

#: datatype.xml:187(entry)
msgid "geometric path on a plane"
msgstr "геометрический путь в плоскости"

#: datatype.xml:191(type)
msgid "pg_lsn"
msgstr "pg_lsn"

#: datatype.xml:193(entry)
msgid "<productname>PostgreSQL</productname> Log Sequence Number"
msgstr "Последовательный номер в журнале <productname>PostgreSQL</productname>"

#: datatype.xml:197(type) datatype.xml:3121(type)
msgid "point"
msgstr "point"

#: datatype.xml:199(entry)
msgid "geometric point on a plane"
msgstr "геометрическая точка в плоскости"

#: datatype.xml:203(type) datatype.xml:3157(type)
msgid "polygon"
msgstr "polygon"

#: datatype.xml:205(entry)
msgid "closed geometric path on a plane"
msgstr "замкнутый геометрический путь в плоскости"

#: datatype.xml:209(type) datatype.xml:384(type)
msgid "real"
msgstr "real"

#: datatype.xml:210(type)
msgid "float4"
msgstr "float4"

#: datatype.xml:211(entry)
msgid "single precision floating-point number (4 bytes)"
msgstr "число одинарной точности с плавающей точкой (4 байта)"

#: datatype.xml:215(type) datatype.xml:352(type)
msgid "smallint"
msgstr "smallint"

#: datatype.xml:216(type)
msgid "int2"
msgstr "int2"

#: datatype.xml:217(entry)
msgid "signed two-byte integer"
msgstr "знаковое двухбайтное целое"

#: datatype.xml:221(type) datatype.xml:397(type)
msgid "smallserial"
msgstr "smallserial"

#: datatype.xml:222(type)
msgid "serial2"
msgstr "serial2"

#: datatype.xml:223(entry)
msgid "autoincrementing two-byte integer"
msgstr "двухбайтное целое с автоувеличением"

#: datatype.xml:227(type) datatype.xml:404(type)
msgid "serial"
msgstr "serial"

#: datatype.xml:228(type)
msgid "serial4"
msgstr "serial4"

#: datatype.xml:229(entry)
msgid "autoincrementing four-byte integer"
msgstr "четырёхбайтное целое с автоувеличением"

#: datatype.xml:233(type) datatype.xml:1040(type)
msgid "text"
msgstr "text"

#: datatype.xml:239(type) datatype.xml:1603(type)
msgid "time [ (<placeholder-1/>) ] [ without time zone ]"
msgstr "time [ (<placeholder-1/>) ] [ without time zone ]"

#: datatype.xml:241(entry)
msgid "time of day (no time zone)"
msgstr "время суток (без часового пояса)"

#: datatype.xml:245(type) datatype.xml:1611(type)
msgid "time [ (<placeholder-1/>) ] with time zone"
msgstr "time [ (<placeholder-1/>) ] with time zone"

#: datatype.xml:246(type)
msgid "timetz"
msgstr "timetz"

#: datatype.xml:247(entry)
msgid "time of day, including time zone"
msgstr "время суток с учётом часового пояса"

#: datatype.xml:251(type) datatype.xml:1579(type)
msgid "timestamp [ (<placeholder-1/>) ] [ without time zone ]"
msgstr "timestamp [ (<placeholder-1/>) ] [ without time zone ]"

#: datatype.xml:253(entry)
msgid "date and time (no time zone)"
msgstr "дата и время (без часового пояса)"

#: datatype.xml:257(type) datatype.xml:1587(type)
msgid "timestamp [ (<placeholder-1/>) ] with time zone"
msgstr "timestamp [ (<placeholder-1/>) ] with time zone"

#: datatype.xml:258(type)
msgid "timestamptz"
msgstr "timestamptz"

#: datatype.xml:259(entry)
msgid "date and time, including time zone"
msgstr "дата и время с учётом часового пояса"

#: datatype.xml:263(type) datatype.xml:3919(type)
msgid "tsquery"
msgstr "tsquery"

#: datatype.xml:265(entry)
msgid "text search query"
msgstr "запрос текстового поиска"

#: datatype.xml:269(type) datatype.xml:3809(type)
msgid "tsvector"
msgstr "tsvector"

#: datatype.xml:271(entry)
msgid "text search document"
msgstr "документ для текстового поиска"

#: datatype.xml:275(type)
msgid "txid_snapshot"
msgstr "txid_snapshot"

#: datatype.xml:277(entry)
msgid "user-level transaction ID snapshot"
msgstr "снимок идентификатора транзакций"

#: datatype.xml:281(type)
msgid "uuid"
msgstr "uuid"

#: datatype.xml:283(entry)
msgid "universally unique identifier"
msgstr "универсальный уникальный идентификатор"

#: datatype.xml:287(type)
msgid "xml"
msgstr "xml"

#: datatype.xml:289(entry)
msgid "XML data"
msgstr "XML-данные"

#: datatype.xml:296(title)
msgid "Compatibility"
msgstr "Совместимость"

#: datatype.xml:297(para)
msgid ""
"The following types (or spellings thereof) are specified by <acronym>SQL</"
"acronym>: <type>bigint</type>, <type>bit</type>, <type>bit varying</type>, "
"<type>boolean</type>, <type>char</type>, <type>character varying</type>, "
"<type>character</type>, <type>varchar</type>, <type>date</type>, "
"<type>double precision</type>, <type>integer</type>, <type>interval</type>, "
"<type>numeric</type>, <type>decimal</type>, <type>real</type>, "
"<type>smallint</type>, <type>time</type> (with or without time zone), "
"<type>timestamp</type> (with or without time zone), <type>xml</type>."
msgstr ""
"В стандарте <acronym>SQL</acronym> описаны следующие типы (или их имена): "
"<type>bigint</type>, <type>bit</type>, <type>bit varying</type>, "
"<type>boolean</type>, <type>char</type>, <type>character varying</type>, "
"<type>character</type>, <type>varchar</type>, <type>date</type>, "
"<type>double precision</type>, <type>integer</type>, <type>interval</type>, "
"<type>numeric</type>, <type>decimal</type>, <type>real</type>, "
"<type>smallint</type>, <type>time</type> (с часовым поясом и без), "
"<type>timestamp</type> (с часовым поясом и без), <type>xml</type>."

#: datatype.xml:311(para)
msgid ""
"Each data type has an external representation determined by its input and "
"output functions. Many of the built-in types have obvious external formats. "
"However, several types are either unique to <productname>PostgreSQL</"
"productname>, such as geometric paths, or have several possible formats, "
"such as the date and time types. Some of the input and output functions are "
"not invertible, i.e., the result of an output function might lose accuracy "
"when compared to the original input."
msgstr ""
"Каждый тип данных имеет внутреннее представление, скрытое функциями ввода и "
"вывода. При этом многие встроенные типы стандартны и имеют очевидные внешние "
"форматы. Однако есть типы, уникальные для <productname>PostgreSQL</"
"productname>, например геометрические пути, и есть типы, которые могут иметь "
"разные форматы, например, дата и время. Некоторые функции ввода и вывода не "
"являются в точности обратными друг к другу, то есть результат функции вывода "
"может не совпадать со входным значением из-за потери точности."

#: datatype.xml:324(title) datatype.xml:339(title)
msgid "Numeric Types"
msgstr "Числовые типы"

#: datatype.xml:326(indexterm)
msgid "<primary>data type</primary> <secondary>numeric</secondary>"
msgstr "<primary>тип данных</primary> <secondary>numeric</secondary>"

#: datatype.xml:331(para)
msgid ""
"Numeric types consist of two-, four-, and eight-byte integers, four- and "
"eight-byte floating-point numbers, and selectable-precision decimals. <xref "
"linkend=\"datatype-numeric-table\"/> lists the available types."
msgstr ""
"Числовые типы включают двух-, четырёх- и восьмибайтные целые, четырёх- и "
"восьмибайтные числа с плавающей точкой, а также десятичные числа с "
"задаваемой точностью. Все эти типы перечислены в <xref remap=\"6\" linkend="
"\"datatype-numeric-table\"/>."

#: datatype.xml:344(entry) datatype.xml:934(entry) datatype.xml:1220(entry)
#: datatype.xml:1263(entry) datatype.xml:1570(entry) datatype.xml:2876(entry)
#: datatype.xml:3114(entry) datatype.xml:3440(entry)
msgid "Storage Size"
msgstr "Размер"

#: datatype.xml:346(entry) datatype.xml:936(entry)
msgid "Range"
msgstr "Диапазон"

#: datatype.xml:353(entry) datatype.xml:398(entry)
msgid "2 bytes"
msgstr "2 байта"

#: datatype.xml:354(entry)
msgid "small-range integer"
msgstr "целое в небольшом диапазоне"

#: datatype.xml:355(entry)
msgid "-32768 to +32767"
msgstr "-32768 .. +32767"

#: datatype.xml:359(entry) datatype.xml:385(entry) datatype.xml:405(entry)
#: datatype.xml:1596(entry)
msgid "4 bytes"
msgstr "4 байта"

#: datatype.xml:360(entry)
msgid "typical choice for integer"
msgstr "типичный выбор для целых чисел"

#: datatype.xml:361(entry)
msgid "-2147483648 to +2147483647"
msgstr "-2147483648 .. +2147483647"

#: datatype.xml:365(entry) datatype.xml:391(entry) datatype.xml:412(entry)
#: datatype.xml:942(entry) datatype.xml:1580(entry) datatype.xml:1588(entry)
#: datatype.xml:1604(entry)
msgid "8 bytes"
msgstr "8 байт"

#: datatype.xml:366(entry)
msgid "large-range integer"
msgstr "целое в большом диапазоне"

#: datatype.xml:367(entry)
msgid "-9223372036854775808 to +9223372036854775807"
msgstr "-9223372036854775808 .. 9223372036854775807"

#: datatype.xml:371(type)
msgid "decimal"
msgstr "decimal"

#: datatype.xml:372(entry) datatype.xml:378(entry)
msgid "variable"
msgstr "переменный"

#: datatype.xml:373(entry) datatype.xml:379(entry)
msgid "user-specified precision, exact"
msgstr "вещественное число с указанной точностью"

#: datatype.xml:374(entry) datatype.xml:380(entry)
msgid ""
"up to 131072 digits before the decimal point; up to 16383 digits after the "
"decimal point"
msgstr "до 131072 цифр до десятичной точки и до 16383 &mdash; после"

#: datatype.xml:377(type)
msgid "numeric"
msgstr "numeric"

#: datatype.xml:386(entry) datatype.xml:392(entry)
msgid "variable-precision, inexact"
msgstr "вещественное число с переменной точностью"

#: datatype.xml:387(entry)
msgid "6 decimal digits precision"
msgstr "точность в пределах 6 десятичных цифр"

#: datatype.xml:393(entry)
msgid "15 decimal digits precision"
msgstr "точность в пределах 15 десятичных цифр"

#: datatype.xml:399(entry)
msgid "small autoincrementing integer"
msgstr "небольшое целое с автоувеличением"

#: datatype.xml:400(entry)
msgid "1 to 32767"
msgstr "1 .. 32767"

#: datatype.xml:406(entry)
msgid "autoincrementing integer"
msgstr "целое с автоувеличением"

#: datatype.xml:407(entry)
msgid "1 to 2147483647"
msgstr "1 .. 2147483647"

#: datatype.xml:413(entry)
msgid "large autoincrementing integer"
msgstr "большое целое с автоувеличением"

#: datatype.xml:414(entry)
msgid "1 to 9223372036854775807"
msgstr "1 .. 9223372036854775807"

#: datatype.xml:420(para)
msgid ""
"The syntax of constants for the numeric types is described in <xref linkend="
"\"sql-syntax-constants\"/>. The numeric types have a full set of "
"corresponding arithmetic operators and functions. Refer to <xref linkend="
"\"functions\"/> for more information. The following sections describe the "
"types in detail."
msgstr ""
"Синтаксис констант числовых типов описан в <xref remap=\"6\" linkend=\"sql-"
"syntax-constants\"/>. Для этих типов определён полный набор соответствующих "
"арифметических операторов и функций. За дополнительными сведениями "
"обратитесь к <xref remap=\"3\" linkend=\"functions\"/>. Подробнее эти типы "
"описаны в следующих разделах."

#: datatype.xml:429(title)
msgid "Integer Types"
msgstr "Целочисленные типы"

#: datatype.xml:431(indexterm)
msgid "<primary>integer</primary>"
msgstr "<primary>integer</primary>"

#: datatype.xml:435(indexterm)
msgid "<primary>smallint</primary>"
msgstr "<primary>smallint</primary>"

#: datatype.xml:439(indexterm)
msgid "<primary>bigint</primary>"
msgstr "<primary>bigint</primary>"

#: datatype.xml:443(indexterm)
msgid "<primary>int4</primary> <see>integer</see>"
msgstr "<primary>int4</primary> <see>integer</see>"

#: datatype.xml:448(indexterm)
msgid "<primary>int2</primary> <see>smallint</see>"
msgstr "<primary>int2</primary> <see>smallint</see>"

#: datatype.xml:453(indexterm)
msgid "<primary>int8</primary> <see>bigint</see>"
msgstr "<primary>int8</primary> <see>bigint</see>"

#: datatype.xml:458(para)
msgid ""
"The types <type>smallint</type>, <type>integer</type>, and <type>bigint</"
"type> store whole numbers, that is, numbers without fractional components, "
"of various ranges. Attempts to store values outside of the allowed range "
"will result in an error."
msgstr ""
"Типы <type>smallint</type>, <type>integer</type> и <type>bigint</type> "
"хранят целые числа, то есть числа без дробной части, имеющие разные "
"допустимые диапазоны. Попытка сохранить значение, выходящее за рамки "
"диапазона, приведёт к ошибке."

#: datatype.xml:465(para)
msgid ""
"The type <type>integer</type> is the common choice, as it offers the best "
"balance between range, storage size, and performance. The <type>smallint</"
"type> type is generally only used if disk space is at a premium. The "
"<type>bigint</type> type is designed to be used when the range of the "
"<type>integer</type> type is insufficient."
msgstr ""
"Чаще всего используется тип <type>integer</type>, как наиболее "
"сбалансированный выбор ширины диапазона, размера и быстродействия. Тип "
"<type>smallint</type> обычно применяется, только когда крайне важно "
"уменьшить размер данных на диске. Тип <type>bigint</type> предназначен для "
"тех случаев, когда числа не умещаются в диапазон типа <type>integer</type>."

#: datatype.xml:473(para)
msgid ""
"<acronym>SQL</acronym> only specifies the integer types <type>integer</type> "
"(or <type>int</type>), <type>smallint</type>, and <type>bigint</type>. The "
"type names <type>int2</type>, <type>int4</type>, and <type>int8</type> are "
"extensions, which are also used by some other <acronym>SQL</acronym> "
"database systems."
msgstr ""
"В <acronym>SQL</acronym> определены только типы <type>integer</type> (или "
"<type>int</type>), <type>smallint</type> и <type>bigint</type>. Имена типов "
"<type>int2</type>, <type>int4</type> и <type>int8</type> выходят за рамки "
"стандарта, хотя могут работать и в некоторых других СУБД."

#: datatype.xml:485(title)
msgid "Arbitrary Precision Numbers"
msgstr "Числа с фиксированной точностью"

#: datatype.xml:487(indexterm)
msgid "<primary>numeric (data type)</primary>"
msgstr "<primary>numeric (тип данных)</primary>"

#: datatype.xml:491(indexterm)
msgid "<primary>arbitrary precision numbers</primary>"
msgstr "<primary>числа с фиксированной точностью</primary>"

#: datatype.xml:495(indexterm)
msgid "<primary>decimal</primary> <see>numeric</see>"
msgstr "<primary>decimal</primary> <see>numeric</see>"

#: datatype.xml:500(para)
msgid ""
"The type <type>numeric</type> can store numbers with a very large number of "
"digits. It is especially recommended for storing monetary amounts and other "
"quantities where exactness is required. Calculations with <type>numeric</"
"type> values yield exact results where possible, e.g. addition, subtraction, "
"multiplication. However, calculations on <type>numeric</type> values are "
"very slow compared to the integer types, or to the floating-point types "
"described in the next section."
msgstr ""
"Тип <type>numeric</type> позволяет хранить числа с очень большим количеством "
"цифр. Он особенно рекомендуется для хранения денежных сумм и других величин, "
"где важна точность. Вычисления с типом <type>numeric</type> дают точные "
"результаты, где это возможно, например, при сложении, вычитании и умножении. "
"Однако операции со значениями <type>numeric</type> выполняются гораздо "
"медленнее, чем с целыми числами или с типами с плавающей точкой, описанными "
"в следующем разделе."

#: datatype.xml:511(para)
msgid ""
"We use the following terms below: The <firstterm>scale</firstterm> of a "
"<type>numeric</type> is the count of decimal digits in the fractional part, "
"to the right of the decimal point. The <firstterm>precision</firstterm> of a "
"<type>numeric</type> is the total count of significant digits in the whole "
"number, that is, the number of digits to both sides of the decimal point. So "
"the number 23.5141 has a precision of 6 and a scale of 4. Integers can be "
"considered to have a scale of zero."
msgstr ""
"Ниже мы используем следующие термины: <firstterm>масштаб</firstterm> "
"значения <type>numeric</type> определяет количество десятичных цифр в "
"дробной части, справа от десятичной точки, а <firstterm>точность</firstterm> "
"&mdash; общее количество значимых цифр в числе, т. е. количество цифр по обе "
"стороны десятичной точки. Например, число 23.5141 имеет точность 6 и масштаб "
"4. Целочисленные значения можно считать числами с масштабом 0."

#: datatype.xml:528(programlisting)
#, no-wrap
msgid "NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)"
msgstr "NUMERIC(<replaceable>точность</replaceable>, <replaceable>масштаб</replaceable>)"

#: datatype.xml:533(programlisting)
#, no-wrap
msgid "NUMERIC(<replaceable>precision</replaceable>)"
msgstr "NUMERIC(<replaceable>точность</replaceable>)"

#: datatype.xml:537(programlisting)
#, no-wrap
msgid "NUMERIC"
msgstr "NUMERIC"

#: datatype.xml:523(para)
msgid ""
"Both the maximum precision and the maximum scale of a <type>numeric</type> "
"column can be configured. To declare a column of type <type>numeric</type> "
"use the syntax: <placeholder-1/> The precision must be positive, the scale "
"zero or positive. Alternatively: <placeholder-2/> selects a scale of 0. "
"Specifying: <placeholder-3/> without any precision or scale creates a column "
"in which numeric values of any precision and scale can be stored, up to the "
"implementation limit on precision. A column of this kind will not coerce "
"input values to any particular scale, whereas <type>numeric</type> columns "
"with a declared scale will coerce input values to that scale. (The "
"<acronym>SQL</acronym> standard requires a default scale of 0, i.e., "
"coercion to integer precision. We find this a bit useless. If you're "
"concerned about portability, always specify the precision and scale "
"explicitly.)"
msgstr ""
"Для столбца типа <type>numeric</type> можно настроить и максимальную "
"точность, и максимальный масштаб. Столбец типа <type>numeric</type> "
"объявляется следующим образом: <placeholder-1/> Точность должна быть "
"положительной, а масштаб положительным или равным нулю. Альтернативный "
"вариант <placeholder-2/> устанавливает масштаб 0. Форма: <placeholder-3/> "
"без указания точности и масштаба создаёт столбец, в котором можно сохранять "
"числовые значения любой точности и масштаба в пределах, поддерживаемых "
"системой. В столбце этого типа входные значения не будут приводиться к "
"какому-либо масштабу, тогда как в столбцах <type>numeric</type> с явно "
"заданным масштабом значения подгоняются под этот масштаб. (Стандарт "
"<acronym>SQL</acronym> утверждает, что по умолчанию должен устанавливаться "
"масштаб 0, т. е. значения должны приводиться к целым числам. Однако мы "
"считаем это не очень полезным. Если для вас важна переносимость, всегда "
"указывайте точность и масштаб явно.)"

#: datatype.xml:553(para)
msgid ""
"The maximum allowed precision when explicitly specified in the type "
"declaration is 1000; <type>NUMERIC</type> without a specified precision is "
"subject to the limits described in <xref linkend=\"datatype-numeric-table\"/"
">."
msgstr ""
"Максимально допустимая точность, которую можно указать в объявлении типа, "
"равна 1000; если же использовать <type>NUMERIC</type> без указания точности, "
"действуют ограничения, описанные в <xref remap=\"6\" linkend=\"datatype-"
"numeric-table\"/>."

#: datatype.xml:561(para)
msgid ""
"If the scale of a value to be stored is greater than the declared scale of "
"the column, the system will round the value to the specified number of "
"fractional digits. Then, if the number of digits to the left of the decimal "
"point exceeds the declared precision minus the declared scale, an error is "
"raised."
msgstr ""
"Если масштаб значения, которое нужно сохранить, превышает объявленный "
"масштаб столбца, система округлит его до заданного количества цифр после "
"точки. Если же после этого количество цифр слева в сумме с масштабом "
"превысит объявленную точность, произойдёт ошибка."

#: datatype.xml:569(para)
msgid ""
"Numeric values are physically stored without any extra leading or trailing "
"zeroes. Thus, the declared precision and scale of a column are maximums, not "
"fixed allocations. (In this sense the <type>numeric</type> type is more akin "
"to <type>varchar(<replaceable>n</replaceable>)</type> than to "
"<type>char(<replaceable>n</replaceable>)</type>.) The actual storage "
"requirement is two bytes for each group of four decimal digits, plus three "
"to eight bytes overhead."
msgstr ""
"Числовые значения физически хранятся без каких-либо дополняющих нулей слева "
"или справа. Таким образом, объявляемые точность и масштаб столбца определяют "
"максимальный, а не фиксированный размер хранения. (В этом смысле тип "
"<type>numeric</type> больше похож на тип <type>varchar(<replaceable>n</"
"replaceable>)</type>, чем на <type>char(<replaceable>n</replaceable>)</"
"type>.) Действительный размер хранения такого значения складывается из двух "
"байт для каждой группы из четырёх цифр и дополнительных трёх-восьми байт."

#: datatype.xml:579(indexterm)
msgid "<primary>NaN</primary> <see>not a number</see>"
msgstr "<primary>NaN</primary> <see>не число</see>"

#: datatype.xml:584(indexterm)
msgid ""
"<primary>not a number</primary> <secondary>numeric (data type)</secondary>"
msgstr ""
"<primary>не число</primary> <secondary>numeric (тип данных)</secondary>"

#: datatype.xml:589(para)
msgid ""
"In addition to ordinary numeric values, the <type>numeric</type> type allows "
"the special value <literal>NaN</literal>, meaning <quote>not-a-number</"
"quote>. Any operation on <literal>NaN</literal> yields another <literal>NaN</"
"literal>. When writing this value as a constant in an SQL command, you must "
"put quotes around it, for example <literal>UPDATE table SET x = 'NaN'</"
"literal>. On input, the string <literal>NaN</literal> is recognized in a "
"case-insensitive manner."
msgstr ""
"Помимо обычных чисел тип <type>numeric</type> позволяет сохранить "
"специальное значение <literal>NaN</literal>, что означает <quote>not-a-"
"number</quote> (не число). Любая операция c <literal>NaN</literal> выдаёт в "
"результате тоже <literal>NaN</literal>. Записывая это значение в виде "
"константы в команде SQL, его нужно заключать в апострофы, например так: "
"<literal>UPDATE table SET x = 'NaN'</literal>. Регистр символов в строке "
"<literal>NaN</literal> не важен."

#: datatype.xml:600(para)
msgid ""
"In most implementations of the <quote>not-a-number</quote> concept, "
"<literal>NaN</literal> is not considered equal to any other numeric value "
"(including <literal>NaN</literal>). In order to allow <type>numeric</type> "
"values to be sorted and used in tree-based indexes, <productname>PostgreSQL</"
"productname> treats <literal>NaN</literal> values as equal, and greater than "
"all non-<literal>NaN</literal> values."
msgstr ""
"В большинстве реализаций <quote>не-число</quote> (<literal>NaN</literal>) "
"считается не равным любому другому значению (в том числе и самому "
"<literal>NaN</literal>). Чтобы значения <type>numeric</type> можно было "
"сортировать и использовать в древовидных индексах, <productname>PostgreSQL</"
"productname> считает, что значения <literal>NaN</literal> равны друг другу и "
"при этом больше любых числовых значений (не <literal>NaN</literal>)."

#: datatype.xml:611(para)
msgid ""
"The types <type>decimal</type> and <type>numeric</type> are equivalent. Both "
"types are part of the <acronym>SQL</acronym> standard."
msgstr ""
"Типы <type>decimal</type> и <type>numeric</type> равнозначны. Оба эти типа "
"описаны в стандарте <acronym>SQL</acronym>."

#: datatype.xml:623(programlisting)
#, no-wrap
msgid ""
"SELECT x,\n"
"  round(x::numeric) AS num_round,\n"
"  round(x::double precision) AS dbl_round\n"
"FROM generate_series(-3.5, 3.5, 1) as x;\n"
"  x   | num_round | dbl_round\n"
"------+-----------+-----------\n"
" -3.5 |        -4 |        -4\n"
" -2.5 |        -3 |        -2\n"
" -1.5 |        -2 |        -2\n"
" -0.5 |        -1 |        -0\n"
"  0.5 |         1 |         0\n"
"  1.5 |         2 |         2\n"
"  2.5 |         3 |         2\n"
"  3.5 |         4 |         4\n"
"(8 rows)"
msgstr ""
"SELECT x,\n"
"  round(x::numeric) AS num_round,\n"
"  round(x::double precision) AS dbl_round\n"
"FROM generate_series(-3.5, 3.5, 1) as x;\n"
"  x   | num_round | dbl_round\n"
"------+-----------+-----------\n"
" -3.5 |        -4 |        -4\n"
" -2.5 |        -3 |        -2\n"
" -1.5 |        -2 |        -2\n"
" -0.5 |        -1 |        -0\n"
"  0.5 |         1 |         0\n"
"  1.5 |         2 |         2\n"
"  2.5 |         3 |         2\n"
"  3.5 |         4 |         4\n"
"(8 rows)"

#: datatype.xml:617(para)
msgid ""
"When rounding values, the <type>numeric</type> type rounds ties away from "
"zero, while (on most machines) the <type>real</type> and <type>double "
"precision</type> types round ties to the nearest even number. For example: "
"<placeholder-1/>"
msgstr ""
"При округлении значений тип <type>numeric</type> выдаёт число, большее по "
"модулю, тогда как (на большинстве платформ) типы <type>real</type> и "
"<type>double precision</type> выдают ближайшее чётное число. Например: "
"<placeholder-1/>"

#: datatype.xml:645(title)
msgid "Floating-Point Types"
msgstr "Типы с плавающей точкой"

#: datatype.xml:647(indexterm)
msgid "<primary>real</primary>"
msgstr "<primary>real</primary>"

#: datatype.xml:651(indexterm)
msgid "<primary>double precision</primary>"
msgstr "<primary>double precision</primary>"

#: datatype.xml:655(indexterm)
msgid "<primary>float4</primary> <see>real</see>"
msgstr "<primary>float4</primary> <see>real</see>"

#: datatype.xml:660(indexterm)
msgid "<primary>float8</primary> <see>double precision</see>"
msgstr "<primary>float8</primary> <see>double precision</see>"

#: datatype.xml:665(indexterm)
msgid "<primary>floating point</primary>"
msgstr "<primary>floating point</primary>"

#: datatype.xml:669(para)
msgid ""
"The data types <type>real</type> and <type>double precision</type> are "
"inexact, variable-precision numeric types. In practice, these types are "
"usually implementations of <acronym>IEEE</acronym> Standard 754 for Binary "
"Floating-Point Arithmetic (single and double precision, respectively), to "
"the extent that the underlying processor, operating system, and compiler "
"support it."
msgstr ""
"Типы данных <type>real</type> и <type>double precision</type> хранят "
"приближённые числовые значения с переменной точностью. На практике эти типы "
"обычно реализуют Стандарт <acronym>IEEE</acronym> 754 для двоичной "
"арифметики с плавающей точкой (с одинарной и двойной точностью "
"соответственно), в той мере, в какой его поддерживают процессор, "
"операционная система и компилятор."

#: datatype.xml:689(para)
msgid ""
"If you require exact storage and calculations (such as for monetary "
"amounts), use the <type>numeric</type> type instead."
msgstr ""
"Если вам нужна точность при хранении и вычислениях (например, для денежных "
"сумм), используйте вместо этого тип <type>numeric</type>."

#: datatype.xml:696(para)
msgid ""
"If you want to do complicated calculations with these types for anything "
"important, especially if you rely on certain behavior in boundary cases "
"(infinity, underflow), you should evaluate the implementation carefully."
msgstr ""
"Если вы хотите выполнять с этими типами сложные вычисления, имеющие большую "
"важность, тщательно изучите реализацию операций в вашей среде и особенно "
"поведение в крайних случаях (бесконечность, антипереполнение)."

#: datatype.xml:705(para)
msgid ""
"Comparing two floating-point values for equality might not always work as "
"expected."
msgstr ""
"Проверка равенства двух чисел с плавающей точкой может не всегда давать "
"ожидаемый результат."

#: datatype.xml:679(para)
msgid ""
"Inexact means that some values cannot be converted exactly to the internal "
"format and are stored as approximations, so that storing and retrieving a "
"value might show slight discrepancies. Managing these errors and how they "
"propagate through calculations is the subject of an entire branch of "
"mathematics and computer science and will not be discussed here, except for "
"the following points: <placeholder-1/>"
msgstr ""
"Неточность здесь выражается в том, что некоторые значения, которые нельзя "
"преобразовать во внутренний формат, сохраняются приближённо, так что "
"полученное значение может несколько отличаться от записанного. Управление "
"подобными ошибками и их распространение в процессе вычислений является "
"предметом изучения целого раздела математики и компьютерной науки, и здесь "
"не рассматривается. Мы отметим только следующее: <placeholder-1/>"

#: datatype.xml:713(para)
msgid ""
"On most platforms, the <type>real</type> type has a range of at least 1E-37 "
"to 1E+37 with a precision of at least 6 decimal digits. The <type>double "
"precision</type> type typically has a range of around 1E-307 to 1E+308 with "
"a precision of at least 15 digits. Values that are too large or too small "
"will cause an error. Rounding might take place if the precision of an input "
"number is too high. Numbers too close to zero that are not representable as "
"distinct from zero will cause an underflow error."
msgstr ""
"На большинстве платформ тип <type>real</type> может сохранить значения в "
"пределах от 1E-37 до 1E+37 с точностью не меньше 6 десятичных цифр. Тип "
"<type>double precision</type> предлагает диапазон значений от 1E-307 до 1E"
"+308 и точностью не меньше 15 цифр. Попытка сохранить слишком большие или "
"слишком маленькие значения приведёт к ошибке. Если точность вводимого числа "
"слишком велика, оно будет округлено. При попытке сохранить число, близкое к "
"0, но непредставимое как отличное от 0, произойдёт ошибка антипереполнения."

#: datatype.xml:725(para)
msgid ""
"The <xref linkend=\"guc-extra-float-digits\"/> setting controls the number "
"of extra significant digits included when a floating point value is "
"converted to text for output. With the default value of <literal>0</"
"literal>, the output is the same on every platform supported by PostgreSQL. "
"Increasing it will produce output that more accurately represents the stored "
"value, but may be unportable."
msgstr ""
"Параметр <xref linkend=\"guc-extra-float-digits\"/> определяет количество "
"дополнительных значащих цифр при преобразовании значения с плавающей точкой "
"в текст для вывода. Со значением по умолчанию (<literal>0</literal>) вывод "
"будет одинаковым на всех платформах, поддерживаемых PostgreSQL. При его "
"увеличении выводимое значение числа будет более точно представлять хранимое, "
"но от этого может пострадать переносимость."

#: datatype.xml:735(indexterm)
msgid "<primary>not a number</primary> <secondary>double precision</secondary>"
msgstr "<primary>не число</primary> <secondary>double precision</secondary>"

#: datatype.xml:740(para)
msgid ""
"In addition to ordinary numeric values, the floating-point types have "
"several special values: <literallayout>\n"
"<literal>Infinity</literal>\n"
"<literal>-Infinity</literal>\n"
"<literal>NaN</literal>\n"
"</literallayout> These represent the IEEE 754 special values "
"<quote>infinity</quote>, <quote>negative infinity</quote>, and <quote>not-a-"
"number</quote>, respectively. (On a machine whose floating-point arithmetic "
"does not follow IEEE 754, these values will probably not work as expected.) "
"When writing these values as constants in an SQL command, you must put "
"quotes around them, for example <literal>UPDATE table SET x = 'Infinity'</"
"literal>. On input, these strings are recognized in a case-insensitive "
"manner."
msgstr ""
"В дополнение к обычным числовым значениям типы с плавающей точкой могут "
"содержать следующие специальные значения: <literallayout>\n"
"<literal>Infinity</literal>\n"
"<literal>-Infinity</literal>\n"
"<literal>NaN</literal>\n"
"</literallayout> Они представляют особые значения, описанные в IEEE 754, "
"соответственно <quote>бесконечность</quote>, <quote>минус бесконечность</"
"quote> и <quote>не число</quote>. (На компьютерах, где арифметика с "
"плавающей точкой не соответствует стандарту IEEE 754, эти значения, "
"вероятно, не будут работать должным образом.) Записывая эти значения в виде "
"констант в команде SQL, их нужно заключать в апострофы, например так: "
"<literal>UPDATE table SET x = 'Infinity'</literal>. Регистр символов в этих "
"строках не важен."

#: datatype.xml:759(para)
msgid ""
"IEEE754 specifies that <literal>NaN</literal> should not compare equal to "
"any other floating-point value (including <literal>NaN</literal>). In order "
"to allow floating-point values to be sorted and used in tree-based indexes, "
"<productname>PostgreSQL</productname> treats <literal>NaN</literal> values "
"as equal, and greater than all non-<literal>NaN</literal> values."
msgstr ""
"Согласно IEEE754, <literal>NaN</literal> не должно считаться равным любому "
"другому значению с плавающей точкой (в том числе и самому <literal>NaN</"
"literal>). Чтобы значения с плавающей точкой можно было сортировать и "
"использовать в древовидных индексах, <productname>PostgreSQL</productname> "
"считает, что значения <literal>NaN</literal> равны друг другу, и при этом "
"больше любых числовых значений (не <literal>NaN</literal>)."

#: datatype.xml:769(para)
msgid ""
"<productname>PostgreSQL</productname> also supports the SQL-standard "
"notations <type>float</type> and <type>float(<replaceable>p</replaceable>)</"
"type> for specifying inexact numeric types. Here, <replaceable>p</"
"replaceable> specifies the minimum acceptable precision in <emphasis>binary</"
"emphasis> digits. <productname>PostgreSQL</productname> accepts "
"<type>float(1)</type> to <type>float(24)</type> as selecting the <type>real</"
"type> type, while <type>float(25)</type> to <type>float(53)</type> select "
"<type>double precision</type>. Values of <replaceable>p</replaceable> "
"outside the allowed range draw an error. <type>float</type> with no "
"precision specified is taken to mean <type>double precision</type>."
msgstr ""
"<productname>PostgreSQL</productname> также поддерживает форматы "
"<type>float</type> и <type>float(<replaceable>p</replaceable>)</type>, "
"оговорённые в стандарте SQL, для указания неточных числовых типов. Здесь "
"<replaceable>p</replaceable> определяет минимально допустимую точность в "
"<emphasis>двоичных</emphasis> цифрах. <productname>PostgreSQL</productname> "
"воспринимает запись от <type>float(1)</type> до <type>float(24)</type> как "
"выбор типа <type>real</type>, а запись от <type>float(25)</type> до "
"<type>float(53)</type> как выбор типа <type>double precision</type>. "
"Значения <replaceable>p</replaceable> вне допустимого диапазона вызывают "
"ошибку. Если <type>float</type> указывается без точности, подразумевается "
"тип <type>double precision</type>."

#: datatype.xml:786(para)
msgid ""
"The assumption that <type>real</type> and <type>double precision</type> have "
"exactly 24 and 53 bits in the mantissa respectively is correct for IEEE-"
"standard floating point implementations. On non-IEEE platforms it might be "
"off a little, but for simplicity the same ranges of <replaceable>p</"
"replaceable> are used on all platforms."
msgstr ""
"Предположение, что типы <type>real</type> и <type>double precision</type> "
"имеют в мантиссе 24 и 53 бита соответственно, справедливо для всех "
"реализаций плавающей точки по стандарту IEEE. На платформах, не "
"поддерживающих IEEE, размер мантиссы может несколько отличаться, но для "
"простоты диапазоны <replaceable>p</replaceable> везде считаются одинаковыми."

#: datatype.xml:799(title)
msgid "Serial Types"
msgstr "Последовательные типы"

#: datatype.xml:801(indexterm)
msgid "<primary>smallserial</primary>"
msgstr "<primary>smallserial</primary>"

#: datatype.xml:805(indexterm)
msgid "<primary>serial</primary>"
msgstr "<primary>serial</primary>"

#: datatype.xml:809(indexterm)
msgid "<primary>bigserial</primary>"
msgstr "<primary>bigserial</primary>"

#: datatype.xml:813(indexterm)
msgid "<primary>serial2</primary>"
msgstr "<primary>serial2</primary>"

#: datatype.xml:817(indexterm)
msgid "<primary>serial4</primary>"
msgstr "<primary>serial4</primary>"

#: datatype.xml:821(indexterm)
msgid "<primary>serial8</primary>"
msgstr "<primary>serial8</primary>"

#: datatype.xml:825(indexterm)
msgid "<primary>auto-increment</primary> <see>serial</see>"
msgstr "<primary>auto-increment</primary> <see>serial</see>"

#: datatype.xml:830(indexterm)
msgid "<primary>sequence</primary> <secondary>and serial type</secondary>"
msgstr "<primary>sequence</primary> <secondary>и тип serial</secondary>"

#: datatype.xml:843(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE <replaceable class=\"parameter\">tablename</replaceable> (\n"
"    <replaceable class=\"parameter\">colname</replaceable> SERIAL\n"
");"
msgstr ""
"CREATE TABLE <replaceable class=\"parameter\">имя_таблицы</replaceable> (\n"
"    <replaceable class=\"parameter\">имя_столбца</replaceable> SERIAL\n"
");"

#: datatype.xml:851(programlisting)
#, no-wrap
msgid ""
"CREATE SEQUENCE <replaceable class=\"parameter\">tablename</replaceable>_<replaceable class=\"parameter\">colname</replaceable>_seq;\n"
"CREATE TABLE <replaceable class=\"parameter\">tablename</replaceable> (\n"
"    <replaceable class=\"parameter\">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class=\"parameter\">tablename</replaceable>_<replaceable class=\"parameter\">colname</replaceable>_seq')\n"
");\n"
"ALTER SEQUENCE <replaceable class=\"parameter\">tablename</replaceable>_<replaceable class=\"parameter\">colname</replaceable>_seq OWNED BY <replaceable class=\"parameter\">tablename</replaceable>.<replaceable class=\"parameter\">colname</replaceable>;"
msgstr ""
"CREATE SEQUENCE <replaceable class=\"parameter\">имя_таблицы</replaceable>_<replaceable class=\"parameter\">имя_столбца</replaceable>_seq;\n"
"CREATE TABLE <replaceable class=\"parameter\">имя_таблицы</replaceable> (\n"
"    <replaceable class=\"parameter\">имя_столбца</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class=\"parameter\">имя_таблицы</replaceable>_<replaceable class=\"parameter\">имя_столбца</replaceable>_seq')\n"
");\n"
"ALTER SEQUENCE <replaceable class=\"parameter\">имя_таблицы</replaceable>_<replaceable class=\"parameter\">имя_столбца</replaceable>_seq OWNED BY <replaceable class=\"parameter\">имя_таблицы</replaceable>.<replaceable class=\"parameter\">имя_столбца</replaceable>;"

#: datatype.xml:835(para)
msgid ""
"The data types <type>smallserial</type>, <type>serial</type> and "
"<type>bigserial</type> are not true types, but merely a notational "
"convenience for creating unique identifier columns (similar to the "
"<literal>AUTO_INCREMENT</literal> property supported by some other "
"databases). In the current implementation, specifying: <placeholder-1/> is "
"equivalent to specifying: <placeholder-2/> Thus, we have created an integer "
"column and arranged for its default values to be assigned from a sequence "
"generator. A <literal>NOT NULL</literal> constraint is applied to ensure "
"that a null value cannot be inserted. (In most cases you would also want to "
"attach a <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> "
"constraint to prevent duplicate values from being inserted by accident, but "
"this is not automatic.) Lastly, the sequence is marked as <quote>owned by</"
"quote> the column, so that it will be dropped if the column or table is "
"dropped."
msgstr ""
"Типы данных <type>smallserial</type>, <type>serial</type> и <type>bigserial</"
"type> не являются настоящими типами, а представляют собой просто удобное "
"средство для создания столбцов с уникальными идентификаторами (подобное "
"свойству <literal>AUTO_INCREMENT</literal> в некоторых СУБД). В текущей "
"реализации запись: <placeholder-1/> равнозначна следующим командам: "
"<placeholder-2/> То есть при определении такого типа создаётся целочисленный "
"столбец со значением по умолчанию, извлекаемым из генератора "
"последовательности. Чтобы в столбец нельзя было вставить NULL, в его "
"определение добавляется ограничение <literal>NOT NULL</literal>. (Во многих "
"случаях также имеет смысл добавить для этого столбца ограничения "
"<literal>UNIQUE</literal> или <literal>PRIMARY KEY</literal> для защиты от "
"ошибочного добавления дублирующихся значений, но автоматически это не "
"происходит.) Последняя команда определяет, что последовательность "
"<quote>принадлежит</quote> столбцу, так что она будет удалена при удалении "
"столбца или таблицы."

#: datatype.xml:870(para)
msgid ""
"Because <type>smallserial</type>, <type>serial</type> and <type>bigserial</"
"type> are implemented using sequences, there may be \"holes\" or gaps in the "
"sequence of values which appears in the column, even if no rows are ever "
"deleted. A value allocated from the sequence is still \"used up\" even if a "
"row containing that value is never successfully inserted into the table "
"column. This may happen, for example, if the inserting transaction rolls "
"back. See <literal>nextval()</literal> in <xref linkend=\"functions-sequence"
"\"/> for details."
msgstr ""
"Так как типы <type>smallserial</type>, <type>serial</type> и "
"<type>bigserial</type> реализованы через последовательности, в числовом ряду "
"значений столбца могут образовываться пропуски (или \"дыры\"), даже если "
"никакие строки не удалялись. Значение, выделенное из последовательности, "
"считается \"задействованным\", даже если строку с этим значением не удалось "
"вставить в таблицу. Это может произойти, например, при откате транзакции, "
"добавляющей данные. См. описание <literal>nextval()</literal> в <xref remap="
"\"6\" linkend=\"functions-sequence\"/>."

#: datatype.xml:883(para)
msgid ""
"To insert the next value of the sequence into the <type>serial</type> "
"column, specify that the <type>serial</type> column should be assigned its "
"default value. This can be done either by excluding the column from the list "
"of columns in the <command>INSERT</command> statement, or through the use of "
"the <literal>DEFAULT</literal> key word."
msgstr ""
"Чтобы вставить в столбец <type>serial</type> следующее значение "
"последовательности, ему нужно присвоить значение по умолчанию. Это можно "
"сделать, либо исключив его из списка столбцов в операторе <command>INSERT</"
"command>, либо с помощью ключевого слова <literal>DEFAULT</literal>."

#: datatype.xml:892(para)
msgid ""
"The type names <type>serial</type> and <type>serial4</type> are equivalent: "
"both create <type>integer</type> columns. The type names <type>bigserial</"
"type> and <type>serial8</type> work the same way, except that they create a "
"<type>bigint</type> column. <type>bigserial</type> should be used if you "
"anticipate the use of more than 2<superscript>31</superscript> identifiers "
"over the lifetime of the table. The type names <type>smallserial</type> and "
"<type>serial2</type> also work the same way, except that they create a "
"<type>smallint</type> column."
msgstr ""
"Имена типов <type>serial</type> и <type>serial4</type> равнозначны: они "
"создают столбцы <type>integer</type>. Так же являются синонимами имена "
"<type>bigserial</type> и <type>serial8</type>, но они создают столбцы "
"<type>bigint</type>. Тип <type>bigserial</type> следует использовать, если "
"за всё время жизни таблицы планируется использовать больше чем "
"2<superscript>31</superscript> значений. И наконец, синонимами являются "
"имена типов <type>smallserial</type> и <type>serial2</type>, но они создают "
"столбец <type>smallint</type>."

#: datatype.xml:904(para)
msgid ""
"The sequence created for a <type>serial</type> column is automatically "
"dropped when the owning column is dropped. You can drop the sequence without "
"dropping the column, but this will force removal of the column default "
"expression."
msgstr ""
"Последовательность, созданная для столбца <type>serial</type>, автоматически "
"удаляется при удалении связанного столбца. Последовательность можно удалить "
"и отдельно от столбца, но при этом также будет удалено определение значения "
"по умолчанию."

#: datatype.xml:914(title) datatype.xml:929(title)
msgid "Monetary Types"
msgstr "Денежные типы"

#: datatype.xml:916(para)
msgid ""
"The <type>money</type> type stores a currency amount with a fixed fractional "
"precision; see <xref linkend=\"datatype-money-table\"/>. The fractional "
"precision is determined by the database's <xref linkend=\"guc-lc-monetary\"/"
"> setting. The range shown in the table assumes there are two fractional "
"digits. Input is accepted in a variety of formats, including integer and "
"floating-point literals, as well as typical currency formatting, such as "
"<literal>'$1,000.00'</literal>. Output is generally in the latter form but "
"depends on the locale."
msgstr ""
"Тип <type>money</type> хранит денежную сумму с фиксированной дробной частью; "
"см. <xref remap=\"4\" linkend=\"datatype-money-table\"/>. Точность дробной "
"части определяется на уровне базы данных параметром <xref linkend=\"guc-lc-"
"monetary\"/>. Для диапазона, показанного в таблице, предполагается, что "
"число содержит два знака после запятой. Входные данные могут быть записаны "
"по-разному, в том числе в виде целых и дробных чисел, а также в виде строки "
"в денежном формате, например <literal>'$1,000.00'</literal>. Выводятся эти "
"значения обычно в денежном формате, зависящем от региональных стандартов."

#: datatype.xml:941(entry)
msgctxt "entry"
msgid "money"
msgstr "money"

#: datatype.xml:944(entry)
msgid "-92233720368547758.08 to +92233720368547758.07"
msgstr "-92233720368547&zwsp;758.08 .. +92233720368547&zwsp;758.07"

#: datatype.xml:950(para)
msgid ""
"Since the output of this data type is locale-sensitive, it might not work to "
"load <type>money</type> data into a database that has a different setting of "
"<varname>lc_monetary</varname>. To avoid problems, before restoring a dump "
"into a new database make sure <varname>lc_monetary</varname> has the same or "
"equivalent value as in the database that was dumped."
msgstr ""
"Так как выводимые значения этого типа зависят от региональных стандартов, "
"попытка загрузить данные типа <type>money</type> в базу данных с другим "
"параметром <varname>lc_monetary</varname> может быть неудачной. Во избежание "
"подобных проблем, прежде чем восстанавливать копию в новую базу данных, "
"убедитесь в том, что параметр <varname>lc_monetary</varname> в этой базе "
"данных имеет то же значение, что и в исходной."

#: datatype.xml:964(programlisting)
#, no-wrap
msgid "SELECT '12.34'::float8::numeric::money;"
msgstr "SELECT '12.34'::float8::numeric::money;"

#: datatype.xml:958(para)
msgid ""
"Values of the <type>numeric</type>, <type>int</type>, and <type>bigint</"
"type> data types can be cast to <type>money</type>. Conversion from the "
"<type>real</type> and <type>double precision</type> data types can be done "
"by casting to <type>numeric</type> first, for example: <placeholder-1/> "
"However, this is not recommended. Floating point numbers should not be used "
"to handle money due to the potential for rounding errors."
msgstr ""
"Значения типов <type>numeric</type>, <type>int</type> и <type>bigint</type> "
"можно привести к типу <type>money</type>. Преобразования типов <type>real</"
"type> и <type>double precision</type> так же возможны через тип "
"<type>numeric</type>, например: <placeholder-1/> Однако использовать числа с "
"плавающей точкой для денежных сумм не рекомендуется из-за возможных ошибок "
"округления."

#: datatype.xml:975(programlisting)
#, no-wrap
msgid "SELECT '52093.89'::money::numeric::float8;"
msgstr "SELECT '52093.89'::money::numeric::float8;"

#: datatype.xml:971(para)
msgid ""
"A <type>money</type> value can be cast to <type>numeric</type> without loss "
"of precision. Conversion to other types could potentially lose precision, "
"and must also be done in two stages: <placeholder-1/>"
msgstr ""
"Значение <type>money</type> можно привести к типу <type>numeric</type> без "
"потери точности. Преобразование в другие типы может быть неточным и также "
"должно выполняться в два этапа: <placeholder-1/>"

#: datatype.xml:980(para)
msgid ""
"When a <type>money</type> value is divided by another <type>money</type> "
"value, the result is <type>double precision</type> (i.e., a pure number, not "
"money); the currency units cancel each other out in the division."
msgstr ""
"При делении значения типа <type>money</type> на другое значение <type>money</"
"type> получается результат типа <type>double precision</type> (т. е. обычное "
"число, не денежная сумма); денежные единицы при делении сокращаются."

#: datatype.xml:989(title) datatype.xml:1022(title)
msgid "Character Types"
msgstr "Символьные типы"

#: datatype.xml:991(indexterm)
msgid "<primary>character string</primary> <secondary>data types</secondary>"
msgstr ""
"<primary>символьная строка</primary> <secondary>типы данных</secondary>"

#: datatype.xml:996(indexterm)
msgid "<primary>string</primary> <see>character string</see>"
msgstr "<primary>строка</primary> <see>символьная строка</see>"

#: datatype.xml:1001(indexterm)
msgid "<primary>character</primary>"
msgstr "<primary>character</primary>"

#: datatype.xml:1005(indexterm)
msgid "<primary>character varying</primary>"
msgstr "<primary>character varying</primary>"

#: datatype.xml:1009(indexterm)
msgid "<primary>text</primary>"
msgstr "<primary>text</primary>"

#: datatype.xml:1013(indexterm)
msgid "<primary>char</primary>"
msgstr "<primary>char</primary>"

#: datatype.xml:1017(indexterm)
msgid "<primary>varchar</primary>"
msgstr "<primary>varchar</primary>"

#: datatype.xml:1032(entry)
msgid ""
"<type>character varying(<replaceable>n</replaceable>)</type>, "
"<type>varchar(<replaceable>n</replaceable>)</type>"
msgstr ""
"<type>character varying(<replaceable>n</replaceable>)</type>, "
"<type>varchar(<replaceable>n</replaceable>)</type>"

#: datatype.xml:1033(entry)
msgid "variable-length with limit"
msgstr "строка ограниченной переменной длины"

#: datatype.xml:1036(entry)
msgid ""
"<type>character(<replaceable>n</replaceable>)</type>, "
"<type>char(<replaceable>n</replaceable>)</type>"
msgstr ""
"<type>character(<replaceable>n</replaceable>)</type>, "
"<type>char(<replaceable>n</replaceable>)</type>"

#: datatype.xml:1037(entry)
msgid "fixed-length, blank padded"
msgstr "строка фиксированной длины, дополненная пробелами"

#: datatype.xml:1041(entry)
msgid "variable unlimited length"
msgstr "строка неограниченной переменной длины"

#: datatype.xml:1047(para)
msgid ""
"<xref linkend=\"datatype-character-table\"/> shows the general-purpose "
"character types available in <productname>PostgreSQL</productname>."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-character-table\"/> перечислены "
"символьные типы общего назначения, доступные в <productname>PostgreSQL</"
"productname>."

#: datatype.xml:1053(para)
msgid ""
"<acronym>SQL</acronym> defines two primary character types: <type>character "
"varying(<replaceable>n</replaceable>)</type> and "
"<type>character(<replaceable>n</replaceable>)</type>, where <replaceable>n</"
"replaceable> is a positive integer. Both of these types can store strings up "
"to <replaceable>n</replaceable> characters (not bytes) in length. An attempt "
"to store a longer string into a column of these types will result in an "
"error, unless the excess characters are all spaces, in which case the string "
"will be truncated to the maximum length. (This somewhat bizarre exception is "
"required by the <acronym>SQL</acronym> standard.) If the string to be stored "
"is shorter than the declared length, values of type <type>character</type> "
"will be space-padded; values of type <type>character varying</type> will "
"simply store the shorter string."
msgstr ""
"<acronym>SQL</acronym> определяет два основных символьных типа: "
"<type>character varying(<replaceable>n</replaceable>)</type> и "
"<type>character(<replaceable>n</replaceable>)</type>, где <replaceable>n</"
"replaceable> &mdash; положительное число. Оба эти типа могут хранить "
"текстовые строки длиной до <replaceable>n</replaceable> символов (не байт). "
"Попытка сохранить в столбце такого типа более длинную строку приведёт к "
"ошибке, если только все лишние символы не являются пробелами (тогда они "
"будут усечены до максимально допустимой длины). (Это несколько странное "
"исключение продиктовано стандартом <acronym>SQL</acronym>.) Если длина "
"сохраняемой строки оказывается меньше объявленной, значения типа "
"<type>character</type> будут дополнятся пробелами; а тип <type>character "
"varying</type> просто сохранит короткую строку."

#: datatype.xml:1070(para)
msgid ""
"If one explicitly casts a value to <type>character varying(<replaceable>n</"
"replaceable>)</type> or <type>character(<replaceable>n</replaceable>)</"
"type>, then an over-length value will be truncated to <replaceable>n</"
"replaceable> characters without raising an error. (This too is required by "
"the <acronym>SQL</acronym> standard.)"
msgstr ""
"При попытке явно привести значение к типу <type>character "
"varying(<replaceable>n</replaceable>)</type> или "
"<type>character(<replaceable>n</replaceable>)</type>, часть строки, "
"выходящая за границу в <replaceable>n</replaceable> символов, удаляется, не "
"вызывая ошибки. (Это также продиктовано стандартом <acronym>SQL</acronym>.)"

#: datatype.xml:1079(para)
msgid ""
"The notations <type>varchar(<replaceable>n</replaceable>)</type> and "
"<type>char(<replaceable>n</replaceable>)</type> are aliases for "
"<type>character varying(<replaceable>n</replaceable>)</type> and "
"<type>character(<replaceable>n</replaceable>)</type>, respectively. "
"<type>character</type> without length specifier is equivalent to "
"<type>character(1)</type>. If <type>character varying</type> is used without "
"length specifier, the type accepts strings of any size. The latter is a "
"<productname>PostgreSQL</productname> extension."
msgstr ""
"Записи <type>varchar(<replaceable>n</replaceable>)</type> и "
"<type>char(<replaceable>n</replaceable>)</type> являются синонимами "
"<type>character varying(<replaceable>n</replaceable>)</type> и "
"<type>character(<replaceable>n</replaceable>)</type>, соответственно. Записи "
"<type>character</type> без указания длины соответствует <type>character(1)</"
"type>. Если же длина не указывается для <type>character varying</type>, этот "
"тип будет принимать строки любого размера. Это поведение является "
"расширением <productname>PostgreSQL</productname>."

#: datatype.xml:1090(para)
msgid ""
"In addition, <productname>PostgreSQL</productname> provides the <type>text</"
"type> type, which stores strings of any length. Although the type "
"<type>text</type> is not in the <acronym>SQL</acronym> standard, several "
"other SQL database management systems have it as well."
msgstr ""
"Помимо этого, <productname>PostgreSQL</productname> предлагает тип "
"<type>text</type>, в котором можно хранить строки произвольной длины. Хотя "
"тип <type>text</type> не описан в стандарте <acronym>SQL</acronym>, его "
"поддерживают и некоторые другие СУБД SQL."

#: datatype.xml:1098(para)
msgid ""
"Values of type <type>character</type> are physically padded with spaces to "
"the specified width <replaceable>n</replaceable>, and are stored and "
"displayed that way. However, trailing spaces are treated as semantically "
"insignificant and disregarded when comparing two values of type "
"<type>character</type>. In collations where whitespace is significant, this "
"behavior can produce unexpected results; for example <command>SELECT 'a '::"
"CHAR(2) collate \"C\" &lt; E'a\\n'::CHAR(2)</command> returns true, even "
"though <literal>C</literal> locale would consider a space to be greater than "
"a newline. Trailing spaces are removed when converting a <type>character</"
"type> value to one of the other string types. Note that trailing spaces "
"<emphasis>are</emphasis> semantically significant in <type>character "
"varying</type> and <type>text</type> values, and when using pattern "
"matching, that is <literal>LIKE</literal> and regular expressions."
msgstr ""
"Значения типа <type>character</type> физически дополняются пробелами до "
"<replaceable>n</replaceable> символов и хранятся, а затем отображаются в "
"таком виде. Однако при сравнении двух значений типа <type>character</type> "
"дополняющие пробелы считаются незначащими и игнорируются. С правилами "
"сортировки, где пробельные символы являются значащими, это поведение может "
"приводить к неожиданным результатам, например <command>SELECT 'a '::CHAR(2) "
"collate \"C\" &lt; E'a\\n'::CHAR(2)</command> вернёт true (условие будет "
"истинным), хотя в локали C символ пробела считается больше символа новой "
"строки. При приведении значения <type>character</type> к другому символьному "
"типу дополняющие пробелы отбрасываются. Заметьте, что эти пробелы "
"<emphasis>несут</emphasis> смысловую нагрузку в типах <type>character "
"varying</type> и <type>text</type> и в проверках по шаблонам, то есть в "
"<literal>LIKE</literal> и регулярных выражениях."

#: datatype.xml:1116(para)
msgid ""
"The storage requirement for a short string (up to 126 bytes) is 1 byte plus "
"the actual string, which includes the space padding in the case of "
"<type>character</type>. Longer strings have 4 bytes of overhead instead of "
"1. Long strings are compressed by the system automatically, so the physical "
"requirement on disk might be less. Very long values are also stored in "
"background tables so that they do not interfere with rapid access to shorter "
"column values. In any case, the longest possible character string that can "
"be stored is about 1 GB. (The maximum value that will be allowed for "
"<replaceable>n</replaceable> in the data type declaration is less than that. "
"It wouldn't be useful to change this because with multibyte character "
"encodings the number of characters and bytes can be quite different. If you "
"desire to store long strings with no specific upper limit, use <type>text</"
"type> or <type>character varying</type> without a length specifier, rather "
"than making up an arbitrary length limit.)"
msgstr ""
"Для хранения короткой строки (до 126 байт) требуется дополнительный 1 байт "
"плюс размер самой строки, включая дополняющие пробелы для типа "
"<type>character</type>. Для строк длиннее требуется не 1, а 4 дополнительных "
"байта. Система может автоматически сжимать длинные строки, так что "
"физический размер на диске может быть меньше. Очень длинные текстовые строки "
"переносятся в отдельные таблицы, чтобы они не замедляли работу с другими "
"столбцами. В любом случае, максимально возможный размер строки составляет "
"около 1 ГБ. (Допустимое значение <replaceable>n</replaceable> в объявлении "
"типа данных меньше этого числа. Это объясняется тем, что в зависимости от "
"кодировки каждый символ может занимать несколько байт. Если вы желаете "
"сохранять строки без определённого предела длины, используйте типы "
"<type>text</type> или <type>character varying</type> без указания длины, а "
"не задавайте какое-либо большое максимальное значение.)"

#: datatype.xml:1135(para)
msgid ""
"There is no performance difference among these three types, apart from "
"increased storage space when using the blank-padded type, and a few extra "
"CPU cycles to check the length when storing into a length-constrained "
"column. While <type>character(<replaceable>n</replaceable>)</type> has "
"performance advantages in some other database systems, there is no such "
"advantage in <productname>PostgreSQL</productname>; in fact "
"<type>character(<replaceable>n</replaceable>)</type> is usually the slowest "
"of the three because of its additional storage costs. In most situations "
"<type>text</type> or <type>character varying</type> should be used instead."
msgstr ""
"По быстродействию эти три типа практически не отличаются друг от друга, не "
"считая большего размера хранения для типа с дополняющими пробелами и "
"нескольких машинных операций для проверки длины при сохранении строк в "
"столбце с ограниченной длиной. Хотя в некоторых СУБД тип "
"<type>character(<replaceable>n</replaceable>)</type> работает быстрее "
"других, в <productname>PostgreSQL</productname> это не так; на деле "
"<type>character(<replaceable>n</replaceable>)</type> обычно оказывается "
"медленнее остальных типов из-за большего размера данных и более медленной "
"сортировки. В большинстве случаев вместо него лучше применять <type>text</"
"type> или <type>character varying</type>."

#: datatype.xml:1150(para)
msgid ""
"Refer to <xref linkend=\"sql-syntax-strings\"/> for information about the "
"syntax of string literals, and to <xref linkend=\"functions\"/> for "
"information about available operators and functions. The database character "
"set determines the character set used to store textual values; for more "
"information on character set support, refer to <xref linkend=\"multibyte\"/>."
msgstr ""
"Подробнее синтаксис текстовых строк описан в <xref remap=\"6\" linkend=\"sql-"
"syntax-strings\"/>, а доступные операторы и функции перечисляются в <xref "
"remap=\"6\" linkend=\"functions\"/>. Кодировка, используемая для хранения "
"текстовых строк, определяется набором символов, выбранным для базы данных. "
"Подробнее это описано в <xref remap=\"6\" linkend=\"multibyte\"/>."

#: datatype.xml:1160(title)
msgid "Using the Character Types"
msgstr "Использование символьных типов"

#: datatype.xml:1162(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test1 (a character(4));\n"
"INSERT INTO test1 VALUES ('ok');\n"
"SELECT a, char_length(a) FROM test1; -- <co id=\"co.datatype-char\"></co>\n"
"<computeroutput>\n"
"  a   | char_length\n"
"------+-------------\n"
" ok   |           2\n"
"</computeroutput>\n"
"\n"
"CREATE TABLE test2 (b varchar(5));\n"
"INSERT INTO test2 VALUES ('ok');\n"
"INSERT INTO test2 VALUES ('good      ');\n"
"INSERT INTO test2 VALUES ('too long');\n"
"<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>\n"
"INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation\n"
"SELECT b, char_length(b) FROM test2;\n"
"<computeroutput>\n"
"   b   | char_length\n"
"-------+-------------\n"
" ok    |           2\n"
" good  |           5\n"
" too l |           5\n"
"</computeroutput>"
msgstr ""
"CREATE TABLE test1 (a character(4));\n"
"INSERT INTO test1 VALUES ('ok');\n"
"SELECT a, char_length(a) FROM test1; -- <co id=\"co.datatype-char\"></co>\n"
"<computeroutput>\n"
"  a   | char_length\n"
"------+-------------\n"
" ok   |           2\n"
"</computeroutput>\n"
"\n"
"CREATE TABLE test2 (b varchar(5));\n"
"INSERT INTO test2 VALUES ('ok');\n"
"INSERT INTO test2 VALUES ('good      ');\n"
"INSERT INTO test2 VALUES ('too long');\n"
"<computeroutput>ОШИБКА:  значение не умещается в тип character varying(5)</computeroutput>\n"
"INSERT INTO test2 VALUES ('too long'::varchar(5)); -- явное усечение\n"
"SELECT b, char_length(b) FROM test2;\n"
"<computeroutput>\n"
"   b   | char_length\n"
"-------+-------------\n"
" ok    |           2\n"
" good  |           5\n"
" too l |           5\n"
"</computeroutput>"

#: datatype.xml:1189(para)
msgid ""
"The <function>char_length</function> function is discussed in <xref linkend="
"\"functions-string\"/>."
msgstr ""
"Функция <function>char_length</function> рассматривается в <xref remap=\"6\" "
"linkend=\"functions-string\"/>."

#: datatype.xml:1197(para)
msgid ""
"There are two other fixed-length character types in <productname>PostgreSQL</"
"productname>, shown in <xref linkend=\"datatype-character-special-table\"/>. "
"The <type>name</type> type exists <emphasis>only</emphasis> for the storage "
"of identifiers in the internal system catalogs and is not intended for use "
"by the general user. Its length is currently defined as 64 bytes (63 usable "
"characters plus terminator) but should be referenced using the constant "
"<symbol>NAMEDATALEN</symbol> in <literal>C</literal> source code. The length "
"is set at compile time (and is therefore adjustable for special uses); the "
"default maximum length might change in a future release. The type <type>"
"\"char\"</type> (note the quotes) is different from <type>char(1)</type> in "
"that it only uses one byte of storage. It is internally used in the system "
"catalogs as a simplistic enumeration type."
msgstr ""
"В <productname>PostgreSQL</productname> есть ещё два символьных типа "
"фиксированной длины, приведённые в <xref remap=\"6\" linkend=\"datatype-"
"character-special-table\"/>. Тип <type>name</type> создан <emphasis>только</"
"emphasis> для хранения идентификаторов во внутренних системных таблицах и не "
"предназначен для обычного применения пользователями. В настоящее время его "
"длина составляет 64 байта (63 ASCII-символа плюс конечный знак), но в "
"исходном коде <literal>C</literal> она задаётся константой "
"<symbol>NAMEDATALEN</symbol>. Эта константа определяется во время компиляции "
"(и её можно менять в особых случаях), а кроме того, максимальная длина по "
"умолчанию может быть увеличена в следующих версиях. Тип <type>\"char\"</"
"type> (обратите внимание на кавычки) отличается от <type>char(1)</type> тем, "
"что он фактически хранится в одном байте. Он используется во внутренних "
"системных таблицах для простых перечислений."

#: datatype.xml:1215(title)
msgid "Special Character Types"
msgstr "Специальные символьные типы"

#: datatype.xml:1226(type)
msgid "\"char\""
msgstr "\"char\""

#: datatype.xml:1227(entry) datatype.xml:2883(entry)
msgid "1 byte"
msgstr "1 байт"

#: datatype.xml:1228(entry)
msgid "single-byte internal type"
msgstr "внутренний однобайтный тип"

#: datatype.xml:1231(type)
msgid "name"
msgstr "name"

#: datatype.xml:1232(entry)
msgid "64 bytes"
msgstr "64 байта"

#: datatype.xml:1233(entry)
msgid "internal type for object names"
msgstr "внутренний тип для имён объектов"

#: datatype.xml:1242(title) datatype.xml:1258(title)
msgid "Binary Data Types"
msgstr "Двоичные типы данных"

#: datatype.xml:1244(indexterm)
msgid "<primary>binary data</primary>"
msgstr "<primary>двоичные данные</primary>"

#: datatype.xml:1248(indexterm)
msgid "<primary>bytea</primary>"
msgstr "<primary>bytea</primary>"

#: datatype.xml:1252(para)
msgid ""
"The <type>bytea</type> data type allows storage of binary strings; see <xref "
"linkend=\"datatype-binary-table\"/>."
msgstr ""
"Для хранения двоичных данных предназначен тип <type>bytea</type>; см. <xref "
"remap=\"4\" linkend=\"datatype-binary-table\"/>."

#: datatype.xml:1270(entry)
msgid "1 or 4 bytes plus the actual binary string"
msgstr "1 или 4 байта плюс сама двоичная строка"

#: datatype.xml:1271(entry)
msgid "variable-length binary string"
msgstr "двоичная строка переменной длины"

#: datatype.xml:1277(para)
msgid ""
"A binary string is a sequence of octets (or bytes). Binary strings are "
"distinguished from character strings in two ways. First, binary strings "
"specifically allow storing octets of value zero and other <quote>non-"
"printable</quote> octets (usually, octets outside the range 32 to 126). "
"Character strings disallow zero octets, and also disallow any other octet "
"values and sequences of octet values that are invalid according to the "
"database's selected character set encoding. Second, operations on binary "
"strings process the actual bytes, whereas the processing of character "
"strings depends on locale settings. In short, binary strings are appropriate "
"for storing data that the programmer thinks of as <quote>raw bytes</quote>, "
"whereas character strings are appropriate for storing text."
msgstr ""
"Двоичные строки представляют собой последовательность октетов (байт) и имеют "
"два отличия от текстовых строк. Во-первых, в двоичных строках можно хранить "
"байты с кодом 0 и другими <quote>непечатаемыми</quote> значениями (обычно "
"это значения вне диапазона 32..126). В текстовых строках нельзя сохранять "
"нулевые байты, а также значения и последовательности значений, не "
"соответствующие выбранной кодировке базы данных. Во-вторых, в операциях с "
"двоичными строками обрабатываются байты в чистом виде, тогда как текстовые "
"строки обрабатываются в зависимости от языковых стандартов. То есть, "
"двоичные строки больше подходят для данных, которые программист видит как "
"<quote>просто байты</quote>, а символьные строки &mdash; для хранения текста."

#: datatype.xml:1293(para)
msgid ""
"The <type>bytea</type> type supports two external formats for input and "
"output: <productname>PostgreSQL</productname>'s historical <quote>escape</"
"quote> format, and <quote>hex</quote> format. Both of these are always "
"accepted on input. The output format depends on the configuration parameter "
"<xref linkend=\"guc-bytea-output\"/>; the default is hex. (Note that the hex "
"format was introduced in <productname>PostgreSQL</productname> 9.0; earlier "
"versions and some tools don't understand it.)"
msgstr ""
"Тип <type>bytea</type> поддерживает два внешних формата ввода и вывода: "
"традиционный для <productname>PostgreSQL</productname> формат "
"<quote>спецпоследовательностей</quote> и <quote>шестнадцатеричный</quote>. "
"Входные данные принимаются в обоих форматах, а формат выходных данных "
"зависит от параметра конфигурации <xref linkend=\"guc-bytea-output\"/>; по "
"умолчанию выбран шестнадцатеричный. (Заметьте, что шестнадцатеричный формат "
"был введён в <productname>PostgreSQL</productname> 9.0; в ранних версиях и "
"некоторых программах он не будет работать.)"

#: datatype.xml:1304(para)
msgid ""
"The <acronym>SQL</acronym> standard defines a different binary string type, "
"called <type>BLOB</type> or <type>BINARY LARGE OBJECT</type>. The input "
"format is different from <type>bytea</type>, but the provided functions and "
"operators are mostly the same."
msgstr ""
"Стандарт <acronym>SQL</acronym> определяет другой тип двоичных данных, "
"<type>BLOB</type> (<type>BINARY LARGE OBJECT</type>, большой двоичный "
"объект). Его входной формат отличается от форматов <type>bytea</type>, но "
"функции и операторы в основном те же."

#: datatype.xml:1313(title)
msgid "<type>bytea</type> Hex Format"
msgstr "Шестнадцатеричный формат <type>bytea</type>"

#: datatype.xml:1315(para)
msgid ""
"The <quote>hex</quote> format encodes binary data as 2 hexadecimal digits "
"per byte, most significant nibble first. The entire string is preceded by "
"the sequence <literal>\\x</literal> (to distinguish it from the escape "
"format). In some contexts, the initial backslash may need to be escaped by "
"doubling it, in the same cases in which backslashes have to be doubled in "
"escape format; details appear below. The hexadecimal digits can be either "
"upper or lower case, and whitespace is permitted between digit pairs (but "
"not within a digit pair nor in the starting <literal>\\x</literal> "
"sequence). The hex format is compatible with a wide range of external "
"applications and protocols, and it tends to be faster to convert than the "
"escape format, so its use is preferred."
msgstr ""
"В <quote>шестнадцатеричном</quote> формате двоичные данные кодируются двумя "
"шестнадцатеричными цифрами на байт, при этом первая цифра соответствует "
"старшим 4 битам. К полученной строке добавляется префикс <literal>\\x</"
"literal> (чтобы она отличалась от формата спецпоследовательности). В "
"некоторых контекстах обратную косую черту нужно выделить, продублировав её, "
"в тех же случаях это нужно сделать для формата спецпоследовательности; "
"подробнее это описано ниже. Шестнадцатеричные цифры могут быть в любом "
"регистре, а между парами цифр допускаются пробельные символы (но не внутри "
"пары и не в начале последовательности <literal>\\x</literal>). Этот формат "
"совместим со множеством внешних приложений и протоколов, к тому же обычно "
"преобразуется быстрее, поэтому предпочтительнее использовать его."

#: datatype.xml:1333(programlisting)
#, no-wrap
msgid "SELECT E'\\\\xDEADBEEF';"
msgstr "SELECT E'\\\\xDEADBEEF';"

#: datatype.xml:1331(para)
msgid "Example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#: datatype.xml:1340(title)
msgid "<type>bytea</type> Escape Format"
msgstr "Формат спецпоследовательностей <type>bytea</type>"

#: datatype.xml:1342(para)
msgid ""
"The <quote>escape</quote> format is the traditional <productname>PostgreSQL</"
"productname> format for the <type>bytea</type> type. It takes the approach "
"of representing a binary string as a sequence of ASCII characters, while "
"converting those bytes that cannot be represented as an ASCII character into "
"special escape sequences. If, from the point of view of the application, "
"representing bytes as characters makes sense, then this representation can "
"be convenient. But in practice it is usually confusing because it fuzzes up "
"the distinction between binary strings and character strings, and also the "
"particular escape mechanism that was chosen is somewhat unwieldy. So this "
"format should probably be avoided for most new applications."
msgstr ""
"Формат <quote>спецпоследовательностей</quote> традиционно использовался в "
"<productname>PostgreSQL</productname> для значений типа <type>bytea</type>. "
"В нём двоичная строка представляется в виде последовательности ASCII-"
"символов, а байты, непредставимые в виде ASCII-символов, передаются в виде "
"спецпоследовательностей. Этот формат может быть удобен, если с точки зрения "
"приложения представление байт в виде символов имеет смысл. Но на практике "
"это обычно создаёт путаницу, так как двоичные и символьные строки могут "
"выглядеть одинаково, а кроме того выбранный механизм спецпоследовательностей "
"довольно неуклюж. Поэтому в новых приложениях этот формат обычно не стоит "
"использовать."

#: datatype.xml:1358(para)
msgid ""
"When entering <type>bytea</type> values in escape format, octets of certain "
"values <emphasis>must</emphasis> be escaped, while all octet values "
"<emphasis>can</emphasis> be escaped. In general, to escape an octet, convert "
"it into its three-digit octal value and precede it by a backslash (or two "
"backslashes, if writing the value as a literal using escape string syntax). "
"Backslash itself (octet value 92) can alternatively be represented by double "
"backslashes. <xref linkend=\"datatype-binary-sqlesc\"/> shows the characters "
"that must be escaped, and gives the alternative escape sequences where "
"applicable."
msgstr ""
"Передавая значения <type>bytea</type> в формате спецпоследовательности, "
"байты с определёнными значениями <emphasis>необходимо</emphasis> записывать "
"специальным образом, хотя так <emphasis>можно</emphasis> записывать и все "
"значения. В общем виде для этого значение байта нужно преобразовать в "
"трёхзначное восьмеричное число и добавить перед ним обратную косую черту (и "
"продублировать её, если значение записывается в текстовой спецстроке). Саму "
"обратную косую черту (символ с кодом 92) можно записать в виде двух таких "
"символов. В <xref remap=\"6\" linkend=\"datatype-binary-sqlesc\"/> "
"перечислены символы, которые нужно записывать спецпоследовательностями, и "
"приведены альтернативные варианты записи там, где они возможны."

#: datatype.xml:1375(title)
msgid "<type>bytea</type> Literal Escaped Octets"
msgstr "Спецпоследовательности записи значений <type>bytea</type>"

#: datatype.xml:1379(entry) datatype.xml:1470(entry)
msgid "Decimal Octet Value"
msgstr "Десятичное значение байта"

#: datatype.xml:1381(entry)
msgid "Escaped Input Representation"
msgstr ""
"Спецпоследова-\n"
"тельность ввода"

#: datatype.xml:1382(entry) datatype.xml:1473(entry) datatype.xml:1785(entry)
#: datatype.xml:1906(entry) datatype.xml:1968(entry) datatype.xml:2250(entry)
#: datatype.xml:2722(entry)
msgid "Example"
msgstr "Пример"

#: datatype.xml:1383(entry)
msgid "Output Representation"
msgstr "Выводимое представление"

#: datatype.xml:1389(entry)
msgid "0"
msgstr "0"

#: datatype.xml:1390(entry)
msgid "zero octet"
msgstr "нулевой байт"

#: datatype.xml:1391(literal)
msgid "E'\\\\000'"
msgstr "E'\\\\000'"

#: datatype.xml:1392(literal)
msgid "SELECT E'\\\\000'::bytea;"
msgstr "SELECT E'\\\\000'::bytea;"

#: datatype.xml:1393(literal)
msgid "\\000"
msgstr "\\000"

#: datatype.xml:1397(entry)
msgid "39"
msgstr "39"

#: datatype.xml:1398(entry)
msgid "single quote"
msgstr "апостроф"

#: datatype.xml:1399(entry)
msgid "<literal>''''</literal> or <literal>E'\\\\047'</literal>"
msgstr "<literal>''''</literal> или <literal>E'\\\\047'</literal>"

#: datatype.xml:1400(literal)
msgid "SELECT E'\\''::bytea;"
msgstr "SELECT E'\\''::bytea;"

#: datatype.xml:1401(literal)
msgid "'"
msgstr "'"

#: datatype.xml:1405(entry) datatype.xml:1481(entry)
msgid "92"
msgstr "92"

#: datatype.xml:1406(entry) datatype.xml:1482(entry)
msgid "backslash"
msgstr "обратная косая черта"

#: datatype.xml:1407(entry)
msgid "<literal>E'\\\\\\\\'</literal> or <literal>E'\\\\134'</literal>"
msgstr "<literal>E'\\\\\\\\'</literal> или <literal>E'\\\\134'</literal>"

#: datatype.xml:1408(literal)
msgid "SELECT E'\\\\\\\\'::bytea;"
msgstr "SELECT E'\\\\\\\\'::bytea;"

#: datatype.xml:1409(literal) datatype.xml:1483(literal)
#: datatype.xml:1485(literal)
msgid "\\\\"
msgstr "\\\\"

#: datatype.xml:1413(entry) datatype.xml:1489(entry)
msgid "0 to 31 and 127 to 255"
msgstr "от 0 до 31 и от 127 до 255"

#: datatype.xml:1414(entry) datatype.xml:1490(entry)
msgid "<quote>non-printable</quote> octets"
msgstr "<quote>непечатаемые</quote> байты"

#: datatype.xml:1415(entry)
msgid "<literal>E'\\\\<replaceable>xxx'</replaceable></literal> (octal value)"
msgstr ""
"<literal>E'\\\\<replaceable>xxx'</replaceable></literal> (значение байта)"

#: datatype.xml:1416(literal) datatype.xml:1492(literal)
msgid "SELECT E'\\\\001'::bytea;"
msgstr "SELECT E'\\\\001'::bytea;"

#: datatype.xml:1417(literal) datatype.xml:1493(literal)
msgid "\\001"
msgstr "\\001"

#: datatype.xml:1424(para)
msgid ""
"The requirement to escape <emphasis>non-printable</emphasis> octets varies "
"depending on locale settings. In some instances you can get away with "
"leaving them unescaped. Note that the result in each of the examples in "
"<xref linkend=\"datatype-binary-sqlesc\"/> was exactly one octet in length, "
"even though the output representation is sometimes more than one character."
msgstr ""
"Набор <emphasis>непечатаемых</emphasis> символов, которые нужно записывать "
"спецпоследовательностями, определяется языковыми стандартами. В некоторых "
"случаях можно оставить в буквальном виде и другие символы. Заметьте, что во "
"всех примерах в <xref remap=\"6\" linkend=\"datatype-binary-sqlesc\"/> "
"задаётся значение ровно одного байта, хотя выходное представление может "
"состоять из нескольких символов."

#: datatype.xml:1433(para)
msgid ""
"The reason multiple backslashes are required, as shown in <xref linkend="
"\"datatype-binary-sqlesc\"/>, is that an input string written as a string "
"literal must pass through two parse phases in the <productname>PostgreSQL</"
"productname> server. The first backslash of each pair is interpreted as an "
"escape character by the string-literal parser (assuming escape string syntax "
"is used) and is therefore consumed, leaving the second backslash of the "
"pair. (Dollar-quoted strings can be used to avoid this level of escaping.) "
"The remaining backslash is then recognized by the <type>bytea</type> input "
"function as starting either a three digit octal value or escaping another "
"backslash. For example, a string literal passed to the server as "
"<literal>E'\\\\001'</literal> becomes <literal>\\001</literal> after passing "
"through the escape string parser. The <literal>\\001</literal> is then sent "
"to the <type>bytea</type> input function, where it is converted to a single "
"octet with a decimal value of 1. Note that the single-quote character is not "
"treated specially by <type>bytea</type>, so it follows the normal rules for "
"string literals. (See also <xref linkend=\"sql-syntax-strings\"/>.)"
msgstr ""
"Необходимость дублирования обратных косых черт в записи "
"спецпоследовательностей, показанного в <xref remap=\"6\" linkend=\"datatype-"
"binary-sqlesc\"/>, объясняется тем, что строковая константа должна пройти "
"два этапа разбора на сервере <productname>PostgreSQL</productname>. Первая "
"обратная косая черта из каждой пары воспринимается анализатором строки как "
"спецсимвол (если используется синтаксис спецпоследовательностей) и таким "
"образом пропускается, оставляя только вторую косую черту. (Для избавления от "
"этой вложенности можно использовать строки в долларах.) Оставшаяся обратная "
"косая черта затем распознаётся функцией ввода <type>bytea</type> как "
"спецсимвол, предваряющий трёхзначное восьмеричное значение или следующий "
"спецсимвол. Например, переданная серверу строковая константа <literal>E'\\"
"\\001'</literal> преобразуется в <literal>\\001</literal>, проходя через "
"анализатор спецстрок. Затем строка <literal>\\001</literal> передаётся "
"функции ввода типа <type>bytea</type>, где она преобразуется в один байт с "
"десятичным значением 1. Заметьте, что символ апостроф для функции ввода "
"<type>bytea</type> не отличается от остальных, поэтому он записывается как "
"обычно принято в строках. (См. также <xref remap=\"4\" linkend=\"sql-syntax-"
"strings\"/>.)"

#: datatype.xml:1455(para)
msgid ""
"<type>Bytea</type> octets are sometimes escaped when output. In general, "
"each <quote>non-printable</quote> octet is converted into its equivalent "
"three-digit octal value and preceded by one backslash. Most "
"<quote>printable</quote> octets are represented by their standard "
"representation in the client character set. The octet with decimal value 92 "
"(backslash) is doubled in the output. Details are in <xref linkend="
"\"datatype-binary-resesc\"/>."
msgstr ""
"Данные <type>bytea</type> иногда выводятся также в спецпоследовательностях. "
"При этом каждый <quote>непечатаемый</quote> байт представляется в виде "
"трёхзначного восьмеричного значения после обратной косой черты. Большинство "
"<quote>печатаемых</quote> байт представляются обычными символами из "
"клиентского набора символов. Байт с десятичным кодом 92 (обратная косая "
"черта) при выводе дублируется. Это иллюстрирует <xref linkend=\"datatype-"
"binary-resesc\"/>."

#: datatype.xml:1466(title)
msgid "<type>bytea</type> Output Escaped Octets"
msgstr "Спецпоследовательности выходных значений <type>bytea</type>"

#: datatype.xml:1472(entry)
msgid "Escaped Output Representation"
msgstr "Спецпоследовательность вывода"

#: datatype.xml:1474(entry)
msgid "Output Result"
msgstr "Выводимый результат"

#: datatype.xml:1484(literal)
msgid "SELECT E'\\\\134'::bytea;"
msgstr "SELECT E'\\\\134'::bytea;"

#: datatype.xml:1491(entry)
msgid "<literal>\\<replaceable>xxx</replaceable></literal> (octal value)"
msgstr "<literal>\\<replaceable>xxx</replaceable></literal> (значение байта)"

#: datatype.xml:1497(entry)
msgid "32 to 126"
msgstr "от 32 до 126"

#: datatype.xml:1498(entry)
msgid "<quote>printable</quote> octets"
msgstr "<quote>печатаемые</quote> байты"

#: datatype.xml:1499(entry)
msgid "client character set representation"
msgstr "представление из клиентского набора символов"

#: datatype.xml:1500(literal)
msgid "SELECT E'\\\\176'::bytea;"
msgstr "SELECT E'\\\\176'::bytea;"

#: datatype.xml:1501(literal)
msgid "~"
msgstr "~"

#: datatype.xml:1508(para)
msgid ""
"Depending on the front end to <productname>PostgreSQL</productname> you use, "
"you might have additional work to do in terms of escaping and unescaping "
"<type>bytea</type> strings. For example, you might also have to escape line "
"feeds and carriage returns if your interface automatically translates these."
msgstr ""
"В зависимости от применяемой клиентской библиотеки <productname>PostgreSQL</"
"productname>, для преобразования значений <type>bytea</type> в спецстроки и "
"обратно могут потребоваться дополнительные действия. Например, если "
"приложение сохраняет в строках символы перевода строк, возможно их также "
"нужно будет представить спецпоследовательностями."

#: datatype.xml:1520(title) datatype.xml:1565(title)
msgid "Date/Time Types"
msgstr "Типы даты/времени"

#: datatype.xml:1522(indexterm) datatype.xml:1771(indexterm)
msgid "<primary>date</primary>"
msgstr "<primary>date</primary>"

#: datatype.xml:1525(indexterm) datatype.xml:1868(indexterm)
msgid "<primary>time</primary>"
msgstr "<primary>time</primary>"

#: datatype.xml:1528(indexterm) datatype.xml:1871(indexterm)
msgid "<primary>time without time zone</primary>"
msgstr "<primary>time without time zone</primary>"

#: datatype.xml:1531(indexterm) datatype.xml:1874(indexterm)
msgid "<primary>time with time zone</primary>"
msgstr "<primary>time with time zone</primary>"

#: datatype.xml:1534(indexterm) datatype.xml:2018(indexterm)
msgid "<primary>timestamp</primary>"
msgstr "<primary>timestamp</primary>"

#: datatype.xml:1537(indexterm)
msgid "<primary>timestamptz</primary>"
msgstr "<primary>timestamptz</primary>"

#: datatype.xml:1540(indexterm) datatype.xml:2022(indexterm)
msgid "<primary>timestamp with time zone</primary>"
msgstr "<primary>timestamp with time zone</primary>"

#: datatype.xml:1543(indexterm) datatype.xml:2026(indexterm)
msgid "<primary>timestamp without time zone</primary>"
msgstr "<primary>timestamp without time zone</primary>"

#: datatype.xml:1546(indexterm) datatype.xml:2549(indexterm)
msgid "<primary>interval</primary>"
msgstr "<primary>interval</primary>"

#: datatype.xml:1549(indexterm)
msgid "<primary>time span</primary>"
msgstr "<primary>time span</primary>"

#: datatype.xml:1553(para)
msgid ""
"<productname>PostgreSQL</productname> supports the full set of <acronym>SQL</"
"acronym> date and time types, shown in <xref linkend=\"datatype-datetime-"
"table\"/>. The operations available on these data types are described in "
"<xref linkend=\"functions-datetime\"/>. Dates are counted according to the "
"Gregorian calendar, even in years before that calendar was introduced (see "
"<xref linkend=\"datetime-units-history\"/> for more information)."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает полный набор типов даты и "
"времени <acronym>SQL</acronym>, показанный в <xref remap=\"6\" linkend="
"\"datatype-datetime-table\"/>. Операции, возможные с этими типами данных, "
"описаны в <xref remap=\"6\" linkend=\"functions-datetime\"/>. Все даты "
"считаются по Григорианскому календарю, даже для времени до его введения (за "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"datetime-"
"units-history\"/>)."

#: datatype.xml:1572(entry)
msgid "Low Value"
msgstr "Наименьшее значение"

#: datatype.xml:1573(entry)
msgid "High Value"
msgstr "Наибольшее значение"

#: datatype.xml:1574(entry)
msgid "Resolution"
msgstr "Точность"

#: datatype.xml:1581(entry)
msgid "both date and time (no time zone)"
msgstr "дата и время (без часового пояса)"

#: datatype.xml:1582(entry) datatype.xml:1590(entry) datatype.xml:1598(entry)
msgid "4713 BC"
msgstr "4713 до н. э."

#: datatype.xml:1583(entry) datatype.xml:1591(entry)
msgid "294276 AD"
msgstr "294276 н. э."

#: datatype.xml:1584(entry) datatype.xml:1592(entry) datatype.xml:1608(entry)
#: datatype.xml:1616(entry) datatype.xml:1624(entry)
msgid "1 microsecond / 14 digits"
msgstr "1 микросекунда / 14 цифр"

#: datatype.xml:1589(entry)
msgid "both date and time, with time zone"
msgstr "дата и время (с часовым поясом)"

#: datatype.xml:1597(entry)
msgid "date (no time of day)"
msgstr "дата (без времени суток)"

#: datatype.xml:1599(entry)
msgid "5874897 AD"
msgstr "5874897 н. э."

#: datatype.xml:1600(entry)
msgid "1 day"
msgstr "1 день"

#: datatype.xml:1605(entry)
msgid "time of day (no date)"
msgstr "время суток (без даты)"

#: datatype.xml:1606(entry)
msgid "00:00:00"
msgstr "00:00:00"

#: datatype.xml:1607(entry)
msgid "24:00:00"
msgstr "24:00:00"

#: datatype.xml:1612(entry)
msgid "12 bytes"
msgstr "12 байт"

#: datatype.xml:1613(entry)
msgid "times of day only, with time zone"
msgstr "только время суток (с часовым поясом)"

#: datatype.xml:1614(entry)
msgid "00:00:00+1459"
msgstr "00:00:00+1459"

#: datatype.xml:1615(entry)
msgid "24:00:00-1459"
msgstr "24:00:00-1459"

#: datatype.xml:1620(entry) datatype.xml:3122(entry)
msgid "16 bytes"
msgstr "16 байт"

#: datatype.xml:1621(entry)
msgid "time interval"
msgstr "временной интервал"

#: datatype.xml:1622(entry)
msgid "-178000000 years"
msgstr "-178000000 лет"

#: datatype.xml:1623(entry)
msgid "178000000 years"
msgstr "178000000 лет"

#: datatype.xml:1631(para)
msgid ""
"The SQL standard requires that writing just <type>timestamp</type> be "
"equivalent to <type>timestamp without time zone</type>, and "
"<productname>PostgreSQL</productname> honors that behavior. "
"<type>timestamptz</type> is accepted as an abbreviation for <type>timestamp "
"with time zone</type>; this is a <productname>PostgreSQL</productname> "
"extension."
msgstr ""
"Стандарт SQL требует, чтобы тип <type>timestamp</type> подразумевал "
"<type>timestamp without time zone</type> (время без часового пояса), и "
"<productname>PostgreSQL</productname> следует этому. Для краткости "
"<type>timestamp with time zone</type> можно записать как <type>timestamptz</"
"type>; это расширение <productname>PostgreSQL</productname>."

#: datatype.xml:1641(para)
msgid ""
"<type>time</type>, <type>timestamp</type>, and <type>interval</type> accept "
"an optional precision value <replaceable>p</replaceable> which specifies the "
"number of fractional digits retained in the seconds field. By default, there "
"is no explicit bound on precision. The allowed range of <replaceable>p</"
"replaceable> is from 0 to 6 for the <type>timestamp</type> and "
"<type>interval</type> types."
msgstr ""
"Типы <type>time</type>, <type>timestamp</type> и <type>interval</type> "
"принимают необязательное значение точности <replaceable>p</replaceable>, "
"определяющее, сколько знаков после запятой должно сохраняться в секундах. По "
"умолчанию точность не ограничивается. Для типов <type>timestamp</type> и "
"<type>interval</type> <replaceable>p</replaceable> может принимать значения "
"от 0 до 6."

#: datatype.xml:1652(para)
msgid ""
"When <type>timestamp</type> values are stored as eight-byte integers "
"(currently the default), microsecond precision is available over the full "
"range of values. When <type>timestamp</type> values are stored as double "
"precision floating-point numbers instead (a deprecated compile-time option), "
"the effective limit of precision might be less than 6. <type>timestamp</"
"type> values are stored as seconds before or after midnight 2000-01-01. When "
"<type>timestamp</type> values are implemented using floating-point numbers, "
"microsecond precision is achieved for dates within a few years of "
"2000-01-01, but the precision degrades for dates further away. Note that "
"using floating-point datetimes allows a larger range of <type>timestamp</"
"type> values to be represented than shown above: from 4713 BC up to 5874897 "
"AD."
msgstr ""
"Когда значения <type>timestamp</type> хранятся в восьмибайтных целых (сейчас "
"по умолчанию это так), на всём интервале значений обеспечивается точность в "
"микросекундах. Если же значения этого типа сохраняются в числах двойной "
"точности с плавающей точкой (устаревший вариант компиляции), фактический "
"предел точности может быть меньше 6. Значения <type>timestamp</type> "
"сохраняются в секундах до или после полуночи 1 января 2000 г. Когда при этом "
"используются числа с плавающей точкой, микросекундная точность достигается "
"для дат в пределах нескольких лет от этой даты, а при удалении от неё "
"точность теряется. Однако заметьте, что даты в числах с плавающей точкой "
"позволяют представить больший диапазон <type>timestamp</type>, чем было "
"показано выше: от 4713 до н. э. до 5874897 н. э."

#: datatype.xml:1668(para)
msgid ""
"The same compile-time option also determines whether <type>time</type> and "
"<type>interval</type> values are stored as floating-point numbers or eight-"
"byte integers. In the floating-point case, large <type>interval</type> "
"values degrade in precision as the size of the interval increases."
msgstr ""
"В зависимости от того же варианта компиляции, типы <type>time</type> и "
"<type>interval</type> могут сохраняться в виде чисел с плавающей точкой или "
"в восьмибайтных целых. В случае с плавающей точкой при больших значениях "
"<type>interval</type> точность уменьшается."

#: datatype.xml:1677(para)
msgid ""
"For the <type>time</type> types, the allowed range of <replaceable>p</"
"replaceable> is from 0 to 6 when eight-byte integer storage is used, or from "
"0 to 10 when floating-point storage is used."
msgstr ""
"Для типа <type>time</type> <replaceable>p</replaceable> может принимать "
"значения от 0 до 6 при хранении типа в восьмибайтном целом и от 0 до 10 при "
"хранении в числе с плавающей точкой."

#: datatype.xml:1683(para)
msgid ""
"The <type>interval</type> type has an additional option, which is to "
"restrict the set of stored fields by writing one of these phrases: "
"<literallayout class=\"monospaced\">\n"
"YEAR\n"
"MONTH\n"
"DAY\n"
"HOUR\n"
"MINUTE\n"
"SECOND\n"
"YEAR TO MONTH\n"
"DAY TO HOUR\n"
"DAY TO MINUTE\n"
"DAY TO SECOND\n"
"HOUR TO MINUTE\n"
"HOUR TO SECOND\n"
"MINUTE TO SECOND\n"
"</literallayout> Note that if both <replaceable>fields</replaceable> and "
"<replaceable>p</replaceable> are specified, the <replaceable>fields</"
"replaceable> must include <literal>SECOND</literal>, since the precision "
"applies only to the seconds."
msgstr ""
"Тип <type>interval</type> дополнительно позволяет ограничить набор "
"сохраняемых поле следующими фразами: <literallayout class=\"monospaced\">\n"
"YEAR\n"
"MONTH\n"
"DAY\n"
"HOUR\n"
"MINUTE\n"
"SECOND\n"
"YEAR TO MONTH\n"
"DAY TO HOUR\n"
"DAY TO MINUTE\n"
"DAY TO SECOND\n"
"HOUR TO MINUTE\n"
"HOUR TO SECOND\n"
"MINUTE TO SECOND\n"
"</literallayout> Заметьте, что если указаны и <replaceable>поля</"
"replaceable>, и точность <replaceable>p</replaceable>, указание "
"<replaceable>поля</replaceable> должно включать <literal>SECOND</literal>, "
"так как точность применима только к секундам."

#: datatype.xml:1707(para)
msgid ""
"The type <type>time with time zone</type> is defined by the SQL standard, "
"but the definition exhibits properties which lead to questionable "
"usefulness. In most cases, a combination of <type>date</type>, <type>time</"
"type>, <type>timestamp without time zone</type>, and <type>timestamp with "
"time zone</type> should provide a complete range of date/time functionality "
"required by any application."
msgstr ""
"Тип <type>time with time zone</type> определён стандартом SQL, но в его "
"определении описаны свойства сомнительной ценности. В большинстве случаев "
"сочетание типов <type>date</type>, <type>time</type>, <type>timestamp "
"without time zone</type> и <type>timestamp with time zone</type> "
"удовлетворяет все потребности в функционале дат/времени, возникающие в "
"приложениях."

#: datatype.xml:1717(para)
msgid ""
"The types <type>abstime</type> and <type>reltime</type> are lower precision "
"types which are used internally. You are discouraged from using these types "
"in applications; these internal types might disappear in a future release."
msgstr ""
"Типы <type>abstime</type> и <type>reltime</type> имеют меньшую точность и "
"предназначены для внутреннего использования. Эти типы не рекомендуется "
"использовать в обычных приложениях; их может не быть в будущих версиях."

#: datatype.xml:1726(title)
msgid "Date/Time Input"
msgstr "Ввод даты/времени"

#: datatype.xml:1728(para)
msgid ""
"Date and time input is accepted in almost any reasonable format, including "
"ISO 8601, <acronym>SQL</acronym>-compatible, traditional "
"<productname>POSTGRES</productname>, and others. For some formats, ordering "
"of day, month, and year in date input is ambiguous and there is support for "
"specifying the expected ordering of these fields. Set the <xref linkend="
"\"guc-datestyle\"/> parameter to <literal>MDY</literal> to select month-day-"
"year interpretation, <literal>DMY</literal> to select day-month-year "
"interpretation, or <literal>YMD</literal> to select year-month-day "
"interpretation."
msgstr ""
"Значения даты и времени принимаются практически в любом разумном формате, "
"включая ISO 8601, <acronym>SQL</acronym>-совместимый, традиционный формат "
"<productname>POSTGRES</productname> и другие. В некоторых форматах порядок "
"даты, месяца и года во вводимой дате неоднозначен и поэтому поддерживается "
"явное определение формата. Для этого предназначен параметр <xref linkend="
"\"guc-datestyle\"/>. Когда он имеет значение <literal>MDY</literal>, "
"выбирается интерпретация месяц-день-год, значению <literal>DMY</literal> "
"соответствует день-месяц-год, а <literal>YMD</literal> &mdash; год-месяц-"
"день."

#: datatype.xml:1740(para)
msgid ""
"<productname>PostgreSQL</productname> is more flexible in handling date/time "
"input than the <acronym>SQL</acronym> standard requires. See <xref linkend="
"\"datetime-appendix\"/> for the exact parsing rules of date/time input and "
"for the recognized text fields including months, days of the week, and time "
"zones."
msgstr ""
"<productname>PostgreSQL</productname> обрабатывает вводимые значения даты/"
"времени более гибко, чем того требует стандарт <acronym>SQL</acronym>. "
"Точные правила разбора даты/времени и распознаваемые текстовые поля, в том "
"числе названия месяцев, дней недели и часовых поясов описаны в <xref remap="
"\"6\" linkend=\"datetime-appendix\"/>."

#: datatype.xml:1750(para)
msgid ""
"Remember that any date or time literal input needs to be enclosed in single "
"quotes, like text strings. Refer to <xref linkend=\"sql-syntax-constants-"
"generic\"/> for more information. <acronym>SQL</acronym> requires the "
"following syntax <synopsis>\n"
"<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] "
"'<replaceable>value</replaceable>'\n"
"</synopsis> where <replaceable>p</replaceable> is an optional precision "
"specification giving the number of fractional digits in the seconds field. "
"Precision can be specified for <type>time</type>, <type>timestamp</type>, "
"and <type>interval</type> types. The allowed values are mentioned above. If "
"no precision is specified in a constant specification, it defaults to the "
"precision of the literal value."
msgstr ""
"Помните, что любые вводимые значения даты и времени нужно заключать в "
"апострофы, как текстовые строки. За дополнительной информацией обратитесь к "
"<xref remap=\"3\" linkend=\"sql-syntax-constants-generic\"/>. <acronym>SQL</"
"acronym> предусматривает следующий синтаксис: <synopsis>\n"
"<replaceable>тип</replaceable> [ (<replaceable>p</replaceable>) ] "
"'<replaceable>значение</replaceable>'\n"
"</synopsis>Здесь <replaceable>p</replaceable> &mdash; необязательное "
"указание точности, определяющее число знаков после точки в секундах. "
"Точность может быть определена для типов <type>time</type>, <type>timestamp</"
"type> и <type>interval</type> в пределах, описанных выше. Если в определении "
"константы точность не указана, она считается равной точности значения в "
"строке."

#: datatype.xml:1769(title)
msgid "Dates"
msgstr "Даты"

#: datatype.xml:1775(para)
msgid ""
"<xref linkend=\"datatype-datetime-date-table\"/> shows some possible inputs "
"for the <type>date</type> type."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-datetime-date-table\"/> приведены "
"некоторые допустимые значения типа <type>date</type>."

#: datatype.xml:1781(title)
msgid "Date Input"
msgstr "Вводимые даты"

#: datatype.xml:1791(entry)
msgid "1999-01-08"
msgstr "1999-01-08"

#: datatype.xml:1792(entry)
msgid "ISO 8601; January 8 in any mode (recommended format)"
msgstr "ISO 8601; 8 января в любом режиме (рекомендуемый формат)"

#: datatype.xml:1796(entry)
msgid "January 8, 1999"
msgstr "January 8, 1999"

#: datatype.xml:1797(entry)
msgid "unambiguous in any <varname>datestyle</varname> input mode"
msgstr "воспринимается однозначно в любом режиме <varname>datestyle</varname>"

#: datatype.xml:1800(entry)
msgid "1/8/1999"
msgstr "1/8/1999"

#: datatype.xml:1801(entry)
msgid ""
"January 8 in <literal>MDY</literal> mode; August 1 in <literal>DMY</literal> "
"mode"
msgstr ""
"8 января в режиме <literal>MDY</literal> и 1 августа в режиме <literal>DMY</"
"literal>"

#: datatype.xml:1805(entry)
msgid "1/18/1999"
msgstr "1/18/1999"

#: datatype.xml:1806(entry)
msgid "January 18 in <literal>MDY</literal> mode; rejected in other modes"
msgstr ""
"18 января в режиме <literal>MDY</literal>; недопустимая дата в других режимах"

#: datatype.xml:1810(entry)
msgid "01/02/03"
msgstr "01/02/03"

#: datatype.xml:1811(entry)
msgid ""
"January 2, 2003 in <literal>MDY</literal> mode; February 1, 2003 in "
"<literal>DMY</literal> mode; February 3, 2001 in <literal>YMD</literal> mode"
msgstr ""
"2 января 2003 г. в режиме <literal>MDY</literal>; 1 февраля 2003 г. в режиме "
"<literal>DMY</literal> и 3 февраля 2001 г. в режиме <literal>YMD</literal>"

#: datatype.xml:1817(entry)
msgid "1999-Jan-08"
msgstr "1999-Jan-08"

#: datatype.xml:1818(entry) datatype.xml:1822(entry) datatype.xml:1826(entry)
msgid "January 8 in any mode"
msgstr "8 января в любом режиме"

#: datatype.xml:1821(entry)
msgid "Jan-08-1999"
msgstr "Jan-08-1999"

#: datatype.xml:1825(entry)
msgid "08-Jan-1999"
msgstr "08-Jan-1999"

#: datatype.xml:1829(entry)
msgid "99-Jan-08"
msgstr "99-Jan-08"

#: datatype.xml:1830(entry)
msgid "January 8 in <literal>YMD</literal> mode, else error"
msgstr "8 января в режиме <literal>YMD</literal>; ошибка в других режимах"

#: datatype.xml:1833(entry)
msgid "08-Jan-99"
msgstr "08-Jan-99"

#: datatype.xml:1834(entry) datatype.xml:1838(entry)
msgid "January 8, except error in <literal>YMD</literal> mode"
msgstr "8 января; ошибка в режиме <literal>YMD</literal>"

#: datatype.xml:1837(entry)
msgid "Jan-08-99"
msgstr "Jan-08-99"

#: datatype.xml:1841(entry)
msgid "19990108"
msgstr "19990108"

#: datatype.xml:1842(entry) datatype.xml:1846(entry)
msgid "ISO 8601; January 8, 1999 in any mode"
msgstr "ISO 8601; 8 января 1999 в любом режиме"

#: datatype.xml:1845(entry)
msgid "990108"
msgstr "990108"

#: datatype.xml:1849(entry)
msgid "1999.008"
msgstr "1999.008"

#: datatype.xml:1850(entry)
msgid "year and day of year"
msgstr "год и день года"

#: datatype.xml:1853(entry)
msgid "J2451187"
msgstr "J2451187"

#: datatype.xml:1854(entry)
msgid "Julian date"
msgstr "дата по юлианскому календарю"

#: datatype.xml:1857(entry)
msgid "January 8, 99 BC"
msgstr "January 8, 99 BC"

#: datatype.xml:1858(entry)
msgid "year 99 BC"
msgstr "99 до н. э."

#: datatype.xml:1866(title)
msgid "Times"
msgstr "Время"

#: datatype.xml:1878(para)
msgid ""
"The time-of-day types are <type>time [ (<replaceable>p</replaceable>) ] "
"without time zone</type> and <type>time [ (<replaceable>p</replaceable>) ] "
"with time zone</type>. <type>time</type> alone is equivalent to <type>time "
"without time zone</type>."
msgstr ""
"Для хранения времени суток без даты предназначены типы <type>time "
"[ (<replaceable>p</replaceable>) ] without time zone</type> и <type>time "
"[ (<replaceable>p</replaceable>) ] with time zone</type>. Тип <type>time</"
"type> без уточнения эквивалентен типу <type>time without time zone</type>."

#: datatype.xml:1886(para)
msgid ""
"Valid input for these types consists of a time of day followed by an "
"optional time zone. (See <xref linkend=\"datatype-datetime-time-table\"/> "
"and <xref linkend=\"datatype-timezone-table\"/>.) If a time zone is "
"specified in the input for <type>time without time zone</type>, it is "
"silently ignored. You can also specify a date but it will be ignored, except "
"when you use a time zone name that involves a daylight-savings rule, such as "
"<literal>America/New_York</literal>. In this case specifying the date is "
"required in order to determine whether standard or daylight-savings time "
"applies. The appropriate time zone offset is recorded in the <type>time with "
"time zone</type> value."
msgstr ""
"Допустимые вводимые значения этих типов состоят из записи времени суток и "
"необязательного указания часового пояса. (См. <xref remap=\"4\" linkend="
"\"datatype-datetime-time-table\"/> и <xref remap=\"4\" linkend=\"datatype-"
"timezone-table\"/>.) Если в значении для типа <type>time without time zone</"
"type> указывается часовой пояс, он просто игнорируется. Так же будет "
"игнорироваться дата, если её указать, за исключением случаев, когда в "
"указанном часовом поясе принят переход на летнее время, например "
"<literal>America/New_York</literal>. В данном случае указать дату "
"необходимо, чтобы система могла определить, применяется ли обычное или "
"летнее время. Соответствующее смещение часового пояса записывается в "
"значении <type>time with time zone</type>."

#: datatype.xml:1902(title)
msgid "Time Input"
msgstr "Вводимое время"

#: datatype.xml:1912(literal)
msgid "04:05:06.789"
msgstr "04:05:06.789"

#: datatype.xml:1913(entry) datatype.xml:1917(entry) datatype.xml:1921(entry)
#: datatype.xml:1925(entry) datatype.xml:1937(entry) datatype.xml:1941(entry)
#: datatype.xml:1945(entry) datatype.xml:1949(entry)
msgid "ISO 8601"
msgstr "ISO 8601"

#: datatype.xml:1916(literal)
msgid "04:05:06"
msgstr "04:05:06"

#: datatype.xml:1920(literal)
msgid "04:05"
msgstr "04:05"

#: datatype.xml:1924(literal)
msgid "040506"
msgstr "040506"

#: datatype.xml:1928(literal)
msgid "04:05 AM"
msgstr "04:05 AM"

#: datatype.xml:1929(entry)
msgid "same as 04:05; AM does not affect value"
msgstr "то же, что и 04:05; AM не меняет значение времени"

#: datatype.xml:1932(literal)
msgid "04:05 PM"
msgstr "04:05 PM"

#: datatype.xml:1933(entry)
msgid "same as 16:05; input hour must be &lt;= 12"
msgstr "то же, что и 16:05; часы должны быть &lt;= 12"

#: datatype.xml:1936(literal)
msgid "04:05:06.789-8"
msgstr "04:05:06.789-8"

#: datatype.xml:1940(literal)
msgid "04:05:06-08:00"
msgstr "04:05:06-08:00"

#: datatype.xml:1944(literal)
msgid "04:05-08:00"
msgstr "04:05-08:00"

#: datatype.xml:1948(literal)
msgid "040506-08"
msgstr "040506-08"

#: datatype.xml:1952(literal)
msgid "04:05:06 PST"
msgstr "04:05:06 PST"

#: datatype.xml:1953(entry)
msgid "time zone specified by abbreviation"
msgstr "часовой пояс задаётся аббревиатурой"

#: datatype.xml:1956(literal)
msgid "2003-04-12 04:05:06 America/New_York"
msgstr "2003-04-12 04:05:06 America/New_York"

#: datatype.xml:1957(entry)
msgid "time zone specified by full name"
msgstr "часовой пояс задаётся полным названием"

#: datatype.xml:1964(title)
msgid "Time Zone Input"
msgstr "Вводимый часовой пояс"

#: datatype.xml:1974(literal)
msgid "PST"
msgstr "PST"

#: datatype.xml:1975(entry)
msgid "Abbreviation (for Pacific Standard Time)"
msgstr "аббревиатура (Pacific Standard Time, Стандартное тихоокеанское время)"

#: datatype.xml:1978(literal)
msgid "America/New_York"
msgstr "America/New_York"

#: datatype.xml:1979(entry)
msgid "Full time zone name"
msgstr "полное название часового пояса"

#: datatype.xml:1982(literal)
msgid "PST8PDT"
msgstr "PST8PDT"

#: datatype.xml:1983(entry)
msgid "POSIX-style time zone specification"
msgstr "указание часового пояса в стиле POSIX"

#: datatype.xml:1986(literal)
msgid "-8:00"
msgstr "-8:00"

#: datatype.xml:1987(entry) datatype.xml:1991(entry) datatype.xml:1995(entry)
msgid "ISO-8601 offset for PST"
msgstr "смещение часового пояса PST по ISO-8601"

#: datatype.xml:1990(literal)
msgid "-800"
msgstr "-800"

#: datatype.xml:1994(literal)
msgid "-8"
msgstr "-8"

#: datatype.xml:1998(literal)
msgid "zulu"
msgstr "zulu"

#: datatype.xml:1999(entry)
msgid "Military abbreviation for UTC"
msgstr "принятое у военных сокращение UTC"

#: datatype.xml:2002(literal)
msgid "z"
msgstr "z"

#: datatype.xml:2003(entry)
msgid "Short form of <literal>zulu</literal>"
msgstr "краткая форма <literal>zulu</literal>"

#: datatype.xml:2009(para)
msgid ""
"Refer to <xref linkend=\"datatype-timezones\"/> for more information on how "
"to specify time zones."
msgstr ""
"Подробнее узнать о том, как указывается часовой пояс, можно в <xref remap="
"\"6\" linkend=\"datatype-timezones\"/>."

#: datatype.xml:2016(title)
msgid "Time Stamps"
msgstr "Даты и время"

#: datatype.xml:2038(programlisting)
#, no-wrap
msgid "1999-01-08 04:05:06"
msgstr "1999-01-08 04:05:06"

#: datatype.xml:2042(programlisting)
#, no-wrap
msgid "1999-01-08 04:05:06 -8:00"
msgstr "1999-01-08 04:05:06 -8:00"

#: datatype.xml:2048(programlisting)
#, no-wrap
msgid "January 8 04:05:06 1999 PST"
msgstr "January 8 04:05:06 1999 PST"

#: datatype.xml:2030(para)
msgid ""
"Valid input for the time stamp types consists of the concatenation of a date "
"and a time, followed by an optional time zone, followed by an optional "
"<literal>AD</literal> or <literal>BC</literal>. (Alternatively, <literal>AD</"
"literal>/<literal>BC</literal> can appear before the time zone, but this is "
"not the preferred ordering.) Thus: <placeholder-1/> and: <placeholder-2/> "
"are valid values, which follow the <acronym>ISO</acronym> 8601 standard. In "
"addition, the common format: <placeholder-3/> is supported."
msgstr ""
"Допустимые значения типов timestamp состоят из записи даты и времени, после "
"которого может указываться часовой пояс и необязательное уточнение "
"<literal>AD</literal> или <literal>BC</literal>, определяющее эпоху до нашей "
"эры и нашу эру соответственно. (<literal>AD</literal>/<literal>BC</literal> "
"можно указать и перед часовым поясом, но предпочтительнее первый вариант.) "
"Таким образом: <placeholder-1/> и <placeholder-2/> допустимые варианты, "
"соответствующие стандарту <acronym>ISO</acronym> 8601. В дополнение к этому "
"поддерживается распространённый формат: <placeholder-3/>"

#: datatype.xml:2061(programlisting)
#, no-wrap
msgid "TIMESTAMP '2004-10-19 10:23:54'"
msgstr "TIMESTAMP '2004-10-19 10:23:54'"

#: datatype.xml:2065(programlisting)
#, no-wrap
msgid "TIMESTAMP '2004-10-19 10:23:54+02'"
msgstr "TIMESTAMP '2004-10-19 10:23:54+02'"

#: datatype.xml:2074(programlisting)
#, no-wrap
msgid "TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'"
msgstr "TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'"

#: datatype.xml:2054(para)
msgid ""
"The <acronym>SQL</acronym> standard differentiates <type>timestamp without "
"time zone</type> and <type>timestamp with time zone</type> literals by the "
"presence of a <quote>+</quote> or <quote>-</quote> symbol and time zone "
"offset after the time. Hence, according to the standard, <placeholder-1/> is "
"a <type>timestamp without time zone</type>, while <placeholder-2/> is a "
"<type>timestamp with time zone</type>. <productname>PostgreSQL</productname> "
"never examines the content of a literal string before determining its type, "
"and therefore will treat both of the above as <type>timestamp without time "
"zone</type>. To ensure that a literal is treated as <type>timestamp with "
"time zone</type>, give it the correct explicit type: <placeholder-3/> In a "
"literal that has been determined to be <type>timestamp without time zone</"
"type>, <productname>PostgreSQL</productname> will silently ignore any time "
"zone indication. That is, the resulting value is derived from the date/time "
"fields in the input value, and is not adjusted for time zone."
msgstr ""
"Стандарт <acronym>SQL</acronym> различает константы типов <type>timestamp "
"without time zone</type> и <type>timestamp with time zone</type> по знаку "
"<quote>+</quote> или <quote>-</quote> и смещению часового пояса, "
"добавленному после времени. Следовательно, согласно стандарту, записи "
"<placeholder-1/> должен соответствовать тип <type>timestamp without time "
"zone</type>, а <placeholder-2/> тип <type>timestamp with time zone</type>. "
"<productname>PostgreSQL</productname> никогда не анализирует содержимое "
"текстовой строки, чтобы определить тип значения, и поэтому обе записи будут "
"обработаны как значения типа <type>timestamp without time zone</type>. Чтобы "
"текстовая константа обрабатывалась как <type>timestamp with time zone</"
"type>, укажите этот тип явно: <placeholder-3/> В константе типа "
"<type>timestamp without time zone</type> <productname>PostgreSQL</"
"productname> просто игнорирует часовой пояс. То есть результирующее значение "
"вычисляется только из полей даты/времени и не подстраивается под указанный "
"часовой пояс."

#: datatype.xml:2083(para)
msgid ""
"For <type>timestamp with time zone</type>, the internally stored value is "
"always in UTC (Universal Coordinated Time, traditionally known as Greenwich "
"Mean Time, <acronym>GMT</acronym>). An input value that has an explicit time "
"zone specified is converted to UTC using the appropriate offset for that "
"time zone. If no time zone is stated in the input string, then it is assumed "
"to be in the time zone indicated by the system's <xref linkend=\"guc-timezone"
"\"/> parameter, and is converted to UTC using the offset for the "
"<varname>timezone</varname> zone."
msgstr ""
"Значения <type>timestamp with time zone</type> внутри всегда хранятся в UTC "
"(Universal Coordinated Time, Всемирное скоординированное время или время по "
"Гринвичу, <acronym>GMT</acronym>). Вводимое значение, в котором явно указан "
"часовой пояс, переводится в UTC с учётом смещения данного часового пояса. "
"Если во входной строке не указан часовой пояс, подразумевается часовой пояс, "
"заданный системным параметром <xref linkend=\"guc-timezone\"/> и время так "
"же пересчитывается в UTC со смещением <varname>timezone</varname>."

#: datatype.xml:2095(para)
msgid ""
"When a <type>timestamp with time zone</type> value is output, it is always "
"converted from UTC to the current <varname>timezone</varname> zone, and "
"displayed as local time in that zone. To see the time in another time zone, "
"either change <varname>timezone</varname> or use the <literal>AT TIME ZONE</"
"literal> construct (see <xref linkend=\"functions-datetime-zoneconvert\"/>)."
msgstr ""
"Когда значение <type>timestamp with time zone</type> выводится, оно всегда "
"преобразуется из UTC в текущий часовой пояс <varname>timezone</varname> и "
"отображается как локальное время. Чтобы получить время для другого часового "
"пояса, нужно либо изменить <varname>timezone</varname>, либо воспользоваться "
"конструкцией <literal>AT TIME ZONE</literal> (см. <xref remap=\"4\" linkend="
"\"functions-datetime-zoneconvert\"/>)."

#: datatype.xml:2104(para)
msgid ""
"Conversions between <type>timestamp without time zone</type> and "
"<type>timestamp with time zone</type> normally assume that the "
"<type>timestamp without time zone</type> value should be taken or given as "
"<varname>timezone</varname> local time. A different time zone can be "
"specified for the conversion using <literal>AT TIME ZONE</literal>."
msgstr ""
"В преобразованиях между <type>timestamp without time zone</type> и "
"<type>timestamp with time zone</type> обычно предполагается, что значение "
"<type>timestamp without time zone</type> содержит местное время (для "
"часового пояса <varname>timezone</varname>). Другой часовой пояс для "
"преобразования можно задать с помощью <literal>AT TIME ZONE</literal>."

#: datatype.xml:2114(title)
msgid "Special Values"
msgstr "Специальные значения"

#: datatype.xml:2116(indexterm)
msgid "<primary>time</primary> <secondary>constants</secondary>"
msgstr "<primary>время</primary> <secondary>константы</secondary>"

#: datatype.xml:2121(indexterm)
msgid "<primary>date</primary> <secondary>constants</secondary>"
msgstr "<primary>дата</primary> <secondary>константы</secondary>"

#: datatype.xml:2126(para)
msgid ""
"<productname>PostgreSQL</productname> supports several special date/time "
"input values for convenience, as shown in <xref linkend=\"datatype-datetime-"
"special-table\"/>. The values <literal>infinity</literal> and <literal>-"
"infinity</literal> are specially represented inside the system and will be "
"displayed unchanged; but the others are simply notational shorthands that "
"will be converted to ordinary date/time values when read. (In particular, "
"<literal>now</literal> and related strings are converted to a specific time "
"value as soon as they are read.) All of these values need to be enclosed in "
"single quotes when used as constants in SQL commands."
msgstr ""
"<productname>PostgreSQL</productname> для удобства поддерживает несколько "
"специальных значений даты/времени, перечисленных в <xref remap=\"6\" linkend="
"\"datatype-datetime-special-table\"/>. Значения <literal>infinity</literal> "
"и <literal>-infinity</literal> имеют особое представление в системе и они "
"отображаются в том же виде, тогда как другие варианты при чтении "
"преобразуются в значения даты/времени. (В частности, <literal>now</literal> "
"и подобные строки преобразуются в актуальные значения времени в момент "
"чтения.) Чтобы использовать эти значения в качестве констант в командах SQL, "
"их нужно заключать в апострофы."

#: datatype.xml:2141(title)
msgid "Special Date/Time Inputs"
msgstr "Специальные значения даты/времени"

#: datatype.xml:2145(entry)
msgid "Input String"
msgstr "Вводимая строка"

#: datatype.xml:2146(entry)
msgid "Valid Types"
msgstr "Допустимые типы"

#: datatype.xml:2152(literal)
msgid "epoch"
msgstr "epoch"

#: datatype.xml:2153(entry) datatype.xml:2158(entry) datatype.xml:2163(entry)
#: datatype.xml:2173(entry) datatype.xml:2178(entry) datatype.xml:2183(entry)
msgid "<type>date</type>, <type>timestamp</type>"
msgstr "<type>date</type>, <type>timestamp</type>"

#: datatype.xml:2154(entry)
msgid "1970-01-01 00:00:00+00 (Unix system time zero)"
msgstr "1970-01-01 00:00:00+00 (точка отсчёта времени в Unix)"

#: datatype.xml:2157(literal)
msgid "infinity"
msgstr "infinity"

#: datatype.xml:2159(entry)
msgid "later than all other time stamps"
msgstr "время после максимальной допустимой даты"

#: datatype.xml:2162(literal)
msgid "-infinity"
msgstr "-infinity"

#: datatype.xml:2164(entry)
msgid "earlier than all other time stamps"
msgstr "время до минимальной допустимой даты"

#: datatype.xml:2167(literal)
msgid "now"
msgstr "now"

#: datatype.xml:2168(entry)
msgid "<type>date</type>, <type>time</type>, <type>timestamp</type>"
msgstr "<type>date</type>, <type>time</type>, <type>timestamp</type>"

#: datatype.xml:2169(entry)
msgid "current transaction's start time"
msgstr "время начала текущей транзакции"

#: datatype.xml:2172(literal)
msgid "today"
msgstr "today"

#: datatype.xml:2174(entry)
msgid "midnight today"
msgstr "время начала текущих суток"

#: datatype.xml:2177(literal)
msgid "tomorrow"
msgstr "tomorrow"

#: datatype.xml:2179(entry)
msgid "midnight tomorrow"
msgstr "время начала следующих суток"

#: datatype.xml:2182(literal)
msgid "yesterday"
msgstr "yesterday"

#: datatype.xml:2184(entry)
msgid "midnight yesterday"
msgstr "время начала предыдущих суток"

#: datatype.xml:2187(literal)
msgid "allballs"
msgstr "allballs"

#: datatype.xml:2188(type)
msgid "time"
msgstr "time"

#: datatype.xml:2189(entry)
msgid "00:00:00.00 UTC"
msgstr "00:00:00.00 UTC"

#: datatype.xml:2195(para)
msgid ""
"The following <acronym>SQL</acronym>-compatible functions can also be used "
"to obtain the current time value for the corresponding data type: "
"<literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>, "
"<literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>, "
"<literal>LOCALTIMESTAMP</literal>. The latter four accept an optional "
"subsecond precision specification. (See <xref linkend=\"functions-datetime-"
"current\"/>.) Note that these are SQL functions and are <emphasis>not</"
"emphasis> recognized in data input strings."
msgstr ""
"Для получения текущей даты/времени соответствующего типа можно также "
"использовать следующие <acronym>SQL</acronym>-совместимые функции: "
"<literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>, "
"<literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal> и "
"<literal>LOCALTIMESTAMP</literal>. Последние четыре функции принимают "
"необязательное указание точности. (См. <xref remap=\"4\" linkend=\"functions-"
"datetime-current\"/>.) Заметьте, что во входных строках эти SQL-функции "
"<emphasis>не</emphasis> распознаются."

#: datatype.xml:2211(title)
msgid "Date/Time Output"
msgstr "Вывод даты/времени"

#: datatype.xml:2213(indexterm)
msgid ""
"<primary>date</primary> <secondary>output format</secondary> "
"<seealso>formatting</seealso>"
msgstr ""
"<primary>дата</primary> <secondary>формат вывода</secondary> "
"<seealso>форматирование</seealso>"

#: datatype.xml:2219(indexterm)
msgid ""
"<primary>time</primary> <secondary>output format</secondary> "
"<seealso>formatting</seealso>"
msgstr ""
"<primary>время</primary> <secondary>формат вывода</secondary> "
"<seealso>форматирование</seealso>"

#: datatype.xml:2225(para)
msgid ""
"The output format of the date/time types can be set to one of the four "
"styles ISO 8601, <acronym>SQL</acronym> (Ingres), traditional "
"<productname>POSTGRES</productname> (Unix <application>date</application> "
"format), or German. The default is the <acronym>ISO</acronym> format. (The "
"<acronym>SQL</acronym> standard requires the use of the ISO 8601 format. The "
"name of the <quote>SQL</quote> output format is a historical accident.) "
"<xref linkend=\"datatype-datetime-output-table\"/> shows examples of each "
"output style. The output of the <type>date</type> and <type>time</type> "
"types is generally only the date or time part in accordance with the given "
"examples. However, the <productname>POSTGRES</productname> style outputs "
"date-only values in <acronym>ISO</acronym> format."
msgstr ""
"В качестве выходного формата типов даты/времени можно использовать один из "
"четырёх стилей: ISO 8601, <acronym>SQL</acronym> (Ingres), традиционный "
"формат <productname>POSTGRES</productname> (формат <application>date</"
"application> в Unix) или German. По умолчанию выбран формат <acronym>ISO</"
"acronym>. (Стандарт <acronym>SQL</acronym> требует, чтобы использовался "
"именно ISO 8601. Другой формат называется <quote>SQL</quote> исключительно "
"по историческим причинам.) Примеры всех стилей вывода перечислены в <xref "
"remap=\"6\" linkend=\"datatype-datetime-output-table\"/>. Вообще со "
"значениями типов <type>date</type> и <type>time</type> выводилась бы только "
"часть даты или времени из показанных примеров, но со стилем "
"<productname>POSTGRES</productname> значение даты без времени выводится в "
"формате <acronym>ISO</acronym>."

#: datatype.xml:2244(title)
msgid "Date/Time Output Styles"
msgstr "Стили вывода даты/время"

#: datatype.xml:2248(entry) datatype.xml:2805(entry)
msgid "Style Specification"
msgstr "Стиль"

#: datatype.xml:2255(literal)
msgid "ISO"
msgstr "ISO"

#: datatype.xml:2256(entry)
msgid "ISO 8601, SQL standard"
msgstr "ISO 8601, стандарт SQL"

#: datatype.xml:2257(literal)
msgid "1997-12-17 07:37:16-08"
msgstr "1997-12-17 07:37:16-08"

#: datatype.xml:2260(literal)
msgid "SQL"
msgstr "SQL"

#: datatype.xml:2261(entry)
msgid "traditional style"
msgstr "традиционный стиль"

#: datatype.xml:2262(literal) datatype.xml:2316(literal)
msgid "12/17/1997 07:37:16.00 PST"
msgstr "12/17/1997 07:37:16.00 PST"

#: datatype.xml:2265(literal)
msgid "Postgres"
msgstr "Postgres"

#: datatype.xml:2266(entry)
msgid "original style"
msgstr "изначальный стиль"

#: datatype.xml:2267(literal)
msgid "Wed Dec 17 07:37:16 1997 PST"
msgstr "Wed Dec 17 07:37:16 1997 PST"

#: datatype.xml:2270(literal)
msgid "German"
msgstr "German"

#: datatype.xml:2271(entry)
msgid "regional style"
msgstr "региональный стиль"

#: datatype.xml:2272(literal)
msgid "17.12.1997 07:37:16.00 PST"
msgstr "17.12.1997 07:37:16.00 PST"

#: datatype.xml:2279(para)
msgid ""
"ISO 8601 specifies the use of uppercase letter <literal>T</literal> to "
"separate the date and time. <productname>PostgreSQL</productname> accepts "
"that format on input, but on output it uses a space rather than <literal>T</"
"literal>, as shown above. This is for readability and for consistency with "
"RFC 3339 as well as some other database systems."
msgstr ""
"ISO 8601 указывает, что дата должна отделяться от времени буквой <literal>T</"
"literal> в верхнем регистре. <productname>PostgreSQL</productname> принимает "
"этот формат при вводе, но при выводе вставляет вместо <literal>T</literal> "
"пробел, как показано выше. Это сделано для улучшения читаемости и для "
"совместимости с RFC 3339 и другими СУБД."

#: datatype.xml:2288(para)
msgid ""
"In the <acronym>SQL</acronym> and POSTGRES styles, day appears before month "
"if DMY field ordering has been specified, otherwise month appears before "
"day. (See <xref linkend=\"datatype-datetime-input\"/> for how this setting "
"also affects interpretation of input values.) <xref linkend=\"datatype-"
"datetime-output2-table\"/> shows examples."
msgstr ""
"В стилях <acronym>SQL</acronym> и POSTGRES день выводится перед месяцем, "
"если установлен порядок DMY, а в противном случае месяц выводится перед "
"днём. (Как этот параметр также влияет на интерпретацию входных значений, "
"описано в <xref remap=\"6\" linkend=\"datatype-datetime-input\"/>) "
"Соответствующие примеры показаны в <xref remap=\"6\" linkend=\"datatype-"
"datetime-output2-table\"/>."

#: datatype.xml:2298(title)
msgid "Date Order Conventions"
msgstr "Соглашения о порядке компонентов даты"

#: datatype.xml:2302(entry)
msgid "<varname>datestyle</varname> Setting"
msgstr "Параметр <varname>datestyle</varname>"

#: datatype.xml:2303(entry)
msgid "Input Ordering"
msgstr "Порядок при вводе"

#: datatype.xml:2304(entry)
msgid "Example Output"
msgstr "Пример вывода"

#: datatype.xml:2309(literal)
msgid "SQL, DMY"
msgstr "SQL, DMY"

#: datatype.xml:2310(entry) datatype.xml:2320(entry)
msgid ""
"<replaceable>day</replaceable>/<replaceable>month</replaceable>/"
"<replaceable>year</replaceable>"
msgstr ""
"<replaceable>день</replaceable>/<replaceable>месяц</replaceable>/"
"<replaceable>год</replaceable>"

#: datatype.xml:2311(literal)
msgid "17/12/1997 15:37:16.00 CET"
msgstr "17/12/1997 15:37:16.00 CET"

#: datatype.xml:2314(literal)
msgid "SQL, MDY"
msgstr "SQL, MDY"

#: datatype.xml:2315(entry)
msgid ""
"<replaceable>month</replaceable>/<replaceable>day</replaceable>/"
"<replaceable>year</replaceable>"
msgstr ""
"<replaceable>месяц</replaceable>/<replaceable>день</replaceable>/"
"<replaceable>год</replaceable>"

#: datatype.xml:2319(literal)
msgid "Postgres, DMY"
msgstr "Postgres, DMY"

#: datatype.xml:2321(literal)
msgid "Wed 17 Dec 07:37:16 1997 PST"
msgstr "Wed 17 Dec 07:37:16 1997 PST"

#: datatype.xml:2327(para)
msgid ""
"The date/time style can be selected by the user using the <command>SET "
"datestyle</command> command, the <xref linkend=\"guc-datestyle\"/> parameter "
"in the <filename>postgresql.conf</filename> configuration file, or the "
"<envar>PGDATESTYLE</envar> environment variable on the server or client."
msgstr ""
"Стиль даты/времени пользователь может выбрать с помощью команды <command>SET "
"datestyle</command>, параметра <xref linkend=\"guc-datestyle\"/> в файле "
"конфигурации <filename>postgresql.conf</filename> или переменной окружения "
"<envar>PGDATESTYLE</envar> на сервере или клиенте."

#: datatype.xml:2336(para)
msgid ""
"The formatting function <function>to_char</function> (see <xref linkend="
"\"functions-formatting\"/>) is also available as a more flexible way to "
"format date/time output."
msgstr ""
"Для большей гибкости при форматировании выводимой даты/времени можно "
"использовать функцию <function>to_char</function> (см. <xref remap=\"4\" "
"linkend=\"functions-formatting\"/>)."

#: datatype.xml:2344(title)
msgid "Time Zones"
msgstr "Часовые пояса"

#: datatype.xml:2346(indexterm)
msgid "<primary>time zone</primary>"
msgstr "<primary>часовой пояс</primary>"

#: datatype.xml:2350(para)
msgid ""
"Time zones, and time-zone conventions, are influenced by political "
"decisions, not just earth geometry. Time zones around the world became "
"somewhat standardized during the 1900s, but continue to be prone to "
"arbitrary changes, particularly with respect to daylight-savings rules. "
"<productname>PostgreSQL</productname> uses the widely-used IANA (Olson) time "
"zone database for information about historical time zone rules. For times in "
"the future, the assumption is that the latest known rules for a given time "
"zone will continue to be observed indefinitely far into the future."
msgstr ""
"Часовые пояса и правила их применения определяются, как вы знаете, не только "
"по географическим, но и по политическим соображениям. Часовые пояса во всём "
"мире были более-менее стандартизированы в начале прошлого века, но они "
"продолжают претерпевать изменения, в частности это касается перехода на "
"летнее время. Для расчёта времени в прошлом <productname>PostgreSQL</"
"productname> получает исторические сведения о правилах часовых поясов из "
"распространённой базы данных IANA (Olson). Для будущего времени "
"предполагается, что в заданном часовом поясе будут продолжать действовать "
"последние принятые правила."

#: datatype.xml:2371(para)
msgid ""
"Although the <type>date</type> type cannot have an associated time zone, the "
"<type>time</type> type can. Time zones in the real world have little meaning "
"unless associated with a date as well as a time, since the offset can vary "
"through the year with daylight-saving time boundaries."
msgstr ""
"Хотя для типа <type>date</type> часовой пояс указать нельзя, это можно "
"сделать для типа <type>time</type>. В реальности это не очень полезно, так "
"как без даты нельзя точно определить смещение при переходе на летнее время."

#: datatype.xml:2383(para)
msgid ""
"The default time zone is specified as a constant numeric offset from "
"<acronym>UTC</acronym>. It is therefore impossible to adapt to daylight-"
"saving time when doing date/time arithmetic across <acronym>DST</acronym> "
"boundaries."
msgstr ""
"По умолчанию часовой пояс задаётся постоянным смещением от <acronym>UTC</"
"acronym>. Это также не позволяет учесть летнее время при арифметических "
"операций с датами, пересекающими границы летнего времени."

#: datatype.xml:2363(para)
msgid ""
"<productname>PostgreSQL</productname> endeavors to be compatible with the "
"<acronym>SQL</acronym> standard definitions for typical usage. However, the "
"<acronym>SQL</acronym> standard has an odd mix of date and time types and "
"capabilities. Two obvious problems are: <placeholder-1/>"
msgstr ""
"<productname>PostgreSQL</productname> стремится к совместимости со "
"стандартом <acronym>SQL</acronym> в наиболее типичных случаях. Однако "
"стандарт <acronym>SQL</acronym> допускает некоторые странности при "
"смешивании типов даты и времени. Две очевидные проблемы: <placeholder-1/>"

#: datatype.xml:2394(para)
msgid ""
"To address these difficulties, we recommend using date/time types that "
"contain both date and time when using time zones. We do <emphasis>not</"
"emphasis> recommend using the type <type>time with time zone</type> (though "
"it is supported by <productname>PostgreSQL</productname> for legacy "
"applications and for compliance with the <acronym>SQL</acronym> standard). "
"<productname>PostgreSQL</productname> assumes your local time zone for any "
"type containing only date or time."
msgstr ""
"Поэтому мы советуем использовать часовой пояс с типами, включающими и время, "
"и дату. Мы <emphasis>не</emphasis> рекомендуем использовать тип <type>time "
"with time zone</type> (хотя <productname>PostgreSQL</productname> "
"поддерживает его для старых приложений и совместимости со стандартом "
"<acronym>SQL</acronym>). Для типов, включающих только дату или только время, "
"в <productname>PostgreSQL</productname> предполагается местный часовой пояс."

#: datatype.xml:2405(para)
msgid ""
"All timezone-aware dates and times are stored internally in <acronym>UTC</"
"acronym>. They are converted to local time in the zone specified by the "
"<xref linkend=\"guc-timezone\"/> configuration parameter before being "
"displayed to the client."
msgstr ""
"Все значения даты и времени с часовым поясом представляются внутри в "
"<acronym>UTC</acronym>, а при передаче клиентскому приложению они "
"переводятся в местное время, при этом часовой пояс по умолчанию определяется "
"параметром конфигурации <xref linkend=\"guc-timezone\"/>."

#: datatype.xml:2417(para)
msgid ""
"A full time zone name, for example <literal>America/New_York</literal>. The "
"recognized time zone names are listed in the <literal>pg_timezone_names</"
"literal> view (see <xref linkend=\"view-pg-timezone-names\"/>). "
"<productname>PostgreSQL</productname> uses the widely-used IANA time zone "
"data for this purpose, so the same time zone names are also recognized by "
"much other software."
msgstr ""
"Полное название часового пояса, например <literal>America/New_York</"
"literal>. Все допустимые названия перечислены в представлении "
"<literal>pg_timezone_names</literal> (см. <xref remap=\"4\" linkend=\"view-"
"pg-timezone-names\"/>). Определения часовых поясов <productname>PostgreSQL</"
"productname> берёт из широко распространённой базы IANA, так что имена "
"часовых поясов PostgreSQL будут воспринимать и многие другие приложения."

#: datatype.xml:2428(para)
msgid ""
"A time zone abbreviation, for example <literal>PST</literal>. Such a "
"specification merely defines a particular offset from UTC, in contrast to "
"full time zone names which can imply a set of daylight savings transition-"
"date rules as well. The recognized abbreviations are listed in the "
"<literal>pg_timezone_abbrevs</literal> view (see <xref linkend=\"view-pg-"
"timezone-abbrevs\"/>). You cannot set the configuration parameters <xref "
"linkend=\"guc-timezone\"/> or <xref linkend=\"guc-log-timezone\"/> to a time "
"zone abbreviation, but you can use abbreviations in date/time input values "
"and with the <literal>AT TIME ZONE</literal> operator."
msgstr ""
"Аббревиатура часового пояса, например <literal>PST</literal>. Такое "
"определение просто задаёт смещение от UTC, в отличие от полных названий "
"поясов, которые кроме того подразумевают и правила перехода на летнее время. "
"Распознаваемые аббревиатуры перечислены в представлении "
"<literal>pg_timezone_abbrevs</literal> (см. <xref remap=\"4\" linkend=\"view-"
"pg-timezone-abbrevs\"/>). Аббревиатуры можно использовать во вводимых "
"значениях даты/времени и в операторе <literal>AT TIME ZONE</literal>, но не "
"в параметрах конфигурации <xref linkend=\"guc-timezone\"/> и <xref linkend="
"\"guc-log-timezone\"/>."

#: datatype.xml:2443(para)
msgid ""
"In addition to the timezone names and abbreviations, "
"<productname>PostgreSQL</productname> will accept POSIX-style time zone "
"specifications of the form <replaceable>STD</"
"replaceable><replaceable>offset</replaceable> or <replaceable>STD</"
"replaceable><replaceable>offset</replaceable><replaceable>DST</replaceable>, "
"where <replaceable>STD</replaceable> is a zone abbreviation, "
"<replaceable>offset</replaceable> is a numeric offset in hours west from "
"UTC, and <replaceable>DST</replaceable> is an optional daylight-savings zone "
"abbreviation, assumed to stand for one hour ahead of the given offset. For "
"example, if <literal>EST5EDT</literal> were not already a recognized zone "
"name, it would be accepted and would be functionally equivalent to United "
"States East Coast time. In this syntax, a zone abbreviation can be a string "
"of letters, or an arbitrary string surrounded by angle brackets "
"(<literal>&lt;&gt;</literal>). When a daylight-savings zone abbreviation is "
"present, it is assumed to be used according to the same daylight-savings "
"transition rules used in the IANA time zone database's <filename>posixrules</"
"filename> entry. In a standard <productname>PostgreSQL</productname> "
"installation, <filename>posixrules</filename> is the same as <literal>US/"
"Eastern</literal>, so that POSIX-style time zone specifications follow USA "
"daylight-savings rules. If needed, you can adjust this behavior by replacing "
"the <filename>posixrules</filename> file."
msgstr ""
"В дополнение к полным названиям и аббревиатурам часовых поясов "
"<productname>PostgreSQL</productname> принимает указания часового пояса в "
"стиле POSIX: <replaceable>STD</replaceable><replaceable>смещение</"
"replaceable> или <replaceable>STD</replaceable><replaceable>смещение</"
"replaceable><replaceable>DST</replaceable>, где <replaceable>STD</"
"replaceable> &mdash; аббревиатура пояса, <replaceable>смещение</replaceable> "
"&mdash; разница с UTC, а <replaceable>DST</replaceable> &mdash; "
"необязательное дополнение, обозначающее летнее время и добавляющее к "
"смещению ещё один час. Например, если бы обозначение <literal>EST5EDT</"
"literal> не являлось названием часового пояса, оно всё равно было бы "
"воспринято и функционально соответствовало бы поясу североамериканского "
"восточного времени. При такой записи аббревиатура пояса может быть набором "
"букв или обычной строкой, заключённой в угловые скобки ((<literal>&lt;&gt;</"
"literal>). Когда представлено название пояса с летним временем, при "
"пересчёте времени будут использоваться правила перехода на летнее время, "
"описанные в базе данных IANA в файле <filename>posixrules</filename>. В "
"стандартной инсталляции <productname>PostgreSQL</productname> файл "
"<filename>posixrules</filename> соответствует описанию <literal>US/Eastern</"
"literal>, так что для указаний часовых поясов в стиле POSIX применяются "
"правила перехода на летнее время, принятые в США. При необходимости это "
"можно изменить, заменив файл <filename>posixrules</filename>."

#: datatype.xml:2412(para)
msgid ""
"<productname>PostgreSQL</productname> allows you to specify time zones in "
"three different forms: <placeholder-1/> In short, this is the difference "
"between abbreviations and full names: abbreviations represent a specific "
"offset from UTC, whereas many of the full names imply a local daylight-"
"savings time rule, and so have two possible UTC offsets. As an example, "
"<literal>2014-06-04 12:00 America/New_York</literal> represents noon local "
"time in New York, which for this particular date was Eastern Daylight Time "
"(UTC-4). So <literal>2014-06-04 12:00 EDT</literal> specifies that same time "
"instant. But <literal>2014-06-04 12:00 EST</literal> specifies noon Eastern "
"Standard Time (UTC-5), regardless of whether daylight savings was nominally "
"in effect on that date."
msgstr ""
"<productname>PostgreSQL</productname> позволяет задать часовой пояс тремя "
"способами: <placeholder-1/> Вкратце, различие между аббревиатурами и полными "
"названиями заключаются в следующем: аббревиатуры представляют определённый "
"сдвиг от UTC, а полное название подразумевает ещё и местное правило по "
"переходу на летнее время, то есть, возможно, два сдвига от UTC. Например, "
"<literal>2014-06-04 12:00 America/New_York</literal> представляет полдень по "
"местному времени в Нью-Йорк, что для данного дня было бы летним восточным "
"временем (EDT или UTC-4). Так что <literal>2014-06-04 12:00 EDT</literal> "
"обозначает тот же момент времени. Но <literal>2014-06-04 12:00 EST</literal> "
"задаёт стандартное восточное время (UTC-5), не зависящее о того, действовало "
"ли летнее время в этот день."

#: datatype.xml:2481(para)
msgid ""
"To complicate matters, some jurisdictions have used the same timezone "
"abbreviation to mean different UTC offsets at different times; for example, "
"in Moscow <literal>MSK</literal> has meant UTC+3 in some years and UTC+4 in "
"others. <application>PostgreSQL</application> interprets such abbreviations "
"according to whatever they meant (or had most recently meant) on the "
"specified date; but, as with the <literal>EST</literal> example above, this "
"is not necessarily the same as local civil time on that date."
msgstr ""
"Мало того, в некоторых юрисдикциях одна и та же аббревиатура часового пояса "
"означала разные сдвиги UTC в разное время; например, аббревиатура "
"московского времени <literal>MSK</literal> несколько лет означала UTC+3, а "
"затем стала означать UTC+4. <application>PostgreSQL</application> "
"обрабатывает такие аббревиатуры в соответствии с их значениями на заданную "
"дату, но, как и с примером выше <literal>EST</literal>, это не обязательно "
"будет соответствовать местному гражданскому времени в этот день."

#: datatype.xml:2491(para)
msgid ""
"One should be wary that the POSIX-style time zone feature can lead to "
"silently accepting bogus input, since there is no check on the "
"reasonableness of the zone abbreviations. For example, <literal>SET TIMEZONE "
"TO FOOBAR0</literal> will work, leaving the system effectively using a "
"rather peculiar abbreviation for UTC. Another issue to keep in mind is that "
"in POSIX time zone names, positive offsets are used for locations "
"<emphasis>west</emphasis> of Greenwich. Everywhere else, "
"<productname>PostgreSQL</productname> follows the ISO-8601 convention that "
"positive timezone offsets are <emphasis>east</emphasis> of Greenwich."
msgstr ""
"При этом следует использовать возможность указания часового пояса в стиле "
"POSIX с осторожностью, так как при этом могут быть приняты заведомо неверные "
"данные, потому что разумность аббревиатуры никак не проверяется. Например, "
"команда <literal>SET TIMEZONE TO FOOBAR0</literal> будет работать и система "
"примет эту довольно оригинальную аббревиатуру для UTC. Также следует "
"учитывать, что в названиях часовых поясов POSIX положительные смещения "
"соответствуют сдвигу <emphasis>к западу</emphasis> Гринвича. Во всех "
"остальных формах <productname>PostgreSQL</productname> следует соглашению "
"ISO-8601, по которому положительным смещениям соответствует сдвиг "
"<emphasis>к востоку</emphasis> от Гринвича."

#: datatype.xml:2504(para)
msgid ""
"In all cases, timezone names and abbreviations are recognized case-"
"insensitively. (This is a change from <productname>PostgreSQL</productname> "
"versions prior to 8.2, which were case-sensitive in some contexts but not "
"others.)"
msgstr ""
"Независимо от формы, регистр в названиях и аббревиатурах часовых поясов не "
"важен. (В <productname>PostgreSQL</productname> до версии 8.2 он где-то имел "
"значение, а где-то нет.)"

#: datatype.xml:2511(para)
msgid ""
"Neither timezone names nor abbreviations are hard-wired into the server; "
"they are obtained from configuration files stored under <filename>.../share/"
"timezone/</filename> and <filename>.../share/timezonesets/</filename> of the "
"installation directory (see <xref linkend=\"datetime-config-files\"/>)."
msgstr ""
"Ни названия, ни аббревиатуры часовых поясов, не зашиты в самом сервере; они "
"считываются из файлов конфигурации, находящихся в путях <filename>.../share/"
"timezone/</filename> и <filename>.../share/timezonesets/</filename> "
"относительно каталога установки (см. <xref remap=\"4\" linkend=\"datetime-"
"config-files\"/>)."

#: datatype.xml:2527(para)
msgid ""
"The <acronym>SQL</acronym> command <command>SET TIME ZONE</command> sets the "
"time zone for the session. This is an alternative spelling of <command>SET "
"TIMEZONE TO</command> with a more SQL-spec-compatible syntax."
msgstr ""
"Часовой пояс для текущего сеанса можно установить с помощью <acronym>SQL</"
"acronym>-команды <command>SET TIME ZONE</command>. Это альтернативная запись "
"команды <command>SET TIMEZONE TO</command>, более соответствующая SQL-"
"стандарту."

#: datatype.xml:2535(para)
msgid ""
"The <envar>PGTZ</envar> environment variable is used by <application>libpq</"
"application> clients to send a <command>SET TIME ZONE</command> command to "
"the server upon connection."
msgstr ""
"Если установлена переменная окружения <envar>PGTZ</envar>, клиенты "
"<application>libpq</application> используют её значение, выполняя при "
"подключении к серверу команду <command>SET TIME ZONE</command>."

#: datatype.xml:2519(para)
msgid ""
"The <xref linkend=\"guc-timezone\"/> configuration parameter can be set in "
"the file <filename>postgresql.conf</filename>, or in any of the other "
"standard ways described in <xref linkend=\"runtime-config\"/>. There are "
"also some special ways to set it: <placeholder-1/>"
msgstr ""
"Параметр конфигурации <xref linkend=\"guc-timezone\"/> можно установить в "
"<filename>postgresql.conf</filename> или любым другим стандартным способом, "
"описанным в <xref remap=\"6\" linkend=\"runtime-config\"/>. Часовой пояс "
"может быть также определён следующими специальными способами: <placeholder-1/"
">"

#: datatype.xml:2547(title) datatype.xml:2718(title)
msgid "Interval Input"
msgstr "Ввод интервалов"

#: datatype.xml:2553(para)
msgid ""
"<type>interval</type> values can be written using the following verbose "
"syntax: <synopsis>\n"
"<optional>@</optional> <replaceable>quantity</replaceable> "
"<replaceable>unit</replaceable> <optional><replaceable>quantity</"
"replaceable> <replaceable>unit</replaceable>...</optional> "
"<optional><replaceable>direction</replaceable></optional>\n"
"</synopsis> where <replaceable>quantity</replaceable> is a number (possibly "
"signed); <replaceable>unit</replaceable> is <literal>microsecond</literal>, "
"<literal>millisecond</literal>, <literal>second</literal>, <literal>minute</"
"literal>, <literal>hour</literal>, <literal>day</literal>, <literal>week</"
"literal>, <literal>month</literal>, <literal>year</literal>, "
"<literal>decade</literal>, <literal>century</literal>, <literal>millennium</"
"literal>, or abbreviations or plurals of these units; "
"<replaceable>direction</replaceable> can be <literal>ago</literal> or empty. "
"The at sign (<literal>@</literal>) is optional noise. The amounts of the "
"different units are implicitly added with appropriate sign accounting. "
"<literal>ago</literal> negates all the fields. This syntax is also used for "
"interval output, if <xref linkend=\"guc-intervalstyle\"/> is set to "
"<literal>postgres_verbose</literal>."
msgstr ""
"Значения типа <type>interval</type> могут быть записаны в следующей "
"расширенной форме: <synopsis>\n"
"<optional>@</optional> <replaceable>количество</replaceable> "
"<replaceable>единица</replaceable> <optional><replaceable>количество</"
"replaceable> <replaceable>единица</replaceable>...</optional> "
"<optional><replaceable>направление</replaceable></optional>\n"
"</synopsis> где <replaceable>количество</replaceable> &mdash; это число "
"(возможно, со знаком); <replaceable>единица </replaceable> &mdash; одно из "
"значений: <literal>microsecond</literal>, <literal>millisecond</literal>, "
"<literal>second</literal>, <literal>minute</literal>, <literal>hour</"
"literal>, <literal>day</literal>, <literal>week</literal>, <literal>month</"
"literal>, <literal>year</literal>, <literal>decade</literal>, "
"<literal>century</literal>, <literal>millennium</literal> (которые "
"обозначают соответственно микросекунды, миллисекунды, секунды, минуты, часы, "
"дни, недели, месяцы, годы, десятилетия, века и тысячелетия), либо эти же "
"слова во множественном числе, либо их сокращения; <replaceable>направление</"
"replaceable> может принимать значение <literal>ago</literal> (назад) или "
"быть пустым. Знак <literal>@</literal> является необязательным. Все заданные "
"величины различных единиц суммируются вместе с учётом знака чисел. Указание "
"<literal>ago</literal> меняет знак всех полей на противоположный. Этот "
"синтаксис также используется при выводе интервала, если параметр <xref "
"linkend=\"guc-intervalstyle\"/> имеет значение <literal>postgres_verbose</"
"literal>."

#: datatype.xml:2577(para)
msgid ""
"Quantities of days, hours, minutes, and seconds can be specified without "
"explicit unit markings. For example, <literal>'1 12:59:10'</literal> is read "
"the same as <literal>'1 day 12 hours 59 min 10 sec'</literal>. Also, a "
"combination of years and months can be specified with a dash; for example "
"<literal>'200-10'</literal> is read the same as <literal>'200 years 10 "
"months'</literal>. (These shorter forms are in fact the only ones allowed by "
"the <acronym>SQL</acronym> standard, and are used for output when "
"<varname>IntervalStyle</varname> is set to <literal>sql_standard</literal>.)"
msgstr ""
"Количества дней, часов, минут и секунд можно определить, не указывая явно "
"соответствующие единицы. Например, запись <literal>'1 12:59:10'</literal> "
"равнозначна <literal>'1 day 12 hours 59 min 10 sec'</literal>. Сочетание "
"года и месяца также можно записать через минус; например <literal>'200-10'</"
"literal> означает то, же что и <literal>'200 years 10 months'</literal>. (На "
"самом деле только эти краткие формы разрешены стандартом <acronym>SQL</"
"acronym> и они используются при выводе, когда <varname>IntervalStyle</"
"varname> имеет значение <literal>sql_standard</literal>.)"

#: datatype.xml:2588(para)
msgid ""
"Interval values can also be written as ISO 8601 time intervals, using either "
"the <quote>format with designators</quote> of the standard's section 4.4.3.2 "
"or the <quote>alternative format</quote> of section 4.4.3.3. The format with "
"designators looks like this: <synopsis>\n"
"P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> "
"<optional> <replaceable>quantity</replaceable> <replaceable>unit</"
"replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</"
"replaceable> <replaceable>unit</replaceable> ...</optional></optional>\n"
"</synopsis> The string must start with a <literal>P</literal>, and may "
"include a <literal>T</literal> that introduces the time-of-day units. The "
"available unit abbreviations are given in <xref linkend=\"datatype-interval-"
"iso8601-units\"/>. Units may be omitted, and may be specified in any order, "
"but units smaller than a day must appear after <literal>T</literal>. In "
"particular, the meaning of <literal>M</literal> depends on whether it is "
"before or after <literal>T</literal>."
msgstr ""
"Интервалы можно также записывать в виде, определённом в ISO 8601, либо в "
"<quote>формате с кодами</quote>, описанном в разделе 4.4.3.2 этого "
"стандарта, либо в <quote>альтернативном формате</quote>, описанном в разделе "
"4.4.3.3. Формат с кодами выглядит так: <synopsis>\n"
"P <replaceable>количество</replaceable> <replaceable>единица</replaceable> "
"<optional> <replaceable>количество</replaceable> <replaceable>единица</"
"replaceable> ...</optional> <optional> T <optional> <replaceable>количество</"
"replaceable> <replaceable>единица</replaceable> ...</optional></optional>\n"
"</synopsis> Строка должна начинаться с символа <literal>P</literal> и может "
"включать также <literal>T</literal> перед временем суток. Допустимые коды "
"единиц перечислены в <xref remap=\"6\" linkend=\"datatype-interval-iso8601-"
"units\"/>. Коды единиц можно опустить или указать в любом порядке, но "
"компоненты времени суток должны идти после символа <literal>T</literal>. В "
"частности, значение кода <literal>M</literal> зависит от того, располагается "
"ли он до или после <literal>T</literal>."

#: datatype.xml:2607(title)
msgid "ISO 8601 Interval Unit Abbreviations"
msgstr "Коды единиц временных интервалов ISO 8601"

#: datatype.xml:2611(entry)
msgid "Abbreviation"
msgstr "Код"

#: datatype.xml:2612(entry)
msgid "Meaning"
msgstr "Значение"

#: datatype.xml:2617(entry)
msgid "Y"
msgstr "Y"

#: datatype.xml:2618(entry)
msgid "Years"
msgstr "годы"

#: datatype.xml:2621(entry) datatype.xml:2637(entry)
msgid "M"
msgstr "M"

#: datatype.xml:2622(entry)
msgid "Months (in the date part)"
msgstr "месяцы (в дате)"

#: datatype.xml:2625(entry)
msgid "W"
msgstr "W"

#: datatype.xml:2626(entry)
msgid "Weeks"
msgstr "недели"

#: datatype.xml:2629(entry)
msgid "D"
msgstr "D"

#: datatype.xml:2630(entry)
msgid "Days"
msgstr "дни"

#: datatype.xml:2633(entry)
msgid "H"
msgstr "H"

#: datatype.xml:2634(entry)
msgid "Hours"
msgstr "часы"

#: datatype.xml:2638(entry)
msgid "Minutes (in the time part)"
msgstr "минуты (во времени)"

#: datatype.xml:2641(entry)
msgid "S"
msgstr "S"

#: datatype.xml:2642(entry)
msgid "Seconds"
msgstr "секунды"

#: datatype.xml:2648(para)
msgid ""
"In the alternative format: <synopsis>\n"
"P <optional> <replaceable>years</replaceable>-<replaceable>months</"
"replaceable>-<replaceable>days</replaceable> </optional> <optional> T "
"<replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:"
"<replaceable>seconds</replaceable> </optional>\n"
"</synopsis> the string must begin with <literal>P</literal>, and a "
"<literal>T</literal> separates the date and time parts of the interval. The "
"values are given as numbers similar to ISO 8601 dates."
msgstr ""
"В альтернативном формате: <synopsis>\n"
"P <optional> <replaceable>год</replaceable>-<replaceable>месяц</replaceable>-"
"<replaceable>день</replaceable> </optional> <optional> T <replaceable>часы</"
"replaceable>:<replaceable>минуты</replaceable>:<replaceable>секунды</"
"replaceable> </optional>\n"
"</synopsis> строка должна начинаться с <literal>P</literal>, а <literal>T</"
"literal> разделяет компоненты даты и времени. Значения выражаются числами "
"так же, как и в датах ISO 8601."

#: datatype.xml:2658(para)
msgid ""
"When writing an interval constant with a <replaceable>fields</replaceable> "
"specification, or when assigning a string to an interval column that was "
"defined with a <replaceable>fields</replaceable> specification, the "
"interpretation of unmarked quantities depends on the <replaceable>fields</"
"replaceable>. For example <literal>INTERVAL '1' YEAR</literal> is read as 1 "
"year, whereas <literal>INTERVAL '1'</literal> means 1 second. Also, field "
"values <quote>to the right</quote> of the least significant field allowed by "
"the <replaceable>fields</replaceable> specification are silently discarded. "
"For example, writing <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</"
"literal> results in dropping the seconds field, but not the day field."
msgstr ""
"При записи интервальной константы с указанием <replaceable>полей</"
"replaceable> или присвоении столбцу типа interval строки с "
"<replaceable>полями</replaceable>, интерпретация непомеченных величин "
"зависит от <replaceable>полей</replaceable>. Например, <literal>INTERVAL '1' "
"YEAR</literal> воспринимается как 1 год, а <literal>INTERVAL '1'</literal> "
"&mdash; как 1 секунда. Кроме того, значения <quote>справа</quote> от "
"меньшего значащего поля, заданного в определении <replaceable>полей</"
"replaceable>, просто отбрасываются. Например, в записи <literal>INTERVAL '1 "
"day 2:03:04' HOUR TO MINUTE</literal> будут отброшены секунды, но не день."

#: datatype.xml:2671(para)
msgid ""
"According to the <acronym>SQL</acronym> standard all fields of an interval "
"value must have the same sign, so a leading negative sign applies to all "
"fields; for example the negative sign in the interval literal <literal>'-1 "
"2:03:04'</literal> applies to both the days and hour/minute/second parts. "
"<productname>PostgreSQL</productname> allows the fields to have different "
"signs, and traditionally treats each field in the textual representation as "
"independently signed, so that the hour/minute/second part is considered "
"positive in this example. If <varname>IntervalStyle</varname> is set to "
"<literal>sql_standard</literal> then a leading sign is considered to apply "
"to all fields (but only if no additional signs appear). Otherwise the "
"traditional <productname>PostgreSQL</productname> interpretation is used. To "
"avoid ambiguity, it's recommended to attach an explicit sign to each field "
"if any field is negative."
msgstr ""
"Согласно стандарту <acronym>SQL</acronym>, все компоненты значения interval "
"должны быть одного знака, и ведущий минус применяется ко всем компонентам; "
"например, минус в записи <literal>'-1 2:03:04'</literal> применяется и к "
"дню, и к часам/минутам/секундам. <productname>PostgreSQL</productname> "
"позволяет задавать для разных компонентов разные знаки и традиционно "
"обрабатывает знак каждого компонента в текстовом представлении отдельно от "
"других, так что в данном случае часы/минуты/секунды будут считаться "
"положительными. Если параметр <varname>IntervalStyle</varname> имеет "
"значение <literal>sql_standard</literal>, ведущий знак применяется ко всем "
"компонентам (но только если они не содержат знаки явно). В противном случае "
"действуют традиционные правила <productname>PostgreSQL</productname>. Во "
"избежание неоднозначности рекомендуется добавлять знак к каждому компоненту "
"с отрицательным значением."

#: datatype.xml:2687(para)
msgid ""
"Internally <type>interval</type> values are stored as months, days, and "
"seconds. This is done because the number of days in a month varies, and a "
"day can have 23 or 25 hours if a daylight savings time adjustment is "
"involved. The months and days fields are integers while the seconds field "
"can store fractions. Because intervals are usually created from constant "
"strings or <type>timestamp</type> subtraction, this storage method works "
"well in most cases. Functions <function>justify_days</function> and "
"<function>justify_hours</function> are available for adjusting days and "
"hours that overflow their normal ranges."
msgstr ""
"Тип <type>interval</type> представлен внутри в виде отдельных значений "
"месяцев, дней и секунд. Это объясняется тем, что число дней в месяце может "
"быть разным, а в сутках может быть и 23, и 25 часов в дни перехода на летнее/"
"зимнее время. Значения месяцев и дней представлены целыми числами, а число "
"секунд может быть дробным. Так как интервалы обычно получаются из строковых "
"констант или при вычитании типов <type>timestamp</type>, этот способ "
"хранения эффективен в большинстве случаев. Для корректировки числа дней и "
"часов, когда они выходят за обычные границы, в <productname>PostgreSQL</"
"productname> есть специальные функции <function>justify_days</function> и "
"<function>justify_hours</function>."

#: datatype.xml:2700(para)
msgid ""
"In the verbose input format, and in some fields of the more compact input "
"formats, field values can have fractional parts; for example <literal>'1.5 "
"week'</literal> or <literal>'01:02:03.45'</literal>. Such input is converted "
"to the appropriate number of months, days, and seconds for storage. When "
"this would result in a fractional number of months or days, the fraction is "
"added to the lower-order fields using the conversion factors 1 month = 30 "
"days and 1 day = 24 hours. For example, <literal>'1.5 month'</literal> "
"becomes 1 month and 15 days. Only seconds will ever be shown as fractional "
"on output."
msgstr ""
"В расширенном формате ввода и в некоторых полях более компактных форматов "
"значения компонентов могут иметь дробные части, например <literal>'1.5 "
"week'</literal> или <literal>'01:02:03.45'</literal>. Такое значение при "
"сохранении пересчитывается в соответствующее число месяцев, дней и секунд. "
"Когда при этом остаётся дробная часть в месяцах или в днях, она переносится "
"в младший компонент с допущением, что 1 месяц = 30 дней, а 1 день = 24 часа. "
"Например, значение <literal>'1.5 month'</literal> будет преобразовано в 1 "
"месяц и 15 дней. В виде дробного числа хранятся и выводятся только секунды."

#: datatype.xml:2712(para)
msgid ""
"<xref linkend=\"datatype-interval-input-examples\"/> shows some examples of "
"valid <type>interval</type> input."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-interval-input-examples\"/> показано "
"несколько примеров допустимых вводимых значений типа <type>interval</type>."

#: datatype.xml:2728(entry) datatype.xml:2814(entry)
msgid "1-2"
msgstr "1-2"

#: datatype.xml:2729(entry)
msgid "SQL standard format: 1 year 2 months"
msgstr "Стандартный формат SQL: 1 год и 2 месяца"

#: datatype.xml:2732(entry) datatype.xml:2815(entry)
msgid "3 4:05:06"
msgstr "3 4:05:06"

#: datatype.xml:2733(entry)
msgid "SQL standard format: 3 days 4 hours 5 minutes 6 seconds"
msgstr "Стандартный формат SQL: 3 дня 4 часа 5 минут 6 секунд"

#: datatype.xml:2736(entry)
msgid "1 year 2 months 3 days 4 hours 5 minutes 6 seconds"
msgstr "1 year 2 months 3 days 4 hours 5 minutes 6 seconds"

#: datatype.xml:2737(entry)
msgid ""
"Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 "
"seconds"
msgstr ""
"Традиционный формат Postgres: 1 год 2 месяца 3 дня 4 часа 5 минут 6 секунд"

#: datatype.xml:2740(entry)
msgid "P1Y2M3DT4H5M6S"
msgstr "P1Y2M3DT4H5M6S"

#: datatype.xml:2741(entry)
msgid "ISO 8601 <quote>format with designators</quote>: same meaning as above"
msgstr "<quote>Формат с кодами</quote> ISO 8601: то же значение, что и выше"

#: datatype.xml:2744(entry)
msgid "P0001-02-03T04:05:06"
msgstr "P0001-02-03T04:05:06"

#: datatype.xml:2745(entry)
msgid "ISO 8601 <quote>alternative format</quote>: same meaning as above"
msgstr ""
"<quote>Альтернативный формат</quote> ISO 8601: то же значение, что и выше"

#: datatype.xml:2754(title)
msgid "Interval Output"
msgstr "Вывод интервалов"

#: datatype.xml:2756(indexterm)
msgid ""
"<primary>interval</primary> <secondary>output format</secondary> "
"<seealso>formatting</seealso>"
msgstr ""
"<primary>интервал</primary> <secondary>формат вывода</secondary> "
"<seealso>форматирование</seealso>"

#: datatype.xml:2762(para)
msgid ""
"The output format of the interval type can be set to one of the four styles "
"<literal>sql_standard</literal>, <literal>postgres</literal>, "
"<literal>postgres_verbose</literal>, or <literal>iso_8601</literal>, using "
"the command <literal>SET intervalstyle</literal>. The default is the "
"<literal>postgres</literal> format. <xref linkend=\"interval-style-output-"
"table\"/> shows examples of each output style."
msgstr ""
"Формат вывода типа interval может определяться одним из четырёх стилей: "
"<literal>sql_standard</literal>, <literal>postgres</literal>, "
"<literal>postgres_verbose</literal> и <literal>iso_8601</literal>. Выбрать "
"нужный стиль позволяет команда <literal>SET intervalstyle</literal> (по "
"умолчанию выбран <literal>postgres</literal>). Примеры форматов разных "
"стилей показаны в <xref remap=\"6\" linkend=\"interval-style-output-table\"/"
">."

#: datatype.xml:2772(para)
msgid ""
"The <literal>sql_standard</literal> style produces output that conforms to "
"the SQL standard's specification for interval literal strings, if the "
"interval value meets the standard's restrictions (either year-month only or "
"day-time only, with no mixing of positive and negative components). "
"Otherwise the output looks like a standard year-month literal string "
"followed by a day-time literal string, with explicit signs added to "
"disambiguate mixed-sign intervals."
msgstr ""
"Стиль <literal>sql_standard</literal> выдаёт результат, соответствующий "
"стандарту SQL, если значение интервала удовлетворяет ограничениям стандарта "
"(и содержит либо только год и месяц, либо только день и время, и при этом "
"все его компоненты одного знака). В противном случае выводится год-месяц, за "
"которым идёт дата-время, а в компоненты для однозначности явно добавляются "
"знаки."

#: datatype.xml:2782(para)
msgid ""
"The output of the <literal>postgres</literal> style matches the output of "
"<productname>PostgreSQL</productname> releases prior to 8.4 when the <xref "
"linkend=\"guc-datestyle\"/> parameter was set to <literal>ISO</literal>."
msgstr ""
"Вывод в стиле <literal>postgres</literal> соответствует формату, который был "
"принят в <productname>PostgreSQL</productname> до версии 8.4, когда параметр "
"<xref linkend=\"guc-datestyle\"/> имел значение <literal>ISO</literal>."

#: datatype.xml:2788(para)
msgid ""
"The output of the <literal>postgres_verbose</literal> style matches the "
"output of <productname>PostgreSQL</productname> releases prior to 8.4 when "
"the <varname>DateStyle</varname> parameter was set to non-<literal>ISO</"
"literal> output."
msgstr ""
"Вывод в стиле <literal>postgres_verbose</literal> соответствует формату, "
"который был принят в <productname>PostgreSQL</productname> до версии 8.4, "
"когда значением параметром <varname>DateStyle</varname> было не "
"<literal>ISO</literal>."

#: datatype.xml:2794(para)
msgid ""
"The output of the <literal>iso_8601</literal> style matches the "
"<quote>format with designators</quote> described in section 4.4.3.2 of the "
"ISO 8601 standard."
msgstr ""
"Вывод в стиле <literal>iso_8601</literal> соответствует <quote>формату с "
"кодами</quote> описанному в разделе 4.4.3.2 формата ISO 8601."

#: datatype.xml:2801(title)
msgid "Interval Output Style Examples"
msgstr "Примеры стилей вывода интервалов"

#: datatype.xml:2806(entry)
msgid "Year-Month Interval"
msgstr "Интервал год-месяц"

#: datatype.xml:2807(entry)
msgid "Day-Time Interval"
msgstr "Интервал день-время"

#: datatype.xml:2808(entry)
msgid "Mixed Interval"
msgstr "Смешанный интервал"

#: datatype.xml:2813(literal)
msgid "sql_standard"
msgstr "sql_standard"

#: datatype.xml:2816(entry)
msgid "-1-2 +3 -4:05:06"
msgstr "-1-2 +3 -4:05:06"

#: datatype.xml:2819(literal)
msgid "postgres"
msgstr "postgres"

#: datatype.xml:2820(entry)
msgid "1 year 2 mons"
msgstr "1 year 2 mons"

#: datatype.xml:2821(entry)
msgid "3 days 04:05:06"
msgstr "3 days 04:05:06"

#: datatype.xml:2822(entry)
msgid "-1 year -2 mons +3 days -04:05:06"
msgstr "-1 year -2 mons +3 days -04:05:06"

#: datatype.xml:2825(literal)
msgid "postgres_verbose"
msgstr "postgres_verbose"

#: datatype.xml:2826(entry)
msgid "@ 1 year 2 mons"
msgstr "@ 1 year 2 mons"

#: datatype.xml:2827(entry)
msgid "@ 3 days 4 hours 5 mins 6 secs"
msgstr "@ 3 days 4 hours 5 mins 6 secs"

#: datatype.xml:2828(entry)
msgid "@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago"
msgstr "@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago"

#: datatype.xml:2831(literal)
msgid "iso_8601"
msgstr "iso_8601"

#: datatype.xml:2832(entry)
msgid "P1Y2M"
msgstr "P1Y2M"

#: datatype.xml:2833(entry)
msgid "P3DT4H5M6S"
msgstr "P3DT4H5M6S"

#: datatype.xml:2834(entry)
msgid "P-1Y-2M3DT-4H-5M-6S"
msgstr "P-1Y-2M3DT-4H-5M-6S"

#: datatype.xml:2845(title)
msgid "Boolean Type"
msgstr "Логический тип"

#: datatype.xml:2847(indexterm)
msgid "<primary>Boolean</primary> <secondary>data type</secondary>"
msgstr "<primary>логический</primary> <secondary>тип данных</secondary>"

#: datatype.xml:2852(indexterm)
msgid "<primary>true</primary>"
msgstr "<primary>true</primary>"

#: datatype.xml:2856(indexterm)
msgid "<primary>false</primary>"
msgstr "<primary>false</primary>"

#: datatype.xml:2860(para)
msgid ""
"<productname>PostgreSQL</productname> provides the standard <acronym>SQL</"
"acronym> type <type>boolean</type>; see <xref linkend=\"datatype-boolean-"
"table\"/>. The <type>boolean</type> type can have several states: "
"<quote>true</quote>, <quote>false</quote>, and a third state, "
"<quote>unknown</quote>, which is represented by the <acronym>SQL</acronym> "
"null value."
msgstr ""
"В <productname>PostgreSQL</productname> есть стандартный <acronym>SQL</"
"acronym>-тип <type>boolean</type>; см. <xref remap=\"4\" linkend=\"datatype-"
"boolean-table\"/>. Тип <type>boolean</type> может иметь следующие состояния: "
"<quote>true</quote>, <quote>false</quote> и третье состояние, "
"<quote>unknown</quote>, которое представляется <acronym>SQL</acronym>-"
"значением NULL."

#: datatype.xml:2871(title)
msgid "Boolean Data Type"
msgstr "Логический тип данных"

#: datatype.xml:2884(entry)
msgid "state of true or false"
msgstr "состояние: истина или ложь"

#: datatype.xml:2893(literal)
msgid "TRUE"
msgstr "TRUE"

#: datatype.xml:2894(literal)
msgid "'t'"
msgstr "'t'"

#: datatype.xml:2895(literal)
msgid "'true'"
msgstr "'true'"

#: datatype.xml:2896(literal)
msgid "'y'"
msgstr "'y'"

#: datatype.xml:2897(literal)
msgid "'yes'"
msgstr "'yes'"

#: datatype.xml:2898(literal)
msgid "'on'"
msgstr "'on'"

#: datatype.xml:2899(literal)
msgid "'1'"
msgstr "'1'"

#: datatype.xml:2904(literal)
msgid "FALSE"
msgstr "FALSE"

#: datatype.xml:2905(literal)
msgid "'f'"
msgstr "'f'"

#: datatype.xml:2906(literal)
msgid "'false'"
msgstr "'false'"

#: datatype.xml:2907(literal)
msgid "'n'"
msgstr "'n'"

#: datatype.xml:2908(literal)
msgid "'no'"
msgstr "'no'"

#: datatype.xml:2909(literal)
msgid "'off'"
msgstr "'off'"

#: datatype.xml:2910(literal)
msgid "'0'"
msgstr "'0'"

#: datatype.xml:2890(para)
msgid ""
"Valid literal values for the <quote>true</quote> state are: <placeholder-1/> "
"For the <quote>false</quote> state, the following values can be used: "
"<placeholder-2/> Leading or trailing whitespace is ignored, and case does "
"not matter. The key words <literal>TRUE</literal> and <literal>FALSE</"
"literal> are the preferred (<acronym>SQL</acronym>-compliant) usage."
msgstr ""
"Состояние <quote>true</quote> может задаваться следующими значениями: "
"<placeholder-1/> Для состояния <quote>false</quote> можно использовать "
"следующие варианты: <placeholder-2/> При этом пробелы в начале и конце "
"строки игнорируются, и регистр так же не имеет значения. Предпочтительными "
"(совместимыми с <acronym>SQL</acronym>) являются варианты <literal>TRUE</"
"literal> и <literal>FALSE</literal>."

#: datatype.xml:2918(para)
msgid ""
"<xref linkend=\"datatype-boolean-example\"/> shows that <type>boolean</type> "
"values are output using the letters <literal>t</literal> and <literal>f</"
"literal>."
msgstr ""
"<xref linkend=\"datatype-boolean-example\"/> показывает, что значения типа "
"<type>boolean</type> при выводе представляются буквами <literal>t</literal> "
"и <literal>f</literal>."

#: datatype.xml:2925(title)
msgid "Using the <type>boolean</type> Type"
msgstr "Использование типа <type>boolean</type>"

#: datatype.xml:2927(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test1 (a boolean, b text);\n"
"INSERT INTO test1 VALUES (TRUE, 'sic est');\n"
"INSERT INTO test1 VALUES (FALSE, 'non est');\n"
"SELECT * FROM test1;\n"
" a |    b\n"
"---+---------\n"
" t | sic est\n"
" f | non est\n"
"\n"
"SELECT * FROM test1 WHERE a;\n"
" a |    b\n"
"---+---------\n"
" t | sic est"
msgstr ""
"CREATE TABLE test1 (a boolean, b text);\n"
"INSERT INTO test1 VALUES (TRUE, 'sic est');\n"
"INSERT INTO test1 VALUES (FALSE, 'non est');\n"
"SELECT * FROM test1;\n"
" a |    b\n"
"---+---------\n"
" t | sic est\n"
" f | non est\n"
"\n"
"SELECT * FROM test1 WHERE a;\n"
" a |    b\n"
"---+---------\n"
" t | sic est"

#: datatype.xml:2946(title)
msgid "Enumerated Types"
msgstr "Типы перечислений"

#: datatype.xml:2948(indexterm)
msgid "<primary>data type</primary> <secondary>enumerated (enum)</secondary>"
msgstr ""
"<primary>тип данных</primary> <secondary>перечисление (enum)</secondary>"

#: datatype.xml:2953(indexterm)
msgid "<primary>enumerated types</primary>"
msgstr "<primary>типы перечислений</primary>"

#: datatype.xml:2957(para)
msgid ""
"Enumerated (enum) types are data types that comprise a static, ordered set "
"of values. They are equivalent to the <type>enum</type> types supported in a "
"number of programming languages. An example of an enum type might be the "
"days of the week, or a set of status values for a piece of data."
msgstr ""
"Типы перечислений (enum) определяют статический упорядоченный набор "
"значений, так же как и типы <type>enum</type>, существующие в ряде языков "
"программирования. В качестве перечисления можно привести дни недели или "
"набор состояний."

#: datatype.xml:2967(title)
msgid "Declaration of Enumerated Types"
msgstr "Объявление перечислений"

#: datatype.xml:2974(programlisting)
#, no-wrap
msgid "CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');"
msgstr "CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');"

#: datatype.xml:2980(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');\n"
"CREATE TABLE person (\n"
"    name text,\n"
"    current_mood mood\n"
");\n"
"INSERT INTO person VALUES ('Moe', 'happy');\n"
"SELECT * FROM person WHERE current_mood = 'happy';\n"
" name | current_mood \n"
"------+--------------\n"
" Moe  | happy\n"
"(1 row)"
msgstr ""
"CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');\n"
"CREATE TABLE person (\n"
"    name text,\n"
"    current_mood mood\n"
");\n"
"INSERT INTO person VALUES ('Moe', 'happy');\n"
"SELECT * FROM person WHERE current_mood = 'happy';\n"
" name | current_mood \n"
"------+--------------\n"
" Moe  | happy\n"
"(1 row)"

#: datatype.xml:2969(para)
msgid ""
"Enum types are created using the <xref linkend=\"sql-createtype\"/> command, "
"for example: <placeholder-1/> Once created, the enum type can be used in "
"table and function definitions much like any other type: <placeholder-2/>"
msgstr ""
"Тип перечислений создаются с помощью команды <xref linkend=\"sql-createtype"
"\"/>, например так: <placeholder-1/> Созданные типы enum можно использовать "
"в определениях таблиц и функций, как и любые другие: <placeholder-2/>"

#: datatype.xml:2997(title)
msgid "Ordering"
msgstr "Порядок"

#: datatype.xml:3005(programlisting)
#, no-wrap
msgid ""
"INSERT INTO person VALUES ('Larry', 'sad');\n"
"INSERT INTO person VALUES ('Curly', 'ok');\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad';\n"
" name  | current_mood \n"
"-------+--------------\n"
" Moe   | happy\n"
" Curly | ok\n"
"(2 rows)\n"
"\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad' ORDER BY current_mood;\n"
" name  | current_mood \n"
"-------+--------------\n"
" Curly | ok\n"
" Moe   | happy\n"
"(2 rows)\n"
"\n"
"SELECT name\n"
"FROM person\n"
"WHERE current_mood = (SELECT MIN(current_mood) FROM person);\n"
" name  \n"
"-------\n"
" Larry\n"
"(1 row)"
msgstr ""
"INSERT INTO person VALUES ('Larry', 'sad');\n"
"INSERT INTO person VALUES ('Curly', 'ok');\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad';\n"
" name  | current_mood \n"
"-------+--------------\n"
" Moe   | happy\n"
" Curly | ok\n"
"(2 rows)\n"
"\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad' ORDER BY current_mood;\n"
" name  | current_mood \n"
"-------+--------------\n"
" Curly | ok\n"
" Moe   | happy\n"
"(2 rows)\n"
"\n"
"SELECT name\n"
"FROM person\n"
"WHERE current_mood = (SELECT MIN(current_mood) FROM person);\n"
" name  \n"
"-------\n"
" Larry\n"
"(1 row)"

#: datatype.xml:2999(para)
msgid ""
"The ordering of the values in an enum type is the order in which the values "
"were listed when the type was created. All standard comparison operators and "
"related aggregate functions are supported for enums. For example: "
"<placeholder-1/>"
msgstr ""
"Порядок значений в перечислении определяется последовательностью, в которой "
"были указаны значения при создании типа. Перечисления поддерживаются всеми "
"стандартными операторами сравнения и связанными агрегатными функциями. "
"Например: <placeholder-1/>"

#: datatype.xml:3034(title)
msgid "Type Safety"
msgstr "Безопасность типа"

#: datatype.xml:3040(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');\n"
"CREATE TABLE holidays (\n"
"    num_weeks integer,\n"
"    happiness happiness\n"
");\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');\n"
"ERROR:  invalid input value for enum happiness: \"sad\"\n"
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood = holidays.happiness;\n"
"ERROR:  operator does not exist: mood = happiness"
msgstr ""
"CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');\n"
"CREATE TABLE holidays (\n"
"    num_weeks integer,\n"
"    happiness happiness\n"
");\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');\n"
"ОШИБКА:  неверное значение для перечисления happiness: \"sad\"\n"
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood = holidays.happiness;\n"
"ОШИБКА:  оператор не существует: mood = happiness"

#: datatype.xml:3036(para)
msgid ""
"Each enumerated data type is separate and cannot be compared with other "
"enumerated types. See this example: <placeholder-1/>"
msgstr ""
"Все типы перечислений считаются уникальными и поэтому значения разных типов "
"нельзя сравнивать. Взгляните на этот пример: <placeholder-1/>"

#: datatype.xml:3061(programlisting)
#, no-wrap
msgid ""
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood::text = holidays.happiness::text;\n"
" name | num_weeks \n"
"------+-----------\n"
" Moe  |         4\n"
"(1 row)"
msgstr ""
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood::text = holidays.happiness::text;\n"
" name | num_weeks \n"
"------+-----------\n"
" Moe  |         4\n"
"(1 row)"

#: datatype.xml:3057(para)
msgid ""
"If you really need to do something like that, you can either write a custom "
"operator or add explicit casts to your query: <placeholder-1/>"
msgstr ""
"Если вам действительно нужно сделать что-то подобное, вы можете либо "
"реализовать собственный оператор, либо явно преобразовать типы в запросе: "
"<placeholder-1/>"

#: datatype.xml:3074(title)
msgid "Implementation Details"
msgstr "Тонкости реализации"

#: datatype.xml:3076(para)
msgid ""
"An enum value occupies four bytes on disk. The length of an enum value's "
"textual label is limited by the <symbol>NAMEDATALEN</symbol> setting "
"compiled into <productname>PostgreSQL</productname>; in standard builds this "
"means at most 63 bytes."
msgstr ""
"Значение enum занимает на диске 4 байта. Длина текстовой метки значения "
"ограничена параметром компиляции <symbol>NAMEDATALEN</symbol>; в стандартных "
"сборках <productname>PostgreSQL</productname> он ограничивает длину 63 "
"байтами."

#: datatype.xml:3083(para)
msgid ""
"Enum labels are case sensitive, so <type>'happy'</type> is not the same as "
"<type>'HAPPY'</type>. White space in the labels is significant too."
msgstr ""
"В метках значений регистр имеет значение, т. е. <type>'happy'</type> и "
"<type>'HAPPY'</type> &mdash; не одно и то же. Также в метках имеют значение "
"пробелы."

#: datatype.xml:3089(para)
msgid ""
"The translations from internal enum values to textual labels are kept in the "
"system catalog <link linkend=\"catalog-pg-enum\"><structname>pg_enum</"
"structname></link>. Querying this catalog directly can be useful."
msgstr ""
"Сопоставления внутренних значений enum с текстовыми метками хранятся в "
"системном каталоге <link linkend=\"catalog-pg-enum\"><structname>pg_enum</"
"structname></link>. Он может быть полезен в ряде случаев."

#: datatype.xml:3100(title) datatype.xml:3109(title)
msgid "Geometric Types"
msgstr "Геометрические типы"

#: datatype.xml:3102(para)
msgid ""
"Geometric data types represent two-dimensional spatial objects. <xref "
"linkend=\"datatype-geo-table\"/> shows the geometric types available in "
"<productname>PostgreSQL</productname>."
msgstr ""
"Геометрические типы данных представляют объекты в двумерном пространстве. "
"Все существующие в <productname>PostgreSQL</productname> геометрические типы "
"перечислены в <xref remap=\"6\" linkend=\"datatype-geo-table\"/>."

#: datatype.xml:3116(entry)
msgid "Representation"
msgstr "Представление"

#: datatype.xml:3123(entry)
msgid "Point on a plane"
msgstr "Точка на плоскости"

#: datatype.xml:3124(entry)
msgid "(x,y)"
msgstr "(x,y)"

#: datatype.xml:3128(entry) datatype.xml:3134(entry) datatype.xml:3140(entry)
msgid "32 bytes"
msgstr "32 байта"

#: datatype.xml:3129(entry)
msgid "Infinite line"
msgstr "Бесконечная прямая"

#: datatype.xml:3130(entry)
msgid "{A,B,C}"
msgstr "{A,B,C}"

#: datatype.xml:3135(entry)
msgid "Finite line segment"
msgstr "Отрезок"

#: datatype.xml:3136(entry) datatype.xml:3142(entry)
msgid "((x1,y1),(x2,y2))"
msgstr "((x1,y1),(x2,y2))"

#: datatype.xml:3141(entry)
msgid "Rectangular box"
msgstr "Прямоугольник"

#: datatype.xml:3146(entry) datatype.xml:3152(entry)
msgid "16+16n bytes"
msgstr "16+16n байт"

#: datatype.xml:3147(entry)
msgid "Closed path (similar to polygon)"
msgstr "Закрытый путь (подобный многоугольнику)"

#: datatype.xml:3148(entry) datatype.xml:3160(entry)
msgid "((x1,y1),...)"
msgstr "((x1,y1),...)"

#: datatype.xml:3153(entry)
msgid "Open path"
msgstr "Открытый путь"

#: datatype.xml:3154(entry)
msgid "[(x1,y1),...]"
msgstr "[(x1,y1),...]"

#: datatype.xml:3158(entry)
msgid "40+16n bytes"
msgstr "40+16n байт"

#: datatype.xml:3159(entry)
msgid "Polygon (similar to closed path)"
msgstr "Многоугольник (подобный закрытому пути)"

#: datatype.xml:3164(entry)
msgid "24 bytes"
msgstr "24 байта"

#: datatype.xml:3165(entry)
msgid "Circle"
msgstr "Окружность"

#: datatype.xml:3166(entry)
msgid "&lt;(x,y),r&gt; (center point and radius)"
msgstr "&lt;(x,y),r&gt; (центр окружности и радиус)"

#: datatype.xml:3172(para)
msgid ""
"A rich set of functions and operators is available to perform various "
"geometric operations such as scaling, translation, rotation, and determining "
"intersections. They are explained in <xref linkend=\"functions-geometry\"/>."
msgstr ""
"Для выполнения различных геометрических операций, в частности "
"масштабирования, вращения и определения пересечений, "
"<productname>PostgreSQL</productname> предлагает богатый набор функций и "
"операторов. Они рассматриваются в <xref remap=\"6\" linkend=\"functions-"
"geometry\"/>."

#: datatype.xml:3179(title)
msgid "Points"
msgstr "Точки"

#: datatype.xml:3181(indexterm)
msgid "<primary>point</primary>"
msgstr "<primary>точка</primary>"

#: datatype.xml:3185(para)
msgid ""
"Points are the fundamental two-dimensional building block for geometric "
"types. Values of type <type>point</type> are specified using either of the "
"following syntaxes: <synopsis>\n"
"( <replaceable>x</replaceable> , <replaceable>y</replaceable> )\n"
"  <replaceable>x</replaceable> , <replaceable>y</replaceable>\n"
"</synopsis> where <replaceable>x</replaceable> and <replaceable>y</"
"replaceable> are the respective coordinates, as floating-point numbers."
msgstr ""
"Точки &mdash; это основной элемент, на базе которого строятся все остальные "
"геометрические типы. Значения типа <type>point</type> записываются в одном "
"из двух форматов: <synopsis>\n"
"( <replaceable>x</replaceable> , <replaceable>y</replaceable> )\n"
"  <replaceable>x</replaceable> , <replaceable>y</replaceable>\n"
"</synopsis> где <replaceable>x</replaceable> и <replaceable>y</replaceable> "
"&mdash; координаты точки на плоскости, выраженные числами с плавающей точкой."

#: datatype.xml:3199(para)
msgid "Points are output using the first syntax."
msgstr "Выводятся точки в первом формате."

#: datatype.xml:3205(title)
msgid "Lines"
msgstr "Прямые"

#: datatype.xml:3207(indexterm)
msgid "<primary>line</primary>"
msgstr "<primary>прямая</primary>"

#: datatype.xml:3211(para)
msgid ""
"Lines are represented by the linear equation <replaceable>A</replaceable>x + "
"<replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0, where "
"<replaceable>A</replaceable> and <replaceable>B</replaceable> are not both "
"zero. Values of type <type>line</type> are input and output in the following "
"form: <synopsis>\n"
"{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, "
"<replaceable>C</replaceable> }\n"
"</synopsis> Alternatively, any of the following forms can be used for input: "
"<synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> and <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> are two different points on the "
"line."
msgstr ""
"Прямые представляются линейным уравнением <replaceable>A</replaceable>x + "
"<replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0, где "
"<replaceable>A</replaceable> и <replaceable>B</replaceable> не равны 0. "
"Значения типа <type>line</type> вводятся и выводятся в следующем виде: "
"<synopsis>\n"
"{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, "
"<replaceable>C</replaceable> }\n"
"</synopsis> Кроме того, для ввода может использоваться любая из этих форм: "
"<synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> &mdash; две различные точки на "
"данной прямой."

#: datatype.xml:3238(title)
msgid "Line Segments"
msgstr "Отрезки"

#: datatype.xml:3240(indexterm)
msgid "<primary>lseg</primary>"
msgstr "<primary>lseg</primary>"

#: datatype.xml:3244(indexterm)
msgid "<primary>line segment</primary>"
msgstr "<primary>отрезок</primary>"

#: datatype.xml:3248(para)
msgid ""
"Line segments are represented by pairs of points that are the endpoints of "
"the segment. Values of type <type>lseg</type> are specified using any of the "
"following syntaxes: <synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> and <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> are the end points of the line "
"segment."
msgstr ""
"Отрезок представляется парой точек, определяющих концы отрезка. Значения "
"типа <type>lseg</type> записываются в одной из следующих форм: <synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> &mdash; концы отрезка."

#: datatype.xml:3267(para)
msgid "Line segments are output using the first syntax."
msgstr "Выводятся отрезки в первом формате."

#: datatype.xml:3273(title)
msgid "Boxes"
msgstr "Прямоугольники"

#: datatype.xml:3275(indexterm)
msgid "<primary>box (data type)</primary>"
msgstr "<primary>box (тип данных)</primary>"

#: datatype.xml:3279(indexterm)
msgid "<primary>rectangle</primary>"
msgstr "<primary>прямоугольник</primary>"

#: datatype.xml:3283(para)
msgid ""
"Boxes are represented by pairs of points that are opposite corners of the "
"box. Values of type <type>box</type> are specified using any of the "
"following syntaxes: <synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> and <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> are any two opposite corners of the "
"box."
msgstr ""
"Прямоугольник представляется двумя точками, находящимися в противоположных "
"его углах. Значения типа <type>box</type> записываются в одной из следующих "
"форм: <synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> &mdash; противоположные углы "
"прямоугольника."

#: datatype.xml:3302(para)
msgid "Boxes are output using the second syntax."
msgstr "Выводятся прямоугольники во второй форме."

#: datatype.xml:3306(para)
msgid ""
"Any two opposite corners can be supplied on input, but the values will be "
"reordered as needed to store the upper right and lower left corners, in that "
"order."
msgstr ""
"Во вводимом значении могут быть указаны любые два противоположных угла, но "
"затем они будут упорядочены, так что внутри сохранятся правый верхний и "
"левый нижний углы, в таком порядке."

#: datatype.xml:3314(title)
msgid "Paths"
msgstr "Пути"

#: datatype.xml:3316(indexterm)
msgid "<primary>path (data type)</primary>"
msgstr "<primary>path (тип данных)</primary>"

#: datatype.xml:3320(para)
msgid ""
"Paths are represented by lists of connected points. Paths can be "
"<firstterm>open</firstterm>, where the first and last points in the list are "
"considered not connected, or <firstterm>closed</firstterm>, where the first "
"and last points are considered connected."
msgstr ""
"Пути представляют собой списки соединённых точек. Пути могут быть "
"<firstterm>закрытыми</firstterm>, когда подразумевается, что первая и "
"последняя точка в списке соединены, или <firstterm>открытыми</firstterm>, в "
"противном случае."

#: datatype.xml:3328(para)
msgid ""
"Values of type <type>path</type> are specified using any of the following "
"syntaxes: <synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> where the points are the end points of the line segments "
"comprising the path. Square brackets (<literal>[]</literal>) indicate an "
"open path, while parentheses (<literal>()</literal>) indicate a closed path. "
"When the outermost parentheses are omitted, as in the third through fifth "
"syntaxes, a closed path is assumed."
msgstr ""
"Значения типа <type>path</type> записываются в одной из следующих форм: "
"<synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> где точки задают узлы сегментов, составляющих путь. Квадратные "
"скобки (<literal>[]</literal>) указывают, что путь открытый, а круглые "
"(<literal>()</literal>) &mdash; закрытый. Когда внешние скобки опускаются, "
"как в показанных выше последних трёх формах, считается, что путь закрытый."

#: datatype.xml:3347(para)
msgid "Paths are output using the first or second syntax, as appropriate."
msgstr "Пути выводятся в первой или второй форме, в соответствии с типом."

#: datatype.xml:3353(title)
msgid "Polygons"
msgstr "Многоугольники"

#: datatype.xml:3355(indexterm)
msgid "<primary>polygon</primary>"
msgstr "<primary>многоугольник</primary>"

#: datatype.xml:3359(para)
msgid ""
"Polygons are represented by lists of points (the vertexes of the polygon). "
"Polygons are very similar to closed paths, but are stored differently and "
"have their own set of support routines."
msgstr ""
"Многоугольники представляются списками точек (вершин). Многоугольники похожи "
"на закрытые пути, но хранятся в другом виде и для работы с ними предназначен "
"отдельный набор функций."

#: datatype.xml:3365(para)
msgid ""
"Values of type <type>polygon</type> are specified using any of the following "
"syntaxes: <synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> where the points are the end points of the line segments "
"comprising the boundary of the polygon."
msgstr ""
"Значения типа <type>polygon</type> записываются в одной из следующих форм: "
"<synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> где точки задают узлы сегментов, образующих границу "
"многоугольника."

#: datatype.xml:3380(para)
msgid "Polygons are output using the first syntax."
msgstr "Выводятся многоугольники в первом формате."

#: datatype.xml:3386(title)
msgid "Circles"
msgstr "Окружности"

#: datatype.xml:3388(indexterm)
msgid "<primary>circle</primary>"
msgstr "<primary>круг</primary>"

#: datatype.xml:3392(para)
msgid ""
"Circles are represented by a center point and radius. Values of type "
"<type>circle</type> are specified using any of the following syntaxes: "
"<synopsis>\n"
"&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> &gt;\n"
"( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> )\n"
"  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable>\n"
"    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , "
"<replaceable>r</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x</replaceable>,<replaceable>y</"
"replaceable>)</literal> is the center point and <replaceable>r</replaceable> "
"is the radius of the circle."
msgstr ""
"Окружности задаются координатами центра и радиусом. Значения типа "
"<type>circle</type> записываются в одном из следующих форматов: <synopsis>\n"
"&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> &gt;\n"
"( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> )\n"
"  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable>\n"
"    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , "
"<replaceable>r</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x</replaceable>,<replaceable>y</"
"replaceable>)</literal> &mdash; центр окружности, а <replaceable>r</"
"replaceable> &mdash; её радиус."

#: datatype.xml:3410(para)
msgid "Circles are output using the first syntax."
msgstr "Выводятся окружности в первом формате."

#: datatype.xml:3418(title) datatype.xml:3435(title)
msgid "Network Address Types"
msgstr "Типы, описывающие сетевые адреса"

#: datatype.xml:3420(indexterm)
msgid "<primary>network</primary> <secondary>data types</secondary>"
msgstr "<primary>сетевые адреса</primary> <secondary>типы данных</secondary>"

#: datatype.xml:3425(para)
msgid ""
"<productname>PostgreSQL</productname> offers data types to store IPv4, IPv6, "
"and MAC addresses, as shown in <xref linkend=\"datatype-net-types-table\"/>. "
"It is better to use these types instead of plain text types to store network "
"addresses, because these types offer input error checking and specialized "
"operators and functions (see <xref linkend=\"functions-net\"/>)."
msgstr ""
"<productname>PostgreSQL</productname> предлагает типы данных для хранения "
"адресов IPv4, IPv6 и MAC, показанные в <xref remap=\"6\" linkend=\"datatype-"
"net-types-table\"/>. Для хранения сетевых адресов лучше использовать эти "
"типы, а не простые текстовые строки, так как <productname>PostgreSQL</"
"productname> проверяет вводимые значения данных типов и предоставляет "
"специализированные операторы и функции для работы с ними (см. <xref remap="
"\"4\" linkend=\"functions-net\"/>)."

#: datatype.xml:3448(entry) datatype.xml:3454(entry)
msgid "7 or 19 bytes"
msgstr "7 или 19 байт"

#: datatype.xml:3449(entry)
msgid "IPv4 and IPv6 networks"
msgstr "Сети IPv4 и IPv6"

#: datatype.xml:3455(entry)
msgid "IPv4 and IPv6 hosts and networks"
msgstr "Узлы и сети IPv4 и IPv6"

#: datatype.xml:3460(entry)
msgid "6 bytes"
msgstr "6 байт"

#: datatype.xml:3461(entry)
msgid "MAC addresses"
msgstr "MAC-адреса"

#: datatype.xml:3468(para)
msgid ""
"When sorting <type>inet</type> or <type>cidr</type> data types, IPv4 "
"addresses will always sort before IPv6 addresses, including IPv4 addresses "
"encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::"
"ffff:10.4.3.2."
msgstr ""
"При сортировке типов <type>inet</type> и <type>cidr</type>, адреса IPv4 "
"всегда идут до адресов IPv6, в том числе адреса IPv4, включённые в IPv6 или "
"сопоставленные с ними, например ::10.2.3.4 или ::ffff:10.4.3.2."

#: datatype.xml:3479(indexterm)
msgid "<primary>inet (data type)</primary>"
msgstr "<primary>inet (тип данных)</primary>"

#: datatype.xml:3483(para)
msgid ""
"The <type>inet</type> type holds an IPv4 or IPv6 host address, and "
"optionally its subnet, all in one field. The subnet is represented by the "
"number of network address bits present in the host address (the "
"<quote>netmask</quote>). If the netmask is 32 and the address is IPv4, then "
"the value does not indicate a subnet, only a single host. In IPv6, the "
"address length is 128 bits, so 128 bits specify a unique host address. Note "
"that if you want to accept only networks, you should use the <type>cidr</"
"type> type rather than <type>inet</type>."
msgstr ""
"Тип <type>inet</type> содержит IPv4- или IPv6-адрес узла и может также "
"содержать его подсеть, всё в одном поле. Подсеть представляется числом бит, "
"определяющих адрес сети в адресе узла (или <quote>маску сети</quote>). Если "
"маска сети равна 32 для адреса IPv4, такое значение представляет не подсеть, "
"а определённый узел. Адреса IPv6 имеют длину 128 бит, поэтому уникальный "
"адрес узла задаётся с маской 128 бит. Заметьте, что когда нужно, чтобы "
"принимались только адреса сетей, следует использовать тип <type>cidr</type>, "
"а не <type>inet</type>."

#: datatype.xml:3496(para)
msgid ""
"The input format for this type is <replaceable class=\"parameter\">address/"
"y</replaceable> where <replaceable class=\"parameter\">address</replaceable> "
"is an IPv4 or IPv6 address and <replaceable class=\"parameter\">y</"
"replaceable> is the number of bits in the netmask. If the <replaceable class="
"\"parameter\">/y</replaceable> portion is missing, the netmask is 32 for "
"IPv4 and 128 for IPv6, so the value represents just a single host. On "
"display, the <replaceable class=\"parameter\">/y</replaceable> portion is "
"suppressed if the netmask specifies a single host."
msgstr ""
"Вводимые значения такого типа должны иметь формат <replaceable class="
"\"parameter\">IP-адрес/y</replaceable>, где <replaceable class=\"parameter"
"\">IP-адрес</replaceable> &mdash; адрес IPv4 или IPv6, а <replaceable class="
"\"parameter\">y</replaceable> &mdash; число бит в маске сети. Если компонент "
"<replaceable class=\"parameter\">/y</replaceable> отсутствует, маска сети "
"считается равной 32 для IPv4 и 128 для IPv6, так что это значение будет "
"представлять один узел. При выводе компонент <replaceable class=\"parameter"
"\">/y</replaceable> опускается, если сетевой адрес определяет адрес одного "
"узла."

#: datatype.xml:3516(indexterm)
msgid "<primary>cidr</primary>"
msgstr "<primary>cidr</primary>"

#: datatype.xml:3520(para)
msgid ""
"The <type>cidr</type> type holds an IPv4 or IPv6 network specification. "
"Input and output formats follow Classless Internet Domain Routing "
"conventions. The format for specifying networks is <replaceable class="
"\"parameter\">address/y</replaceable> where <replaceable class=\"parameter"
"\">address</replaceable> is the network represented as an IPv4 or IPv6 "
"address, and <replaceable class=\"parameter\">y</replaceable> is the number "
"of bits in the netmask. If <replaceable class=\"parameter\">y</replaceable> "
"is omitted, it is calculated using assumptions from the older classful "
"network numbering system, except it will be at least large enough to include "
"all of the octets written in the input. It is an error to specify a network "
"address that has bits set to the right of the specified netmask."
msgstr ""
"Тип <type>cidr</type> содержит определение сети IPv4 или IPv6. Входные и "
"выходные форматы соответствуют соглашениям CIDR (Classless Internet Domain "
"Routing, Бесклассовая межсетевая адресация). Определение сети записывается в "
"формате <replaceable class=\"parameter\">IP-адрес/y</replaceable>, где "
"<replaceable class=\"parameter\">IP-адрес</replaceable> &mdash; адрес сети "
"IPv4 или IPv6, а <replaceable class=\"parameter\">y</replaceable> &mdash; "
"число бит в маске сети. Если <replaceable class=\"parameter\">y</"
"replaceable> не указывается, это значение вычисляется по старой классовой "
"схеме нумерации сетей, но при этом оно может быть увеличено, чтобы в него "
"вошли все байты введённого адреса. Если в сетевом адресе справа от маски "
"сети окажутся биты со значением 1, он будет считаться ошибочным."

#: datatype.xml:3536(para)
msgid "<xref linkend=\"datatype-net-cidr-table\"/> shows some examples."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-net-cidr-table\"/> показаны несколько "
"примеров адресов."

#: datatype.xml:3541(title)
msgid "<type>cidr</type> Type Input Examples"
msgstr "Примеры допустимых значений типа <type>cidr</type>"

#: datatype.xml:3545(entry)
msgid "<type>cidr</type> Input"
msgstr "Вводимое значение <type>cidr</type>"

#: datatype.xml:3546(entry)
msgid "<type>cidr</type> Output"
msgstr "Выводимое значение <type>cidr</type>"

#: datatype.xml:3547(function)
msgid "abbrev(<placeholder-1/>)"
msgstr "abbrev(<placeholder-1/>)"

#: datatype.xml:3552(entry) datatype.xml:3553(entry) datatype.xml:3554(entry)
msgid "192.168.100.128/25"
msgstr "192.168.100.128/25"

#: datatype.xml:3557(entry)
msgid "192.168/24"
msgstr "192.168/24"

#: datatype.xml:3558(entry) datatype.xml:3573(entry)
msgid "192.168.0.0/24"
msgstr "192.168.0.0/24"

#: datatype.xml:3559(entry) datatype.xml:3574(entry)
msgid "192.168.0/24"
msgstr "192.168.0/24"

#: datatype.xml:3562(entry)
msgid "192.168/25"
msgstr "192.168/25"

#: datatype.xml:3563(entry) datatype.xml:3564(entry)
msgid "192.168.0.0/25"
msgstr "192.168.0.0/25"

#: datatype.xml:3567(entry)
msgid "192.168.1"
msgstr "192.168.1"

#: datatype.xml:3568(entry)
msgid "192.168.1.0/24"
msgstr "192.168.1.0/24"

#: datatype.xml:3569(entry)
msgid "192.168.1/24"
msgstr "192.168.1/24"

#: datatype.xml:3572(entry)
msgid "192.168"
msgstr "192.168"

#: datatype.xml:3577(entry)
msgid "128.1"
msgstr "128.1"

#: datatype.xml:3578(entry)
msgid "128.1.0.0/16"
msgstr "128.1.0.0/16"

#: datatype.xml:3579(entry)
msgid "128.1/16"
msgstr "128.1/16"

#: datatype.xml:3582(entry)
msgid "128"
msgstr "128"

#: datatype.xml:3583(entry)
msgid "128.0.0.0/16"
msgstr "128.0.0.0/16"

#: datatype.xml:3584(entry)
msgid "128.0/16"
msgstr "128.0/16"

#: datatype.xml:3587(entry)
msgid "128.1.2"
msgstr "128.1.2"

#: datatype.xml:3588(entry)
msgid "128.1.2.0/24"
msgstr "128.1.2.0/24"

#: datatype.xml:3589(entry)
msgid "128.1.2/24"
msgstr "128.1.2/24"

#: datatype.xml:3592(entry)
msgid "10.1.2"
msgstr "10.1.2"

#: datatype.xml:3593(entry)
msgid "10.1.2.0/24"
msgstr "10.1.2.0/24"

#: datatype.xml:3594(entry)
msgid "10.1.2/24"
msgstr "10.1.2/24"

#: datatype.xml:3597(entry)
msgid "10.1"
msgstr "10.1"

#: datatype.xml:3598(entry)
msgid "10.1.0.0/16"
msgstr "10.1.0.0/16"

#: datatype.xml:3599(entry)
msgid "10.1/16"
msgstr "10.1/16"

#: datatype.xml:3602(entry)
msgid "10"
msgstr "10"

#: datatype.xml:3603(entry)
msgid "10.0.0.0/8"
msgstr "10.0.0.0/8"

#: datatype.xml:3604(entry)
msgid "10/8"
msgstr "10/8"

#: datatype.xml:3607(entry) datatype.xml:3608(entry) datatype.xml:3609(entry)
msgid "10.1.2.3/32"
msgstr "10.1.2.3/32"

#: datatype.xml:3612(entry) datatype.xml:3613(entry) datatype.xml:3614(entry)
msgid "2001:4f8:3:ba::/64"
msgstr "2001:4f8:3:ba::/64"

#: datatype.xml:3617(entry) datatype.xml:3618(entry)
msgid "2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128"
msgstr "2001:4f8:3:ba:2e0:81ff:fe22:&zwsp;d1f1/128"

#: datatype.xml:3619(entry)
msgid "2001:4f8:3:ba:2e0:81ff:fe22:d1f1"
msgstr "2001:4f8:3:ba:2e0:81ff:fe22:&zwsp;d1f1"

#: datatype.xml:3622(entry) datatype.xml:3623(entry)
msgid "::ffff:1.2.3.0/120"
msgstr "::ffff:1.2.3.0/120"

#: datatype.xml:3624(entry)
msgid "::ffff:1.2.3/120"
msgstr "::ffff:1.2.3/120"

#: datatype.xml:3627(entry) datatype.xml:3628(entry) datatype.xml:3629(entry)
msgid "::ffff:1.2.3.0/128"
msgstr "::ffff:1.2.3.0/128"

#: datatype.xml:3637(title)
msgid "<type>inet</type> vs. <type>cidr</type>"
msgstr "Различия <type>inet</type> и <type>cidr</type>"

#: datatype.xml:3639(para)
msgid ""
"The essential difference between <type>inet</type> and <type>cidr</type> "
"data types is that <type>inet</type> accepts values with nonzero bits to the "
"right of the netmask, whereas <type>cidr</type> does not."
msgstr ""
"Существенным различием типов данных <type>inet</type> и <type>cidr</type> "
"является то, что <type>inet</type> принимает значения с ненулевыми битами "
"справа от маски сети, а <type>cidr</type> &mdash; нет."

#: datatype.xml:3646(para)
msgid ""
"If you do not like the output format for <type>inet</type> or <type>cidr</"
"type> values, try the functions <function>host</function>, <function>text</"
"function>, and <function>abbrev</function>."
msgstr ""
"Если вас не устраивает выходной формат значений <type>inet</type> или "
"<type>cidr</type>, попробуйте функции <function>host</function>, "
"<function>text</function> и <function>abbrev</function>."

#: datatype.xml:3657(indexterm)
msgid "<primary>macaddr (data type)</primary>"
msgstr "<primary>macaddr (тип данных)</primary>"

#: datatype.xml:3661(indexterm)
msgid "<primary>MAC address</primary> <see>macaddr</see>"
msgstr "<primary>MAC-адрес</primary> <see>macaddr</see>"

#: datatype.xml:3673(literal)
msgid "'08:00:2b:01:02:03'"
msgstr "'08:00:2b:01:02:03'"

#: datatype.xml:3674(literal)
msgid "'08-00-2b-01-02-03'"
msgstr "'08-00-2b-01-02-03'"

#: datatype.xml:3675(literal)
msgid "'08002b:010203'"
msgstr "'08002b:010203'"

#: datatype.xml:3676(literal)
msgid "'08002b-010203'"
msgstr "'08002b-010203'"

#: datatype.xml:3677(literal)
msgid "'0800.2b01.0203'"
msgstr "'0800.2b01.0203'"

#: datatype.xml:3678(literal)
msgid "'0800-2b01-0203'"
msgstr "'0800-2b01-0203'"

#: datatype.xml:3679(literal)
msgid "'08002b010203'"
msgstr "'08002b010203'"

#: datatype.xml:3666(para)
msgid ""
"The <type>macaddr</type> type stores MAC addresses, known for example from "
"Ethernet card hardware addresses (although MAC addresses are used for other "
"purposes as well). Input is accepted in the following formats: "
"<placeholder-1/> These examples would all specify the same address. Upper "
"and lower case is accepted for the digits <literal>a</literal> through "
"<literal>f</literal>. Output is always in the first of the forms shown."
msgstr ""
"Тип <type>macaddr</type> предназначен для хранения MAC-адреса, примером "
"которого является адрес сетевой платы Ethernet (хотя MAC-адреса применяются "
"и для других целей). Вводимые значения могут задаваться в следующих "
"форматах: <placeholder-1/> Все эти примеры определяют один и тот же адрес. "
"Шестнадцатеричные цифры от <literal>a</literal> до <literal>f</literal> "
"могут быть и в нижнем, и в верхнем регистре. Выводятся MAC-адреса всегда в "
"первой форме."

#: datatype.xml:3688(para)
msgid ""
"IEEE Std 802-2001 specifies the second shown form (with hyphens) as the "
"canonical form for MAC addresses, and specifies the first form (with colons) "
"as the bit-reversed notation, so that 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. "
"This convention is widely ignored nowadays, and it is relevant only for "
"obsolete network protocols (such as Token Ring). PostgreSQL makes no "
"provisions for bit reversal, and all accepted formats use the canonical LSB "
"order."
msgstr ""
"Стандарт IEEE 802-2001 считает канонической формой MAC-адресов вторую (с "
"минусами), а в первой (с двоеточиями) предполагает обратный порядок бит, так "
"что 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. В настоящее время этому "
"соглашению практически никто не следует, и уместно оно было только для "
"устаревших сетевых протоколов (таких как Token Ring). PostgreSQL не меняет "
"порядок бит и во всех принимаемых форматах подразумевается традиционный "
"порядок LSB."

#: datatype.xml:3699(para)
msgid "The remaining five input formats are not part of any standard."
msgstr "Последние пять входных форматов не описаны ни в каком стандарте."

#: datatype.xml:3707(title)
msgid "Bit String Types"
msgstr "Битовые строки"

#: datatype.xml:3709(indexterm)
msgid "<primary>bit string</primary> <secondary>data type</secondary>"
msgstr "<primary>битовая строка</primary> <secondary>тип данных</secondary>"

#: datatype.xml:3714(para)
msgid ""
"Bit strings are strings of 1's and 0's. They can be used to store or "
"visualize bit masks. There are two SQL bit types: <type>bit(<replaceable>n</"
"replaceable>)</type> and <type>bit varying(<replaceable>n</replaceable>)</"
"type>, where <replaceable>n</replaceable> is a positive integer."
msgstr ""
"Битовые строки представляют собой последовательности из 1 и 0. Их можно "
"использовать для хранения или отображения битовых масок. В SQL есть два "
"битовых типа: <type>bit(<replaceable>n</replaceable>)</type> и <type>bit "
"varying(<replaceable>n</replaceable>)</type>, где <replaceable>n</"
"replaceable> &mdash; положительное целое число."

#: datatype.xml:3722(para)
msgid ""
"<type>bit</type> type data must match the length <replaceable>n</"
"replaceable> exactly; it is an error to attempt to store shorter or longer "
"bit strings. <type>bit varying</type> data is of variable length up to the "
"maximum length <replaceable>n</replaceable>; longer strings will be "
"rejected. Writing <type>bit</type> without a length is equivalent to "
"<literal>bit(1)</literal>, while <type>bit varying</type> without a length "
"specification means unlimited length."
msgstr ""
"Длина значения типа <type>bit</type> должна в точности равняться "
"<replaceable>n</replaceable>; при попытке сохранить данные длиннее или "
"короче произойдёт ошибка. Данные типа <type>bit varying</type> могут иметь "
"переменную длину, но не превышающую <replaceable>n</replaceable>; строки "
"большей длины не будут приняты. Запись <type>bit</type> без указания длины "
"равнозначна записи <literal>bit(1)</literal>, тогда как <type>bit varying</"
"type> без указания длины подразумевает строку неограниченной длины."

#: datatype.xml:3734(para)
msgid ""
"If one explicitly casts a bit-string value to <type>bit(<replaceable>n</"
"replaceable>)</type>, it will be truncated or zero-padded on the right to be "
"exactly <replaceable>n</replaceable> bits, without raising an error. "
"Similarly, if one explicitly casts a bit-string value to <type>bit "
"varying(<replaceable>n</replaceable>)</type>, it will be truncated on the "
"right if it is more than <replaceable>n</replaceable> bits."
msgstr ""
"При попытке привести значение битовой строки к типу "
"<type>bit(<replaceable>n</replaceable>)</type>, оно будет усечено или "
"дополнено нулями справа до длины ровно <replaceable>n</replaceable> бит, "
"ошибки при этом не будет. Подобным образом, если явно привести значение "
"битовой строки к типу <type>bit varying(<replaceable>n</replaceable>)</"
"type>, она будет усечена справа, если её длина превышает <replaceable>n</"
"replaceable> бит."

#: datatype.xml:3745(para)
msgid ""
"Refer to <xref linkend=\"sql-syntax-bit-strings\"/> for information about "
"the syntax of bit string constants. Bit-logical operators and string "
"manipulation functions are available; see <xref linkend=\"functions-bitstring"
"\"/>."
msgstr ""
"Синтаксис констант битовых строк описан в <xref remap=\"6\" linkend=\"sql-"
"syntax-bit-strings\"/>, а все доступные битовые операторы и функции "
"перечислены в <xref remap=\"6\" linkend=\"functions-bitstring\"/>."

#: datatype.xml:3754(title)
msgid "Using the Bit String Types"
msgstr "Использование битовых строк"

#: datatype.xml:3756(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test (a BIT(3), b BIT VARYING(5));\n"
"INSERT INTO test VALUES (B'101', B'00');\n"
"INSERT INTO test VALUES (B'10', B'101');\n"
"<computeroutput>\n"
"ERROR:  bit string length 2 does not match type bit(3)\n"
"</computeroutput>\n"
"INSERT INTO test VALUES (B'10'::bit(3), B'101');\n"
"SELECT * FROM test;\n"
"<computeroutput>\n"
"  a  |  b\n"
"-----+-----\n"
" 101 | 00\n"
" 100 | 101\n"
"</computeroutput>"
msgstr ""
"CREATE TABLE test (a BIT(3), b BIT VARYING(5));\n"
"INSERT INTO test VALUES (B'101', B'00');\n"
"INSERT INTO test VALUES (B'10', B'101');\n"
"<computeroutput>\n"
"ОШИБКА:  длина битовой строки (2) не соответствует типу bit(3)\n"
"</computeroutput>\n"
"INSERT INTO test VALUES (B'10'::bit(3), B'101');\n"
"SELECT * FROM test;\n"
"<computeroutput>\n"
"  a  |  b\n"
"-----+-----\n"
" 101 | 00\n"
" 100 | 101\n"
"</computeroutput>"

#: datatype.xml:3774(para)
msgid ""
"A bit string value requires 1 byte for each group of 8 bits, plus 5 or 8 "
"bytes overhead depending on the length of the string (but long values may be "
"compressed or moved out-of-line, as explained in <xref linkend=\"datatype-"
"character\"/> for character strings)."
msgstr ""
"Для хранения битовой строки используется по 1 байту для каждой группы из 8 "
"бит, плюс 5 или 8 байт дополнительно в зависимости от длины строки (но "
"длинные строки могут быть сжаты или вынесены отдельно, как описано в <xref "
"remap=\"6\" linkend=\"datatype-character\"/> применительно к символьным "
"строкам)."

#: datatype.xml:3783(title)
msgid "Text Search Types"
msgstr "Типы, предназначенные для текстового поиска"

#: datatype.xml:3785(indexterm)
msgid "<primary>full text search</primary> <secondary>data types</secondary>"
msgstr ""
"<primary>полнотекстовый поиск</primary> <secondary>типы данных</secondary>"

#: datatype.xml:3790(indexterm)
msgid "<primary>text search</primary> <secondary>data types</secondary>"
msgstr "<primary>текстовый поиск</primary> <secondary>типы данных</secondary>"

#: datatype.xml:3795(para)
msgid ""
"<productname>PostgreSQL</productname> provides two data types that are "
"designed to support full text search, which is the activity of searching "
"through a collection of natural-language <firstterm>documents</firstterm> to "
"locate those that best match a <firstterm>query</firstterm>. The "
"<type>tsvector</type> type represents a document in a form optimized for "
"text search; the <type>tsquery</type> type similarly represents a text "
"query. <xref linkend=\"textsearch\"/> provides a detailed explanation of "
"this facility, and <xref linkend=\"functions-textsearch\"/> summarizes the "
"related functions and operators."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет два типа данных для "
"поддержки полнотекстового поиска. Текстовым поиском называется операция "
"анализа набора <firstterm>документов</firstterm> с текстом на естественном "
"языке, в результате которой находятся фрагменты, наиболее соответствующие "
"<firstterm>запросу</firstterm>. Тип <type>tsvector</type> представляет "
"документ в виде, оптимизированном для текстового поиска, а <type>tsquery</"
"type> представляет запрос текстового поиска в подобном виде. Более подробно "
"это описывается в <xref remap=\"6\" linkend=\"textsearch\"/>, а все "
"связанные функции и операторы перечислены в <xref remap=\"6\" linkend="
"\"functions-textsearch\"/>."

#: datatype.xml:3811(indexterm)
msgid "<primary>tsvector (data type)</primary>"
msgstr "<primary>tsvector (тип данных)</primary>"

#: datatype.xml:3823(programlisting)
#, no-wrap
msgid ""
"SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;\n"
"                      tsvector\n"
"----------------------------------------------------\n"
" 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'"
msgstr ""
"SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;\n"
"                      tsvector\n"
"----------------------------------------------------\n"
" 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'"

#: datatype.xml:3833(programlisting)
#, no-wrap
msgid ""
"SELECT $$the lexeme '    ' contains spaces$$::tsvector;\n"
"                 tsvector                  \n"
"-------------------------------------------\n"
" '    ' 'contains' 'lexeme' 'spaces' 'the'"
msgstr ""
"SELECT $$the lexeme '    ' contains spaces$$::tsvector;\n"
"                 tsvector                  \n"
"-------------------------------------------\n"
" '    ' 'contains' 'lexeme' 'spaces' 'the'"

#: datatype.xml:3844(programlisting)
#, no-wrap
msgid ""
"SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;\n"
"                    tsvector                    \n"
"------------------------------------------------\n"
" 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'"
msgstr ""
"SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;\n"
"                    tsvector                    \n"
"------------------------------------------------\n"
" 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'"

#: datatype.xml:3854(programlisting)
#, no-wrap
msgid ""
"SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;\n"
"                                  tsvector\n"
"-------------------------------------------------------------------------------\n"
" 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4"
msgstr ""
"SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11\n"
"  rat:12'::tsvector;\n"
"                                  tsvector\n"
"---------------------------------------------------------------------------\n"
" 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12\n"
"  'sat':4"

#: datatype.xml:3815(para)
msgid ""
"A <type>tsvector</type> value is a sorted list of distinct "
"<firstterm>lexemes</firstterm>, which are words that have been "
"<firstterm>normalized</firstterm> to merge different variants of the same "
"word (see <xref linkend=\"textsearch\"/> for details). Sorting and duplicate-"
"elimination are done automatically during input, as shown in this example: "
"<placeholder-1/> To represent lexemes containing whitespace or punctuation, "
"surround them with quotes: <placeholder-2/> (We use dollar-quoted string "
"literals in this example and the next one to avoid the confusion of having "
"to double quote marks within the literals.) Embedded quotes and backslashes "
"must be doubled: <placeholder-3/> Optionally, integer <firstterm>positions</"
"firstterm> can be attached to lexemes: <placeholder-4/> A position normally "
"indicates the source word's location in the document. Positional information "
"can be used for <firstterm>proximity ranking</firstterm>. Position values "
"can range from 1 to 16383; larger numbers are silently set to 16383. "
"Duplicate positions for the same lexeme are discarded."
msgstr ""
"Значение типа <type>tsvector</type> содержит отсортированный список "
"неповторяющихся <firstterm>лексем</firstterm>, т. е. слов, "
"<firstterm>нормализованных</firstterm> так, что все словоформы сводятся к "
"одной (подробнее это описано в <xref remap=\"6\" linkend=\"textsearch\"/>). "
"Сортировка и исключение повторяющихся слов производится автоматически при "
"вводе значения, как показано в этом примере: <placeholder-1/> Для "
"представления в виде лексем пробелов или знаков препинания их нужно "
"заключить в апострофы: <placeholder-2/> (В данном и следующих примерах мы "
"используем строку в долларах, чтобы не дублировать все апострофы в таких "
"строках.) При этом включаемый апостроф или обратную косую черту нужно "
"продублировать: <placeholder-3/> Также для лексем можно указать их "
"целочисленные <firstterm>позиции</firstterm>: <placeholder-4/> Позиция "
"обычно указывает положение исходного слова в документе. Информация о "
"расположении слов затем может использоваться для <firstterm>оценки близости</"
"firstterm>. Позиция может задаваться числом от 1 до 16383; большие значения "
"просто заменяются на 16383. Если для одной лексемы дважды указывается одно "
"положение, такое повторение отбрасывается."

#: datatype.xml:3874(programlisting)
#, no-wrap
msgid ""
"SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;\n"
"          tsvector          \n"
"----------------------------\n"
" 'a':1A 'cat':5 'fat':2B,4C"
msgstr ""
"SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;\n"
"          tsvector          \n"
"----------------------------\n"
" 'a':1A 'cat':5 'fat':2B,4C"

#: datatype.xml:3868(para)
msgid ""
"Lexemes that have positions can further be labeled with a <firstterm>weight</"
"firstterm>, which can be <literal>A</literal>, <literal>B</literal>, "
"<literal>C</literal>, or <literal>D</literal>. <literal>D</literal> is the "
"default and hence is not shown on output: <placeholder-1/> Weights are "
"typically used to reflect document structure, for example by marking title "
"words differently from body words. Text search ranking functions can assign "
"different priorities to the different weight markers."
msgstr ""
"Лексемам, для которых заданы позиции, также можно назначить <firstterm>вес</"
"firstterm>, выраженный буквами <literal>A</literal>, <literal>B</literal>, "
"<literal>C</literal> или <literal>D</literal>. Вес <literal>D</literal> "
"подразумевается по умолчанию и поэтому он не показывается при выводе: "
"<placeholder-1/> Веса обычно применяются для отражения структуры документа, "
"например для придания особого значения словам в заголовке по сравнению со "
"словами в обычном тексте. Назначенным весам можно сопоставить числовые "
"приоритеты в функциях ранжирования результатов."

#: datatype.xml:3893(programlisting)
#, no-wrap
msgid ""
"SELECT 'The Fat Rats'::tsvector;\n"
"      tsvector      \n"
"--------------------\n"
" 'Fat' 'Rats' 'The'"
msgstr ""
"SELECT 'The Fat Rats'::tsvector;\n"
"      tsvector      \n"
"--------------------\n"
" 'Fat' 'Rats' 'The'"

#: datatype.xml:3906(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector('english', 'The Fat Rats');\n"
"   to_tsvector   \n"
"-----------------\n"
" 'fat':2 'rat':3"
msgstr ""
"SELECT to_tsvector('english', 'The Fat Rats');\n"
"   to_tsvector   \n"
"-----------------\n"
" 'fat':2 'rat':3"

#: datatype.xml:3887(para)
msgid ""
"It is important to understand that the <type>tsvector</type> type itself "
"does not perform any word normalization; it assumes the words it is given "
"are normalized appropriately for the application. For example, "
"<placeholder-1/> For most English-text-searching applications the above "
"words would be considered non-normalized, but <type>tsvector</type> doesn't "
"care. Raw document text should usually be passed through "
"<function>to_tsvector</function> to normalize the words appropriately for "
"searching: <placeholder-2/> Again, see <xref linkend=\"textsearch\"/> for "
"more detail."
msgstr ""
"Важно понимать, что тип <type>tsvector</type> сам по себе не выполняет "
"нормализацию слов; предполагается, что в сохраняемом значении слова уже "
"нормализованы приложением. Например: <placeholder-1/> Для большинства "
"англоязычных приложений приведённые выше слова будут считаться "
"ненормализованными, но для <type>tsvector</type> это не важно. Поэтому "
"исходный документ обычно следует обработать функцией <function>to_tsvector</"
"function>, нормализующей слова для поиска: <placeholder-2/> И это подробнее "
"описано в <xref remap=\"6\" linkend=\"textsearch\"/>."

#: datatype.xml:3921(indexterm)
msgid "<primary>tsquery (data type)</primary>"
msgstr "<primary>tsquery (тип данных)</primary>"

#: datatype.xml:3925(para)
msgid ""
"A <type>tsquery</type> value stores lexemes that are to be searched for, and "
"can combine them using the Boolean operators <literal>&amp;</literal> (AND), "
"<literal>|</literal> (OR), and <literal>!</literal> (NOT), as well as the "
"phrase search operator <literal>&lt;-&gt;</literal> (FOLLOWED BY). There is "
"also a variant <literal>&lt;<replaceable>N</replaceable>&gt;</literal> of "
"the FOLLOWED BY operator, where <replaceable>N</replaceable> is an integer "
"constant that specifies the distance between the two lexemes being searched "
"for. <literal>&lt;-&gt;</literal> is equivalent to <literal>&lt;1&gt;</"
"literal>."
msgstr ""
"Значение <type>tsquery</type> содержит искомые лексемы, объединяемые "
"логическими операторами <literal>&amp;</literal> (И), <literal>|</literal> "
"(ИЛИ) и <literal>!</literal> (НЕ), а также оператором поиска фраз "
"<literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ). Также допускается вариация "
"оператора ПРЕДШЕСТВУЕТ вида <literal>&lt;<replaceable>N</replaceable>&gt;</"
"literal>, где <replaceable>N</replaceable> — целочисленная константа, "
"задающая расстояние между двумя искомыми лексемами. Запись оператора "
"<literal>&lt;-&gt;</literal> равнозначна <literal>&lt;1&gt;</literal>."

#: datatype.xml:3937(para)
msgid ""
"Parentheses can be used to enforce grouping of these operators. In the "
"absence of parentheses, <literal>!</literal> (NOT) binds most tightly, "
"<literal>&lt;-&gt;</literal> (FOLLOWED BY) next most tightly, then "
"<literal>&amp;</literal> (AND), with <literal>|</literal> (OR) binding the "
"least tightly."
msgstr ""
"Для группировки операторов могут использоваться скобки. Без скобок эти "
"операторы имеют разные приоритеты, в порядке убывания: <literal>!</literal> "
"(НЕ), <literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ), <literal>&amp;</literal> "
"(И) и <literal>|</literal> (ИЛИ)."

#: datatype.xml:3948(programlisting)
#, no-wrap
msgid ""
"SELECT 'fat &amp; rat'::tsquery;\n"
"    tsquery    \n"
"---------------\n"
" 'fat' &amp; 'rat'\n"
"\n"
"SELECT 'fat &amp; (rat | cat)'::tsquery;\n"
"          tsquery          \n"
"---------------------------\n"
" 'fat' &amp; ( 'rat' | 'cat' )\n"
"\n"
"SELECT 'fat &amp; rat &amp; ! cat'::tsquery;\n"
"        tsquery         \n"
"------------------------\n"
" 'fat' &amp; 'rat' &amp; !'cat'"
msgstr ""
"SELECT 'fat &amp; rat'::tsquery;\n"
"    tsquery    \n"
"---------------\n"
" 'fat' &amp; 'rat'\n"
"\n"
"SELECT 'fat &amp; (rat | cat)'::tsquery;\n"
"          tsquery          \n"
"---------------------------\n"
" 'fat' &amp; ( 'rat' | 'cat' )\n"
"\n"
"SELECT 'fat &amp; rat &amp; ! cat'::tsquery;\n"
"        tsquery         \n"
"------------------------\n"
" 'fat' &amp; 'rat' &amp; !'cat'"

#: datatype.xml:3945(para)
msgid "Here are some examples: <placeholder-1/>"
msgstr "Несколько примеров: <placeholder-1/>"

#: datatype.xml:3971(programlisting)
#, no-wrap
msgid ""
"SELECT 'fat:ab &amp; cat'::tsquery;\n"
"    tsquery\n"
"------------------\n"
" 'fat':AB &amp; 'cat'"
msgstr ""
"SELECT 'fat:ab &amp; cat'::tsquery;\n"
"    tsquery\n"
"------------------\n"
" 'fat':AB &amp; 'cat'"

#: datatype.xml:3966(para)
msgid ""
"Optionally, lexemes in a <type>tsquery</type> can be labeled with one or "
"more weight letters, which restricts them to match only <type>tsvector</"
"type> lexemes with one of those weights: <placeholder-1/>"
msgstr ""
"Лексемам в <type>tsquery</type> можно дополнительно сопоставить буквы весов, "
"при этом они будут соответствовать только тем лексемам в <type>tsvector</"
"type>, которые имеют какой-либо из этих весов: <placeholder-1/>"

#: datatype.xml:3982(programlisting)
#, no-wrap
msgid ""
"SELECT 'super:*'::tsquery;\n"
"  tsquery  \n"
"-----------\n"
" 'super':*"
msgstr ""
"SELECT 'super:*'::tsquery;\n"
"  tsquery  \n"
"-----------\n"
" 'super':*"

#: datatype.xml:3979(para)
msgid ""
"Also, lexemes in a <type>tsquery</type> can be labeled with <literal>*</"
"literal> to specify prefix matching: <placeholder-1/> This query will match "
"any word in a <type>tsvector</type> that begins with <quote>super</quote>."
msgstr ""
"Кроме того, в лексемах <type>tsquery</type> можно использовать знак "
"<literal>*</literal> для поиска по префиксу: <placeholder-1/> Этот запрос "
"найдёт все слова в <type>tsvector</type>, начинающиеся с приставки "
"<quote>super</quote>."

#: datatype.xml:3999(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsquery('Fat:ab &amp; Cats');\n"
"    to_tsquery    \n"
"------------------\n"
" 'fat':AB &amp; 'cat'"
msgstr ""
"SELECT to_tsquery('Fat:ab &amp; Cats');\n"
"    to_tsquery    \n"
"------------------\n"
" 'fat':AB &amp; 'cat'"

#: datatype.xml:4009(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );\n"
" ?column?\n"
"----------\n"
" t"
msgstr ""
"SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );\n"
" ?column?\n"
"----------\n"
" t"

#: datatype.xml:4016(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );\n"
"  to_tsvector  | to_tsquery\n"
"---------------+------------\n"
" 'postgradu':1 | 'postgr':*"
msgstr ""
"SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );\n"
"  to_tsvector  | to_tsquery\n"
"---------------+------------\n"
" 'postgradu':1 | 'postgr':*"

#: datatype.xml:3992(para)
msgid ""
"Quoting rules for lexemes are the same as described previously for lexemes "
"in <type>tsvector</type>; and, as with <type>tsvector</type>, any required "
"normalization of words must be done before converting to the <type>tsquery</"
"type> type. The <function>to_tsquery</function> function is convenient for "
"performing such normalization: <placeholder-1/> Note that "
"<function>to_tsquery</function> will process prefixes in the same way as "
"other words, which means this comparison returns true: <placeholder-2/> "
"because <literal>postgres</literal> gets stemmed to <literal>postgr</"
"literal>: <placeholder-3/> which will match the stemmed form of "
"<literal>postgraduate</literal>."
msgstr ""
"Апострофы в лексемах этого типа можно использовать так же, как и в лексемах "
"в <type>tsvector</type>; и так же, как и для типа <type>tsvector</type>, "
"необходимая нормализация слова должна выполняться до приведения значения к "
"типу <type>tsquery</type>. Для такой нормализации удобно использовать "
"функцию <function>to_tsquery</function>: <placeholder-1/> Заметьте, что "
"функция <function>to_tsquery</function> будет обрабатывать префиксы подобно "
"другим словам, поэтому следующее сравнение возвращает true: <placeholder-2/> "
"так как <literal>postgres</literal> преобразуется стеммером в "
"<literal>postgr</literal>: <placeholder-3/> и эта приставка находится в "
"преобразованной форме слова <literal>postgraduate</literal>."

#: datatype.xml:4030(title)
msgid "<acronym>UUID</acronym> Type"
msgstr "Тип <acronym>UUID</acronym>"

#: datatype.xml:4032(indexterm)
msgid "<primary>UUID</primary>"
msgstr "<primary>UUID</primary>"

#: datatype.xml:4040(indexterm)
msgid "<primary>GUID</primary>"
msgstr "<primary>GUID</primary>"

#: datatype.xml:4036(para)
msgid ""
"The data type <type>uuid</type> stores Universally Unique Identifiers (UUID) "
"as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some "
"systems refer to this data type as a globally unique identifier, or GUID,"
"<placeholder-1/> instead.) This identifier is a 128-bit quantity that is "
"generated by an algorithm chosen to make it very unlikely that the same "
"identifier will be generated by anyone else in the known universe using the "
"same algorithm. Therefore, for distributed systems, these identifiers "
"provide a better uniqueness guarantee than sequence generators, which are "
"only unique within a single database."
msgstr ""
"Тип данных <type>uuid</type> сохраняет универсальные уникальные "
"идентификаторы (Universally Unique Identifiers, UUID), определённые в RFC "
"4122, ISO/IEC 9834-8:2005 и связанных стандартах. (В некоторых системах это "
"называется <placeholder-1/>GUID, глобальным уникальным идентификатором.) "
"Этот идентификатор представляет собой 128-битное значение, генерируемое "
"специальным алгоритмом, практически гарантирующим, что этим же алгоритмом "
"оно не будет получено больше нигде в мире. Таким образом, эти идентификаторы "
"будут уникальными и в распределённых системах, а не только в единственной "
"базе данных, как значения генераторов последовательностей."

#: datatype.xml:4055(programlisting)
#, no-wrap
msgid "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"
msgstr "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"

#: datatype.xml:4063(programlisting)
#, no-wrap
msgid ""
"A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n"
"{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}\n"
"a0eebc999c0b4ef8bb6d6bb9bd380a11\n"
"a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n"
"{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}"
msgstr ""
"A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n"
"{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}\n"
"a0eebc999c0b4ef8bb6d6bb9bd380a11\n"
"a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n"
"{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}"

#: datatype.xml:4049(para)
msgid ""
"A UUID is written as a sequence of lower-case hexadecimal digits, in several "
"groups separated by hyphens, specifically a group of 8 digits followed by "
"three groups of 4 digits followed by a group of 12 digits, for a total of 32 "
"digits representing the 128 bits. An example of a UUID in this standard form "
"is: <placeholder-1/> <productname>PostgreSQL</productname> also accepts the "
"following alternative forms for input: use of upper-case digits, the "
"standard format surrounded by braces, omitting some or all hyphens, adding a "
"hyphen after any group of four digits. Examples are: <placeholder-2/> Output "
"is always in the standard form."
msgstr ""
"UUID записывается в виде последовательности шестнадцатеричных цифр в нижнем "
"регистре, разделённых знаками минуса на несколько групп, в таком порядке: "
"группа из 8 цифр, за ней три группы из 4 цифр и, наконец, группа из 12 цифр, "
"что в сумме составляет 32 цифры и представляет 128 бит. Пример UUID в этом "
"стандартном виде: <placeholder-1/> <productname>PostgreSQL</productname> "
"также принимает альтернативные варианты: цифры в верхнем регистре, "
"стандартную запись, заключённую в фигурные скобки, запись без минусов или с "
"минусами, разделяющими любые группы из четырёх цифр. Например: "
"<placeholder-2/> Выводится значение этого типа всегда в стандартном виде."

#: datatype.xml:4073(para)
msgid ""
"<productname>PostgreSQL</productname> provides storage and comparison "
"functions for UUIDs, but the core database does not include any function for "
"generating UUIDs, because no single algorithm is well suited for every "
"application. The <xref linkend=\"uuid-ossp\"/> module provides functions "
"that implement several standard algorithms. The <xref linkend=\"pgcrypto\"/> "
"module also provides a generation function for random UUIDs. Alternatively, "
"UUIDs could be generated by client applications or other libraries invoked "
"through a server-side function."
msgstr ""
"В <productname>PostgreSQL</productname> встроены функции хранения и "
"сравнения идентификаторов UUID, но нет внутренней функции генерирования "
"UUID, потому что не существует какого-то единственного алгоритма, "
"подходящего для всех приложений. Сгенерировать UUID можно с помощью "
"дополнительного модуля <xref linkend=\"uuid-ossp\"/>, в котором реализованы "
"несколько стандартных алгоритмов, а можно воспользоваться модулем <xref "
"linkend=\"pgcrypto\"/>, где тоже есть функция генерирования случайных UUID. "
"Кроме того, можно сделать это в клиентском приложении или в другой "
"библиотеке, подключённой на стороне сервера."

#: datatype.xml:4088(title)
msgid "<acronym>XML</acronym> Type"
msgstr "Тип <acronym>XML</acronym>"

#: datatype.xml:4090(indexterm)
msgid "<primary>XML</primary>"
msgstr "<primary>XML</primary>"

#: datatype.xml:4094(para)
msgid ""
"The <type>xml</type> data type can be used to store XML data. Its advantage "
"over storing XML data in a <type>text</type> field is that it checks the "
"input values for well-formedness, and there are support functions to perform "
"type-safe operations on it; see <xref linkend=\"functions-xml\"/>. Use of "
"this data type requires the installation to have been built with "
"<command>configure --with-libxml</command>."
msgstr ""
"Тип <type>xml</type> предназначен для хранения XML-данных. Его преимущество "
"по сравнению с обычным типом <type>text</type> в том, что он проверяет "
"вводимые значения на допустимость по правилам XML и для работы с ним есть "
"типобезопасные функции; см. <xref remap=\"4\" linkend=\"functions-xml\"/>. "
"Для использования этого типа дистрибутив должен быть скомпилирован в "
"конфигурации <command>configure --with-libxml</command>."

#: datatype.xml:4104(para)
msgid ""
"The <type>xml</type> type can store well-formed <quote>documents</quote>, as "
"defined by the XML standard, as well as <quote>content</quote> fragments, "
"which are defined by the production <literal>XMLDecl? content</literal> in "
"the XML standard. Roughly, this means that content fragments can have more "
"than one top-level element or character node. The expression "
"<literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal> can be "
"used to evaluate whether a particular <type>xml</type> value is a full "
"document or only a content fragment."
msgstr ""
"Тип <type>xml</type> может сохранять правильно оформленные <quote>документы</"
"quote>, в соответствии со стандартом XML, а также фрагменты "
"<quote>содержимого</quote>, описанные как <literal>содержимое</literal> "
"элементов в стандарте XML. Другими словами, это означает, что фрагменты "
"содержимого могут содержать несколько элементов верхнего уровня или "
"текстовых узлов. Определить, является ли определённое значение типа "
"<type>xml</type> полным документом или фрагментом содержимого, позволяет "
"выражение <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>."

#: datatype.xml:4117(title)
msgid "Creating XML Values"
msgstr "Создание XML-значений"

#: datatype.xml:4121(indexterm)
msgid "<primary>xmlparse</primary>"
msgstr "<primary>xmlparse</primary>"

#: datatype.xml:4118(para)
msgid ""
"To produce a value of type <type>xml</type> from character data, use the "
"function <function>xmlparse</function>:<placeholder-1/> <synopsis>\n"
"XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)\n"
"</synopsis> Examples: <placeholder-2/> While this is the only way to convert "
"character strings into XML values according to the SQL standard, the "
"PostgreSQL-specific syntaxes: <placeholder-3/> can also be used."
msgstr ""
"Чтобы получить значение типа <type>xml</type> из текстовой строки, "
"используйте функцию <function>xmlparse</function>:<placeholder-1/> "
"<synopsis>\n"
"XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)\n"
"</synopsis> Примеры: <placeholder-2/> Хотя в стандарте SQL описан только "
"один способ преобразования текстовых строк в XML-значения, специфический "
"синтаксис PostgreSQL: <placeholder-3/> тоже допустим."

#: datatype.xml:4143(indexterm)
msgid "<primary>DTD</primary>"
msgstr "<primary>DTD</primary>"

#: datatype.xml:4140(para)
msgid ""
"The <type>xml</type> type does not validate input values against a document "
"type declaration (DTD),<placeholder-1/> even when the input value specifies "
"a DTD. There is also currently no built-in support for validating against "
"other XML schema languages such as XML Schema."
msgstr ""
"Тип <type>xml</type> не проверяет вводимые значения по схеме DTD (Document "
"Type Declaration, Объявления типа документа),<placeholder-1/> даже если в "
"них присутствуют ссылка на DTD. В настоящее время в <productname>PostgreSQL</"
"productname> также нет встроенной поддержки других разновидностей схем, "
"например XML Schema."

#: datatype.xml:4152(indexterm)
msgid "<primary>xmlserialize</primary>"
msgstr "<primary>xmlserialize</primary>"

#: datatype.xml:4149(para)
msgid ""
"The inverse operation, producing a character string value from <type>xml</"
"type>, uses the function <function>xmlserialize</function>:<placeholder-1/> "
"<synopsis>\n"
"XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS "
"<replaceable>type</replaceable> )\n"
"</synopsis> <replaceable>type</replaceable> can be <type>character</type>, "
"<type>character varying</type>, or <type>text</type> (or an alias for one of "
"those). Again, according to the SQL standard, this is the only way to "
"convert between type <type>xml</type> and character types, but PostgreSQL "
"also allows you to simply cast the value."
msgstr ""
"Обратная операция, получение текстовой строки из <type>xml</type>, "
"выполняется с помощью функции <function>xmlserialize</function>:"
"<placeholder-1/> <synopsis>\n"
"XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>значение</replaceable> AS "
"<replaceable>тип</replaceable> )\n"
"</synopsis> Здесь допустимый <replaceable>тип</replaceable> &mdash; "
"<type>character</type>, <type>character varying</type> или <type>text</type> "
"(или их псевдонимы). И в данном случае стандарт SQL предусматривает только "
"один способ преобразования <type>xml</type> в тип текстовых строк, но "
"PostgreSQL позволяет просто привести значение к нужному типу."

#: datatype.xml:4170(indexterm)
msgid "<primary>XML option</primary>"
msgstr "<primary>XML option</primary>"

#: datatype.xml:4164(para)
msgid ""
"When a character string value is cast to or from type <type>xml</type> "
"without going through <type>XMLPARSE</type> or <type>XMLSERIALIZE</type>, "
"respectively, the choice of <literal>DOCUMENT</literal> versus "
"<literal>CONTENT</literal> is determined by the <quote>XML option</quote> "
"<placeholder-1/> session configuration parameter, which can be set using the "
"standard command: <synopsis>\n"
"SET XML OPTION { DOCUMENT | CONTENT };\n"
"</synopsis> or the more PostgreSQL-like syntax <synopsis>\n"
"SET xmloption TO { DOCUMENT | CONTENT };\n"
"</synopsis> The default is <literal>CONTENT</literal>, so all forms of XML "
"data are allowed."
msgstr ""
"При преобразовании текстовой строки в тип <type>xml</type> или наоборот без "
"использования функций <type>XMLPARSE</type> и <type>XMLSERIALIZE</type>, "
"выбор режима <literal>DOCUMENT</literal> или <literal>CONTENT</literal> "
"определяется параметром конфигурации сеанса <quote>XML option</"
"quote><placeholder-1/>, установить который можно следующей стандартной "
"командой: <synopsis>\n"
"SET XML OPTION { DOCUMENT | CONTENT };\n"
"</synopsis> или такой командой в духе PostgreSQL:<synopsis>\n"
"SET xmloption TO { DOCUMENT | CONTENT };\n"
"</synopsis> По умолчанию этот параметр имеет значение <literal>CONTENT</"
"literal>, так что допускаются все формы XML-данных."

#: datatype.xml:4185(para)
msgid ""
"With the default XML option setting, you cannot directly cast character "
"strings to type <type>xml</type> if they contain a document type "
"declaration, because the definition of XML content fragment does not accept "
"them. If you need to do that, either use <literal>XMLPARSE</literal> or "
"change the XML option."
msgstr ""
"Когда параметр XML option имеет значение по умолчанию, текстовые строки "
"нельзя напрямую привести к типу <type>xml</type>, если они содержат "
"объявление типа документа, так как такие объявления не допускаются во "
"фрагментах. Для выполнения преобразования в таких случаях следует "
"использовать <literal>XMLPARSE</literal> или изменить параметр XML option."

#: datatype.xml:4197(title)
msgid "Encoding Handling"
msgstr "Обработка кодировки"

#: datatype.xml:4198(para)
msgid ""
"Care must be taken when dealing with multiple character encodings on the "
"client, server, and in the XML data passed through them. When using the text "
"mode to pass queries to the server and query results to the client (which is "
"the normal mode), PostgreSQL converts all character data passed between the "
"client and the server and vice versa to the character encoding of the "
"respective end; see <xref linkend=\"multibyte\"/>. This includes string "
"representations of XML values, such as in the above examples. This would "
"ordinarily mean that encoding declarations contained in XML data can become "
"invalid as the character data is converted to other encodings while "
"traveling between client and server, because the embedded encoding "
"declaration is not changed. To cope with this behavior, encoding "
"declarations contained in character strings presented for input to the "
"<type>xml</type> type are <emphasis>ignored</emphasis>, and content is "
"assumed to be in the current server encoding. Consequently, for correct "
"processing, character strings of XML data must be sent from the client in "
"the current client encoding. It is the responsibility of the client to "
"either convert documents to the current client encoding before sending them "
"to the server, or to adjust the client encoding appropriately. On output, "
"values of type <type>xml</type> will not have an encoding declaration, and "
"clients should assume all data is in the current client encoding."
msgstr ""
"Если на стороне сервера и клиента и в XML-данных используются разные "
"кодировки символов, с этим могут возникать проблемы. Когда запросы "
"передаются на сервер, а их результаты возвращаются клиенту в обычном "
"текстовом режиме, PostgreSQL преобразует все передаваемые текстовые данные в "
"кодировку для соответствующей стороны; см. <xref remap=\"4\" linkend="
"\"multibyte\"/>. В том числе это происходит и со строковыми представлениями "
"XML-данных, подобными тем, что показаны в предыдущих примерах. Обычно это "
"означает, что объявления кодировки, содержащиеся в XML-данных, могут не "
"соответствовать действительности, когда текстовая строка преобразуется из "
"одной кодировки в другую при передаче данных между клиентом и сервером, так "
"как подобные включённые в данные объявления не будут изменены автоматически. "
"Для решения этой проблемы объявления кодировки, содержащиеся в текстовых "
"строках, вводимых в тип <type>xml</type>, просто <emphasis>игнорируются</"
"emphasis> и предполагается, что XML-содержимое представлено в текущей "
"кодировке сервера. Как следствие, для правильной обработки таких строк с XML-"
"данными клиент должен передавать их в своей текущей кодировке. Для сервера "
"не важно, будет ли клиент для этого преобразовывать документы в свою "
"кодировку, или изменит её, прежде чем передавать ему данные. При выводе "
"значения типа <type>xml</type> не содержат объявления кодировки, а клиент "
"должен предполагать, что все данные поступают в его текущей кодировке."

#: datatype.xml:4225(para)
msgid ""
"When using binary mode to pass query parameters to the server and query "
"results back to the client, no encoding conversion is performed, so the "
"situation is different. In this case, an encoding declaration in the XML "
"data will be observed, and if it is absent, the data will be assumed to be "
"in UTF-8 (as required by the XML standard; note that PostgreSQL does not "
"support UTF-16). On output, data will have an encoding declaration "
"specifying the client encoding, unless the client encoding is UTF-8, in "
"which case it will be omitted."
msgstr ""
"Если параметры запроса передаются на сервер и он возвращает результаты "
"клиенту в двоичном режиме, кодировка символов не преобразуется, так что "
"возникает другая ситуация. В этом случае объявление кодировки в XML "
"принимается во внимание, а если его нет, то предполагается, что данные "
"закодированы в UTF-8 (это соответствует стандарту XML; заметьте, что "
"PostgreSQL не поддерживает UTF-16). При выводе в данные будет добавлено "
"объявление кодировки, выбранной на стороне клиента (но если это UTF-8, "
"объявление будет опущено)."

#: datatype.xml:4237(para)
msgid ""
"Needless to say, processing XML data with PostgreSQL will be less error-"
"prone and more efficient if the XML data encoding, client encoding, and "
"server encoding are the same. Since XML data is internally processed in "
"UTF-8, computations will be most efficient if the server encoding is also "
"UTF-8."
msgstr ""
"Само собой, XML-данные в PostgreSQL будут обрабатываться гораздо "
"эффективнее, когда и в XML-данных, и на стороне клиента, и на стороне "
"сервера используется одна кодировка. Так как внутри XML-данные "
"представляются в UTF-8, оптимальный вариант, когда на сервере также выбрана "
"кодировка UTF-8."

#: datatype.xml:4246(para)
msgid ""
"Some XML-related functions may not work at all on non-ASCII data when the "
"server encoding is not UTF-8. This is known to be an issue for "
"<function>xpath()</function> in particular."
msgstr ""
"Некоторые XML-функции могут вовсе не работать с данными не-ASCII, если "
"кодировка сервера &mdash; не UTF-8. В частности, это известная особенность "
"функции <function>xpath()</function>."

#: datatype.xml:4255(title)
msgid "Accessing XML Values"
msgstr "Обращение к XML-значениям"

#: datatype.xml:4257(para)
msgid ""
"The <type>xml</type> data type is unusual in that it does not provide any "
"comparison operators. This is because there is no well-defined and "
"universally useful comparison algorithm for XML data. One consequence of "
"this is that you cannot retrieve rows by comparing an <type>xml</type> "
"column against a search value. XML values should therefore typically be "
"accompanied by a separate key field such as an ID. An alternative solution "
"for comparing XML values is to convert them to character strings first, but "
"note that character string comparison has little to do with a useful XML "
"comparison method."
msgstr ""
"Тип <type>xml</type> отличается от других тем, что для него не определены "
"никакие операторы сравнения, так как чётко определённого и универсального "
"алгоритма сравнения XML-данных не существует. Одно из следствий этого "
"&mdash; нельзя отфильтровать строки таблицы, сравнив столбец <type>xml</"
"type> с искомым значением. Поэтому обычно XML-значения должны дополняться "
"отдельным ключевым полем, например ID. Можно также сравнивать XML-значения, "
"преобразовав их сначала в текстовые строки, но заметьте, что с учётом "
"специфики XML-данных этот метод практически бесполезен."

#: datatype.xml:4270(para)
msgid ""
"Since there are no comparison operators for the <type>xml</type> data type, "
"it is not possible to create an index directly on a column of this type. If "
"speedy searches in XML data are desired, possible workarounds include "
"casting the expression to a character string type and indexing that, or "
"indexing an XPath expression. Of course, the actual query would have to be "
"adjusted to search by the indexed expression."
msgstr ""
"Из-за отсутствия операторов сравнения для типа <type>xml</type>, для столбца "
"этого типа также нельзя создать индекс. Поэтому, когда требуется быстрый "
"поиск в XML данных, обойти это ограничение можно, приведя данные к типу "
"текстовой строки и проиндексировав эти строки, либо проиндексировав "
"выражение XPath. Конечно сам запрос при этом следует изменить, чтобы поиск "
"выполнялся по индексированному выражению."

#: datatype.xml:4280(para)
msgid ""
"The text-search functionality in PostgreSQL can also be used to speed up "
"full-document searches of XML data. The necessary preprocessing support is, "
"however, not yet available in the PostgreSQL distribution."
msgstr ""
"Для ускорения поиска в XML-данных также можно использовать функции "
"полнотекстового поиска в PostgreSQL. Однако это требует определённой "
"подготовки данных, что дистрибутив PostgreSQL пока не поддерживает."

#: datatype.xml:4298(title) datatype.xml:4411(title)
msgid "Object Identifier Types"
msgstr "Идентификаторы объектов"

#: datatype.xml:4300(indexterm)
msgid "<primary>object identifier</primary> <secondary>data type</secondary>"
msgstr ""
"<primary>идентификатор объекта</primary> <secondary>тип данных</secondary>"

#: datatype.xml:4305(indexterm)
msgid "<primary>oid</primary>"
msgstr "<primary>oid</primary>"

#: datatype.xml:4309(indexterm)
msgid "<primary>regproc</primary>"
msgstr "<primary>regproc</primary>"

#: datatype.xml:4313(indexterm)
msgid "<primary>regprocedure</primary>"
msgstr "<primary>regprocedure</primary>"

#: datatype.xml:4317(indexterm)
msgid "<primary>regoper</primary>"
msgstr "<primary>regoper</primary>"

#: datatype.xml:4321(indexterm)
msgid "<primary>regoperator</primary>"
msgstr "<primary>regoperator</primary>"

#: datatype.xml:4325(indexterm)
msgid "<primary>regclass</primary>"
msgstr "<primary>regclass</primary>"

#: datatype.xml:4329(indexterm)
msgid "<primary>regtype</primary>"
msgstr "<primary>regtype</primary>"

#: datatype.xml:4333(indexterm)
msgid "<primary>regconfig</primary>"
msgstr "<primary>regconfig</primary>"

#: datatype.xml:4337(indexterm)
msgid "<primary>regdictionary</primary>"
msgstr "<primary>regdictionary</primary>"

#: datatype.xml:4341(indexterm)
msgid "<primary>xid</primary>"
msgstr "<primary>xid</primary>"

#: datatype.xml:4345(indexterm)
msgid "<primary>cid</primary>"
msgstr "<primary>cid</primary>"

#: datatype.xml:4349(indexterm)
msgid "<primary>tid</primary>"
msgstr "<primary>tid</primary>"

#: datatype.xml:4353(para)
msgid ""
"Object identifiers (OIDs) are used internally by <productname>PostgreSQL</"
"productname> as primary keys for various system tables. OIDs are not added "
"to user-created tables, unless <literal>WITH OIDS</literal> is specified "
"when the table is created, or the <xref linkend=\"guc-default-with-oids\"/> "
"configuration variable is enabled. Type <type>oid</type> represents an "
"object identifier. There are also several alias types for <type>oid</type>: "
"<type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, "
"<type>regoperator</type>, <type>regclass</type>, <type>regtype</type>, "
"<type>regrole</type>, <type>regnamespace</type>, <type>regconfig</type>, and "
"<type>regdictionary</type>. <xref linkend=\"datatype-oid-table\"/> shows an "
"overview."
msgstr ""
"Идентификатор объекта (Object Identifier, OID) используется внутри "
"<productname>PostgreSQL</productname> в качестве первичного ключа различных "
"системных таблиц. В пользовательские таблицы столбец OID добавляется, только "
"если при создании таблицы указывается <literal>WITH OIDS</literal> или "
"включён параметр конфигурации <xref linkend=\"guc-default-with-oids\"/>. "
"Идентификатор объекта представляется в типе <type>oid</type>. Также для типа "
"<type>oid</type> определены следующие псевдонимы: <type>regproc</type>, "
"<type>regprocedure</type>, <type>regoper</type>, <type>regoperator</type>, "
"<type>regclass</type>, <type>regtype</type>, <type>regrole</type>, "
"<type>regnamespace</type>, <type>regconfig</type> и <type>regdictionary</"
"type>. Обзор этих типов приведён в <xref remap=\"6\" linkend=\"datatype-oid-"
"table\"/>."

#: datatype.xml:4368(para)
msgid ""
"The <type>oid</type> type is currently implemented as an unsigned four-byte "
"integer. Therefore, it is not large enough to provide database-wide "
"uniqueness in large databases, or even in large individual tables. So, using "
"a user-created table's OID column as a primary key is discouraged. OIDs are "
"best used only for references to system tables."
msgstr ""
"В настоящее время тип <type>oid</type> реализован как четырёхбайтное целое. "
"Таким образом оно может быть недостаточно большим для обеспечения "
"уникальности в базе данных или даже в отдельных больших таблицах. Поэтому в "
"пользовательских таблицах использовать столбец типа OID в качестве "
"первичного ключа не рекомендуется. Лучше всего ограничить применение этого "
"типа обращениями к системным таблицам."

#: datatype.xml:4377(para)
msgid ""
"The <type>oid</type> type itself has few operations beyond comparison. It "
"can be cast to integer, however, and then manipulated using the standard "
"integer operators. (Beware of possible signed-versus-unsigned confusion if "
"you do this.)"
msgstr ""
"Для самого типа <type>oid</type> помимо сравнения определены всего несколько "
"операторов. Однако его можно привести к целому и затем задействовать в "
"обычных целочисленных вычислениях. (При этом следует опасаться путаницы со "
"знаковыми/беззнаковыми значениями.)"

#: datatype.xml:4392(programlisting)
#, no-wrap
msgid "SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;"
msgstr "SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;"

#: datatype.xml:4396(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM pg_attribute\n"
"  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');"
msgstr ""
"SELECT * FROM pg_attribute\n"
"  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');"

#: datatype.xml:4384(para)
msgid ""
"The OID alias types have no operations of their own except for specialized "
"input and output routines. These routines are able to accept and display "
"symbolic names for system objects, rather than the raw numeric value that "
"type <type>oid</type> would use. The alias types allow simplified lookup of "
"OID values for objects. For example, to examine the "
"<structname>pg_attribute</structname> rows related to a table "
"<literal>mytable</literal>, one could write: <placeholder-1/> rather than: "
"<placeholder-2/> While that doesn't look all that bad by itself, it's still "
"oversimplified. A far more complicated sub-select would be needed to select "
"the right OID if there are multiple tables named <literal>mytable</literal> "
"in different schemas. The <type>regclass</type> input converter handles the "
"table lookup according to the schema path setting, and so it does the "
"<quote>right thing</quote> automatically. Similarly, casting a table's OID "
"to <type>regclass</type> is handy for symbolic display of a numeric OID."
msgstr ""
"Типы-псевдонимы OID сами по себе не вводят новых операций и отличаются "
"только специализированными функциями ввода/вывода. Эти функции могут "
"принимать и выводить не просто числовые значения, как тип <type>oid</type>, "
"а символические имена системных объектов. Эти типы позволяют упростить поиск "
"объектов по значениям OID. Например, чтобы выбрать из "
"<structname>pg_attribute</structname> строки, относящиеся к таблице "
"<literal>mytable</literal>, можно написать: <placeholder-1/> вместо: "
"<placeholder-2/> Хотя второй вариант выглядит не таким уж плохим, но это "
"лишь очень простой запрос. Если же потребуется выбрать правильный OID, когда "
"таблица <literal>mytable</literal> есть в нескольких схемах, вложенный "
"подзапрос будет гораздо сложнее. Преобразователь вводимого значения типа "
"<type>regclass</type> находит таблицу согласно заданному пути поиска схем, "
"так что он делает <quote>всё правильно</quote> автоматически. Аналогично, "
"приведя идентификатор таблицы к типу <type>regclass</type>, можно получить "
"символическое представление числового кода."

#: datatype.xml:4416(entry)
msgid "References"
msgstr "Ссылки"

# msgid "References"
# msgstr "Применяется"
#: datatype.xml:4418(entry)
msgid "Value Example"
msgstr "Пример значения"

#: datatype.xml:4425(type)
msgid "oid"
msgstr "oid"

#: datatype.xml:4426(entry)
msgctxt "entry"
msgid "any"
msgstr "any"

# msgid "any"
# msgstr "везде"
#: datatype.xml:4427(entry)
msgid "numeric object identifier"
msgstr "числовой идентификатор объекта"

#: datatype.xml:4428(literal)
msgid "564182"
msgstr "564182"

#: datatype.xml:4432(type)
msgid "regproc"
msgstr "regproc"

#: datatype.xml:4433(structname) datatype.xml:4440(structname)
msgid "pg_proc"
msgstr "pg_proc"

#: datatype.xml:4434(entry)
msgid "function name"
msgstr "имя функции"

#: datatype.xml:4435(literal)
msgid "sum"
msgstr "sum"

#: datatype.xml:4439(type)
msgid "regprocedure"
msgstr "regprocedure"

#: datatype.xml:4441(entry)
msgid "function with argument types"
msgstr "функция с типами аргументов"

#: datatype.xml:4442(literal)
msgid "sum(int4)"
msgstr "sum(int4)"

#: datatype.xml:4446(type)
msgid "regoper"
msgstr "regoper"

#: datatype.xml:4447(structname) datatype.xml:4454(structname)
msgid "pg_operator"
msgstr "pg_operator"

#: datatype.xml:4448(entry)
msgid "operator name"
msgstr "имя оператора"

#: datatype.xml:4449(literal)
msgid "+"
msgstr "+"

#: datatype.xml:4453(type)
msgid "regoperator"
msgstr "regoperator"

#: datatype.xml:4455(entry)
msgid "operator with argument types"
msgstr "оператор с типами аргументов"

#: datatype.xml:4456(entry)
msgid ""
"<literal>*(integer,integer)</literal> or <literal>-(NONE,integer)</literal>"
msgstr ""
"<literal>*(integer,integer)</literal> или <literal>-(NONE,integer)</literal>"

#: datatype.xml:4460(type)
msgid "regclass"
msgstr "regclass"

#: datatype.xml:4461(structname)
msgid "pg_class"
msgstr "pg_class"

#: datatype.xml:4462(entry)
msgid "relation name"
msgstr "имя отношения"

#: datatype.xml:4463(literal)
msgctxt "literal"
msgid "pg_type"
msgstr "pg_type"

#: datatype.xml:4467(type)
msgid "regtype"
msgstr "regtype"

#: datatype.xml:4468(structname)
msgctxt "structname"
msgid "pg_type"
msgstr "pg_type"

#: datatype.xml:4469(entry)
msgid "data type name"
msgstr "имя типа данных"

#: datatype.xml:4470(literal)
msgctxt "literal"
msgid "integer"
msgstr "integer"

#: datatype.xml:4474(type)
msgid "regrole"
msgstr "regrole"

#: datatype.xml:4475(structname)
msgid "pg_authid"
msgstr "pg_authid"

#: datatype.xml:4476(entry)
msgid "role name"
msgstr "имя роли"

#: datatype.xml:4477(literal)
msgid "smithee"
msgstr "smithee"

#: datatype.xml:4481(type)
msgid "regnamespace"
msgstr "regnamespace"

#: datatype.xml:4482(structname)
msgid "pg_namespace"
msgstr "pg_namespace"

#: datatype.xml:4483(entry)
msgid "namespace name"
msgstr "пространство имён"

#: datatype.xml:4484(literal)
msgid "pg_catalog"
msgstr "pg_catalog"

#: datatype.xml:4488(type)
msgid "regconfig"
msgstr "regconfig"

#: datatype.xml:4489(structname)
msgid "pg_ts_config"
msgstr "pg_ts_config"

#: datatype.xml:4490(entry)
msgid "text search configuration"
msgstr "конфигурация текстового поиска"

#: datatype.xml:4491(literal)
msgid "english"
msgstr "english"

#: datatype.xml:4495(type)
msgid "regdictionary"
msgstr "regdictionary"

#: datatype.xml:4496(structname)
msgid "pg_ts_dict"
msgstr "pg_ts_dict"

#: datatype.xml:4497(entry)
msgid "text search dictionary"
msgstr "словарь текстового поиска"

#: datatype.xml:4498(literal)
msgid "simple"
msgstr "simple"

#: datatype.xml:4504(para)
msgid ""
"All of the OID alias types for objects grouped by namespace accept schema-"
"qualified names, and will display schema-qualified names on output if the "
"object would not be found in the current search path without being "
"qualified. The <type>regproc</type> and <type>regoper</type> alias types "
"will only accept input names that are unique (not overloaded), so they are "
"of limited use; for most uses <type>regprocedure</type> or "
"<type>regoperator</type> are more appropriate. For <type>regoperator</type>, "
"unary operators are identified by writing <literal>NONE</literal> for the "
"unused operand."
msgstr ""
"Все типы псевдонимов OID для объектов, сгруппированных в пространство имён, "
"принимают имена, дополненные именем схемы, и выводят имена со схемой, если "
"данный объект нельзя будет найти в текущем пути поиска без имени схемы. Типы "
"<type>regproc</type> и <type>regoper</type> принимают только уникальные "
"вводимые имена (не перегруженные), что ограничивает их применимость; в "
"большинстве случаев лучше использовать <type>regprocedure</type> или "
"<type>regoperator</type>. Для типа <type>regoperator</type> в записи "
"унарного оператора неиспользуемый операнд заменяется словом <literal>NONE</"
"literal>."

#: datatype.xml:4517(para)
msgid ""
"An additional property of most of the OID alias types is the creation of "
"dependencies. If a constant of one of these types appears in a stored "
"expression (such as a column default expression or view), it creates a "
"dependency on the referenced object. For example, if a column has a default "
"expression <literal>nextval('my_seq'::regclass)</literal>, "
"<productname>PostgreSQL</productname> understands that the default "
"expression depends on the sequence <literal>my_seq</literal>; the system "
"will not let the sequence be dropped without first removing the default "
"expression. <type>regrole</type> is the only exception for the property. "
"Constants of this type are not allowed in such expressions."
msgstr ""
"Дополнительным свойством большинства типов псевдонимов OID является "
"образование зависимостей. Когда в сохранённом выражении фигурирует константа "
"одного из этих типов (например, в представлении или в значении столбца по "
"умолчанию), это создаёт зависимость от целевого объекта. Например, если "
"значение по умолчанию определяется выражением <literal>nextval('my_seq'::"
"regclass)</literal>, <productname>PostgreSQL</productname> понимает, что это "
"выражение зависит от последовательности <literal>my_seq</literal>, и не "
"позволит удалить последовательность раньше, чем будет удалено это выражение. "
"Единственным ограничением является тип <type>regrole</type>. Константы этого "
"типа в таких выражениях не допускаются."

#: datatype.xml:4533(para)
msgid ""
"The OID alias types do not completely follow transaction isolation rules. "
"The planner also treats them as simple constants, which may result in sub-"
"optimal planning."
msgstr ""
"Типы псевдонимов OID не полностью следуют правилам изоляции транзакций. "
"Планировщик тоже воспринимает их как простые константы, что может привести к "
"неоптимальному планированию запросов."

#: datatype.xml:4540(para)
msgid ""
"Another identifier type used by the system is <type>xid</type>, or "
"transaction (abbreviated <abbrev>xact</abbrev>) identifier. This is the data "
"type of the system columns <structfield>xmin</structfield> and "
"<structfield>xmax</structfield>. Transaction identifiers are 32-bit "
"quantities."
msgstr ""
"Есть ещё один тип системных идентификаторов, <type>xid</type>, "
"представляющий идентификатор транзакции (сокращённо <abbrev>xact</abbrev>). "
"Этот тип имеют системные столбцы <structfield>xmin</structfield> и "
"<structfield>xmax</structfield>. Идентификаторы транзакций определяются 32-"
"битными числами."

#: datatype.xml:4546(para)
msgid ""
"A third identifier type used by the system is <type>cid</type>, or command "
"identifier. This is the data type of the system columns <structfield>cmin</"
"structfield> and <structfield>cmax</structfield>. Command identifiers are "
"also 32-bit quantities."
msgstr ""
"Третий тип идентификаторов, используемых в системе, &mdash; <type>cid</"
"type>, идентификатор команды (command identifier). Этот тип данных имеют "
"системные столбцы <structfield>cmin</structfield> и <structfield>cmax</"
"structfield>. Идентификаторы команд &mdash; это тоже 32-битные числа."

#: datatype.xml:4552(para)
msgid ""
"A final identifier type used by the system is <type>tid</type>, or tuple "
"identifier (row identifier). This is the data type of the system column "
"<structfield>ctid</structfield>. A tuple ID is a pair (block number, tuple "
"index within block) that identifies the physical location of the row within "
"its table."
msgstr ""
"И наконец, последний тип системных идентификаторов &mdash; <type>tid</type>, "
"идентификатор строки/кортежа (tuple identifier). Этот тип данных имеет "
"системный столбец <structfield>ctid</structfield>. Идентификатор кортежа "
"представляет собой пару (из номера блока и индекса кортежа в блоке), "
"идентифицирующую физическое расположение строки в таблице."

#: datatype.xml:4560(para)
msgid ""
"(The system columns are further explained in <xref linkend=\"ddl-system-"
"columns\"/>.)"
msgstr ""
"(Подробнее о системных столбцах рассказывается в <xref remap=\"6\" linkend="
"\"ddl-system-columns\"/>.)"

#: datatype.xml:4567(acronym)
msgid "pg_lsn Type"
msgstr "Тип pg_lsn"

#: datatype.xml:4569(indexterm)
msgid "<primary>pg_lsn</primary>"
msgstr "<primary>pg_lsn</primary>"

#: datatype.xml:4573(para)
msgid ""
"The <type>pg_lsn</type> data type can be used to store LSN (Log Sequence "
"Number) data which is a pointer to a location in the XLOG. This type is a "
"representation of <type>XLogRecPtr</type> and an internal system type of "
"<productname>PostgreSQL</productname>."
msgstr ""
"Тип данных <type>pg_lsn</type> может применяться для хранения значения LSN "
"(последовательный номер в журнале, Log Sequence Number), которое "
"представляет собой указатель на позицию в журнале транзакций (XLOG). Это тип "
"содержит <type>XLogRecPtr</type> и является внутренним системным типом "
"<productname>PostgreSQL</productname>."

#: datatype.xml:4580(para)
msgid ""
"Internally, an LSN is a 64-bit integer, representing a byte position in the "
"write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 "
"digits each, separated by a slash; for example, <literal>16/B374D848</"
"literal>. The <type>pg_lsn</type> type supports the standard comparison "
"operators, like <literal>=</literal> and <literal>&gt;</literal>. Two LSNs "
"can be subtracted using the <literal>-</literal> operator; the result is the "
"number of bytes separating those write-ahead log positions."
msgstr ""
"Технически LSN &mdash; это 64-битное целое, представляющее байтовое смещение "
"в потоке журнала упреждающей записи. Он выводится в виде двух "
"шестнадцатеричных чисел до 8 цифр каждое, через косую черту, например: "
"<literal>16/B374D848</literal>. Тип <type>pg_lsn</type> поддерживает "
"стандартные операторы сравнения, такие как <literal>=</literal> и "
"<literal>&gt;</literal>. Можно также вычесть один LSN из другого с помощью "
"оператора <literal>-</literal>; результатом будет число байт между этими "
"двумя позициями в журнале транзакций."

#: datatype.xml:4593(title) datatype.xml:4681(title)
msgid "Pseudo-Types"
msgstr "Псевдотипы"

#: datatype.xml:4595(indexterm)
msgid "<primary>record</primary>"
msgstr "<primary>record</primary>"

#: datatype.xml:4599(indexterm)
msgid "<primary>any</primary>"
msgstr "<primary>any</primary>"

#: datatype.xml:4603(indexterm)
msgid "<primary>anyelement</primary>"
msgstr "<primary>anyelement</primary>"

#: datatype.xml:4607(indexterm)
msgid "<primary>anyarray</primary>"
msgstr "<primary>anyarray</primary>"

#: datatype.xml:4611(indexterm)
msgid "<primary>anynonarray</primary>"
msgstr "<primary>anynonarray</primary>"

#: datatype.xml:4615(indexterm)
msgid "<primary>anyenum</primary>"
msgstr "<primary>anyenum</primary>"

#: datatype.xml:4619(indexterm)
msgid "<primary>anyrange</primary>"
msgstr "<primary>anyrange</primary>"

#: datatype.xml:4623(indexterm)
msgid "<primary>void</primary>"
msgstr "<primary>void</primary>"

#: datatype.xml:4627(indexterm)
msgid "<primary>trigger</primary>"
msgstr "<primary>trigger</primary>"

#: datatype.xml:4631(indexterm)
msgid "<primary>event_trigger</primary>"
msgstr "<primary>event_trigger</primary>"

#: datatype.xml:4635(indexterm)
msgid "<primary>pg_ddl_command</primary>"
msgstr "<primary>pg_ddl_command</primary>"

#: datatype.xml:4639(indexterm)
msgid "<primary>language_handler</primary>"
msgstr "<primary>language_handler</primary>"

#: datatype.xml:4643(indexterm)
msgid "<primary>fdw_handler</primary>"
msgstr "<primary>fdw_handler</primary>"

#: datatype.xml:4647(indexterm)
msgid "<primary>index_am_handler</primary>"
msgstr "<primary>index_am_handler</primary>"

#: datatype.xml:4651(indexterm)
msgid "<primary>tsm_handler</primary>"
msgstr "<primary>tsm_handler</primary>"

#: datatype.xml:4655(indexterm)
msgid "<primary>cstring</primary>"
msgstr "<primary>cstring</primary>"

#: datatype.xml:4659(indexterm)
msgid "<primary>internal</primary>"
msgstr "<primary>internal</primary>"

#: datatype.xml:4663(indexterm)
msgid "<primary>opaque</primary>"
msgstr "<primary>opaque</primary>"

#: datatype.xml:4667(para)
msgid ""
"The <productname>PostgreSQL</productname> type system contains a number of "
"special-purpose entries that are collectively called <firstterm>pseudo-"
"types</firstterm>. A pseudo-type cannot be used as a column data type, but "
"it can be used to declare a function's argument or result type. Each of the "
"available pseudo-types is useful in situations where a function's behavior "
"does not correspond to simply taking or returning a value of a specific "
"<acronym>SQL</acronym> data type. <xref linkend=\"datatype-pseudotypes-table"
"\"/> lists the existing pseudo-types."
msgstr ""
"В систему типов <productname>PostgreSQL</productname> включены несколько "
"специальных элементов, которые в совокупности называются "
"<firstterm>псевдотипами</firstterm>. Псевдотип нельзя использовать в "
"качестве типа данных столбца, но можно объявить функцию с аргументом или "
"результатом такого типа. Каждый из существующих псевдотипов полезен в "
"ситуациях, когда характер функции не позволяет просто получить или вернуть "
"определённый тип данных <acronym>SQL</acronym>. Все существующие псевдотипы "
"перечислены в <xref remap=\"6\" linkend=\"datatype-pseudotypes-table\"/>."

#: datatype.xml:4692(type)
msgctxt "type"
msgid "any"
msgstr "any"

#: datatype.xml:4693(entry)
msgid "Indicates that a function accepts any input data type."
msgstr "Указывает, что функция принимает любой вводимый тип данных."

#: datatype.xml:4697(type)
msgid "anyelement"
msgstr "anyelement"

#: datatype.xml:4698(entry)
msgid ""
"Indicates that a function accepts any data type (see <xref linkend=\"extend-"
"types-polymorphic\"/>)."
msgstr ""
"Указывает, что функция принимает любой тип данных (см. <xref remap=\"4\" "
"linkend=\"extend-types-polymorphic\"/>)."

#: datatype.xml:4703(type)
msgid "anyarray"
msgstr "anyarray"

#: datatype.xml:4704(entry)
msgid ""
"Indicates that a function accepts any array data type (see <xref linkend="
"\"extend-types-polymorphic\"/>)."
msgstr ""
"Указывает, что функция принимает любой тип массива (см. <xref remap=\"4\" "
"linkend=\"extend-types-polymorphic\"/>)."

#: datatype.xml:4709(type)
msgid "anynonarray"
msgstr "anynonarray"

#: datatype.xml:4710(entry)
msgid ""
"Indicates that a function accepts any non-array data type (see <xref linkend="
"\"extend-types-polymorphic\"/>)."
msgstr ""
"Указывает, что функция принимает любой тип данных, кроме массивов (см. <xref "
"remap=\"4\" linkend=\"extend-types-polymorphic\"/>)."

#: datatype.xml:4715(type)
msgid "anyenum"
msgstr "anyenum"

#: datatype.xml:4716(entry)
msgid ""
"Indicates that a function accepts any enum data type (see <xref linkend="
"\"extend-types-polymorphic\"/> and <xref linkend=\"datatype-enum\"/>)."
msgstr ""
"Указывает, что функция принимает любое перечисление (см. <xref remap=\"4\" "
"linkend=\"extend-types-polymorphic\"/> и <xref remap=\"4\" linkend="
"\"datatype-enum\"/>)."

#: datatype.xml:4722(type)
msgid "anyrange"
msgstr "anyrange"

#: datatype.xml:4723(entry)
msgid ""
"Indicates that a function accepts any range data type (see <xref linkend="
"\"extend-types-polymorphic\"/> and <xref linkend=\"rangetypes\"/>)."
msgstr ""
"Указывает, что функция принимает любой диапазонный тип данных (см. <xref "
"remap=\"4\" linkend=\"extend-types-polymorphic\"/> и <xref remap=\"4\" "
"linkend=\"rangetypes\"/>)."

#: datatype.xml:4729(type)
msgid "cstring"
msgstr "cstring"

#: datatype.xml:4730(entry)
msgid ""
"Indicates that a function accepts or returns a null-terminated C string."
msgstr "Указывает, что функция принимает или возвращает строку в стиле C."

#: datatype.xml:4734(type)
msgid "internal"
msgstr "internal"

#: datatype.xml:4735(entry)
msgid ""
"Indicates that a function accepts or returns a server-internal data type."
msgstr ""
"Указывает, что функция принимает или возвращает внутренний серверный тип "
"данных."

#: datatype.xml:4740(type)
msgid "language_handler"
msgstr "language_handler"

#: datatype.xml:4741(entry)
msgid ""
"A procedural language call handler is declared to return "
"<type>language_handler</type>."
msgstr ""
"Обработчик процедурного языка объявляется как возвращающий тип "
"<type>language_handler</type>."

#: datatype.xml:4745(type)
msgid "fdw_handler"
msgstr "fdw_handler"

#: datatype.xml:4746(entry)
msgid ""
"A foreign-data wrapper handler is declared to return <type>fdw_handler</"
"type>."
msgstr ""
"Обработчик обёртки сторонних данных объявляется как возвращающий тип "
"<type>fdw_handler</type>."

#: datatype.xml:4750(type)
msgid "index_am_handler"
msgstr "index_am_handler"

#: datatype.xml:4751(entry)
msgid ""
"An index access method handler is declared to return <type>index_am_handler</"
"type>."
msgstr ""
"Обработчик метода доступа индекса объявляется как возвращающий тип "
"<type>index_am_handler</type>."

#: datatype.xml:4755(type)
msgid "tsm_handler"
msgstr "tsm_handler"

#: datatype.xml:4756(entry)
msgid ""
"A tablesample method handler is declared to return <type>tsm_handler</type>."
msgstr ""
"Обработчик метода выборки из таблицы объявляется как возвращающий тип "
"<type>tsm_handler</type>."

#: datatype.xml:4760(type)
msgid "record"
msgstr "record"

#: datatype.xml:4761(entry)
msgid "Identifies a function taking or returning an unspecified row type."
msgstr ""
"Указывает, что функция принимает или возвращает неопределённый тип строки."

#: datatype.xml:4765(type)
msgid "trigger"
msgstr "trigger"

#: datatype.xml:4766(entry)
msgid "A trigger function is declared to return <type>trigger.</type>"
msgstr ""
"Триггерная функция объявляется как возвращающая тип <type>trigger</type>."

#: datatype.xml:4770(type)
msgid "event_trigger"
msgstr "event_trigger"

#: datatype.xml:4771(entry)
msgid ""
"An event trigger function is declared to return <type>event_trigger.</type>"
msgstr ""
"Функция событийного триггера объявляется как возвращающая тип "
"<type>event_trigger</type>."

#: datatype.xml:4775(type)
msgid "pg_ddl_command"
msgstr "pg_ddl_command"

#: datatype.xml:4776(entry)
msgid ""
"Identifies a representation of DDL commands that is available to event "
"triggers."
msgstr "Обозначает представление команд DDL, доступное событийным триггерам."

#: datatype.xml:4780(type)
msgid "void"
msgstr "void"

#: datatype.xml:4781(entry)
msgid "Indicates that a function returns no value."
msgstr "Указывает, что функция не возвращает значение."

#: datatype.xml:4785(type)
msgid "opaque"
msgstr "opaque"

#: datatype.xml:4786(entry)
msgid "An obsolete type name that formerly served all the above purposes."
msgstr ""
"Устаревший тип, который раньше использовался во всех вышеперечисленных "
"случаях."

#: datatype.xml:4792(para)
msgid ""
"Functions coded in C (whether built-in or dynamically loaded) can be "
"declared to accept or return any of these pseudo data types. It is up to the "
"function author to ensure that the function will behave safely when a pseudo-"
"type is used as an argument type."
msgstr ""
"Функции, написанные на языке C (встроенные или динамически загружаемые), "
"могут быть объявлены с параметрами или результатами любого из этих типов. "
"Ответственность за безопасное поведение функции с аргументами таких типов "
"ложится на разработчика функции."

#: datatype.xml:4799(para)
msgid ""
"Functions coded in procedural languages can use pseudo-types only as allowed "
"by their implementation languages. At present most procedural languages "
"forbid use of a pseudo-type as an argument type, and allow only <type>void</"
"type> and <type>record</type> as a result type (plus <type>trigger</type> or "
"<type>event_trigger</type> when the function is used as a trigger or event "
"trigger). Some also support polymorphic functions using the types "
"<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, "
"<type>anyenum</type>, and <type>anyrange</type>."
msgstr ""
"Функции, написанные на процедурных языках, могут использовать псевдотипы, "
"только если это позволяет соответствующий язык. В настоящее время "
"большинство процедурных языков запрещают использовать псевдотипы в качестве "
"типа аргумента и позволяют использовать для результатов только типы "
"<type>void</type> и <type>record</type> (и <type>trigger</type> или "
"<type>event_trigger</type>, когда функция реализует триггер или событийный "
"триггер). Некоторые языки также поддерживают полиморфные функции с типами "
"<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, "
"<type>anyenum</type> и <type>anyrange</type>."

#: datatype.xml:4811(para)
msgid ""
"The <type>internal</type> pseudo-type is used to declare functions that are "
"meant only to be called internally by the database system, and not by direct "
"invocation in an <acronym>SQL</acronym> query. If a function has at least "
"one <type>internal</type>-type argument then it cannot be called from "
"<acronym>SQL</acronym>. To preserve the type safety of this restriction it "
"is important to follow this coding rule: do not create any function that is "
"declared to return <type>internal</type> unless it has at least one "
"<type>internal</type> argument."
msgstr ""
"Псевдотип <type>internal</type> используется в объявлениях функций, "
"предназначенных только для внутреннего использования в СУБД, но не для "
"прямого вызова в запросах <acronym>SQL</acronym>. Если у функции есть как "
"хотя бы один аргумент типа <type>internal</type>, её нельзя будет вызывать "
"из <acronym>SQL</acronym>. Чтобы сохранить типобезопасность при таком "
"ограничении, следуйте важному правилу: не создавайте функцию, возвращающую "
"результат типа <type>internal</type>, если у неё нет ни одного аргумента "
"<type>internal</type>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: datatype.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "Here are some examples: <placeholder-1/> The last example demonstrates "
#~ "that <type>tsquery</type> sometimes rearranges nested operators into a "
#~ "logically equivalent formulation."
#~ msgstr ""
#~ "Несколько примеров: <placeholder-1/> Последний пример показывает, что "
#~ "<type>tsquery</type> иногда переставляет вложенные операторы, получая "
#~ "логически равнозначную формулировку."

#~ msgid ""
#~ "SELECT to_tsquery('postgres:*');\n"
#~ " to_tsquery \n"
#~ "------------\n"
#~ " 'postgr':*\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT to_tsquery('postgres:*');\n"
#~ " to_tsquery \n"
#~ "------------\n"
#~ " 'postgr':*\n"
#~ "(1 row)"
