# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: mvcc.xml:5(title)
msgid "Concurrency Control"
msgstr "Управление конкурентным доступом"

#: mvcc.xml:7(indexterm)
msgid "<primary>concurrency</primary>"
msgstr "<primary>конкурентный доступ</primary>"

#: mvcc.xml:11(para)
msgid ""
"This chapter describes the behavior of the <productname>PostgreSQL</"
"productname> database system when two or more sessions try to access the "
"same data at the same time. The goals in that situation are to allow "
"efficient access for all sessions while maintaining strict data integrity. "
"Every developer of database applications should be familiar with the topics "
"covered in this chapter."
msgstr ""
"В этой главе описывается поведение СУБД <productname>PostgreSQL</"
"productname> в ситуациях, когда два или более сеансов пытаются одновременно "
"обратиться к одним и тем же данным. В таких ситуациях важно, чтобы все "
"сеансы могли эффективно работать с данными, и при этом сохранялась "
"целостность данных. Обсуждаемые в этой главе темы заслуживают внимания всех "
"разработчиков баз данных."

#: mvcc.xml:22(title)
msgid "Introduction"
msgstr "Введение"

#: mvcc.xml:24(indexterm)
msgid "<primary>Multiversion Concurrency Control</primary>"
msgstr "<primary>Многоверсионное управление конкурентным доступом</primary>"

#: mvcc.xml:28(indexterm)
msgid "<primary>MVCC</primary>"
msgstr "<primary>MVCC</primary>"

#: mvcc.xml:32(indexterm)
msgid "<primary>Serializable Snapshot Isolation</primary>"
msgstr "<primary>Сериализуемая изоляция снимков</primary>"

#: mvcc.xml:36(indexterm)
msgid "<primary>SSI</primary>"
msgstr "<primary>SSI</primary>"

#: mvcc.xml:40(para)
msgid ""
"<productname>PostgreSQL</productname> provides a rich set of tools for "
"developers to manage concurrent access to data. Internally, data consistency "
"is maintained by using a multiversion model (Multiversion Concurrency "
"Control, <acronym>MVCC</acronym>). This means that each SQL statement sees a "
"snapshot of data (a <firstterm>database version</firstterm>) as it was some "
"time ago, regardless of the current state of the underlying data. This "
"prevents statements from viewing inconsistent data produced by concurrent "
"transactions performing updates on the same data rows, providing "
"<firstterm>transaction isolation</firstterm> for each database session. "
"<acronym>MVCC</acronym>, by eschewing the locking methodologies of "
"traditional database systems, minimizes lock contention in order to allow "
"for reasonable performance in multiuser environments."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет разработчикам богатый "
"набор средств для управления конкурентным доступом к данным. Внутри он "
"поддерживает целостность данных, реализуя модель <acronym>MVCC</acronym> "
"(Multiversion Concurrency Control, Многоверсионное управление конкурентным "
"доступом). Это означает, что каждый SQL-оператор видит снимок данных "
"(<firstterm>версию базы данных</firstterm>) на определённый момент времени, "
"вне зависимости от текущего состояния данных. Это защищает операторы от "
"несогласованности данных, возможной, если другие конкурирующие транзакции "
"внесут изменения в те же строки данных, и обеспечивает тем самым "
"<firstterm>изоляцию транзакций</firstterm> для каждого сеанса баз данных. "
"<acronym>MVCC</acronym>, отходя от методик блокирования, принятых в "
"традиционных СУБД, снижает уровень конфликтов блокировок и таким образом "
"обеспечивает более высокую производительность в многопользовательской среде."

#: mvcc.xml:58(para)
msgid ""
"The main advantage of using the <acronym>MVCC</acronym> model of concurrency "
"control rather than locking is that in <acronym>MVCC</acronym> locks "
"acquired for querying (reading) data do not conflict with locks acquired for "
"writing data, and so reading never blocks writing and writing never blocks "
"reading. <productname>PostgreSQL</productname> maintains this guarantee even "
"when providing the strictest level of transaction isolation through the use "
"of an innovative <firstterm>Serializable Snapshot Isolation</firstterm> "
"(<acronym>SSI</acronym>) level."
msgstr ""
"Основное преимущество использования модели <acronym>MVCC</acronym> по "
"сравнению с блокированием заключается в том, что блокировки <acronym>MVCC</"
"acronym>, полученные для чтения данных, не конфликтуют с блокировками, "
"полученными для записи, и поэтому чтение никогда не мешает записи, а запись "
"чтению. <productname>PostgreSQL</productname> гарантирует это даже для "
"самого строгого уровня изоляции транзакций, используя инновационный уровень "
"изоляции <acronym>SSI</acronym> (<firstterm>Serializable Snapshot Isolation</"
"firstterm>, Сериализуемая изоляция снимков)."

#: mvcc.xml:70(para)
msgid ""
"Table- and row-level locking facilities are also available in "
"<productname>PostgreSQL</productname> for applications which don't generally "
"need full transaction isolation and prefer to explicitly manage particular "
"points of conflict. However, proper use of <acronym>MVCC</acronym> will "
"generally provide better performance than locks. In addition, application-"
"defined advisory locks provide a mechanism for acquiring locks that are not "
"tied to a single transaction."
msgstr ""
"Для приложений, которым в принципе не нужна полная изоляция транзакций и "
"которые предпочитают явно определять точки конфликтов, в "
"<productname>PostgreSQL</productname> также есть средства блокировки на "
"уровне таблиц и строк. Однако при правильном использовании <acronym>MVCC</"
"acronym> обычно обеспечивает лучшую производительность, чем блокировки. "
"Кроме этого, приложения могут использовать рекомендательные блокировки, не "
"привязанные к какой-либо одной транзакции."

#: mvcc.xml:83(title)
msgid "Transaction Isolation"
msgstr "Изоляция транзакций"

#: mvcc.xml:85(indexterm)
msgid "<primary>transaction isolation</primary>"
msgstr "<primary>изоляция транзакций</primary>"

#: mvcc.xml:89(para)
msgid ""
"The <acronym>SQL</acronym> standard defines four levels of transaction "
"isolation. The most strict is Serializable, which is defined by the standard "
"in a paragraph which says that any concurrent execution of a set of "
"Serializable transactions is guaranteed to produce the same effect as "
"running them one at a time in some order. The other three levels are defined "
"in terms of phenomena, resulting from interaction between concurrent "
"transactions, which must not occur at each level. The standard notes that "
"due to the definition of Serializable, none of these phenomena are possible "
"at that level. (This is hardly surprising -- if the effect of the "
"transactions must be consistent with having been run one at a time, how "
"could you see any phenomena caused by interactions?)"
msgstr ""
"Стандарт <acronym>SQL</acronym> определяет четыре уровня изоляции "
"транзакций. Наиболее строгий из них &mdash; сериализуемый, определяется "
"одним абзацем, говорящем, что при параллельном выполнении несколько "
"сериализуемых транзакций должны гарантированно выдавать такой же результат, "
"как если бы они запускались по очереди в некотором порядке. Остальные три "
"уровня определяются через описания особых явлений, которые возможны при "
"взаимодействии параллельных транзакций, но не допускаются на определённом "
"уровне. Как отмечается в стандарте, из определения сериализуемого уровня "
"вытекает, что на этом уровне ни одно из этих явлений не возможно. (В самом "
"деле &mdash; если эффект транзакций должен быть тем же, что и при их "
"выполнении по очереди, как можно было бы увидеть особые явления, связанные с "
"другими транзакциями?)"

#: mvcc.xml:111(indexterm)
msgid "<primary>dirty read</primary>"
msgstr "<primary>&laquo;грязное&raquo; чтение</primary>"

#: mvcc.xml:109(term)
msgid "dirty read <placeholder-1/>"
msgstr "&laquo;грязное&raquo; чтение<placeholder-1/>"

#: mvcc.xml:114(para)
msgid ""
"A transaction reads data written by a concurrent uncommitted transaction."
msgstr ""
"Транзакция читает данные, записанные параллельной незавершённой транзакцией."

#: mvcc.xml:123(indexterm)
msgid "<primary>nonrepeatable read</primary>"
msgstr "<primary>неповторяемое чтение</primary>"

#: mvcc.xml:121(term)
msgid "nonrepeatable read <placeholder-1/>"
msgstr "неповторяемое чтение<placeholder-1/>"

#: mvcc.xml:126(para)
msgid ""
"A transaction re-reads data it has previously read and finds that data has "
"been modified by another transaction (that committed since the initial read)."
msgstr ""
"Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что "
"они были изменены другой транзакцией (которая завершилась после первого "
"чтения)."

#: mvcc.xml:137(indexterm)
msgid "<primary>phantom read</primary>"
msgstr "<primary>фантомное чтение</primary>"

#: mvcc.xml:135(term)
msgid "phantom read <placeholder-1/>"
msgstr "фантомное чтение<placeholder-1/>"

#: mvcc.xml:140(para)
msgid ""
"A transaction re-executes a query returning a set of rows that satisfy a "
"search condition and finds that the set of rows satisfying the condition has "
"changed due to another recently-committed transaction."
msgstr ""
"Транзакция повторно выполняет запрос, возвращающий набор строк для "
"некоторого условия, и обнаруживает, что набор строк, удовлетворяющих "
"условию, изменился из-за транзакции, завершившейся за это время."

#: mvcc.xml:151(indexterm) mvcc.xml:565(indexterm)
msgid "<primary>serialization anomaly</primary>"
msgstr "<primary>аномалия сериализации</primary>"

#: mvcc.xml:149(term)
msgid "serialization anomaly <placeholder-1/>"
msgstr "аномалия сериализации <placeholder-1/>"

#: mvcc.xml:154(para)
msgid ""
"The result of successfully committing a group of transactions is "
"inconsistent with all possible orderings of running those transactions one "
"at a time."
msgstr ""
"Результат успешной фиксации группы транзакций оказывается несогласованным "
"при всевозможных вариантах исполнения этих транзакций по очереди."

#: mvcc.xml:104(para)
msgid ""
"The phenomena which are prohibited at various levels are: <placeholder-1/>"
msgstr ""
"Стандарт описывает следующие особые условия, недопустимые для различных "
"уровней изоляции: <placeholder-1/>"

#: mvcc.xml:165(indexterm)
msgid "<primary>transaction isolation level</primary>"
msgstr "<primary>уровень изоляции транзакций</primary>"

#: mvcc.xml:164(para)
msgid ""
"<placeholder-1/> The SQL standard and PostgreSQL-implemented transaction "
"isolation levels are described in <xref linkend=\"mvcc-isolevel-table\"/>."
msgstr ""
"<placeholder-1/> Уровни изоляции транзакций, описанные в стандарте SQL и "
"реализованные в PostgreSQL, описываются в <xref remap=\"6\" linkend=\"mvcc-"
"isolevel-table\"/>."

#: mvcc.xml:173(title)
msgid "Transaction Isolation Levels"
msgstr "Уровни изоляции транзакций"

#: mvcc.xml:177(entry)
msgid "Isolation Level"
msgstr "Уровень изоляции"

#: mvcc.xml:180(entry)
msgid "Dirty Read"
msgstr "&laquo;Грязное&raquo; чтение"

#: mvcc.xml:183(entry)
msgid "Nonrepeatable Read"
msgstr "Неповторяемое чтение"

#: mvcc.xml:186(entry)
msgid "Phantom Read"
msgstr "Фантомное чтение"

#: mvcc.xml:189(entry)
msgid "Serialization Anomaly"
msgstr "Аномалия сериализации"

#: mvcc.xml:196(entry)
msgid "Read uncommitted"
msgstr "Read uncommited (Чтение незафиксированных данных)"

#: mvcc.xml:199(entry) mvcc.xml:241(entry)
msgid "Allowed, but not in PG"
msgstr "Допускается, но не в PG"

#: mvcc.xml:202(entry) mvcc.xml:205(entry) mvcc.xml:208(entry)
#: mvcc.xml:220(entry) mvcc.xml:223(entry) mvcc.xml:226(entry)
#: mvcc.xml:244(entry)
msgid "Possible"
msgstr "Возможно"

#: mvcc.xml:214(entry)
msgid "Read committed"
msgstr "Read committed (Чтение зафиксированных данных)"

#: mvcc.xml:217(entry) mvcc.xml:235(entry) mvcc.xml:238(entry)
#: mvcc.xml:253(entry) mvcc.xml:256(entry) mvcc.xml:259(entry)
#: mvcc.xml:262(entry)
msgid "Not possible"
msgstr "Невозможно"

#: mvcc.xml:232(entry)
msgid "Repeatable read"
msgstr "Repeatable read (Повторяемое чтение)"

#: mvcc.xml:250(entry)
msgid "Serializable"
msgstr "Serializable (Сериализуемость)"

#: mvcc.xml:270(para)
msgid ""
"In <productname>PostgreSQL</productname>, you can request any of the four "
"standard transaction isolation levels, but internally only three distinct "
"isolation levels are implemented, i.e. PostgreSQL's Read Uncommitted mode "
"behaves like Read Committed. This is because it is the only sensible way to "
"map the standard isolation levels to PostgreSQL's multiversion concurrency "
"control architecture."
msgstr ""
"В <productname>PostgreSQL</productname> вы можете запросить любой из четырёх "
"уровней изоляции транзакций, однако внутри реализованы только три различных "
"уровня, то есть режим Read Uncommitted в PostgreSQL действует как Read "
"Committed. Причина этого в том, что только так можно сопоставить стандартные "
"уровни изоляции с реализованной в PostgreSQL архитектурой многоверсионного "
"управления конкурентным доступом."

#: mvcc.xml:279(para)
msgid ""
"The table also shows that PostgreSQL's Repeatable Read implementation does "
"not allow phantom reads. Stricter behavior is permitted by the SQL standard: "
"the four isolation levels only define which phenomena must not happen, not "
"which phenomena <emphasis>must</emphasis> happen. The behavior of the "
"available isolation levels is detailed in the following subsections."
msgstr ""
"В этой таблице также показано, что реализация Repeatable Read в PostgreSQL "
"не допускает фантомное чтение. Стандарт SQL допускает возможность более "
"строгого поведения: четыре уровня изоляции определяют только, какие особые "
"условия не должны наблюдаться, но не какие <emphasis>обязательно должны</"
"emphasis>. Поведение имеющихся уровней изоляции подробно описывается в "
"следующих подразделах."

#: mvcc.xml:288(para)
msgid ""
"To set the transaction isolation level of a transaction, use the command "
"<xref linkend=\"sql-set-transaction\"/>."
msgstr ""
"Для выбора нужного уровня изоляции транзакций используется команда <xref "
"linkend=\"sql-set-transaction\"/>."

#: mvcc.xml:294(para)
msgid ""
"Some <productname>PostgreSQL</productname> data types and functions have "
"special rules regarding transactional behavior. In particular, changes made "
"to a sequence (and therefore the counter of a column declared using "
"<type>serial</type>) are immediately visible to all other transactions and "
"are not rolled back if the transaction that made the changes aborts. See "
"<xref linkend=\"functions-sequence\"/> and <xref linkend=\"datatype-serial\"/"
">."
msgstr ""
"Поведение некоторых функций и типов данных <productname>PostgreSQL</"
"productname> в транзакциях подчиняется особым правилам. В частности, "
"изменения последовательностей (и следовательно, счётчика в столбце, "
"объявленному как <type>serial</type>) немедленно видны во всех остальных "
"транзакциях и не откатываются назад, если выполнившая их транзакция "
"прерывается. См. <xref remap=\"4\" linkend=\"functions-sequence\"/> и <xref "
"remap=\"4\" linkend=\"datatype-serial\"/>."

#: mvcc.xml:306(title)
msgid "Read Committed Isolation Level"
msgstr "Уровень изоляции Read Committed"

#: mvcc.xml:308(indexterm)
msgid ""
"<primary>transaction isolation level</primary> <secondary>read committed</"
"secondary>"
msgstr ""
"<primary>уровень изоляции транзакций</primary> <secondary>read committed</"
"secondary>"

#: mvcc.xml:313(indexterm)
msgid "<primary>read committed</primary>"
msgstr "<primary>read committed</primary>"

#: mvcc.xml:317(para)
msgid ""
"<firstterm>Read Committed</firstterm> is the default isolation level in "
"<productname>PostgreSQL</productname>. When a transaction uses this "
"isolation level, a <command>SELECT</command> query (without a <literal>FOR "
"UPDATE/SHARE</literal> clause) sees only data committed before the query "
"began; it never sees either uncommitted data or changes committed during "
"query execution by concurrent transactions. In effect, a <command>SELECT</"
"command> query sees a snapshot of the database as of the instant the query "
"begins to run. However, <command>SELECT</command> does see the effects of "
"previous updates executed within its own transaction, even though they are "
"not yet committed. Also note that two successive <command>SELECT</command> "
"commands can see different data, even though they are within a single "
"transaction, if other transactions commit changes after the first "
"<command>SELECT</command> starts and before the second <command>SELECT</"
"command> starts."
msgstr ""
"<firstterm>Read Committed</firstterm> &mdash; уровень изоляции транзакции, "
"выбираемый в <productname>PostgreSQL</productname> по умолчанию. В "
"транзакции, работающей на этом уровне, запрос <command>SELECT</command> (без "
"предложения <literal>FOR UPDATE/SHARE</literal>) видит только те данные, "
"которые были зафиксированы до начала запроса; он никогда не увидит "
"незафиксированных данных или изменений, внесённых в процессе выполнения "
"запроса параллельными транзакциями. По сути запрос <command>SELECT</command> "
"видит снимок базы данных в момент начала выполнения запроса. Однако "
"<command>SELECT</command> видит результаты изменений, внесённых ранее в этой "
"же транзакции, даже если они ещё не зафиксированы. Также заметьте, что два "
"последовательных оператора <command>SELECT</command> могут видеть разные "
"данные даже в рамках одной транзакции, если какие-то другие транзакции "
"зафиксируют изменения после запуска первого <command>SELECT</command>, но до "
"запуска второго."

#: mvcc.xml:335(para)
msgid ""
"<command>UPDATE</command>, <command>DELETE</command>, <command>SELECT FOR "
"UPDATE</command>, and <command>SELECT FOR SHARE</command> commands behave "
"the same as <command>SELECT</command> in terms of searching for target rows: "
"they will only find target rows that were committed as of the command start "
"time. However, such a target row might have already been updated (or deleted "
"or locked) by another concurrent transaction by the time it is found. In "
"this case, the would-be updater will wait for the first updating transaction "
"to commit or roll back (if it is still in progress). If the first updater "
"rolls back, then its effects are negated and the second updater can proceed "
"with updating the originally found row. If the first updater commits, the "
"second updater will ignore the row if the first updater deleted it, "
"otherwise it will attempt to apply its operation to the updated version of "
"the row. The search condition of the command (the <literal>WHERE</literal> "
"clause) is re-evaluated to see if the updated version of the row still "
"matches the search condition. If so, the second updater proceeds with its "
"operation using the updated version of the row. In the case of "
"<command>SELECT FOR UPDATE</command> and <command>SELECT FOR SHARE</"
"command>, this means it is the updated version of the row that is locked and "
"returned to the client."
msgstr ""
"Команды <command>UPDATE</command>, <command>DELETE</command>, "
"<command>SELECT FOR UPDATE</command> и <command>SELECT FOR SHARE</command> "
"ведут себя подобно <command>SELECT</command> при поиске целевых строк: они "
"найдут только те целевые строки, которые были зафиксированы на момент начала "
"команды. Однако к моменту, когда они будут найдены, эти целевые строки могут "
"быть уже изменены (а также удалены или заблокированы) другой параллельной "
"транзакцией. В этом случае запланированное изменение будет отложено до "
"фиксирования или отката первой изменяющей данные транзакции (если она ещё "
"выполняется). Если первая изменяющая транзакция откатывается, её результат "
"отбрасывается и вторая изменяющая транзакция может продолжить изменение "
"изначально полученной строки. Если первая транзакция зафиксировалась, но в "
"результате удалила эту строку, вторая будет игнорировать её, а в противном "
"случае попытается выполнить свою операцию с изменённой версией строки. "
"Условие поиска в команде (предложение <literal>WHERE</literal>) вычисляется "
"повторно для выяснения, соответствует ли по-прежнему этому условию "
"изменённая версия строки. Если да, вторая изменяющая транзакция продолжают "
"свою работу с изменённой версией строки. Применительно к командам "
"<command>SELECT FOR UPDATE</command> и <command>SELECT FOR SHARE</command> "
"это означает, что изменённая версия строки блокируется и возвращается "
"клиенту."

#: mvcc.xml:358(para)
msgid ""
"<command>INSERT</command> with an <literal>ON CONFLICT DO UPDATE</literal> "
"clause behaves similarly. In Read Committed mode, each row proposed for "
"insertion will either insert or update. Unless there are unrelated errors, "
"one of those two outcomes is guaranteed. If a conflict originates in another "
"transaction whose effects are not yet visible to the <command>INSERT </"
"command>, the <command>UPDATE</command> clause will affect that row, even "
"though possibly <emphasis>no</emphasis> version of that row is "
"conventionally visible to the command."
msgstr ""
"Похожим образом ведёт себя <command>INSERT</command> с предложением "
"<literal>ON CONFLICT DO UPDATE</literal>. В режиме Read Committed каждая "
"строка, предлагаемая для добавления, будет либо вставлена, либо изменена. "
"Если не возникнет несвязанных ошибок, гарантируется один из этих двух "
"исходов. Если конфликт будет вызван другой транзакцией, результат которой "
"ещё не видим для <command>INSERT</command>, предложение <command>UPDATE</"
"command> подействует на эту строку, даже несмотря на то, что эта команда "
"обычным образом может не видеть <emphasis>никакую</emphasis> версию этой "
"строки."

#: mvcc.xml:369(para)
msgid ""
"<command>INSERT</command> with an <literal>ON CONFLICT DO NOTHING</literal> "
"clause may have insertion not proceed for a row due to the outcome of "
"another transaction whose effects are not visible to the <command>INSERT</"
"command> snapshot. Again, this is only the case in Read Committed mode."
msgstr ""
"При выполнении <command>INSERT</command> с предложением <literal>ON CONFLICT "
"DO NOTHING</literal> строка может не добавиться в результате действия другой "
"транзакции, эффект которой не виден в снимке команды <command>INSERT</"
"command>. Это опять же имеет место только в режиме Read Committed."

#: mvcc.xml:377(para)
msgid ""
"Because of the above rules, it is possible for an updating command to see an "
"inconsistent snapshot: it can see the effects of concurrent updating "
"commands on the same rows it is trying to update, but it does not see "
"effects of those commands on other rows in the database. This behavior makes "
"Read Committed mode unsuitable for commands that involve complex search "
"conditions; however, it is just right for simpler cases. For example, "
"consider updating bank balances with transactions like: <screen>\n"
"BEGIN;\n"
"UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;\n"
"UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;\n"
"COMMIT;\n"
"</screen> If two such transactions concurrently try to change the balance of "
"account 12345, we clearly want the second transaction to start with the "
"updated version of the account's row. Because each command is affecting only "
"a predetermined row, letting it see the updated version of the row does not "
"create any troublesome inconsistency."
msgstr ""
"Вследствие описанных выше правил, изменяющая команда может увидеть "
"несогласованное состояние: она может видеть результаты параллельных команд, "
"изменяющих те же строки, что пытается изменить она, но при этом она не видит "
"результаты этих команд в других строках таблиц. Из-за этого поведения "
"уровень Read Committed не подходит для команд со сложными условиями поиска; "
"однако он вполне пригоден для простых случаев. Например, рассмотрим "
"изменение баланса счёта в таких транзакциях: <screen>\n"
"BEGIN;\n"
"UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;\n"
"UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;\n"
"COMMIT;\n"
"</screen> Если две такие транзакции пытаются параллельно изменить баланс "
"счёта 12345, мы, естественно, хотим, чтобы вторая транзакция работала с "
"изменённой версией строки счёта. Так как каждая команда влияет только на "
"определённую строку, если она будет видеть изменённую версию строки, это не "
"приведёт к проблемам несогласованности."

#: mvcc.xml:401(para)
msgid ""
"More complex usage can produce undesirable results in Read Committed mode. "
"For example, consider a <command>DELETE</command> command operating on data "
"that is being both added and removed from its restriction criteria by "
"another command, e.g., assume <literal>website</literal> is a two-row table "
"with <literal>website.hits</literal> equaling <literal>9</literal> and "
"<literal>10</literal>: <screen>\n"
"BEGIN;\n"
"UPDATE website SET hits = hits + 1;\n"
"-- run from another session:  DELETE FROM website WHERE hits = 10;\n"
"COMMIT;\n"
"</screen> The <command>DELETE</command> will have no effect even though "
"there is a <literal>website.hits = 10</literal> row before and after the "
"<command>UPDATE</command>. This occurs because the pre-update row value "
"<literal>9</literal> is skipped, and when the <command>UPDATE</command> "
"completes and <command>DELETE</command> obtains a lock, the new row value is "
"no longer <literal>10</literal> but <literal>11</literal>, which no longer "
"matches the criteria."
msgstr ""
"В более сложных ситуациях уровень Read Committed может приводить к "
"нежелательным результатам. Например, рассмотрим команду <command>DELETE</"
"command>, работающую со строками, которые параллельно добавляет и удаляет из "
"множества, определённого её условием, другая команда. Например, предположим, "
"что <literal>website</literal> &mdash; таблица из двух строк, в которых "
"<literal>website.hits</literal> равны <literal>9</literal> и <literal>10</"
"literal>: <screen>\n"
"BEGIN;\n"
"UPDATE website SET hits = hits + 1;\n"
"-- выполняется параллельно:  DELETE FROM website WHERE hits = 10;\n"
"COMMIT;\n"
"</screen> Команда <command>DELETE</command> не сделает ничего, даже несмотря "
"на то, что строка с <literal>website.hits = 10</literal> была в таблице и "
"до, и после выполнения <command>UPDATE</command>. Это происходит потому, что "
"строка со значением <literal>9</literal> до изменения пропускается, а когда "
"команда <command>UPDATE</command> завершается и <command>DELETE</command> "
"получает освободившуюся блокировку, строка с <literal>10</literal> теперь "
"содержит <literal>11</literal>, а это значение уже не соответствует условию."

#: mvcc.xml:426(para)
msgid ""
"Because Read Committed mode starts each command with a new snapshot that "
"includes all transactions committed up to that instant, subsequent commands "
"in the same transaction will see the effects of the committed concurrent "
"transaction in any case. The point at issue above is whether or not a "
"<emphasis>single</emphasis> command sees an absolutely consistent view of "
"the database."
msgstr ""
"Так как в режиме Read Committed каждая команда начинается с нового снимка "
"состояния, который включает результаты всех транзакций, зафиксированных к "
"этому моменту, последующие команды в одной транзакции будут в любом случае "
"видеть эффекты всех параллельных зафиксированных транзакций. Вопрос здесь "
"состоит в том, видит ли <emphasis>одна</emphasis> команда абсолютно "
"согласованное состояние базы данных."

#: mvcc.xml:435(para)
msgid ""
"The partial transaction isolation provided by Read Committed mode is "
"adequate for many applications, and this mode is fast and simple to use; "
"however, it is not sufficient for all cases. Applications that do complex "
"queries and updates might require a more rigorously consistent view of the "
"database than Read Committed mode provides."
msgstr ""
"Частичная изоляция транзакция, обеспечиваемая в режиме Read Committed, "
"приемлема для множества приложений. Этот режим быстр и прост в "
"использовании, однако он подходит не для всех случаев. Приложениям, "
"выполняющим сложные запросы и изменения, могут потребоваться более строго "
"согласованное представление данных, чем то, что даёт Read Committed."

#: mvcc.xml:445(title)
msgid "Repeatable Read Isolation Level"
msgstr "Уровень изоляции Repeatable Read"

#: mvcc.xml:447(indexterm)
msgid ""
"<primary>transaction isolation level</primary> <secondary>repeatable read</"
"secondary>"
msgstr ""
"<primary>уровень изоляции транзакций</primary> <secondary>repeatable read</"
"secondary>"

#: mvcc.xml:452(indexterm)
msgid "<primary>repeatable read</primary>"
msgstr "<primary>repeatable read</primary>"

#: mvcc.xml:456(para)
msgid ""
"The <firstterm>Repeatable Read</firstterm> isolation level only sees data "
"committed before the transaction began; it never sees either uncommitted "
"data or changes committed during transaction execution by concurrent "
"transactions. (However, the query does see the effects of previous updates "
"executed within its own transaction, even though they are not yet "
"committed.) This is a stronger guarantee than is required by the "
"<acronym>SQL</acronym> standard for this isolation level, and prevents all "
"of the phenomena described in <xref linkend=\"mvcc-isolevel-table\"/> except "
"for serialization anomalies. As mentioned above, this is specifically "
"allowed by the standard, which only describes the <emphasis>minimum</"
"emphasis> protections each isolation level must provide."
msgstr ""
"В режиме <firstterm>Repeatable Read</firstterm> видны только те данные, "
"которые были зафиксированы до начала транзакции, но не видны "
"незафиксированные данные и изменения, произведённые другими транзакциями в "
"процессе выполнения данной транзакции. (Однако запрос будет видеть эффекты "
"предыдущих изменений в своей транзакции, несмотря на то, что они не "
"зафиксированы.) Это самое строгое требование, которое стандарт <acronym>SQL</"
"acronym> вводит для этого уровня изоляции, и при его выполнении "
"предотвращаются все явления, описанные в <xref remap=\"6\" linkend=\"mvcc-"
"isolevel-table\"/>, за исключением аномалий реализации. Как было сказано "
"выше, это не противоречит стандарту, так как он определяет только "
"<emphasis>минимальную</emphasis> защиту, которая должна обеспечиваться на "
"каждом уровне изоляции."

#: mvcc.xml:472(para)
msgid ""
"This level is different from Read Committed in that a query in a repeatable "
"read transaction sees a snapshot as of the start of the first non-"
"transaction-control statement in the <emphasis>transaction</emphasis>, not "
"as of the start of the current statement within the transaction. Thus, "
"successive <command>SELECT</command> commands within a <emphasis>single</"
"emphasis> transaction see the same data, i.e., they do not see changes made "
"by other transactions that committed after their own transaction started."
msgstr ""
"Этот уровень отличается от Read Committed тем, что запрос в транзакции "
"данного уровня видит снимок данных на момент начала первого оператора в "
"<emphasis>транзакции</emphasis> (не считая команд управления транзакциями), "
"а не начала текущего оператора. Таким образом, последовательные команды "
"<command>SELECT</command> в <emphasis>одной</emphasis> транзакции видят одни "
"и те же данные; они не видят изменений, внесённых и зафиксированных другими "
"транзакциями после начала их текущей транзакции."

#: mvcc.xml:483(para)
msgid ""
"Applications using this level must be prepared to retry transactions due to "
"serialization failures."
msgstr ""
"Приложения, использующие этот уровень, должны быть готовы повторить "
"транзакции в случае сбоев сериализации."

#: mvcc.xml:488(para)
msgid ""
"<command>UPDATE</command>, <command>DELETE</command>, <command>SELECT FOR "
"UPDATE</command>, and <command>SELECT FOR SHARE</command> commands behave "
"the same as <command>SELECT</command> in terms of searching for target rows: "
"they will only find target rows that were committed as of the transaction "
"start time. However, such a target row might have already been updated (or "
"deleted or locked) by another concurrent transaction by the time it is "
"found. In this case, the repeatable read transaction will wait for the first "
"updating transaction to commit or roll back (if it is still in progress). If "
"the first updater rolls back, then its effects are negated and the "
"repeatable read transaction can proceed with updating the originally found "
"row. But if the first updater commits (and actually updated or deleted the "
"row, not just locked it) then the repeatable read transaction will be rolled "
"back with the message <screen>\n"
"ERROR:  could not serialize access due to concurrent update\n"
"</screen> because a repeatable read transaction cannot modify or lock rows "
"changed by other transactions after the repeatable read transaction began."
msgstr ""
"Команды <command>UPDATE</command>, <command>DELETE</command>, "
"<command>SELECT FOR UPDATE</command> и <command>SELECT FOR SHARE</command> "
"ведут себя подобно <command>SELECT</command> при поиске целевых строк: они "
"найдут только те целевые строки, которые были зафиксированы на момент начала "
"транзакции. Однако к моменту, когда они будут найдены, эти целевые строки "
"могут быть уже изменены (а также удалены или заблокированы) другой "
"параллельной транзакцией. В этом случае транзакция в режиме Repeatable Read "
"будет ожидать фиксирования или отката первой изменяющей данные транзакции "
"(если она ещё выполняется). Если первая изменяющая транзакция откатывается, "
"её результат отбрасывается и текущая транзакция может продолжить изменение "
"изначально полученной строки. Если же первая транзакция зафиксировалась, и в "
"результате изменила или удалила эту строку, а не просто заблокировала её, "
"произойдёт откат текущей транзакции с сообщением <screen>\n"
"ОШИБКА: не удалось сериализовать доступ из-за параллельного изменения\n"
"</screen> так как транзакция уровня Repeatable Read не может изменять или "
"блокировать строки, изменённые другими транзакциями с момента её начала."

#: mvcc.xml:511(para)
msgid ""
"When an application receives this error message, it should abort the current "
"transaction and retry the whole transaction from the beginning. The second "
"time through, the transaction will see the previously-committed change as "
"part of its initial view of the database, so there is no logical conflict in "
"using the new version of the row as the starting point for the new "
"transaction's update."
msgstr ""
"Когда приложение получает это сообщение об ошибке, оно должна прервать "
"текущую транзакцию и попытаться повторить её с самого начала. Во второй раз "
"транзакция увидит внесённое до этого изменение как часть начального снимка "
"базы данных, так что новая версия строки вполне может использоваться в "
"качестве отправной точки для изменения в повторной транзакции."

#: mvcc.xml:520(para)
msgid ""
"Note that only updating transactions might need to be retried; read-only "
"transactions will never have serialization conflicts."
msgstr ""
"Заметьте, что потребность в повторении транзакции может возникнуть, только "
"если эта транзакция изменяет данные; в транзакциях, которые только читают "
"данные, конфликтов сериализации не бывает."

#: mvcc.xml:525(para)
msgid ""
"The Repeatable Read mode provides a rigorous guarantee that each transaction "
"sees a completely stable view of the database. However, this view will not "
"necessarily always be consistent with some serial (one at a time) execution "
"of concurrent transactions of the same level. For example, even a read only "
"transaction at this level may see a control record updated to show that a "
"batch has been completed but <emphasis>not</emphasis> see one of the detail "
"records which is logically part of the batch because it read an earlier "
"revision of the control record. Attempts to enforce business rules by "
"transactions running at this isolation level are not likely to work "
"correctly without careful use of explicit locks to block conflicting "
"transactions."
msgstr ""
"Режим Repeatable Read строго гарантирует, что каждая транзакция видит "
"полностью стабильное представление базы данных. Однако это представление не "
"обязательно будет согласовано с некоторым последовательным выполнением "
"транзакций одного уровня. Например, даже транзакция, которая только читает "
"данные, в этом режиме может видеть строку, показывающую, что некоторое "
"задание завершено, но <emphasis>не</emphasis> видеть одну из строк "
"логических частей задания, так как эта транзакция может прочитать более "
"раннюю версию строки задания, чем ту, для которой параллельно добавлялась "
"очередная логическая часть. Строго исполнить бизнес-правила в транзакциях, "
"работающих на этом уровне изоляции, скорее всего не удастся без явных "
"блокировок конфликтующих транзакций."

#: mvcc.xml:540(para)
msgid ""
"Prior to <productname>PostgreSQL</productname> version 9.1, a request for "
"the Serializable transaction isolation level provided exactly the same "
"behavior described here. To retain the legacy Serializable behavior, "
"Repeatable Read should now be requested."
msgstr ""
"До версии 9.1 в <productname>PostgreSQL</productname> при запросе режима "
"Serializable поведение системы в точности соответствовало вышеописанному. "
"Таким образом, чтобы сейчас получить старое поведение Serializable, нужно "
"запрашивать режим Repeatable Read."

#: mvcc.xml:550(title)
msgid "Serializable Isolation Level"
msgstr "Уровень изоляции Serializable"

#: mvcc.xml:552(indexterm)
msgid ""
"<primary>transaction isolation level</primary> <secondary>serializable</"
"secondary>"
msgstr ""
"<primary>уровень изоляции транзакций</primary> <secondary>serializable</"
"secondary>"

#: mvcc.xml:557(indexterm)
msgid "<primary>serializable</primary>"
msgstr "<primary>serializable</primary>"

#: mvcc.xml:561(indexterm)
msgid "<primary>predicate locking</primary>"
msgstr "<primary>предикатная блокировка</primary>"

#: mvcc.xml:569(para)
msgid ""
"The <firstterm>Serializable</firstterm> isolation level provides the "
"strictest transaction isolation. This level emulates serial transaction "
"execution for all committed transactions; as if transactions had been "
"executed one after another, serially, rather than concurrently. However, "
"like the Repeatable Read level, applications using this level must be "
"prepared to retry transactions due to serialization failures. In fact, this "
"isolation level works exactly the same as Repeatable Read except that it "
"monitors for conditions which could make execution of a concurrent set of "
"serializable transactions behave in a manner inconsistent with all possible "
"serial (one at a time) executions of those transactions. This monitoring "
"does not introduce any blocking beyond that present in repeatable read, but "
"there is some overhead to the monitoring, and detection of the conditions "
"which could cause a <firstterm>serialization anomaly</firstterm> will "
"trigger a <firstterm>serialization failure</firstterm>."
msgstr ""
"Уровень <firstterm>Serializable</firstterm> обеспечивает самую строгую "
"изоляцию транзакций. На этом уровне моделируется последовательное выполнение "
"всех зафиксированных транзакций, как если бы транзакции выполнялись одна за "
"другой, последовательно, а не параллельно. Однако, как и на уровне "
"Repeatable Read, на этом уровне приложения должны быть готовы повторять "
"транзакции из-за сбоев сериализации. Фактически этот режим изоляции работает "
"так же, как и Repeatable Read, только он дополнительно отслеживает условия, "
"при которых результат параллельно выполняемых сериализуемых транзакций может "
"не согласовываться с результатом этих же транзакций, выполняемых по очереди. "
"Это отслеживание не привносит дополнительных препятствий для выполнения, "
"кроме тех, что присущи режиму Repeatable Read, но тем не менее создаёт "
"некоторую добавочную нагрузку, а при выявлении исключительных условий "
"регистрируется <firstterm>аномалия сериализации</firstterm> и происходит "
"<firstterm>сбой сериализации</firstterm>."

#: mvcc.xml:589(para)
msgid ""
"As an example, consider a table <structname>mytab</structname>, initially "
"containing: <screen>\n"
" class | value\n"
"-------+-------\n"
"     1 |    10\n"
"     1 |    20\n"
"     2 |   100\n"
"     2 |   200\n"
"</screen> Suppose that serializable transaction A computes: <screen>\n"
"SELECT SUM(value) FROM mytab WHERE class = 1;\n"
"</screen> and then inserts the result (30) as the <structfield>value</"
"structfield> in a new row with <structfield>class</structfield><literal> = "
"2</literal>. Concurrently, serializable transaction B computes: <screen>\n"
"SELECT SUM(value) FROM mytab WHERE class = 2;\n"
"</screen> and obtains the result 300, which it inserts in a new row with "
"<structfield>class</structfield><literal> = 1</literal>. Then both "
"transactions try to commit. If either transaction were running at the "
"Repeatable Read isolation level, both would be allowed to commit; but since "
"there is no serial order of execution consistent with the result, using "
"Serializable transactions will allow one transaction to commit and will roll "
"the other back with this message: <screen>\n"
"ERROR:  could not serialize access due to read/write dependencies among "
"transactions\n"
"</screen> This is because if A had executed before B, B would have computed "
"the sum 330, not 300, and similarly the other order would have resulted in a "
"different sum computed by A."
msgstr ""
"Например, рассмотрим таблицу <structname>mytab</structname>, изначально "
"содержащую: <screen>\n"
" class | value\n"
"-------+-------\n"
"     1 |    10\n"
"     1 |    20\n"
"     2 |   100\n"
"     2 |   200\n"
"</screen> Предположим, что сериализуемая транзакция A вычисляет: <screen>\n"
"SELECT SUM(value) FROM mytab WHERE class = 1;\n"
"</screen> а затем вставляет результат (30) в поле <structfield>value</"
"structfield> в новую строку со значением <structfield>class</"
"structfield><literal> = 2</literal>. В это же время сериализуемая транзакция "
"B вычисляет: <screen>\n"
"SELECT SUM(value) FROM mytab WHERE class = 2;\n"
"</screen> получает результат 300 и вставляет его в новую строку со значением "
"<structfield>class</structfield><literal> = 1</literal>. Затем обе "
"транзакции пытаются зафиксироваться. Если бы одна из этих транзакций "
"работала в режиме Repeatable Read, зафиксироваться могли бы обе; но так как "
"полученный результат не соответствовал бы последовательному порядку, в "
"режиме Serializable будет зафиксирована только одна транзакция, а вторая "
"закончится откатом с сообщением: <screen>\n"
"ОШИБКА: не удалось сериализовать доступ из-за зависимостей чтения/записи "
"между\n"
"  транзакциями\n"
"</screen> Это объясняется тем, что при выполнении A перед B транзакция B "
"вычислила бы сумму 330, а не 300, а при выполнении в обратном порядке A "
"вычислила бы другую сумму."

#: mvcc.xml:627(para)
msgid ""
"When relying on Serializable transactions to prevent anomalies, it is "
"important that any data read from a permanent user table not be considered "
"valid until the transaction which read it has successfully committed. This "
"is true even for read-only transactions, except that data read within a "
"<firstterm>deferrable</firstterm> read-only transaction is known to be valid "
"as soon as it is read, because such a transaction waits until it can acquire "
"a snapshot guaranteed to be free from such problems before starting to read "
"any data. In all other cases applications must not depend on results read "
"during a transaction that later aborted; instead, they should retry the "
"transaction until it succeeds."
msgstr ""
"Рассчитывая, что сериализуемые транзакции предотвратят аномалии, важно "
"понимать, что любые данные, полученные из постоянной таблицы пользователя, "
"не должны считаться действительными, пока транзакция, прочитавшая их, не "
"будет успешно зафиксирована. Это верно даже для транзакций, не "
"модифицирующих данные, за исключением случая, когда данные считываются в "
"<firstterm>откладываемой</firstterm> транзакции такого типа. В этом случае "
"данные могут считаться действительными, так как такая транзакция ждёт, пока "
"не сможет получить снимок, гарантированно предотвращающий подобные проблемы. "
"Во всех остальных случаях приложения не должны полагаться на результаты "
"чтения данных в транзакции, которая не была зафиксирована; в случае ошибки и "
"отката приложения должны повторять транзакцию, пока она не будет завершена "
"успешно."

#: mvcc.xml:641(para)
msgid ""
"To guarantee true serializability <productname>PostgreSQL</productname> uses "
"<firstterm>predicate locking</firstterm>, which means that it keeps locks "
"which allow it to determine when a write would have had an impact on the "
"result of a previous read from a concurrent transaction, had it run first. "
"In <productname>PostgreSQL</productname> these locks do not cause any "
"blocking and therefore can <emphasis>not</emphasis> play any part in causing "
"a deadlock. They are used to identify and flag dependencies among concurrent "
"Serializable transactions which in certain combinations can lead to "
"serialization anomalies. In contrast, a Read Committed or Repeatable Read "
"transaction which wants to ensure data consistency may need to take out a "
"lock on an entire table, which could block other users attempting to use "
"that table, or it may use <literal>SELECT FOR UPDATE</literal> or "
"<literal>SELECT FOR SHARE</literal> which not only can block other "
"transactions but cause disk access."
msgstr ""
"Для полной гарантии сериализуемости в <productname>PostgreSQL</productname> "
"применяются <firstterm>предикатные блокировки</firstterm>, то есть "
"блокировки, позволяющие определить, когда запись могла бы повлиять на "
"результат предыдущего чтения параллельной транзакции, если бы эта запись "
"выполнялась сначала. В <productname>PostgreSQL</productname> эти блокировки "
"не приводят к фактическим блокировкам данным и следовательно никоим образом "
"<emphasis>не</emphasis> могут повлечь взаимоблокировки транзакций. Они "
"помогают выявить и отметить зависимости между параллельными транзакциями "
"уровня Serializable, которые в определённых сочетаниях могут приводить к "
"аномалиям сериализации. Транзакции Read Committed или Repeatable Read для "
"обеспечения целостности данных, напротив, должны либо блокировать таблицы "
"целиком, что помешает пользователям обращаться к этим таблицам, либо "
"применять <literal>SELECT FOR UPDATE</literal> или <literal>SELECT FOR "
"SHARE</literal>, что не только заблокирует другие транзакции, но и создаст "
"дополнительную нагрузку на диск."

#: mvcc.xml:658(para)
msgid ""
"Predicate locks in <productname>PostgreSQL</productname>, like in most other "
"database systems, are based on data actually accessed by a transaction. "
"These will show up in the <link linkend=\"view-pg-locks"
"\"><structname>pg_locks</structname></link> system view with a "
"<literal>mode</literal> of <literal>SIReadLock</literal>. The particular "
"locks acquired during execution of a query will depend on the plan used by "
"the query, and multiple finer-grained locks (e.g., tuple locks) may be "
"combined into fewer coarser-grained locks (e.g., page locks) during the "
"course of the transaction to prevent exhaustion of the memory used to track "
"the locks. A <literal>READ ONLY</literal> transaction may be able to release "
"its SIRead locks before completion, if it detects that no conflicts can "
"still occur which could lead to a serialization anomaly. In fact, "
"<literal>READ ONLY</literal> transactions will often be able to establish "
"that fact at startup and avoid taking any predicate locks. If you explicitly "
"request a <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal> transaction, "
"it will block until it can establish this fact. (This is the <emphasis>only</"
"emphasis> case where Serializable transactions block but Repeatable Read "
"transactions don't.) On the other hand, SIRead locks often need to be kept "
"past transaction commit, until overlapping read write transactions complete."
msgstr ""
"Предикатные блокировки в <productname>PostgreSQL</productname>, как и в "
"большинстве других СУБД, устанавливаются для данных, фактически используемых "
"в транзакции. Они отображаются в системном представлении <link linkend="
"\"view-pg-locks\"><structname>pg_locks</structname></link> со значением "
"<literal>mode</literal> равным <literal>SIReadLock</literal>. Какие именно "
"блокировки будут затребованы при выполнении запроса, зависит от плана "
"запроса, при этом детализированные блокировки (например, блокировки строк) "
"могут объединяться в более общие (например, в блокировки страниц) в процессе "
"транзакции для экономии памяти, расходуемой для отслеживания блокировок. "
"Транзакция <literal>READ ONLY</literal> может даже освободить свои "
"блокировки SIRead до завершения, если обнаруживается, что конфликты, которые "
"могли бы привести к аномалии сериализации, исключены. На самом деле для "
"транзакций <literal>READ ONLY</literal> этот факт чаще всего устанавливается "
"в самом начале, так что они обходятся без предикатных блокировок. Если же вы "
"явно запросите транзакцию <literal>SERIALIZABLE READ ONLY DEFERRABLE</"
"literal>, она будет заблокирована до тех пор, пока не сможет установить этот "
"факт. (Это <emphasis>единственный</emphasis> случай, когда транзакции уровня "
"Serializable блокируются, а транзакции Repeatable Read &mdash; нет.) С "
"другой стороны, блокировки SIRead часто должны сохраняться и после "
"фиксирования транзакции, пока не будут завершены другие, наложившиеся на неё "
"транзакции."

#: mvcc.xml:682(para)
msgid ""
"Consistent use of Serializable transactions can simplify development. The "
"guarantee that any set of successfully committed concurrent Serializable "
"transactions will have the same effect as if they were run one at a time "
"means that if you can demonstrate that a single transaction, as written, "
"will do the right thing when run by itself, you can have confidence that it "
"will do the right thing in any mix of Serializable transactions, even "
"without any information about what those other transactions might do, or it "
"will not successfully commit. It is important that an environment which uses "
"this technique have a generalized way of handling serialization failures "
"(which always return with a SQLSTATE value of '40001'), because it will be "
"very hard to predict exactly which transactions might contribute to the read/"
"write dependencies and need to be rolled back to prevent serialization "
"anomalies. The monitoring of read/write dependencies has a cost, as does the "
"restart of transactions which are terminated with a serialization failure, "
"but balanced against the cost and blocking involved in use of explicit locks "
"and <literal>SELECT FOR UPDATE</literal> or <literal>SELECT FOR SHARE</"
"literal>, Serializable transactions are the best performance choice for some "
"environments."
msgstr ""
"При правильном использовании сериализуемые транзакции могут значительно "
"упростить разработку приложений. Гарантия того, что любое сочетание успешно "
"зафиксированных параллельных сериализуемых транзакций даст тот же результат, "
"что и последовательность этих транзакций, выполненных по очереди, означает, "
"что если вы уверены, что единственная транзакция определённого содержания "
"работает правильно, когда она запускается отдельно, вы можете быть уверены, "
"что она будет работать так же правильно в любом сочетании сериализуемых "
"транзакций, вне зависимости от того, что они делают, либо же она не будет "
"зафиксирована успешно. При этом важно, чтобы в среде, где применяется этот "
"подход, была реализована общая обработка сбоев сериализации (которые можно "
"определить по значению SQLSTATE '40001'), так как заведомо определить, какие "
"именно транзакции могут стать жертвами зависимостей чтения/записи и не будут "
"зафиксированы для предотвращения аномалий сериализации, обычно очень сложно. "
"Отслеживание зависимостей чтения-записи неизбежно создаёт дополнительную "
"нагрузку, как и перезапуск транзакций, не зафиксированных из-за сбоев "
"сериализации, но если на другую чашу весов положить нагрузку и блокирование, "
"связанные с применением явных блокировок и <literal>SELECT FOR UPDATE</"
"literal> или <literal>SELECT FOR SHARE</literal>, использовать сериализуемые "
"транзакции в ряде случаев окажется выгоднее."

#: mvcc.xml:704(para)
msgid ""
"While <productname>PostgreSQL</productname>'s Serializable transaction "
"isolation level only allows concurrent transactions to commit if it can "
"prove there is a serial order of execution that would produce the same "
"effect, it doesn't always prevent errors from being raised that would not "
"occur in true serial execution. In particular, it is possible to see unique "
"constraint violations caused by conflicts with overlapping Serializable "
"transactions even after explicitly checking that the key isn't present "
"before attempting to insert it. This can be avoided by making sure that "
"<emphasis>all</emphasis> Serializable transactions that insert potentially "
"conflicting keys explicitly check if they can do so first. For example, "
"imagine an application that asks the user for a new key and then checks that "
"it doesn't exist already by trying to select it first, or generates a new "
"key by selecting the maximum existing key and adding one. If some "
"Serializable transactions insert new keys directly without following this "
"protocol, unique constraints violations might be reported even in cases "
"where they could not occur in a serial execution of the concurrent "
"transactions."
msgstr ""
"Тогда как уровень изоляции транзакций Serializable в "
"<productname>PostgreSQL</productname> позволяет фиксировать параллельные "
"транзакции, только если есть уверенность, что тот же результат будет получен "
"при последовательном их выполнении, он не всегда предотвращает ошибки, "
"которые не возникли бы при действительно последовательном выполнении. В "
"частности, можно столкнуться с нарушениями ограничений уникальности, "
"вызванными наложением сериализуемых транзакций, даже после явной проверки "
"отсутствия ключа перед добавлением его. Этого можно избежать, если "
"<emphasis>все</emphasis> сериализуемые транзакции, добавляющие потенциально "
"конфликтующие ключи, будут предварительно явно проверять, можно ли вставить "
"ключ. Например, приложение, добавляющее новый ключ, может запрашивать его у "
"пользователя и затем проверять, существует ли он, сначала пытаясь найти его, "
"либо генерировать новый ключ, выбирая максимальное существующее значение и "
"увеличивая его на один. Если некоторые сериализуемые транзакции добавляют "
"новые ключи сразу, не следуя этому протоколу, возможны нарушения ограничений "
"уникальности, даже когда они не наблюдались бы при последовательном "
"выполнении этих транзакций."

#: mvcc.xml:730(para)
msgid "Declare transactions as <literal>READ ONLY</literal> when possible."
msgstr ""
"Объявляйте транзакции как <literal>READ ONLY</literal>, если это отражает их "
"суть."

#: mvcc.xml:735(para)
msgid ""
"Control the number of active connections, using a connection pool if needed. "
"This is always an important performance consideration, but it can be "
"particularly important in a busy system using Serializable transactions."
msgstr ""
"Управляйте числом активных подключений, при необходимости используя пул "
"соединений. Это всегда полезно для увеличения производительности, но "
"особенно важно это в загруженной системе с сериализуемыми транзакциями."

#: mvcc.xml:743(para)
msgid ""
"Don't put more into a single transaction than needed for integrity purposes."
msgstr ""
"Заключайте в одну транзакцию не больше команд, чем необходимо для "
"обеспечения целостности."

#: mvcc.xml:749(para)
msgid ""
"Don't leave connections dangling <quote>idle in transaction</quote> longer "
"than necessary. The configuration parameter <xref linkend=\"guc-idle-in-"
"transaction-session-timeout\"/> may be used to automatically disconnect "
"lingering sessions."
msgstr ""
"Не оставляйте соединения <quote>простаивающими в транзакции</quote> дольше, "
"чем необходимо. Для автоматического отключения затянувшихся транзакций можно "
"применить параметр конфигурации <xref linkend=\"guc-idle-in-transaction-"
"session-timeout\"/>."

#: mvcc.xml:757(para)
msgid ""
"Eliminate explicit locks, <literal>SELECT FOR UPDATE</literal>, and "
"<literal>SELECT FOR SHARE</literal> where no longer needed due to the "
"protections automatically provided by Serializable transactions."
msgstr ""
"Исключите явные блокировки, <literal>SELECT FOR UPDATE</literal> и "
"<literal>SELECT FOR SHARE</literal> там, где они не нужны благодаря защите, "
"автоматически предоставляемой сериализуемыми транзакциями."

#: mvcc.xml:764(para)
msgid ""
"When the system is forced to combine multiple page-level predicate locks "
"into a single relation-level predicate lock because the predicate lock table "
"is short of memory, an increase in the rate of serialization failures may "
"occur. You can avoid this by increasing <xref linkend=\"guc-max-pred-locks-"
"per-transaction\"/>."
msgstr ""
"Когда система вынуждена объединять предикатные блокировки уровня страницы в "
"одну предикатную блокировку уровня таблицы из-за нехватки памяти, может "
"возрасти частота сбоев сериализации. Избежать этого можно, увеличив параметр "
"<xref linkend=\"guc-max-pred-locks-per-transaction\"/>."

#: mvcc.xml:773(para)
msgid ""
"A sequential scan will always necessitate a relation-level predicate lock. "
"This can result in an increased rate of serialization failures. It may be "
"helpful to encourage the use of index scans by reducing <xref linkend=\"guc-"
"random-page-cost\"/> and/or increasing <xref linkend=\"guc-cpu-tuple-cost\"/"
">. Be sure to weigh any decrease in transaction rollbacks and restarts "
"against any overall change in query execution time."
msgstr ""
"Последовательное сканирование всегда влечёт за собой предикатную блокировку "
"на уровне таблицы. Это приводит к увеличению сбоев сериализации. В таких "
"ситуациях бывает полезно склонить систему к использованию индексов, уменьшая "
"<xref linkend=\"guc-random-page-cost\"/> и/или увеличивая <xref linkend="
"\"guc-cpu-tuple-cost\"/>. Однако тут важно сопоставить выигрыш от уменьшения "
"числа откатов и перезапусков транзакций с проигрышем от возможного менее "
"эффективного выполнения запросов."

#: mvcc.xml:724(para)
msgid ""
"For optimal performance when relying on Serializable transactions for "
"concurrency control, these issues should be considered: <placeholder-1/>"
msgstr ""
"Применяя сериализуемые транзакции для управления конкурентным доступом, "
"примите к сведению следующие рекомендации: <placeholder-1/>"

#: mvcc.xml:789(title)
msgid "Explicit Locking"
msgstr "Явные блокировки"

#: mvcc.xml:791(indexterm)
msgid "<primary>lock</primary>"
msgstr "<primary>lock</primary>"

#: mvcc.xml:795(para)
msgid ""
"<productname>PostgreSQL</productname> provides various lock modes to control "
"concurrent access to data in tables. These modes can be used for application-"
"controlled locking in situations where <acronym>MVCC</acronym> does not give "
"the desired behavior. Also, most <productname>PostgreSQL</productname> "
"commands automatically acquire locks of appropriate modes to ensure that "
"referenced tables are not dropped or modified in incompatible ways while the "
"command executes. (For example, <command>TRUNCATE</command> cannot safely be "
"executed concurrently with other operations on the same table, so it obtains "
"an exclusive lock on the table to enforce that.)"
msgstr ""
"Для управления параллельным доступом к данным в таблицах "
"<productname>PostgreSQL</productname> предоставляет несколько режимов явных "
"блокировок. Эти режимы могут применяться для блокировки данных со стороны "
"приложения в ситуациях, когда <acronym>MVCC</acronym> не даёт желаемый "
"результат. Кроме того, большинство команд <productname>PostgreSQL</"
"productname> автоматически получают блокировки соответствующих режимов, "
"защищающие от удаления или изменения задействованных таблиц, несовместимого "
"с характером выполняемой команды. (Например, <command>TRUNCATE</command> не "
"может безопасно выполняться одновременно с другими операциями с этой "
"таблицей, так что во избежание конфликта эта команда получает исключительную "
"блокировку для данной таблицы.)"

#: mvcc.xml:808(para)
msgid ""
"To examine a list of the currently outstanding locks in a database server, "
"use the <link linkend=\"view-pg-locks\"><structname>pg_locks</structname></"
"link> system view. For more information on monitoring the status of the lock "
"manager subsystem, refer to <xref linkend=\"monitoring\"/>."
msgstr ""
"Список текущих активных блокировок на сервере можно получить, прочитав "
"системное представление <link linkend=\"view-pg-locks"
"\"><structname>pg_locks</structname></link>. За дополнительными сведениями о "
"наблюдении за состоянием менеджера блокировок обратитесь к <xref remap=\"3\" "
"linkend=\"monitoring\"/>."

#: mvcc.xml:817(title)
msgid "Table-level Locks"
msgstr "Блокировки на уровне таблицы"

#: mvcc.xml:819(indexterm)
msgid "<primary>LOCK</primary>"
msgstr "<primary>LOCK</primary>"

#: mvcc.xml:823(para)
msgid ""
"The list below shows the available lock modes and the contexts in which they "
"are used automatically by <productname>PostgreSQL</productname>. You can "
"also acquire any of these locks explicitly with the command <xref linkend="
"\"sql-lock\"/>. Remember that all of these lock modes are table-level locks, "
"even if the name contains the word <quote>row</quote>; the names of the lock "
"modes are historical. To some extent the names reflect the typical usage of "
"each lock mode &mdash; but the semantics are all the same. The only real "
"difference between one lock mode and another is the set of lock modes with "
"which each conflicts (see <xref linkend=\"table-lock-compatibility\"/>). Two "
"transactions cannot hold locks of conflicting modes on the same table at the "
"same time. (However, a transaction never conflicts with itself. For example, "
"it might acquire <literal>ACCESS EXCLUSIVE</literal> lock and later acquire "
"<literal>ACCESS SHARE</literal> lock on the same table.) Non-conflicting "
"lock modes can be held concurrently by many transactions. Notice in "
"particular that some lock modes are self-conflicting (for example, an "
"<literal>ACCESS EXCLUSIVE</literal> lock cannot be held by more than one "
"transaction at a time) while others are not self-conflicting (for example, "
"an <literal>ACCESS SHARE</literal> lock can be held by multiple "
"transactions)."
msgstr ""
"В приведённом ниже списке перечислены имеющиеся режимы блокировок и "
"контексты, где их автоматически применяет <productname>PostgreSQL</"
"productname>. Вы можете также явно запросить любую из этих блокировок с "
"помощью команды <xref linkend=\"sql-lock\"/>. Помните, что все эти режимы "
"работают на уровне таблицы, даже если имя режима содержит слово <quote>row</"
"quote>; такие имена сложились исторически. В некоторой степени эти имена "
"отражают типичное применение каждого режима блокировки, но смысл у всех "
"один. Единственное, что действительно отличает один режим блокировки от "
"другого, это набор режимов, с которыми конфликтует каждый из них (см. <xref "
"remap=\"4\" linkend=\"table-lock-compatibility\"/>). Две транзакции не могут "
"одновременно владеть блокировками конфликтующих режимов для одной и той же "
"таблицы. (Однако учтите, что транзакция никогда не конфликтует с собой. "
"Например, она может запросить блокировку <literal>ACCESS EXCLUSIVE</"
"literal>, а затем <literal>ACCESS SHARE</literal> для той же таблицы.) При "
"этом разные транзакции свободно могут одновременно владеть блокировками "
"неконфликтующих режимов. Заметьте, что некоторые режимы блокировки "
"конфликтуют сами с собой (например, блокировкой <literal>ACCESS EXCLUSIVE</"
"literal> в один момент времени может владеть только одна транзакция), а "
"некоторые &mdash; нет (например, блокировку <literal>ACCESS SHARE</literal> "
"могут получить сразу несколько транзакций)."

#: mvcc.xml:849(title)
msgid "Table-level Lock Modes"
msgstr "Режимы блокировок на уровне таблицы"

#: mvcc.xml:852(literal)
msgctxt "literal"
msgid "ACCESS SHARE"
msgstr "ACCESS SHARE"

#: mvcc.xml:855(para)
msgid "Conflicts with the <literal>ACCESS EXCLUSIVE</literal> lock mode only."
msgstr ""
"Конфликтует только с режимом блокировки <literal>ACCESS EXCLUSIVE</literal>."

#: mvcc.xml:860(para)
msgid ""
"The <command>SELECT</command> command acquires a lock of this mode on "
"referenced tables. In general, any query that only <emphasis>reads</"
"emphasis> a table and does not modify it will acquire this lock mode."
msgstr ""
"Команда <command>SELECT</command> получает такую блокировку для таблиц, на "
"которые она ссылается. Вообще говоря, блокировку в этом режиме получает "
"любой запрос, который только <emphasis>читает</emphasis> таблицу, но не "
"меняет её данные."

#: mvcc.xml:870(literal)
msgctxt "literal"
msgid "ROW SHARE"
msgstr "ROW SHARE"

#: mvcc.xml:873(para)
msgid ""
"Conflicts with the <literal>EXCLUSIVE</literal> and <literal>ACCESS "
"EXCLUSIVE</literal> lock modes."
msgstr ""
"Конфликтует с режимами блокировки <literal>EXCLUSIVE</literal> и "
"<literal>ACCESS EXCLUSIVE</literal>."

#: mvcc.xml:878(para)
msgid ""
"The <command>SELECT FOR UPDATE</command> and <command>SELECT FOR SHARE</"
"command> commands acquire a lock of this mode on the target table(s) (in "
"addition to <literal>ACCESS SHARE</literal> locks on any other tables that "
"are referenced but not selected <option>FOR UPDATE/FOR SHARE</option>)."
msgstr ""
"Команды <command>SELECT FOR UPDATE</command> и <command>SELECT FOR SHARE</"
"command> получают такую блокировку для своих целевых таблиц (помимо "
"блокировок <literal>ACCESS SHARE</literal> для любых таблиц, которые "
"используется в этих запросов, но не в предложении <option>FOR UPDATE/FOR "
"SHARE</option>)."

#: mvcc.xml:891(literal)
msgctxt "literal"
msgid "ROW EXCLUSIVE"
msgstr "ROW EXCLUSIVE"

#: mvcc.xml:894(para)
msgid ""
"Conflicts with the <literal>SHARE</literal>, <literal>SHARE ROW EXCLUSIVE</"
"literal>, <literal>EXCLUSIVE</literal>, and <literal>ACCESS EXCLUSIVE</"
"literal> lock modes."
msgstr ""
"Конфликтует с режимами блокировки <literal>SHARE</literal>, <literal>SHARE "
"ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> и <literal>ACCESS "
"EXCLUSIVE</literal>."

#: mvcc.xml:900(para)
msgid ""
"The commands <command>UPDATE</command>, <command>DELETE</command>, and "
"<command>INSERT</command> acquire this lock mode on the target table (in "
"addition to <literal>ACCESS SHARE</literal> locks on any other referenced "
"tables). In general, this lock mode will be acquired by any command that "
"<emphasis>modifies data</emphasis> in a table."
msgstr ""
"Команды <command>UPDATE</command>, <command>DELETE</command> и "
"<command>INSERT</command> получают такую блокировку для целевой таблицы (в "
"дополнение к блокировкам <literal>ACCESS SHARE</literal> для всех других "
"задействованных таблиц). Вообще говоря, блокировку в этом режиме получает "
"любая команда, которая <emphasis>изменяет данные</emphasis> в таблице."

#: mvcc.xml:913(literal)
msgctxt "literal"
msgid "SHARE UPDATE EXCLUSIVE"
msgstr "SHARE UPDATE EXCLUSIVE"

#: mvcc.xml:916(para)
msgid ""
"Conflicts with the <literal>SHARE UPDATE EXCLUSIVE</literal>, "
"<literal>SHARE</literal>, <literal>SHARE ROW EXCLUSIVE</literal>, "
"<literal>EXCLUSIVE</literal>, and <literal>ACCESS EXCLUSIVE</literal> lock "
"modes. This mode protects a table against concurrent schema changes and "
"<command>VACUUM</command> runs."
msgstr ""
"Конфликтует с режимами блокировки <literal>SHARE UPDATE EXCLUSIVE</literal>, "
"<literal>SHARE</literal>, <literal>SHARE ROW EXCLUSIVE</literal>, "
"<literal>EXCLUSIVE</literal> и <literal>ACCESS EXCLUSIVE</literal>. Этот "
"режим защищает таблицу от параллельного изменения схемы и запуска процесса "
"<command>VACUUM</command>."

#: mvcc.xml:925(para)
msgid ""
"Acquired by <command>VACUUM</command> (without <option>FULL</option>), "
"<command>ANALYZE</command>, <command>CREATE INDEX CONCURRENTLY</command>, "
"and <command>ALTER TABLE VALIDATE</command> and other <command>ALTER TABLE</"
"command> variants (for full details see <xref linkend=\"sql-altertable\"/>)."
msgstr ""
"Запрашивается командами <command>VACUUM</command> (без <option>FULL</"
"option>), <command>ANALYZE</command>, <command>CREATE INDEX CONCURRENTLY</"
"command>, <command>ALTER TABLE VALIDATE</command> и другими видами "
"<command>ALTER TABLE</command> (за подробностями обратитесь к <xref remap="
"\"3\" linkend=\"sql-altertable\"/>)."

#: mvcc.xml:937(literal)
msgctxt "literal"
msgid "SHARE"
msgstr "SHARE"

#: mvcc.xml:940(para)
msgid ""
"Conflicts with the <literal>ROW EXCLUSIVE</literal>, <literal>SHARE UPDATE "
"EXCLUSIVE</literal>, <literal>SHARE ROW EXCLUSIVE</literal>, "
"<literal>EXCLUSIVE</literal>, and <literal>ACCESS EXCLUSIVE</literal> lock "
"modes. This mode protects a table against concurrent data changes."
msgstr ""
"Конфликтует с режимами блокировки <literal>ROW EXCLUSIVE</literal>, "
"<literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW EXCLUSIVE</"
"literal>, <literal>EXCLUSIVE</literal> и <literal>ACCESS EXCLUSIVE</"
"literal>. Этот режим защищает таблицу от параллельного изменения данных."

#: mvcc.xml:948(para)
msgid ""
"Acquired by <command>CREATE INDEX</command> (without <option>CONCURRENTLY</"
"option>)."
msgstr ""
"Запрашивается командой <command>CREATE INDEX</command> (без параметра "
"<option>CONCURRENTLY</option>)."

#: mvcc.xml:957(literal)
msgctxt "literal"
msgid "SHARE ROW EXCLUSIVE"
msgstr "SHARE ROW EXCLUSIVE"

#: mvcc.xml:960(para)
msgid ""
"Conflicts with the <literal>ROW EXCLUSIVE</literal>, <literal>SHARE UPDATE "
"EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE ROW EXCLUSIVE</"
"literal>, <literal>EXCLUSIVE</literal>, and <literal>ACCESS EXCLUSIVE</"
"literal> lock modes. This mode protects a table against concurrent data "
"changes, and is self-exclusive so that only one session can hold it at a "
"time."
msgstr ""
"Конфликтует с режимами блокировки <literal>ROW EXCLUSIVE</literal>, "
"<literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE</literal>, "
"<literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> и "
"<literal>ACCESS EXCLUSIVE</literal>. Этот режим защищает таблицу от "
"параллельных изменений данных и при этом он является самоисключающим, так "
"что такую блокировку может получить только один сеанс."

#: mvcc.xml:970(para)
msgid ""
"Acquired by <command>CREATE TRIGGER</command> and many forms of "
"<command>ALTER TABLE</command> (see <xref linkend=\"sql-altertable\"/>)."
msgstr ""
"Запрашивается командой <command>CREATE TRIGGER</command> и многими формами "
"<command>ALTER TABLE</command> (см. <xref remap=\"4\" linkend=\"sql-"
"altertable\"/>)."

#: mvcc.xml:979(literal)
msgctxt "literal"
msgid "EXCLUSIVE"
msgstr "EXCLUSIVE"

#: mvcc.xml:982(para)
msgid ""
"Conflicts with the <literal>ROW SHARE</literal>, <literal>ROW EXCLUSIVE</"
"literal>, <literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE</"
"literal>, <literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</"
"literal>, and <literal>ACCESS EXCLUSIVE</literal> lock modes. This mode "
"allows only concurrent <literal>ACCESS SHARE</literal> locks, i.e., only "
"reads from the table can proceed in parallel with a transaction holding this "
"lock mode."
msgstr ""
"Конфликтует с режимами блокировки <literal>ROW SHARE</literal>, <literal>ROW "
"EXCLUSIVE</literal>, <literal>SHARE UPDATE EXCLUSIVE</literal>, "
"<literal>SHARE</literal>, <literal>SHARE ROW EXCLUSIVE</literal>, "
"<literal>EXCLUSIVE</literal> и <literal>ACCESS EXCLUSIVE</literal>. Этот "
"режим совместим только с блокировкой <literal>ACCESS SHARE</literal>, то "
"есть параллельно с транзакцией, получившей блокировку в этой режиме, "
"допускается только чтение таблицы."

#: mvcc.xml:993(para)
msgid "Acquired by <command>REFRESH MATERIALIZED VIEW CONCURRENTLY</command>."
msgstr ""
"Запрашивается командой <command>REFRESH MATERIALIZED VIEW CONCURRENTLY</"
"command>."

#: mvcc.xml:1001(literal)
msgctxt "literal"
msgid "ACCESS EXCLUSIVE"
msgstr "ACCESS EXCLUSIVE"

#: mvcc.xml:1004(para)
msgid ""
"Conflicts with locks of all modes (<literal>ACCESS SHARE</literal>, "
"<literal>ROW SHARE</literal>, <literal>ROW EXCLUSIVE</literal>, "
"<literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE</literal>, "
"<literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and "
"<literal>ACCESS EXCLUSIVE</literal>). This mode guarantees that the holder "
"is the only transaction accessing the table in any way."
msgstr ""
"Конфликтует со всеми режимами блокировки (<literal>ACCESS SHARE</literal>, "
"<literal>ROW SHARE</literal>, <literal>ROW EXCLUSIVE</literal>, "
"<literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE</literal>, "
"<literal>SHARE ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal> и "
"<literal>ACCESS EXCLUSIVE</literal>). Этот режим гарантирует, что кроме "
"транзакции, получившей эту блокировку, никакая другая транзакция не может "
"обращаться к таблице каким-либо способом."

#: mvcc.xml:1015(para)
msgid ""
"Acquired by the <command>DROP TABLE</command>, <command>TRUNCATE</command>, "
"<command>REINDEX</command>, <command>CLUSTER</command>, <command>VACUUM "
"FULL</command>, and <command>REFRESH MATERIALIZED VIEW</command> (without "
"<option>CONCURRENTLY</option>) commands. Many forms of <command>ALTER TABLE</"
"command> also acquire a lock at this level. This is also the default lock "
"mode for <command>LOCK TABLE</command> statements that do not specify a mode "
"explicitly."
msgstr ""
"Запрашивается командами <command>DROP TABLE</command>, <command>TRUNCATE</"
"command>, <command>REINDEX</command>, <command>CLUSTER</command>, "
"<command>VACUUM FULL</command> и <command>REFRESH MATERIALIZED VIEW</"
"command> (без <option>CONCURRENTLY</option>). Блокировку на этом уровне "
"запрашивают также многие виды <command>ALTER TABLE</command>. В этом режиме "
"по умолчанию запрашивают блокировку и операторы <command>LOCK TABLE</"
"command>, если явно не выбран другой режим."

#: mvcc.xml:1031(para)
msgid ""
"Only an <literal>ACCESS EXCLUSIVE</literal> lock blocks a <command>SELECT</"
"command> (without <option>FOR UPDATE/SHARE</option>) statement."
msgstr ""
"Только блокировка <literal>ACCESS EXCLUSIVE</literal> блокирует оператор "
"<command>SELECT</command> (без <option>FOR UPDATE/SHARE</option>)."

#: mvcc.xml:1038(para)
msgid ""
"Once acquired, a lock is normally held till end of transaction. But if a "
"lock is acquired after establishing a savepoint, the lock is released "
"immediately if the savepoint is rolled back to. This is consistent with the "
"principle that <command>ROLLBACK</command> cancels all effects of the "
"commands since the savepoint. The same holds for locks acquired within a "
"<application>PL/pgSQL</application> exception block: an error escape from "
"the block releases locks acquired within it."
msgstr ""
"Полученная транзакцией блокировка обычно сохраняется до конца транзакции. Но "
"если блокировка получена после установки точки сохранения, она освобождается "
"немедленно в случае отката к этой точке. Это согласуется с принципом "
"действия <command>ROLLBACK</command> &mdash; эта команда отменяет эффекты "
"всех команд после точки сохранения. То же справедливо и для блокировок, "
"полученных в блоке исключений <application>PL/pgSQL</application>: при "
"выходе из блока с ошибкой такие блокировки освобождаются."

#: mvcc.xml:1051(title)
msgid "Conflicting Lock Modes"
msgstr "Конфликтующие режимы блокировки"

#: mvcc.xml:1058(entry) mvcc.xml:1291(entry)
msgid "Requested Lock Mode"
msgstr "Запраши&zwsp;ваемый режим блоки&zwsp;ровки"

#: mvcc.xml:1059(entry) mvcc.xml:1292(entry)
msgid "Current Lock Mode"
msgstr "Текущий режим блокировки"

#: mvcc.xml:1062(entry) mvcc.xml:1074(entry)
msgctxt "entry"
msgid "ACCESS SHARE"
msgstr "ACCESS SHARE"

#: mvcc.xml:1063(entry) mvcc.xml:1085(entry)
msgctxt "entry"
msgid "ROW SHARE"
msgstr "ROW SHARE"

#: mvcc.xml:1064(entry) mvcc.xml:1096(entry)
msgctxt "entry"
msgid "ROW EXCLUSIVE"
msgstr "ROW EXCLUSIVE"

#: mvcc.xml:1065(entry) mvcc.xml:1107(entry)
msgctxt "entry"
msgid "SHARE UPDATE EXCLUSIVE"
msgstr "SHARE UPDATE EXCLUSIVE"

#: mvcc.xml:1066(entry) mvcc.xml:1118(entry)
msgctxt "entry"
msgid "SHARE"
msgstr "SHARE"

#: mvcc.xml:1067(entry) mvcc.xml:1129(entry)
msgctxt "entry"
msgid "SHARE ROW EXCLUSIVE"
msgstr "SHARE ROW EXCLUSIVE"

#: mvcc.xml:1068(entry) mvcc.xml:1140(entry)
msgctxt "entry"
msgid "EXCLUSIVE"
msgstr "EXCLU&zwsp;SIVE"

#: mvcc.xml:1069(entry) mvcc.xml:1151(entry)
msgctxt "entry"
msgid "ACCESS EXCLUSIVE"
msgstr "ACCESS EXCLUSIVE"

#: mvcc.xml:1082(entry) mvcc.xml:1092(entry) mvcc.xml:1093(entry)
#: mvcc.xml:1101(entry) mvcc.xml:1102(entry) mvcc.xml:1103(entry)
#: mvcc.xml:1104(entry) mvcc.xml:1111(entry) mvcc.xml:1112(entry)
#: mvcc.xml:1113(entry) mvcc.xml:1114(entry) mvcc.xml:1115(entry)
#: mvcc.xml:1121(entry) mvcc.xml:1122(entry) mvcc.xml:1124(entry)
#: mvcc.xml:1125(entry) mvcc.xml:1126(entry) mvcc.xml:1132(entry)
#: mvcc.xml:1133(entry) mvcc.xml:1134(entry) mvcc.xml:1135(entry)
#: mvcc.xml:1136(entry) mvcc.xml:1137(entry) mvcc.xml:1142(entry)
#: mvcc.xml:1143(entry) mvcc.xml:1144(entry) mvcc.xml:1145(entry)
#: mvcc.xml:1146(entry) mvcc.xml:1147(entry) mvcc.xml:1148(entry)
#: mvcc.xml:1152(entry) mvcc.xml:1153(entry) mvcc.xml:1154(entry)
#: mvcc.xml:1155(entry) mvcc.xml:1156(entry) mvcc.xml:1157(entry)
#: mvcc.xml:1158(entry) mvcc.xml:1159(entry) mvcc.xml:1307(entry)
#: mvcc.xml:1313(entry) mvcc.xml:1314(entry) mvcc.xml:1319(entry)
#: mvcc.xml:1320(entry) mvcc.xml:1321(entry) mvcc.xml:1325(entry)
#: mvcc.xml:1326(entry) mvcc.xml:1327(entry) mvcc.xml:1328(entry)
msgid "X"
msgstr "X"

#: mvcc.xml:1167(title)
msgid "Row-level Locks"
msgstr "Блокировки на уровне строк"

#: mvcc.xml:1169(para)
msgid ""
"In addition to table-level locks, there are row-level locks, which are "
"listed as below with the contexts in which they are used automatically by "
"<productname>PostgreSQL</productname>. See <xref linkend=\"row-lock-"
"compatibility\"/> for a complete table of row-level lock conflicts. Note "
"that a transaction can hold conflicting locks on the same row, even in "
"different subtransactions; but other than that, two transactions can never "
"hold conflicting locks on the same row. Row-level locks do not affect data "
"querying; they block only <emphasis>writers and lockers</emphasis> to the "
"same row."
msgstr ""
"В дополнение к блокировкам на уровне таблицы, существуют блокировки на "
"уровне строк, перечисленные ниже с контекстами, где <productname>PostgreSQL</"
"productname> применяет их по умолчанию. Полный перечень конфликтов "
"блокировок на уровне строк приведён в <xref remap=\"6\" linkend=\"row-lock-"
"compatibility\"/>. Заметьте, что одна транзакция может владеть несколькими "
"конфликтующими блокировками одной строки, даже в разных подтранзакциях; но "
"две разных транзакции никогда не получат конфликтующие блокировки одной и "
"той же строки. Блокировки на уровне строк блокируют только <emphasis>запись "
"в определённые строки</emphasis>, но никак не влияют на выборку."

#: mvcc.xml:1182(title)
msgid "Row-level Lock Modes"
msgstr "Режимы блокировки на уровне строк"

#: mvcc.xml:1185(literal)
msgctxt "literal"
msgid "FOR UPDATE"
msgstr "FOR UPDATE"

#: mvcc.xml:1188(para)
msgid ""
"<literal>FOR UPDATE</literal> causes the rows retrieved by the "
"<command>SELECT</command> statement to be locked as though for update. This "
"prevents them from being locked, modified or deleted by other transactions "
"until the current transaction ends. That is, other transactions that attempt "
"<command>UPDATE</command>, <command>DELETE</command>, <command>SELECT FOR "
"UPDATE</command>, <command>SELECT FOR NO KEY UPDATE</command>, "
"<command>SELECT FOR SHARE</command> or <command>SELECT FOR KEY SHARE</"
"command> of these rows will be blocked until the current transaction ends; "
"conversely, <command>SELECT FOR UPDATE</command> will wait for a concurrent "
"transaction that has run any of those commands on the same row, and will "
"then lock and return the updated row (or no row, if the row was deleted). "
"Within a <literal>REPEATABLE READ</literal> or <literal>SERIALIZABLE</"
"literal> transaction, however, an error will be thrown if a row to be locked "
"has changed since the transaction started. For further discussion see <xref "
"linkend=\"applevel-consistency\"/>."
msgstr ""
"В режиме <literal>FOR UPDATE</literal> строки, выданные оператором "
"<command>SELECT</command>, блокируются как для изменения. При этом они "
"защищаются от блокировки, изменения и удаления другими транзакциями до "
"завершения текущей. То есть другие транзакции, пытающиеся выполнить "
"<command>UPDATE</command>, <command>DELETE</command>, <command>SELECT FOR "
"UPDATE</command>, <command>SELECT FOR NO KEY UPDATE</command>, "
"<command>SELECT FOR SHARE</command> или <command>SELECT FOR KEY SHARE</"
"command> с этими строками, будут заблокированы до завершения текущей "
"транзакции; и наоборот, команда <command>SELECT FOR UPDATE</command> будет "
"ожидать окончания параллельной транзакции, в которой выполнилась одна из "
"этих команд с той же строкой, а затем установит блокировку и вернёт "
"изменённую строку (или не вернёт, если она была удалена). Однако в "
"транзакции <literal>REPEATABLE READ</literal> или <literal>SERIALIZABLE</"
"literal> возникнет ошибка, если блокируемая строка изменилась с момента "
"начала транзакции. Подробнее это обсуждается в <xref remap=\"6\" linkend="
"\"applevel-consistency\"/>."

#: mvcc.xml:1210(para)
msgid ""
"The <literal>FOR UPDATE</literal> lock mode is also acquired by any "
"<command>DELETE</command> on a row, and also by an <command>UPDATE</command> "
"that modifies the values on certain columns. Currently, the set of columns "
"considered for the <command>UPDATE</command> case are those that have a "
"unique index on them that can be used in a foreign key (so partial indexes "
"and expressional indexes are not considered), but this may change in the "
"future."
msgstr ""
"Режим блокировки <literal>FOR UPDATE</literal> также запрашивается на уровне "
"строки любой командой <command>DELETE</command> и командой <command>UPDATE</"
"command>, изменяющей значения определённых столбцов. В настоящее время "
"блокировка с <command>UPDATE</command> касается столбцов, по которым создан "
"уникальный индекс, применимый в качестве внешнего ключа (так что на "
"частичные индексы и индексы выражений это не распространяется), но в будущем "
"это может поменяться."

#: mvcc.xml:1224(literal)
msgctxt "literal"
msgid "FOR NO KEY UPDATE"
msgstr "FOR NO KEY UPDATE"

#: mvcc.xml:1227(para)
msgid ""
"Behaves similarly to <literal>FOR UPDATE</literal>, except that the lock "
"acquired is weaker: this lock will not block <literal>SELECT FOR KEY SHARE</"
"literal> commands that attempt to acquire a lock on the same rows. This lock "
"mode is also acquired by any <command>UPDATE</command> that does not acquire "
"a <literal>FOR UPDATE</literal> lock."
msgstr ""
"Действует подобно <literal>FOR UPDATE</literal>, но запрашиваемая в этом "
"режиме блокировка слабее: она не будет блокировать команды <literal>SELECT "
"FOR KEY SHARE</literal>, пытающиеся получить блокировку тех же строк. Этот "
"режим блокировки также запрашивается любой командой <command>UPDATE</"
"command>, которая не требует блокировки <literal>FOR UPDATE</literal>."

#: mvcc.xml:1239(literal)
msgctxt "literal"
msgid "FOR SHARE"
msgstr "FOR SHARE"

#: mvcc.xml:1242(para)
msgid ""
"Behaves similarly to <literal>FOR NO KEY UPDATE</literal>, except that it "
"acquires a shared lock rather than exclusive lock on each retrieved row. A "
"shared lock blocks other transactions from performing <command>UPDATE</"
"command>, <command>DELETE</command>, <command>SELECT FOR UPDATE</command> or "
"<command>SELECT FOR NO KEY UPDATE</command> on these rows, but it does not "
"prevent them from performing <command>SELECT FOR SHARE</command> or "
"<command>SELECT FOR KEY SHARE</command>."
msgstr ""
"Действует подобно <literal>FOR NO KEY UPDATE</literal>, за исключением того, "
"что для каждой из полученных строк запрашивается разделяемая, а не "
"исключительная блокировка. Разделяемая блокировка не позволяет другим "
"транзакциям выполнять с этими строками <command>UPDATE</command>, "
"<command>DELETE</command>, <command>SELECT FOR UPDATE</command> или "
"<command>SELECT FOR NO KEY UPDATE</command>, но допускает <command>SELECT "
"FOR SHARE</command> и <command>SELECT FOR KEY SHARE</command>."

#: mvcc.xml:1257(literal)
msgctxt "literal"
msgid "FOR KEY SHARE"
msgstr "FOR KEY SHARE"

#: mvcc.xml:1260(para)
msgid ""
"Behaves similarly to <literal>FOR SHARE</literal>, except that the lock is "
"weaker: <literal>SELECT FOR UPDATE</literal> is blocked, but not "
"<literal>SELECT FOR NO KEY UPDATE</literal>. A key-shared lock blocks other "
"transactions from performing <command>DELETE</command> or any "
"<command>UPDATE</command> that changes the key values, but not other "
"<command>UPDATE</command>, and neither does it prevent <command>SELECT FOR "
"NO KEY UPDATE</command>, <command>SELECT FOR SHARE</command>, or "
"<command>SELECT FOR KEY SHARE</command>."
msgstr ""
"Действует подобно <literal>FOR SHARE</literal>, но устанавливает более "
"слабую блокировку: блокируется <literal>SELECT FOR UPDATE</literal>, но не "
"<literal>SELECT FOR NO KEY UPDATE</literal>. Блокировка разделяемого ключа "
"не позволяет другим транзакциям выполнять команды <command>DELETE</command> "
"и <command>UPDATE</command>, только если они меняют значение ключа (но не "
"другие <command>UPDATE</command>), и при этом допускает выполнение команд "
"<command>SELECT FOR NO KEY UPDATE</command>, <command>SELECT FOR SHARE</"
"command> и <command>SELECT FOR KEY SHARE</command>."

#: mvcc.xml:1274(para)
msgid ""
"<productname>PostgreSQL</productname> doesn't remember any information about "
"modified rows in memory, so there is no limit on the number of rows locked "
"at one time. However, locking a row might cause a disk write, e.g., "
"<command>SELECT FOR UPDATE</command> modifies selected rows to mark them "
"locked, and so will result in disk writes."
msgstr ""
"<productname>PostgreSQL</productname> не держит информацию об изменённых "
"строках в памяти, так что никаких ограничений на число блокируемых строк "
"нет. Однако блокировка строки может повлечь запись на диск, например, если "
"<command>SELECT FOR UPDATE</command> изменяет выбранные строки, чтобы "
"заблокировать их, при этом происходит запись на диск."

#: mvcc.xml:1284(title)
msgid "Conflicting Row-level Locks"
msgstr "Конфликтующие блокировки на уровне строк"

#: mvcc.xml:1295(entry) mvcc.xml:1303(entry)
msgctxt "entry"
msgid "FOR KEY SHARE"
msgstr "FOR KEY SHARE"

#: mvcc.xml:1296(entry) mvcc.xml:1310(entry)
msgctxt "entry"
msgid "FOR SHARE"
msgstr "FOR SHARE"

#: mvcc.xml:1297(entry) mvcc.xml:1317(entry)
msgctxt "entry"
msgid "FOR NO KEY UPDATE"
msgstr "FOR NO KEY UPDATE"

#: mvcc.xml:1298(entry) mvcc.xml:1324(entry)
msgctxt "entry"
msgid "FOR UPDATE"
msgstr "FOR UPDATE"

#: mvcc.xml:1336(title)
msgid "Page-level Locks"
msgstr "Блокировки на уровне страниц"

#: mvcc.xml:1338(para)
msgid ""
"In addition to table and row locks, page-level share/exclusive locks are "
"used to control read/write access to table pages in the shared buffer pool. "
"These locks are released immediately after a row is fetched or updated. "
"Application developers normally need not be concerned with page-level locks, "
"but they are mentioned here for completeness."
msgstr ""
"В дополнение к блокировкам на уровне таблицы и строк, для управления "
"доступом к страницам таблиц в общих буферах используются блокировки на "
"уровне страниц, исключительные и разделяемые. Эти блокировки освобождаются "
"немедленно после выборки или изменения строк. Разработчикам приложений "
"обычно можно не задумываться о блокировках страниц, здесь они упоминаются "
"только для полноты картины."

#: mvcc.xml:1349(title)
msgid "Deadlocks"
msgstr "Взаимоблокировки"

#: mvcc.xml:1351(indexterm)
msgid "<primary>deadlock</primary>"
msgstr "<primary>взаимоблокировка</primary>"

#: mvcc.xml:1355(para)
msgid ""
"The use of explicit locking can increase the likelihood of "
"<firstterm>deadlocks</firstterm>, wherein two (or more) transactions each "
"hold locks that the other wants. For example, if transaction 1 acquires an "
"exclusive lock on table A and then tries to acquire an exclusive lock on "
"table B, while transaction 2 has already exclusive-locked table B and now "
"wants an exclusive lock on table A, then neither one can proceed. "
"<productname>PostgreSQL</productname> automatically detects deadlock "
"situations and resolves them by aborting one of the transactions involved, "
"allowing the other(s) to complete. (Exactly which transaction will be "
"aborted is difficult to predict and should not be relied upon.)"
msgstr ""
"Частое применение явных блокировок может увеличить вероятность "
"<firstterm>взаимоблокировок</firstterm>, то есть ситуаций, когда две (или "
"более) транзакций держат блокировки так, что взаимно блокируют друг друга. "
"Например, если транзакция 1 получает исключительную блокировку таблицы A, а "
"затем пытается получить исключительную блокировку таблицы B, которую до "
"этого получила транзакция 2, в данный момент требующая исключительную "
"блокировку таблицы A, ни одна из транзакций не сможет продолжить работу. "
"<productname>PostgreSQL</productname> автоматически выявляет такие ситуации "
"и разрешает их, прерывая одну из сцепившихся транзакций и тем самым позволяя "
"другой (другим) продолжить работу. (Какая именно транзакция будет прервана, "
"обычно сложно предсказать, так что рассчитывать на определённое поведение не "
"следует.)"

#: mvcc.xml:1370(para)
msgid ""
"Note that deadlocks can also occur as the result of row-level locks (and "
"thus, they can occur even if explicit locking is not used). Consider the "
"case in which two concurrent transactions modify a table. The first "
"transaction executes: <screen>\n"
"UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;\n"
"</screen> This acquires a row-level lock on the row with the specified "
"account number. Then, the second transaction executes: <screen>\n"
"UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;\n"
"UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;\n"
"</screen> The first <command>UPDATE</command> statement successfully "
"acquires a row-level lock on the specified row, so it succeeds in updating "
"that row. However, the second <command>UPDATE</command> statement finds that "
"the row it is attempting to update has already been locked, so it waits for "
"the transaction that acquired the lock to complete. Transaction two is now "
"waiting on transaction one to complete before it continues execution. Now, "
"transaction one executes: <screen>\n"
"UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;\n"
"</screen> Transaction one attempts to acquire a row-level lock on the "
"specified row, but it cannot: transaction two already holds such a lock. So "
"it waits for transaction two to complete. Thus, transaction one is blocked "
"on transaction two, and transaction two is blocked on transaction one: a "
"deadlock condition. <productname>PostgreSQL</productname> will detect this "
"situation and abort one of the transactions."
msgstr ""
"Заметьте, что взаимоблокировки могут вызываться и блокировками на уровне "
"строк (таким образом, они возможны, даже если не применяются явные "
"блокировки). Рассмотрим случай, когда две параллельных транзакции изменяют "
"таблицу. Первая транзакция выполняет: <screen>\n"
"UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;\n"
"</screen> При этом она получает блокировку строки с указанным номером счёта. "
"Затем вторая транзакция выполняет: <screen>\n"
"UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;\n"
"UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;\n"
"</screen> Первый оператор <command>UPDATE</command> успешно получает "
"блокировку указанной строки и изменяет данные в ней. Однако второй оператор "
"<command>UPDATE</command> обнаруживает, что строка, которую он пытается "
"изменить, уже заблокирована, так что он ждёт завершения транзакции, "
"получившей блокировку. Таким образом, вторая транзакция сможет продолжиться "
"только после завершения первой. Теперь первая транзакция выполняет: "
"<screen>\n"
"UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;\n"
"</screen> Первая транзакция пытается получить блокировку заданной строки, но "
"ей это не удаётся: эта блокировка уже принадлежит второй транзакции. Поэтому "
"первой транзакции остаётся только ждать завершения второй. В результате "
"первая транзакция блокируется второй, а вторая &mdash; первой: происходит "
"взаимоблокировка. <productname>PostgreSQL</productname> выявляет эту "
"ситуацию и прерывает одну из транзакций."

#: mvcc.xml:1410(para)
msgid ""
"The best defense against deadlocks is generally to avoid them by being "
"certain that all applications using a database acquire locks on multiple "
"objects in a consistent order. In the example above, if both transactions "
"had updated the rows in the same order, no deadlock would have occurred. One "
"should also ensure that the first lock acquired on an object in a "
"transaction is the most restrictive mode that will be needed for that "
"object. If it is not feasible to verify this in advance, then deadlocks can "
"be handled on-the-fly by retrying transactions that abort due to deadlocks."
msgstr ""
"Обычно лучший способ предотвращения взаимоблокировок &mdash; добиться, чтобы "
"все приложения, обращающиеся к базе данных, запрашивали блокировки "
"нескольких объектов единообразно. В данном примере, если бы обе транзакции "
"изменяли строки в одном порядке, взаимоблокировка бы не произошла. "
"Блокировки в транзакции следует упорядочивать так, чтобы первой для какого-"
"либо объекта запрашивалась наиболее ограничивающая из тех, которые для него "
"потребуются. Если заранее обеспечить такой порядок нельзя, взаимоблокировки "
"можно обработать по факту, повторяя прерванные транзакции."

#: mvcc.xml:1423(para)
msgid ""
"So long as no deadlock situation is detected, a transaction seeking either a "
"table-level or row-level lock will wait indefinitely for conflicting locks "
"to be released. This means it is a bad idea for applications to hold "
"transactions open for long periods of time (e.g., while waiting for user "
"input)."
msgstr ""
"Если ситуация взаимоблокировки не будет выявлена, транзакция, ожидающая "
"блокировки на уровне таблицы или строки, будет ждать её освобождения "
"неограниченное время. Это означает, что приложения не должны оставлять "
"транзакции открытыми долгое время (например, ожидая ввода пользователя)."

#: mvcc.xml:1433(title)
msgid "Advisory Locks"
msgstr "Рекомендательные блокировки"

#: mvcc.xml:1435(indexterm)
msgid "<primary>advisory lock</primary>"
msgstr "<primary>рекомендательная блокировка</primary>"

#: mvcc.xml:1439(indexterm)
msgid "<primary>lock</primary> <secondary>advisory</secondary>"
msgstr "<primary>блокировка</primary> <secondary>рекомендательная</secondary>"

#: mvcc.xml:1444(para)
msgid ""
"<productname>PostgreSQL</productname> provides a means for creating locks "
"that have application-defined meanings. These are called <firstterm>advisory "
"locks</firstterm>, because the system does not enforce their use &mdash; it "
"is up to the application to use them correctly. Advisory locks can be useful "
"for locking strategies that are an awkward fit for the MVCC model. For "
"example, a common use of advisory locks is to emulate pessimistic locking "
"strategies typical of so-called <quote>flat file</quote> data management "
"systems. While a flag stored in a table could be used for the same purpose, "
"advisory locks are faster, avoid table bloat, and are automatically cleaned "
"up by the server at the end of the session."
msgstr ""
"<productname>PostgreSQL</productname> также имеет средства создания "
"блокировок, смысл которых определяют сами приложения. Такие блокировки "
"называются <firstterm>рекомендательными</firstterm>, так как система не "
"форсирует их использование &mdash; правильно их использовать должно само "
"приложение. Рекомендательные блокировки бывают полезны для реализаций "
"стратегий блокирования, плохо вписывающихся в модель MVCC. Например, "
"рекомендательные блокировки часто применяются для исполнения стратегии "
"пессимистичной блокировки, типичной для систем управления данными "
"<quote>плоский файл</quote>. Хотя для этого можно использовать и "
"дополнительные флаги в таблицах, рекомендательные блокировки работают "
"быстрее, не нагружают таблицы и автоматически ликвидируется сервером в конце "
"сеанса."

#: mvcc.xml:1459(para)
msgid ""
"There are two ways to acquire an advisory lock in <productname>PostgreSQL</"
"productname>: at session level or at transaction level. Once acquired at "
"session level, an advisory lock is held until explicitly released or the "
"session ends. Unlike standard lock requests, session-level advisory lock "
"requests do not honor transaction semantics: a lock acquired during a "
"transaction that is later rolled back will still be held following the "
"rollback, and likewise an unlock is effective even if the calling "
"transaction fails later. A lock can be acquired multiple times by its owning "
"process; for each completed lock request there must be a corresponding "
"unlock request before the lock is actually released. Transaction-level lock "
"requests, on the other hand, behave more like regular lock requests: they "
"are automatically released at the end of the transaction, and there is no "
"explicit unlock operation. This behavior is often more convenient than the "
"session-level behavior for short-term usage of an advisory lock. Session-"
"level and transaction-level lock requests for the same advisory lock "
"identifier will block each other in the expected way. If a session already "
"holds a given advisory lock, additional requests by it will always succeed, "
"even if other sessions are awaiting the lock; this statement is true "
"regardless of whether the existing lock hold and new request are at session "
"level or transaction level."
msgstr ""
"В <productname>PostgreSQL</productname> есть два варианта получить "
"рекомендательные блокировки: на уровне сеанса и на уровне транзакции. "
"Рекомендательная блокировка, полученная на уровне сеанса, удерживается, пока "
"она не будет явно освобождена, или до конца сеанса. В отличие от стандартных "
"рекомендательные блокировки уровня сеанса нарушают логику транзакций &mdash; "
"блокировка, полученная в транзакции, даже если произойдёт откат этой "
"транзакции, будет сохраняться в сеансе; аналогично, освобождение блокировки "
"остаётся в силе, даже если транзакция, в которой оно было выполнено, позже "
"прерывается. Вызывающий процесс может запросить блокировку несколько раз; "
"при этом каждому запросу блокировки должен соответствовать запрос "
"освобождения, чтобы она была действительно освобождена. Рекомендательные "
"блокировки на уровне транзакций, напротив, во многом похожи на обычные "
"блокировки: они автоматически освобождаются в конце транзакций и не требуют "
"явного освобождения. Для кратковременного применения блокировок это "
"поведение часто более уместно, чем поведение рекомендательных блокировок на "
"уровне сеанса. Запросы рекомендательных блокировок одного идентификатора на "
"уровне сеанса и на уровне транзакции будут блокировать друг друга вполне "
"предсказуемым образом. Если сеанс уже владеет данной рекомендуемой "
"блокировкой, дополнительные запросы её в том же сеансе будут всегда успешны, "
"даже если её ожидают другие сеансы. Это утверждение справедливо вне "
"зависимости от того, на каком уровне (сеанса или транзакции) установлены или "
"запрашиваются новые блокировки."

#: mvcc.xml:1484(para)
msgid ""
"Like all locks in <productname>PostgreSQL</productname>, a complete list of "
"advisory locks currently held by any session can be found in the <link "
"linkend=\"view-pg-locks\"><structname>pg_locks</structname></link> system "
"view."
msgstr ""
"Как и остальные блокировки в <productname>PostgreSQL</productname>, все "
"рекомендательные блокировки, связанные с любыми сеансами, можно просмотреть "
"в системном представлении <link linkend=\"view-pg-locks"
"\"><structname>pg_locks</structname></link>."

#: mvcc.xml:1492(para)
msgid ""
"Both advisory locks and regular locks are stored in a shared memory pool "
"whose size is defined by the configuration variables <xref linkend=\"guc-max-"
"locks-per-transaction\"/> and <xref linkend=\"guc-max-connections\"/>. Care "
"must be taken not to exhaust this memory or the server will be unable to "
"grant any locks at all. This imposes an upper limit on the number of "
"advisory locks grantable by the server, typically in the tens to hundreds of "
"thousands depending on how the server is configured."
msgstr ""
"И рекомендательные, и обычные блокировки сохраняются в области общей памяти, "
"размер которой определяется параметрами конфигурации <xref linkend=\"guc-max-"
"locks-per-transaction\"/> и <xref linkend=\"guc-max-connections\"/>. Важно, "
"чтобы этой памяти было достаточно, так как в противном случае сервер не "
"сможет выдать никакую блокировку. Таким образом, число рекомендуемых "
"блокировок, которые может выдать сервер, ограничивается обычно десятками или "
"сотнями тысяч в зависимости от конфигурации сервера."

#: mvcc.xml:1504(para)
msgid ""
"In certain cases using advisory locking methods, especially in queries "
"involving explicit ordering and <literal>LIMIT</literal> clauses, care must "
"be taken to control the locks acquired because of the order in which SQL "
"expressions are evaluated. For example: <screen>\n"
"SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok\n"
"SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- "
"danger!\n"
"SELECT pg_advisory_lock(q.id) FROM\n"
"(\n"
"  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100\n"
") q; -- ok\n"
"</screen> In the above queries, the second form is dangerous because the "
"<literal>LIMIT</literal> is not guaranteed to be applied before the locking "
"function is executed. This might cause some locks to be acquired that the "
"application was not expecting, and hence would fail to release (until it "
"ends the session). From the point of view of the application, such locks "
"would be dangling, although still viewable in <structname>pg_locks</"
"structname>."
msgstr ""
"В определённых случаях при использовании рекомендательных блокировок, "
"особенно в запросах с явными указаниями <literal>ORDER BY</literal> и "
"<literal>LIMIT</literal>, важно учитывать, что получаемые блокировки могут "
"зависеть от порядка вычисления SQL-выражений. Например: <screen>\n"
"SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok\n"
"SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- "
"опасно!\n"
"SELECT pg_advisory_lock(q.id) FROM\n"
"(\n"
"  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100\n"
") q; -- ok\n"
"</screen> В этом примере второй вариант опасен, так как <literal>LIMIT</"
"literal> не обязательно будет применяться перед вызовом функции блокировки. "
"В результате приложение может получить блокировки, на которые оно не "
"рассчитывает и которые оно не сможет освободить (до завершения сеанса). С "
"точки зрения приложения такие блокировки окажутся в подвешенном состоянии, "
"хотя они и будут отображаться в <structname>pg_locks</structname>."

#: mvcc.xml:1527(para)
msgid ""
"The functions provided to manipulate advisory locks are described in <xref "
"linkend=\"functions-advisory-locks\"/>."
msgstr ""
"Функции, предназначенные для работы с рекомендательными блокировками, "
"описаны в <xref remap=\"6\" linkend=\"functions-advisory-locks\"/>."

#: mvcc.xml:1536(title)
msgid "Data Consistency Checks at the Application Level"
msgstr "Проверки целостности данных на уровне приложения"

#: mvcc.xml:1538(para)
msgid ""
"It is very difficult to enforce business rules regarding data integrity "
"using Read Committed transactions because the view of the data is shifting "
"with each statement, and even a single statement may not restrict itself to "
"the statement's snapshot if a write conflict occurs."
msgstr ""
"Используя транзакции Read Committed, очень сложно обеспечить целостность "
"данных с точки зрения бизнес-логики, так как представление данных смещается "
"с каждым оператором и даже один оператор может не ограничиваться своим "
"снимком состояния в случае конфликта записи."

#: mvcc.xml:1545(para)
msgid ""
"While a Repeatable Read transaction has a stable view of the data throughout "
"its execution, there is a subtle issue with using <acronym>MVCC</acronym> "
"snapshots for data consistency checks, involving something known as "
"<firstterm>read/write conflicts</firstterm>. If one transaction writes data "
"and a concurrent transaction attempts to read the same data (whether before "
"or after the write), it cannot see the work of the other transaction. The "
"reader then appears to have executed first regardless of which started first "
"or which committed first. If that is as far as it goes, there is no problem, "
"but if the reader also writes data which is read by a concurrent transaction "
"there is now a transaction which appears to have run before either of the "
"previously mentioned transactions. If the transaction which appears to have "
"executed last actually commits first, it is very easy for a cycle to appear "
"in a graph of the order of execution of the transactions. When such a cycle "
"appears, integrity checks will not work correctly without some help."
msgstr ""
"Хотя транзакция Repeatable Read получает стабильное представление данных в "
"процессе выполнения, с использованием снимков <acronym>MVCC</acronym> для "
"проверки целостности данных всё же связаны тонкие моменты, включая так "
"называемые <firstterm>конфликты чтения/записи</firstterm>. Если одна "
"транзакция записывает данные, а другая в это же время пытается их прочитать "
"(до или после записи), она не может увидеть результат работы первой. В таком "
"случае создаётся впечатление, что читающая транзакция выполняется первой вне "
"зависимости от того, какая из них была начата или зафиксирована раньше. Если "
"этим всё и ограничивается, нет никаких проблем, но если читающая транзакция "
"также пишет данные, которые читает параллельная транзакция, получается, что "
"теперь эта транзакция будет исполняться, как будто она запущена перед "
"другими вышеупомянутыми. Если же транзакция, которая должна исполняться как "
"последняя, на самом деле зафиксирована первой, в графе упорядоченных "
"транзакций легко может возникнуть цикл. И когда он возникает, проверки "
"целостности не будут работать правильно без дополнительных мер."

#: mvcc.xml:1564(para)
msgid ""
"As mentioned in <xref linkend=\"xact-serializable\"/>, Serializable "
"transactions are just Repeatable Read transactions which add nonblocking "
"monitoring for dangerous patterns of read/write conflicts. When a pattern is "
"detected which could cause a cycle in the apparent order of execution, one "
"of the transactions involved is rolled back to break the cycle."
msgstr ""
"Как было сказано в <xref remap=\"6\" linkend=\"xact-serializable\"/>, "
"сериализуемые транзакции представляют собой те же транзакции Repeatable "
"Read, но дополненные неблокирующим механизмом отслеживания опасных условий "
"конфликтов чтения/записи. Когда выявляется условие, приводящее к циклу в "
"порядке транзакций, одна из этих транзакций откатывается и этот цикл таким "
"образом разрывается."

#: mvcc.xml:1574(title)
msgid "Enforcing Consistency With Serializable Transactions"
msgstr "Обеспечение согласованности в сериализуемых транзакциях"

#: mvcc.xml:1576(para)
msgid ""
"If the Serializable transaction isolation level is used for all writes and "
"for all reads which need a consistent view of the data, no other effort is "
"required to ensure consistency. Software from other environments which is "
"written to use serializable transactions to ensure consistency should "
"<quote>just work</quote> in this regard in <productname>PostgreSQL</"
"productname>."
msgstr ""
"Если для всех операций чтения и записи, нуждающихся в согласованном "
"представлении данных, используются транзакции уровня изоляции Serializable, "
"это обеспечивает необходимую согласованность без дополнительных усилий. "
"Приложения из других окружений, применяющие сериализуемые транзакции для "
"обеспечения целостности, в <productname>PostgreSQL</productname> в этом "
"смысле будут <quote>просто работать</quote>."

#: mvcc.xml:1585(para)
msgid ""
"When using this technique, it will avoid creating an unnecessary burden for "
"application programmers if the application software goes through a framework "
"which automatically retries transactions which are rolled back with a "
"serialization failure. It may be a good idea to set "
"<literal>default_transaction_isolation</literal> to <literal>serializable</"
"literal>. It would also be wise to take some action to ensure that no other "
"transaction isolation level is used, either inadvertently or to subvert "
"integrity checks, through checks of the transaction isolation level in "
"triggers."
msgstr ""
"Применение этого подхода избавляет программистов приложений от лишних "
"сложностей, если приложение использует инфраструктуру, которая автоматически "
"повторяет транзакции в случае отката из-за сбоев сериализации. Возможно, "
"<literal>serializable</literal> стоит даже установить в качестве уровня "
"изоляции по умолчанию (<literal>default_transaction_isolation</literal>). "
"Также имеет смысл принять меры для предотвращения использования других "
"уровней изоляции, непреднамеренного или с целью обойти проверки целостности, "
"например проверять уровень изоляции в триггерах."

#: mvcc.xml:1597(para)
msgid "See <xref linkend=\"xact-serializable\"/> for performance suggestions."
msgstr ""
"Рекомендации по увеличению быстродействия приведены в <xref remap=\"6\" "
"linkend=\"xact-serializable\"/>."

#: mvcc.xml:1602(para)
msgid ""
"This level of integrity protection using Serializable transactions does not "
"yet extend to hot standby mode (<xref linkend=\"hot-standby\"/>). Because of "
"that, those using hot standby may want to use Repeatable Read and explicit "
"locking on the master."
msgstr ""
"Защита целостности с применением сериализуемых транзакций пока ещё не "
"поддерживается в режиме горячего резерва (<xref linkend=\"hot-standby\"/>). "
"Поэтому там, где применяется горячий резерв, следует использовать уровень "
"Repeatable Read и явные блокировки на главном сервере."

#: mvcc.xml:1612(title)
msgid "Enforcing Consistency With Explicit Blocking Locks"
msgstr "Применение явных блокировок для обеспечения согласованности"

#: mvcc.xml:1614(para)
msgid ""
"When non-serializable writes are possible, to ensure the current validity of "
"a row and protect it against concurrent updates one must use <command>SELECT "
"FOR UPDATE</command>, <command>SELECT FOR SHARE</command>, or an appropriate "
"<command>LOCK TABLE</command> statement. (<command>SELECT FOR UPDATE</"
"command> and <command>SELECT FOR SHARE</command> lock just the returned rows "
"against concurrent updates, while <command>LOCK TABLE</command> locks the "
"whole table.) This should be taken into account when porting applications to "
"<productname>PostgreSQL</productname> from other environments."
msgstr ""
"Когда возможны несериализуемые операции записи, для обеспечения целостности "
"строк и защиты от одновременных изменений, следует использовать "
"<command>SELECT FOR UPDATE</command>, <command>SELECT FOR SHARE</command> "
"или соответствующий оператор <command>LOCK TABLE</command>. (<command>SELECT "
"FOR UPDATE</command> и <command>SELECT FOR SHARE</command> защищают от "
"параллельных изменений только возвращаемые строки, тогда как <command>LOCK "
"TABLE</command> блокирует всю таблицу.) Это следует учитывать, перенося в "
"<productname>PostgreSQL</productname> приложения из других СУБД."

#: mvcc.xml:1627(para)
msgid ""
"Also of note to those converting from other environments is the fact that "
"<command>SELECT FOR UPDATE</command> does not ensure that a concurrent "
"transaction will not update or delete a selected row. To do that in "
"<productname>PostgreSQL</productname> you must actually update the row, even "
"if no values need to be changed. <command>SELECT FOR UPDATE</command> "
"<emphasis>temporarily blocks</emphasis> other transactions from acquiring "
"the same lock or executing an <command>UPDATE</command> or <command>DELETE</"
"command> which would affect the locked row, but once the transaction holding "
"this lock commits or rolls back, a blocked transaction will proceed with the "
"conflicting operation unless an actual <command>UPDATE</command> of the row "
"was performed while the lock was held."
msgstr ""
"Мигрируя в <productname>PostgreSQL</productname> из других СУБД также "
"следует учитывать, что команда <command>SELECT FOR UPDATE</command> сама по "
"себе не гарантирует, что параллельная транзакция не изменит или не удалит "
"выбранную строку. Для получения такой гарантии в <productname>PostgreSQL</"
"productname> нужно именно изменить эту строку, даже если никакие значения в "
"ней менять не требуется. <command>SELECT FOR UPDATE</command> "
"<emphasis>временно блокирует</emphasis> другие транзакции, не давая им "
"получить ту же блокировку или выполнить команды <command>UPDATE</command> "
"или <command>DELETE</command>, которые бы повлияли на заблокированную "
"строку, но как только транзакция, владеющая этой блокировкой, фиксируется "
"или откатывается, заблокированная транзакция сможет выполнить конфликтующую "
"операцию, если только для данной строки действительно не был выполнен "
"<command>UPDATE</command>, пока транзакция владела блокировкой."

#: mvcc.xml:1642(para)
msgid ""
"Global validity checks require extra thought under non-serializable "
"<acronym>MVCC</acronym>. For example, a banking application might wish to "
"check that the sum of all credits in one table equals the sum of debits in "
"another table, when both tables are being actively updated. Comparing the "
"results of two successive <literal>SELECT sum(...)</literal> commands will "
"not work reliably in Read Committed mode, since the second query will likely "
"include the results of transactions not counted by the first. Doing the two "
"sums in a single repeatable read transaction will give an accurate picture "
"of only the effects of transactions that committed before the repeatable "
"read transaction started &mdash; but one might legitimately wonder whether "
"the answer is still relevant by the time it is delivered. If the repeatable "
"read transaction itself applied some changes before trying to make the "
"consistency check, the usefulness of the check becomes even more debatable, "
"since now it includes some but not all post-transaction-start changes. In "
"such cases a careful person might wish to lock all tables needed for the "
"check, in order to get an indisputable picture of current reality. A "
"<literal>SHARE</literal> mode (or higher) lock guarantees that there are no "
"uncommitted changes in the locked table, other than those of the current "
"transaction."
msgstr ""
"Реализация глобальной целостности с использованием несериализуемых "
"транзакций <acronym>MVCC</acronym> требует более вдумчивого подхода. "
"Например, банковскому приложению может потребоваться проверить, равняется ли "
"сумма всех расходов в одной таблице сумме приходов в другой, при том, что "
"обе таблицы активно изменяются. Просто сравнивать результаты двух успешных "
"последовательных команд <literal>SELECT sum(...)</literal> в режиме Read "
"Committed нельзя, так как вторая команда может захватить результаты "
"транзакций, пропущенных первой. Подсчитывая суммы в одной транзакции "
"Repeatable Read, можно получить точную картину только для транзакций, "
"которые были зафиксированы до начала данной, но при этом может возникнуть "
"законный вопрос &mdash; будет ли этот результат актуален тогда, когда он "
"будет выдан. Если транзакция Repeatable Read сама вносит какие-то изменения, "
"прежде чем проверять равенство сумм, полезность этой проверки становится ещё "
"более сомнительной, так как при проверке будут учитываться некоторые, но не "
"все изменения, произошедшие после начала транзакции. В таких случаях "
"предусмотрительный разработчик может заблокировать все таблицы, "
"задействованные в проверке, чтобы получить картину действительности, не "
"вызывающую сомнений. Для этого применяется блокировка <literal>SHARE</"
"literal> (или более строгая), которая гарантирует, что в заблокированной "
"таблице не будет незафиксированных изменений, за исключением тех, что внесла "
"текущая транзакция."

#: mvcc.xml:1665(para)
msgid ""
"Note also that if one is relying on explicit locking to prevent concurrent "
"changes, one should either use Read Committed mode, or in Repeatable Read "
"mode be careful to obtain locks before performing queries. A lock obtained "
"by a repeatable read transaction guarantees that no other transactions "
"modifying the table are still running, but if the snapshot seen by the "
"transaction predates obtaining the lock, it might predate some now-committed "
"changes in the table. A repeatable read transaction's snapshot is actually "
"frozen at the start of its first query or data-modification command "
"(<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, or <literal>DELETE</literal>), so it is possible to obtain locks "
"explicitly before the snapshot is frozen."
msgstr ""
"Также заметьте, что, применяя явные блокировки для предотвращения "
"параллельных операций записи, следует использовать либо режим Read "
"Committed, либо в режиме Repeatable Read обязательно получать блокировки "
"прежде, чем выполнять запросы. Блокировка, получаемая транзакцией Repeatable "
"Read, гарантирует, что никакая другая транзакция, изменяющая таблицу, не "
"выполняется, но если снимок состояния, полученный транзакцией, предшествует "
"блокировке, он может не включать на данный момент уже зафиксированные "
"изменения. Снимок состояния в транзакции Repeatable Read создаётся "
"фактически на момент начала первой команды выборки или изменения данных "
"(<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal> или <literal>DELETE</literal>), так что получить явные блокировки "
"можно до того, как он будет сформирован."

#: mvcc.xml:1684(title)
msgid "Caveats"
msgstr "Ограничения"

#: mvcc.xml:1686(para)
msgid ""
"Some DDL commands, currently only <xref linkend=\"sql-truncate\"/> and the "
"table-rewriting forms of <xref linkend=\"sql-altertable\"/>, are not MVCC-"
"safe. This means that after the truncation or rewrite commits, the table "
"will appear empty to concurrent transactions, if they are using a snapshot "
"taken before the DDL command committed. This will only be an issue for a "
"transaction that did not access the table in question before the DDL command "
"started &mdash; any transaction that has done so would hold at least an "
"<literal>ACCESS SHARE</literal> table lock, which would block the DDL "
"command until that transaction completes. So these commands will not cause "
"any apparent inconsistency in the table contents for successive queries on "
"the target table, but they could cause visible inconsistency between the "
"contents of the target table and other tables in the database."
msgstr ""
"Некоторые команды DDL, в настоящее время это <xref linkend=\"sql-truncate\"/"
"> и формы <xref linkend=\"sql-altertable\"/>, перезаписывающие таблицу, не "
"являются безопасными с точки зрения MVCC. Это значит, что после фиксации "
"усечения или перезаписи таблица окажется пустой для всех параллельных "
"транзакций, если они работают со снимком, полученным перед фиксацией такой "
"команды DDL. Это может проявиться только в транзакции, которая не обращалась "
"к таблице до момента начала команды DDL &mdash; любая транзакция, которая "
"обращалась к ней раньше, получила бы как минимум блокировку <literal>ACCESS "
"SHARE</literal>, которая заблокировала бы эту команду DDL до завершения "
"транзакции. Поэтому такие команды не приводят ни к каким видимым "
"несоответствиям с содержимым таблицы при последовательных запросах к целевой "
"таблице, хотя возможно видимое несоответствие между содержимым целевой "
"таблицы и другими таблицами в базе данных."

#: mvcc.xml:1702(para)
msgid ""
"Support for the Serializable transaction isolation level has not yet been "
"added to Hot Standby replication targets (described in <xref linkend=\"hot-"
"standby\"/>). The strictest isolation level currently supported in hot "
"standby mode is Repeatable Read. While performing all permanent database "
"writes within Serializable transactions on the master will ensure that all "
"standbys will eventually reach a consistent state, a Repeatable Read "
"transaction run on the standby can sometimes see a transient state that is "
"inconsistent with any serial execution of the transactions on the master."
msgstr ""
"Поддержка уровня изоляции Serializable ещё не реализована для целевых "
"серверов горячего резерва (они описываются в <xref remap=\"6\" linkend=\"hot-"
"standby\"/>). На данный момент самый строгий уровень изоляции, "
"поддерживаемый в режиме горячего резерва, это Repeatable Read. Хотя и тогда, "
"когда главный сервер выполняет запись в транзакциях Serializable, все "
"резервные серверы в итоге достигают согласованного состояния, но транзакция "
"Repeatable Read на резервном сервере иногда может увидеть промежуточное "
"состояние, не соответствующее результату последовательного выполнения "
"транзакций на главном сервере."

#: mvcc.xml:1716(title)
msgid "Locking and Indexes"
msgstr "Блокировки и индексы"

#: mvcc.xml:1718(indexterm)
msgid "<primary>index</primary> <secondary>locks</secondary>"
msgstr "<primary>индексы</primary> <secondary>блокировки</secondary>"

#: mvcc.xml:1733(term)
msgid "B-tree, <acronym>GiST</acronym> and <acronym>SP-GiST</acronym> indexes"
msgstr ""
"Индексы типа B-дерево, <acronym>GiST</acronym> и <acronym>SP-GiST</acronym>"

#: mvcc.xml:1737(para)
msgid ""
"Short-term share/exclusive page-level locks are used for read/write access. "
"Locks are released immediately after each index row is fetched or inserted. "
"These index types provide the highest concurrency without deadlock "
"conditions."
msgstr ""
"Для управления чтением/записью используются кратковременные блокировки на "
"уровне страницы, исключительные и разделяемые. Блокировки освобождаются "
"сразу после извлечения или добавления строки индекса. Эти типы индексов "
"обеспечивают максимальное распараллеливание операций, не допуская "
"взаимоблокировок."

#: mvcc.xml:1747(term)
msgid "Hash indexes"
msgstr "Хеш-индексы"

#: mvcc.xml:1751(para)
msgid ""
"Share/exclusive hash-bucket-level locks are used for read/write access. "
"Locks are released after the whole bucket is processed. Bucket-level locks "
"provide better concurrency than index-level ones, but deadlock is possible "
"since the locks are held longer than one index operation."
msgstr ""
"Для управления чтением/записью используются блокировки на уровне групп хеша. "
"Блокировки освобождаются после обработки всей группы. Такие блокировки с "
"точки зрения распараллеливания лучше, чем блокировки на уровне индекса, но "
"не исключают взаимоблокировок, так как они сохраняются дольше, чем "
"выполняется одна операция с индексом."

#: mvcc.xml:1762(term)
msgid "<acronym>GIN</acronym> indexes"
msgstr "Индексы <acronym>GIN</acronym>"

#: mvcc.xml:1766(para)
msgid ""
"Short-term share/exclusive page-level locks are used for read/write access. "
"Locks are released immediately after each index row is fetched or inserted. "
"But note that insertion of a GIN-indexed value usually produces several "
"index key insertions per row, so GIN might do substantial work for a single "
"value's insertion."
msgstr ""
"Для управления чтением/записью используются кратковременные блокировки на "
"уровне страницы, исключительные и разделяемые. Блокировки освобождаются "
"сразу после извлечения или добавления строки индекса. Но заметьте, что "
"добавление значения в поле с GIN-индексом обычно влечёт добавление "
"нескольких ключей индекса, так что GIN может проделывать целый ряд операций "
"для одного значения."

#: mvcc.xml:1723(para)
msgid ""
"Though <productname>PostgreSQL</productname> provides nonblocking read/write "
"access to table data, nonblocking read/write access is not currently offered "
"for every index access method implemented in <productname>PostgreSQL</"
"productname>. The various index types are handled as follows: <placeholder-1/"
">"
msgstr ""
"Хотя <productname>PostgreSQL</productname> обеспечивает неблокирующий доступ "
"на чтение/запись к данным таблиц, для индексов в настоящий момент это "
"поддерживается не в полной мере. <productname>PostgreSQL</productname> "
"управляет доступом к различным типам индексов следующим образом: "
"<placeholder-1/>"

#: mvcc.xml:1779(para)
msgid ""
"Currently, B-tree indexes offer the best performance for concurrent "
"applications; since they also have more features than hash indexes, they are "
"the recommended index type for concurrent applications that need to index "
"scalar data. When dealing with non-scalar data, B-trees are not useful, and "
"GiST, SP-GiST or GIN indexes should be used instead."
msgstr ""
"В настоящее время в многопоточной среде наиболее производительны индексы-B-"
"деревья; и так как они более функциональны, чем хеш-индексы, их "
"рекомендуется использовать в такой среде для приложений, когда нужно "
"индексировать скалярные данные. Если же нужно индексировать не скалярные "
"данные, B-деревья не подходят, и вместо них следует использовать индексы "
"GiST, SP-GiST или GIN."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: mvcc.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
