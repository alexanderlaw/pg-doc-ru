# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-08-09 16:00+0300\n"
"PO-Revision-Date: 2017-05-12 10:46+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: wal.xml:5(title)
msgid "Reliability and the Write-Ahead Log"
msgstr "Надёжность и журнал упреждающей записи"

#: wal.xml:7(para)
msgid ""
"This chapter explains how the Write-Ahead Log is used to obtain efficient, "
"reliable operation."
msgstr ""
"В данной главе рассказывается, как для обеспечения эффективной и надёжной "
"работы используется журнал упреждающей записи."

#: wal.xml:13(title)
msgid "Reliability"
msgstr "Надёжность"

#: wal.xml:15(para)
msgid ""
"Reliability is an important property of any serious database system, and "
"<productname>PostgreSQL</productname> does everything possible to guarantee "
"reliable operation. One aspect of reliable operation is that all data "
"recorded by a committed transaction should be stored in a nonvolatile area "
"that is safe from power loss, operating system failure, and hardware failure "
"(except failure of the nonvolatile area itself, of course). Successfully "
"writing the data to the computer's permanent storage (disk drive or "
"equivalent) ordinarily meets this requirement. In fact, even if a computer "
"is fatally damaged, if the disk drives survive they can be moved to another "
"computer with similar hardware and all committed transactions will remain "
"intact."
msgstr ""
"Надёжность — это важное свойство любой серьёзной СУБД и "
"<productname>PostgreSQL</productname> делает всё возможное, чтобы "
"гарантировать надёжность своего функционирования. Один из аспектов "
"надёжности состоит в том, что все данные записываются с помощью "
"подтверждённых транзакций, которые сохраняются в энергонезависимой области, "
"которая защищена от потери питания, сбоев операционной системы и аппаратных "
"отказов (разумеется, за исключением отказа самой энергонезависимой области). "
"Успешная запись данных в постоянное место хранения (диск или эквивалентный "
"носитель) обычно всё, что требуется. Фактически, даже если компьютер "
"полностью вышел из строя, если диски выжили, то они могут быть переставлены "
"в другой похожий компьютер и все подтверждённые транзакции останутся "
"неповреждёнными."

#: wal.xml:30(para)
msgid ""
"While forcing data to the disk platters periodically might seem like a "
"simple operation, it is not. Because disk drives are dramatically slower "
"than main memory and CPUs, several layers of caching exist between the "
"computer's main memory and the disk platters. First, there is the operating "
"system's buffer cache, which caches frequently requested disk blocks and "
"combines disk writes. Fortunately, all operating systems give applications a "
"way to force writes from the buffer cache to disk, and "
"<productname>PostgreSQL</productname> uses those features. (See the <xref "
"linkend=\"guc-wal-sync-method\"/> parameter to adjust how this is done.)"
msgstr ""
"Хотя периодическая запись данных на пластины диска может выглядеть как "
"простая операция, это не так, потому что диски значительно медленнее, чем "
"оперативная память и процессор, а также потому что между оперативной памятью "
"и пластинами диска есть некоторые механизмы кеширования. Во-первых, есть "
"буферный кеш операционной системы, который кеширует частые запросы к блокам "
"диска и комбинирует запись на диск. К счастью, все операционные системы "
"предоставляют приложениям способ принудительной записи из буферного кеша на "
"диск и <productname>PostgreSQL</productname> использует эту возможность. "
"(Смотрите параметр <xref linkend=\"guc-wal-sync-method\"/> который отвечает "
"за то как это делается.)"

#: wal.xml:43(para)
msgid ""
"Next, there might be a cache in the disk drive controller; this is "
"particularly common on <acronym>RAID</acronym> controller cards. Some of "
"these caches are <firstterm>write-through</firstterm>, meaning writes are "
"sent to the drive as soon as they arrive. Others are <firstterm>write-back</"
"firstterm>, meaning data is sent to the drive at some later time. Such "
"caches can be a reliability hazard because the memory in the disk controller "
"cache is volatile, and will lose its contents in a power failure. Better "
"controller cards have <firstterm>battery-backup units</firstterm> "
"(<acronym>BBU</acronym>s), meaning the card has a battery that maintains "
"power to the cache in case of system power loss. After power is restored the "
"data will be written to the disk drives."
msgstr ""
"Далее, кеширование также может осуществляться контроллером диска; в "
"особенности это касается <acronym>RAID</acronym>-контроллеров. В некоторых "
"случаях это кеширование работает в режиме <firstterm>сквозной записи</"
"firstterm>, что означает, что запись осуществляется на диск как только "
"приходят данные. В других случаях, возможна работа в режиме "
"<firstterm>отложенной записи</firstterm>, что означает, что запись "
"осуществляется некоторое время спустя. Такой режим кеширования может "
"создавать риск для надёжности, потому что память контроллера диска "
"непостоянна и будет потеряна в случае потери питания. Лучшие контроллеры "
"имеют так называемую <firstterm>батарею резервного питания</firstterm> "
"(Battery-Backup Unit, <acronym>BBU</acronym>), которая сохраняет кеш "
"контроллера на батарее, если пропадёт системное питание. После возобновления "
"питания, данные, оставшиеся в кеше контроллера, будут записаны на диски."

#: wal.xml:58(para)
msgid ""
"And finally, most disk drives have caches. Some are write-through while some "
"are write-back, and the same concerns about data loss exist for write-back "
"drive caches as for disk controller caches. Consumer-grade IDE and SATA "
"drives are particularly likely to have write-back caches that will not "
"survive a power failure. Many solid-state drives (SSD) also have volatile "
"write-back caches."
msgstr ""
"И наконец, многие диски имеют кеширование. На каких-то дисках оно работает в "
"режиме сквозной записи, на других в режиме отложенной записи, что приводит к "
"тем же проблемам потери данных для кеша отложенной записи, что и с кешем в "
"контроллерах дисков. Диски IDE и SATA, потребительского класса особенно, "
"часто имеют кеш отложенной записи, который сбрасывается при потере питания. "
"Многие SSD-накопители также имеют зависимый от питания кеш отложенной записи."

#: wal.xml:67(para)
msgid ""
"These caches can typically be disabled; however, the method for doing this "
"varies by operating system and drive type:"
msgstr ""
"Обычно, такое кеширование можно выключить; однако, то, как это делается, "
"различается для операционной системы и для типа диска:"

#: wal.xml:74(para)
msgid ""
"On <productname>Linux</productname>, IDE and SATA drives can be queried "
"using <command>hdparm -I</command>; write caching is enabled if there is a "
"<literal>*</literal> next to <literal>Write cache</literal>. <command>hdparm "
"-W 0</command> can be used to turn off write caching. SCSI drives can be "
"queried using <ulink url=\"http://sg.danny.cz/sg/sdparm.html"
"\"><application>sdparm</application></ulink>. Use <command>sdparm --get=WCE</"
"command> to check whether the write cache is enabled and <command>sdparm --"
"clear=WCE</command> to disable it."
msgstr ""
"В <productname>Linux</productname> параметры дисков IDE и SATA могут быть "
"получены с помощью команды <command>hdparm -I</command>; кеширование записи "
"включено, если за строкой <literal>Write cache</literal> следует <literal>*</"
"literal>. Для выключения кеширования записи может быть использована команда "
"<command>hdparm -W 0</command>. Параметры SCSI-дисков могут быть получены с "
"помощью утилиты <ulink url=\"http://sg.danny.cz/sg/sdparm.html"
"\"><application>sdparm</application></ulink>. Используйте <command>sdparm --"
"get=WCE</command>, чтобы проверить, включено ли кеширование записи, и "
"<command>sdparm --clear=WCE</command>, чтобы выключить его."

#: wal.xml:87(para)
msgid ""
"On <productname>FreeBSD</productname>, IDE drives can be queried using "
"<command>atacontrol</command> and write caching turned off using <literal>hw."
"ata.wc=0</literal> in <filename>/boot/loader.conf</filename>; SCSI drives "
"can be queried using <command>camcontrol identify</command>, and the write "
"cache both queried and changed using <command>sdparm</command> when "
"available."
msgstr ""
"Во <productname>FreeBSD</productname> параметры IDE-дисков могут быть "
"получены с помощью команды <command>atacontrol</command>, а кеширование "
"записи выключается при помощи установки параметра <literal>hw.ata.wc=0</"
"literal> в файле <filename>/boot/loader.conf</filename>; Для SCSI-дисков "
"параметры могут быть получены, используя команду <command>camcontrol "
"identify</command>, а кеширование записи изменяется при помощи утилиты "
"<command>sdparm</command>."

#: wal.xml:98(para)
msgid ""
"On <productname>Solaris</productname>, the disk write cache is controlled by "
"<command>format -e</command>. (The Solaris <acronym>ZFS</acronym> file "
"system is safe with disk write-cache enabled because it issues its own disk "
"cache flush commands.)"
msgstr ""
"В <productname>Solaris</productname> кешированием записи на диск управляет "
"команда <command>format -e</command>. (Использование файловой системы "
"Solaris <acronym>ZFS</acronym>, при включённом кешировании записи на диск, "
"является безопасным, потому что она использует собственные команды сброса "
"кеша на диск.)"

#: wal.xml:107(para)
msgid ""
"On <productname>Windows</productname>, if <varname>wal_sync_method</varname> "
"is <literal>open_datasync</literal> (the default), write caching can be "
"disabled by unchecking <literal>My Computer\\Open\\<replaceable>disk drive</"
"replaceable>\\Properties\\Hardware\\Properties\\Policies\\Enable write "
"caching on the disk</literal>. Alternatively, set <varname>wal_sync_method</"
"varname> to <literal>fsync</literal> or <literal>fsync_writethrough</"
"literal>, which prevent write caching."
msgstr ""
"В <productname>Windows</productname>, если параметр "
"<varname>wal_sync_method</varname> установлен в <literal>open_datasync</"
"literal> (по умолчанию), кеширование записи на диск может быть выключено "
"снятием галочки <literal>My Computer\\Open\\<replaceable>disk drive</"
"replaceable>\\Properties\\Hardware\\Properties\\Policies\\Enable write "
"caching on the disk</literal>. В качестве альтернативы, можно установить "
"параметр <varname>wal_sync_method</varname> в значение <literal>fsync</"
"literal> или <literal>fsync_writethrough</literal>, что предотвращает "
"кеширование записи."

#: wal.xml:118(para)
msgid ""
"On <productname>OS X</productname>, write caching can be prevented by "
"setting <varname>wal_sync_method</varname> to <literal>fsync_writethrough</"
"literal>."
msgstr ""
"В <productname>OS X</productname> кеширование записи можно отключить, "
"установив для параметра <varname>wal_sync_method</varname> значение "
"<literal>fsync_writethrough</literal>."

#: wal.xml:125(para)
msgid ""
"Recent SATA drives (those following <acronym>ATAPI-6</acronym> or later) "
"offer a drive cache flush command (<command>FLUSH CACHE EXT</command>), "
"while SCSI drives have long supported a similar command <command>SYNCHRONIZE "
"CACHE</command>. These commands are not directly accessible to "
"<productname>PostgreSQL</productname>, but some file systems (e.g., "
"<acronym>ZFS</acronym>, <acronym>ext4</acronym>) can use them to flush data "
"to the platters on write-back-enabled drives. Unfortunately, such file "
"systems behave suboptimally when combined with battery-backup unit "
"(<acronym>BBU</acronym>) disk controllers. In such setups, the synchronize "
"command forces all data from the controller cache to the disks, eliminating "
"much of the benefit of the BBU. You can run the <xref linkend=\"pgtestfsync"
"\"/> program to see if you are affected. If you are affected, the "
"performance benefits of the BBU can be regained by turning off write "
"barriers in the file system or reconfiguring the disk controller, if that is "
"an option. If write barriers are turned off, make sure the battery remains "
"functional; a faulty battery can potentially lead to data loss. Hopefully "
"file system and disk controller designers will eventually address this "
"suboptimal behavior."
msgstr ""
"Новые модели SATA-дисков (которые соответствуют стандарту <acronym>ATAPI-6</"
"acronym> или более позднему) предлагают команду сброса кеша на диск "
"(<command>FLUSH CACHE EXT</command>), а SCSI-диски уже давно поддерживают "
"похожую команду <command>SYNCHRONIZE CACHE</command>. Эти команды недоступны "
"из <productname>PostgreSQL</productname> напрямую, но некоторые файловые "
"системы (например, <acronym>ZFS</acronym>, <acronym>ext4</acronym>), могут "
"использовать их для сброса данных из кеша на пластины диска при включённом "
"режиме кеша сквозной записи. К сожалению, такие файловые системы ведут себя "
"неоптимально при комбинировании с батареей резервного питания (<acronym>BBU</"
"acronym>) дискового контроллера. В таких случаях, команда синхронизации "
"принуждает сохранять все данные на диск из кеша контроллера, сводя "
"преимущество BBU к нулю. Вы можете запустить модуль <xref linkend="
"\"pgtestfsync\"/>, чтобы увидеть, что вы попали в эту ситуацию. Если это "
"так, преимущества производительности BBU могут быть восстановлены с помощью "
"выключения барьеров записи для файловой системы или переконфигурирования "
"контроллера диска, если это возможно. Если барьеры записи выключены, "
"убедитесь, что батарея годная; при отказе батареи может произойти потеря "
"данных. Есть надежда, что разработчики файловых систем и контроллеров "
"дисков, в конце концов, устранят это неоптимальное поведение."

#: wal.xml:147(para)
msgid ""
"When the operating system sends a write request to the storage hardware, "
"there is little it can do to make sure the data has arrived at a truly non-"
"volatile storage area. Rather, it is the administrator's responsibility to "
"make certain that all storage components ensure integrity for both data and "
"file-system metadata. Avoid disk controllers that have non-battery-backed "
"write caches. At the drive level, disable write-back caching if the drive "
"cannot guarantee the data will be written before shutdown. If you use SSDs, "
"be aware that many of these do not honor cache flush commands by default. "
"You can test for reliable I/O subsystem behavior using <ulink url=\"http://"
"brad.livejournal.com/2116715.html\"><filename>diskchecker.pl</filename></"
"ulink>."
msgstr ""
"Когда операционная система отправляет запрос на запись к аппаратному "
"обеспечению для хранения данных, она мало что может сделать, чтобы "
"убедиться, что данные действительно сохранены в какой-либо энергонезависимой "
"области. Скорее, это является зоной ответственности администратора, "
"убедиться в целостности данных на всех компонентах хранения. Избегайте "
"дисковых контроллеров, которые не имеют батарей резервного питания для "
"кеширования записи. На уровне диска, запретите режим отложенной записи, если "
"диск не может гарантировать, что данные будут записаны перед выключением. "
"Если вы используете SSD, знайте, что многие их них по умолчанию не выполняют "
"команды сброса кеша на диск. Вы можете протестировать надёжность поведения "
"подсистемы ввода/вывода, используя <ulink url=\"http://brad.livejournal."
"com/2116715.html\"><filename>diskchecker.pl</filename></ulink>."

#: wal.xml:162(para)
msgid ""
"Another risk of data loss is posed by the disk platter write operations "
"themselves. Disk platters are divided into sectors, commonly 512 bytes each. "
"Every physical read or write operation processes a whole sector. When a "
"write request arrives at the drive, it might be for some multiple of 512 "
"bytes (<productname>PostgreSQL</productname> typically writes 8192 bytes, or "
"16 sectors, at a time), and the process of writing could fail due to power "
"loss at any time, meaning some of the 512-byte sectors were written while "
"others were not. To guard against such failures, <productname>PostgreSQL</"
"productname> periodically writes full page images to permanent WAL storage "
"<emphasis>before</emphasis> modifying the actual page on disk. By doing "
"this, during crash recovery <productname>PostgreSQL</productname> can "
"restore partially-written pages from WAL. If you have file-system software "
"that prevents partial page writes (e.g., ZFS), you can turn off this page "
"imaging by turning off the <xref linkend=\"guc-full-page-writes\"/> "
"parameter. Battery-Backed Unit (BBU) disk controllers do not prevent partial "
"page writes unless they guarantee that data is written to the BBU as full "
"(8kB) pages."
msgstr ""
"Другой риск потери данных состоит в самой записи на пластины диска. Пластины "
"диска разделяются на секторы, обычно по 512 байт каждый. Каждая операция "
"физического чтения или записи обрабатывает целый сектор. Когда дисковый "
"накопитель получает запрос на запись, он может соответствовать нескольким "
"секторам по 512 байт (<productname>PostgreSQL</productname> обычно за один "
"раз записывает 8192 байта или 16 секторов) и из-за отказа питания процесс "
"записи может закончится неудачей в любое время, что означает, что некоторые "
"из 512-байтовых секторов будут записаны, а некоторые нет. Чтобы защититься "
"от таких сбоев, <emphasis>перед</emphasis> изменением фактической страницы "
"на диске, <productname>PostgreSQL</productname> периодически записывает "
"полные образы страниц на постоянное устройство хранения WAL. С помощью "
"этого, во время восстановления после краха, <productname>PostgreSQL</"
"productname> может восстановить из WAL страницы, которые записаны частично. "
"Если у вас файловая система, которая защищена от частичной записи страниц "
"(например, ZFS), вы можете выключить работу с образами страниц, выключив "
"параметр <xref linkend=\"guc-full-page-writes\"/>. Батарея резервного "
"питания (BBU) контроллера диска не защищает от частичной записи страниц, "
"если не гарантируется, что данные записаны в BBU как полные (8kB) страницы."

#: wal.xml:188(para)
msgid ""
"Each individual record in a WAL file is protected by a CRC-32 (32-bit) check "
"that allows us to tell if record contents are correct. The CRC value is set "
"when we write each WAL record and checked during crash recovery, archive "
"recovery and replication."
msgstr ""
"Каждая индивидуальная запись в WAL защищена с помощью контрольной суммы по "
"алгоритму CRC-32 (32-bit), что позволяет судить о корректности данных в "
"записи. Значение CRC устанавливается, когда мы пишем каждую запись WAL и "
"проверяется в ходе восстановления после сбоя, восстановления из архива, и "
"при репликации."

#: wal.xml:196(para)
msgid ""
"Data pages are not currently checksummed by default, though full page images "
"recorded in WAL records will be protected; see <link linkend=\"app-initdb-"
"data-checksums\"><application>initdb</application></link> for details about "
"enabling data page checksums."
msgstr ""
"Страницы данных в настоящее время не защищаются контрольными суммами по "
"умолчанию, хотя полные образы страниц, записанные в WAL будут защищены; "
"смотрите <link linkend=\"app-initdb-data-checksums\"><application>initdb</"
"application></link> для деталей о включении в страницы данных информации о "
"контрольных суммах."

#: wal.xml:204(para)
msgid ""
"Internal data structures such as <filename>pg_clog</filename>, "
"<filename>pg_subtrans</filename>, <filename>pg_multixact</filename>, "
"<filename>pg_serial</filename>, <filename>pg_notify</filename>, "
"<filename>pg_stat</filename>, <filename>pg_snapshots</filename> are not "
"directly checksummed, nor are pages protected by full page writes. However, "
"where such data structures are persistent, WAL records are written that "
"allow recent changes to be accurately rebuilt at crash recovery and those "
"WAL records are protected as discussed above."
msgstr ""
"Для внутренних структур данных, таких как <filename>pg_clog</filename>, "
"<filename>pg_subtrans</filename>, <filename>pg_multixact</filename>, "
"<filename>pg_serial</filename>, <filename>pg_notify</filename>, "
"<filename>pg_stat</filename>, <filename>pg_snapshots</filename> не ведётся "
"расчёт контрольной суммы, равно как и для страниц, защищённых посредством "
"полностраничной записи. Однако там, где такие структуры данных являются "
"постоянными, записи WAL пишутся таким образом, чтобы после сбоя было "
"возможно аккуратно повторить последние изменения, а эти записи WAL "
"защищаются так же, как описано выше."

#: wal.xml:214(para)
msgid ""
"Individual state files in <filename>pg_twophase</filename> are protected by "
"CRC-32."
msgstr ""
"Файлы каталога <filename>pg_twophase</filename> защищены с помощью "
"контрольной суммы CRC-32."

#: wal.xml:219(para)
msgid ""
"Temporary data files used in larger SQL queries for sorts, materializations "
"and intermediate results are not currently checksummed, nor will WAL records "
"be written for changes to those files."
msgstr ""
"Временные файлы данных, используемые в больших SQL-запросах для сортировки, "
"материализации и промежуточных результатов, в настоящее время не защищаются "
"контрольной суммой, а изменения в этих файлах не отражаются в WAL."

#: wal.xml:182(para)
msgid ""
"<productname>PostgreSQL</productname> also protects against some kinds of "
"data corruption on storage devices that may occur because of hardware errors "
"or media failure over time, such as reading/writing garbage data. "
"<placeholder-1/>"
msgstr ""
"<productname>PostgreSQL</productname> также защищает от некоторых видов "
"повреждения данных на устройствах хранения, которые могут произойти из-за "
"аппаратных ошибок или из-за дефектов поверхности с течением времени, "
"например, при операциях чтения/записи во время сборки мусора. <placeholder-1/"
">"

#: wal.xml:227(para)
msgid ""
"<productname>PostgreSQL</productname> does not protect against correctable "
"memory errors and it is assumed you will operate using RAM that uses "
"industry standard Error Correcting Codes (ECC) or better protection."
msgstr ""
"<productname>PostgreSQL</productname> не защищает от корректируемых ошибок "
"памяти; предполагается, что вы будете работать с памятью, которая использует "
"промышленный стандарт коррекции ошибок (ECC, Error Correcting Codes) или "
"лучшую защиту."

#: wal.xml:235(title)
msgid "Write-Ahead Logging (<acronym>WAL</acronym>)"
msgstr "Журнал упреждающей записи (<acronym>WAL</acronym>)"

#: wal.xml:237(indexterm)
msgid "<primary>WAL</primary>"
msgstr "<primary>WAL</primary>"

#: wal.xml:241(indexterm)
msgid "<primary>transaction log</primary> <see>WAL</see>"
msgstr "<primary>журнал транзакций</primary> <see>WAL</see>"

#: wal.xml:246(para)
msgid ""
"<firstterm>Write-Ahead Logging</firstterm> (<acronym>WAL</acronym>) is a "
"standard method for ensuring data integrity. A detailed description can be "
"found in most (if not all) books about transaction processing. Briefly, "
"<acronym>WAL</acronym>'s central concept is that changes to data files "
"(where tables and indexes reside) must be written only after those changes "
"have been logged, that is, after log records describing the changes have "
"been flushed to permanent storage. If we follow this procedure, we do not "
"need to flush data pages to disk on every transaction commit, because we "
"know that in the event of a crash we will be able to recover the database "
"using the log: any changes that have not been applied to the data pages can "
"be redone from the log records. (This is roll-forward recovery, also known "
"as REDO.)"
msgstr ""
"<firstterm>Журнал упреждающей записи</firstterm> (<acronym>WAL</acronym>) — "
"это стандартный метод обеспечения целостности данных. Детальное описание "
"можно найти в большинстве книг (если не во всех) по обработке транзакций. "
"Вкратце, основная идея <acronym>WAL</acronym> состоит в том, что изменения в "
"файлах с данными (где находятся таблицы и индексы) должны записываться "
"только после того, как эти изменения были занесены в журнал, т. е. после "
"того как записи журнала, описывающие данные изменения, будут сохранены на "
"постоянное устройство хранения. Если следовать этой процедуре, то записывать "
"страницы данных на диск после подтверждения каждой транзакции нет "
"необходимости, потому что мы знаем, что если случится сбой, то у нас будет "
"возможность восстановить базу данных с помощью журнала: любые изменения, "
"которые не были применены к страницам с данными, могут быть воссозданы из "
"записей журнала. (Это называется восстановлением с воспроизведением, или "
"REDO.)"

#: wal.xml:263(para)
msgid ""
"Because <acronym>WAL</acronym> restores database file contents after a "
"crash, journaled file systems are not necessary for reliable storage of the "
"data files or WAL files. In fact, journaling overhead can reduce "
"performance, especially if journaling causes file system <emphasis>data</"
"emphasis> to be flushed to disk. Fortunately, data flushing during "
"journaling can often be disabled with a file system mount option, e.g. "
"<literal>data=writeback</literal> on a Linux ext3 file system. Journaled "
"file systems do improve boot speed after a crash."
msgstr ""
"Поскольку <acronym>WAL</acronym> восстанавливает содержимое файлов базы "
"данных, журналируемая файловая система не является необходимой для надёжного "
"хранения файлов с данными или файлов WAL. Фактически, журналирование может "
"снизить производительность, особенно если журналирование заставляет "
"сохранять <emphasis>данные</emphasis> файловой системы на диск. К счастью, "
"такое сохранение при журналировании часто можно отключить с помощью "
"параметров монтирования файловой системы, например, <literal>data=writeback</"
"literal> для файловой системы ext3 в Linux. С другой стороны, с "
"журналируемыми файловыми системами увеличивается скорость загрузки после "
"сбоя."

#: wal.xml:277(para)
msgid ""
"Using <acronym>WAL</acronym> results in a significantly reduced number of "
"disk writes, because only the log file needs to be flushed to disk to "
"guarantee that a transaction is committed, rather than every data file "
"changed by the transaction. The log file is written sequentially, and so the "
"cost of syncing the log is much less than the cost of flushing the data "
"pages. This is especially true for servers handling many small transactions "
"touching different parts of the data store. Furthermore, when the server is "
"processing many small concurrent transactions, one <function>fsync</"
"function> of the log file may suffice to commit many transactions."
msgstr ""
"Результатом использования <acronym>WAL</acronym> является значительное "
"уменьшение количества запросов записи на диск, потому что для гарантии, что "
"транзакция подтверждена, в записи на диск нуждается только файл журнала, а "
"не каждый файл данных изменённый в результате транзакции. Файл журнала "
"записывается последовательно и таким образом, затраты на синхронизацию "
"журнала намного меньше, чем затраты на запись страниц с данными. Это "
"особенно справедливо для серверов, которые обрабатывают много маленьких "
"транзакций, изменяющих разные части хранилища данных. Таким образом, когда "
"сервер обрабатывает множество мелких конкурентных транзакций, для "
"подтверждения многих транзакций достаточно одного вызова <function>fsync</"
"function> на файл журнала."

#: wal.xml:291(para)
msgid ""
"<acronym>WAL</acronym> also makes it possible to support on-line backup and "
"point-in-time recovery, as described in <xref linkend=\"continuous-archiving"
"\"/>. By archiving the WAL data we can support reverting to any time instant "
"covered by the available WAL data: we simply install a prior physical backup "
"of the database, and replay the WAL log just as far as the desired time. "
"What's more, the physical backup doesn't have to be an instantaneous "
"snapshot of the database state &mdash; if it is made over some period of "
"time, then replaying the WAL log for that period will fix any internal "
"inconsistencies."
msgstr ""
"<acronym>WAL</acronym> также делает возможным поддержку онлайнового "
"резервного копирования и восстановления на определённый момент времени, как "
"описывается в <xref remap=\"6\" linkend=\"continuous-archiving\"/>. С "
"помощью архивирования данных WAL поддерживается возврат к любому моменту "
"времени, который доступен в данных WAL: мы просто устанавливаем предыдущую "
"физическую резервную копию базы данных и воспроизводим журнал WAL до нужного "
"момента времени. Более того, физическая резервная копия не должна быть "
"мгновенным снимком состояния баз данных &mdash; если она была сделана "
"некоторое время назад, воспроизведение журнала WAL за этот период исправит "
"все внутренние несоответствия."

#: wal.xml:306(title)
msgid "Asynchronous Commit"
msgstr "Асинхронное подтверждение транзакций"

#: wal.xml:308(indexterm)
msgid "<primary>synchronous commit</primary>"
msgstr "<primary>синхронная фиксация данных</primary>"

#: wal.xml:312(indexterm)
msgid "<primary>asynchronous commit</primary>"
msgstr "<primary>асинхронная фиксация данных</primary>"

#: wal.xml:316(para)
msgid ""
"<firstterm>Asynchronous commit</firstterm> is an option that allows "
"transactions to complete more quickly, at the cost that the most recent "
"transactions may be lost if the database should crash. In many applications "
"this is an acceptable trade-off."
msgstr ""
"<firstterm>Асинхронная фиксация</firstterm> &mdash; это возможность "
"завершать транзакции быстрее, ценой того, что в случае краха СУБД последние "
"транзакции могут быть потеряны. Для многих приложений такой компромисс "
"приемлем."

#: wal.xml:323(para)
msgid ""
"As described in the previous section, transaction commit is normally "
"<firstterm>synchronous</firstterm>: the server waits for the transaction's "
"<acronym>WAL</acronym> records to be flushed to permanent storage before "
"returning a success indication to the client. The client is therefore "
"guaranteed that a transaction reported to be committed will be preserved, "
"even in the event of a server crash immediately after. However, for short "
"transactions this delay is a major component of the total transaction time. "
"Selecting asynchronous commit mode means that the server returns success as "
"soon as the transaction is logically completed, before the <acronym>WAL</"
"acronym> records it generated have actually made their way to disk. This can "
"provide a significant boost in throughput for small transactions."
msgstr ""
"Как описано в предыдущей части, подтверждение транзакции обычно "
"<firstterm>синхронное</firstterm>: сервер ждёт сохранения записей "
"<acronym>WAL</acronym> транзакции в постоянном хранилище, прежде чем "
"сообщить клиенту об успешном завершении. Таким образом, клиенту "
"гарантируется, что транзакция, которую подтвердил сервер, будет защищена, "
"даже если сразу после этого произойдёт крах сервера. Однако, для коротких "
"транзакций данная задержка будет основной составляющей общего времени "
"транзакции. В режиме асинхронного подтверждения сервер сообщает об успешном "
"завершении сразу, как только транзакция будет завершена логически, прежде "
"чем сгенерированные записи <acronym>WAL</acronym> фактически будут записаны "
"на диск. Это может значительно увеличить производительность при выполнении "
"небольших транзакций."

#: wal.xml:338(para)
msgid ""
"Asynchronous commit introduces the risk of data loss. There is a short time "
"window between the report of transaction completion to the client and the "
"time that the transaction is truly committed (that is, it is guaranteed not "
"to be lost if the server crashes). Thus asynchronous commit should not be "
"used if the client will take external actions relying on the assumption that "
"the transaction will be remembered. As an example, a bank would certainly "
"not use asynchronous commit for a transaction recording an ATM's dispensing "
"of cash. But in many scenarios, such as event logging, there is no need for "
"a strong guarantee of this kind."
msgstr ""
"Асинхронное подтверждение транзакций приводит к риску потери данных. "
"Существует короткое окно между отчётом о завершении транзакции для клиента и "
"временем, когда транзакция реально подтверждена (т. е. гарантируется, что "
"она не будет потеряна в случае краха сервера). Таким образом, асинхронное "
"подтверждение транзакций не должно использоваться, если клиент будет "
"выполнять внешние действия, опираясь на предположение, что транзакция будет "
"сохранена. Например, банк конечно не должен использовать асинхронное "
"подтверждение для транзакций в банкоматах, выдающих наличные. Но во многих "
"случаях, таких как журналирование событий, столь серьёзная гарантия "
"сохранности данных не нужна."

#: wal.xml:351(para)
msgid ""
"The risk that is taken by using asynchronous commit is of data loss, not "
"data corruption. If the database should crash, it will recover by replaying "
"<acronym>WAL</acronym> up to the last record that was flushed. The database "
"will therefore be restored to a self-consistent state, but any transactions "
"that were not yet flushed to disk will not be reflected in that state. The "
"net effect is therefore loss of the last few transactions. Because the "
"transactions are replayed in commit order, no inconsistency can be "
"introduced &mdash; for example, if transaction B made changes relying on the "
"effects of a previous transaction A, it is not possible for A's effects to "
"be lost while B's effects are preserved."
msgstr ""
"Риск потери данных при использовании асинхронного подтверждения транзакций "
"&mdash; это не риск повреждения данных. Если случился крах СУБД, она будет "
"восстановлена путём воспроизведения <acronym>WAL</acronym> до последней "
"записи, которая была записана на диск. Таким образом, будет восстановлено "
"целостное состояние СУБД, но любые транзакции, которые ещё не были сохранены "
"на диск, в этом состоянии не будут отражены. Чистый эффект будет заключаться "
"в потере нескольких последних транзакций. Поскольку транзакции "
"воспроизводятся в том же порядке, в котором подтверждались, воспроизведение "
"не нарушает целостность &mdash; например, если транзакция \"B\" выполнила "
"изменения, которые влияют на предыдущую транзакцию \"A\", то не может быть "
"такого, что изменения, выполненные \"A\" были потеряны, а изменения, "
"внесённые \"B\" сохранены."

#: wal.xml:365(para)
msgid ""
"The user can select the commit mode of each transaction, so that it is "
"possible to have both synchronous and asynchronous commit transactions "
"running concurrently. This allows flexible trade-offs between performance "
"and certainty of transaction durability. The commit mode is controlled by "
"the user-settable parameter <xref linkend=\"guc-synchronous-commit\"/>, "
"which can be changed in any of the ways that a configuration parameter can "
"be set. The mode used for any one transaction depends on the value of "
"<varname>synchronous_commit</varname> when transaction commit begins."
msgstr ""
"Пользователь может выбрать режим подтверждения для каждой транзакции, так "
"что возможен конкурентный запуск транзакций в синхронном и асинхронном "
"режиме. Это позволяет достичь гибкого компромисса между производительностью "
"и конечно надёжностью транзакций. Режим подтверждения транзакций управляется "
"параметром <xref linkend=\"guc-synchronous-commit\"/>, который может быть "
"изменён любым из способов, пригодным для установки параметров конфигурации. "
"Режим, используемый для какой-либо конкретной транзакции, зависит от "
"значения <varname>synchronous_commit</varname>, которое действует на момент "
"начала этой транзакции."

#: wal.xml:377(para)
msgid ""
"Certain utility commands, for instance <command>DROP TABLE</command>, are "
"forced to commit synchronously regardless of the setting of "
"<varname>synchronous_commit</varname>. This is to ensure consistency between "
"the server's file system and the logical state of the database. The commands "
"supporting two-phase commit, such as <command>PREPARE TRANSACTION</command>, "
"are also always synchronous."
msgstr ""
"Некоторые команды, например <command>DROP TABLE</command>, принудительно "
"запускают синхронное подтверждение транзакции, независимо от значения "
"<varname>synchronous_commit</varname>. Это сделано для того, чтобы иметь "
"уверенность в целостности данных между файловой системой сервера и "
"логическим состоянием базы данных. Команды, которые поддерживают двухфазное "
"подтверждение транзакций, такие как <command>PREPARE TRANSACTION</command>, "
"также всегда синхронные."

#: wal.xml:386(para)
msgid ""
"If the database crashes during the risk window between an asynchronous "
"commit and the writing of the transaction's <acronym>WAL</acronym> records, "
"then changes made during that transaction <emphasis>will</emphasis> be lost. "
"The duration of the risk window is limited because a background process (the "
"<quote>WAL writer</quote>) flushes unwritten <acronym>WAL</acronym> records "
"to disk every <xref linkend=\"guc-wal-writer-delay\"/> milliseconds. The "
"actual maximum duration of the risk window is three times "
"<varname>wal_writer_delay</varname> because the WAL writer is designed to "
"favor writing whole pages at a time during busy periods."
msgstr ""
"Если во время окна риска между асинхронным подтверждением транзакции и "
"сохранением на диск записей <acronym>WAL</acronym>, происходит крах СУБД, то "
"изменения, сделанные во время этой транзакции <emphasis>будут</emphasis> "
"потеряны. Продолжительность окна риска ограничена, потому что фоновый "
"процесс (<quote>WAL writer</quote>), сохраняет не записанные записи "
"<acronym>WAL</acronym> на диск каждые <xref linkend=\"guc-wal-writer-delay\"/"
"> миллисекунд. Фактически, максимальная продолжительность окна риска "
"составляет трёхкратное значение <varname>wal_writer_delay</varname>, потому "
"что WAL writer разработан так, чтобы сразу сохранять целые страницы во время "
"периодов занятости."

#: wal.xml:401(para)
msgid ""
"An immediate-mode shutdown is equivalent to a server crash, and will "
"therefore cause loss of any unflushed asynchronous commits."
msgstr ""
"Режим немедленного завершения работы (immediate) эквивалентен краху сервера "
"и приведёт, таким образом, к потере всех не сохранённых асинхронных "
"транзакций."

#: wal.xml:407(para)
msgid ""
"Asynchronous commit provides behavior different from setting <xref linkend="
"\"guc-fsync\"/> = off. <varname>fsync</varname> is a server-wide setting "
"that will alter the behavior of all transactions. It disables all logic "
"within <productname>PostgreSQL</productname> that attempts to synchronize "
"writes to different portions of the database, and therefore a system crash "
"(that is, a hardware or operating system crash, not a failure of "
"<productname>PostgreSQL</productname> itself) could result in arbitrarily "
"bad corruption of the database state. In many scenarios, asynchronous commit "
"provides most of the performance improvement that could be obtained by "
"turning off <varname>fsync</varname>, but without the risk of data "
"corruption."
msgstr ""
"Асинхронное подтверждение транзакций предоставляет поведение, которое "
"отличается от того, что соответствует установке параметра <xref linkend="
"\"guc-fsync\"/> = off. Настройка <varname>fsync</varname> касается всего "
"сервера и может изменить поведение всех транзакций. Она выключает всю логику "
"внутри <productname>PostgreSQL</productname>, которая пытается "
"синхронизировать запись отдельных порций в базу данных и, таким образом, "
"крах системы (обусловленный отказом аппаратного обеспечения или операционной "
"системы, который не является сбоем самой СУБД <productname>PostgreSQL</"
"productname> ) может в результате привести к повреждению состояния базы "
"данных. Во многих случаях, асинхронное подтверждение транзакций "
"предоставляет лучшую производительность, чем то, что можно получить "
"выключением <varname>fsync</varname>, но без риска повреждения данных."

#: wal.xml:422(para)
msgid ""
"<xref linkend=\"guc-commit-delay\"/> also sounds very similar to "
"asynchronous commit, but it is actually a synchronous commit method (in "
"fact, <varname>commit_delay</varname> is ignored during an asynchronous "
"commit). <varname>commit_delay</varname> causes a delay just before a "
"transaction flushes <acronym>WAL</acronym> to disk, in the hope that a "
"single flush executed by one such transaction can also serve other "
"transactions committing at about the same time. The setting can be thought "
"of as a way of increasing the time window in which transactions can join a "
"group about to participate in a single flush, to amortize the cost of the "
"flush among multiple transactions."
msgstr ""
"<xref linkend=\"guc-commit-delay\"/> также выглядит очень похоже на "
"асинхронное подтверждение транзакций, но по сути это является методом "
"асинхронного подтверждения транзакций (фактически, во время асинхронных "
"транзакций <varname>commit_delay</varname> игнорируется). "
"<varname>commit_delay</varname> приводит к задержке только перед тем, как "
"синхронная транзакция пытается записать данные <acronym>WAL</acronym> на "
"диск, в надежде, что одиночная запись, выполняемая на одну такую транзакцию, "
"сможет также обслужить другие транзакции, которые подтверждаются "
"приблизительно в это же время. Установку этого параметра можно рассматривать "
"как способ увеличения промежутка времени, в течение которого транзакции "
"группируются для единовременной записи на диск. Это распределяет стоимость "
"записи между несколькими транзакциями."

#: wal.xml:438(title)
msgid "<acronym>WAL</acronym> Configuration"
msgstr "Настройка <acronym>WAL</acronym>"

#: wal.xml:440(para)
msgid ""
"There are several <acronym>WAL</acronym>-related configuration parameters "
"that affect database performance. This section explains their use. Consult "
"<xref linkend=\"runtime-config\"/> for general information about setting "
"server configuration parameters."
msgstr ""
"Существует несколько конфигурационных параметров относящихся к <acronym>WAL</"
"acronym>, которые влияют на производительность СУБД. Далее рассказывается об "
"их использовании. Общую информацию об установке параметров конфигурации "
"сервера смотрите в <xref remap=\"6\" linkend=\"runtime-config\"/>."

#: wal.xml:448(indexterm)
msgid "<primary>checkpoint</primary>"
msgstr "<primary>контрольная точка</primary>"

#: wal.xml:447(para)
msgid ""
"<firstterm>Checkpoints</firstterm><placeholder-1/> are points in the "
"sequence of transactions at which it is guaranteed that the heap and index "
"data files have been updated with all information written before that "
"checkpoint. At checkpoint time, all dirty data pages are flushed to disk and "
"a special checkpoint record is written to the log file. (The change records "
"were previously flushed to the <acronym>WAL</acronym> files.) In the event "
"of a crash, the crash recovery procedure looks at the latest checkpoint "
"record to determine the point in the log (known as the redo record) from "
"which it should start the REDO operation. Any changes made to data files "
"before that point are guaranteed to be already on disk. Hence, after a "
"checkpoint, log segments preceding the one containing the redo record are no "
"longer needed and can be recycled or removed. (When <acronym>WAL</acronym> "
"archiving is being done, the log segments must be archived before being "
"recycled or removed.)"
msgstr ""
"<firstterm>Контрольные точки</firstterm><placeholder-1/> &mdash; это точки в "
"последовательности транзакций, в которых гарантируется, что файлы с данными "
"и индексами были обновлены всей информацией записанной перед контрольной "
"точкой. Во время контрольной точки, все страницы данных, находящиеся в "
"памяти, сохраняются на диск, а в файл журнала записывается специальная "
"запись контрольной точки. (Сделанные изменения были перед этим записаны в "
"файлы <acronym>WAL</acronym>.) В случае краха процедура восстановления ищет "
"последнюю запись контрольной точки, чтобы определить эту точку в журнале "
"(называемую записью REDO), от которой процедура должна начать операцию "
"воспроизведения изменений. Любые изменения файлов данных перед этой точкой "
"гарантированно находятся уже на диске. Таким образом, после контрольной "
"точки, сегменты журнала, которые предшествуют записи воспроизведения, больше "
"не нужны и могут быть удалены или пущены в циклическую перезапись. (Когда "
"архивирование WAL будет завершено, сегменты журнала должны быть архивированы "
"перед их удалением или циклической перезаписи.)"

#: wal.xml:465(para)
msgid ""
"The checkpoint requirement of flushing all dirty data pages to disk can "
"cause a significant I/O load. For this reason, checkpoint activity is "
"throttled so that I/O begins at checkpoint start and completes before the "
"next checkpoint is due to start; this minimizes performance degradation "
"during checkpoints."
msgstr ""
"Запись всех страниц данных из памяти на диск, которая требуется для "
"контрольной точки, может вызвать значительную нагрузку на дисковый ввод/"
"вывод. По этой причине, активность записи по контрольной точке регулируется "
"так, что ввод/вывод начинается при старте контрольной точки и завершается "
"перед стартом следующей контрольной точки; это минимизирует потерю "
"производительности во время прохождения контрольных точек."

#: wal.xml:473(para)
msgid ""
"The server's checkpointer process automatically performs a checkpoint every "
"so often. A checkpoint is begun every <xref linkend=\"guc-checkpoint-timeout"
"\"/> seconds, or if <xref linkend=\"guc-max-wal-size\"/> is about to be "
"exceeded, whichever comes first. The default settings are 5 minutes and 1 "
"GB, respectively. If no WAL has been written since the previous checkpoint, "
"new checkpoints will be skipped even if <varname>checkpoint_timeout</"
"varname> has passed. (If WAL archiving is being used and you want to put a "
"lower limit on how often files are archived in order to bound potential data "
"loss, you should adjust the <xref linkend=\"guc-archive-timeout\"/> "
"parameter rather than the checkpoint parameters.) It is also possible to "
"force a checkpoint by using the SQL command <command>CHECKPOINT</command>."
msgstr ""
"Отдельный серверный процесс контрольных точек автоматически выполняет "
"контрольные точки с заданной частотой. Контрольные точки производятся каждые "
"<xref linkend=\"guc-checkpoint-timeout\"/> секунд либо при приближении к "
"пределу <xref linkend=\"guc-max-wal-size\"/>, если это имеет место раньше. "
"Значения по умолчанию: 5 минут и 1 Гбайт, соответственно. Если после "
"предыдущей контрольной точки новые записи WAL не добавились, следующие "
"контрольные точки будут пропущены, даже если проходит время "
"<varname>checkpoint_timeout</varname>. (Если вы применяете архивацию WAL и "
"хотите установить нижний предел для частоты архивации, чтобы ограничить "
"потенциальную потерю данных, вам следует настраивать параметр <xref linkend="
"\"guc-archive-timeout\"/>, а не параметры контрольных точек.) Также можно "
"выполнить контрольную точку принудительно, воспользовавшись SQL-командой "
"<command>CHECKPOINT</command>."

#: wal.xml:490(para)
msgid ""
"Reducing <varname>checkpoint_timeout</varname> and/or <varname>max_wal_size</"
"varname> causes checkpoints to occur more often. This allows faster after-"
"crash recovery, since less work will need to be redone. However, one must "
"balance this against the increased cost of flushing dirty data pages more "
"often. If <xref linkend=\"guc-full-page-writes\"/> is set (as is the "
"default), there is another factor to consider. To ensure data page "
"consistency, the first modification of a data page after each checkpoint "
"results in logging the entire page content. In that case, a smaller "
"checkpoint interval increases the volume of output to the WAL log, partially "
"negating the goal of using a smaller interval, and in any case causing more "
"disk I/O."
msgstr ""
"Уменьшение значений <varname>checkpoint_timeout</varname> и/или "
"<varname>max_wal_size</varname> приводит к учащению контрольных точек. Это "
"позволяет ускорить восстановление после краха (поскольку для воспроизведения "
"нужно меньше данных), но с другой стороны нужно учитывать дополнительную "
"нагрузку, возникающую вследствие более частого сброса изменённых страниц "
"данных на диск. Если включён режим <xref linkend=\"guc-full-page-writes\"/> "
"(по умолчанию это так), нужно учесть и ещё один фактор. Для обеспечения "
"целостности страницы данных, при первом изменении страницы данных после "
"контрольной точки эта страница записывается в журнал целиком. В данном "
"случае, чем меньше интервал между контрольными точками, тем больше объём "
"записи в журнал WAL, так что это частично дискредитирует идею уменьшения "
"интервала записи, и в любом случае приводит к увеличению объёма обмена с "
"диском"

#: wal.xml:505(para)
msgid ""
"Checkpoints are fairly expensive, first because they require writing out all "
"currently dirty buffers, and second because they result in extra subsequent "
"WAL traffic as discussed above. It is therefore wise to set the "
"checkpointing parameters high enough so that checkpoints don't happen too "
"often. As a simple sanity check on your checkpointing parameters, you can "
"set the <xref linkend=\"guc-checkpoint-warning\"/> parameter. If checkpoints "
"happen closer together than <varname>checkpoint_warning</varname> seconds, a "
"message will be output to the server log recommending increasing "
"<varname>max_wal_size</varname>. Occasional appearance of such a message is "
"not cause for alarm, but if it appears often then the checkpoint control "
"parameters should be increased. Bulk operations such as large <command>COPY</"
"command> transfers might cause a number of such warnings to appear if you "
"have not set <varname>max_wal_size</varname> high enough."
msgstr ""
"Контрольные точки довольно дороги с точки зрения ресурсов, во-первых, потому "
"что они требуют записи всех буферов из памяти на диск, и во-вторых потому "
"что они создают дополнительный трафик WAL, о чём говорилось выше. Таким "
"образом, будет благоразумным установить параметры контрольных точек так, "
"чтобы контрольные точки не выполнялись слишком часто. Для простой проверки "
"параметров контрольной точки можно установить параметр <xref linkend=\"guc-"
"checkpoint-warning\"/>. Если промежуток времени между контрольными точками "
"будет меньше чем количество секунд, заданное параметром "
"<varname>checkpoint_warning</varname>, то в журнал сервера будет выдано "
"сообщение с рекомендацией увеличить <varname>max_wal_size</varname>. "
"Эпизодическое появление такого сообщения не является поводом для "
"беспокойства. Но если оно появляется часто, необходимо увеличить значения "
"параметров управления контрольными точками. Массовые операции, такие как "
"<command>COPY</command> с большим объёмом данных, могут привести к появлению "
"нескольких таких предупреждений, если вы не установили "
"<varname>max_wal_size</varname> достаточно большим."

#: wal.xml:523(para)
msgid ""
"To avoid flooding the I/O system with a burst of page writes, writing dirty "
"buffers during a checkpoint is spread over a period of time. That period is "
"controlled by <xref linkend=\"guc-checkpoint-completion-target\"/>, which is "
"given as a fraction of the checkpoint interval. The I/O rate is adjusted so "
"that the checkpoint finishes when the given fraction of "
"<varname>checkpoint_timeout</varname> seconds have elapsed, or before "
"<varname>max_wal_size</varname> is exceeded, whichever is sooner. With the "
"default value of 0.5, <productname>PostgreSQL</productname> can be expected "
"to complete each checkpoint in about half the time before the next "
"checkpoint starts. On a system that's very close to maximum I/O throughput "
"during normal operation, you might want to increase "
"<varname>checkpoint_completion_target</varname> to reduce the I/O load from "
"checkpoints. The disadvantage of this is that prolonging checkpoints affects "
"recovery time, because more WAL segments will need to be kept around for "
"possible use in recovery. Although <varname>checkpoint_completion_target</"
"varname> can be set as high as 1.0, it is best to keep it less than that "
"(perhaps 0.9 at most) since checkpoints include some other activities "
"besides writing dirty buffers. A setting of 1.0 is quite likely to result in "
"checkpoints not being completed on time, which would result in performance "
"loss due to unexpected variation in the number of WAL segments needed."
msgstr ""
"Чтобы избежать &laquo;заваливания&raquo; системы ввода/вывода при резкой "
"интенсивной записи страниц, запись &laquo;грязных&raquo; буферов во время "
"контрольной точки растягивается на определённый период времени. Этот период "
"управляется параметром <xref linkend=\"guc-checkpoint-completion-target\"/>, "
"который задаётся как часть интервала контрольной точки. Скорость ввода/"
"вывода подстраивается так, чтобы контрольная точка завершилась к моменту "
"истечения заданной части от <varname>checkpoint_timeout</varname> секунд или "
"до превышения <varname>max_wal_size</varname>, если оно имеет место раньше. "
"Со значением 0.5, заданным по умолчанию, можно ожидать, что "
"<productname>PostgreSQL</productname> завершит процедуру контрольной точки "
"примерно за половину времени до начала следующей. В системе, которая "
"работает практически на пределе мощности ввода/вывода в обычном режиме, есть "
"смысл увеличить <varname>checkpoint_completion_target</varname>, чтобы "
"уменьшить нагрузку ввода/вывода, связанную с контрольными точками. Но с "
"другой стороны, растягивание контрольных точек влияет на время "
"восстановления, так как для восстановления нужно будет задействовать большее "
"количество сегментов WAL. Хотя в <varname>checkpoint_completion_target</"
"varname> можно задать значение вплоть до 1.0, лучше выбрать значение меньше "
"(по крайней мере, не больше 0.9), так как при контрольных точках выполняются "
"и некоторые другие операции, помимо записи &laquo;грязных&raquo; буферов. Со "
"значением 1.0 контрольные точки, скорее всего, не будут завершаться вовремя, "
"что приведёт к потере производительности из-за неожиданных колебаний "
"требуемого количества сегментов WAL."

#: wal.xml:549(para)
msgid ""
"On Linux and POSIX platforms <xref linkend=\"guc-checkpoint-flush-after\"/> "
"allows to force the OS that pages written by the checkpoint should be "
"flushed to disk after a configurable number of bytes. Otherwise, these pages "
"may be kept in the OS's page cache, inducing a stall when <literal>fsync</"
"literal> is issued at the end of a checkpoint. This setting will often help "
"to reduce transaction latency, but it also can an adverse effect on "
"performance; particularly for workloads that are bigger than <xref linkend="
"\"guc-shared-buffers\"/>, but smaller than the OS's page cache."
msgstr ""
"На платформах Linux и POSIX параметр <xref linkend=\"guc-checkpoint-flush-"
"after\"/> позволяет принудить ОС к сбросу страниц, записываемых во время "
"контрольной точки, при накоплении заданного количества байт. Если его не "
"настроить, эти страницы могут оставаться в кеше страниц ОС, что повлечёт "
"затормаживание при выполнении <literal>fsync</literal> в конце контрольной "
"точки. Этот параметр часто помогает уменьшить задержки транзакций, но может "
"оказать и негативное влияние на производительность; особенно, когда объём "
"нагрузки больше <xref linkend=\"guc-shared-buffers\"/>, но меньше кеша "
"страниц в ОС."

#: wal.xml:560(para)
msgid ""
"The number of WAL segment files in <filename>pg_xlog</filename> directory "
"depends on <varname>min_wal_size</varname>, <varname>max_wal_size</varname> "
"and the amount of WAL generated in previous checkpoint cycles. When old log "
"segment files are no longer needed, they are removed or recycled (that is, "
"renamed to become future segments in the numbered sequence). If, due to a "
"short-term peak of log output rate, <varname>max_wal_size</varname> is "
"exceeded, the unneeded segment files will be removed until the system gets "
"back under this limit. Below that limit, the system recycles enough WAL "
"files to cover the estimated need until the next checkpoint, and removes the "
"rest. The estimate is based on a moving average of the number of WAL files "
"used in previous checkpoint cycles. The moving average is increased "
"immediately if the actual usage exceeds the estimate, so it accommodates "
"peak usage rather than average usage to some extent. <varname>min_wal_size</"
"varname> puts a minimum on the amount of WAL files recycled for future "
"usage; that much WAL is always recycled for future use, even if the system "
"is idle and the WAL usage estimate suggests that little WAL is needed."
msgstr ""
"Число файлов сегментов WAL в каталоге <filename>pg_xlog</filename> зависит "
"от <varname>min_wal_size</varname>, <varname>max_wal_size</varname> и объёма "
"WAL, сгенерированного в предыдущих циклах контрольных точек. Когда старые "
"файлы сегментов оказываются не нужны, они удаляются или перерабатываются (то "
"есть переименовываются, чтобы стать будущими сегментами в нумерованной "
"последовательности). Если вследствие кратковременного скачка интенсивности "
"записи в журнал, предел <varname>max_wal_size</varname> превышается, "
"ненужные файлы сегментов будут удаляться, пока система не опустится ниже "
"этого предела. Оставаясь ниже этого предела, система перерабатывает столько "
"файлов WAL, сколько необходимо для покрытия ожидаемой потребности до "
"следующей контрольной точки, и удаляет остальные. Эта оценка базируется на "
"скользящем среднем числа файлов WAL, задействованных в предыдущих циклах "
"контрольных точек. Скользящее среднее увеличивается немедленно, если "
"фактическое использование превышает оценку, так что в нём в некоторой "
"степени накапливается пиковое использование, а не среднее. Значение "
"<varname>min_wal_size</varname> ограничивает снизу число файлов WAL, которые "
"будут переработаны для будущего использования; такой объём WAL всегда будет "
"перерабатываться, даже если система простаивает и оценка использования "
"говорит, что нужен совсем небольшой WAL."

#: wal.xml:580(para)
msgid ""
"Independently of <varname>max_wal_size</varname>, <xref linkend=\"guc-wal-"
"keep-segments\"/> + 1 most recent WAL files are kept at all times. Also, if "
"WAL archiving is used, old segments can not be removed or recycled until "
"they are archived. If WAL archiving cannot keep up with the pace that WAL is "
"generated, or if <varname>archive_command</varname> fails repeatedly, old "
"WAL files will accumulate in <filename>pg_xlog</filename> until the "
"situation is resolved. A slow or failed standby server that uses a "
"replication slot will have the same effect (see <xref linkend=\"streaming-"
"replication-slots\"/>)."
msgstr ""
"Вне зависимости от <varname>max_wal_size</varname>, в количестве <xref "
"linkend=\"guc-wal-keep-segments\"/> + 1 самые последние файлы WAL "
"сохраняются в любом случае. Так же, если применяется архивация WAL, старые "
"сегменты не могут быть удалены или переработаны, пока они не будут "
"заархивированы. Если WAL архивируется медленнее, чем генерируется, либо если "
"команда <varname>archive_command</varname> постоянно даёт сбои, старые файлы "
"WAL будут накапливаться в <filename>pg_xlog</filename>, пока ситуация не "
"будет разрешена. Медленно работающий или отказавший резервный сервер, "
"использующий слот репликации, даст тот же эффект (см. <xref remap=\"4\" "
"linkend=\"streaming-replication-slots\"/>)."

#: wal.xml:594(indexterm)
msgid "<primary>restartpoint</primary>"
msgstr "<primary>точка перезапуска</primary>"

#: wal.xml:592(para)
msgid ""
"In archive recovery or standby mode, the server periodically performs "
"<firstterm>restartpoints</firstterm>,<placeholder-1/> which are similar to "
"checkpoints in normal operation: the server forces all its state to disk, "
"updates the <filename>pg_control</filename> file to indicate that the "
"already-processed WAL data need not be scanned again, and then recycles any "
"old log segment files in the <filename>pg_xlog</filename> directory. "
"Restartpoints can't be performed more frequently than checkpoints in the "
"master because restartpoints can only be performed at checkpoint records. A "
"restartpoint is triggered when a checkpoint record is reached if at least "
"<varname>checkpoint_timeout</varname> seconds have passed since the last "
"restartpoint, or if WAL size is about to exceed <varname>max_wal_size</"
"varname>. However, because of limitations on when a restartpoint can be "
"performed, <varname>max_wal_size</varname> is often exceeded during "
"recovery, by up to one checkpoint cycle's worth of WAL. "
"(<varname>max_wal_size</varname> is never a hard limit anyway, so you should "
"always leave plenty of headroom to avoid running out of disk space.)"
msgstr ""
"В режиме восстановления архива или горячего резерва сервер периодически "
"выполняет <firstterm>точки перезапуска</firstterm><placeholder-1/>, которые "
"похожи на контрольные точки в обычном режиме работы: сервер принудительно "
"сбрасывает своё состояние на диск, обновляет файл <filename>pg_control</"
"filename>, чтобы показать, что уже обработанные данные WAL не нужно "
"сканировать снова, и затем перерабатывает все старые файлы сегментов журнала "
"в каталоге <filename>pg_xlog</filename>. Точки перезапуска не могут "
"выполняться чаще, чем контрольные точки на главном сервере, так как они "
"могут происходить только в записях контрольных точек. Точка перезапуска "
"производится, когда достигается запись контрольной точки и после предыдущей "
"точки перезапуска прошло не меньше <varname>checkpoint_timeout</varname> "
"секунд или размер WAL может превысить <varname>max_wal_size</varname>. "
"Однако из-за того, что на время выполнения точек перезапуска накладываются "
"ограничения, <varname>max_wal_size</varname> часто превышается при "
"восстановлении, вплоть до объёма WAL, записываемого в цикле между "
"контрольными точками. (Значение <varname>max_wal_size</varname> никогда и не "
"было жёстким пределом, так что всегда следует оставлять приличный запас "
"сверху, чтобы не остаться без свободного места на диске.)"

#: wal.xml:612(para)
msgid ""
"There are two commonly used internal <acronym>WAL</acronym> functions: "
"<function>XLogInsertRecord</function> and <function>XLogFlush</function>. "
"<function>XLogInsertRecord</function> is used to place a new record into the "
"<acronym>WAL</acronym> buffers in shared memory. If there is no space for "
"the new record, <function>XLogInsertRecord</function> will have to write "
"(move to kernel cache) a few filled <acronym>WAL</acronym> buffers. This is "
"undesirable because <function>XLogInsertRecord</function> is used on every "
"database low level modification (for example, row insertion) at a time when "
"an exclusive lock is held on affected data pages, so the operation needs to "
"be as fast as possible. What is worse, writing <acronym>WAL</acronym> "
"buffers might also force the creation of a new log segment, which takes even "
"more time. Normally, <acronym>WAL</acronym> buffers should be written and "
"flushed by an <function>XLogFlush</function> request, which is made, for the "
"most part, at transaction commit time to ensure that transaction records are "
"flushed to permanent storage. On systems with high log output, "
"<function>XLogFlush</function> requests might not occur often enough to "
"prevent <function>XLogInsertRecord</function> from having to do writes. On "
"such systems one should increase the number of <acronym>WAL</acronym> "
"buffers by modifying the <xref linkend=\"guc-wal-buffers\"/> parameter. When "
"<xref linkend=\"guc-full-page-writes\"/> is set and the system is very busy, "
"setting <varname>wal_buffers</varname> higher will help smooth response "
"times during the period immediately following each checkpoint."
msgstr ""
"Наиболее часто используются две связанные с <acronym>WAL</acronym> "
"внутренние функции: <function>XLogInsertRecord</function> и "
"<function>XLogFlush</function>. <function>XLogInsertRecord</function> "
"применяется для добавления записи в буферы <acronym>WAL</acronym> в "
"разделяемой памяти. Если места для новой записи недостаточно, "
"<function>XLogInsertRecord</function> придётся записать (переместить в кеш "
"ядра) несколько заполненных буферов <acronym>WAL</acronym>. Это "
"нежелательно, так как <function>XLogInsertRecord</function> используется при "
"каждом изменении в базе данных на низком уровне (например, при добавлении "
"строки) в момент, когда установлена исключительная блокировка "
"задействованных страниц данных, поэтому данная операция должна быть "
"максимально быстрой. Что ещё хуже, запись буферов <acronym>WAL</acronym> "
"может также повлечь создание нового сегмента журнала, что займёт ещё больше "
"времени. Обычно буферы <acronym>WAL</acronym> должны записываться и "
"сохраняться на диске в функции <function>XLogFlush</function>, которая "
"вызывается, по большей части, при фиксировании транзакции, чтобы результаты "
"транзакции сохранились в надёжном хранилище. В системах с интенсивной "
"записью в журнал вызовы <function>XLogFlush</function> могут иметь место не "
"так часто, чтобы <function>XLogInsertRecord</function> не приходилось "
"производить запись. В таких системах следует увеличить число буферов "
"<acronym>WAL</acronym>, изменив параметр <xref linkend=\"guc-wal-buffers\"/"
">. Когда включён режим <xref linkend=\"guc-full-page-writes\"/> и система "
"очень сильно загружена, увеличение <varname>wal_buffers</varname> поможет "
"сгладить скачки во времени ответа в период сразу после каждой контрольной "
"точки."

#: wal.xml:639(para)
msgid ""
"The <xref linkend=\"guc-commit-delay\"/> parameter defines for how many "
"microseconds a group commit leader process will sleep after acquiring a lock "
"within <function>XLogFlush</function>, while group commit followers queue up "
"behind the leader. This delay allows other server processes to add their "
"commit records to the WAL buffers so that all of them will be flushed by the "
"leader's eventual sync operation. No sleep will occur if <xref linkend=\"guc-"
"fsync\"/> is not enabled, or if fewer than <xref linkend=\"guc-commit-"
"siblings\"/> other sessions are currently in active transactions; this "
"avoids sleeping when it's unlikely that any other session will commit soon. "
"Note that on some platforms, the resolution of a sleep request is ten "
"milliseconds, so that any nonzero <varname>commit_delay</varname> setting "
"between 1 and 10000 microseconds would have the same effect. Note also that "
"on some platforms, sleep operations may take slightly longer than requested "
"by the parameter."
msgstr ""
"Параметр <xref linkend=\"guc-commit-delay\"/> определяет, на сколько "
"микросекунд будет засыпать ведущий процесс группы, записывающий в журнал, "
"после получения блокировки в <function>XLogFlush</function>, пока "
"подчинённые формируют очередь на запись. Во время этой задержки другие "
"серверные процессы смогут добавлять записи в WAL буферы журнала, чтобы все "
"эти записи сохранились на диск в результате одной операции синхронизации, "
"которую выполнит ведущий. Ведущий процесс не засыпает, если отключён режим "
"<xref linkend=\"guc-fsync\"/>, либо число сеансов с активными транзакциями "
"меньше <xref linkend=\"guc-commit-siblings\"/>, так как маловероятно, что "
"какой-либо другой сеанс зафиксирует транзакцию в ближайшее время. Заметьте, "
"что на некоторых платформах, разрешение этого таймера сна составляет 10 "
"миллисекунд, так что любое значение параметра <varname>commit_delay</"
"varname> от 1 до 10000 микросекунд будет действовать одинаково. Кроме того, "
"в некоторых системах состояние сна может продлиться несколько дольше, чем "
"требует параметр."

#: wal.xml:657(para)
msgid ""
"Since the purpose of <varname>commit_delay</varname> is to allow the cost of "
"each flush operation to be amortized across concurrently committing "
"transactions (potentially at the expense of transaction latency), it is "
"necessary to quantify that cost before the setting can be chosen "
"intelligently. The higher that cost is, the more effective "
"<varname>commit_delay</varname> is expected to be in increasing transaction "
"throughput, up to a point. The <xref linkend=\"pgtestfsync\"/> program can "
"be used to measure the average time in microseconds that a single WAL flush "
"operation takes. A value of half of the average time the program reports it "
"takes to flush after a single 8kB write operation is often the most "
"effective setting for <varname>commit_delay</varname>, so this value is "
"recommended as the starting point to use when optimizing for a particular "
"workload. While tuning <varname>commit_delay</varname> is particularly "
"useful when the WAL log is stored on high-latency rotating disks, benefits "
"can be significant even on storage media with very fast sync times, such as "
"solid-state drives or RAID arrays with a battery-backed write cache; but "
"this should definitely be tested against a representative workload. Higher "
"values of <varname>commit_siblings</varname> should be used in such cases, "
"whereas smaller <varname>commit_siblings</varname> values are often helpful "
"on higher latency media. Note that it is quite possible that a setting of "
"<varname>commit_delay</varname> that is too high can increase transaction "
"latency by so much that total transaction throughput suffers."
msgstr ""
"Так как цель <varname>commit_delay</varname> состоит в том, чтобы позволить "
"стоимости каждой операции синхронизации амортизироваться через параллельную "
"фиксацию транзакций (потенциально за счёт задержки транзакции), необходимо "
"определить количество той стоимости, прежде чем урегулирование сможет быть "
"выбрано разумно. Чем выше стоимость, тем более эффективный будет "
"<varname>commit_delay</varname> в увеличении пропускной способности "
"транзакций в какой-то степени. Программа <xref linkend=\"pgtestfsync\"/> "
"может использоваться, чтобы измерить среднее время в микросекундах, которое "
"занимает одиночная работа сброса WAL на диск. Значение половины среднего "
"времени сообщаемого программой рекомендуется в качестве отправной точки для "
"использования значения в параметре <varname>commit_delay</varname> при "
"оптимизации для конкретного объёма работы, и говорит о том, сколько нужно "
"времени для синхронизации сброса единственной операции записи 8 КБ. "
"Настройка параметра <varname>commit_delay</varname> особенно полезна в "
"случае хранения WAL в хранилище с высокоскоростными дисками, такими как "
"твердотельные накопители (SSD) или RAID-массивы с кешем записи и аварийным "
"питанием на батарее; но это определённо должно тестироваться на "
"репрезентативной рабочей нагрузке. Более высокие значения "
"<varname>commit_siblings</varname> должны использоваться в таких случаях, "
"тогда как меньшие значения <varname>commit_siblings</varname> часто полезны "
"на носителях с большими задержками. Обратите внимание на то, что увеличение "
"значения параметра <varname>commit_delay</varname> может увеличить задержку "
"транзакции настолько, что пострадает общая производительность транзакций."

#: wal.xml:684(para)
msgid ""
"When <varname>commit_delay</varname> is set to zero (the default), it is "
"still possible for a form of group commit to occur, but each group will "
"consist only of sessions that reach the point where they need to flush their "
"commit records during the window in which the previous flush operation (if "
"any) is occurring. At higher client counts a <quote>gangway effect</quote> "
"tends to occur, so that the effects of group commit become significant even "
"when <varname>commit_delay</varname> is zero, and thus explicitly setting "
"<varname>commit_delay</varname> tends to help less. Setting "
"<varname>commit_delay</varname> can only help when (1) there are some "
"concurrently committing transactions, and (2) throughput is limited to some "
"degree by commit rate; but with high rotational latency this setting can be "
"effective in increasing transaction throughput with as few as two clients "
"(that is, a single committing client with one sibling transaction)."
msgstr ""
"Даже если <varname>commit_delay</varname> равен нулю (значение по "
"умолчанию), групповая фиксация все равно может произойти, но группа будет "
"состоять только из тех сеансов, которым понадобилось сбросить записи о "
"фиксации на диск за то время, пока происходил предыдущий сброс. Чем больше "
"сеансов, тем чаще это происходит даже при нулевом <varname>commit_delay</"
"varname>, поэтому увеличение этого параметра может и не оказать заметного "
"действия. Установка <varname>commit_delay</varname> имеет смысл в двух "
"случаях: (1) когда несколько транзакций одновременно фиксируют изменения, "
"(2) либо когда частота фиксаций ограничена пропускной способностью дисковой "
"подсистемы. Однако при задержке из-за низкой скорости вращения диска, эта "
"настройка может оказаться полезной даже всего при двух сеансах."

#: wal.xml:701(para)
msgid ""
"The <xref linkend=\"guc-wal-sync-method\"/> parameter determines how "
"<productname>PostgreSQL</productname> will ask the kernel to force "
"<acronym>WAL</acronym> updates out to disk. All the options should be the "
"same in terms of reliability, with the exception of "
"<literal>fsync_writethrough</literal>, which can sometimes force a flush of "
"the disk cache even when other options do not do so. However, it's quite "
"platform-specific which one will be the fastest. You can test the speeds of "
"different options using the <xref linkend=\"pgtestfsync\"/> program. Note "
"that this parameter is irrelevant if <varname>fsync</varname> has been "
"turned off."
msgstr ""
"Параметр <xref linkend=\"guc-wal-sync-method\"/> определяет, как "
"<productname>PostgreSQL</productname> будет обращаться к ядру, чтобы "
"принудительно сохранить <acronym>WAL</acronym> на диск. Все методы должны "
"быть одинаковыми в плане надёжности, за исключением "
"<literal>fsync_writethrough</literal>, который может иногда принудительно "
"сбрасывать кеш диска, даже если другие методы не делают этого. Однако, какой "
"из них самый быстрый, во многом определяется платформой; вы можете "
"протестировать скорость, используя модуль <xref linkend=\"pgtestfsync\"/>. "
"Обратите внимание, что данный параметр не имеет значения, если "
"<varname>fsync</varname> выключен."

#: wal.xml:715(para)
msgid ""
"Enabling the <xref linkend=\"guc-wal-debug\"/> configuration parameter "
"(provided that <productname>PostgreSQL</productname> has been compiled with "
"support for it) will result in each <function>XLogInsertRecord</function> "
"and <function>XLogFlush</function> <acronym>WAL</acronym> call being logged "
"to the server log. This option might be replaced by a more general mechanism "
"in the future."
msgstr ""
"Включение параметра конфигурации <xref linkend=\"guc-wal-debug\"/> "
"(предоставляется, если <productname>PostgreSQL</productname> был "
"скомпилирован с его поддержкой) будет приводить к тому, что все вызовы "
"связанных с <acronym>WAL</acronym> функций <function>XLogInsertRecord</"
"function> и <function>XLogFlush</function> будут протоколироваться в журнале "
"сервера. В будущем данный параметр может быть заменён более общим механизмом."

#: wal.xml:726(title)
msgid "WAL Internals"
msgstr "Внутреннее устройство WAL"

#: wal.xml:728(para)
msgid ""
"<acronym>WAL</acronym> is automatically enabled; no action is required from "
"the administrator except ensuring that the disk-space requirements for the "
"<acronym>WAL</acronym> logs are met, and that any necessary tuning is done "
"(see <xref linkend=\"wal-configuration\"/>)."
msgstr ""
"<acronym>WAL</acronym> включается автоматически; от администратора не "
"требуется никаких действий за исключением того, чтобы убедиться, что "
"выполнены требования <acronym>WAL</acronym> к месту на диске, и что "
"выполнены все необходимые действия по тонкой настройке (см. <xref remap="
"\"4\" linkend=\"wal-configuration\"/>)."

#: wal.xml:736(para)
msgid ""
"<acronym>WAL</acronym> logs are stored in the directory <filename>pg_xlog</"
"filename> under the data directory, as a set of segment files, normally each "
"16 MB in size (but the size can be changed by altering the <option>--with-"
"wal-segsize</option> configure option when building the server). Each "
"segment is divided into pages, normally 8 kB each (this size can be changed "
"via the <option>--with-wal-blocksize</option> configure option). The log "
"record headers are described in <filename>access/xlogrecord.h</filename>; "
"the record content is dependent on the type of event that is being logged. "
"Segment files are given ever-increasing numbers as names, starting at "
"<filename>000000010000000000000000</filename>. The numbers do not wrap, but "
"it will take a very, very long time to exhaust the available stock of "
"numbers."
msgstr ""
"Журналы <acronym>WAL</acronym> хранятся в каталоге <filename>pg_xlog</"
"filename>, который находится в каталоге data, в виде списка файлов "
"сегментов, обычно 16MB каждый (этот размер может быть изменён с помощью "
"указания configure <option>--with-wal-segsize</option> во время компиляции "
"сервера). Каждый файл сегмента разделяется на страницы, обычно по 8KB каждая "
"(данный размер может быть изменён с помощью указания configure <option>--"
"with-wal-blocksize</option>). Заголовки записи журнала описываются в "
"<filename>access/xlogrecord.h</filename>; содержимое самой записи зависит от "
"типа события, которое сохраняется в журнале. Файлы сегментов имеют имена-"
"номера, которые начинаются с <filename>000000010000000000000000</filename> и "
"увеличиваются автоматически. Эти номера не перекрываются, но пока доступные "
"номера исчерпаются, пройдёт очень, очень долгое время."

#: wal.xml:752(para)
msgid ""
"It is advantageous if the log is located on a different disk from the main "
"database files. This can be achieved by moving the <filename>pg_xlog</"
"filename> directory to another location (while the server is shut down, of "
"course) and creating a symbolic link from the original location in the main "
"data directory to the new location."
msgstr ""
"Выгодно размещать журналы WAL на другом диске, отличном от того, где "
"находятся основные файлы базы данных. Для этого можно переместить каталог "
"<filename>pg_xlog</filename> в другое место (разумеется, когда сервер "
"остановлен) и создать символьную ссылку из исходного места на перемещённый "
"каталог."

#: wal.xml:763(indexterm)
msgid "<primary>disk drive</primary>"
msgstr "<primary>дисковое устройство</primary>"

#: wal.xml:760(para)
msgid ""
"The aim of <acronym>WAL</acronym> is to ensure that the log is written "
"before database records are altered, but this can be subverted by disk "
"drives<placeholder-1/> that falsely report a successful write to the kernel, "
"when in fact they have only cached the data and not yet stored it on the "
"disk. A power failure in such a situation might lead to irrecoverable data "
"corruption. Administrators should try to ensure that disks holding "
"<productname>PostgreSQL</productname>'s <acronym>WAL</acronym> log files do "
"not make such false reports. (See <xref linkend=\"wal-reliability\"/>.)"
msgstr ""
"Для <acronym>WAL</acronym> важно, чтобы запись в журнал выполнялась до "
"изменений данных в базе. Но этот порядок могут нарушить дисковые "
"устройства<placeholder-1/>, которые ложно сообщают ядру об успешном "
"завершении записи, хотя фактически они только выполнили кеширование данных и "
"пока не сохранили их на диск. Сбой питания в такой ситуации может привести к "
"неисправимому повреждению данных. Администраторы должны убедиться, что "
"диски, где хранятся файлы журналов <acronym>WAL</acronym> "
"<productname>PostgreSQL</productname>, не выдают таких ложных сообщений "
"ядру. (См. <xref remap=\"4\" linkend=\"wal-reliability\"/>.)"

#: wal.xml:773(para)
msgid ""
"After a checkpoint has been made and the log flushed, the checkpoint's "
"position is saved in the file <filename>pg_control</filename>. Therefore, at "
"the start of recovery, the server first reads <filename>pg_control</"
"filename> and then the checkpoint record; then it performs the REDO "
"operation by scanning forward from the log position indicated in the "
"checkpoint record. Because the entire content of data pages is saved in the "
"log on the first page modification after a checkpoint (assuming <xref "
"linkend=\"guc-full-page-writes\"/> is not disabled), all pages changed since "
"the checkpoint will be restored to a consistent state."
msgstr ""
"При наступлении контрольной точки и сохранения журнала, позиция контрольной "
"точки сохраняется в файл <filename>pg_control</filename>. Таким образом, при "
"старте восстановления, сервер сперва читает файл <filename>pg_control</"
"filename> и затем запись контрольной точки; затем он выполняет операцию "
"REDO, сканируя вперёд от точки журнала, обозначенной в записи контрольной "
"точки. Поскольку полное содержимое страниц данных сохраняется в журнале в "
"первой странице после контрольной точки (предполагается, что включён режим "
"<xref linkend=\"guc-full-page-writes\"/>), все страницы, изменённые с "
"момента контрольной точки будут восстановлены в целостное состояние."

#: wal.xml:787(para)
msgid ""
"To deal with the case where <filename>pg_control</filename> is corrupt, we "
"should support the possibility of scanning existing log segments in reverse "
"order &mdash; newest to oldest &mdash; in order to find the latest "
"checkpoint. This has not been implemented yet. <filename>pg_control</"
"filename> is small enough (less than one disk page) that it is not subject "
"to partial-write problems, and as of this writing there have been no reports "
"of database failures due solely to the inability to read "
"<filename>pg_control</filename> itself. So while it is theoretically a weak "
"spot, <filename>pg_control</filename> does not seem to be a problem in "
"practice."
msgstr ""
"В случае, если файл <filename>pg_control</filename> повреждён, мы должны "
"поддерживать возможность сканирования существующих сегментов журнала в "
"обратном порядке &mdash; от новых к старым &mdash; чтобы найти последнюю "
"контрольную точку. Это пока не реализовано. <filename>pg_control</filename> "
"является достаточно маленьким файлом (меньше, чем одна дисковая страница), "
"который не должен попадать под проблему частичной записи и на момент "
"написания данной документации, не было ни одного сообщения о сбоях СУБД "
"исключительно из-за невозможности чтения самого файла <filename>pg_control</"
"filename>. Таким образом, хотя теоретически это является слабым местом, на "
"практике проблем с <filename>pg_control</filename> не обнаружено."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: wal.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
