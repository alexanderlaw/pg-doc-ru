# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:14+0300\n"
"PO-Revision-Date: 2017-09-22 18:09+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:5(title)
msgid "Server Programming Interface"
msgstr "Интерфейс программирования сервера"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:7(indexterm)
msgid "<primary>SPI</primary>"
msgstr "<primary>SPI</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:11(para)
msgid ""
"The <firstterm>Server Programming Interface</firstterm> (<acronym>SPI</"
"acronym>) gives writers of user-defined <acronym>C</acronym> functions the "
"ability to run <acronym>SQL</acronym> commands inside their functions. "
"<acronym>SPI</acronym> is a set of interface functions to simplify access to "
"the parser, planner, and executor. <acronym>SPI</acronym> also does some "
"memory management."
msgstr ""
"<firstterm>Интерфейс программирования сервера</firstterm> (<acronym>SPI</"
"acronym>, Server Programming Interface) даёт разработчикам пользовательских "
"функций на <acronym>C</acronym> возможность запускать команды <acronym>SQL</"
"acronym> из своих функций. <acronym>SPI</acronym> представляет собой набор "
"интерфейсных функций, упрощающих доступ к анализатору, планировщику и "
"исполнителю запросов. В <acronym>SPI</acronym> есть также функции для "
"управления памятью."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:23(para)
msgid ""
"The available procedural languages provide various means to execute SQL "
"commands from procedures. Most of these facilities are based on SPI, so this "
"documentation might be of use for users of those languages as well."
msgstr ""
"Доступные процедурные языки предоставляют различные средства для выполнения "
"SQL-команд из процедур. Большинство этих средств основаны на SPI, так что "
"эта документация будет полезна и тем, кто использует эти языки."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:31(para)
msgid ""
"To avoid misunderstanding we'll use the term <quote>function</quote> when we "
"speak of <acronym>SPI</acronym> interface functions and <quote>procedure</"
"quote> for a user-defined C-function that is using <acronym>SPI</acronym>."
msgstr ""
"Во избежание недопонимания мы будем употреблять слово <quote>функция</"
"quote>, говоря о функциях <acronym>SPI</acronym>, и слово <quote>процедура</"
"quote>, говоря о пользовательских функциях, написанных на C, и использующих "
"<acronym>SPI</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:38(para)
msgid ""
"Note that if a command invoked via SPI fails, then control will not be "
"returned to your procedure. Rather, the transaction or subtransaction in "
"which your procedure executes will be rolled back. (This might seem "
"surprising given that the SPI functions mostly have documented error-return "
"conventions. Those conventions only apply for errors detected within the SPI "
"functions themselves, however.) It is possible to recover control after an "
"error by establishing your own subtransaction surrounding SPI calls that "
"might fail. This is not currently documented because the mechanisms required "
"are still in flux."
msgstr ""
"Учтите, что если команда, вызванная через SPI, прерывается ошибкой, "
"управление не возвращается в вашу процедуру. Вместо этого происходит откат "
"транзакции или подтранзакции, из которой вызывалась ваша процедура. (Это "
"может показаться удивительным, с учётом того, что для большинства функций "
"SPI описаны соглашения по возврату ошибок. Однако эти соглашения применимы "
"только к ошибкам, выявляемым в самих функциях SPI.) Получить управление "
"после ошибки можно, только организовав собственную подтранзакцию, окружающую "
"вызовы SPI, в которых возможна ошибка. В настоящее время этот подход не "
"документирован, так как требуемые для него механизмы окончательно ещё не "
"сформированы."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:50(para)
msgid ""
"<acronym>SPI</acronym> functions return a nonnegative result on success "
"(either via a returned integer value or in the global variable "
"<varname>SPI_result</varname>, as described below). On error, a negative "
"result or <symbol>NULL</symbol> will be returned."
msgstr ""
"Функции <acronym>SPI</acronym> выдают неотрицательный результат в случае "
"успеха (либо через возвращаемое целочисленное значение, либо в глобальной "
"переменной <varname>SPI_result</varname>, как описано ниже). В случае ошибки "
"выдаётся отрицательный результат или <symbol>NULL</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:57(para)
msgid ""
"Source code files that use SPI must include the header file "
"<filename>executor/spi.h</filename>."
msgstr ""
"Файлы исходного кода, использующие SPI, должны включать заголовочный файл "
"<filename>executor/spi.h</filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:64(title)
msgid "Interface Functions"
msgstr "Интерфейсные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:67(indexterm)
msgid "<primary>SPI_connect</primary>"
msgstr "<primary>SPI_connect</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:70(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_connect"
msgstr "SPI_connect"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:71(manvolnum) spi.xml:128(manvolnum) spi.xml:187(manvolnum)
#: spi.xml:543(manvolnum) spi.xml:609(manvolnum) spi.xml:762(manvolnum)
#: spi.xml:924(manvolnum) spi.xml:1026(manvolnum) spi.xml:1114(manvolnum)
#: spi.xml:1171(manvolnum) spi.xml:1241(manvolnum) spi.xml:1310(manvolnum)
#: spi.xml:1446(manvolnum) spi.xml:1541(manvolnum) spi.xml:1645(manvolnum)
#: spi.xml:1769(manvolnum) spi.xml:1922(manvolnum) spi.xml:2018(manvolnum)
#: spi.xml:2074(manvolnum) spi.xml:2159(manvolnum) spi.xml:2234(manvolnum)
#: spi.xml:2333(manvolnum) spi.xml:2434(manvolnum) spi.xml:2486(manvolnum)
#: spi.xml:2555(manvolnum) spi.xml:2655(manvolnum) spi.xml:2762(manvolnum)
#: spi.xml:2872(manvolnum) spi.xml:2995(manvolnum) spi.xml:3062(manvolnum)
#: spi.xml:3136(manvolnum) spi.xml:3220(manvolnum) spi.xml:3315(manvolnum)
#: spi.xml:3381(manvolnum) spi.xml:3447(manvolnum) spi.xml:3500(manvolnum)
#: spi.xml:3616(manvolnum) spi.xml:3675(manvolnum) spi.xml:3745(manvolnum)
#: spi.xml:3798(manvolnum) spi.xml:3861(manvolnum) spi.xml:3941(manvolnum)
#: spi.xml:4105(manvolnum) spi.xml:4157(manvolnum) spi.xml:4224(manvolnum)
msgid "3"
msgstr "3"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:75(refname)
msgctxt "refname"
msgid "SPI_connect"
msgstr "SPI_connect"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:76(refpurpose)
msgid "connect a procedure to the SPI manager"
msgstr "подключить процедуру к менеджеру SPI"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:80(synopsis)
#, no-wrap
msgid "int SPI_connect(void)"
msgstr "int SPI_connect(void)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:86(title) spi.xml:143(title) spi.xml:202(title) spi.xml:558(title)
#: spi.xml:627(title) spi.xml:777(title) spi.xml:940(title) spi.xml:1044(title)
#: spi.xml:1130(title) spi.xml:1187(title) spi.xml:1258(title)
#: spi.xml:1326(title) spi.xml:1464(title) spi.xml:1556(title)
#: spi.xml:1662(title) spi.xml:1788(title) spi.xml:1940(title)
#: spi.xml:2033(title) spi.xml:2089(title) spi.xml:2174(title)
#: spi.xml:2250(title) spi.xml:2349(title) spi.xml:2449(title)
#: spi.xml:2501(title) spi.xml:2570(title) spi.xml:2670(title)
#: spi.xml:2777(title) spi.xml:2887(title) spi.xml:3010(title)
#: spi.xml:3077(title) spi.xml:3151(title) spi.xml:3236(title)
#: spi.xml:3330(title) spi.xml:3396(title) spi.xml:3462(title)
#: spi.xml:3515(title) spi.xml:3631(title) spi.xml:3690(title)
#: spi.xml:3760(title) spi.xml:3813(title) spi.xml:3876(title)
#: spi.xml:3957(title) spi.xml:4120(title) spi.xml:4173(title)
#: spi.xml:4239(title)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:88(para)
msgid ""
"<function>SPI_connect</function> opens a connection from a procedure "
"invocation to the SPI manager. You must call this function if you want to "
"execute commands through SPI. Some utility SPI functions can be called from "
"unconnected procedures."
msgstr ""
"<function>SPI_connect</function> устанавливает подключение вызова процедуры "
"к менеджеру SPI. Эту функцию необходимо вызвать, если вы хотите выполнять "
"команды через SPI. Некоторые вспомогательные функции SPI могут вызываться из "
"неподключённых процедур."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:97(title) spi.xml:156(title) spi.xml:357(title) spi.xml:594(title)
#: spi.xml:741(title) spi.xml:851(title) spi.xml:996(title) spi.xml:1098(title)
#: spi.xml:1154(title) spi.xml:1221(title) spi.xml:1289(title)
#: spi.xml:1402(title) spi.xml:1520(title) spi.xml:1624(title)
#: spi.xml:1753(title) spi.xml:1906(title) spi.xml:2002(title)
#: spi.xml:2058(title) spi.xml:2133(title) spi.xml:2299(title)
#: spi.xml:2399(title) spi.xml:2528(title) spi.xml:2598(title)
#: spi.xml:2695(title) spi.xml:2801(title) spi.xml:2916(title)
#: spi.xml:3044(title) spi.xml:3119(title) spi.xml:3200(title)
#: spi.xml:3293(title) spi.xml:3364(title) spi.xml:3429(title)
#: spi.xml:3487(title) spi.xml:3542(title) spi.xml:3660(title)
#: spi.xml:3729(title) spi.xml:3845(title) spi.xml:3924(title)
#: spi.xml:4051(title) spi.xml:4264(title)
msgid "Return Value"
msgstr "Возвращаемое значение"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:101(symbol)
msgid "SPI_OK_CONNECT"
msgstr "SPI_OK_CONNECT"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:103(para)
msgid "on success"
msgstr "при успехе"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:110(symbol)
msgid "SPI_ERROR_CONNECT"
msgstr "SPI_ERROR_CONNECT"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:112(para)
msgid "on error"
msgstr "при ошибке"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:124(indexterm)
msgid "<primary>SPI_finish</primary>"
msgstr "<primary>SPI_finish</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:127(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_finish"
msgstr "SPI_finish"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:132(refname)
msgctxt "refname"
msgid "SPI_finish"
msgstr "SPI_finish"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:133(refpurpose)
msgid "disconnect a procedure from the SPI manager"
msgstr "отключить процедуру от менеджера SPI"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:137(synopsis)
#, no-wrap
msgid "int SPI_finish(void)"
msgstr "int SPI_finish(void)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:145(para)
msgid ""
"<function>SPI_finish</function> closes an existing connection to the SPI "
"manager. You must call this function after completing the SPI operations "
"needed during your procedure's current invocation. You do not need to worry "
"about making this happen, however, if you abort the transaction via "
"<literal>elog(ERROR)</literal>. In that case SPI will clean itself up "
"automatically."
msgstr ""
"<function>SPI_finish</function> закрывает текущее соединение с менеджером "
"SPI. Эту функцию необходимо вызывать после завершения операций SPI, которые "
"должны выполняться в текущем вызове процедуры. Однако, если вы прерываете "
"транзакцию, выполняя <literal>elog(ERROR)</literal>, о закрытии соединения "
"можно не беспокоиться. В этом случае SPI произведёт очистку автоматически."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:160(symbol)
msgid "SPI_OK_FINISH"
msgstr "SPI_OK_FINISH"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:162(para)
msgid "if properly disconnected"
msgstr "если отключение выполнено корректно"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:169(symbol) spi.xml:510(symbol) spi.xml:2615(symbol)
#: spi.xml:2728(symbol) spi.xml:2833(symbol) spi.xml:2948(symbol)
#: spi.xml:4086(symbol)
msgid "SPI_ERROR_UNCONNECTED"
msgstr "SPI_ERROR_UNCONNECTED"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:171(para) spi.xml:512(para) spi.xml:2617(para) spi.xml:2730(para)
#: spi.xml:2835(para) spi.xml:2950(para)
msgid "if called from an unconnected procedure"
msgstr "если вызывается из неподключённой процедуры"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:183(indexterm)
msgid "<primary>SPI_execute</primary>"
msgstr "<primary>SPI_execute</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:186(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute"
msgstr "SPI_execute"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:191(refname)
msgctxt "refname"
msgid "SPI_execute"
msgstr "SPI_execute"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:192(refpurpose)
msgid "execute a command"
msgstr "выполнить команду"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:197(parameter) spi.xml:329(parameter) spi.xml:553(parameter)
#: spi.xml:573(parameter) spi.xml:619(parameter) spi.xml:662(parameter)
#: spi.xml:772(parameter) spi.xml:821(parameter) spi.xml:934(parameter)
#: spi.xml:957(parameter) spi.xml:1036(parameter) spi.xml:1060(parameter)
#: spi.xml:1780(parameter) spi.xml:1828(parameter)
msgid "command"
msgstr "command"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:197(parameter) spi.xml:338(parameter) spi.xml:622(parameter)
#: spi.xml:722(parameter) spi.xml:1321(parameter) spi.xml:1383(parameter)
#: spi.xml:1458(parameter) spi.xml:1501(parameter) spi.xml:1657(parameter)
#: spi.xml:1744(parameter) spi.xml:1783(parameter) spi.xml:1888(parameter)
#: spi.xml:1935(parameter) spi.xml:1993(parameter)
msgid "read_only"
msgstr "read_only"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:197(parameter) spi.xml:345(parameter) spi.xml:553(parameter)
#: spi.xml:582(parameter) spi.xml:622(parameter) spi.xml:729(parameter)
#: spi.xml:1321(parameter) spi.xml:1390(parameter) spi.xml:1459(parameter)
#: spi.xml:1508(parameter) spi.xml:1551(parameter) spi.xml:1612(parameter)
#: spi.xml:2084(parameter) spi.xml:2122(parameter) spi.xml:2169(parameter)
#: spi.xml:2207(parameter) spi.xml:2245(parameter) spi.xml:2284(parameter)
#: spi.xml:2344(parameter) spi.xml:2384(parameter)
msgid "count"
msgstr "count"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:196(synopsis)
#, no-wrap
msgid "int SPI_execute(const char * <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"
msgstr "int SPI_execute(const char * <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:204(para)
msgid ""
"<function>SPI_execute</function> executes the specified SQL command for "
"<parameter>count</parameter> rows. If <parameter>read_only</parameter> is "
"<literal>true</literal>, the command must be read-only, and execution "
"overhead is somewhat reduced."
msgstr ""
"<function>SPI_execute</function> выполняет заданную команду SQL для "
"получения строк в количестве, ограниченном <parameter>count</parameter>. С "
"параметром <parameter>read_only</parameter>, равным <literal>true</literal>, "
"команда должна только читать данные; это несколько сокращает издержки на её "
"выполнение."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:211(para)
msgid "This function can only be called from a connected procedure."
msgstr "Эту функцию можно вызывать только из подключённой процедуры."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:221(programlisting)
#, no-wrap
msgid "SPI_execute(\"SELECT * FROM foo\", true, 5);"
msgstr "SPI_execute(\"SELECT * FROM foo\", true, 5);"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:226(programlisting)
#, no-wrap
msgid "SPI_execute(\"INSERT INTO foo SELECT * FROM bar\", false, 5);"
msgstr "SPI_execute(\"INSERT INTO foo SELECT * FROM bar\", false, 5);"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:231(programlisting)
#, no-wrap
msgid "SPI_execute(\"INSERT INTO foo SELECT * FROM bar RETURNING *\", false, 5);"
msgstr "SPI_execute(\"INSERT INTO foo SELECT * FROM bar RETURNING *\", false, 5);"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:215(para)
msgid ""
"If <parameter>count</parameter> is zero then the command is executed for all "
"rows that it applies to. If <parameter>count</parameter> is greater than "
"zero, then no more than <parameter>count</parameter> rows will be retrieved; "
"execution stops when the count is reached, much like adding a "
"<literal>LIMIT</literal> clause to the query. For example, <placeholder-1/> "
"will retrieve at most 5 rows from the table. Note that such a limit is only "
"effective when the command actually returns rows. For example, "
"<placeholder-2/> inserts all rows from <structname>bar</structname>, "
"ignoring the <parameter>count</parameter> parameter. However, with "
"<placeholder-3/> at most 5 rows would be inserted, since execution would "
"stop after the fifth <literal>RETURNING</literal> result row is retrieved."
msgstr ""
"Если <parameter>count</parameter> равен 0, команда выполняется для всех "
"строк, к которым она применима. Если <parameter>count</parameter> больше "
"нуля, будет получено не более чем <parameter>count</parameter> строк; "
"выполнение команды остановится при достижении этого предела, практически так "
"же, как и с предложением <literal>LIMIT</literal> в запросе. Например, "
"команда: <placeholder-1/> получит из таблицы не более 5 строк. Заметьте, что "
"это ограничение действует, только когда команда действительно возвращает "
"строки. Например, эта команда: <placeholder-2/> вставляет все строки из "
"<structname>bar</structname>, игнорируя параметр <parameter>count</"
"parameter>. Однако, команда <placeholder-3/> вставит не более 5 строк, так "
"как её выполнение будет остановлено после получения пятой строки, выданной "
"предложением <literal>RETURNING</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:238(para)
msgid ""
"You can pass multiple commands in one string; <function>SPI_execute</"
"function> returns the result for the command executed last. The "
"<parameter>count</parameter> limit applies to each command separately (even "
"though only the last result will actually be returned). The limit is not "
"applied to any hidden commands generated by rules."
msgstr ""
"В одной строке можно передать несколько команд; <function>SPI_execute</"
"function> возвращает результат команды, выполненной последней. Параметр "
"<parameter>count</parameter> при этом будет применяться к каждой команде по "
"отдельности (несмотря даже на то, что возвращён будет только последний "
"результат). Это ограничение не будет распространяться на скрытые команды, "
"генерируемые правилами."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:247(para)
msgid ""
"When <parameter>read_only</parameter> is <literal>false</literal>, "
"<function>SPI_execute</function> increments the command counter and computes "
"a new <firstterm>snapshot</firstterm> before executing each command in the "
"string. The snapshot does not actually change if the current transaction "
"isolation level is <literal>SERIALIZABLE</literal> or <literal>REPEATABLE "
"READ</literal>, but in <literal>READ COMMITTED</literal> mode the snapshot "
"update allows each command to see the results of newly committed "
"transactions from other sessions. This is essential for consistent behavior "
"when the commands are modifying the database."
msgstr ""
"Когда параметр <parameter>read_only</parameter> равен <literal>false</"
"literal>, <function>SPI_execute</function> увеличивает счётчик команд и "
"получает новый <firstterm>снимок</firstterm> перед выполнением каждой "
"очередной команды в строке. Этот снимок фактически не меняется при текущем "
"уровне изоляции транзакций <literal>SERIALIZABLE</literal> или "
"<literal>REPEATABLE READ</literal>, но в режиме <literal>READ COMMITTED</"
"literal> после обновления снимка очередная команда может видеть результаты "
"только что зафиксированных транзакций из других сеансов. Это важно для "
"согласованного поведения, когда команды модифицируют базу данных."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:259(para)
msgid ""
"When <parameter>read_only</parameter> is <literal>true</literal>, "
"<function>SPI_execute</function> does not update either the snapshot or the "
"command counter, and it allows only plain <command>SELECT</command> commands "
"to appear in the command string. The commands are executed using the "
"snapshot previously established for the surrounding query. This execution "
"mode is somewhat faster than the read/write mode due to eliminating per-"
"command overhead. It also allows genuinely <firstterm>stable</firstterm> "
"functions to be built: since successive executions will all use the same "
"snapshot, there will be no change in the results."
msgstr ""
"Когда параметр <parameter>read_only</parameter> равен <literal>true</"
"literal>, <function>SPI_execute</function> не обновляет снимок и не "
"увеличивает счётчик команд, и допускает в строке команд только "
"<command>SELECT</command>. Заданные команды выполняются со снимком, ранее "
"полученным для окружающего запроса. Этот режим выполнения несколько быстрее "
"режима чтения/записи вследствие исключения издержек, связанных с отдельными "
"командами. Он также позволяет создавать подлинно <firstterm>стабильные</"
"firstterm> функции: так как последующие вызовы в транзакции будут "
"использовать один снимок, результаты команд не изменятся."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:271(para)
msgid ""
"It is generally unwise to mix read-only and read-write commands within a "
"single function using SPI; that could result in very confusing behavior, "
"since the read-only queries would not see the results of any database "
"updates done by the read-write queries."
msgstr ""
"Смешивать команды, только читающие, с командами, читающими и пишущими, в "
"одной процедуре, использующей SPI, обычно неразумно; запросы только на "
"чтение не увидят результатов изменений в базе данных, произведённых пишущими "
"запросами."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:278(para)
msgid ""
"The actual number of rows for which the (last) command was executed is "
"returned in the global variable <varname>SPI_processed</varname>. If the "
"return value of the function is <symbol>SPI_OK_SELECT</symbol>, "
"<symbol>SPI_OK_INSERT_RETURNING</symbol>, <symbol>SPI_OK_DELETE_RETURNING</"
"symbol>, or <symbol>SPI_OK_UPDATE_RETURNING</symbol>, then you can use the "
"global pointer <literal>SPITupleTable *SPI_tuptable</literal> to access the "
"result rows. Some utility commands (such as <command>EXPLAIN</command>) also "
"return row sets, and <literal>SPI_tuptable</literal> will contain the result "
"in these cases too. Some utility commands (<command>COPY</command>, "
"<command>CREATE TABLE AS</command>) don't return a row set, so "
"<literal>SPI_tuptable</literal> is NULL, but they still return the number of "
"rows processed in <varname>SPI_processed</varname>."
msgstr ""
"Число строк, которые были фактически обработаны командой (последней), "
"возвращается в глобальной переменной <varname>SPI_processed</varname>. Если "
"эта функция возвращает значение <symbol>SPI_OK_SELECT</symbol>, "
"<symbol>SPI_OK_INSERT_RETURNING</symbol>, <symbol>SPI_OK_DELETE_RETURNING</"
"symbol> или <symbol>SPI_OK_UPDATE_RETURNING</symbol>, вы можете обратиться "
"по глобальному указателю <literal>SPITupleTable *SPI_tuptable</literal> и "
"прочитать строки результата. Некоторые служебные команды (например, "
"<command>EXPLAIN</command>) также возвращают наборы строк, и "
"<literal>SPI_tuptable</literal> будет содержать их результаты и в этих "
"случаях. Другие вспомогательные команды (<command>COPY</command>, "
"<command>CREATE TABLE AS</command>) не возвращают набор строк, так что "
"указатель <literal>SPI_tuptable</literal> равен NULL, но они так же "
"возвращают число обработанных строк в <varname>SPI_processed</varname>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:298(programlisting)
#, no-wrap
msgid ""
"typedef struct\n"
"{\n"
"    MemoryContext tuptabcxt;    /* memory context of result table */\n"
"    uint64      alloced;        /* number of alloced vals */\n"
"    uint64      free;           /* number of free vals */\n"
"    TupleDesc   tupdesc;        /* row descriptor */\n"
"    HeapTuple  *vals;           /* rows */\n"
"} SPITupleTable;"
msgstr ""
"typedef struct\n"
"{\n"
"    MemoryContext tuptabcxt;    /* контекст таблицы результатов в памяти */\n"
"    uint64      alloced;        /* число занятых значений */\n"
"    uint64      free;           /* число свободных значений */\n"
"    TupleDesc   tupdesc;        /* дескриптор строки */\n"
"    HeapTuple  *vals;           /* данные строк */\n"
"} SPITupleTable;"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:295(para)
msgid ""
"The structure <structname>SPITupleTable</structname> is defined thus: "
"<placeholder-1/> <structfield>vals</structfield> is an array of pointers to "
"rows. (The number of valid entries is given by <varname>SPI_processed</"
"varname>.) <structfield>tupdesc</structfield> is a row descriptor which you "
"can pass to SPI functions dealing with rows. <structfield>tuptabcxt</"
"structfield>, <structfield>alloced</structfield>, and <structfield>free</"
"structfield> are internal fields not intended for use by SPI callers."
msgstr ""
"Структура <structname>SPITupleTable</structname> определена так: "
"<placeholder-1/> <structfield>vals</structfield> представляет собой массив "
"указателей на строки. (Число записей в нём указывается в "
"<varname>SPI_processed</varname>.) Поле <structfield>tupdesc</structfield> "
"содержит дескриптор строки, который вы сможете передать функциям SPI, "
"работающими со строками. Поля <structfield>tuptabcxt</structfield>, "
"<structfield>alloced</structfield> и <structfield>free</structfield> "
"предназначены для внутреннего использования, а не для процедур, работающих с "
"SPI."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:316(para)
msgid ""
"<function>SPI_finish</function> frees all <structname>SPITupleTable</"
"structname>s allocated during the current procedure. You can free a "
"particular result table earlier, if you are done with it, by calling "
"<function>SPI_freetuptable</function>."
msgstr ""
"<function>SPI_finish</function> освобождает все структуры "
"<structname>SPITupleTable</structname>, размещённые в памяти для текущей "
"процедуры. Вы можете освободить структуру конкретной результирующей таблицы, "
"если она вам не нужна, вызвав <function>SPI_freetuptable</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:325(title) spi.xml:569(title) spi.xml:658(title) spi.xml:817(title)
#: spi.xml:953(title) spi.xml:1056(title) spi.xml:1139(title)
#: spi.xml:1197(title) spi.xml:1274(title) spi.xml:1338(title)
#: spi.xml:1479(title) spi.xml:1567(title) spi.xml:1689(title)
#: spi.xml:1814(title) spi.xml:1961(title) spi.xml:2043(title)
#: spi.xml:2100(title) spi.xml:2185(title) spi.xml:2259(title)
#: spi.xml:2359(title) spi.xml:2464(title) spi.xml:2513(title)
#: spi.xml:2583(title) spi.xml:2680(title) spi.xml:2786(title)
#: spi.xml:2900(title) spi.xml:3020(title) spi.xml:3095(title)
#: spi.xml:3167(title) spi.xml:3251(title) spi.xml:3340(title)
#: spi.xml:3405(title) spi.xml:3472(title) spi.xml:3527(title)
#: spi.xml:3645(title) spi.xml:3705(title) spi.xml:3776(title)
#: spi.xml:3830(title) spi.xml:3899(title) spi.xml:3974(title)
#: spi.xml:4135(title) spi.xml:4202(title) spi.xml:4249(title)
msgid "Arguments"
msgstr "Аргументы"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:329(literal) spi.xml:573(literal) spi.xml:662(literal)
#: spi.xml:700(literal) spi.xml:821(literal) spi.xml:957(literal)
#: spi.xml:1060(literal) spi.xml:1361(literal) spi.xml:1590(literal)
#: spi.xml:1693(literal) spi.xml:1722(literal) spi.xml:1818(literal)
#: spi.xml:1828(literal) spi.xml:1866(literal) spi.xml:1965(literal)
#: spi.xml:2047(literal) spi.xml:2790(literal) spi.xml:3108(literal)
#: spi.xml:4027(literal)
msgid "const char * <placeholder-1/>"
msgstr "const char * <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:331(para) spi.xml:575(para)
msgid "string containing command to execute"
msgstr "строка с командой, которая должна быть выполнена"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:338(literal) spi.xml:722(literal) spi.xml:1383(literal)
#: spi.xml:1501(literal) spi.xml:1744(literal) spi.xml:1888(literal)
#: spi.xml:1993(literal) spi.xml:2113(literal) spi.xml:2198(literal)
msgid "bool <placeholder-1/>"
msgstr "bool <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:340(para) spi.xml:724(para) spi.xml:1385(para) spi.xml:1503(para)
#: spi.xml:1746(para) spi.xml:1890(para) spi.xml:1995(para)
msgid "<literal>true</literal> for read-only execution"
msgstr ""
"<literal>true</literal> для режима выполнения &laquo;только чтение&raquo;"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:345(literal) spi.xml:582(literal) spi.xml:729(literal)
#: spi.xml:1390(literal) spi.xml:1508(literal) spi.xml:1612(literal)
#: spi.xml:2122(literal) spi.xml:2207(literal) spi.xml:2284(literal)
#: spi.xml:2384(literal)
msgid "long <placeholder-1/>"
msgstr "long <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:347(para) spi.xml:584(para) spi.xml:731(para) spi.xml:1392(para)
#: spi.xml:1510(para) spi.xml:1614(para)
msgid "maximum number of rows to return, or <literal>0</literal> for no limit"
msgstr ""
"максимальное число строк, которое должно быть возвращено; с <literal>0</"
"literal> ограничения нет"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:365(symbol)
msgid "SPI_OK_SELECT"
msgstr "SPI_OK_SELECT"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:367(para)
msgid ""
"if a <command>SELECT</command> (but not <command>SELECT INTO</command>) was "
"executed"
msgstr ""
"если выполнялась команда <command>SELECT</command> (но не <command>SELECT "
"INTO</command>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:375(symbol)
msgid "SPI_OK_SELINTO"
msgstr "SPI_OK_SELINTO"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:377(para)
msgid "if a <command>SELECT INTO</command> was executed"
msgstr "если выполнялась команда <command>SELECT INTO</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:384(symbol)
msgid "SPI_OK_INSERT"
msgstr "SPI_OK_INSERT"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:386(para)
msgid "if an <command>INSERT</command> was executed"
msgstr "если выполнялась команда <command>INSERT</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:393(symbol)
msgid "SPI_OK_DELETE"
msgstr "SPI_OK_DELETE"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:395(para)
msgid "if a <command>DELETE</command> was executed"
msgstr "если выполнялась команда <command>DELETE</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:402(symbol)
msgid "SPI_OK_UPDATE"
msgstr "SPI_OK_UPDATE"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:404(para)
msgid "if an <command>UPDATE</command> was executed"
msgstr "если выполнялась команда <command>UPDATE</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:411(symbol)
msgid "SPI_OK_INSERT_RETURNING"
msgstr "SPI_OK_INSERT_RETURNING"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:413(para)
msgid "if an <command>INSERT RETURNING</command> was executed"
msgstr "если выполнялась команда <command>INSERT RETURNING</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:420(symbol)
msgid "SPI_OK_DELETE_RETURNING"
msgstr "SPI_OK_DELETE_RETURNING"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:422(para)
msgid "if a <command>DELETE RETURNING</command> was executed"
msgstr "если выполнялась команда <command>DELETE RETURNING</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:429(symbol)
msgid "SPI_OK_UPDATE_RETURNING"
msgstr "SPI_OK_UPDATE_RETURNING"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:431(para)
msgid "if an <command>UPDATE RETURNING</command> was executed"
msgstr "если выполнялась команда <command>UPDATE RETURNING</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:438(symbol)
msgid "SPI_OK_UTILITY"
msgstr "SPI_OK_UTILITY"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:440(para)
msgid ""
"if a utility command (e.g., <command>CREATE TABLE</command>) was executed"
msgstr ""
"если выполнялась служебная команда (например, <command>CREATE TABLE</"
"command>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:448(symbol)
msgid "SPI_OK_REWRITTEN"
msgstr "SPI_OK_REWRITTEN"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:450(para)
msgid ""
"if the command was rewritten into another kind of command (e.g., "
"<command>UPDATE</command> became an <command>INSERT</command>) by a <link "
"linkend=\"rules\">rule</link>."
msgstr ""
"если команда была преобразована <link linkend=\"rules\">правилом</link> в "
"команду другого вида (например, <command>UPDATE</command> стал командой "
"<command>INSERT</command>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:359(para)
msgid ""
"If the execution of the command was successful then one of the following "
"(nonnegative) values will be returned: <placeholder-1/>"
msgstr ""
"Если команда была выполнена успешно, возвращается одно из следующих "
"(неотрицательных) значений: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:464(symbol) spi.xml:1410(symbol) spi.xml:2606(symbol)
#: spi.xml:2718(symbol) spi.xml:2824(symbol) spi.xml:2939(symbol)
#: spi.xml:4063(symbol)
msgid "SPI_ERROR_ARGUMENT"
msgstr "SPI_ERROR_ARGUMENT"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:466(para)
msgid ""
"if <parameter>command</parameter> is <symbol>NULL</symbol> or "
"<parameter>count</parameter> is less than 0"
msgstr ""
"если в качестве <parameter>command</parameter> передан <symbol>NULL</symbol> "
"или <parameter>count</parameter> меньше 0"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:474(symbol)
msgid "SPI_ERROR_COPY"
msgstr "SPI_ERROR_COPY"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:476(para)
msgid ""
"if <command>COPY TO stdout</command> or <command>COPY FROM stdin</command> "
"was attempted"
msgstr ""
"при попытке выполнить <command>COPY TO stdout</command> или <command>COPY "
"FROM stdin</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:484(symbol)
msgid "SPI_ERROR_TRANSACTION"
msgstr "SPI_ERROR_TRANSACTION"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:486(para)
msgid ""
"if a transaction manipulation command was attempted (<command>BEGIN</"
"command>, <command>COMMIT</command>, <command>ROLLBACK</command>, "
"<command>SAVEPOINT</command>, <command>PREPARE TRANSACTION</command>, "
"<command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command>, or "
"any variant thereof)"
msgstr ""
"при попытке выполнить команду управления транзакциями (<command>BEGIN</"
"command>, <command>COMMIT</command>, <command>ROLLBACK</command>, "
"<command>SAVEPOINT</command>, <command>PREPARE TRANSACTION</command>, "
"<command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command> или "
"любую их вариацию)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:501(symbol)
msgid "SPI_ERROR_OPUNKNOWN"
msgstr "SPI_ERROR_OPUNKNOWN"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:503(para)
msgid "if the command type is unknown (shouldn't happen)"
msgstr "если тип команды неизвестен (такого быть не должно)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:459(para) spi.xml:2713(para) spi.xml:2819(para) spi.xml:2934(para)
msgid ""
"On error, one of the following negative values is returned: <placeholder-1/>"
msgstr ""
"В случае ошибки возвращается одно из следующих отрицательных значений: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:522(title) spi.xml:867(title) spi.xml:1005(title)
#: spi.xml:2143(title) spi.xml:2218(title) spi.xml:2309(title)
#: spi.xml:2410(title) spi.xml:2538(title) spi.xml:2627(title)
msgid "Notes"
msgstr "Замечания"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:524(para)
msgid ""
"All SPI query-execution functions set both <varname>SPI_processed</varname> "
"and <varname>SPI_tuptable</varname> (just the pointer, not the contents of "
"the structure). Save these two global variables into local procedure "
"variables if you need to access the result table of <function>SPI_execute</"
"function> or another query-execution function across later calls."
msgstr ""
"Все функции SPI, выполняющие запросы, заполняют и <varname>SPI_processed</"
"varname>, и <varname>SPI_tuptable</varname> (только указатель, но не "
"содержимое структуры). Сохраните эти две глобальные переменные в локальных "
"переменных процедуры, если хотите обращаться к таблице результата "
"<function>SPI_execute</function> или другой функции, выполняющей запрос, в "
"нескольких вызовах процедуры."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:539(indexterm)
msgid "<primary>SPI_exec</primary>"
msgstr "<primary>SPI_exec</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:542(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_exec"
msgstr "SPI_exec"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:547(refname)
msgctxt "refname"
msgid "SPI_exec"
msgstr "SPI_exec"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:548(refpurpose)
msgid "execute a read/write command"
msgstr "выполнить команду чтения/записи"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:552(synopsis)
#, no-wrap
msgid "int SPI_exec(const char * <placeholder-1/>, long <placeholder-2/>)"
msgstr "int SPI_exec(const char * <placeholder-1/>, long <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:560(para)
msgid ""
"<function>SPI_exec</function> is the same as <function>SPI_execute</"
"function>, with the latter's <parameter>read_only</parameter> parameter "
"always taken as <literal>false</literal>."
msgstr ""
"<function>SPI_exec</function> действует подобно <function>SPI_execute</"
"function>, но ей не передаётся параметр <parameter>read_only</parameter> "
"(всегда подразумевается <literal>false</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:596(para)
msgid "See <function>SPI_execute</function>."
msgstr "См. <function>SPI_execute</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:605(indexterm)
msgid "<primary>SPI_execute_with_args</primary>"
msgstr "<primary>SPI_execute_with_args</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:608(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute_with_args"
msgstr "SPI_execute_with_args"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:613(refname)
msgctxt "refname"
msgid "SPI_execute_with_args"
msgstr "SPI_execute_with_args"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:614(refpurpose)
msgid "execute a command with out-of-line parameters"
msgstr "выполнить команду с выделенными параметрами"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:620(parameter) spi.xml:671(parameter) spi.xml:772(parameter)
#: spi.xml:830(parameter) spi.xml:934(parameter) spi.xml:966(parameter)
#: spi.xml:1781(parameter) spi.xml:1837(parameter)
msgid "nargs"
msgstr "nargs"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:620(parameter) spi.xml:680(parameter) spi.xml:772(parameter)
#: spi.xml:839(parameter) spi.xml:935(parameter) spi.xml:975(parameter)
#: spi.xml:1781(parameter) spi.xml:1846(parameter)
msgid "argtypes"
msgstr "argtypes"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:621(parameter) spi.xml:690(parameter) spi.xml:1320(parameter)
#: spi.xml:1351(parameter) spi.xml:1551(parameter) spi.xml:1580(parameter)
#: spi.xml:1656(parameter) spi.xml:1712(parameter) spi.xml:1782(parameter)
#: spi.xml:1856(parameter) spi.xml:3952(parameter) spi.xml:4017(parameter)
msgid "values"
msgstr "values"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:621(parameter) spi.xml:700(parameter) spi.xml:1320(parameter)
#: spi.xml:1361(parameter) spi.xml:1551(parameter) spi.xml:1590(parameter)
#: spi.xml:1656(parameter) spi.xml:1722(parameter) spi.xml:1782(parameter)
#: spi.xml:1866(parameter) spi.xml:3952(parameter) spi.xml:4027(parameter)
msgid "nulls"
msgstr "nulls"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:618(synopsis)
#, no-wrap
msgid ""
"int SPI_execute_with_args(const char *<placeholder-1/>,\n"
"                          int <placeholder-2/>, Oid *<placeholder-3/>,\n"
"                          Datum *<placeholder-4/>, const char *<placeholder-5/>,\n"
"                          bool <placeholder-6/>, long <placeholder-7/>)"
msgstr ""
"int SPI_execute_with_args(const char *<placeholder-1/>,\n"
"                          int <placeholder-2/>, Oid *<placeholder-3/>,\n"
"                          Datum *<placeholder-4/>, const char *<placeholder-5/>,\n"
"                          bool <placeholder-6/>, long <placeholder-7/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:629(para)
msgid ""
"<function>SPI_execute_with_args</function> executes a command that might "
"include references to externally supplied parameters. The command text "
"refers to a parameter as <literal>$<replaceable>n</replaceable></literal>, "
"and the call specifies data types and values for each such symbol. "
"<parameter>read_only</parameter> and <parameter>count</parameter> have the "
"same interpretation as in <function>SPI_execute</function>."
msgstr ""
"<function>SPI_execute_with_args</function> выполняет команду, которая может "
"включать ссылки на параметры, передаваемые извне. В тексте команды параметры "
"обозначаются символами <literal>$<replaceable>n</replaceable></literal>, а в "
"вызове указываются типы данных и значения для каждого такого символа. "
"Параметры <parameter>read_only</parameter> и <parameter>count</parameter> "
"имеют тот же смысл, что и в <function>SPI_execute</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:638(para)
msgid ""
"The main advantage of this routine compared to <function>SPI_execute</"
"function> is that data values can be inserted into the command without "
"tedious quoting/escaping, and thus with much less risk of SQL-injection "
"attacks."
msgstr ""
"Основное преимущество этой функции по сравнению с <function>SPI_execute</"
"function> в том, что она позволяет передавать в команду значения данных, не "
"требуя кропотливой подготовки строк, и таким образом сокращает риск атак с "
"SQL-инъекцией."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:645(para)
msgid ""
"Similar results can be achieved with <function>SPI_prepare</function> "
"followed by <function>SPI_execute_plan</function>; however, when using this "
"function the query plan is always customized to the specific parameter "
"values provided. For one-time query execution, this function should be "
"preferred. If the same command is to be executed with many different "
"parameters, either method might be faster, depending on the cost of re-"
"planning versus the benefit of custom plans."
msgstr ""
"Подобного результата можно достичь, вызвав <function>SPI_prepare</function> "
"и затем <function>SPI_execute_plan</function>; однако, с данной функцией "
"план запроса всегда подстраивается под переданные конкретные значения "
"параметров. Поэтому для разового выполнения запроса рекомендуется применять "
"эту функцию. Если же одна и та же команда должна выполняться с самыми "
"разными параметрами, какой вариант окажется быстрее, будет зависеть от "
"стоимости повторного планирования и выигрыша от выбора специализированных "
"планов."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:664(para) spi.xml:823(para) spi.xml:959(para) spi.xml:1062(para)
#: spi.xml:1830(para)
msgid "command string"
msgstr "строка команды"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:671(literal) spi.xml:830(literal) spi.xml:966(literal)
#: spi.xml:985(literal) spi.xml:1087(literal) spi.xml:1210(literal)
#: spi.xml:1837(literal) spi.xml:1895(literal) spi.xml:3033(literal)
#: spi.xml:3189(literal) spi.xml:3273(literal) spi.xml:3353(literal)
#: spi.xml:3418(literal) spi.xml:3998(literal)
msgid "int <placeholder-1/>"
msgstr "int <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:673(para) spi.xml:832(para) spi.xml:968(para) spi.xml:1839(para)
msgid ""
"number of input parameters (<literal>$1</literal>, <literal>$2</literal>, "
"etc.)"
msgstr ""
"число входных параметров (<literal>$1</literal>, <literal>$2</literal> и т. "
"д.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:680(literal) spi.xml:839(literal) spi.xml:975(literal)
#: spi.xml:1846(literal)
msgid "Oid * <placeholder-1/>"
msgstr "Oid * <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:682(para) spi.xml:1848(para)
msgid ""
"an array of length <parameter>nargs</parameter>, containing the "
"<acronym>OID</acronym>s of the data types of the parameters"
msgstr ""
"массив размера <parameter>nargs</parameter>, содержащий <acronym>OID</"
"acronym> типов параметров"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:690(literal) spi.xml:1351(literal) spi.xml:1580(literal)
#: spi.xml:1712(literal) spi.xml:1856(literal) spi.xml:4017(literal)
msgid "Datum * <placeholder-1/>"
msgstr "Datum * <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:692(para) spi.xml:1858(para)
msgid ""
"an array of length <parameter>nargs</parameter>, containing the actual "
"parameter values"
msgstr ""
"массив размера <parameter>nargs</parameter>, содержащий фактические значения "
"параметров"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:702(para) spi.xml:1868(para)
msgid ""
"an array of length <parameter>nargs</parameter>, describing which parameters "
"are null"
msgstr ""
"массив размера <parameter>nargs</parameter>, описывающий, в каких параметрах "
"передаётся NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:707(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_execute_with_args</function> assumes that no parameters are "
"null. Otherwise, each entry of the <parameter>nulls</parameter> array should "
"be <literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_execute_with_args</function> считает, что ни один из "
"параметров не равен NULL. В противном случае элемент массива "
"<parameter>nulls</parameter> должен содержать <literal>'&nbsp;'</literal>, "
"если значение соответствующего параметра не NULL, либо <literal>'n'</"
"literal>, если это значение — NULL. (В последнем случае значение, переданное "
"в соответствующем элементе <parameter>values</parameter>, не учитывается.) "
"Заметьте, что <parameter>nulls</parameter> — это не текстовая строка, а "
"просто массив: ноль (<literal>'\\0'</literal>) в конце не нужен."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:743(para)
msgid "The return value is the same as for <function>SPI_execute</function>."
msgstr "Возвращаемые значения те же, что и у <function>SPI_execute</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:747(para) spi.xml:1431(para) spi.xml:1630(para) spi.xml:2135(para)
#: spi.xml:2301(para)
msgid ""
"<varname>SPI_processed</varname> and <varname>SPI_tuptable</varname> are set "
"as in <function>SPI_execute</function> if successful."
msgstr ""
"Переменные <varname>SPI_processed</varname> и <varname>SPI_tuptable</"
"varname> устанавливаются как в <function>SPI_execute</function>, если вызов "
"был успешным."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:758(indexterm)
msgid "<primary>SPI_prepare</primary>"
msgstr "<primary>SPI_prepare</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:761(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_prepare"
msgstr "SPI_prepare"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:766(refname)
msgctxt "refname"
msgid "SPI_prepare"
msgstr "SPI_prepare"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:767(refpurpose) spi.xml:929(refpurpose) spi.xml:1031(refpurpose)
msgid "prepare a statement, without executing it yet"
msgstr "подготовить оператор, но пока не выполнять его"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:771(synopsis)
#, no-wrap
msgid "SPIPlanPtr SPI_prepare(const char * <placeholder-1/>, int <placeholder-2/>, Oid * <placeholder-3/>)"
msgstr "SPIPlanPtr SPI_prepare(const char * <placeholder-1/>, int <placeholder-2/>, Oid * <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:779(para)
msgid ""
"<function>SPI_prepare</function> creates and returns a prepared statement "
"for the specified command, but doesn't execute the command. The prepared "
"statement can later be executed repeatedly using <function>SPI_execute_plan</"
"function>."
msgstr ""
"<function>SPI_prepare</function> создаёт и возвращает подготовленный "
"оператор для заданной команды. Подготовленный оператор может быть затем "
"неоднократно выполнен функцией <function>SPI_execute_plan</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:786(para)
msgid ""
"When the same or a similar command is to be executed repeatedly, it is "
"generally advantageous to perform parse analysis only once, and might "
"furthermore be advantageous to re-use an execution plan for the command. "
"<function>SPI_prepare</function> converts a command string into a prepared "
"statement that encapsulates the results of parse analysis. The prepared "
"statement also provides a place for caching an execution plan if it is found "
"that generating a custom plan for each execution is not helpful."
msgstr ""
"Когда одна и та же или похожие команды выполняются неоднократно, обычно "
"выгоднее произвести анализ запроса только раз, а ещё выгоднее может быть "
"повторно использовать план выполнения команды. <function>SPI_prepare</"
"function> преобразует строку команды в подготовленный оператор, включающий в "
"себя результаты анализа запроса. Подготовленный оператор также оставляет "
"место для кеширования плана выполнения, если выбор специализированного плана "
"для каждого выполнения не принесёт пользы."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:798(para)
msgid ""
"A prepared command can be generalized by writing parameters (<literal>$1</"
"literal>, <literal>$2</literal>, etc.) in place of what would be constants "
"in a normal command. The actual values of the parameters are then specified "
"when <function>SPI_execute_plan</function> is called. This allows the "
"prepared command to be used over a wider range of situations than would be "
"possible without parameters."
msgstr ""
"Подготавливаемую команду можно сделать более общей, записав параметры "
"(<literal>$1</literal>, <literal>$2</literal>, etc.) вместо значений, "
"задаваемыми константами в обычной команде. Фактические значения параметров в "
"этом случае будут задаваться при вызове <function>SPI_execute_plan</"
"function>. Это позволяет применять подготовленную команду в более широком "
"круге ситуаций, чем это возможно без параметров."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:807(para)
msgid ""
"The statement returned by <function>SPI_prepare</function> can be used only "
"in the current invocation of the procedure, since <function>SPI_finish</"
"function> frees memory allocated for such a statement. But the statement can "
"be saved for longer using the functions <function>SPI_keepplan</function> or "
"<function>SPI_saveplan</function>."
msgstr ""
"Оператор, возвращаемый функцией <function>SPI_prepare</function>, может "
"использоваться только в текущем вызове процедуры, так как "
"<function>SPI_finish</function> освобождает память, выделенную для такого "
"оператора. Но этот оператор может быть сохранён на будущее с помощью функций "
"<function>SPI_keepplan</function> или <function>SPI_saveplan</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:841(para) spi.xml:977(para)
msgid ""
"pointer to an array containing the <acronym>OID</acronym>s of the data types "
"of the parameters"
msgstr ""
"указатель на массив, содержащий <acronym>OID</acronym> типов параметров"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:853(para)
msgid ""
"<function>SPI_prepare</function> returns a non-null pointer to an "
"<type>SPIPlan</type>, which is an opaque struct representing a prepared "
"statement. On error, <symbol>NULL</symbol> will be returned, and "
"<varname>SPI_result</varname> will be set to one of the same error codes "
"used by <function>SPI_execute</function>, except that it is set to "
"<symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>command</parameter> is "
"<symbol>NULL</symbol>, or if <parameter>nargs</parameter> is less than 0, or "
"if <parameter>nargs</parameter> is greater than 0 and <parameter>argtypes</"
"parameter> is <symbol>NULL</symbol>."
msgstr ""
"<function>SPI_prepare</function> возвращает ненулевой указатель на "
"<type>SPIPlan</type>, скрытую структуру, представляющую подготовленный "
"оператор. В случае ошибки возвращается <symbol>NULL</symbol>, а в "
"<varname>SPI_result</varname> устанавливается один из кодов ошибок, "
"определённых для <function>SPI_execute</function>, за исключением того, что "
"код <symbol>SPI_ERROR_ARGUMENT</symbol> устанавливается, когда "
"<parameter>command</parameter> — <symbol>NULL</symbol>, когда "
"<parameter>nargs</parameter> меньше 0 или когда <parameter>nargs</parameter> "
"больше 0, а <parameter>argtypes</parameter> — <symbol>NULL</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:869(para)
msgid ""
"If no parameters are defined, a generic plan will be created at the first "
"use of <function>SPI_execute_plan</function>, and used for all subsequent "
"executions as well. If there are parameters, the first few uses of "
"<function>SPI_execute_plan</function> will generate custom plans that are "
"specific to the supplied parameter values. After enough uses of the same "
"prepared statement, <function>SPI_execute_plan</function> will build a "
"generic plan, and if that is not too much more expensive than the custom "
"plans, it will start using the generic plan instead of re-planning each "
"time. If this default behavior is unsuitable, you can alter it by passing "
"the <literal>CURSOR_OPT_GENERIC_PLAN</literal> or "
"<literal>CURSOR_OPT_CUSTOM_PLAN</literal> flag to "
"<function>SPI_prepare_cursor</function>, to force use of generic or custom "
"plans respectively."
msgstr ""
"Если параметры не определены, при первом использовании "
"<function>SPI_execute_plan</function> создаётся общий план, который затем "
"будет применяться при последующих вызовах. Если же присутствуют параметры, "
"<function>SPI_execute_plan</function> будет создавать специализированные "
"планы для конкретных значений параметров. После достаточного количества "
"использований полученного подготовленного оператора, функция "
"<function>SPI_execute_plan</function> построит общий план, и если он не "
"будет значительно дороже специализированных, она начнёт использовать его, а "
"не будет строить план заново. Если это поведение по умолчанию не устраивает, "
"его можно изменить, передав флаг <literal>CURSOR_OPT_GENERIC_PLAN</literal> "
"или <literal>CURSOR_OPT_CUSTOM_PLAN</literal> в "
"<function>SPI_prepare_cursor</function>, чтобы ограничиться использованием "
"только общего или специализированных планов, соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:885(para)
msgid ""
"Although the main point of a prepared statement is to avoid repeated parse "
"analysis and planning of the statement, <productname>PostgreSQL</"
"productname> will force re-analysis and re-planning of the statement before "
"using it whenever database objects used in the statement have undergone "
"definitional (DDL) changes since the previous use of the prepared statement. "
"Also, if the value of <xref linkend=\"guc-search-path\"/> changes from one "
"use to the next, the statement will be re-parsed using the new "
"<varname>search_path</varname>. (This latter behavior is new as of "
"<productname>PostgreSQL</productname> 9.3.) See <xref linkend=\"sql-prepare"
"\"/> for more information about the behavior of prepared statements."
msgstr ""
"Хотя основной смысл подготовленного оператора в том, чтобы избежать "
"повторного разбора и планирования запроса, <productname>PostgreSQL</"
"productname> всё же будет принудительно повторять разбор и планирование "
"запроса перед его выполнением, если со времени предыдущего использования "
"подготовленного оператора произойдут изменения определений (DDL) объектов "
"базы, задействованных в этом запросе. Также, если перед очередным "
"использованием было изменено значение <xref linkend=\"guc-search-path\"/>, "
"запрос будет разобран заново с новым значением <varname>search_path</"
"varname>. (Последняя особенность появилась в <productname>PostgreSQL</"
"productname> 9.3.) Чтобы узнать о поведении подготовленных операторов "
"больше, обратитесь к <xref remap=\"3\" linkend=\"sql-prepare\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:899(para)
msgid "This function should only be called from a connected procedure."
msgstr "Эту функцию следует вызывать только из подключённой процедуры."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:903(para)
msgid ""
"<type>SPIPlanPtr</type> is declared as a pointer to an opaque struct type in "
"<filename>spi.h</filename>. It is unwise to try to access its contents "
"directly, as that makes your code much more likely to break in future "
"revisions of <productname>PostgreSQL</productname>."
msgstr ""
"<type>SPIPlanPtr</type> объявлен в <filename>spi.h</filename> как указатель "
"на скрытую структуру. Пытаться обращаться к её содержимому напрямую не "
"стоит, так как ваш код скорее всего сломается при выходе новых версий "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:910(para)
msgid ""
"The name <type>SPIPlanPtr</type> is somewhat historical, since the data "
"structure no longer necessarily contains an execution plan."
msgstr ""
"Имя <type>SPIPlanPtr</type> объясняется отчасти историческими причинами, так "
"как теперь эта структура может не содержать собственно план выполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:920(indexterm)
msgid "<primary>SPI_prepare_cursor</primary>"
msgstr "<primary>SPI_prepare_cursor</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:923(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_prepare_cursor"
msgstr "SPI_prepare_cursor"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:928(refname)
msgctxt "refname"
msgid "SPI_prepare_cursor"
msgstr "SPI_prepare_cursor"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:935(parameter) spi.xml:985(parameter) spi.xml:1039(parameter)
#: spi.xml:1087(parameter) spi.xml:1783(parameter) spi.xml:1895(parameter)
msgid "cursorOptions"
msgstr "cursorOptions"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:933(synopsis)
#, no-wrap
msgid ""
"SPIPlanPtr SPI_prepare_cursor(const char * <placeholder-1/>, int <placeholder-2/>,\n"
"                              Oid * <placeholder-3/>, int <placeholder-4/>)"
msgstr ""
"SPIPlanPtr SPI_prepare_cursor(const char * <placeholder-1/>, int <placeholder-2/>,\n"
"                              Oid * <placeholder-3/>, int <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:942(para)
msgid ""
"<function>SPI_prepare_cursor</function> is identical to "
"<function>SPI_prepare</function>, except that it also allows specification "
"of the planner's <quote>cursor options</quote> parameter. This is a bit mask "
"having the values shown in <filename>nodes/parsenodes.h</filename> for the "
"<structfield>options</structfield> field of <structname>DeclareCursorStmt</"
"structname>. <function>SPI_prepare</function> always takes the cursor "
"options as zero."
msgstr ""
"Функция <function>SPI_prepare_cursor</function> равнозначна "
"<function>SPI_prepare</function>, за исключением того, что ей можно передать "
"<quote>параметры курсора</quote>. Эти параметры задаются битовой маской со "
"значениями, определёнными в <filename>nodes/parsenodes.h</filename> для поля "
"<structfield>options</structfield> структуры <structname>DeclareCursorStmt</"
"structname>. <function>SPI_prepare</function> подразумевает, что эти "
"параметры всегда нулевые."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:987(para) spi.xml:1089(para) spi.xml:1897(para)
msgid "integer bit mask of cursor options; zero produces default behavior"
msgstr "битовая маска параметров курсора; 0 выбирает поведение по умолчанию"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:998(para)
msgid ""
"<function>SPI_prepare_cursor</function> has the same return conventions as "
"<function>SPI_prepare</function>."
msgstr ""
"<function>SPI_prepare_cursor</function> возвращает результат по тем же "
"соглашениям, что и <function>SPI_prepare</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1007(para)
msgid ""
"Useful bits to set in <parameter>cursorOptions</parameter> include "
"<symbol>CURSOR_OPT_SCROLL</symbol>, <symbol>CURSOR_OPT_NO_SCROLL</symbol>, "
"<symbol>CURSOR_OPT_FAST_PLAN</symbol>, <symbol>CURSOR_OPT_GENERIC_PLAN</"
"symbol>, and <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>. Note in particular "
"that <symbol>CURSOR_OPT_HOLD</symbol> is ignored."
msgstr ""
"К числу полезных бит, которые можно задать в <parameter>cursorOptions</"
"parameter>, относятся <symbol>CURSOR_OPT_SCROLL</symbol>, "
"<symbol>CURSOR_OPT_NO_SCROLL</symbol>, <symbol>CURSOR_OPT_FAST_PLAN</"
"symbol>, <symbol>CURSOR_OPT_GENERIC_PLAN</symbol> и "
"<symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>. Заметьте, что параметр "
"<symbol>CURSOR_OPT_HOLD</symbol> игнорируется."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1022(indexterm)
msgid "<primary>SPI_prepare_params</primary>"
msgstr "<primary>SPI_prepare_params</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1025(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_prepare_params"
msgstr "SPI_prepare_params"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1030(refname)
msgctxt "refname"
msgid "SPI_prepare_params"
msgstr "SPI_prepare_params"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1037(parameter) spi.xml:1069(parameter)
msgid "parserSetup"
msgstr "parserSetup"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1038(parameter) spi.xml:1078(parameter)
msgid "parserSetupArg"
msgstr "parserSetupArg"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1035(synopsis)
#, no-wrap
msgid ""
"SPIPlanPtr SPI_prepare_params(const char * <placeholder-1/>,\n"
"                              ParserSetupHook <placeholder-2/>,\n"
"                              void * <placeholder-3/>,\n"
"                              int <placeholder-4/>)"
msgstr ""
"SPIPlanPtr SPI_prepare_params(const char * <placeholder-1/>,\n"
"                              ParserSetupHook <placeholder-2/>,\n"
"                              void * <placeholder-3/>,\n"
"                              int <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1046(para)
msgid ""
"<function>SPI_prepare_params</function> creates and returns a prepared "
"statement for the specified command, but doesn't execute the command. This "
"function is equivalent to <function>SPI_prepare_cursor</function>, with the "
"addition that the caller can specify parser hook functions to control the "
"parsing of external parameter references."
msgstr ""
"<function>SPI_prepare_params</function> создаёт и возвращает подготовленный "
"оператор для заданной команды, но не выполняет саму команду. Эта функция "
"равнозначна <function>SPI_prepare_cursor</function>, но позволяет "
"вызывающему дополнительно установить функции-обработчики для управления "
"разбором ссылок на внешние параметры."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1069(literal)
msgid "ParserSetupHook <placeholder-1/>"
msgstr "ParserSetupHook <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1071(para)
msgid "Parser hook setup function"
msgstr "Функция настройки обработчиков разбора"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1078(literal) spi.xml:3709(literal) spi.xml:3780(literal)
msgid "void * <placeholder-1/>"
msgstr "void * <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1080(para)
msgid "pass-through argument for <parameter>parserSetup</parameter>"
msgstr "аргумент для сквозной передачи в <parameter>parserSetup</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1100(para)
msgid ""
"<function>SPI_prepare_params</function> has the same return conventions as "
"<function>SPI_prepare</function>."
msgstr ""
"<function>SPI_prepare_params</function> возвращает результат по тем же "
"соглашениям, что и <function>SPI_prepare</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1110(indexterm)
msgid "<primary>SPI_getargcount</primary>"
msgstr "<primary>SPI_getargcount</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1113(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getargcount"
msgstr "SPI_getargcount"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1118(refname)
msgctxt "refname"
msgid "SPI_getargcount"
msgstr "SPI_getargcount"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1120(function) spi.xml:1177(function) spi.xml:1247(function)
#: spi.xml:1315(function) spi.xml:1451(function) spi.xml:1650(function)
msgctxt "function"
msgid "SPI_prepare"
msgstr "SPI_prepare"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1119(refpurpose)
msgid ""
"return the number of arguments needed by a statement prepared by "
"<placeholder-1/>"
msgstr ""
"получить число аргументов, требующихся оператору, подготовленному функцией "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1125(parameter) spi.xml:1143(parameter) spi.xml:1182(parameter)
#: spi.xml:1201(parameter) spi.xml:1253(parameter) spi.xml:1278(parameter)
#: spi.xml:1320(parameter) spi.xml:1342(parameter) spi.xml:1456(parameter)
#: spi.xml:1483(parameter) spi.xml:1551(parameter) spi.xml:1571(parameter)
#: spi.xml:1655(parameter) spi.xml:1703(parameter) spi.xml:1933(parameter)
#: spi.xml:1975(parameter) spi.xml:2496(parameter) spi.xml:2517(parameter)
#: spi.xml:2565(parameter) spi.xml:2587(parameter) spi.xml:4234(parameter)
#: spi.xml:4253(parameter)
msgid "plan"
msgstr "plan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1124(synopsis)
#, no-wrap
msgid "int SPI_getargcount(SPIPlanPtr <placeholder-1/>)"
msgstr "int SPI_getargcount(SPIPlanPtr <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1132(para)
msgid ""
"<function>SPI_getargcount</function> returns the number of arguments needed "
"to execute a statement prepared by <function>SPI_prepare</function>."
msgstr ""
"<function>SPI_getargcount</function> возвращает число аргументов, "
"требующихся для выполнения оператора, подготовленного функцией "
"<function>SPI_prepare</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1143(literal) spi.xml:1201(literal) spi.xml:1278(literal)
#: spi.xml:1342(literal) spi.xml:1483(literal) spi.xml:1571(literal)
#: spi.xml:1703(literal) spi.xml:1975(literal) spi.xml:2517(literal)
#: spi.xml:2587(literal) spi.xml:4253(literal)
msgid "SPIPlanPtr <placeholder-1/>"
msgstr "SPIPlanPtr <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1145(para) spi.xml:1203(para) spi.xml:1280(para) spi.xml:1344(para)
#: spi.xml:1485(para) spi.xml:1573(para) spi.xml:1705(para) spi.xml:1977(para)
msgid "prepared statement (returned by <function>SPI_prepare</function>)"
msgstr ""
"подготовленный оператор (возвращаемый функцией <function>SPI_prepare</"
"function>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1155(para)
msgid ""
"The count of expected arguments for the <parameter>plan</parameter>. If the "
"<parameter>plan</parameter> is <symbol>NULL</symbol> or invalid, "
"<varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol> "
"and -1 is returned."
msgstr ""
"Число аргументов, которое ожидает план, заданный параметром <parameter>plan</"
"parameter>. Если значение <parameter>plan</parameter> неверное или "
"<symbol>NULL</symbol>, в <varname>SPI_result</varname> устанавливается код "
"<symbol>SPI_ERROR_ARGUMENT</symbol>, а функция возвращает -1."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1167(indexterm)
msgid "<primary>SPI_getargtypeid</primary>"
msgstr "<primary>SPI_getargtypeid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1170(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getargtypeid"
msgstr "SPI_getargtypeid"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1175(refname)
msgctxt "refname"
msgid "SPI_getargtypeid"
msgstr "SPI_getargtypeid"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1176(refpurpose)
msgid ""
"return the data type OID for an argument of a statement prepared by "
"<placeholder-1/>"
msgstr ""
"получить OID типа аргумента для оператора, подготовленного функцией "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1182(parameter) spi.xml:1210(parameter)
msgid "argIndex"
msgstr "argIndex"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1181(synopsis)
#, no-wrap
msgid "Oid SPI_getargtypeid(SPIPlanPtr <placeholder-1/>, int <placeholder-2/>)"
msgstr "Oid SPI_getargtypeid(SPIPlanPtr <placeholder-1/>, int <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1189(para)
msgid ""
"<function>SPI_getargtypeid</function> returns the OID representing the type "
"for the <parameter>argIndex</parameter>'th argument of a statement prepared "
"by <function>SPI_prepare</function>. First argument is at index zero."
msgstr ""
"<function>SPI_getargtypeid</function> возвращает OID, представляющий тип "
"аргумента под номером <parameter>argIndex</parameter> оператора, "
"подготовленного функцией <function>SPI_prepare</function>. Первый аргумент "
"идёт под номером ноль."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1212(para)
msgid "zero based index of the argument"
msgstr "индекс аргумента, начиная с нуля"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1222(para)
msgid ""
"The type OID of the argument at the given index. If the <parameter>plan</"
"parameter> is <symbol>NULL</symbol> or invalid, or <parameter>argIndex</"
"parameter> is less than 0 or not less than the number of arguments declared "
"for the <parameter>plan</parameter>, <varname>SPI_result</varname> is set to "
"<symbol>SPI_ERROR_ARGUMENT</symbol> and <symbol>InvalidOid</symbol> is "
"returned."
msgstr ""
"OID типа аргумента с заданным индексом. Если значение <parameter>plan</"
"parameter> неверное или <symbol>NULL</symbol>, либо <parameter>argIndex</"
"parameter> меньше 0 или не меньше числа аргументов, объявленных при "
"подготовке плана (передаваемого в <parameter>plan</parameter>), в "
"<varname>SPI_result</varname> устанавливается <symbol>SPI_ERROR_ARGUMENT</"
"symbol> и возвращается <symbol>InvalidOid</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1237(indexterm)
msgid "<primary>SPI_is_cursor_plan</primary>"
msgstr "<primary>SPI_is_cursor_plan</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1240(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_is_cursor_plan"
msgstr "SPI_is_cursor_plan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1245(refname)
msgctxt "refname"
msgid "SPI_is_cursor_plan"
msgstr "SPI_is_cursor_plan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1246(symbol)
msgid "true"
msgstr "true"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1248(function)
msgctxt "function"
msgid "SPI_cursor_open"
msgstr "SPI_cursor_open"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1246(refpurpose)
msgid ""
"return <placeholder-1/> if a statement prepared by <placeholder-2/> can be "
"used with <placeholder-3/>"
msgstr ""
"выдать <placeholder-1/>, если оператор, подготовленный функцией "
"<placeholder-2/>, можно использовать с <placeholder-3/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1252(synopsis)
#, no-wrap
msgid "bool SPI_is_cursor_plan(SPIPlanPtr <placeholder-1/>)"
msgstr "bool SPI_is_cursor_plan(SPIPlanPtr <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1260(para)
msgid ""
"<function>SPI_is_cursor_plan</function> returns <symbol>true</symbol> if a "
"statement prepared by <function>SPI_prepare</function> can be passed as an "
"argument to <function>SPI_cursor_open</function>, or <symbol>false</symbol> "
"if that is not the case. The criteria are that the <parameter>plan</"
"parameter> represents one single command and that this command returns "
"tuples to the caller; for example, <command>SELECT</command> is allowed "
"unless it contains an <literal>INTO</literal> clause, and <command>UPDATE</"
"command> is allowed only if it contains a <literal>RETURNING</literal> "
"clause."
msgstr ""
"<function>SPI_is_cursor_plan</function> возвращает <symbol>true</symbol>, "
"если оператор, подготовленный функцией <function>SPI_prepare</function>, "
"можно передать в качестве аргумента <function>SPI_cursor_open</function>, "
"или <symbol>false</symbol> в противном случае. Для положительного ответа в "
"<parameter>plan</parameter> должна быть представлена одна команда, и эта "
"команда должна возвращать кортежи; например, <command>SELECT</command> может "
"быть подходящей командой, если он не содержит предложения <literal>INTO</"
"literal>, а <command>UPDATE</command> подходит, только если он содержит "
"предложение <literal>RETURNING</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1290(para)
msgid ""
"<symbol>true</symbol> or <symbol>false</symbol> to indicate if the "
"<parameter>plan</parameter> can produce a cursor or not, with "
"<varname>SPI_result</varname> set to zero. If it is not possible to "
"determine the answer (for example, if the <parameter>plan</parameter> is "
"<symbol>NULL</symbol> or invalid, or if called when not connected to SPI), "
"then <varname>SPI_result</varname> is set to a suitable error code and "
"<symbol>false</symbol> is returned."
msgstr ""
"Значение <symbol>true</symbol> или <symbol>false</symbol>, показывающее, "
"можно ли для подготовленного оператора, заданного параметром "
"<parameter>plan</parameter>, получить курсор, при <varname>SPI_result</"
"varname> равном нулю. Если дать ответ невозможно (например, если значение "
"<parameter>plan</parameter> неверное или <symbol>NULL</symbol>, либо "
"вызывающий не подключён к SPI), в <varname>SPI_result</varname> "
"устанавливается соответствующий код ошибки и возвращается <symbol>false</"
"symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1306(indexterm)
msgid "<primary>SPI_execute_plan</primary>"
msgstr "<primary>SPI_execute_plan</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1309(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute_plan"
msgstr "SPI_execute_plan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1314(refname)
msgctxt "refname"
msgid "SPI_execute_plan"
msgstr "SPI_execute_plan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1315(refpurpose) spi.xml:1451(refpurpose)
msgid "execute a statement prepared by <placeholder-1/>"
msgstr "выполнить оператор, подготовленный функцией <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1319(synopsis)
#, no-wrap
msgid ""
"int SPI_execute_plan(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>,\n"
"                     bool <placeholder-4/>, long <placeholder-5/>)"
msgstr ""
"int SPI_execute_plan(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>,\n"
"                     bool <placeholder-4/>, long <placeholder-5/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1328(para)
msgid ""
"<function>SPI_execute_plan</function> executes a statement prepared by "
"<function>SPI_prepare</function> or one of its siblings. "
"<parameter>read_only</parameter> and <parameter>count</parameter> have the "
"same interpretation as in <function>SPI_execute</function>."
msgstr ""
"<function>SPI_execute_plan</function> выполняет оператор, подготовленный "
"функцией <function>SPI_prepare</function> или родственными ей. Параметры "
"<parameter>read_only</parameter> и <parameter>count</parameter> имеют тот же "
"смысл, что и в <function>SPI_execute</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1353(para) spi.xml:1582(para) spi.xml:1714(para)
msgid ""
"An array of actual parameter values. Must have same length as the "
"statement's number of arguments."
msgstr ""
"Массив фактических значений параметров. Его размер должен равняться числу "
"аргументов оператора."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1363(para) spi.xml:1592(para) spi.xml:1724(para)
msgid ""
"An array describing which parameters are null. Must have same length as the "
"statement's number of arguments."
msgstr ""
"Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь "
"размер, равный числу аргументов оператора."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1368(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_execute_plan</function> assumes that no parameters are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_execute_plan</function> считает, что ни один из параметров не "
"равен NULL. В противном случае элемент массива <parameter>nulls</parameter> "
"должен содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль (<literal>'\\0'</literal>) в конце не нужен."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1412(para)
msgid ""
"if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid, or "
"<parameter>count</parameter> is less than 0"
msgstr ""
"Если <parameter>plan</parameter> неверный или <symbol>NULL</symbol>, либо "
"<parameter>count</parameter> меньше 0"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1420(symbol)
msgid "SPI_ERROR_PARAM"
msgstr "SPI_ERROR_PARAM"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1422(para)
msgid ""
"if <parameter>values</parameter> is <symbol>NULL</symbol> and "
"<parameter>plan</parameter> was prepared with some parameters"
msgstr ""
"Если в <parameter>values</parameter> передан <symbol>NULL</symbol> и "
"<parameter>plan</parameter> был подготовлен с другими параметрами"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1404(para)
msgid ""
"The return value is the same as for <function>SPI_execute</function>, with "
"the following additional possible error (negative) results: <placeholder-1/>"
msgstr ""
"Возвращаемые значения те же, что и у <function>SPI_execute</function>, со "
"следующими дополнительными вариантами ошибок (отрицательных результатов): "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1442(indexterm)
msgid "<primary>SPI_execute_plan_with_paramlist</primary>"
msgstr "<primary>SPI_execute_plan_with_paramlist</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1445(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute_plan_with_paramlist"
msgstr "SPI_execute_plan_with_paramlist"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1450(refname)
msgctxt "refname"
msgid "SPI_execute_plan_with_paramlist"
msgstr "SPI_execute_plan_with_paramlist"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1457(parameter) spi.xml:1492(parameter) spi.xml:1934(parameter)
#: spi.xml:1984(parameter)
msgid "params"
msgstr "params"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1455(synopsis)
#, no-wrap
msgid ""
"int SPI_execute_plan_with_paramlist(SPIPlanPtr <placeholder-1/>,\n"
"                                    ParamListInfo <placeholder-2/>,\n"
"                                    bool <placeholder-3/>,\n"
"                                    long <placeholder-4/>)"
msgstr ""
"int SPI_execute_plan_with_paramlist(SPIPlanPtr <placeholder-1/>,\n"
"                                    ParamListInfo <placeholder-2/>,\n"
"                                    bool <placeholder-3/>,\n"
"                                    long <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1466(para)
msgid ""
"<function>SPI_execute_plan_with_paramlist</function> executes a statement "
"prepared by <function>SPI_prepare</function>. This function is equivalent to "
"<function>SPI_execute_plan</function> except that information about the "
"parameter values to be passed to the query is presented differently. The "
"<literal>ParamListInfo</literal> representation can be convenient for "
"passing down values that are already available in that format. It also "
"supports use of dynamic parameter sets via hook functions specified in "
"<literal>ParamListInfo</literal>."
msgstr ""
"<function>SPI_execute_plan_with_paramlist</function> выполняет оператор, "
"подготовленный функцией <function>SPI_prepare</function>. Данная функция "
"равнозначна <function>SPI_execute_plan</function>, не считая того, что "
"информация о значениях параметров, передаваемых запросу, представляется по-"
"другому. Представление <literal>ParamListInfo</literal> может быть удобным "
"для передачи значений, уже имеющих нужный формат. Эта функция также "
"поддерживает динамические наборы параметров, которые реализуются через "
"функции-обработчики, устанавливаемые в <literal>ParamListInfo</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1492(literal) spi.xml:1984(literal)
msgid "ParamListInfo <placeholder-1/>"
msgstr "ParamListInfo <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1494(para) spi.xml:1986(para)
msgid "data structure containing parameter types and values; NULL if none"
msgstr ""
"структура данных, содержащая типы и значения параметров; NULL, если их нет"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1522(para)
msgid ""
"The return value is the same as for <function>SPI_execute_plan</function>."
msgstr ""
"Возвращаемые значения те же, что и у <function>SPI_execute_plan</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1526(para)
msgid ""
"<varname>SPI_processed</varname> and <varname>SPI_tuptable</varname> are set "
"as in <function>SPI_execute_plan</function> if successful."
msgstr ""
"Переменные <varname>SPI_processed</varname> и <varname>SPI_tuptable</"
"varname> устанавливаются как в <function>SPI_execute_plan</function>, если "
"вызов был успешным."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1537(indexterm)
msgid "<primary>SPI_execp</primary>"
msgstr "<primary>SPI_execp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1540(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execp"
msgstr "SPI_execp"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1545(refname)
msgctxt "refname"
msgid "SPI_execp"
msgstr "SPI_execp"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1546(refpurpose)
msgid "execute a statement in read/write mode"
msgstr "выполнить оператор в режиме чтения/записи"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1550(synopsis)
#, no-wrap
msgid "int SPI_execp(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>, long <placeholder-4/>)"
msgstr "int SPI_execp(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>, long <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1558(para)
msgid ""
"<function>SPI_execp</function> is the same as <function>SPI_execute_plan</"
"function>, with the latter's <parameter>read_only</parameter> parameter "
"always taken as <literal>false</literal>."
msgstr ""
"<function>SPI_execp</function> действует подобно <function>SPI_execute_plan</"
"function>, но ей не передаётся параметр <parameter>read_only</parameter> "
"(всегда подразумевается <literal>false</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1597(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_execp</function> assumes that no parameters are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_execp</function> считает, что ни один из параметров не равен "
"NULL. В противном случае элемент массива <parameter>nulls</parameter> должен "
"содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль (<literal>'\\0'</literal>) в конце не нужен."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1626(para)
msgid "See <function>SPI_execute_plan</function>."
msgstr "См. <function>SPI_execute_plan</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1641(indexterm)
msgid "<primary>SPI_cursor_open</primary>"
msgstr "<primary>SPI_cursor_open</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1644(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_open"
msgstr "SPI_cursor_open"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1649(refname)
msgctxt "refname"
msgid "SPI_cursor_open"
msgstr "SPI_cursor_open"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1650(refpurpose)
msgid "set up a cursor using a statement created with <placeholder-1/>"
msgstr "открыть курсор для оператора, созданного функцией <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1655(parameter) spi.xml:1693(parameter) spi.xml:1779(parameter)
#: spi.xml:1818(parameter) spi.xml:1932(parameter) spi.xml:1965(parameter)
#: spi.xml:2028(parameter) spi.xml:2047(parameter) spi.xml:2772(parameter)
#: spi.xml:2790(parameter)
msgid "name"
msgstr "name"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1654(synopsis)
#, no-wrap
msgid ""
"Portal SPI_cursor_open(const char * <placeholder-1/>, SPIPlanPtr <placeholder-2/>,\n"
"                       Datum * <placeholder-3/>, const char * <placeholder-4/>,\n"
"                       bool <placeholder-5/>)"
msgstr ""
"Portal SPI_cursor_open(const char * <placeholder-1/>, SPIPlanPtr <placeholder-2/>,\n"
"                       Datum * <placeholder-3/>, const char * <placeholder-4/>,\n"
"                       bool <placeholder-5/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1664(para)
msgid ""
"<function>SPI_cursor_open</function> sets up a cursor (internally, a portal) "
"that will execute a statement prepared by <function>SPI_prepare</function>. "
"The parameters have the same meanings as the corresponding parameters to "
"<function>SPI_execute_plan</function>."
msgstr ""
"<function>SPI_cursor_open</function> открывает курсор (внутри называемый "
"порталом), через который будет выполняться оператор, подготовленный функцией "
"<function>SPI_prepare</function>. Параметры этой функции имеют тот же смысл, "
"что и соответствующие параметры <function>SPI_execute_plan</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1672(para)
msgid ""
"Using a cursor instead of executing the statement directly has two benefits. "
"First, the result rows can be retrieved a few at a time, avoiding memory "
"overrun for queries that return many rows. Second, a portal can outlive the "
"current procedure (it can, in fact, live to the end of the current "
"transaction). Returning the portal name to the procedure's caller provides a "
"way of returning a row set as result."
msgstr ""
"Применение курсора по сравнению с непосредственным выполнением оператора "
"даёт двойную выгоду. Во-первых, строки результата можно получать в небольших "
"количествах, без риска исчерпать всю память при выполнении запросов, "
"возвращающих много строк. Во-вторых, портал может существовать и после "
"завершения текущей процедуры (на самом деле, он может просуществовать до "
"конца текущей транзакции). Возвратив имя портала в код, вызывающий "
"процедуру, можно организовать выдачу результата в виде набора строк."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1682(para) spi.xml:1807(para) spi.xml:1954(para)
msgid ""
"The passed-in parameter data will be copied into the cursor's portal, so it "
"can be freed while the cursor still exists."
msgstr ""
"Переданные значения параметров копируются в портал курсора, так что их можно "
"освободить и во время существования курсора."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1695(para) spi.xml:1820(para) spi.xml:1967(para)
msgid ""
"name for portal, or <symbol>NULL</symbol> to let the system select a name"
msgstr "имя портала, либо <symbol>NULL</symbol>, чтобы имя выбрала система"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1729(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_cursor_open</function> assumes that no parameters are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_cursor_open</function> считает, что ни один из параметров не "
"равен NULL. В противном случае элемент массива <parameter>nulls</parameter> "
"должен содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль (<literal>'\\0'</literal>) в конце не нужен."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1755(para) spi.xml:1908(para) spi.xml:2004(para)
msgid ""
"Pointer to portal containing the cursor. Note there is no error return "
"convention; any error will be reported via <function>elog</function>."
msgstr ""
"Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате "
"ошибок отсутствует; все ошибки выдаются через <function>elog</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1765(indexterm)
msgid "<primary>SPI_cursor_open_with_args</primary>"
msgstr "<primary>SPI_cursor_open_with_args</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1768(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_open_with_args"
msgstr "SPI_cursor_open_with_args"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1773(refname)
msgctxt "refname"
msgid "SPI_cursor_open_with_args"
msgstr "SPI_cursor_open_with_args"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1774(refpurpose)
msgid "set up a cursor using a query and parameters"
msgstr "открывает курсор для запроса с параметрами"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1778(synopsis)
#, no-wrap
msgid ""
"Portal SPI_cursor_open_with_args(const char *<placeholder-1/>,\n"
"                                 const char *<placeholder-2/>,\n"
"                                 int <placeholder-3/>, Oid *<placeholder-4/>,\n"
"                                 Datum *<placeholder-5/>, const char *<placeholder-6/>,\n"
"                                 bool <placeholder-7/>, int <placeholder-8/>)"
msgstr ""
"Portal SPI_cursor_open_with_args(const char *<placeholder-1/>,\n"
"                                 const char *<placeholder-2/>,\n"
"                                 int <placeholder-3/>, Oid *<placeholder-4/>,\n"
"                                 Datum *<placeholder-5/>, const char *<placeholder-6/>,\n"
"                                 bool <placeholder-7/>, int <placeholder-8/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1790(para)
msgid ""
"<function>SPI_cursor_open_with_args</function> sets up a cursor (internally, "
"a portal) that will execute the specified query. Most of the parameters have "
"the same meanings as the corresponding parameters to "
"<function>SPI_prepare_cursor</function> and <function>SPI_cursor_open</"
"function>."
msgstr ""
"<function>SPI_cursor_open_with_args</function> открывает курсор (внутри "
"называемый порталом) для выполнения заданного запроса. Большинство "
"параметров имеют тот же смысл, что и соответствующие параметры функций "
"<function>SPI_prepare_cursor</function> и <function>SPI_cursor_open</"
"function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1798(para)
msgid ""
"For one-time query execution, this function should be preferred over "
"<function>SPI_prepare_cursor</function> followed by "
"<function>SPI_cursor_open</function>. If the same command is to be executed "
"with many different parameters, either method might be faster, depending on "
"the cost of re-planning versus the benefit of custom plans."
msgstr ""
"Для разового выполнения запроса эту функцию следует предпочесть "
"<function>SPI_prepare_cursor</function> с последующей "
"<function>SPI_cursor_open</function>. Если же одна и та же команда должна "
"выполняться с самыми разными параметрами, какой вариант окажется быстрее, "
"будет зависеть от стоимости повторного планирования и выигрыша от выбора "
"специализированных планов."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1873(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_cursor_open_with_args</function> assumes that no parameters "
"are null. Otherwise, each entry of the <parameter>nulls</parameter> array "
"should be <literal>'&nbsp;'</literal> if the corresponding parameter value "
"is non-null, or <literal>'n'</literal> if the corresponding parameter value "
"is null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_cursor_open_with_args</function> считает, что ни один из "
"параметров не равен NULL. В противном случае, элемент массива "
"<parameter>nulls</parameter> должен содержать <literal>'&nbsp;'</literal>, "
"если значение соответствующего параметра не NULL, либо <literal>'n'</"
"literal>, если это значение — NULL. (В последнем случае значение, переданное "
"в соответствующем элементе <parameter>values</parameter>, не учитывается.) "
"Заметьте, что <parameter>nulls</parameter> — это не текстовая строка, а "
"просто массив: ноль (<literal>'\\0'</literal>) в конце не нужен."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1918(indexterm)
msgid "<primary>SPI_cursor_open_with_paramlist</primary>"
msgstr "<primary>SPI_cursor_open_with_paramlist</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1921(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_open_with_paramlist"
msgstr "SPI_cursor_open_with_paramlist"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1926(refname)
msgctxt "refname"
msgid "SPI_cursor_open_with_paramlist"
msgstr "SPI_cursor_open_with_paramlist"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1927(refpurpose)
msgid "set up a cursor using parameters"
msgstr "открыть курсор с параметрами"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1931(synopsis)
#, no-wrap
msgid ""
"Portal SPI_cursor_open_with_paramlist(const char *<placeholder-1/>,\n"
"                                      SPIPlanPtr <placeholder-2/>,\n"
"                                      ParamListInfo <placeholder-3/>,\n"
"                                      bool <placeholder-4/>)"
msgstr ""
"Portal SPI_cursor_open_with_paramlist(const char *<placeholder-1/>,\n"
"                                      SPIPlanPtr <placeholder-2/>,\n"
"                                      ParamListInfo <placeholder-3/>,\n"
"                                      bool <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:1942(para)
msgid ""
"<function>SPI_cursor_open_with_paramlist</function> sets up a cursor "
"(internally, a portal) that will execute a statement prepared by "
"<function>SPI_prepare</function>. This function is equivalent to "
"<function>SPI_cursor_open</function> except that information about the "
"parameter values to be passed to the query is presented differently. The "
"<literal>ParamListInfo</literal> representation can be convenient for "
"passing down values that are already available in that format. It also "
"supports use of dynamic parameter sets via hook functions specified in "
"<literal>ParamListInfo</literal>."
msgstr ""
"<function>SPI_cursor_open_with_paramlist</function> открывает курсор (внутри "
"называемый порталом) для выполнения оператора, подготовленного функцией "
"<function>SPI_prepare</function>. Эта функция равнозначна "
"<function>SPI_cursor_open</function>, не считая того, что информация о "
"значениях параметров, передаваемых запросу, представляется по-другому. "
"Представление <literal>ParamListInfo</literal> может быть удобным для "
"передачи значений, уже имеющих нужный формат. Эта функция также поддерживает "
"динамические наборы параметров через функции-обработчики, устанавливаемые в "
"<literal>ParamListInfo</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2014(indexterm)
msgid "<primary>SPI_cursor_find</primary>"
msgstr "<primary>SPI_cursor_find</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2017(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_find"
msgstr "SPI_cursor_find"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2022(refname)
msgctxt "refname"
msgid "SPI_cursor_find"
msgstr "SPI_cursor_find"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2023(refpurpose)
msgid "find an existing cursor by name"
msgstr "найти существующий курсор по имени"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2027(synopsis)
#, no-wrap
msgid "Portal SPI_cursor_find(const char * <placeholder-1/>)"
msgstr "Portal SPI_cursor_find(const char * <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2035(para)
msgid ""
"<function>SPI_cursor_find</function> finds an existing portal by name. This "
"is primarily useful to resolve a cursor name returned as text by some other "
"function."
msgstr ""
"<function>SPI_cursor_find</function> находит существующий портал по имени. В "
"основном это полезно для разрешения имени курсора, возвращённого в текстовом "
"виде какой-то другой функцией."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2049(para)
msgid "name of the portal"
msgstr "имя портала"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2060(para)
msgid ""
"pointer to the portal with the specified name, or <symbol>NULL</symbol> if "
"none was found"
msgstr ""
"указатель на портал с заданным именем или <symbol>NULL</symbol>, если такой "
"портал не найден"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2070(indexterm)
msgid "<primary>SPI_cursor_fetch</primary>"
msgstr "<primary>SPI_cursor_fetch</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2073(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_fetch"
msgstr "SPI_cursor_fetch"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2078(refname)
msgctxt "refname"
msgid "SPI_cursor_fetch"
msgstr "SPI_cursor_fetch"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2079(refpurpose) spi.xml:2239(refpurpose)
msgid "fetch some rows from a cursor"
msgstr "выбрать строки через курсор"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2084(parameter) spi.xml:2104(parameter) spi.xml:2169(parameter)
#: spi.xml:2189(parameter) spi.xml:2244(parameter) spi.xml:2263(parameter)
#: spi.xml:2343(parameter) spi.xml:2363(parameter) spi.xml:2444(parameter)
#: spi.xml:2468(parameter)
msgid "portal"
msgstr "portal"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2084(parameter) spi.xml:2113(parameter) spi.xml:2169(parameter)
#: spi.xml:2198(parameter)
msgid "forward"
msgstr "forward"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2083(synopsis)
#, no-wrap
msgid "void SPI_cursor_fetch(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"
msgstr "void SPI_cursor_fetch(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2091(para)
msgid ""
"<function>SPI_cursor_fetch</function> fetches some rows from a cursor. This "
"is equivalent to a subset of the SQL command <command>FETCH</command> (see "
"<function>SPI_scroll_cursor_fetch</function> for more functionality)."
msgstr ""
"<function>SPI_cursor_fetch</function> выбирает некоторое количество строк "
"через курсор. Эта функция реализует подмножество возможностей SQL-команды "
"<command>FETCH</command> (расширенную функциональность предоставляет "
"<function>SPI_scroll_cursor_fetch</function>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2104(literal) spi.xml:2189(literal) spi.xml:2263(literal)
#: spi.xml:2363(literal) spi.xml:2468(literal)
msgid "Portal <placeholder-1/>"
msgstr "Portal <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2106(para) spi.xml:2191(para) spi.xml:2265(para) spi.xml:2365(para)
#: spi.xml:2470(para)
msgid "portal containing the cursor"
msgstr "портал, содержащий курсор"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2115(para)
msgid "true for fetch forward, false for fetch backward"
msgstr "true для выборки с перемещением вперёд, false — назад"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2124(para)
msgid "maximum number of rows to fetch"
msgstr "максимальное число строк, которое нужно выбрать"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2145(para)
msgid ""
"Fetching backward may fail if the cursor's plan was not created with the "
"<symbol>CURSOR_OPT_SCROLL</symbol> option."
msgstr ""
"Выборка назад может не поддерживаться, если план курсора был создан без "
"параметра <symbol>CURSOR_OPT_SCROLL</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2155(indexterm)
msgid "<primary>SPI_cursor_move</primary>"
msgstr "<primary>SPI_cursor_move</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2158(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_move"
msgstr "SPI_cursor_move"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2163(refname)
msgctxt "refname"
msgid "SPI_cursor_move"
msgstr "SPI_cursor_move"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2164(refpurpose) spi.xml:2338(refpurpose)
msgid "move a cursor"
msgstr "переместить курсор"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2168(synopsis)
#, no-wrap
msgid "void SPI_cursor_move(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"
msgstr "void SPI_cursor_move(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2176(para)
msgid ""
"<function>SPI_cursor_move</function> skips over some number of rows in a "
"cursor. This is equivalent to a subset of the SQL command <command>MOVE</"
"command> (see <function>SPI_scroll_cursor_move</function> for more "
"functionality)."
msgstr ""
"<function>SPI_cursor_move</function> перемещает курсор на несколько строк. "
"Эта функция реализует подмножество возможностей SQL-команды <command>MOVE</"
"command> (расширенную функциональность предоставляет "
"<function>SPI_scroll_cursor_move</function>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2200(para)
msgid "true for move forward, false for move backward"
msgstr "true для перемещения вперёд, false — назад"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2209(para)
msgid "maximum number of rows to move"
msgstr "максимальное число строк, на какое возможно перемещение"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2220(para)
msgid ""
"Moving backward may fail if the cursor's plan was not created with the "
"<symbol>CURSOR_OPT_SCROLL</symbol> option."
msgstr ""
"Перемещение назад может не поддерживаться, если план курсора был создан без "
"параметра <symbol>CURSOR_OPT_SCROLL</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2230(indexterm)
msgid "<primary>SPI_scroll_cursor_fetch</primary>"
msgstr "<primary>SPI_scroll_cursor_fetch</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2233(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_scroll_cursor_fetch"
msgstr "SPI_scroll_cursor_fetch"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2238(refname)
msgctxt "refname"
msgid "SPI_scroll_cursor_fetch"
msgstr "SPI_scroll_cursor_fetch"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2244(parameter) spi.xml:2272(parameter) spi.xml:2343(parameter)
#: spi.xml:2372(parameter)
msgid "direction"
msgstr "direction"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2243(synopsis)
#, no-wrap
msgid ""
"void SPI_scroll_cursor_fetch(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                             long <placeholder-3/>)"
msgstr ""
"void SPI_scroll_cursor_fetch(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                             long <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2252(para)
msgid ""
"<function>SPI_scroll_cursor_fetch</function> fetches some rows from a "
"cursor. This is equivalent to the SQL command <command>FETCH</command>."
msgstr ""
"<function>SPI_scroll_cursor_fetch</function> выбирает некоторое количество "
"строк через курсор. Её функциональность равнозначна <command>FETCH</command> "
"в SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2272(literal) spi.xml:2372(literal)
msgid "FetchDirection <placeholder-1/>"
msgstr "FetchDirection <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2274(para) spi.xml:2374(para)
msgid ""
"one of <symbol>FETCH_FORWARD</symbol>, <symbol>FETCH_BACKWARD</symbol>, "
"<symbol>FETCH_ABSOLUTE</symbol> or <symbol>FETCH_RELATIVE</symbol>"
msgstr ""
"один из вариантов: <symbol>FETCH_FORWARD</symbol>, <symbol>FETCH_BACKWARD</"
"symbol>, <symbol>FETCH_ABSOLUTE</symbol> или <symbol>FETCH_RELATIVE</symbol>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2286(para)
msgid ""
"number of rows to fetch for <symbol>FETCH_FORWARD</symbol> or "
"<symbol>FETCH_BACKWARD</symbol>; absolute row number to fetch for "
"<symbol>FETCH_ABSOLUTE</symbol>; or relative row number to fetch for "
"<symbol>FETCH_RELATIVE</symbol>"
msgstr ""
"число строк, выбираемых с направлением <symbol>FETCH_FORWARD</symbol> или "
"<symbol>FETCH_BACKWARD</symbol>; абсолютный номер выбираемой строки с "
"вариантом <symbol>FETCH_ABSOLUTE</symbol>; либо относительный номер "
"выбираемой строки с вариантом <symbol>FETCH_RELATIVE</symbol>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2311(para) spi.xml:2412(para)
msgid ""
"See the SQL <xref linkend=\"sql-fetch\"/> command for details of the "
"interpretation of the <parameter>direction</parameter> and <parameter>count</"
"parameter> parameters."
msgstr ""
"Подробнее о параметрах <parameter>direction</parameter> и <parameter>count</"
"parameter> рассказывается в описании SQL-команды <xref linkend=\"sql-fetch\"/"
">."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2318(para) spi.xml:2419(para)
msgid ""
"Direction values other than <symbol>FETCH_FORWARD</symbol> may fail if the "
"cursor's plan was not created with the <symbol>CURSOR_OPT_SCROLL</symbol> "
"option."
msgstr ""
"Варианты направления, отличные от <symbol>FETCH_FORWARD</symbol>, могут не "
"поддерживаться, если план курсора был создан без параметра "
"<symbol>CURSOR_OPT_SCROLL</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2329(indexterm)
msgid "<primary>SPI_scroll_cursor_move</primary>"
msgstr "<primary>SPI_scroll_cursor_move</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2332(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_scroll_cursor_move"
msgstr "SPI_scroll_cursor_move"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2337(refname)
msgctxt "refname"
msgid "SPI_scroll_cursor_move"
msgstr "SPI_scroll_cursor_move"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2342(synopsis)
#, no-wrap
msgid ""
"void SPI_scroll_cursor_move(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                            long <placeholder-3/>)"
msgstr ""
"void SPI_scroll_cursor_move(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                            long <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2351(para)
msgid ""
"<function>SPI_scroll_cursor_move</function> skips over some number of rows "
"in a cursor. This is equivalent to the SQL command <command>MOVE</command>."
msgstr ""
"<function>SPI_scroll_cursor_move</function> перемещает курсор на несколько "
"строк. Её функциональность равнозначна <command>MOVE</command> в SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2386(para)
msgid ""
"number of rows to move for <symbol>FETCH_FORWARD</symbol> or "
"<symbol>FETCH_BACKWARD</symbol>; absolute row number to move to for "
"<symbol>FETCH_ABSOLUTE</symbol>; or relative row number to move to for "
"<symbol>FETCH_RELATIVE</symbol>"
msgstr ""
"число строк, на которое сдвигается курсор, с направлением "
"<symbol>FETCH_FORWARD</symbol> или <symbol>FETCH_BACKWARD</symbol>; "
"абсолютный номер строки, к которой переходит курсор, с направлением "
"<symbol>FETCH_ABSOLUTE</symbol>; либо относительный номер строки, к которой "
"переходит курсор, с направлением <symbol>FETCH_RELATIVE</symbol>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2401(para)
msgid ""
"<varname>SPI_processed</varname> is set as in <function>SPI_execute</"
"function> if successful. <varname>SPI_tuptable</varname> is set to "
"<symbol>NULL</symbol>, since no rows are returned by this function."
msgstr ""
"В случае успеха переменная <varname>SPI_processed</varname> устанавливается "
"как в <function>SPI_execute</function>. В <varname>SPI_tuptable</varname> "
"оказывается <symbol>NULL</symbol>, так как эта функция не возвращает никакие "
"строки."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2430(indexterm)
msgid "<primary>SPI_cursor_close</primary>"
msgstr "<primary>SPI_cursor_close</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2433(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_close"
msgstr "SPI_cursor_close"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2438(refname)
msgctxt "refname"
msgid "SPI_cursor_close"
msgstr "SPI_cursor_close"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2439(refpurpose)
msgid "close a cursor"
msgstr "закрыть курсор"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2443(synopsis)
#, no-wrap
msgid "void SPI_cursor_close(Portal <placeholder-1/>)"
msgstr "void SPI_cursor_close(Portal <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2451(para)
msgid ""
"<function>SPI_cursor_close</function> closes a previously created cursor and "
"releases its portal storage."
msgstr ""
"<function>SPI_cursor_close</function> закрывает ранее созданный курсор и "
"освобождает память, занятую его порталом."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2456(para)
msgid ""
"All open cursors are closed automatically at the end of a transaction. "
"<function>SPI_cursor_close</function> need only be invoked if it is "
"desirable to release resources sooner."
msgstr ""
"Все открытые курсоры закрываются автоматически в конце транзакции. Вызывать "
"<function>SPI_cursor_close</function> может потребоваться, только если "
"возникает желание освободить ресурсы скорее."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2482(indexterm)
msgid "<primary>SPI_keepplan</primary>"
msgstr "<primary>SPI_keepplan</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2485(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_keepplan"
msgstr "SPI_keepplan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2490(refname)
msgctxt "refname"
msgid "SPI_keepplan"
msgstr "SPI_keepplan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2491(refpurpose) spi.xml:2560(refpurpose)
msgid "save a prepared statement"
msgstr "сохранить подготовленный оператор"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2495(synopsis)
#, no-wrap
msgid "int SPI_keepplan(SPIPlanPtr <placeholder-1/>)"
msgstr "int SPI_keepplan(SPIPlanPtr <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2503(para)
msgid ""
"<function>SPI_keepplan</function> saves a passed statement (prepared by "
"<function>SPI_prepare</function>) so that it will not be freed by "
"<function>SPI_finish</function> nor by the transaction manager. This gives "
"you the ability to reuse prepared statements in the subsequent invocations "
"of your procedure in the current session."
msgstr ""
"<function>SPI_keepplan</function> закрепляет переданный оператор "
"(подготовленный функцией <function>SPI_prepare</function>), чтобы он не был "
"ликвидирован функцией <function>SPI_finish</function> или диспетчером "
"транзакций. Это даёт возможность повторно использовать подготовленные "
"операторы при последующих вызовах вашей процедуры в текущем сеансе."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2519(para) spi.xml:2589(para)
msgid "the prepared statement to be saved"
msgstr "подготовленный оператор, который нужно сохранить"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2530(para) spi.xml:4266(para)
msgid ""
"0 on success; <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</"
"parameter> is <symbol>NULL</symbol> or invalid"
msgstr ""
"0 в случае успеха; <symbol>SPI_ERROR_ARGUMENT</symbol>, если "
"<parameter>plan</parameter> неверный или <symbol>NULL</symbol>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2540(para)
msgid ""
"The passed-in statement is relocated to permanent storage by means of "
"pointer adjustment (no data copying is required). If you later wish to "
"delete it, use <function>SPI_freeplan</function> on it."
msgstr ""
"Переданный оператор перемещается в постоянное хранилище путём смены "
"указателя (копировать данные не требуется). Если позже вы захотите удалить "
"его, выполните для него <function>SPI_freeplan</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2551(indexterm)
msgid "<primary>SPI_saveplan</primary>"
msgstr "<primary>SPI_saveplan</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2554(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_saveplan"
msgstr "SPI_saveplan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2559(refname)
msgctxt "refname"
msgid "SPI_saveplan"
msgstr "SPI_saveplan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2564(synopsis)
#, no-wrap
msgid "SPIPlanPtr SPI_saveplan(SPIPlanPtr <placeholder-1/>)"
msgstr "SPIPlanPtr SPI_saveplan(SPIPlanPtr <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2572(para)
msgid ""
"<function>SPI_saveplan</function> copies a passed statement (prepared by "
"<function>SPI_prepare</function>) into memory that will not be freed by "
"<function>SPI_finish</function> nor by the transaction manager, and returns "
"a pointer to the copied statement. This gives you the ability to reuse "
"prepared statements in the subsequent invocations of your procedure in the "
"current session."
msgstr ""
"<function>SPI_saveplan</function> копирует переданный оператор "
"(подготовленный функцией <function>SPI_prepare</function>) в память, чтобы "
"он не был ликвидирован функцией <function>SPI_finish</function> или "
"менеджером транзакций, и возвращает указатель на скопированный оператор. Это "
"даёт возможность повторно использовать подготовленные операторы при "
"последующих вызовах вашей процедуры в текущем сеансе."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2608(para)
msgid "if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid"
msgstr "если <parameter>plan</parameter> неверный или <symbol>NULL</symbol>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2600(para)
msgid ""
"Pointer to the copied statement; or <symbol>NULL</symbol> if unsuccessful. "
"On error, <varname>SPI_result</varname> is set thus: <placeholder-1/>"
msgstr ""
"Указатель на скопированный оператор, либо <symbol>NULL</symbol> в случае "
"ошибки. При ошибке <varname>SPI_result</varname> принимает одно из этих "
"значений: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2629(para)
msgid ""
"The originally passed-in statement is not freed, so you might wish to do "
"<function>SPI_freeplan</function> on it to avoid leaking memory until "
"<function>SPI_finish</function>."
msgstr ""
"Изначально переданный оператор не освобождается, поэтому вы можете выполнить "
"<function>SPI_freeplan</function> для него, чтобы высвободить память до "
"<function>SPI_finish</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2635(para)
msgid ""
"In most cases, <function>SPI_keepplan</function> is preferred to this "
"function, since it accomplishes largely the same result without needing to "
"physically copy the prepared statement's data structures."
msgstr ""
"В большинстве случаев <function>SPI_keepplan</function> предпочтительнее "
"данной функции, так как она даёт примерно тот же результат, но обходится без "
"физического копирования структур данных подготовленного оператора."

#. +> REL_10
#: spi.xml:2646(indexterm)
msgid "<primary>SPI_register_relation</primary>"
msgstr "<primary>SPI_register_relation</primary>"

#. +> REL_10
#: spi.xml:2648(indexterm) spi.xml:2860(indexterm)
msgid ""
"<primary>ephemeral named relation</primary> <secondary>registering with SPI</"
"secondary>"
msgstr ""
"<primary>эфемерное именованное отношение</primary> <secondary>регистрация в "
"SPI</secondary>"

#. +> REL_10
#: spi.xml:2654(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_register_relation"
msgstr "SPI_register_relation"

#. +> REL_10
#: spi.xml:2659(refname)
msgctxt "refname"
msgid "SPI_register_relation"
msgstr "SPI_register_relation"

#. +> REL_10
#: spi.xml:2660(refpurpose)
msgid "make a ephemeral named relation available by name in SPI queries"
msgstr ""
"сделать эфемерное именованное отношение доступным по имени в запросах SPI"

#. +> REL_10
#: spi.xml:2665(parameter) spi.xml:2684(parameter)
msgid "enr"
msgstr "enr"

#. +> REL_10
#: spi.xml:2664(synopsis)
#, no-wrap
msgid "int SPI_register_relation(EphemeralNamedRelation <placeholder-1/>)"
msgstr "int SPI_register_relation(EphemeralNamedRelation <placeholder-1/>)"

#. +> REL_10
#: spi.xml:2672(para)
msgid ""
"<function>SPI_register_relation</function> makes an ephemeral named "
"relation, with associated information, available to queries planned and "
"executed through the current SPI connection."
msgstr ""
"<function>SPI_register_relation</function> делает эфемерное именованное "
"отношение (со связанной информацией) доступным в запросах, планируемых и "
"выполняемых через текущее подключение SPI."

#. +> REL_10
#: spi.xml:2684(literal)
msgid "EphemeralNamedRelation <placeholder-1/>"
msgstr "EphemeralNamedRelation <placeholder-1/>"

#. +> REL_10
#: spi.xml:2686(para)
msgid "the ephemeral named relation registry entry"
msgstr "запись эфемерного именованного отношения в реестре"

#. +> REL_10
#: spi.xml:2703(symbol)
msgid "SPI_OK_REL_REGISTER"
msgstr "SPI_OK_REL_REGISTER"

#. +> REL_10
#: spi.xml:2705(para)
msgid "if the relation has been successfully registered by name"
msgstr "если отношение было успешно зарегистрировано по имени"

#. +> REL_10
#: spi.xml:2697(para) spi.xml:2803(para) spi.xml:2918(para)
msgid ""
"If the execution of the command was successful then the following "
"(nonnegative) value will be returned: <placeholder-1/>"
msgstr ""
"Если команда была выполнена успешно, возвращается следующее "
"(неотрицательное) значение: <placeholder-1/>"

#. +> REL_10
#: spi.xml:2720(para)
msgid ""
"if <parameter>enr</parameter> is <symbol>NULL</symbol> or its <varname>name</"
"varname> field is <symbol>NULL</symbol>"
msgstr ""
"если <symbol>NULL</symbol> передан в <parameter>enr</parameter> или в поле "
"<varname>name</varname>"

#. +> REL_10
#: spi.xml:2737(symbol) spi.xml:2957(symbol)
msgid "SPI_ERROR_REL_DUPLICATE"
msgstr "SPI_ERROR_REL_DUPLICATE"

#. +> REL_10
#: spi.xml:2739(para)
msgid ""
"if the name specified in the <varname>name</varname> field of "
"<parameter>enr</parameter> is already registered for this connection"
msgstr ""
"если имя, заданное в поле <varname>name</varname> структуры <parameter>enr</"
"parameter>, уже зарегистрировано для этого отношения"

#. +> REL_10
#: spi.xml:2753(indexterm)
msgid "<primary>SPI_unregister_relation</primary>"
msgstr "<primary>SPI_unregister_relation</primary>"

#. +> REL_10
#: spi.xml:2755(indexterm)
msgid ""
"<primary>ephemeral named relation</primary> <secondary>unregistering from "
"SPI</secondary>"
msgstr ""
"<primary>эфемерное именованное отношение</primary> <secondary>разрегистрация "
"в SPI</secondary>"

#. +> REL_10
#: spi.xml:2761(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_unregister_relation"
msgstr "SPI_unregister_relation"

#. +> REL_10
#: spi.xml:2766(refname)
msgctxt "refname"
msgid "SPI_unregister_relation"
msgstr "SPI_unregister_relation"

#. +> REL_10
#: spi.xml:2767(refpurpose)
msgid "remove an ephemeral named relation from the registry"
msgstr "удалить эфемерное именованное отношение из реестра"

#. +> REL_10
#: spi.xml:2771(synopsis)
#, no-wrap
msgid "int SPI_unregister_relation(const char * <placeholder-1/>)"
msgstr "int SPI_unregister_relation(const char * <placeholder-1/>)"

#. +> REL_10
#: spi.xml:2779(para)
msgid ""
"<function>SPI_unregister_relation</function> removes an ephemeral named "
"relation from the registry for the current connection."
msgstr ""
"<function>SPI_unregister_relation</function> удаляет эфемерное именованное "
"отношение из реестра для текущего подключения."

#. +> REL_10
#: spi.xml:2792(para)
msgid "the relation registry entry name"
msgstr "имя записи отношения в реестре"

#. +> REL_10
#: spi.xml:2809(symbol)
msgid "SPI_OK_REL_UNREGISTER"
msgstr "SPI_OK_REL_UNREGISTER"

#. +> REL_10
#: spi.xml:2811(para)
msgid "if the tuplestore has been successfully removed from the registry"
msgstr "если совокупность кортежей была успешно удалена из реестра"

#. +> REL_10
#: spi.xml:2826(para)
msgid "if <parameter>name</parameter> is <symbol>NULL</symbol>"
msgstr "если в <parameter>name</parameter> передан <symbol>NULL</symbol>"

#. +> REL_10
#: spi.xml:2842(symbol)
msgid "SPI_ERROR_REL_NOT_FOUND"
msgstr "SPI_ERROR_REL_NOT_FOUND"

#. +> REL_10
#: spi.xml:2844(para)
msgid ""
"if <parameter>name</parameter> is not found in the registry for the current "
"connection"
msgstr ""
"если <parameter>name</parameter> не находится в реестре для текущего "
"подключения"

#. +> REL_10
#: spi.xml:2858(indexterm)
msgid "<primary>SPI_register_trigger_data</primary>"
msgstr "<primary>SPI_register_trigger_data</primary>"

#. +> REL_10
#: spi.xml:2865(indexterm)
msgid ""
"<primary>transition tables</primary> <secondary>implementation in PLs</"
"secondary>"
msgstr ""
"<primary>переходные таблицы</primary> <secondary>реализация на языках "
"программирования</secondary>"

#. +> REL_10
#: spi.xml:2871(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_register_trigger_data"
msgstr "SPI_register_trigger_data"

#. +> REL_10
#: spi.xml:2876(refname)
msgctxt "refname"
msgid "SPI_register_trigger_data"
msgstr "SPI_register_trigger_data"

#. +> REL_10
#: spi.xml:2877(refpurpose)
msgid "make ephemeral trigger data available in SPI queries"
msgstr "сделать эфемерные данные триггера доступными в запросах SPI"

#. +> REL_10
#: spi.xml:2882(parameter) spi.xml:2904(parameter)
msgid "tdata"
msgstr "tdata"

#. +> REL_10
#: spi.xml:2881(synopsis)
#, no-wrap
msgid "int SPI_register_trigger_data(TriggerData *<placeholder-1/>)"
msgstr "int SPI_register_trigger_data(TriggerData *<placeholder-1/>)"

#. +> REL_10
#: spi.xml:2889(para)
msgid ""
"<function>SPI_register_trigger_data</function> makes any ephemeral relations "
"captured by a trigger available to queries planned and executed through the "
"current SPI connection. Currently, this means the transition tables captured "
"by an <literal>AFTER</literal> trigger defined with a <literal>REFERENCING "
"OLD/NEW TABLE AS</literal> ... clause. This function should be called by a "
"PL trigger handler function after connecting."
msgstr ""
"<function>SPI_register_trigger_data</function> делает эфемерные отношения, "
"которые перехватывает триггер, доступными для запросов, планируемых и "
"выполняемых через текущее подключение SPI. В настоящее время это переходные "
"таблицы, перехватываемые триггером <literal>AFTER</literal>, определённым с "
"предложением <literal>REFERENCING OLD/NEW TABLE AS</literal>. Эта функция "
"должна вызываться функцией, реализующей триггер на языке программирования, "
"после подключения."

#. +> REL_10
#: spi.xml:2904(literal)
msgid "TriggerData *<placeholder-1/>"
msgstr "TriggerData *<placeholder-1/>"

#. +> REL_10
#: spi.xml:2906(para)
msgid ""
"the <structname>TriggerData</structname> object passed to a trigger handler "
"function as <literal>fcinfo-&gt;context</literal>"
msgstr ""
"объект <structname>TriggerData</structname>, передаваемый функцией, "
"реализующей триггер, через <literal>fcinfo-&gt;context</literal>"

#. +> REL_10
#: spi.xml:2924(symbol)
msgid "SPI_OK_TD_REGISTER"
msgstr "SPI_OK_TD_REGISTER"

#. +> REL_10
#: spi.xml:2926(para)
msgid "if the captured trigger data (if any) has been successfully registered"
msgstr ""
"если перехваченные данные триггера (при наличии) были успешно "
"зарегистрированы"

#. +> REL_10
#: spi.xml:2941(para)
msgid "if <parameter>tdata</parameter> is <symbol>NULL</symbol>"
msgstr "если в <parameter>tdata</parameter> передан <symbol>NULL</symbol>"

#. +> REL_10
#: spi.xml:2959(para)
msgid ""
"if the name of any trigger data transient relation is already registered for "
"this connection"
msgstr ""
"если имя в любом из переходных отношений в данных триггера уже "
"зарегистрировано для этого подключения"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2975(title)
msgid "Interface Support Functions"
msgstr "Вспомогательные интерфейсные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2977(para)
msgid ""
"The functions described here provide an interface for extracting information "
"from result sets returned by <function>SPI_execute</function> and other SPI "
"functions."
msgstr ""
"Функции, описанные здесь, предоставляют возможности для извлечения "
"информации из наборов результатов, возвращаемых <function>SPI_execute</"
"function> и другими функциями SPI."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2983(para)
msgid ""
"All functions described in this section can be used by both connected and "
"unconnected procedures."
msgstr ""
"Все функции, описанные в этом разделе, могут использоваться и в "
"подключённых, и в неподключённых процедурах."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2991(indexterm)
msgid "<primary>SPI_fname</primary>"
msgstr "<primary>SPI_fname</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2994(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_fname"
msgstr "SPI_fname"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:2999(refname)
msgctxt "refname"
msgid "SPI_fname"
msgstr "SPI_fname"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3000(refpurpose)
msgid "determine the column name for the specified column number"
msgstr "определить имя столбца с заданным номером"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3005(parameter) spi.xml:3024(parameter) spi.xml:3072(parameter)
#: spi.xml:3099(parameter) spi.xml:3146(parameter) spi.xml:3180(parameter)
#: spi.xml:3230(parameter) spi.xml:3264(parameter) spi.xml:3325(parameter)
#: spi.xml:3344(parameter) spi.xml:3391(parameter) spi.xml:3409(parameter)
#: spi.xml:3871(parameter) spi.xml:3912(parameter)
msgid "rowdesc"
msgstr "rowdesc"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3005(parameter) spi.xml:3033(parameter) spi.xml:3146(parameter)
#: spi.xml:3189(parameter) spi.xml:3230(parameter) spi.xml:3273(parameter)
#: spi.xml:3325(parameter) spi.xml:3353(parameter) spi.xml:3391(parameter)
#: spi.xml:3418(parameter)
msgid "colnumber"
msgstr "colnumber"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3004(synopsis)
#, no-wrap
msgid "char * SPI_fname(TupleDesc <placeholder-1/>, int <placeholder-2/>)"
msgstr "char * SPI_fname(TupleDesc <placeholder-1/>, int <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3012(para)
msgid ""
"<function>SPI_fname</function> returns a copy of the column name of the "
"specified column. (You can use <function>pfree</function> to release the "
"copy of the name when you don't need it anymore.)"
msgstr ""
"<function>SPI_fname</function> возвращает копию имени столбца с заданным "
"номером. (Когда эта копия имени будет не нужна, её можно освободить с "
"помощью <function>pfree</function>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3024(literal) spi.xml:3099(literal) spi.xml:3180(literal)
#: spi.xml:3264(literal) spi.xml:3344(literal) spi.xml:3409(literal)
#: spi.xml:3912(literal)
msgid "TupleDesc <placeholder-1/>"
msgstr "TupleDesc <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3026(para) spi.xml:3101(para) spi.xml:3182(para) spi.xml:3266(para)
#: spi.xml:3346(para) spi.xml:3411(para)
msgid "input row description"
msgstr "описание строк"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3035(para) spi.xml:3191(para) spi.xml:3275(para) spi.xml:3355(para)
#: spi.xml:3420(para)
msgid "column number (count starts at 1)"
msgstr "номер столбца (начиная с 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3046(para)
msgid ""
"The column name; <symbol>NULL</symbol> if <parameter>colnumber</parameter> "
"is out of range. <varname>SPI_result</varname> set to "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error."
msgstr ""
"Имя столбца; <symbol>NULL</symbol>, если <parameter>colnumber</parameter> "
"вне допустимого диапазона. В случае ошибки в <varname>SPI_result</varname> "
"устанавливается <symbol>SPI_ERROR_NOATTRIBUTE</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3058(indexterm)
msgid "<primary>SPI_fnumber</primary>"
msgstr "<primary>SPI_fnumber</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3061(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_fnumber"
msgstr "SPI_fnumber"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3066(refname)
msgctxt "refname"
msgid "SPI_fnumber"
msgstr "SPI_fnumber"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3067(refpurpose)
msgid "determine the column number for the specified column name"
msgstr "определить номер столбца с заданным именем"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3072(parameter) spi.xml:3108(parameter)
msgid "colname"
msgstr "colname"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3071(synopsis)
#, no-wrap
msgid "int SPI_fnumber(TupleDesc <placeholder-1/>, const char * <placeholder-2/>)"
msgstr "int SPI_fnumber(TupleDesc <placeholder-1/>, const char * <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3079(para)
msgid ""
"<function>SPI_fnumber</function> returns the column number for the column "
"with the specified name."
msgstr ""
"<function>SPI_fnumber</function> возвращает номер столбца, имеющего заданное "
"имя."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3084(para)
msgid ""
"If <parameter>colname</parameter> refers to a system column (e.g., "
"<literal>oid</literal>) then the appropriate negative column number will be "
"returned. The caller should be careful to test the return value for exact "
"equality to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> to detect an error; "
"testing the result for less than or equal to 0 is not correct unless system "
"columns should be rejected."
msgstr ""
"Если <parameter>colname</parameter> ссылается на системный столбец "
"(например, <literal>oid</literal>), возвращается соответствующий "
"отрицательный номер столбца. Вызывающий должен проверять, не была ли "
"возвращена ошибка, сравнивая значение результата именно с "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>; проверка результата по условию "
"меньше или равно нулю не будет корректной, если только системные столбцы не "
"должны исключаться."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3110(para)
msgid "column name"
msgstr "имя столбца"

#. +> REL_10
#: spi.xml:3121(para)
msgid ""
"Column number (count starts at 1 for user-defined columns), or "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol> if the named column was not found."
msgstr ""
"Номер столбца (начиная с 1 для столбцов, создаваемых пользователем), либо "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>, если столбец с заданным именем не "
"найден."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3132(indexterm)
msgid "<primary>SPI_getvalue</primary>"
msgstr "<primary>SPI_getvalue</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3135(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getvalue"
msgstr "SPI_getvalue"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3140(refname)
msgctxt "refname"
msgid "SPI_getvalue"
msgstr "SPI_getvalue"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3141(refpurpose)
msgid "return the string value of the specified column"
msgstr "получить строковое значение указанного столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3146(parameter) spi.xml:3171(parameter) spi.xml:3230(parameter)
#: spi.xml:3255(parameter) spi.xml:3808(parameter) spi.xml:3834(parameter)
#: spi.xml:3871(parameter) spi.xml:3903(parameter) spi.xml:3951(parameter)
#: spi.xml:3989(parameter) spi.xml:4115(parameter) spi.xml:4139(parameter)
msgid "row"
msgstr "row"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3145(synopsis)
#, no-wrap
msgid "char * SPI_getvalue(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>)"
msgstr "char * SPI_getvalue(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3153(para)
msgid ""
"<function>SPI_getvalue</function> returns the string representation of the "
"value of the specified column."
msgstr ""
"<function>SPI_getvalue</function> возвращает строковое представление "
"значения указанного столбца."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3158(para)
msgid ""
"The result is returned in memory allocated using <function>palloc</"
"function>. (You can use <function>pfree</function> to release the memory "
"when you don't need it anymore.)"
msgstr ""
"Результат возвращается в памяти, размещённой функцией <function>palloc</"
"function>. (Когда он будет не нужен, эту память можно освободить с помощью "
"<function>pfree</function>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3171(literal) spi.xml:3255(literal) spi.xml:3834(literal)
#: spi.xml:3903(literal) spi.xml:3989(literal) spi.xml:4139(literal)
msgid "HeapTuple <placeholder-1/>"
msgstr "HeapTuple <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3173(para) spi.xml:3257(para)
msgid "input row to be examined"
msgstr "строка с нужными данными"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3202(para)
msgid ""
"Column value, or <symbol>NULL</symbol> if the column is null, "
"<parameter>colnumber</parameter> is out of range (<varname>SPI_result</"
"varname> is set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol>), or no output "
"function is available (<varname>SPI_result</varname> is set to "
"<symbol>SPI_ERROR_NOOUTFUNC</symbol>)."
msgstr ""
"Значение столбца, либо <symbol>NULL</symbol>, если столбец содержит NULL, "
"<parameter>colnumber</parameter> вне допустимого диапазона (в "
"<varname>SPI_result</varname> при этом устанавливается "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>) или если отсутствует функция вывода "
"(в <varname>SPI_result</varname> устанавливается "
"<symbol>SPI_ERROR_NOOUTFUNC</symbol>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3216(indexterm)
msgid "<primary>SPI_getbinval</primary>"
msgstr "<primary>SPI_getbinval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3219(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getbinval"
msgstr "SPI_getbinval"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3224(refname)
msgctxt "refname"
msgid "SPI_getbinval"
msgstr "SPI_getbinval"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3225(refpurpose)
msgid "return the binary value of the specified column"
msgstr "получить двоичное значение указанного столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3231(parameter) spi.xml:3282(parameter)
msgid "isnull"
msgstr "isnull"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3229(synopsis)
#, no-wrap
msgid ""
"Datum SPI_getbinval(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>,\n"
"                    bool * <placeholder-4/>)"
msgstr ""
"Datum SPI_getbinval(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>,\n"
"                    bool * <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3238(para)
msgid ""
"<function>SPI_getbinval</function> returns the value of the specified column "
"in the internal form (as type <type>Datum</type>)."
msgstr ""
"<function>SPI_getbinval</function> возвращает значение указанного столбца во "
"внутренней форме (в структуре <type>Datum</type>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3243(para)
msgid ""
"This function does not allocate new space for the datum. In the case of a "
"pass-by-reference data type, the return value will be a pointer into the "
"passed row."
msgstr ""
"Эта функция не выделяет новый блок памяти для данных. В случае с типом, "
"передаваемым по ссылке, возвращаемым значением будет указатель на переданную "
"строку данных."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3282(literal)
msgid "bool * <placeholder-1/>"
msgstr "bool * <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3284(para)
msgid "flag for a null value in the column"
msgstr "признак того, что столбец содержит NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3295(para)
msgid ""
"The binary value of the column is returned. The variable pointed to by "
"<parameter>isnull</parameter> is set to true if the column is null, else to "
"false."
msgstr ""
"Возвращается двоичное значение столбца. Если этот столбец содержит NULL, "
"переменной, на которую указывает <parameter>isnull</parameter>, "
"присваивается true; в противном случае — false."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3301(para)
msgid ""
"<varname>SPI_result</varname> is set to <symbol>SPI_ERROR_NOATTRIBUTE</"
"symbol> on error."
msgstr ""
"При ошибке в <varname>SPI_result</varname> устанавливается "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3311(indexterm)
msgid "<primary>SPI_gettype</primary>"
msgstr "<primary>SPI_gettype</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3314(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_gettype"
msgstr "SPI_gettype"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3319(refname)
msgctxt "refname"
msgid "SPI_gettype"
msgstr "SPI_gettype"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3320(refpurpose)
msgid "return the data type name of the specified column"
msgstr "получить имя типа данных указанного столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3324(synopsis)
#, no-wrap
msgid "char * SPI_gettype(TupleDesc <placeholder-1/>, int <placeholder-2/>)"
msgstr "char * SPI_gettype(TupleDesc <placeholder-1/>, int <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3332(para)
msgid ""
"<function>SPI_gettype</function> returns a copy of the data type name of the "
"specified column. (You can use <function>pfree</function> to release the "
"copy of the name when you don't need it anymore.)"
msgstr ""
"<function>SPI_gettype</function> возвращает копию имени типа данных "
"указанного столбца. (Когда эта копия имени будет не нужна, её можно "
"освободить с помощью <function>pfree</function>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3366(para)
msgid ""
"The data type name of the specified column, or <symbol>NULL</symbol> on "
"error. <varname>SPI_result</varname> is set to "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error."
msgstr ""
"Имя типа данных указанного столбца, либо <symbol>NULL</symbol> в случае "
"ошибки. При ошибке в <varname>SPI_result</varname> устанавливается "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3377(indexterm)
msgid "<primary>SPI_gettypeid</primary>"
msgstr "<primary>SPI_gettypeid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3380(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_gettypeid"
msgstr "SPI_gettypeid"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3385(refname)
msgctxt "refname"
msgid "SPI_gettypeid"
msgstr "SPI_gettypeid"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3386(acronym)
msgid "OID"
msgstr "OID"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3386(refpurpose)
msgid "return the data type <placeholder-1/> of the specified column"
msgstr "получить <placeholder-1/> типа данных указанного столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3390(synopsis)
#, no-wrap
msgid "Oid SPI_gettypeid(TupleDesc <placeholder-1/>, int <placeholder-2/>)"
msgstr "Oid SPI_gettypeid(TupleDesc <placeholder-1/>, int <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3398(para)
msgid ""
"<function>SPI_gettypeid</function> returns the <acronym>OID</acronym> of the "
"data type of the specified column."
msgstr ""
"<function>SPI_gettypeid</function> возвращает <acronym>OID</acronym> типа "
"данных указанного столбца."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3431(para)
msgid ""
"The <acronym>OID</acronym> of the data type of the specified column or "
"<symbol>InvalidOid</symbol> on error. On error, <varname>SPI_result</"
"varname> is set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol>."
msgstr ""
"<acronym>OID</acronym> типа данных указанного столбца, либо "
"<symbol>InvalidOid</symbol> в случае ошибки. При ошибке в "
"<varname>SPI_result</varname> устанавливается <symbol>SPI_ERROR_NOATTRIBUTE</"
"symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3443(indexterm)
msgid "<primary>SPI_getrelname</primary>"
msgstr "<primary>SPI_getrelname</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3446(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getrelname"
msgstr "SPI_getrelname"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3451(refname)
msgctxt "refname"
msgid "SPI_getrelname"
msgstr "SPI_getrelname"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3452(refpurpose)
msgid "return the name of the specified relation"
msgstr "возвращает имя указанного отношения"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3457(parameter) spi.xml:3476(parameter) spi.xml:3510(parameter)
#: spi.xml:3531(parameter) spi.xml:3951(parameter) spi.xml:3978(parameter)
msgid "rel"
msgstr "rel"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3456(synopsis)
#, no-wrap
msgid "char * SPI_getrelname(Relation <placeholder-1/>)"
msgstr "char * SPI_getrelname(Relation <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3464(para)
msgid ""
"<function>SPI_getrelname</function> returns a copy of the name of the "
"specified relation. (You can use <function>pfree</function> to release the "
"copy of the name when you don't need it anymore.)"
msgstr ""
"<function>SPI_getrelname</function> возвращает копию имени указанного "
"отношения. (Когда эта копия имени будет не нужна, её можно освободить с "
"помощью <function>pfree</function>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3476(literal) spi.xml:3531(literal) spi.xml:3978(literal)
msgid "Relation <placeholder-1/>"
msgstr "Relation <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3478(para) spi.xml:3533(para)
msgid "input relation"
msgstr "целевое отношение"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3489(para)
msgid "The name of the specified relation."
msgstr "Имя указанного отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3496(indexterm)
msgid "<primary>SPI_getnspname</primary>"
msgstr "<primary>SPI_getnspname</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3499(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getnspname"
msgstr "SPI_getnspname"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3504(refname)
msgctxt "refname"
msgid "SPI_getnspname"
msgstr "SPI_getnspname"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3505(refpurpose)
msgid "return the namespace of the specified relation"
msgstr "возвращает пространство имён указанного отношения"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3509(synopsis)
#, no-wrap
msgid "char * SPI_getnspname(Relation <placeholder-1/>)"
msgstr "char * SPI_getnspname(Relation <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3517(para)
msgid ""
"<function>SPI_getnspname</function> returns a copy of the name of the "
"namespace that the specified <structname>Relation</structname> belongs to. "
"This is equivalent to the relation's schema. You should <function>pfree</"
"function> the return value of this function when you are finished with it."
msgstr ""
"<function>SPI_getnspname</function> возвращает копию имени пространства "
"имён, к которому принадлежит указанное отношение (<structname>Relation</"
"structname>). Пространство имён по-другому называется схемой отношения. "
"Когда значение, возвращённое этой функцией, будет не нужно, освободите его с "
"помощью <function>pfree</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3544(para)
msgid "The name of the specified relation's namespace."
msgstr "Имя пространства имён указанного отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3553(title)
msgid "Memory Management"
msgstr "Управление памятью"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3556(indexterm)
msgid "<primary>memory context</primary> <secondary>in SPI</secondary>"
msgstr "<primary>контекст памяти</primary> <secondary>в SPI</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3555(para)
msgid ""
"<placeholder-1/> <productname>PostgreSQL</productname> allocates memory "
"within <firstterm>memory contexts</firstterm>, which provide a convenient "
"method of managing allocations made in many different places that need to "
"live for differing amounts of time. Destroying a context releases all the "
"memory that was allocated in it. Thus, it is not necessary to keep track of "
"individual objects to avoid memory leaks; instead only a relatively small "
"number of contexts have to be managed. <function>palloc</function> and "
"related functions allocate memory from the <quote>current</quote> context."
msgstr ""
"<placeholder-1/> <productname>PostgreSQL</productname> выделяет память в "
"<firstterm>контекстах памяти</firstterm>, и тем самым реализует удобный "
"способ управления выделением памяти в различных местах, с разными сроками "
"жизни выделенной памяти. При уничтожении контекста освобождается вся "
"выделенная в нём память. Таким образом, нет необходимости контролировать "
"каждый отдельный объект во избежание утечек памяти; вместо этого достаточно "
"управлять только небольшим числом контекстов. Функция <function>palloc</"
"function> и родственные ей освобождают память из <quote>текущего</quote> "
"контекста."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3571(para)
msgid ""
"<function>SPI_connect</function> creates a new memory context and makes it "
"current. <function>SPI_finish</function> restores the previous current "
"memory context and destroys the context created by <function>SPI_connect</"
"function>. These actions ensure that transient memory allocations made "
"inside your procedure are reclaimed at procedure exit, avoiding memory "
"leakage."
msgstr ""
"<function>SPI_connect</function> создаёт новый контекст памяти и делает его "
"текущим. <function>SPI_finish</function> восстанавливает контекст, который "
"был текущим до этого, и уничтожает контекст, созданный функцией "
"<function>SPI_connect</function>. Эти действия обеспечивают при выходе из "
"вашей процедуры освобождение временной памяти, выделенной внутри процедуры, "
"во избежание утечки памяти."

#. +> REL_10
#: spi.xml:3580(para)
msgid ""
"However, if your procedure needs to return an object in allocated memory "
"(such as a value of a pass-by-reference data type), you cannot allocate that "
"memory using <function>palloc</function>, at least not while you are "
"connected to SPI. If you try, the object will be deallocated by "
"<function>SPI_finish</function>, and your procedure will not work reliably. "
"To solve this problem, use <function>SPI_palloc</function> to allocate "
"memory for your return object. <function>SPI_palloc</function> allocates "
"memory in the <quote>upper executor context</quote>, that is, the memory "
"context that was current when <function>SPI_connect</function> was called, "
"which is precisely the right context for a value returned from your "
"procedure. Several of the other utility procedures described in this section "
"also return objects created in the upper executor context."
msgstr ""
"Однако, если ваша процедура должна вернуть объект в выделенной памяти (как "
"значение типа, передаваемого по ссылке), эту память нельзя выделять через "
"<function>palloc</function>, как минимум пока установлено подключение к SPI. "
"Если вы попытаетесь это сделать, объект будет освобождён при вызове "
"<function>SPI_finish</function> и ваша процедура не будет работать надёжно. "
"Для решения этой проблемы выделяйте память для возвращаемого объекта, "
"используя <function>SPI_palloc</function>. <function>SPI_palloc</function> "
"выделяет память в <quote>верхнем контексте исполнителя</quote>, то есть, в "
"контексте памяти, который был текущим при вызове <function>SPI_connect</"
"function>; именно этот контекст подходит для значения, возвращаемого из "
"процедуры. Некоторые из вспомогательных процедур, описанных в этом разделе, "
"также возвращают объекты, созданные в верхнем контексте исполнителя."

#. +> REL_10
#: spi.xml:3596(para)
msgid ""
"When <function>SPI_connect</function> is called, the private context of the "
"procedure, which is created by <function>SPI_connect</function>, is made the "
"current context. All allocations made by <function>palloc</function>, "
"<function>repalloc</function>, or SPI utility functions (except as described "
"in this section) are made in this context. When a procedure disconnects from "
"the SPI manager (via <function>SPI_finish</function>) the current context is "
"restored to the upper executor context, and all allocations made in the "
"procedure memory context are freed and cannot be used any more."
msgstr ""
"Когда вызывается <function>SPI_connect</function>, текущим контекстом "
"становится частный контекст процедуры, создаваемый в <function>SPI_connect</"
"function>. Все операции выделения памяти, выполняемые функциями "
"<function>palloc</function>, <function>repalloc</function> или служебными "
"функциями SPI (кроме описанных в этом разделе исключений), производятся в "
"этом контексте. Когда процедура отключается от менеджера SPI (выполняя "
"<function>SPI_finish</function>), текущим контекстом снова становится "
"верхний контекст исполнителя, а вся память, выделенная в контексте "
"процедуры, освобождается, так что использовать её дальше нельзя."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3612(indexterm)
msgid "<primary>SPI_palloc</primary>"
msgstr "<primary>SPI_palloc</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3615(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_palloc"
msgstr "SPI_palloc"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3620(refname)
msgctxt "refname"
msgid "SPI_palloc"
msgstr "SPI_palloc"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3621(refpurpose)
msgid "allocate memory in the upper executor context"
msgstr "выделить память в верхнем контексте исполнителя"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3626(parameter) spi.xml:3649(parameter) spi.xml:3685(parameter)
#: spi.xml:3718(parameter)
msgid "size"
msgstr "size"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3625(synopsis)
#, no-wrap
msgid "void * SPI_palloc(Size <placeholder-1/>)"
msgstr "void * SPI_palloc(Size <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3633(para)
msgid ""
"<function>SPI_palloc</function> allocates memory in the upper executor "
"context."
msgstr ""
"<function>SPI_palloc</function> выделяет память в верхнем контексте "
"исполнителя."

#. +> REL_10
#: spi.xml:3638(para)
msgid ""
"This function can only be used while connected to SPI. Otherwise, it throws "
"an error."
msgstr ""
"Эту функцию можно использовать только когда установлено подключение к SPI. В "
"противном случае она выдаёт ошибку."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3649(literal) spi.xml:3718(literal)
msgid "Size <placeholder-1/>"
msgstr "Size <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3651(para) spi.xml:3720(para)
msgid "size in bytes of storage to allocate"
msgstr "размер выделяемой памяти, в байтах"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3662(para)
msgid "pointer to new storage space of the specified size"
msgstr "указатель на выделенный блок памяти заданного размера"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3671(indexterm)
msgid "<primary>SPI_repalloc</primary>"
msgstr "<primary>SPI_repalloc</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3674(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_repalloc"
msgstr "SPI_repalloc"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3679(refname)
msgctxt "refname"
msgid "SPI_repalloc"
msgstr "SPI_repalloc"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3680(refpurpose)
msgid "reallocate memory in the upper executor context"
msgstr "поменять блок памяти в верхнем контексте исполнителя"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3685(parameter) spi.xml:3709(parameter) spi.xml:3755(parameter)
#: spi.xml:3780(parameter)
msgid "pointer"
msgstr "pointer"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3684(synopsis)
#, no-wrap
msgid "void * SPI_repalloc(void * <placeholder-1/>, Size <placeholder-2/>)"
msgstr "void * SPI_repalloc(void * <placeholder-1/>, Size <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3692(para)
msgid ""
"<function>SPI_repalloc</function> changes the size of a memory segment "
"previously allocated using <function>SPI_palloc</function>."
msgstr ""
"<function>SPI_repalloc</function> изменяет размер блока памяти, ранее "
"выделенного функцией <function>SPI_palloc</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3697(para)
msgid ""
"This function is no longer different from plain <function>repalloc</"
"function>. It's kept just for backward compatibility of existing code."
msgstr ""
"Эта функция теперь не отличается от простой <function>repalloc</function>. "
"Она сохранена только для обратной совместимости с существующим кодом."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3711(para)
msgid "pointer to existing storage to change"
msgstr "указатель на существующий блок памяти, подлежащий изменению"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3731(para)
msgid ""
"pointer to new storage space of specified size with the contents copied from "
"the existing area"
msgstr ""
"указатель на новый блок памяти указанного размера, в который скопировано "
"содержимое прежнего блока"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3741(indexterm)
msgid "<primary>SPI_pfree</primary>"
msgstr "<primary>SPI_pfree</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3744(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_pfree"
msgstr "SPI_pfree"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3749(refname)
msgctxt "refname"
msgid "SPI_pfree"
msgstr "SPI_pfree"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3750(refpurpose)
msgid "free memory in the upper executor context"
msgstr "освободить память в верхнем контексте исполнителя"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3754(synopsis)
#, no-wrap
msgid "void SPI_pfree(void * <placeholder-1/>)"
msgstr "void SPI_pfree(void * <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3762(para)
msgid ""
"<function>SPI_pfree</function> frees memory previously allocated using "
"<function>SPI_palloc</function> or <function>SPI_repalloc</function>."
msgstr ""
"<function>SPI_pfree</function> освобождает память, ранее выделенную функцией "
"<function>SPI_palloc</function> или <function>SPI_repalloc</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3768(para)
msgid ""
"This function is no longer different from plain <function>pfree</function>. "
"It's kept just for backward compatibility of existing code."
msgstr ""
"Эта функция теперь не отличается от простой <function>pfree</function>. Она "
"сохранена только для обратной совместимости с существующим кодом."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3782(para)
msgid "pointer to existing storage to free"
msgstr "указатель на существующий блок памяти, подлежащий освобождению"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3794(indexterm)
msgid "<primary>SPI_copytuple</primary>"
msgstr "<primary>SPI_copytuple</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3797(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_copytuple"
msgstr "SPI_copytuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3802(refname)
msgctxt "refname"
msgid "SPI_copytuple"
msgstr "SPI_copytuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3803(refpurpose)
msgid "make a copy of a row in the upper executor context"
msgstr "скопировать строку в верхнем контексте исполнителя"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3807(synopsis)
#, no-wrap
msgid "HeapTuple SPI_copytuple(HeapTuple <placeholder-1/>)"
msgstr "HeapTuple SPI_copytuple(HeapTuple <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3815(para)
msgid ""
"<function>SPI_copytuple</function> makes a copy of a row in the upper "
"executor context. This is normally used to return a modified row from a "
"trigger. In a function declared to return a composite type, use "
"<function>SPI_returntuple</function> instead."
msgstr ""
"<function>SPI_copytuple</function> делает копию строки в верхнем контексте "
"исполнителя. Обычно это применяется, когда нужно вернуть изменённую строку "
"из триггера. В функции, которая должна возвращать составной тип, нужно "
"использовать <function>SPI_returntuple</function>."

#. +> REL_10
#: spi.xml:3822(para) spi.xml:3885(para) spi.xml:3966(para)
msgid ""
"This function can only be used while connected to SPI. Otherwise, it returns "
"NULL and sets <varname>SPI_result</varname> to "
"<symbol>SPI_ERROR_UNCONNECTED</symbol>."
msgstr ""
"Эту функцию можно использовать только когда установлено подключение к SPI. В "
"противном случае она возвращает NULL и устанавливает в <varname>SPI_result</"
"varname> значение <symbol>SPI_ERROR_UNCONNECTED</symbol>."

#. +> REL9_6_3 REL9_6
#: spi.xml:3822(para)
msgid ""
"new row with modifications, allocated in the upper executor context; "
"<symbol>NULL</symbol> only if <parameter>row</parameter> is <symbol>NULL</"
"symbol>"
msgstr ""
"новая строка с изменениями, размещённая в верхнем контексте исполнителя; "
"<symbol>NULL</symbol>, только если <parameter>row</parameter> — "
"<symbol>NULL</symbol>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3836(para) spi.xml:3905(para)
msgid "row to be copied"
msgstr "строка, подлежащая копированию"

#. +> REL_10
#: spi.xml:3847(para)
msgid ""
"the copied row, or <symbol>NULL</symbol> on error (see <varname>SPI_result</"
"varname> for an error indication)"
msgstr ""
"скопированная строка либо <symbol>NULL</symbol> в случае ошибки "
"(<varname>SPI_result</varname> содержит код ошибки)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3857(indexterm)
msgid "<primary>SPI_returntuple</primary>"
msgstr "<primary>SPI_returntuple</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3860(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_returntuple"
msgstr "SPI_returntuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3865(refname)
msgctxt "refname"
msgid "SPI_returntuple"
msgstr "SPI_returntuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3866(refpurpose)
msgid "prepare to return a tuple as a Datum"
msgstr "подготовить строку для возврата в виде Datum"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3870(synopsis)
#, no-wrap
msgid "HeapTupleHeader SPI_returntuple(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>)"
msgstr "HeapTupleHeader SPI_returntuple(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3878(para)
msgid ""
"<function>SPI_returntuple</function> makes a copy of a row in the upper "
"executor context, returning it in the form of a row type <type>Datum</type>. "
"The returned pointer need only be converted to <type>Datum</type> via "
"<function>PointerGetDatum</function> before returning."
msgstr ""
"<function>SPI_returntuple</function> делает копию строки в верхнем контексте "
"исполнителя и возвращает её в форме типа <type>Datum</type>. Чтобы выдать "
"результат, полученный указатель остаётся только преобразовать в <type>Datum</"
"type> функцией <function>PointerGetDatum</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3891(para)
msgid ""
"Note that this should be used for functions that are declared to return "
"composite types. It is not used for triggers; use <function>SPI_copytuple</"
"function> for returning a modified row in a trigger."
msgstr ""
"Заметьте, что эту операцию следует применять в функциях, объявленных как "
"возвращающие составные типы. В триггерах она не применяется; чтобы вернуть "
"изменённую строку из триггера, используйте <function>SPI_copytuple</"
"function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3914(para)
msgid ""
"descriptor for row (pass the same descriptor each time for most effective "
"caching)"
msgstr ""
"дескриптор строки (передавайте каждый раз один дескриптор для более "
"эффективного кеширования)"

#. +> REL_10
#: spi.xml:3926(para)
msgid ""
"<type>HeapTupleHeader</type> pointing to copied row, or <symbol>NULL</"
"symbol> on error (see <varname>SPI_result</varname> for an error indication)"
msgstr ""
"<type>HeapTupleHeader</type>, указывающий на скопированную строку, или "
"<symbol>NULL</symbol> в случае ошибки (<varname>SPI_result</varname> "
"содержит код ошибки)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3937(indexterm)
msgid "<primary>SPI_modifytuple</primary>"
msgstr "<primary>SPI_modifytuple</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3940(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_modifytuple"
msgstr "SPI_modifytuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3945(refname)
msgctxt "refname"
msgid "SPI_modifytuple"
msgstr "SPI_modifytuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3946(refpurpose)
msgid "create a row by replacing selected fields of a given row"
msgstr "создать строку, заменяя отдельные поля в данной"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3951(parameter) spi.xml:3998(parameter)
msgid "ncols"
msgstr "ncols"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3952(parameter) spi.xml:4007(parameter)
msgid "colnum"
msgstr "colnum"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3950(synopsis)
#, no-wrap
msgid ""
"HeapTuple SPI_modifytuple(Relation <placeholder-1/>, HeapTuple <placeholder-2/>, int <placeholder-3/>,\n"
"                          int * <placeholder-4/>, Datum * <placeholder-5/>, const char * <placeholder-6/>)"
msgstr ""
"HeapTuple SPI_modifytuple(Relation <placeholder-1/>, HeapTuple <placeholder-2/>, int <placeholder-3/>,\n"
"                          int * <placeholder-4/>, Datum * <placeholder-5/>, const char * <placeholder-6/>)"

#. +> REL_10
#: spi.xml:3959(para)
msgid ""
"<function>SPI_modifytuple</function> creates a new row by substituting new "
"values for selected columns, copying the original row's columns at other "
"positions. The input row is not modified. The new row is returned in the "
"upper executor context."
msgstr ""
"<function>SPI_modifytuple</function> создаёт новую строку, подставляя новые "
"значения для указанных столбцов и копируя исходное содержимое остальных "
"столбцов. Исходная строка не изменяется. Новая строка возвращается в верхнем "
"контексте исполнителя."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3980(para)
msgid ""
"Used only as the source of the row descriptor for the row. (Passing a "
"relation rather than a row descriptor is a misfeature.)"
msgstr ""
"Используется только в качестве дескриптора строки. (Передача отношения "
"вместо собственно дескриптора строки — нехорошая особенность.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:3991(para)
msgid "row to be modified"
msgstr "строка, подлежащая изменению"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4000(para)
msgid "number of columns to be changed"
msgstr "число изменяемых столбцов"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4007(literal)
msgid "int * <placeholder-1/>"
msgstr "int * <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4009(para)
msgid ""
"an array of length <parameter>ncols</parameter>, containing the numbers of "
"the columns that are to be changed (column numbers start at 1)"
msgstr ""
"массив длины <parameter>ncols</parameter>, содержащий номера изменяемых "
"столбцов (начиная с 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4019(para)
msgid ""
"an array of length <parameter>ncols</parameter>, containing the new values "
"for the specified columns"
msgstr ""
"массив длины <parameter>ncols</parameter>, содержащий новые значения "
"указанных столбцов"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4029(para)
msgid ""
"an array of length <parameter>ncols</parameter>, describing which new values "
"are null"
msgstr ""
"массив длины <parameter>ncols</parameter>, описывающий, в каких столбцах "
"передаётся NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4034(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_modifytuple</function> assumes that no new values are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding new value is non-null, or "
"<literal>'n'</literal> if the corresponding new value is null. (In the "
"latter case, the actual value in the corresponding <parameter>values</"
"parameter> entry doesn't matter.) Note that <parameter>nulls</parameter> is "
"not a text string, just an array: it does not need a <literal>'\\0'</"
"literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_modifytuple</function> считает, что ни один из параметров не "
"равен NULL. В противном случае элемент массива <parameter>nulls</parameter> "
"должен содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль <literal>'\\0'</literal> в конце не нужен."

#. +> REL_10
#: spi.xml:4053(para)
msgid ""
"new row with modifications, allocated in the upper executor context, or "
"<symbol>NULL</symbol> on error (see <varname>SPI_result</varname> for an "
"error indication)"
msgstr ""
"новая строка с изменениями, размещённая в верхнем контексте исполнителя, или "
"<symbol>NULL</symbol> при ошибке (<varname>SPI_result</varname> содержит код "
"ошибки)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4065(para)
msgid ""
"if <parameter>rel</parameter> is <symbol>NULL</symbol>, or if "
"<parameter>row</parameter> is <symbol>NULL</symbol>, or if <parameter>ncols</"
"parameter> is less than or equal to 0, or if <parameter>colnum</parameter> "
"is <symbol>NULL</symbol>, or if <parameter>values</parameter> is "
"<symbol>NULL</symbol>."
msgstr ""
"если <parameter>rel</parameter> — <symbol>NULL</symbol>, либо "
"<parameter>row</parameter> — <symbol>NULL</symbol>, либо <parameter>ncols</"
"parameter> меньше или равно 0, либо <parameter>colnum</parameter> — "
"<symbol>NULL</symbol>, либо <parameter>values</parameter> — <symbol>NULL</"
"symbol>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4075(symbol)
msgid "SPI_ERROR_NOATTRIBUTE"
msgstr "SPI_ERROR_NOATTRIBUTE"

#. +> REL_10
#: spi.xml:4077(para)
msgid ""
"if <parameter>colnum</parameter> contains an invalid column number (less "
"than or equal to 0 or greater than the number of columns in <parameter>row</"
"parameter>)"
msgstr ""
"если <parameter>colnum</parameter> содержит недопустимый номер столбца "
"(меньше или равен 0, либо больше числа столбцов в строке <parameter>row</"
"parameter>)"

#. +> REL_10
#: spi.xml:4088(para)
msgid "if SPI is not active"
msgstr "если SPI неактивен"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4059(para)
msgid ""
"On error, <varname>SPI_result</varname> is set as follows: <placeholder-1/>"
msgstr ""
"В случае ошибки в <varname>SPI_result</varname> устанавливается: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4101(indexterm)
msgid "<primary>SPI_freetuple</primary>"
msgstr "<primary>SPI_freetuple</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4104(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_freetuple"
msgstr "SPI_freetuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4109(refname)
msgctxt "refname"
msgid "SPI_freetuple"
msgstr "SPI_freetuple"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4110(refpurpose)
msgid "free a row allocated in the upper executor context"
msgstr "освободить строку, размещённую в верхнем контексте исполнителя"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4114(synopsis)
#, no-wrap
msgid "void SPI_freetuple(HeapTuple <placeholder-1/>)"
msgstr "void SPI_freetuple(HeapTuple <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4122(para)
msgid ""
"<function>SPI_freetuple</function> frees a row previously allocated in the "
"upper executor context."
msgstr ""
"<function>SPI_freetuple</function> освобождает строку, ранее размещённую в "
"верхнем контексте исполнителя."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4127(para)
msgid ""
"This function is no longer different from plain <function>heap_freetuple</"
"function>. It's kept just for backward compatibility of existing code."
msgstr ""
"Эта функция теперь не отличается от простой <function>heap_freetuple</"
"function>. Она сохранена только для обратной совместимости с существующим "
"кодом."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4141(para)
msgid "row to free"
msgstr "строка, подлежащая освобождению"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4153(indexterm)
msgid "<primary>SPI_freetuptable</primary>"
msgstr "<primary>SPI_freetuptable</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4156(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_freetuptable"
msgstr "SPI_freetuptable"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4161(refname)
msgctxt "refname"
msgid "SPI_freetuptable"
msgstr "SPI_freetuptable"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4162(function)
msgctxt "function"
msgid "SPI_execute"
msgstr "SPI_execute"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4162(refpurpose)
msgid "free a row set created by <placeholder-1/> or a similar function"
msgstr ""
"освободить набор строк, созданный <placeholder-1/> или подобной функцией"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4168(parameter) spi.xml:4206(parameter)
msgid "tuptable"
msgstr "tuptable"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4167(synopsis)
#, no-wrap
msgid "void SPI_freetuptable(SPITupleTable * <placeholder-1/>)"
msgstr "void SPI_freetuptable(SPITupleTable * <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4175(para)
msgid ""
"<function>SPI_freetuptable</function> frees a row set created by a prior SPI "
"command execution function, such as <function>SPI_execute</function>. "
"Therefore, this function is often called with the global variable "
"<varname>SPI_tuptable</varname> as argument."
msgstr ""
"<function>SPI_freetuptable</function> освобождает набор строк, созданных "
"предыдущей функцией SPI выполнения команд, например <function>SPI_execute</"
"function>. Таким образом, при вызове этой функции в качестве аргумента часто "
"передаётся глобальная переменная <varname>SPI_tuptable</varname>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4183(para)
msgid ""
"This function is useful if a SPI procedure needs to execute multiple "
"commands and does not want to keep the results of earlier commands around "
"until it ends. Note that any unfreed row sets will be freed anyway at "
"<function>SPI_finish</function>. Also, if a subtransaction is started and "
"then aborted within execution of a SPI procedure, SPI automatically frees "
"any row sets created while the subtransaction was running."
msgstr ""
"Эта функция полезна, когда процедура, использующая SPI, должна выполнить "
"несколько команд, но не хочет сохранять результаты предыдущих команд до "
"завершения. Заметьте, что любые не освобождённые таким образом наборы строк "
"будут всё равно освобождены при выполнении <function>SPI_finish</function>. "
"Кроме того, если была запущена подтранзакция, а затем она прервалась в ходе "
"выполнения процедуры SPI, все наборы строк, созданные в рамках "
"подтранзакции, будут автоматически освобождены."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4193(para)
msgid ""
"Beginning in <productname>PostgreSQL</productname> 9.3, "
"<function>SPI_freetuptable</function> contains guard logic to protect "
"against duplicate deletion requests for the same row set. In previous "
"releases, duplicate deletions would lead to crashes."
msgstr ""
"Начиная с <productname>PostgreSQL</productname> версии 9.3, "
"<function>SPI_freetuptable</function> содержит защитную логику, "
"отфильтровывающую повторные запросы на удаление одного и того же набора "
"строк. В предыдущих версиях повторное удаление могло приводить к сбоям."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4206(literal)
msgid "SPITupleTable * <placeholder-1/>"
msgstr "SPITupleTable * <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4208(para)
msgid "pointer to row set to free, or NULL to do nothing"
msgstr ""
"указатель на набор строк, который нужно освободить (если NULL, ничего не "
"происходит)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4220(indexterm)
msgid "<primary>SPI_freeplan</primary>"
msgstr "<primary>SPI_freeplan</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4223(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_freeplan"
msgstr "SPI_freeplan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4228(refname)
msgctxt "refname"
msgid "SPI_freeplan"
msgstr "SPI_freeplan"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4229(refpurpose)
msgid "free a previously saved prepared statement"
msgstr "освободить ранее сохранённый подготовленный оператор"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4233(synopsis)
#, no-wrap
msgid "int SPI_freeplan(SPIPlanPtr <placeholder-1/>)"
msgstr "int SPI_freeplan(SPIPlanPtr <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4241(para)
msgid ""
"<function>SPI_freeplan</function> releases a prepared statement previously "
"returned by <function>SPI_prepare</function> or saved by "
"<function>SPI_keepplan</function> or <function>SPI_saveplan</function>."
msgstr ""
"<function>SPI_freeplan</function> освобождает подготовленный оператор, до "
"этого выданный функцией <function>SPI_prepare</function> или сохранённый "
"функциями <function>SPI_keepplan</function> и <function>SPI_saveplan</"
"function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4255(para)
msgid "pointer to statement to free"
msgstr "указатель на оператор, подлежащий освобождению"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4277(title)
msgid "Visibility of Data Changes"
msgstr "Видимость изменений в данных"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4289(programlisting)
#, no-wrap
msgid "INSERT INTO a SELECT * FROM a;"
msgstr "INSERT INTO a SELECT * FROM a;"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4285(para)
msgid ""
"During the execution of an SQL command, any data changes made by the command "
"are invisible to the command itself. For example, in: <placeholder-1/> the "
"inserted rows are invisible to the <command>SELECT</command> part."
msgstr ""
"В процессе выполнения SQL-команды любые произведённые ей изменения не видны "
"для неё самой. Например, в команде: <placeholder-1/> вставляемые строки не "
"видны в части <command>SELECT</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4298(para)
msgid ""
"Changes made by a command C are visible to all commands that are started "
"after C, no matter whether they are started inside C (during the execution "
"of C) or after C is done."
msgstr ""
"Изменения, произведённые командой К, видны во всех командах, запущенных "
"после К, независимо от того, были ли эти команды запущены из К (во время "
"выполнения К) или после завершения К."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4306(para)
msgid ""
"Commands executed via SPI inside a function called by an SQL command (either "
"an ordinary function or a trigger) follow one or the other of the above "
"rules depending on the read/write flag passed to SPI. Commands executed in "
"read-only mode follow the first rule: they cannot see changes of the calling "
"command. Commands executed in read-write mode follow the second rule: they "
"can see all changes made so far."
msgstr ""
"Команды, выполняемые через SPI внутри функции, вызванной SQL-командой (будь "
"то обычная функция или триггер), следуют одному или другому из "
"вышеприведённых правил в зависимости флага чтения/записи, переданного SPI. "
"Команды, выполняемые в режиме &laquo;только чтение&raquo;, следует первому "
"правилу: они не видят изменений, произведённых вызывающей командой. Команды, "
"выполняемые в режиме &laquo;чтение-запись&raquo;, следуют второму правилу: "
"они могут видеть все произведённые к этому времени изменения."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4318(para)
msgid ""
"All standard procedural languages set the SPI read-write mode depending on "
"the volatility attribute of the function. Commands of <literal>STABLE</"
"literal> and <literal>IMMUTABLE</literal> functions are done in read-only "
"mode, while commands of <literal>VOLATILE</literal> functions are done in "
"read-write mode. While authors of C functions are able to violate this "
"convention, it's unlikely to be a good idea to do so."
msgstr ""
"Все стандартные процедурные языки устанавливают режим чтения-записи в SPI в "
"зависимости от атрибута изменчивости функции. Команды функций "
"<literal>STABLE</literal> и <literal>IMMUTABLE</literal> выполняются в "
"режиме &laquo;только чтение&raquo;, тогда как команды функций "
"<literal>VOLATILE</literal> — в режиме &laquo;чтение-запись&raquo;. Хотя "
"авторы функций на C могут нарушить это соглашение, вряд ли это будет хорошей "
"идеей."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4279(para)
msgid ""
"The following rules govern the visibility of data changes in functions that "
"use SPI (or any other C function): <placeholder-1/>"
msgstr ""
"Видимость изменений в данных, которые производятся функциями, использующими "
"SPI, (или любыми другими функциями на C), описывается следующими правилами: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4330(para)
msgid ""
"The next section contains an example that illustrates the application of "
"these rules."
msgstr ""
"В следующем разделе приводится пример, иллюстрирующий применение этих правил."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4337(title)
msgid "Examples"
msgstr "Примеры"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4339(para)
msgid ""
"This section contains a very simple example of SPI usage. The procedure "
"<function>execq</function> takes an SQL command as its first argument and a "
"row count as its second, executes the command using <function>SPI_exec</"
"function> and returns the number of rows that were processed by the command. "
"You can find more complex examples for SPI in the source tree in "
"<filename>src/test/regress/regress.c</filename> and in the <xref linkend="
"\"contrib-spi\"/> module."
msgstr ""
"Этот раздел содержит очень простой пример использования SPI. Процедура "
"<function>execq</function> принимает в качестве первого аргумента команду "
"SQL, а в качестве второго число строк, выполняет команду, вызывая "
"<function>SPI_exec</function>, и возвращает число строк, обработанных этой "
"командой. Более сложные примеры работы с SPI вы можете найти в <filename>src/"
"test/regress/regress.c</filename> в дереве исходного кода, а также в модуле "
"<xref linkend=\"contrib-spi\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4350(programlisting)
#, no-wrap
msgid ""
"#include \"postgres.h\"\n"
"\n"
"#include \"executor/spi.h\"\n"
"#include \"utils/builtins.h\"\n"
"\n"
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif\n"
"\n"
"int64 execq(text *sql, int cnt);\n"
"\n"
"int64\n"
"execq(text *sql, int cnt)\n"
"{\n"
"    char *command;\n"
"    int ret;\n"
"    uint64 proc;\n"
"\n"
"    /* Convert given text object to a C string */\n"
"    command = text_to_cstring(sql);\n"
"\n"
"    SPI_connect();\n"
"\n"
"    ret = SPI_exec(command, cnt);\n"
"\n"
"    proc = SPI_processed;\n"
"    /*\n"
"     * If some rows were fetched, print them via elog(INFO).\n"
"     */\n"
"    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)\n"
"    {\n"
"        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;\n"
"        SPITupleTable *tuptable = SPI_tuptable;\n"
"        char buf[8192];\n"
"        uint64 j;\n"
"\n"
"        for (j = 0; j &lt; proc; j++)\n"
"        {\n"
"            HeapTuple tuple = tuptable-&gt;vals[j];\n"
"            int i;\n"
"\n"
"            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)\n"
"                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), \" %s%s\",\n"
"                        SPI_getvalue(tuple, tupdesc, i),\n"
"                        (i == tupdesc-&gt;natts) ? \" \" : \" |\");\n"
"            elog(INFO, \"EXECQ: %s\", buf);\n"
"        }\n"
"    }\n"
"\n"
"    SPI_finish();\n"
"    pfree(command);\n"
"\n"
"    return (proc);\n"
"}"
msgstr ""
"#include \"postgres.h\"\n"
"\n"
"#include \"executor/spi.h\"\n"
"#include \"utils/builtins.h\"\n"
"\n"
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif\n"
"\n"
"int64 execq(text *sql, int cnt);\n"
"\n"
"int64\n"
"execq(text *sql, int cnt)\n"
"{\n"
"    char *command;\n"
"    int ret;\n"
"    uint64 proc;\n"
"\n"
"    /* Преобразовать данный текстовый объект в строку C */\n"
"    command = text_to_cstring(sql);\n"
"\n"
"    SPI_connect();\n"
"\n"
"    ret = SPI_exec(command, cnt);\n"
"\n"
"    proc = SPI_processed;\n"
"    /*\n"
"     * Если были выбраны какие-то строки, вывести их через elog(INFO).\n"
"     */\n"
"    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)\n"
"    {\n"
"        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;\n"
"        SPITupleTable *tuptable = SPI_tuptable;\n"
"        char buf[8192];\n"
"        uint64 j;\n"
"\n"
"        for (j = 0; j &lt; proc; j++)\n"
"        {\n"
"            HeapTuple tuple = tuptable-&gt;vals[j];\n"
"            int i;\n"
"\n"
"            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)\n"
"                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), \" %s%s\",\n"
"                        SPI_getvalue(tuple, tupdesc, i),\n"
"                        (i == tupdesc-&gt;natts) ? \" \" : \" |\");\n"
"            elog(INFO, \"EXECQ: %s\", buf);\n"
"        }\n"
"    }\n"
"\n"
"    SPI_finish();\n"
"    pfree(command);\n"
"\n"
"    return (proc);\n"
"}"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4407(para)
msgid ""
"(This function uses call convention version 0, to make the example easier to "
"understand. In real applications you should use the new version 1 interface.)"
msgstr ""
"(В этой функции используется соглашение о вызовах версии 0, чтобы этот "
"пример было легче понять. В реальных приложениях вы должны использовать "
"новый интерфейс версии 1.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4417(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION execq(text, integer) RETURNS int8\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C STRICT;"
msgstr ""
"CREATE FUNCTION execq(text, integer) RETURNS int8\n"
"    AS '<replaceable>имя_файла</replaceable>'\n"
"    LANGUAGE C STRICT;"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4413(para)
msgid ""
"This is how you declare the function after having compiled it into a shared "
"library (details are in <xref linkend=\"dfunc\"/>.): <placeholder-1/>"
msgstr ""
"Так эта функция будет объявляться после того, как она будет скомпилирована в "
"разделяемую библиотеку (подробности в <xref remap=\"6\" linkend=\"dfunc\"/"
">): <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4427(programlisting)
#, no-wrap
msgid ""
"=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);\n"
" execq\n"
"-------\n"
"     0\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));\n"
"INSERT 0 1\n"
"=&gt; SELECT execq('SELECT * FROM a', 0);\n"
"INFO:  EXECQ:  0    -- inserted by execq\n"
"INFO:  EXECQ:  1    -- returned by execq and inserted by upper INSERT\n"
"\n"
" execq\n"
"-------\n"
"     2\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);\n"
" execq\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('SELECT * FROM a', 10);\n"
"INFO:  EXECQ:  0\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2    -- 0 + 2, only one row inserted - as specified\n"
"\n"
" execq\n"
"-------\n"
"     3              -- 10 is the max value only, 3 is the real number of rows\n"
"(1 row)\n"
"\n"
"=&gt; DELETE FROM a;\n"
"DELETE 3\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1                  -- no rows in a (0) + 1\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INFO:  EXECQ:  1\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2                  -- there was one row in a + 1\n"
"(2 rows)\n"
"\n"
"-- This demonstrates the data changes visibility rule:\n"
"\n"
"=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  2\n"
"INSERT 0 2\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2\n"
" 2                  -- 2 rows * 1 (x in first row)\n"
" 6                  -- 3 rows (2 + 1 just inserted) * 2 (x in second row)\n"
"(4 rows)               ^^^^^^\n"
"                       rows visible to execq() in different invocations"
msgstr ""
"=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);\n"
" execq\n"
"-------\n"
"     0\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));\n"
"INSERT 0 1\n"
"=&gt; SELECT execq('SELECT * FROM a', 0);\n"
"INFO:  EXECQ:  0    -- вставлено функцией execq\n"
"INFO:  EXECQ:  1    -- возвращено функцией execq и вставлено командой INSERT\n"
"\n"
" execq\n"
"-------\n"
"     2\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);\n"
" execq\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('SELECT * FROM a', 10);\n"
"INFO:  EXECQ:  0\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2    -- 0 + 2, вставлена только одна строка - как указано\n"
"\n"
" execq\n"
"-------\n"
"     3              -- 10 — только максимальное значение, 3 — реальное число строк\n"
"(1 row)\n"
"\n"
"=&gt; DELETE FROM a;\n"
"DELETE 3\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1                  -- нет строк в a (0) + 1\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INFO:  EXECQ:  1\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2                  -- была одна строка в a + 1\n"
"(2 rows)\n"
"\n"
"-- Этот пример демонстрирует правило видимости изменений в данных:\n"
"\n"
"=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  2\n"
"INSERT 0 2\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2\n"
" 2                  -- 2 строки * 1 (x в первой в строке)\n"
" 6                  -- 3 строки (2 + 1 только вставленная) * 2 (x во второй строке)\n"
"(4 rows)               ^^^^^^\n"
"                       строки, видимые в execq() при разных вызовах"

#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:4424(para)
msgid "Here is a sample session: <placeholder-1/>"
msgstr "Демонстрация использования: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: spi.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: spi.xml:95(para)
msgid ""
"If your procedure is already connected, <function>SPI_connect</function> "
"will return the error code <returnvalue>SPI_ERROR_CONNECT</returnvalue>. "
"This could happen if a procedure that has called <function>SPI_connect</"
"function> directly calls another procedure that calls <function>SPI_connect</"
"function>. While recursive calls to the <acronym>SPI</acronym> manager are "
"permitted when an SQL command called through SPI invokes another function "
"that uses <acronym>SPI</acronym>, directly nested calls to "
"<function>SPI_connect</function> and <function>SPI_finish</function> are "
"forbidden. (But see <function>SPI_push</function> and <function>SPI_pop</"
"function>.)"
msgstr ""
"Если ваша процедура уже подключена, <function>SPI_connect</function> "
"возвратит код ошибки <returnvalue>SPI_ERROR_CONNECT</returnvalue>. Это может "
"произойти, если процедура, которая вызвала <function>SPI_connect</function>, "
"непосредственно вызывает другую процедуру, снова вызывающую "
"<function>SPI_connect</function>. Хотя рекурсивные обращения к менеджеру "
"<acronym>SPI</acronym>, когда команда SQL, выполняемая через SPI, вызывает "
"функцию, тоже использующую <acronym>SPI</acronym>, возможны, "
"непосредственные вложенные вызовы <function>SPI_connect</function> и "
"<function>SPI_finish</function> запрещены. (Но обратите внимание на "
"<function>SPI_push</function> и <function>SPI_pop</function>.)"

#. +> REL9_6_3 REL9_6
#: spi.xml:169(para)
msgid ""
"If <function>SPI_finish</function> is called without having a valid "
"connection, it will return <symbol>SPI_ERROR_UNCONNECTED</symbol>. There is "
"no fundamental problem with this; it means that the SPI manager has nothing "
"to do."
msgstr ""
"Если <function>SPI_finish</function> вызывается в отсутствие установленного "
"подключения, она возвращает <symbol>SPI_ERROR_UNCONNECTED</symbol>. В этом "
"нет никакой серьёзной проблемы, это просто означает, что менеджеру SPI "
"нечего делать."

#. +> REL9_6_3 REL9_6
#: spi.xml:205(indexterm)
msgid "<primary>SPI_push</primary>"
msgstr "<primary>SPI_push</primary>"

#. +> REL9_6_3 REL9_6
#: spi.xml:208(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_push"
msgstr "SPI_push"

#. +> REL9_6_3 REL9_6
#: spi.xml:213(refname)
msgctxt "refname"
msgid "SPI_push"
msgstr "SPI_push"

#. +> REL9_6_3 REL9_6
#: spi.xml:214(refpurpose)
msgid "push SPI stack to allow recursive SPI usage"
msgstr "поднять стек SPI для входа в рекурсивное использование SPI"

#. +> REL9_6_3 REL9_6
#: spi.xml:218(synopsis)
#, no-wrap
msgid "void SPI_push(void)"
msgstr "void SPI_push(void)"

#. +> REL9_6_3 REL9_6
#: spi.xml:226(para)
msgid ""
"<function>SPI_push</function> should be called before executing another "
"procedure that might itself wish to use SPI. After <function>SPI_push</"
"function>, SPI is no longer in a <quote>connected</quote> state, and SPI "
"function calls will be rejected unless a fresh <function>SPI_connect</"
"function> is done. This ensures a clean separation between your procedure's "
"SPI state and that of another procedure you call. After the other procedure "
"returns, call <function>SPI_pop</function> to restore access to your own SPI "
"state."
msgstr ""
"Функция <function>SPI_push</function> должна вызываться перед выполнением "
"другой процедуры, которая может пожелать самостоятельно использовать SPI. "
"После <function>SPI_push</function>, SPI выходит из <quote>подключённого</"
"quote> состояния, и последующие вызовы функций SPI не будут выполняться, "
"пока вновь не будет вызвана <function>SPI_connect</function>. Это "
"обеспечивает чёткое разделение состояний SPI между вашей процедурой и "
"процедурой, которую вы вызываете. После завершения другой процедуры вызовите "
"<function>SPI_pop</function>, чтобы восстановить доступ к вашему состоянию "
"SPI."

#. +> REL9_6_3 REL9_6
#: spi.xml:237(para)
msgid ""
"Note that <function>SPI_execute</function> and related functions "
"automatically do the equivalent of <function>SPI_push</function> before "
"passing control back to the SQL execution engine, so it is not necessary for "
"you to worry about this when using those functions. Only when you are "
"directly calling arbitrary code that might contain <function>SPI_connect</"
"function> calls do you need to issue <function>SPI_push</function> and "
"<function>SPI_pop</function>."
msgstr ""
"Заметьте, что <function>SPI_execute</function> и связанные функции "
"автоматически выполняют действие, равнозначное вызову <function>SPI_push</"
"function>, до передачи управления механизму исполнения SQL, так что вызывая "
"эти функции, можно не беспокоиться об этом. Выполнять <function>SPI_push</"
"function> и <function>SPI_pop</function> требуется, только если вы "
"непосредственно вызываете произвольный код, который может содержать вызовы "
"<function>SPI_connect</function>."

#. +> REL9_6_3 REL9_6
#: spi.xml:253(indexterm)
msgid "<primary>SPI_pop</primary>"
msgstr "<primary>SPI_pop</primary>"

#. +> REL9_6_3 REL9_6
#: spi.xml:256(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_pop"
msgstr "SPI_pop"

#. +> REL9_6_3 REL9_6
#: spi.xml:261(refname)
msgctxt "refname"
msgid "SPI_pop"
msgstr "SPI_pop"

#. +> REL9_6_3 REL9_6
#: spi.xml:262(refpurpose)
msgid "pop SPI stack to return from recursive SPI usage"
msgstr "опустить стек SPI для выхода из рекурсивного использования SPI"

#. +> REL9_6_3 REL9_6
#: spi.xml:266(synopsis)
#, no-wrap
msgid "void SPI_pop(void)"
msgstr "void SPI_pop(void)"

#. +> REL9_6_3 REL9_6
#: spi.xml:274(para)
msgid ""
"<function>SPI_pop</function> pops the previous environment from the SPI call "
"stack. See <function>SPI_push</function>."
msgstr ""
"<function>SPI_pop</function> восстанавливает предыдущее окружение из стека "
"вызовов SPI. См. <function>SPI_push</function>."

#. +> REL9_6_3 REL9_6
#: spi.xml:2894(para)
msgid ""
"Column number (count starts at 1), or <symbol>SPI_ERROR_NOATTRIBUTE</symbol> "
"if the named column was not found."
msgstr ""
"Номер столбца (начиная с 1), либо <symbol>SPI_ERROR_NOATTRIBUTE</symbol>, "
"если столбец с заданным именем не найден."

#. +> REL9_6_3 REL9_6
#: spi.xml:3353(para)
msgid ""
"However, if your procedure needs to return an object in allocated memory "
"(such as a value of a pass-by-reference data type), you cannot allocate that "
"memory using <function>palloc</function>, at least not while you are "
"connected to SPI. If you try, the object will be deallocated by "
"<function>SPI_finish</function>, and your procedure will not work reliably. "
"To solve this problem, use <function>SPI_palloc</function> to allocate "
"memory for your return object. <function>SPI_palloc</function> allocates "
"memory in the <quote>upper executor context</quote>, that is, the memory "
"context that was current when <function>SPI_connect</function> was called, "
"which is precisely the right context for a value returned from your "
"procedure."
msgstr ""
"Однако, если ваша процедура должна вернуть объект в выделенной памяти (как "
"значение типа, передаваемого по ссылке), эту память нельзя выделять через "
"<function>palloc</function>, как минимум пока установлено подключение к SPI. "
"Если вы попытаетесь это сделать, объект будет освобождён при вызове "
"<function>SPI_finish</function> и ваша процедура не будет работать надёжно. "
"Для решения этой проблемы выделяйте память для возвращаемого объекта, "
"используя <function>SPI_palloc</function>. <function>SPI_palloc</function> "
"выделяет память в <quote>верхнем контексте исполнителя</quote>, то есть, в "
"контексте памяти, который был текущим при вызове <function>SPI_connect</"
"function>; именно этот контекст подходит для значения, возвращаемого из "
"процедуры."

#. +> REL9_6_3 REL9_6
#: spi.xml:3368(para)
msgid ""
"If <function>SPI_palloc</function> is called while the procedure is not "
"connected to SPI, then it acts the same as a normal <function>palloc</"
"function>. Before a procedure connects to the SPI manager, the current "
"memory context is the upper executor context, so all allocations made by the "
"procedure via <function>palloc</function> or by SPI utility functions are "
"made in this context."
msgstr ""
"Если <function>SPI_palloc</function> вызывается, когда процедура не "
"подключена к SPI, она действует как обычная функция <function>palloc</"
"function>. До подключения процедуры к менеджеру SPI текущим контекстом "
"является верхний контекст исполнителя, так что все операции выделения "
"памяти, выполняемые процедурой через <function>palloc</function> или "
"служебные функции SPI, производятся в этом контексте."

#. +> REL9_6_3 REL9_6
#: spi.xml:3378(para)
msgid ""
"When <function>SPI_connect</function> is called, the private context of the "
"procedure, which is created by <function>SPI_connect</function>, is made the "
"current context. All allocations made by <function>palloc</function>, "
"<function>repalloc</function>, or SPI utility functions (except for "
"<function>SPI_copytuple</function>, <function>SPI_returntuple</function>, "
"<function>SPI_modifytuple</function>, and <function>SPI_palloc</function>) "
"are made in this context. When a procedure disconnects from the SPI manager "
"(via <function>SPI_finish</function>) the current context is restored to the "
"upper executor context, and all allocations made in the procedure memory "
"context are freed and cannot be used any more."
msgstr ""
"Когда вызывается <function>SPI_connect</function>, текущим контекстом "
"становится частный контекст процедуры, создаваемый в <function>SPI_connect</"
"function>. Все операции выделения памяти, выполняемые функциями "
"<function>palloc</function>, <function>repalloc</function> или служебными "
"функциями SPI (за исключением <function>SPI_copytuple</function>, "
"<function>SPI_returntuple</function>, <function>SPI_modifytuple</function> и "
"<function>SPI_palloc</function>), производятся в этом контексте. Когда "
"процедура отключается от менеджера SPI (выполняя <function>SPI_finish</"
"function>), текущим контекстом снова становится верхний контекст "
"исполнителя, а вся память, выделенная в контексте процедуры, освобождается, "
"так что использовать её дальше нельзя."

#. +> REL9_6_3 REL9_6
#: spi.xml:3394(para)
msgid ""
"All functions described in this section can be used by both connected and "
"unconnected procedures. In an unconnected procedure, they act the same as "
"the underlying ordinary server functions (<function>palloc</function>, etc.)."
msgstr ""
"Все функции, описанные в этом разделе, могут использоваться и в "
"подключённых, и в неподключённых процедурах. В неподключённой процедуре они "
"действуют как обычные низкоуровневые серверные функции (<function>palloc</"
"function> и т. д.)."

#. +> REL9_6_3 REL9_6
#: spi.xml:3628(para)
msgid ""
"the copied row; <symbol>NULL</symbol> only if <parameter>tuple</parameter> "
"is <symbol>NULL</symbol>"
msgstr ""
"скопированная строка; <symbol>NULL</symbol>, только если <parameter>tuple</"
"parameter> — <symbol>NULL</symbol>"

#. +> REL9_6_3 REL9_6
#: spi.xml:3701(para)
msgid ""
"<type>HeapTupleHeader</type> pointing to copied row; <symbol>NULL</symbol> "
"only if <parameter>row</parameter> or <parameter>rowdesc</parameter> is "
"<symbol>NULL</symbol>"
msgstr ""
"<type>HeapTupleHeader</type>, указывающий на скопированную строку; "
"<symbol>NULL</symbol>, только если параметр <parameter>row</parameter> или "
"<parameter>rowdesc</parameter> — <symbol>NULL</symbol>"

#. +> REL9_6_3 REL9_6
#: spi.xml:3735(para)
msgid ""
"<function>SPI_modifytuple</function> creates a new row by substituting new "
"values for selected columns, copying the original row's columns at other "
"positions. The input row is not modified."
msgstr ""
"<function>SPI_modifytuple</function> создаёт новую строку, подставляя новые "
"значения для указанных столбцов и копируя исходное содержимое остальных "
"столбцов. Исходная строка не изменяется."

#. +> REL9_6_3 REL9_6
#: spi.xml:3846(para)
msgid ""
"if <parameter>colnum</parameter> contains an invalid column number (less "
"than or equal to 0 or greater than the number of column in <parameter>row</"
"parameter>)"
msgstr ""
"если <parameter>colnum</parameter> содержит недопустимый номер столбца "
"(меньше или равен 0, либо больше числа столбцов в строке <parameter>row</"
"parameter>)"
