# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: spi.xml:5(title)
msgid "Server Programming Interface"
msgstr "Интерфейс программирования сервера"

#: spi.xml:7(indexterm)
msgid "<primary>SPI</primary>"
msgstr "<primary>SPI</primary>"

#: spi.xml:11(para)
msgid ""
"The <firstterm>Server Programming Interface</firstterm> (<acronym>SPI</"
"acronym>) gives writers of user-defined <acronym>C</acronym> functions the "
"ability to run <acronym>SQL</acronym> commands inside their functions. "
"<acronym>SPI</acronym> is a set of interface functions to simplify access to "
"the parser, planner, and executor. <acronym>SPI</acronym> also does some "
"memory management."
msgstr ""
"<firstterm>Интерфейс программирования сервера</firstterm> (<acronym>SPI</"
"acronym>, Server Programming Interface) даёт разработчикам пользовательских "
"функций на <acronym>C</acronym> возможность запускать команды <acronym>SQL</"
"acronym> из своих функций. <acronym>SPI</acronym> представляет собой набор "
"интерфейсных функций, упрощающих доступ к анализатору, планировщику и "
"исполнителю запросов. В <acronym>SPI</acronym> есть также функции для "
"управления памятью."

#: spi.xml:23(para)
msgid ""
"The available procedural languages provide various means to execute SQL "
"commands from procedures. Most of these facilities are based on SPI, so this "
"documentation might be of use for users of those languages as well."
msgstr ""
"Доступные процедурные языки предоставляют различные средства для выполнения "
"SQL-команд из процедур. Большинство этих средств основаны на SPI, так что "
"эта документация будет полезна и тем, кто использует эти языки."

#: spi.xml:31(para)
msgid ""
"To avoid misunderstanding we'll use the term <quote>function</quote> when we "
"speak of <acronym>SPI</acronym> interface functions and <quote>procedure</"
"quote> for a user-defined C-function that is using <acronym>SPI</acronym>."
msgstr ""
"Во избежание недопонимания мы будем употреблять слово <quote>функция</"
"quote>, говоря о функциях <acronym>SPI</acronym>, и слово <quote>процедура</"
"quote>, говоря о пользовательских функциях, написанных на C, и использующих "
"<acronym>SPI</acronym>."

#: spi.xml:38(para)
msgid ""
"Note that if a command invoked via SPI fails, then control will not be "
"returned to your procedure. Rather, the transaction or subtransaction in "
"which your procedure executes will be rolled back. (This might seem "
"surprising given that the SPI functions mostly have documented error-return "
"conventions. Those conventions only apply for errors detected within the SPI "
"functions themselves, however.) It is possible to recover control after an "
"error by establishing your own subtransaction surrounding SPI calls that "
"might fail. This is not currently documented because the mechanisms required "
"are still in flux."
msgstr ""
"Учтите, что если команда, вызванная через SPI, прерывается ошибкой, "
"управление не возвращается в вашу процедуру. Вместо этого происходит откат "
"транзакции или подтранзакции, из которой вызывалась ваша процедура. (Это "
"может показаться удивительным, с учётом того, что для большинства функций "
"SPI описаны соглашения по возврату ошибок. Однако эти соглашения применимы "
"только к ошибкам, выявляемым в самих функциях SPI.) Получить управление "
"после ошибки можно, только организовав собственную подтранзакцию, окружающую "
"вызовы SPI, в которых возможна ошибка. В настоящее время этот подход не "
"документирован, так как требуемые для него механизмы окончательно ещё не "
"сформированы."

#: spi.xml:50(para)
msgid ""
"<acronym>SPI</acronym> functions return a nonnegative result on success "
"(either via a returned integer value or in the global variable "
"<varname>SPI_result</varname>, as described below). On error, a negative "
"result or <symbol>NULL</symbol> will be returned."
msgstr ""
"Функции <acronym>SPI</acronym> выдают неотрицательный результат в случае "
"успеха (либо через возвращаемое целочисленное значение, либо в глобальной "
"переменной <varname>SPI_result</varname>, как описано ниже). В случае ошибки "
"выдаётся отрицательный результат или <symbol>NULL</symbol>."

#: spi.xml:57(para)
msgid ""
"Source code files that use SPI must include the header file "
"<filename>executor/spi.h</filename>."
msgstr ""
"Файлы исходного кода, использующие SPI, должны включать заголовочный файл "
"<filename>executor/spi.h</filename>."

#: spi.xml:64(title)
msgid "Interface Functions"
msgstr "Интерфейсные функции"

#: spi.xml:67(indexterm)
msgid "<primary>SPI_connect</primary>"
msgstr "<primary>SPI_connect</primary>"

#: spi.xml:70(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_connect"
msgstr "SPI_connect"

#: spi.xml:71(manvolnum) spi.xml:143(manvolnum) spi.xml:209(manvolnum)
#: spi.xml:257(manvolnum) spi.xml:289(manvolnum) spi.xml:645(manvolnum)
#: spi.xml:711(manvolnum) spi.xml:864(manvolnum) spi.xml:1026(manvolnum)
#: spi.xml:1128(manvolnum) spi.xml:1216(manvolnum) spi.xml:1273(manvolnum)
#: spi.xml:1343(manvolnum) spi.xml:1412(manvolnum) spi.xml:1548(manvolnum)
#: spi.xml:1643(manvolnum) spi.xml:1747(manvolnum) spi.xml:1871(manvolnum)
#: spi.xml:2024(manvolnum) spi.xml:2120(manvolnum) spi.xml:2176(manvolnum)
#: spi.xml:2261(manvolnum) spi.xml:2336(manvolnum) spi.xml:2435(manvolnum)
#: spi.xml:2536(manvolnum) spi.xml:2588(manvolnum) spi.xml:2657(manvolnum)
#: spi.xml:2768(manvolnum) spi.xml:2835(manvolnum) spi.xml:2909(manvolnum)
#: spi.xml:2993(manvolnum) spi.xml:3088(manvolnum) spi.xml:3154(manvolnum)
#: spi.xml:3220(manvolnum) spi.xml:3273(manvolnum) spi.xml:3408(manvolnum)
#: spi.xml:3462(manvolnum) spi.xml:3532(manvolnum) spi.xml:3585(manvolnum)
#: spi.xml:3642(manvolnum) spi.xml:3717(manvolnum) spi.xml:3865(manvolnum)
#: spi.xml:3917(manvolnum) spi.xml:3984(manvolnum)
msgid "3"
msgstr "3"

#: spi.xml:75(refname)
msgctxt "refname"
msgid "SPI_connect"
msgstr "SPI_connect"

#: spi.xml:76(refpurpose)
msgid "connect a procedure to the SPI manager"
msgstr "подключить процедуру к менеджеру SPI"

#: spi.xml:80(synopsis)
#, no-wrap
msgid "int SPI_connect(void)"
msgstr "int SPI_connect(void)"

#: spi.xml:86(title) spi.xml:158(title) spi.xml:224(title) spi.xml:272(title)
#: spi.xml:304(title) spi.xml:660(title) spi.xml:729(title) spi.xml:879(title)
#: spi.xml:1042(title) spi.xml:1146(title) spi.xml:1232(title)
#: spi.xml:1289(title) spi.xml:1360(title) spi.xml:1428(title)
#: spi.xml:1566(title) spi.xml:1658(title) spi.xml:1764(title)
#: spi.xml:1890(title) spi.xml:2042(title) spi.xml:2135(title)
#: spi.xml:2191(title) spi.xml:2276(title) spi.xml:2352(title)
#: spi.xml:2451(title) spi.xml:2551(title) spi.xml:2603(title)
#: spi.xml:2672(title) spi.xml:2783(title) spi.xml:2850(title)
#: spi.xml:2924(title) spi.xml:3009(title) spi.xml:3103(title)
#: spi.xml:3169(title) spi.xml:3235(title) spi.xml:3288(title)
#: spi.xml:3423(title) spi.xml:3477(title) spi.xml:3547(title)
#: spi.xml:3600(title) spi.xml:3657(title) spi.xml:3733(title)
#: spi.xml:3880(title) spi.xml:3933(title) spi.xml:3999(title)
msgid "Description"
msgstr "Описание"

#: spi.xml:88(para)
msgid ""
"<function>SPI_connect</function> opens a connection from a procedure "
"invocation to the SPI manager. You must call this function if you want to "
"execute commands through SPI. Some utility SPI functions can be called from "
"unconnected procedures."
msgstr ""
"<function>SPI_connect</function> устанавливает подключение вызова процедуры "
"к менеджеру SPI. Эту функцию необходимо вызвать, если вы хотите выполнять "
"команды через SPI. Некоторые вспомогательные функции SPI могут вызываться из "
"неподключённых процедур."

#: spi.xml:95(para)
msgid ""
"If your procedure is already connected, <function>SPI_connect</function> "
"will return the error code <returnvalue>SPI_ERROR_CONNECT</returnvalue>. "
"This could happen if a procedure that has called <function>SPI_connect</"
"function> directly calls another procedure that calls <function>SPI_connect</"
"function>. While recursive calls to the <acronym>SPI</acronym> manager are "
"permitted when an SQL command called through SPI invokes another function "
"that uses <acronym>SPI</acronym>, directly nested calls to "
"<function>SPI_connect</function> and <function>SPI_finish</function> are "
"forbidden. (But see <function>SPI_push</function> and <function>SPI_pop</"
"function>.)"
msgstr ""
"Если ваша процедура уже подключена, <function>SPI_connect</function> "
"возвратит код ошибки <returnvalue>SPI_ERROR_CONNECT</returnvalue>. Это может "
"произойти, если процедура, которая вызвала <function>SPI_connect</function>, "
"непосредственно вызывает другую процедуру, снова вызывающую "
"<function>SPI_connect</function>. Хотя рекурсивные обращения к менеджеру "
"<acronym>SPI</acronym>, когда команда SQL, выполняемая через SPI, вызывает "
"функцию, тоже использующую <acronym>SPI</acronym>, возможны, "
"непосредственные вложенные вызовы <function>SPI_connect</function> и "
"<function>SPI_finish</function> запрещены. (Но обратите внимание на "
"<function>SPI_push</function> и <function>SPI_pop</function>.)"

#: spi.xml:112(title) spi.xml:178(title) spi.xml:459(title) spi.xml:696(title)
#: spi.xml:843(title) spi.xml:953(title) spi.xml:1098(title)
#: spi.xml:1200(title) spi.xml:1256(title) spi.xml:1323(title)
#: spi.xml:1391(title) spi.xml:1504(title) spi.xml:1622(title)
#: spi.xml:1726(title) spi.xml:1855(title) spi.xml:2008(title)
#: spi.xml:2104(title) spi.xml:2160(title) spi.xml:2235(title)
#: spi.xml:2401(title) spi.xml:2501(title) spi.xml:2630(title)
#: spi.xml:2700(title) spi.xml:2817(title) spi.xml:2892(title)
#: spi.xml:2973(title) spi.xml:3066(title) spi.xml:3137(title)
#: spi.xml:3202(title) spi.xml:3260(title) spi.xml:3315(title)
#: spi.xml:3447(title) spi.xml:3516(title) spi.xml:3626(title)
#: spi.xml:3699(title) spi.xml:3820(title) spi.xml:4024(title)
msgid "Return Value"
msgstr "Возвращаемое значение"

#: spi.xml:116(symbol)
msgid "SPI_OK_CONNECT"
msgstr "SPI_OK_CONNECT"

#: spi.xml:118(para)
msgid "on success"
msgstr "при успехе"

#: spi.xml:125(symbol)
msgid "SPI_ERROR_CONNECT"
msgstr "SPI_ERROR_CONNECT"

#: spi.xml:127(para)
msgid "on error"
msgstr "при ошибке"

#: spi.xml:139(indexterm)
msgid "<primary>SPI_finish</primary>"
msgstr "<primary>SPI_finish</primary>"

#: spi.xml:142(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_finish"
msgstr "SPI_finish"

#: spi.xml:147(refname)
msgctxt "refname"
msgid "SPI_finish"
msgstr "SPI_finish"

#: spi.xml:148(refpurpose)
msgid "disconnect a procedure from the SPI manager"
msgstr "отключить процедуру от менеджера SPI"

#: spi.xml:152(synopsis)
#, no-wrap
msgid "int SPI_finish(void)"
msgstr "int SPI_finish(void)"

#: spi.xml:160(para)
msgid ""
"<function>SPI_finish</function> closes an existing connection to the SPI "
"manager. You must call this function after completing the SPI operations "
"needed during your procedure's current invocation. You do not need to worry "
"about making this happen, however, if you abort the transaction via "
"<literal>elog(ERROR)</literal>. In that case SPI will clean itself up "
"automatically."
msgstr ""
"<function>SPI_finish</function> закрывает текущее соединение с менеджером "
"SPI. Эту функцию необходимо вызывать после завершения операций SPI, которые "
"должны выполняться в текущем вызове процедуры. Однако, если вы прерываете "
"транзакцию, выполняя <literal>elog(ERROR)</literal>, о закрытии соединения "
"можно не беспокоиться. В этом случае SPI произведёт очистку автоматически."

#: spi.xml:169(para)
msgid ""
"If <function>SPI_finish</function> is called without having a valid "
"connection, it will return <symbol>SPI_ERROR_UNCONNECTED</symbol>. There is "
"no fundamental problem with this; it means that the SPI manager has nothing "
"to do."
msgstr ""
"Если <function>SPI_finish</function> вызывается в отсутствие установленного "
"подключения, она возвращает <symbol>SPI_ERROR_UNCONNECTED</symbol>. В этом "
"нет никакой серьёзной проблемы, это просто означает, что менеджеру SPI "
"нечего делать."

#: spi.xml:182(symbol)
msgid "SPI_OK_FINISH"
msgstr "SPI_OK_FINISH"

#: spi.xml:184(para)
msgid "if properly disconnected"
msgstr "если отключение выполнено корректно"

#: spi.xml:191(symbol) spi.xml:612(symbol) spi.xml:2717(symbol)
msgid "SPI_ERROR_UNCONNECTED"
msgstr "SPI_ERROR_UNCONNECTED"

#: spi.xml:193(para) spi.xml:614(para) spi.xml:2719(para)
msgid "if called from an unconnected procedure"
msgstr "если вызывается из неподключённой процедуры"

#: spi.xml:205(indexterm)
msgid "<primary>SPI_push</primary>"
msgstr "<primary>SPI_push</primary>"

#: spi.xml:208(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_push"
msgstr "SPI_push"

#: spi.xml:213(refname)
msgctxt "refname"
msgid "SPI_push"
msgstr "SPI_push"

#: spi.xml:214(refpurpose)
msgid "push SPI stack to allow recursive SPI usage"
msgstr "поднять стек SPI для входа в рекурсивное использование SPI"

#: spi.xml:218(synopsis)
#, no-wrap
msgid "void SPI_push(void)"
msgstr "void SPI_push(void)"

#: spi.xml:226(para)
msgid ""
"<function>SPI_push</function> should be called before executing another "
"procedure that might itself wish to use SPI. After <function>SPI_push</"
"function>, SPI is no longer in a <quote>connected</quote> state, and SPI "
"function calls will be rejected unless a fresh <function>SPI_connect</"
"function> is done. This ensures a clean separation between your procedure's "
"SPI state and that of another procedure you call. After the other procedure "
"returns, call <function>SPI_pop</function> to restore access to your own SPI "
"state."
msgstr ""
"Функция <function>SPI_push</function> должна вызываться перед выполнением "
"другой процедуры, которая может пожелать самостоятельно использовать SPI. "
"После <function>SPI_push</function>, SPI выходит из <quote>подключённого</"
"quote> состояния, и последующие вызовы функций SPI не будут выполняться, "
"пока вновь не будет вызвана <function>SPI_connect</function>. Это "
"обеспечивает чёткое разделение состояний SPI между вашей процедурой и "
"процедурой, которую вы вызываете. После завершения другой процедуры вызовите "
"<function>SPI_pop</function>, чтобы восстановить доступ к вашему состоянию "
"SPI."

#: spi.xml:237(para)
msgid ""
"Note that <function>SPI_execute</function> and related functions "
"automatically do the equivalent of <function>SPI_push</function> before "
"passing control back to the SQL execution engine, so it is not necessary for "
"you to worry about this when using those functions. Only when you are "
"directly calling arbitrary code that might contain <function>SPI_connect</"
"function> calls do you need to issue <function>SPI_push</function> and "
"<function>SPI_pop</function>."
msgstr ""
"Заметьте, что <function>SPI_execute</function> и связанные функции "
"автоматически выполняют действие, равнозначное вызову <function>SPI_push</"
"function>, до передачи управления механизму исполнения SQL, так что вызывая "
"эти функции, можно не беспокоиться об этом. Выполнять <function>SPI_push</"
"function> и <function>SPI_pop</function> требуется, только если вы "
"непосредственно вызываете произвольный код, который может содержать вызовы "
"<function>SPI_connect</function>."

#: spi.xml:253(indexterm)
msgid "<primary>SPI_pop</primary>"
msgstr "<primary>SPI_pop</primary>"

#: spi.xml:256(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_pop"
msgstr "SPI_pop"

#: spi.xml:261(refname)
msgctxt "refname"
msgid "SPI_pop"
msgstr "SPI_pop"

#: spi.xml:262(refpurpose)
msgid "pop SPI stack to return from recursive SPI usage"
msgstr "опустить стек SPI для выхода из рекурсивного использования SPI"

#: spi.xml:266(synopsis)
#, no-wrap
msgid "void SPI_pop(void)"
msgstr "void SPI_pop(void)"

#: spi.xml:274(para)
msgid ""
"<function>SPI_pop</function> pops the previous environment from the SPI call "
"stack. See <function>SPI_push</function>."
msgstr ""
"<function>SPI_pop</function> восстанавливает предыдущее окружение из стека "
"вызовов SPI. См. <function>SPI_push</function>."

#: spi.xml:285(indexterm)
msgid "<primary>SPI_execute</primary>"
msgstr "<primary>SPI_execute</primary>"

#: spi.xml:288(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute"
msgstr "SPI_execute"

#: spi.xml:293(refname)
msgctxt "refname"
msgid "SPI_execute"
msgstr "SPI_execute"

#: spi.xml:294(refpurpose)
msgid "execute a command"
msgstr "выполнить команду"

#: spi.xml:299(parameter) spi.xml:431(parameter) spi.xml:655(parameter)
#: spi.xml:675(parameter) spi.xml:721(parameter) spi.xml:764(parameter)
#: spi.xml:874(parameter) spi.xml:923(parameter) spi.xml:1036(parameter)
#: spi.xml:1059(parameter) spi.xml:1138(parameter) spi.xml:1162(parameter)
#: spi.xml:1882(parameter) spi.xml:1930(parameter)
msgid "command"
msgstr "command"

#: spi.xml:299(parameter) spi.xml:440(parameter) spi.xml:724(parameter)
#: spi.xml:824(parameter) spi.xml:1423(parameter) spi.xml:1485(parameter)
#: spi.xml:1560(parameter) spi.xml:1603(parameter) spi.xml:1759(parameter)
#: spi.xml:1846(parameter) spi.xml:1885(parameter) spi.xml:1990(parameter)
#: spi.xml:2037(parameter) spi.xml:2095(parameter)
msgid "read_only"
msgstr "read_only"

#: spi.xml:299(parameter) spi.xml:447(parameter) spi.xml:655(parameter)
#: spi.xml:684(parameter) spi.xml:724(parameter) spi.xml:831(parameter)
#: spi.xml:1423(parameter) spi.xml:1492(parameter) spi.xml:1561(parameter)
#: spi.xml:1610(parameter) spi.xml:1653(parameter) spi.xml:1714(parameter)
#: spi.xml:2186(parameter) spi.xml:2224(parameter) spi.xml:2271(parameter)
#: spi.xml:2309(parameter) spi.xml:2347(parameter) spi.xml:2386(parameter)
#: spi.xml:2446(parameter) spi.xml:2486(parameter)
msgid "count"
msgstr "count"

#: spi.xml:298(synopsis)
#, no-wrap
msgid "int SPI_execute(const char * <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"
msgstr "int SPI_execute(const char * <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"

#: spi.xml:306(para)
msgid ""
"<function>SPI_execute</function> executes the specified SQL command for "
"<parameter>count</parameter> rows. If <parameter>read_only</parameter> is "
"<literal>true</literal>, the command must be read-only, and execution "
"overhead is somewhat reduced."
msgstr ""
"<function>SPI_execute</function> выполняет заданную команду SQL для "
"получения строк в количестве, ограниченном <parameter>count</parameter>. С "
"параметром <parameter>read_only</parameter>, равным <literal>true</literal>, "
"команда должна только читать данные; это несколько сокращает издержки на её "
"выполнение."

#: spi.xml:313(para)
msgid "This function can only be called from a connected procedure."
msgstr "Эту функцию можно вызывать только из подключённой процедуры."

#: spi.xml:323(programlisting)
#, no-wrap
msgid "SPI_execute(\"SELECT * FROM foo\", true, 5);"
msgstr "SPI_execute(\"SELECT * FROM foo\", true, 5);"

#: spi.xml:328(programlisting)
#, no-wrap
msgid "SPI_execute(\"INSERT INTO foo SELECT * FROM bar\", false, 5);"
msgstr "SPI_execute(\"INSERT INTO foo SELECT * FROM bar\", false, 5);"

#: spi.xml:333(programlisting)
#, no-wrap
msgid "SPI_execute(\"INSERT INTO foo SELECT * FROM bar RETURNING *\", false, 5);"
msgstr "SPI_execute(\"INSERT INTO foo SELECT * FROM bar RETURNING *\", false, 5);"

#: spi.xml:317(para)
msgid ""
"If <parameter>count</parameter> is zero then the command is executed for all "
"rows that it applies to. If <parameter>count</parameter> is greater than "
"zero, then no more than <parameter>count</parameter> rows will be retrieved; "
"execution stops when the count is reached, much like adding a "
"<literal>LIMIT</literal> clause to the query. For example, <placeholder-1/> "
"will retrieve at most 5 rows from the table. Note that such a limit is only "
"effective when the command actually returns rows. For example, "
"<placeholder-2/> inserts all rows from <structname>bar</structname>, "
"ignoring the <parameter>count</parameter> parameter. However, with "
"<placeholder-3/> at most 5 rows would be inserted, since execution would "
"stop after the fifth <literal>RETURNING</literal> result row is retrieved."
msgstr ""
"Если <parameter>count</parameter> равен 0, команда выполняется для всех "
"строк, к которым она применима. Если <parameter>count</parameter> больше "
"нуля, будет получено не более чем <parameter>count</parameter> строк; "
"выполнение команды остановится при достижении этого предела, практически так "
"же, как и с предложением <literal>LIMIT</literal> в запросе. Например, "
"команда: <placeholder-1/> получит из таблицы не более 5 строк. Заметьте, что "
"это ограничение действует, только когда команда действительно возвращает "
"строки. Например, эта команда: <placeholder-2/> вставляет все строки из "
"<structname>bar</structname>, игнорируя параметр <parameter>count</"
"parameter>. Однако, команда <placeholder-3/> вставит не более 5 строк, так "
"как её выполнение будет остановлено после получения пятой строки, выданной "
"предложением <literal>RETURNING</literal>."

#: spi.xml:340(para)
msgid ""
"You can pass multiple commands in one string; <function>SPI_execute</"
"function> returns the result for the command executed last. The "
"<parameter>count</parameter> limit applies to each command separately (even "
"though only the last result will actually be returned). The limit is not "
"applied to any hidden commands generated by rules."
msgstr ""
"В одной строке можно передать несколько команд; <function>SPI_execute</"
"function> возвращает результат команды, выполненной последней. Параметр "
"<parameter>count</parameter> при этом будет применяться к каждой команде по "
"отдельности (несмотря даже на то, что возвращён будет только последний "
"результат). Это ограничение не будет распространяться на скрытые команды, "
"генерируемые правилами."

#: spi.xml:349(para)
msgid ""
"When <parameter>read_only</parameter> is <literal>false</literal>, "
"<function>SPI_execute</function> increments the command counter and computes "
"a new <firstterm>snapshot</firstterm> before executing each command in the "
"string. The snapshot does not actually change if the current transaction "
"isolation level is <literal>SERIALIZABLE</literal> or <literal>REPEATABLE "
"READ</literal>, but in <literal>READ COMMITTED</literal> mode the snapshot "
"update allows each command to see the results of newly committed "
"transactions from other sessions. This is essential for consistent behavior "
"when the commands are modifying the database."
msgstr ""
"Когда параметр <parameter>read_only</parameter> равен <literal>false</"
"literal>, <function>SPI_execute</function> увеличивает счётчик команд и "
"получает новый <firstterm>снимок</firstterm> перед выполнением каждой "
"очередной команды в строке. Этот снимок фактически не меняется при текущем "
"уровне изоляции транзакций <literal>SERIALIZABLE</literal> или "
"<literal>REPEATABLE READ</literal>, но в режиме <literal>READ COMMITTED</"
"literal> после обновления снимка очередная команда может видеть результаты "
"только что зафиксированных транзакций из других сеансов. Это важно для "
"согласованного поведения, когда команды модифицируют базу данных."

#: spi.xml:361(para)
msgid ""
"When <parameter>read_only</parameter> is <literal>true</literal>, "
"<function>SPI_execute</function> does not update either the snapshot or the "
"command counter, and it allows only plain <command>SELECT</command> commands "
"to appear in the command string. The commands are executed using the "
"snapshot previously established for the surrounding query. This execution "
"mode is somewhat faster than the read/write mode due to eliminating per-"
"command overhead. It also allows genuinely <firstterm>stable</firstterm> "
"functions to be built: since successive executions will all use the same "
"snapshot, there will be no change in the results."
msgstr ""
"Когда параметр <parameter>read_only</parameter> равен <literal>true</"
"literal>, <function>SPI_execute</function> не обновляет снимок и не "
"увеличивает счётчик команд, и допускает в строке команд только "
"<command>SELECT</command>. Заданные команды выполняются со снимком, ранее "
"полученным для окружающего запроса. Этот режим выполнения несколько быстрее "
"режима чтения/записи вследствие исключения издержек, связанных с отдельными "
"командами. Он также позволяет создавать подлинно <firstterm>стабильные</"
"firstterm> функции: так как последующие вызовы в транзакции будут "
"использовать один снимок, результаты команд не изменятся."

#: spi.xml:373(para)
msgid ""
"It is generally unwise to mix read-only and read-write commands within a "
"single function using SPI; that could result in very confusing behavior, "
"since the read-only queries would not see the results of any database "
"updates done by the read-write queries."
msgstr ""
"Смешивать команды, только читающие, с командами, читающими и пишущими, в "
"одной процедуре, использующей SPI, обычно неразумно; запросы только на "
"чтение не увидят результатов изменений в базе данных, произведённых пишущими "
"запросами."

#: spi.xml:380(para)
msgid ""
"The actual number of rows for which the (last) command was executed is "
"returned in the global variable <varname>SPI_processed</varname>. If the "
"return value of the function is <symbol>SPI_OK_SELECT</symbol>, "
"<symbol>SPI_OK_INSERT_RETURNING</symbol>, <symbol>SPI_OK_DELETE_RETURNING</"
"symbol>, or <symbol>SPI_OK_UPDATE_RETURNING</symbol>, then you can use the "
"global pointer <literal>SPITupleTable *SPI_tuptable</literal> to access the "
"result rows. Some utility commands (such as <command>EXPLAIN</command>) also "
"return row sets, and <literal>SPI_tuptable</literal> will contain the result "
"in these cases too. Some utility commands (<command>COPY</command>, "
"<command>CREATE TABLE AS</command>) don't return a row set, so "
"<literal>SPI_tuptable</literal> is NULL, but they still return the number of "
"rows processed in <varname>SPI_processed</varname>."
msgstr ""
"Число строк, которые были фактически обработаны командой (последней), "
"возвращается в глобальной переменной <varname>SPI_processed</varname>. Если "
"эта функция возвращает значение <symbol>SPI_OK_SELECT</symbol>, "
"<symbol>SPI_OK_INSERT_RETURNING</symbol>, <symbol>SPI_OK_DELETE_RETURNING</"
"symbol> или <symbol>SPI_OK_UPDATE_RETURNING</symbol>, вы можете обратиться "
"по глобальному указателю <literal>SPITupleTable *SPI_tuptable</literal> и "
"прочитать строки результата. Некоторые служебные команды (например, "
"<command>EXPLAIN</command>) также возвращают наборы строк, и "
"<literal>SPI_tuptable</literal> будет содержать их результаты и в этих "
"случаях. Другие вспомогательные команды (<command>COPY</command>, "
"<command>CREATE TABLE AS</command>) не возвращают набор строк, так что "
"указатель <literal>SPI_tuptable</literal> равен NULL, но они так же "
"возвращают число обработанных строк в <varname>SPI_processed</varname>."

#: spi.xml:400(programlisting)
#, no-wrap
msgid ""
"typedef struct\n"
"{\n"
"    MemoryContext tuptabcxt;    /* memory context of result table */\n"
"    uint64      alloced;        /* number of alloced vals */\n"
"    uint64      free;           /* number of free vals */\n"
"    TupleDesc   tupdesc;        /* row descriptor */\n"
"    HeapTuple  *vals;           /* rows */\n"
"} SPITupleTable;"
msgstr ""
"typedef struct\n"
"{\n"
"    MemoryContext tuptabcxt;    /* контекст таблицы результатов в памяти */\n"
"    uint64      alloced;        /* число занятых значений */\n"
"    uint64      free;           /* число свободных значений */\n"
"    TupleDesc   tupdesc;        /* дескриптор строки */\n"
"    HeapTuple  *vals;           /* данные строк */\n"
"} SPITupleTable;"

#: spi.xml:397(para)
msgid ""
"The structure <structname>SPITupleTable</structname> is defined thus: "
"<placeholder-1/> <structfield>vals</structfield> is an array of pointers to "
"rows. (The number of valid entries is given by <varname>SPI_processed</"
"varname>.) <structfield>tupdesc</structfield> is a row descriptor which you "
"can pass to SPI functions dealing with rows. <structfield>tuptabcxt</"
"structfield>, <structfield>alloced</structfield>, and <structfield>free</"
"structfield> are internal fields not intended for use by SPI callers."
msgstr ""
"Структура <structname>SPITupleTable</structname> определена так: "
"<placeholder-1/> <structfield>vals</structfield> представляет собой массив "
"указателей на строки. (Число записей в нём указывается в "
"<varname>SPI_processed</varname>.) Поле <structfield>tupdesc</structfield> "
"содержит дескриптор строки, который вы сможете передать функциям SPI, "
"работающими со строками. Поля <structfield>tuptabcxt</structfield>, "
"<structfield>alloced</structfield> и <structfield>free</structfield> "
"предназначены для внутреннего использования, а не для процедур, работающих с "
"SPI."

#: spi.xml:418(para)
msgid ""
"<function>SPI_finish</function> frees all <structname>SPITupleTable</"
"structname>s allocated during the current procedure. You can free a "
"particular result table earlier, if you are done with it, by calling "
"<function>SPI_freetuptable</function>."
msgstr ""
"<function>SPI_finish</function> освобождает все структуры "
"<structname>SPITupleTable</structname>, размещённые в памяти для текущей "
"процедуры. Вы можете освободить структуру конкретной результирующей таблицы, "
"если она вам не нужна, вызвав <function>SPI_freetuptable</function>."

#: spi.xml:427(title) spi.xml:671(title) spi.xml:760(title) spi.xml:919(title)
#: spi.xml:1055(title) spi.xml:1158(title) spi.xml:1241(title)
#: spi.xml:1299(title) spi.xml:1376(title) spi.xml:1440(title)
#: spi.xml:1581(title) spi.xml:1669(title) spi.xml:1791(title)
#: spi.xml:1916(title) spi.xml:2063(title) spi.xml:2145(title)
#: spi.xml:2202(title) spi.xml:2287(title) spi.xml:2361(title)
#: spi.xml:2461(title) spi.xml:2566(title) spi.xml:2615(title)
#: spi.xml:2685(title) spi.xml:2793(title) spi.xml:2868(title)
#: spi.xml:2940(title) spi.xml:3024(title) spi.xml:3113(title)
#: spi.xml:3178(title) spi.xml:3245(title) spi.xml:3300(title)
#: spi.xml:3432(title) spi.xml:3492(title) spi.xml:3563(title)
#: spi.xml:3611(title) spi.xml:3674(title) spi.xml:3743(title)
#: spi.xml:3895(title) spi.xml:3962(title) spi.xml:4009(title)
msgid "Arguments"
msgstr "Аргументы"

#: spi.xml:431(literal) spi.xml:675(literal) spi.xml:764(literal)
#: spi.xml:802(literal) spi.xml:923(literal) spi.xml:1059(literal)
#: spi.xml:1162(literal) spi.xml:1463(literal) spi.xml:1692(literal)
#: spi.xml:1795(literal) spi.xml:1824(literal) spi.xml:1920(literal)
#: spi.xml:1930(literal) spi.xml:1968(literal) spi.xml:2067(literal)
#: spi.xml:2149(literal) spi.xml:2881(literal) spi.xml:3796(literal)
msgid "const char * <placeholder-1/>"
msgstr "const char * <placeholder-1/>"

#: spi.xml:433(para) spi.xml:677(para)
msgid "string containing command to execute"
msgstr "строка с командой, которая должна быть выполнена"

#: spi.xml:440(literal) spi.xml:824(literal) spi.xml:1485(literal)
#: spi.xml:1603(literal) spi.xml:1846(literal) spi.xml:1990(literal)
#: spi.xml:2095(literal) spi.xml:2215(literal) spi.xml:2300(literal)
msgid "bool <placeholder-1/>"
msgstr "bool <placeholder-1/>"

#: spi.xml:442(para) spi.xml:826(para) spi.xml:1487(para) spi.xml:1605(para)
#: spi.xml:1848(para) spi.xml:1992(para) spi.xml:2097(para)
msgid "<literal>true</literal> for read-only execution"
msgstr ""
"<literal>true</literal> для режима выполнения &laquo;только чтение&raquo;"

#: spi.xml:447(literal) spi.xml:684(literal) spi.xml:831(literal)
#: spi.xml:1492(literal) spi.xml:1610(literal) spi.xml:1714(literal)
#: spi.xml:2224(literal) spi.xml:2309(literal) spi.xml:2386(literal)
#: spi.xml:2486(literal)
msgid "long <placeholder-1/>"
msgstr "long <placeholder-1/>"

#: spi.xml:449(para) spi.xml:686(para) spi.xml:833(para) spi.xml:1494(para)
#: spi.xml:1612(para) spi.xml:1716(para)
msgid "maximum number of rows to return, or <literal>0</literal> for no limit"
msgstr ""
"максимальное число строк, которое должно быть возвращено; с <literal>0</"
"literal> ограничения нет"

#: spi.xml:467(symbol)
msgid "SPI_OK_SELECT"
msgstr "SPI_OK_SELECT"

#: spi.xml:469(para)
msgid ""
"if a <command>SELECT</command> (but not <command>SELECT INTO</command>) was "
"executed"
msgstr ""
"если выполнялась команда <command>SELECT</command> (но не <command>SELECT "
"INTO</command>)"

#: spi.xml:477(symbol)
msgid "SPI_OK_SELINTO"
msgstr "SPI_OK_SELINTO"

#: spi.xml:479(para)
msgid "if a <command>SELECT INTO</command> was executed"
msgstr "если выполнялась команда <command>SELECT INTO</command>"

#: spi.xml:486(symbol)
msgid "SPI_OK_INSERT"
msgstr "SPI_OK_INSERT"

#: spi.xml:488(para)
msgid "if an <command>INSERT</command> was executed"
msgstr "если выполнялась команда <command>INSERT</command>"

#: spi.xml:495(symbol)
msgid "SPI_OK_DELETE"
msgstr "SPI_OK_DELETE"

#: spi.xml:497(para)
msgid "if a <command>DELETE</command> was executed"
msgstr "если выполнялась команда <command>DELETE</command>"

#: spi.xml:504(symbol)
msgid "SPI_OK_UPDATE"
msgstr "SPI_OK_UPDATE"

#: spi.xml:506(para)
msgid "if an <command>UPDATE</command> was executed"
msgstr "если выполнялась команда <command>UPDATE</command>"

#: spi.xml:513(symbol)
msgid "SPI_OK_INSERT_RETURNING"
msgstr "SPI_OK_INSERT_RETURNING"

#: spi.xml:515(para)
msgid "if an <command>INSERT RETURNING</command> was executed"
msgstr "если выполнялась команда <command>INSERT RETURNING</command>"

#: spi.xml:522(symbol)
msgid "SPI_OK_DELETE_RETURNING"
msgstr "SPI_OK_DELETE_RETURNING"

#: spi.xml:524(para)
msgid "if a <command>DELETE RETURNING</command> was executed"
msgstr "если выполнялась команда <command>DELETE RETURNING</command>"

#: spi.xml:531(symbol)
msgid "SPI_OK_UPDATE_RETURNING"
msgstr "SPI_OK_UPDATE_RETURNING"

#: spi.xml:533(para)
msgid "if an <command>UPDATE RETURNING</command> was executed"
msgstr "если выполнялась команда <command>UPDATE RETURNING</command>"

#: spi.xml:540(symbol)
msgid "SPI_OK_UTILITY"
msgstr "SPI_OK_UTILITY"

#: spi.xml:542(para)
msgid ""
"if a utility command (e.g., <command>CREATE TABLE</command>) was executed"
msgstr ""
"если выполнялась служебная команда (например, <command>CREATE TABLE</"
"command>)"

#: spi.xml:550(symbol)
msgid "SPI_OK_REWRITTEN"
msgstr "SPI_OK_REWRITTEN"

#: spi.xml:552(para)
msgid ""
"if the command was rewritten into another kind of command (e.g., "
"<command>UPDATE</command> became an <command>INSERT</command>) by a <link "
"linkend=\"rules\">rule</link>."
msgstr ""
"если команда была преобразована <link linkend=\"rules\">правилом</link> в "
"команду другого вида (например, <command>UPDATE</command> стал командой "
"<command>INSERT</command>)."

#: spi.xml:461(para)
msgid ""
"If the execution of the command was successful then one of the following "
"(nonnegative) values will be returned: <placeholder-1/>"
msgstr ""
"Если команда была выполнена успешно, возвращается одно из следующих "
"(неотрицательных) значений: <placeholder-1/>"

#: spi.xml:566(symbol) spi.xml:1512(symbol) spi.xml:2708(symbol)
#: spi.xml:3832(symbol)
msgid "SPI_ERROR_ARGUMENT"
msgstr "SPI_ERROR_ARGUMENT"

#: spi.xml:568(para)
msgid ""
"if <parameter>command</parameter> is <symbol>NULL</symbol> or "
"<parameter>count</parameter> is less than 0"
msgstr ""
"если в качестве <parameter>command</parameter> передан <symbol>NULL</symbol> "
"или <parameter>count</parameter> меньше 0"

#: spi.xml:576(symbol)
msgid "SPI_ERROR_COPY"
msgstr "SPI_ERROR_COPY"

#: spi.xml:578(para)
msgid ""
"if <command>COPY TO stdout</command> or <command>COPY FROM stdin</command> "
"was attempted"
msgstr ""
"при попытке выполнить <command>COPY TO stdout</command> или <command>COPY "
"FROM stdin</command>"

#: spi.xml:586(symbol)
msgid "SPI_ERROR_TRANSACTION"
msgstr "SPI_ERROR_TRANSACTION"

#: spi.xml:588(para)
msgid ""
"if a transaction manipulation command was attempted (<command>BEGIN</"
"command>, <command>COMMIT</command>, <command>ROLLBACK</command>, "
"<command>SAVEPOINT</command>, <command>PREPARE TRANSACTION</command>, "
"<command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command>, or "
"any variant thereof)"
msgstr ""
"при попытке выполнить команду управления транзакциями (<command>BEGIN</"
"command>, <command>COMMIT</command>, <command>ROLLBACK</command>, "
"<command>SAVEPOINT</command>, <command>PREPARE TRANSACTION</command>, "
"<command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command> или "
"любую их вариацию)"

#: spi.xml:603(symbol)
msgid "SPI_ERROR_OPUNKNOWN"
msgstr "SPI_ERROR_OPUNKNOWN"

#: spi.xml:605(para)
msgid "if the command type is unknown (shouldn't happen)"
msgstr "если тип команды неизвестен (такого быть не должно)"

#: spi.xml:561(para)
msgid ""
"On error, one of the following negative values is returned: <placeholder-1/>"
msgstr ""
"В случае ошибки возвращается одно из следующих отрицательных значений: "
"<placeholder-1/>"

#: spi.xml:624(title) spi.xml:969(title) spi.xml:1107(title)
#: spi.xml:2245(title) spi.xml:2320(title) spi.xml:2411(title)
#: spi.xml:2512(title) spi.xml:2640(title) spi.xml:2729(title)
msgid "Notes"
msgstr "Замечания"

#: spi.xml:626(para)
msgid ""
"All SPI query-execution functions set both <varname>SPI_processed</varname> "
"and <varname>SPI_tuptable</varname> (just the pointer, not the contents of "
"the structure). Save these two global variables into local procedure "
"variables if you need to access the result table of <function>SPI_execute</"
"function> or another query-execution function across later calls."
msgstr ""
"Все функции SPI, выполняющие запросы, заполняют и <varname>SPI_processed</"
"varname>, и <varname>SPI_tuptable</varname> (только указатель, но не "
"содержимое структуры). Сохраните эти две глобальные переменные в локальных "
"переменных процедуры, если хотите обращаться к таблице результата "
"<function>SPI_execute</function> или другой функции, выполняющей запрос, в "
"нескольких вызовах процедуры."

#: spi.xml:641(indexterm)
msgid "<primary>SPI_exec</primary>"
msgstr "<primary>SPI_exec</primary>"

#: spi.xml:644(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_exec"
msgstr "SPI_exec"

#: spi.xml:649(refname)
msgctxt "refname"
msgid "SPI_exec"
msgstr "SPI_exec"

#: spi.xml:650(refpurpose)
msgid "execute a read/write command"
msgstr "выполнить команду чтения/записи"

#: spi.xml:654(synopsis)
#, no-wrap
msgid "int SPI_exec(const char * <placeholder-1/>, long <placeholder-2/>)"
msgstr "int SPI_exec(const char * <placeholder-1/>, long <placeholder-2/>)"

#: spi.xml:662(para)
msgid ""
"<function>SPI_exec</function> is the same as <function>SPI_execute</"
"function>, with the latter's <parameter>read_only</parameter> parameter "
"always taken as <literal>false</literal>."
msgstr ""
"<function>SPI_exec</function> действует подобно <function>SPI_execute</"
"function>, но ей не передаётся параметр <parameter>read_only</parameter> "
"(всегда подразумевается <literal>false</literal>)."

#: spi.xml:698(para)
msgid "See <function>SPI_execute</function>."
msgstr "См. <function>SPI_execute</function>."

#: spi.xml:707(indexterm)
msgid "<primary>SPI_execute_with_args</primary>"
msgstr "<primary>SPI_execute_with_args</primary>"

#: spi.xml:710(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute_with_args"
msgstr "SPI_execute_with_args"

#: spi.xml:715(refname)
msgctxt "refname"
msgid "SPI_execute_with_args"
msgstr "SPI_execute_with_args"

#: spi.xml:716(refpurpose)
msgid "execute a command with out-of-line parameters"
msgstr "выполнить команду с выделенными параметрами"

#: spi.xml:722(parameter) spi.xml:773(parameter) spi.xml:874(parameter)
#: spi.xml:932(parameter) spi.xml:1036(parameter) spi.xml:1068(parameter)
#: spi.xml:1883(parameter) spi.xml:1939(parameter)
msgid "nargs"
msgstr "nargs"

#: spi.xml:722(parameter) spi.xml:782(parameter) spi.xml:874(parameter)
#: spi.xml:941(parameter) spi.xml:1037(parameter) spi.xml:1077(parameter)
#: spi.xml:1883(parameter) spi.xml:1948(parameter)
msgid "argtypes"
msgstr "argtypes"

#: spi.xml:723(parameter) spi.xml:792(parameter) spi.xml:1422(parameter)
#: spi.xml:1453(parameter) spi.xml:1653(parameter) spi.xml:1682(parameter)
#: spi.xml:1758(parameter) spi.xml:1814(parameter) spi.xml:1884(parameter)
#: spi.xml:1958(parameter) spi.xml:3728(parameter) spi.xml:3786(parameter)
msgid "values"
msgstr "values"

#: spi.xml:723(parameter) spi.xml:802(parameter) spi.xml:1422(parameter)
#: spi.xml:1463(parameter) spi.xml:1653(parameter) spi.xml:1692(parameter)
#: spi.xml:1758(parameter) spi.xml:1824(parameter) spi.xml:1884(parameter)
#: spi.xml:1968(parameter) spi.xml:3728(parameter) spi.xml:3796(parameter)
msgid "nulls"
msgstr "nulls"

#: spi.xml:720(synopsis)
#, no-wrap
msgid ""
"int SPI_execute_with_args(const char *<placeholder-1/>,\n"
"                          int <placeholder-2/>, Oid *<placeholder-3/>,\n"
"                          Datum *<placeholder-4/>, const char *<placeholder-5/>,\n"
"                          bool <placeholder-6/>, long <placeholder-7/>)"
msgstr ""
"int SPI_execute_with_args(const char *<placeholder-1/>,\n"
"                          int <placeholder-2/>, Oid *<placeholder-3/>,\n"
"                          Datum *<placeholder-4/>, const char *<placeholder-5/>,\n"
"                          bool <placeholder-6/>, long <placeholder-7/>)"

#: spi.xml:731(para)
msgid ""
"<function>SPI_execute_with_args</function> executes a command that might "
"include references to externally supplied parameters. The command text "
"refers to a parameter as <literal>$<replaceable>n</replaceable></literal>, "
"and the call specifies data types and values for each such symbol. "
"<parameter>read_only</parameter> and <parameter>count</parameter> have the "
"same interpretation as in <function>SPI_execute</function>."
msgstr ""
"<function>SPI_execute_with_args</function> выполняет команду, которая может "
"включать ссылки на параметры, передаваемые извне. В тексте команды параметры "
"обозначаются символами <literal>$<replaceable>n</replaceable></literal>, а в "
"вызове указываются типы данных и значения для каждого такого символа. "
"Параметры <parameter>read_only</parameter> и <parameter>count</parameter> "
"имеют тот же смысл, что и в <function>SPI_execute</function>."

#: spi.xml:740(para)
msgid ""
"The main advantage of this routine compared to <function>SPI_execute</"
"function> is that data values can be inserted into the command without "
"tedious quoting/escaping, and thus with much less risk of SQL-injection "
"attacks."
msgstr ""
"Основное преимущество этой функции по сравнению с <function>SPI_execute</"
"function> в том, что она позволяет передавать в команду значения данных, не "
"требуя кропотливой подготовки строк, и таким образом сокращает риск атак с "
"SQL-инъекцией."

#: spi.xml:747(para)
msgid ""
"Similar results can be achieved with <function>SPI_prepare</function> "
"followed by <function>SPI_execute_plan</function>; however, when using this "
"function the query plan is always customized to the specific parameter "
"values provided. For one-time query execution, this function should be "
"preferred. If the same command is to be executed with many different "
"parameters, either method might be faster, depending on the cost of re-"
"planning versus the benefit of custom plans."
msgstr ""
"Подобного результата можно достичь, вызвав <function>SPI_prepare</function> "
"и затем <function>SPI_execute_plan</function>; однако, с данной функцией "
"план запроса всегда подстраивается под переданные конкретные значения "
"параметров. Поэтому для разового выполнения запроса рекомендуется применять "
"эту функцию. Если же одна и та же команда должна выполняться с самыми "
"разными параметрами, какой вариант окажется быстрее, будет зависеть от "
"стоимости повторного планирования и выигрыша от выбора специализированных "
"планов."

#: spi.xml:766(para) spi.xml:925(para) spi.xml:1061(para) spi.xml:1164(para)
#: spi.xml:1932(para)
msgid "command string"
msgstr "строка команды"

#: spi.xml:773(literal) spi.xml:932(literal) spi.xml:1068(literal)
#: spi.xml:1087(literal) spi.xml:1189(literal) spi.xml:1312(literal)
#: spi.xml:1939(literal) spi.xml:1997(literal) spi.xml:2806(literal)
#: spi.xml:2962(literal) spi.xml:3046(literal) spi.xml:3126(literal)
#: spi.xml:3191(literal) spi.xml:3767(literal)
msgid "int <placeholder-1/>"
msgstr "int <placeholder-1/>"

#: spi.xml:775(para) spi.xml:934(para) spi.xml:1070(para) spi.xml:1941(para)
msgid ""
"number of input parameters (<literal>$1</literal>, <literal>$2</literal>, "
"etc.)"
msgstr ""
"число входных параметров (<literal>$1</literal>, <literal>$2</literal> и т. "
"д.)"

#: spi.xml:782(literal) spi.xml:941(literal) spi.xml:1077(literal)
#: spi.xml:1948(literal)
msgid "Oid * <placeholder-1/>"
msgstr "Oid * <placeholder-1/>"

#: spi.xml:784(para) spi.xml:1950(para)
msgid ""
"an array of length <parameter>nargs</parameter>, containing the "
"<acronym>OID</acronym>s of the data types of the parameters"
msgstr ""
"массив размера <parameter>nargs</parameter>, содержащий <acronym>OID</"
"acronym> типов параметров"

#: spi.xml:792(literal) spi.xml:1453(literal) spi.xml:1682(literal)
#: spi.xml:1814(literal) spi.xml:1958(literal) spi.xml:3786(literal)
msgid "Datum * <placeholder-1/>"
msgstr "Datum * <placeholder-1/>"

#: spi.xml:794(para) spi.xml:1960(para)
msgid ""
"an array of length <parameter>nargs</parameter>, containing the actual "
"parameter values"
msgstr ""
"массив размера <parameter>nargs</parameter>, содержащий фактические значения "
"параметров"

#: spi.xml:804(para) spi.xml:1970(para)
msgid ""
"an array of length <parameter>nargs</parameter>, describing which parameters "
"are null"
msgstr ""
"массив размера <parameter>nargs</parameter>, описывающий, в каких параметрах "
"передаётся NULL"

#: spi.xml:809(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_execute_with_args</function> assumes that no parameters are "
"null. Otherwise, each entry of the <parameter>nulls</parameter> array should "
"be <literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_execute_with_args</function> считает, что ни один из "
"параметров не равен NULL. В противном случае элемент массива "
"<parameter>nulls</parameter> должен содержать <literal>'&nbsp;'</literal>, "
"если значение соответствующего параметра не NULL, либо <literal>'n'</"
"literal>, если это значение — NULL. (В последнем случае значение, переданное "
"в соответствующем элементе <parameter>values</parameter>, не учитывается.) "
"Заметьте, что <parameter>nulls</parameter> — это не текстовая строка, а "
"просто массив: ноль (<literal>'\\0'</literal>) в конце не нужен."

#: spi.xml:845(para)
msgid "The return value is the same as for <function>SPI_execute</function>."
msgstr "Возвращаемые значения те же, что и у <function>SPI_execute</function>."

#: spi.xml:849(para) spi.xml:1533(para) spi.xml:1732(para) spi.xml:2237(para)
#: spi.xml:2403(para)
msgid ""
"<varname>SPI_processed</varname> and <varname>SPI_tuptable</varname> are set "
"as in <function>SPI_execute</function> if successful."
msgstr ""
"Переменные <varname>SPI_processed</varname> и <varname>SPI_tuptable</"
"varname> устанавливаются как в <function>SPI_execute</function>, если вызов "
"был успешным."

#: spi.xml:860(indexterm)
msgid "<primary>SPI_prepare</primary>"
msgstr "<primary>SPI_prepare</primary>"

#: spi.xml:863(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_prepare"
msgstr "SPI_prepare"

#: spi.xml:868(refname)
msgctxt "refname"
msgid "SPI_prepare"
msgstr "SPI_prepare"

#: spi.xml:869(refpurpose) spi.xml:1031(refpurpose) spi.xml:1133(refpurpose)
msgid "prepare a statement, without executing it yet"
msgstr "подготовить оператор, но пока не выполнять его"

#: spi.xml:873(synopsis)
#, no-wrap
msgid "SPIPlanPtr SPI_prepare(const char * <placeholder-1/>, int <placeholder-2/>, Oid * <placeholder-3/>)"
msgstr "SPIPlanPtr SPI_prepare(const char * <placeholder-1/>, int <placeholder-2/>, Oid * <placeholder-3/>)"

#: spi.xml:881(para)
msgid ""
"<function>SPI_prepare</function> creates and returns a prepared statement "
"for the specified command, but doesn't execute the command. The prepared "
"statement can later be executed repeatedly using <function>SPI_execute_plan</"
"function>."
msgstr ""
"<function>SPI_prepare</function> создаёт и возвращает подготовленный "
"оператор для заданной команды. Подготовленный оператор может быть затем "
"неоднократно выполнен функцией <function>SPI_execute_plan</function>."

#: spi.xml:888(para)
msgid ""
"When the same or a similar command is to be executed repeatedly, it is "
"generally advantageous to perform parse analysis only once, and might "
"furthermore be advantageous to re-use an execution plan for the command. "
"<function>SPI_prepare</function> converts a command string into a prepared "
"statement that encapsulates the results of parse analysis. The prepared "
"statement also provides a place for caching an execution plan if it is found "
"that generating a custom plan for each execution is not helpful."
msgstr ""
"Когда одна и та же или похожие команды выполняются неоднократно, обычно "
"выгоднее произвести анализ запроса только раз, а ещё выгоднее может быть "
"повторно использовать план выполнения команды. <function>SPI_prepare</"
"function> преобразует строку команды в подготовленный оператор, включающий в "
"себя результаты анализа запроса. Подготовленный оператор также оставляет "
"место для кеширования плана выполнения, если выбор специализированного плана "
"для каждого выполнения не принесёт пользы."

#: spi.xml:900(para)
msgid ""
"A prepared command can be generalized by writing parameters (<literal>$1</"
"literal>, <literal>$2</literal>, etc.) in place of what would be constants "
"in a normal command. The actual values of the parameters are then specified "
"when <function>SPI_execute_plan</function> is called. This allows the "
"prepared command to be used over a wider range of situations than would be "
"possible without parameters."
msgstr ""
"Подготавливаемую команду можно сделать более общей, записав параметры "
"(<literal>$1</literal>, <literal>$2</literal>, etc.) вместо значений, "
"задаваемыми константами в обычной команде. Фактические значения параметров в "
"этом случае будут задаваться при вызове <function>SPI_execute_plan</"
"function>. Это позволяет применять подготовленную команду в более широком "
"круге ситуаций, чем это возможно без параметров."

#: spi.xml:909(para)
msgid ""
"The statement returned by <function>SPI_prepare</function> can be used only "
"in the current invocation of the procedure, since <function>SPI_finish</"
"function> frees memory allocated for such a statement. But the statement can "
"be saved for longer using the functions <function>SPI_keepplan</function> or "
"<function>SPI_saveplan</function>."
msgstr ""
"Оператор, возвращаемый функцией <function>SPI_prepare</function>, может "
"использоваться только в текущем вызове процедуры, так как "
"<function>SPI_finish</function> освобождает память, выделенную для такого "
"оператора. Но этот оператор может быть сохранён на будущее с помощью функций "
"<function>SPI_keepplan</function> или <function>SPI_saveplan</function>."

#: spi.xml:943(para) spi.xml:1079(para)
msgid ""
"pointer to an array containing the <acronym>OID</acronym>s of the data types "
"of the parameters"
msgstr ""
"указатель на массив, содержащий <acronym>OID</acronym> типов параметров"

#: spi.xml:955(para)
msgid ""
"<function>SPI_prepare</function> returns a non-null pointer to an "
"<type>SPIPlan</type>, which is an opaque struct representing a prepared "
"statement. On error, <symbol>NULL</symbol> will be returned, and "
"<varname>SPI_result</varname> will be set to one of the same error codes "
"used by <function>SPI_execute</function>, except that it is set to "
"<symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>command</parameter> is "
"<symbol>NULL</symbol>, or if <parameter>nargs</parameter> is less than 0, or "
"if <parameter>nargs</parameter> is greater than 0 and <parameter>argtypes</"
"parameter> is <symbol>NULL</symbol>."
msgstr ""
"<function>SPI_prepare</function> возвращает ненулевой указатель на "
"<type>SPIPlan</type>, скрытую структуру, представляющую подготовленный "
"оператор. В случае ошибки возвращается <symbol>NULL</symbol>, а в "
"<varname>SPI_result</varname> устанавливается один из кодов ошибок, "
"определённых для <function>SPI_execute</function>, за исключением того, что "
"код <symbol>SPI_ERROR_ARGUMENT</symbol> устанавливается, когда "
"<parameter>command</parameter> — <symbol>NULL</symbol>, когда "
"<parameter>nargs</parameter> меньше 0 или когда <parameter>nargs</parameter> "
"больше 0, а <parameter>argtypes</parameter> — <symbol>NULL</symbol>."

#: spi.xml:971(para)
msgid ""
"If no parameters are defined, a generic plan will be created at the first "
"use of <function>SPI_execute_plan</function>, and used for all subsequent "
"executions as well. If there are parameters, the first few uses of "
"<function>SPI_execute_plan</function> will generate custom plans that are "
"specific to the supplied parameter values. After enough uses of the same "
"prepared statement, <function>SPI_execute_plan</function> will build a "
"generic plan, and if that is not too much more expensive than the custom "
"plans, it will start using the generic plan instead of re-planning each "
"time. If this default behavior is unsuitable, you can alter it by passing "
"the <literal>CURSOR_OPT_GENERIC_PLAN</literal> or "
"<literal>CURSOR_OPT_CUSTOM_PLAN</literal> flag to "
"<function>SPI_prepare_cursor</function>, to force use of generic or custom "
"plans respectively."
msgstr ""
"Если параметры не определены, при первом использовании "
"<function>SPI_execute_plan</function> создаётся общий план, который затем "
"будет применяться при последующих вызовах. Если же присутствуют параметры, "
"<function>SPI_execute_plan</function> будет создавать специализированные "
"планы для конкретных значений параметров. После достаточного количества "
"использований полученного подготовленного оператора, функция "
"<function>SPI_execute_plan</function> построит общий план, и если он не "
"будет значительно дороже специализированных, она начнёт использовать его, а "
"не будет строить план заново. Если это поведение по умолчанию не устраивает, "
"его можно изменить, передав флаг <literal>CURSOR_OPT_GENERIC_PLAN</literal> "
"или <literal>CURSOR_OPT_CUSTOM_PLAN</literal> в "
"<function>SPI_prepare_cursor</function>, чтобы ограничиться использованием "
"только общего или специализированных планов, соответственно."

#: spi.xml:987(para)
msgid ""
"Although the main point of a prepared statement is to avoid repeated parse "
"analysis and planning of the statement, <productname>PostgreSQL</"
"productname> will force re-analysis and re-planning of the statement before "
"using it whenever database objects used in the statement have undergone "
"definitional (DDL) changes since the previous use of the prepared statement. "
"Also, if the value of <xref linkend=\"guc-search-path\"/> changes from one "
"use to the next, the statement will be re-parsed using the new "
"<varname>search_path</varname>. (This latter behavior is new as of "
"<productname>PostgreSQL</productname> 9.3.) See <xref linkend=\"sql-prepare"
"\"/> for more information about the behavior of prepared statements."
msgstr ""
"Хотя основной смысл подготовленного оператора в том, чтобы избежать "
"повторного разбора и планирования запроса, <productname>PostgreSQL</"
"productname> всё же будет принудительно повторять разбор и планирование "
"запроса перед его выполнением, если со времени предыдущего использования "
"подготовленного оператора произойдут изменения определений (DDL) объектов "
"базы, задействованных в этом запросе. Также, если перед очередным "
"использованием было изменено значение <xref linkend=\"guc-search-path\"/>, "
"запрос будет разобран заново с новым значением <varname>search_path</"
"varname>. (Последняя особенность появилась в <productname>PostgreSQL</"
"productname> 9.3.) Чтобы узнать о поведении подготовленных операторов "
"больше, обратитесь к <xref remap=\"3\" linkend=\"sql-prepare\"/>."

#: spi.xml:1001(para)
msgid "This function should only be called from a connected procedure."
msgstr "Эту функцию следует вызывать только из подключённой процедуры."

#: spi.xml:1005(para)
msgid ""
"<type>SPIPlanPtr</type> is declared as a pointer to an opaque struct type in "
"<filename>spi.h</filename>. It is unwise to try to access its contents "
"directly, as that makes your code much more likely to break in future "
"revisions of <productname>PostgreSQL</productname>."
msgstr ""
"<type>SPIPlanPtr</type> объявлен в <filename>spi.h</filename> как указатель "
"на скрытую структуру. Пытаться обращаться к её содержимому напрямую не "
"стоит, так как ваш код скорее всего сломается при выходе новых версий "
"<productname>PostgreSQL</productname>."

#: spi.xml:1012(para)
msgid ""
"The name <type>SPIPlanPtr</type> is somewhat historical, since the data "
"structure no longer necessarily contains an execution plan."
msgstr ""
"Имя <type>SPIPlanPtr</type> объясняется отчасти историческими причинами, так "
"как теперь эта структура может не содержать собственно план выполнения."

#: spi.xml:1022(indexterm)
msgid "<primary>SPI_prepare_cursor</primary>"
msgstr "<primary>SPI_prepare_cursor</primary>"

#: spi.xml:1025(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_prepare_cursor"
msgstr "SPI_prepare_cursor"

#: spi.xml:1030(refname)
msgctxt "refname"
msgid "SPI_prepare_cursor"
msgstr "SPI_prepare_cursor"

#: spi.xml:1037(parameter) spi.xml:1087(parameter) spi.xml:1141(parameter)
#: spi.xml:1189(parameter) spi.xml:1885(parameter) spi.xml:1997(parameter)
msgid "cursorOptions"
msgstr "cursorOptions"

#: spi.xml:1035(synopsis)
#, no-wrap
msgid ""
"SPIPlanPtr SPI_prepare_cursor(const char * <placeholder-1/>, int <placeholder-2/>,\n"
"                              Oid * <placeholder-3/>, int <placeholder-4/>)"
msgstr ""
"SPIPlanPtr SPI_prepare_cursor(const char * <placeholder-1/>, int <placeholder-2/>,\n"
"                              Oid * <placeholder-3/>, int <placeholder-4/>)"

#: spi.xml:1044(para)
msgid ""
"<function>SPI_prepare_cursor</function> is identical to "
"<function>SPI_prepare</function>, except that it also allows specification "
"of the planner's <quote>cursor options</quote> parameter. This is a bit mask "
"having the values shown in <filename>nodes/parsenodes.h</filename> for the "
"<structfield>options</structfield> field of <structname>DeclareCursorStmt</"
"structname>. <function>SPI_prepare</function> always takes the cursor "
"options as zero."
msgstr ""
"Функция <function>SPI_prepare_cursor</function> равнозначна "
"<function>SPI_prepare</function>, за исключением того, что ей можно передать "
"<quote>параметры курсора</quote>. Эти параметры задаются битовой маской со "
"значениями, определёнными в <filename>nodes/parsenodes.h</filename> для поля "
"<structfield>options</structfield> структуры <structname>DeclareCursorStmt</"
"structname>. <function>SPI_prepare</function> подразумевает, что эти "
"параметры всегда нулевые."

#: spi.xml:1089(para) spi.xml:1191(para) spi.xml:1999(para)
msgid "integer bit mask of cursor options; zero produces default behavior"
msgstr "битовая маска параметров курсора; 0 выбирает поведение по умолчанию"

#: spi.xml:1100(para)
msgid ""
"<function>SPI_prepare_cursor</function> has the same return conventions as "
"<function>SPI_prepare</function>."
msgstr ""
"<function>SPI_prepare_cursor</function> возвращает результат по тем же "
"соглашениям, что и <function>SPI_prepare</function>."

#: spi.xml:1109(para)
msgid ""
"Useful bits to set in <parameter>cursorOptions</parameter> include "
"<symbol>CURSOR_OPT_SCROLL</symbol>, <symbol>CURSOR_OPT_NO_SCROLL</symbol>, "
"<symbol>CURSOR_OPT_FAST_PLAN</symbol>, <symbol>CURSOR_OPT_GENERIC_PLAN</"
"symbol>, and <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>. Note in particular "
"that <symbol>CURSOR_OPT_HOLD</symbol> is ignored."
msgstr ""
"К числу полезных бит, которые можно задать в <parameter>cursorOptions</"
"parameter>, относятся <symbol>CURSOR_OPT_SCROLL</symbol>, "
"<symbol>CURSOR_OPT_NO_SCROLL</symbol>, <symbol>CURSOR_OPT_FAST_PLAN</"
"symbol>, <symbol>CURSOR_OPT_GENERIC_PLAN</symbol> и "
"<symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>. Заметьте, что параметр "
"<symbol>CURSOR_OPT_HOLD</symbol> игнорируется."

#: spi.xml:1124(indexterm)
msgid "<primary>SPI_prepare_params</primary>"
msgstr "<primary>SPI_prepare_params</primary>"

#: spi.xml:1127(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_prepare_params"
msgstr "SPI_prepare_params"

#: spi.xml:1132(refname)
msgctxt "refname"
msgid "SPI_prepare_params"
msgstr "SPI_prepare_params"

#: spi.xml:1139(parameter) spi.xml:1171(parameter)
msgid "parserSetup"
msgstr "parserSetup"

#: spi.xml:1140(parameter) spi.xml:1180(parameter)
msgid "parserSetupArg"
msgstr "parserSetupArg"

#: spi.xml:1137(synopsis)
#, no-wrap
msgid ""
"SPIPlanPtr SPI_prepare_params(const char * <placeholder-1/>,\n"
"                              ParserSetupHook <placeholder-2/>,\n"
"                              void * <placeholder-3/>,\n"
"                              int <placeholder-4/>)"
msgstr ""
"SPIPlanPtr SPI_prepare_params(const char * <placeholder-1/>,\n"
"                              ParserSetupHook <placeholder-2/>,\n"
"                              void * <placeholder-3/>,\n"
"                              int <placeholder-4/>)"

#: spi.xml:1148(para)
msgid ""
"<function>SPI_prepare_params</function> creates and returns a prepared "
"statement for the specified command, but doesn't execute the command. This "
"function is equivalent to <function>SPI_prepare_cursor</function>, with the "
"addition that the caller can specify parser hook functions to control the "
"parsing of external parameter references."
msgstr ""
"<function>SPI_prepare_params</function> создаёт и возвращает подготовленный "
"оператор для заданной команды, но не выполняет саму команду. Эта функция "
"равнозначна <function>SPI_prepare_cursor</function>, но позволяет "
"вызывающему дополнительно установить функции-обработчики для управления "
"разбором ссылок на внешние параметры."

#: spi.xml:1171(literal)
msgid "ParserSetupHook <placeholder-1/>"
msgstr "ParserSetupHook <placeholder-1/>"

#: spi.xml:1173(para)
msgid "Parser hook setup function"
msgstr "Функция настройки обработчиков разбора"

#: spi.xml:1180(literal) spi.xml:3496(literal) spi.xml:3567(literal)
msgid "void * <placeholder-1/>"
msgstr "void * <placeholder-1/>"

#: spi.xml:1182(para)
msgid "pass-through argument for <parameter>parserSetup</parameter>"
msgstr "аргумент для сквозной передачи в <parameter>parserSetup</parameter>"

#: spi.xml:1202(para)
msgid ""
"<function>SPI_prepare_params</function> has the same return conventions as "
"<function>SPI_prepare</function>."
msgstr ""
"<function>SPI_prepare_params</function> возвращает результат по тем же "
"соглашениям, что и <function>SPI_prepare</function>."

#: spi.xml:1212(indexterm)
msgid "<primary>SPI_getargcount</primary>"
msgstr "<primary>SPI_getargcount</primary>"

#: spi.xml:1215(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getargcount"
msgstr "SPI_getargcount"

#: spi.xml:1220(refname)
msgctxt "refname"
msgid "SPI_getargcount"
msgstr "SPI_getargcount"

#: spi.xml:1222(function) spi.xml:1279(function) spi.xml:1349(function)
#: spi.xml:1417(function) spi.xml:1553(function) spi.xml:1752(function)
msgctxt "function"
msgid "SPI_prepare"
msgstr "SPI_prepare"

#: spi.xml:1221(refpurpose)
msgid ""
"return the number of arguments needed by a statement prepared by "
"<placeholder-1/>"
msgstr ""
"получить число аргументов, требующихся оператору, подготовленному функцией "
"<placeholder-1/>"

#: spi.xml:1227(parameter) spi.xml:1245(parameter) spi.xml:1284(parameter)
#: spi.xml:1303(parameter) spi.xml:1355(parameter) spi.xml:1380(parameter)
#: spi.xml:1422(parameter) spi.xml:1444(parameter) spi.xml:1558(parameter)
#: spi.xml:1585(parameter) spi.xml:1653(parameter) spi.xml:1673(parameter)
#: spi.xml:1757(parameter) spi.xml:1805(parameter) spi.xml:2035(parameter)
#: spi.xml:2077(parameter) spi.xml:2598(parameter) spi.xml:2619(parameter)
#: spi.xml:2667(parameter) spi.xml:2689(parameter) spi.xml:3994(parameter)
#: spi.xml:4013(parameter)
msgid "plan"
msgstr "plan"

#: spi.xml:1226(synopsis)
#, no-wrap
msgid "int SPI_getargcount(SPIPlanPtr <placeholder-1/>)"
msgstr "int SPI_getargcount(SPIPlanPtr <placeholder-1/>)"

#: spi.xml:1234(para)
msgid ""
"<function>SPI_getargcount</function> returns the number of arguments needed "
"to execute a statement prepared by <function>SPI_prepare</function>."
msgstr ""
"<function>SPI_getargcount</function> возвращает число аргументов, "
"требующихся для выполнения оператора, подготовленного функцией "
"<function>SPI_prepare</function>."

#: spi.xml:1245(literal) spi.xml:1303(literal) spi.xml:1380(literal)
#: spi.xml:1444(literal) spi.xml:1585(literal) spi.xml:1673(literal)
#: spi.xml:1805(literal) spi.xml:2077(literal) spi.xml:2619(literal)
#: spi.xml:2689(literal) spi.xml:4013(literal)
msgid "SPIPlanPtr <placeholder-1/>"
msgstr "SPIPlanPtr <placeholder-1/>"

#: spi.xml:1247(para) spi.xml:1305(para) spi.xml:1382(para) spi.xml:1446(para)
#: spi.xml:1587(para) spi.xml:1675(para) spi.xml:1807(para) spi.xml:2079(para)
msgid "prepared statement (returned by <function>SPI_prepare</function>)"
msgstr ""
"подготовленный оператор (возвращаемый функцией <function>SPI_prepare</"
"function>)"

#: spi.xml:1257(para)
msgid ""
"The count of expected arguments for the <parameter>plan</parameter>. If the "
"<parameter>plan</parameter> is <symbol>NULL</symbol> or invalid, "
"<varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol> "
"and -1 is returned."
msgstr ""
"Число аргументов, которое ожидает план, заданный параметром <parameter>plan</"
"parameter>. Если значение <parameter>plan</parameter> неверное или "
"<symbol>NULL</symbol>, в <varname>SPI_result</varname> устанавливается код "
"<symbol>SPI_ERROR_ARGUMENT</symbol>, а функция возвращает -1."

#: spi.xml:1269(indexterm)
msgid "<primary>SPI_getargtypeid</primary>"
msgstr "<primary>SPI_getargtypeid</primary>"

#: spi.xml:1272(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getargtypeid"
msgstr "SPI_getargtypeid"

#: spi.xml:1277(refname)
msgctxt "refname"
msgid "SPI_getargtypeid"
msgstr "SPI_getargtypeid"

#: spi.xml:1278(refpurpose)
msgid ""
"return the data type OID for an argument of a statement prepared by "
"<placeholder-1/>"
msgstr ""
"получить OID типа аргумента для оператора, подготовленного функцией "
"<placeholder-1/>"

#: spi.xml:1284(parameter) spi.xml:1312(parameter)
msgid "argIndex"
msgstr "argIndex"

#: spi.xml:1283(synopsis)
#, no-wrap
msgid "Oid SPI_getargtypeid(SPIPlanPtr <placeholder-1/>, int <placeholder-2/>)"
msgstr "Oid SPI_getargtypeid(SPIPlanPtr <placeholder-1/>, int <placeholder-2/>)"

#: spi.xml:1291(para)
msgid ""
"<function>SPI_getargtypeid</function> returns the OID representing the type "
"for the <parameter>argIndex</parameter>'th argument of a statement prepared "
"by <function>SPI_prepare</function>. First argument is at index zero."
msgstr ""
"<function>SPI_getargtypeid</function> возвращает OID, представляющий тип "
"аргумента под номером <parameter>argIndex</parameter> оператора, "
"подготовленного функцией <function>SPI_prepare</function>. Первый аргумент "
"идёт под номером ноль."

#: spi.xml:1314(para)
msgid "zero based index of the argument"
msgstr "индекс аргумента, начиная с нуля"

#: spi.xml:1324(para)
msgid ""
"The type OID of the argument at the given index. If the <parameter>plan</"
"parameter> is <symbol>NULL</symbol> or invalid, or <parameter>argIndex</"
"parameter> is less than 0 or not less than the number of arguments declared "
"for the <parameter>plan</parameter>, <varname>SPI_result</varname> is set to "
"<symbol>SPI_ERROR_ARGUMENT</symbol> and <symbol>InvalidOid</symbol> is "
"returned."
msgstr ""
"OID типа аргумента с заданным индексом. Если значение <parameter>plan</"
"parameter> неверное или <symbol>NULL</symbol>, либо <parameter>argIndex</"
"parameter> меньше 0 или не меньше числа аргументов, объявленных при "
"подготовке плана (передаваемого в <parameter>plan</parameter>), в "
"<varname>SPI_result</varname> устанавливается <symbol>SPI_ERROR_ARGUMENT</"
"symbol> и возвращается <symbol>InvalidOid</symbol>."

#: spi.xml:1339(indexterm)
msgid "<primary>SPI_is_cursor_plan</primary>"
msgstr "<primary>SPI_is_cursor_plan</primary>"

#: spi.xml:1342(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_is_cursor_plan"
msgstr "SPI_is_cursor_plan"

#: spi.xml:1347(refname)
msgctxt "refname"
msgid "SPI_is_cursor_plan"
msgstr "SPI_is_cursor_plan"

#: spi.xml:1348(symbol)
msgid "true"
msgstr "true"

#: spi.xml:1350(function)
msgctxt "function"
msgid "SPI_cursor_open"
msgstr "SPI_cursor_open"

#: spi.xml:1348(refpurpose)
msgid ""
"return <placeholder-1/> if a statement prepared by <placeholder-2/> can be "
"used with <placeholder-3/>"
msgstr ""
"выдать <placeholder-1/>, если оператор, подготовленный функцией "
"<placeholder-2/>, можно использовать с <placeholder-3/>"

#: spi.xml:1354(synopsis)
#, no-wrap
msgid "bool SPI_is_cursor_plan(SPIPlanPtr <placeholder-1/>)"
msgstr "bool SPI_is_cursor_plan(SPIPlanPtr <placeholder-1/>)"

#: spi.xml:1362(para)
msgid ""
"<function>SPI_is_cursor_plan</function> returns <symbol>true</symbol> if a "
"statement prepared by <function>SPI_prepare</function> can be passed as an "
"argument to <function>SPI_cursor_open</function>, or <symbol>false</symbol> "
"if that is not the case. The criteria are that the <parameter>plan</"
"parameter> represents one single command and that this command returns "
"tuples to the caller; for example, <command>SELECT</command> is allowed "
"unless it contains an <literal>INTO</literal> clause, and <command>UPDATE</"
"command> is allowed only if it contains a <literal>RETURNING</literal> "
"clause."
msgstr ""
"<function>SPI_is_cursor_plan</function> возвращает <symbol>true</symbol>, "
"если оператор, подготовленный функцией <function>SPI_prepare</function>, "
"можно передать в качестве аргумента <function>SPI_cursor_open</function>, "
"или <symbol>false</symbol> в противном случае. Для положительного ответа в "
"<parameter>plan</parameter> должна быть представлена одна команда, и эта "
"команда должна возвращать кортежи; например, <command>SELECT</command> может "
"быть подходящей командой, если он не содержит предложения <literal>INTO</"
"literal>, а <command>UPDATE</command> подходит, только если он содержит "
"предложение <literal>RETURNING</literal>."

#: spi.xml:1392(para)
msgid ""
"<symbol>true</symbol> or <symbol>false</symbol> to indicate if the "
"<parameter>plan</parameter> can produce a cursor or not, with "
"<varname>SPI_result</varname> set to zero. If it is not possible to "
"determine the answer (for example, if the <parameter>plan</parameter> is "
"<symbol>NULL</symbol> or invalid, or if called when not connected to SPI), "
"then <varname>SPI_result</varname> is set to a suitable error code and "
"<symbol>false</symbol> is returned."
msgstr ""
"Значение <symbol>true</symbol> или <symbol>false</symbol>, показывающее, "
"можно ли для подготовленного оператора, заданного параметром "
"<parameter>plan</parameter>, получить курсор, при <varname>SPI_result</"
"varname> равном нулю. Если дать ответ невозможно (например, если значение "
"<parameter>plan</parameter> неверное или <symbol>NULL</symbol>, либо "
"вызывающий не подключён к SPI), в <varname>SPI_result</varname> "
"устанавливается соответствующий код ошибки и возвращается <symbol>false</"
"symbol>."

#: spi.xml:1408(indexterm)
msgid "<primary>SPI_execute_plan</primary>"
msgstr "<primary>SPI_execute_plan</primary>"

#: spi.xml:1411(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute_plan"
msgstr "SPI_execute_plan"

#: spi.xml:1416(refname)
msgctxt "refname"
msgid "SPI_execute_plan"
msgstr "SPI_execute_plan"

#: spi.xml:1417(refpurpose) spi.xml:1553(refpurpose)
msgid "execute a statement prepared by <placeholder-1/>"
msgstr "выполнить оператор, подготовленный функцией <placeholder-1/>"

#: spi.xml:1421(synopsis)
#, no-wrap
msgid ""
"int SPI_execute_plan(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>,\n"
"                     bool <placeholder-4/>, long <placeholder-5/>)"
msgstr ""
"int SPI_execute_plan(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>,\n"
"                     bool <placeholder-4/>, long <placeholder-5/>)"

#: spi.xml:1430(para)
msgid ""
"<function>SPI_execute_plan</function> executes a statement prepared by "
"<function>SPI_prepare</function> or one of its siblings. "
"<parameter>read_only</parameter> and <parameter>count</parameter> have the "
"same interpretation as in <function>SPI_execute</function>."
msgstr ""
"<function>SPI_execute_plan</function> выполняет оператор, подготовленный "
"функцией <function>SPI_prepare</function> или родственными ей. Параметры "
"<parameter>read_only</parameter> и <parameter>count</parameter> имеют тот же "
"смысл, что и в <function>SPI_execute</function>."

#: spi.xml:1455(para) spi.xml:1684(para) spi.xml:1816(para)
msgid ""
"An array of actual parameter values. Must have same length as the "
"statement's number of arguments."
msgstr ""
"Массив фактических значений параметров. Его размер должен равняться числу "
"аргументов оператора."

#: spi.xml:1465(para) spi.xml:1694(para) spi.xml:1826(para)
msgid ""
"An array describing which parameters are null. Must have same length as the "
"statement's number of arguments."
msgstr ""
"Массив, описывающий, в каких параметрах передаётся NULL. Должен иметь "
"размер, равный числу аргументов оператора."

#: spi.xml:1470(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_execute_plan</function> assumes that no parameters are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_execute_plan</function> считает, что ни один из параметров не "
"равен NULL. В противном случае элемент массива <parameter>nulls</parameter> "
"должен содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль (<literal>'\\0'</literal>) в конце не нужен."

#: spi.xml:1514(para)
msgid ""
"if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid, or "
"<parameter>count</parameter> is less than 0"
msgstr ""
"Если <parameter>plan</parameter> неверный или <symbol>NULL</symbol>, либо "
"<parameter>count</parameter> меньше 0"

#: spi.xml:1522(symbol)
msgid "SPI_ERROR_PARAM"
msgstr "SPI_ERROR_PARAM"

#: spi.xml:1524(para)
msgid ""
"if <parameter>values</parameter> is <symbol>NULL</symbol> and "
"<parameter>plan</parameter> was prepared with some parameters"
msgstr ""
"Если в <parameter>values</parameter> передан <symbol>NULL</symbol> и "
"<parameter>plan</parameter> был подготовлен с другими параметрами"

#: spi.xml:1506(para)
msgid ""
"The return value is the same as for <function>SPI_execute</function>, with "
"the following additional possible error (negative) results: <placeholder-1/>"
msgstr ""
"Возвращаемые значения те же, что и у <function>SPI_execute</function>, со "
"следующими дополнительными вариантами ошибок (отрицательных результатов): "
"<placeholder-1/>"

#: spi.xml:1544(indexterm)
msgid "<primary>SPI_execute_plan_with_paramlist</primary>"
msgstr "<primary>SPI_execute_plan_with_paramlist</primary>"

#: spi.xml:1547(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execute_plan_with_paramlist"
msgstr "SPI_execute_plan_with_paramlist"

#: spi.xml:1552(refname)
msgctxt "refname"
msgid "SPI_execute_plan_with_paramlist"
msgstr "SPI_execute_plan_with_paramlist"

#: spi.xml:1559(parameter) spi.xml:1594(parameter) spi.xml:2036(parameter)
#: spi.xml:2086(parameter)
msgid "params"
msgstr "params"

#: spi.xml:1557(synopsis)
#, no-wrap
msgid ""
"int SPI_execute_plan_with_paramlist(SPIPlanPtr <placeholder-1/>,\n"
"                                    ParamListInfo <placeholder-2/>,\n"
"                                    bool <placeholder-3/>,\n"
"                                    long <placeholder-4/>)"
msgstr ""
"int SPI_execute_plan_with_paramlist(SPIPlanPtr <placeholder-1/>,\n"
"                                    ParamListInfo <placeholder-2/>,\n"
"                                    bool <placeholder-3/>,\n"
"                                    long <placeholder-4/>)"

#: spi.xml:1568(para)
msgid ""
"<function>SPI_execute_plan_with_paramlist</function> executes a statement "
"prepared by <function>SPI_prepare</function>. This function is equivalent to "
"<function>SPI_execute_plan</function> except that information about the "
"parameter values to be passed to the query is presented differently. The "
"<literal>ParamListInfo</literal> representation can be convenient for "
"passing down values that are already available in that format. It also "
"supports use of dynamic parameter sets via hook functions specified in "
"<literal>ParamListInfo</literal>."
msgstr ""
"<function>SPI_execute_plan_with_paramlist</function> выполняет оператор, "
"подготовленный функцией <function>SPI_prepare</function>. Данная функция "
"равнозначна <function>SPI_execute_plan</function>, не считая того, что "
"информация о значениях параметров, передаваемых запросу, представляется по-"
"другому. Представление <literal>ParamListInfo</literal> может быть удобным "
"для передачи значений, уже имеющих нужный формат. Эта функция также "
"поддерживает динамические наборы параметров, которые реализуются через "
"функции-обработчики, устанавливаемые в <literal>ParamListInfo</literal>."

#: spi.xml:1594(literal) spi.xml:2086(literal)
msgid "ParamListInfo <placeholder-1/>"
msgstr "ParamListInfo <placeholder-1/>"

#: spi.xml:1596(para) spi.xml:2088(para)
msgid "data structure containing parameter types and values; NULL if none"
msgstr ""
"структура данных, содержащая типы и значения параметров; NULL, если их нет"

#: spi.xml:1624(para)
msgid ""
"The return value is the same as for <function>SPI_execute_plan</function>."
msgstr ""
"Возвращаемые значения те же, что и у <function>SPI_execute_plan</function>."

#: spi.xml:1628(para)
msgid ""
"<varname>SPI_processed</varname> and <varname>SPI_tuptable</varname> are set "
"as in <function>SPI_execute_plan</function> if successful."
msgstr ""
"Переменные <varname>SPI_processed</varname> и <varname>SPI_tuptable</"
"varname> устанавливаются как в <function>SPI_execute_plan</function>, если "
"вызов был успешным."

#: spi.xml:1639(indexterm)
msgid "<primary>SPI_execp</primary>"
msgstr "<primary>SPI_execp</primary>"

#: spi.xml:1642(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_execp"
msgstr "SPI_execp"

#: spi.xml:1647(refname)
msgctxt "refname"
msgid "SPI_execp"
msgstr "SPI_execp"

#: spi.xml:1648(refpurpose)
msgid "execute a statement in read/write mode"
msgstr "выполнить оператор в режиме чтения/записи"

#: spi.xml:1652(synopsis)
#, no-wrap
msgid "int SPI_execp(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>, long <placeholder-4/>)"
msgstr "int SPI_execp(SPIPlanPtr <placeholder-1/>, Datum * <placeholder-2/>, const char * <placeholder-3/>, long <placeholder-4/>)"

#: spi.xml:1660(para)
msgid ""
"<function>SPI_execp</function> is the same as <function>SPI_execute_plan</"
"function>, with the latter's <parameter>read_only</parameter> parameter "
"always taken as <literal>false</literal>."
msgstr ""
"<function>SPI_execp</function> действует подобно <function>SPI_execute_plan</"
"function>, но ей не передаётся параметр <parameter>read_only</parameter> "
"(всегда подразумевается <literal>false</literal>)."

#: spi.xml:1699(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_execp</function> assumes that no parameters are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_execp</function> считает, что ни один из параметров не равен "
"NULL. В противном случае элемент массива <parameter>nulls</parameter> должен "
"содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль (<literal>'\\0'</literal>) в конце не нужен."

#: spi.xml:1728(para)
msgid "See <function>SPI_execute_plan</function>."
msgstr "См. <function>SPI_execute_plan</function>."

#: spi.xml:1743(indexterm)
msgid "<primary>SPI_cursor_open</primary>"
msgstr "<primary>SPI_cursor_open</primary>"

#: spi.xml:1746(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_open"
msgstr "SPI_cursor_open"

#: spi.xml:1751(refname)
msgctxt "refname"
msgid "SPI_cursor_open"
msgstr "SPI_cursor_open"

#: spi.xml:1752(refpurpose)
msgid "set up a cursor using a statement created with <placeholder-1/>"
msgstr "открыть курсор для оператора, созданного функцией <placeholder-1/>"

#: spi.xml:1757(parameter) spi.xml:1795(parameter) spi.xml:1881(parameter)
#: spi.xml:1920(parameter) spi.xml:2034(parameter) spi.xml:2067(parameter)
#: spi.xml:2130(parameter) spi.xml:2149(parameter)
msgid "name"
msgstr "name"

#: spi.xml:1756(synopsis)
#, no-wrap
msgid ""
"Portal SPI_cursor_open(const char * <placeholder-1/>, SPIPlanPtr <placeholder-2/>,\n"
"                       Datum * <placeholder-3/>, const char * <placeholder-4/>,\n"
"                       bool <placeholder-5/>)"
msgstr ""
"Portal SPI_cursor_open(const char * <placeholder-1/>, SPIPlanPtr <placeholder-2/>,\n"
"                       Datum * <placeholder-3/>, const char * <placeholder-4/>,\n"
"                       bool <placeholder-5/>)"

#: spi.xml:1766(para)
msgid ""
"<function>SPI_cursor_open</function> sets up a cursor (internally, a portal) "
"that will execute a statement prepared by <function>SPI_prepare</function>. "
"The parameters have the same meanings as the corresponding parameters to "
"<function>SPI_execute_plan</function>."
msgstr ""
"<function>SPI_cursor_open</function> открывает курсор (внутри называемый "
"порталом), через который будет выполняться оператор, подготовленный функцией "
"<function>SPI_prepare</function>. Параметры этой функции имеют тот же смысл, "
"что и соответствующие параметры <function>SPI_execute_plan</function>."

#: spi.xml:1774(para)
msgid ""
"Using a cursor instead of executing the statement directly has two benefits. "
"First, the result rows can be retrieved a few at a time, avoiding memory "
"overrun for queries that return many rows. Second, a portal can outlive the "
"current procedure (it can, in fact, live to the end of the current "
"transaction). Returning the portal name to the procedure's caller provides a "
"way of returning a row set as result."
msgstr ""
"Применение курсора по сравнению с непосредственным выполнением оператора "
"даёт двойную выгоду. Во-первых, строки результата можно получать в небольших "
"количествах, без риска исчерпать всю память при выполнении запросов, "
"возвращающих много строк. Во-вторых, портал может существовать и после "
"завершения текущей процедуры (на самом деле, он может просуществовать до "
"конца текущей транзакции). Возвратив имя портала в код, вызывающий "
"процедуру, можно организовать выдачу результата в виде набора строк."

#: spi.xml:1784(para) spi.xml:1909(para) spi.xml:2056(para)
msgid ""
"The passed-in parameter data will be copied into the cursor's portal, so it "
"can be freed while the cursor still exists."
msgstr ""
"Переданные значения параметров копируются в портал курсора, так что их можно "
"освободить и во время существования курсора."

#: spi.xml:1797(para) spi.xml:1922(para) spi.xml:2069(para)
msgid ""
"name for portal, or <symbol>NULL</symbol> to let the system select a name"
msgstr "имя портала, либо <symbol>NULL</symbol>, чтобы имя выбрала система"

#: spi.xml:1831(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_cursor_open</function> assumes that no parameters are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding parameter value is non-"
"null, or <literal>'n'</literal> if the corresponding parameter value is "
"null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_cursor_open</function> считает, что ни один из параметров не "
"равен NULL. В противном случае элемент массива <parameter>nulls</parameter> "
"должен содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль (<literal>'\\0'</literal>) в конце не нужен."

#: spi.xml:1857(para) spi.xml:2010(para) spi.xml:2106(para)
msgid ""
"Pointer to portal containing the cursor. Note there is no error return "
"convention; any error will be reported via <function>elog</function>."
msgstr ""
"Указатель на портал, содержащий курсор. Заметьте, что соглашение о возврате "
"ошибок отсутствует; все ошибки выдаются через <function>elog</function>."

#: spi.xml:1867(indexterm)
msgid "<primary>SPI_cursor_open_with_args</primary>"
msgstr "<primary>SPI_cursor_open_with_args</primary>"

#: spi.xml:1870(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_open_with_args"
msgstr "SPI_cursor_open_with_args"

#: spi.xml:1875(refname)
msgctxt "refname"
msgid "SPI_cursor_open_with_args"
msgstr "SPI_cursor_open_with_args"

#: spi.xml:1876(refpurpose)
msgid "set up a cursor using a query and parameters"
msgstr "открывает курсор для запроса с параметрами"

#: spi.xml:1880(synopsis)
#, no-wrap
msgid ""
"Portal SPI_cursor_open_with_args(const char *<placeholder-1/>,\n"
"                                 const char *<placeholder-2/>,\n"
"                                 int <placeholder-3/>, Oid *<placeholder-4/>,\n"
"                                 Datum *<placeholder-5/>, const char *<placeholder-6/>,\n"
"                                 bool <placeholder-7/>, int <placeholder-8/>)"
msgstr ""
"Portal SPI_cursor_open_with_args(const char *<placeholder-1/>,\n"
"                                 const char *<placeholder-2/>,\n"
"                                 int <placeholder-3/>, Oid *<placeholder-4/>,\n"
"                                 Datum *<placeholder-5/>, const char *<placeholder-6/>,\n"
"                                 bool <placeholder-7/>, int <placeholder-8/>)"

#: spi.xml:1892(para)
msgid ""
"<function>SPI_cursor_open_with_args</function> sets up a cursor (internally, "
"a portal) that will execute the specified query. Most of the parameters have "
"the same meanings as the corresponding parameters to "
"<function>SPI_prepare_cursor</function> and <function>SPI_cursor_open</"
"function>."
msgstr ""
"<function>SPI_cursor_open_with_args</function> открывает курсор (внутри "
"называемый порталом) для выполнения заданного запроса. Большинство "
"параметров имеют тот же смысл, что и соответствующие параметры функций "
"<function>SPI_prepare_cursor</function> и <function>SPI_cursor_open</"
"function>."

#: spi.xml:1900(para)
msgid ""
"For one-time query execution, this function should be preferred over "
"<function>SPI_prepare_cursor</function> followed by "
"<function>SPI_cursor_open</function>. If the same command is to be executed "
"with many different parameters, either method might be faster, depending on "
"the cost of re-planning versus the benefit of custom plans."
msgstr ""
"Для разового выполнения запроса эту функцию следует предпочесть "
"<function>SPI_prepare_cursor</function> с последующей "
"<function>SPI_cursor_open</function>. Если же одна и та же команда должна "
"выполняться с самыми разными параметрами, какой вариант окажется быстрее, "
"будет зависеть от стоимости повторного планирования и выигрыша от выбора "
"специализированных планов."

#: spi.xml:1975(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_cursor_open_with_args</function> assumes that no parameters "
"are null. Otherwise, each entry of the <parameter>nulls</parameter> array "
"should be <literal>'&nbsp;'</literal> if the corresponding parameter value "
"is non-null, or <literal>'n'</literal> if the corresponding parameter value "
"is null. (In the latter case, the actual value in the corresponding "
"<parameter>values</parameter> entry doesn't matter.) Note that "
"<parameter>nulls</parameter> is not a text string, just an array: it does "
"not need a <literal>'\\0'</literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_cursor_open_with_args</function> считает, что ни один из "
"параметров не равен NULL. В противном случае, элемент массива "
"<parameter>nulls</parameter> должен содержать <literal>'&nbsp;'</literal>, "
"если значение соответствующего параметра не NULL, либо <literal>'n'</"
"literal>, если это значение — NULL. (В последнем случае значение, переданное "
"в соответствующем элементе <parameter>values</parameter>, не учитывается.) "
"Заметьте, что <parameter>nulls</parameter> — это не текстовая строка, а "
"просто массив: ноль (<literal>'\\0'</literal>) в конце не нужен."

#: spi.xml:2020(indexterm)
msgid "<primary>SPI_cursor_open_with_paramlist</primary>"
msgstr "<primary>SPI_cursor_open_with_paramlist</primary>"

#: spi.xml:2023(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_open_with_paramlist"
msgstr "SPI_cursor_open_with_paramlist"

#: spi.xml:2028(refname)
msgctxt "refname"
msgid "SPI_cursor_open_with_paramlist"
msgstr "SPI_cursor_open_with_paramlist"

#: spi.xml:2029(refpurpose)
msgid "set up a cursor using parameters"
msgstr "открыть курсор с параметрами"

#: spi.xml:2033(synopsis)
#, no-wrap
msgid ""
"Portal SPI_cursor_open_with_paramlist(const char *<placeholder-1/>,\n"
"                                      SPIPlanPtr <placeholder-2/>,\n"
"                                      ParamListInfo <placeholder-3/>,\n"
"                                      bool <placeholder-4/>)"
msgstr ""
"Portal SPI_cursor_open_with_paramlist(const char *<placeholder-1/>,\n"
"                                      SPIPlanPtr <placeholder-2/>,\n"
"                                      ParamListInfo <placeholder-3/>,\n"
"                                      bool <placeholder-4/>)"

#: spi.xml:2044(para)
msgid ""
"<function>SPI_cursor_open_with_paramlist</function> sets up a cursor "
"(internally, a portal) that will execute a statement prepared by "
"<function>SPI_prepare</function>. This function is equivalent to "
"<function>SPI_cursor_open</function> except that information about the "
"parameter values to be passed to the query is presented differently. The "
"<literal>ParamListInfo</literal> representation can be convenient for "
"passing down values that are already available in that format. It also "
"supports use of dynamic parameter sets via hook functions specified in "
"<literal>ParamListInfo</literal>."
msgstr ""
"<function>SPI_cursor_open_with_paramlist</function> открывает курсор (внутри "
"называемый порталом) для выполнения оператора, подготовленного функцией "
"<function>SPI_prepare</function>. Эта функция равнозначна "
"<function>SPI_cursor_open</function>, не считая того, что информация о "
"значениях параметров, передаваемых запросу, представляется по-другому. "
"Представление <literal>ParamListInfo</literal> может быть удобным для "
"передачи значений, уже имеющих нужный формат. Эта функция также поддерживает "
"динамические наборы параметров через функции-обработчики, устанавливаемые в "
"<literal>ParamListInfo</literal>."

#: spi.xml:2116(indexterm)
msgid "<primary>SPI_cursor_find</primary>"
msgstr "<primary>SPI_cursor_find</primary>"

#: spi.xml:2119(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_find"
msgstr "SPI_cursor_find"

#: spi.xml:2124(refname)
msgctxt "refname"
msgid "SPI_cursor_find"
msgstr "SPI_cursor_find"

#: spi.xml:2125(refpurpose)
msgid "find an existing cursor by name"
msgstr "найти существующий курсор по имени"

#: spi.xml:2129(synopsis)
#, no-wrap
msgid "Portal SPI_cursor_find(const char * <placeholder-1/>)"
msgstr "Portal SPI_cursor_find(const char * <placeholder-1/>)"

#: spi.xml:2137(para)
msgid ""
"<function>SPI_cursor_find</function> finds an existing portal by name. This "
"is primarily useful to resolve a cursor name returned as text by some other "
"function."
msgstr ""
"<function>SPI_cursor_find</function> находит существующий портал по имени. В "
"основном это полезно для разрешения имени курсора, возвращённого в текстовом "
"виде какой-то другой функцией."

#: spi.xml:2151(para)
msgid "name of the portal"
msgstr "имя портала"

#: spi.xml:2162(para)
msgid ""
"pointer to the portal with the specified name, or <symbol>NULL</symbol> if "
"none was found"
msgstr ""
"указатель на портал с заданным именем или <symbol>NULL</symbol>, если такой "
"портал не найден"

#: spi.xml:2172(indexterm)
msgid "<primary>SPI_cursor_fetch</primary>"
msgstr "<primary>SPI_cursor_fetch</primary>"

#: spi.xml:2175(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_fetch"
msgstr "SPI_cursor_fetch"

#: spi.xml:2180(refname)
msgctxt "refname"
msgid "SPI_cursor_fetch"
msgstr "SPI_cursor_fetch"

#: spi.xml:2181(refpurpose) spi.xml:2341(refpurpose)
msgid "fetch some rows from a cursor"
msgstr "выбрать строки через курсор"

#: spi.xml:2186(parameter) spi.xml:2206(parameter) spi.xml:2271(parameter)
#: spi.xml:2291(parameter) spi.xml:2346(parameter) spi.xml:2365(parameter)
#: spi.xml:2445(parameter) spi.xml:2465(parameter) spi.xml:2546(parameter)
#: spi.xml:2570(parameter)
msgid "portal"
msgstr "portal"

#: spi.xml:2186(parameter) spi.xml:2215(parameter) spi.xml:2271(parameter)
#: spi.xml:2300(parameter)
msgid "forward"
msgstr "forward"

#: spi.xml:2185(synopsis)
#, no-wrap
msgid "void SPI_cursor_fetch(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"
msgstr "void SPI_cursor_fetch(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"

#: spi.xml:2193(para)
msgid ""
"<function>SPI_cursor_fetch</function> fetches some rows from a cursor. This "
"is equivalent to a subset of the SQL command <command>FETCH</command> (see "
"<function>SPI_scroll_cursor_fetch</function> for more functionality)."
msgstr ""
"<function>SPI_cursor_fetch</function> выбирает некоторое количество строк "
"через курсор. Эта функция реализует подмножество возможностей SQL-команды "
"<command>FETCH</command> (расширенную функциональность предоставляет "
"<function>SPI_scroll_cursor_fetch</function>)."

#: spi.xml:2206(literal) spi.xml:2291(literal) spi.xml:2365(literal)
#: spi.xml:2465(literal) spi.xml:2570(literal)
msgid "Portal <placeholder-1/>"
msgstr "Portal <placeholder-1/>"

#: spi.xml:2208(para) spi.xml:2293(para) spi.xml:2367(para) spi.xml:2467(para)
#: spi.xml:2572(para)
msgid "portal containing the cursor"
msgstr "портал, содержащий курсор"

#: spi.xml:2217(para)
msgid "true for fetch forward, false for fetch backward"
msgstr "true для выборки с перемещением вперёд, false — назад"

#: spi.xml:2226(para)
msgid "maximum number of rows to fetch"
msgstr "максимальное число строк, которое нужно выбрать"

#: spi.xml:2247(para)
msgid ""
"Fetching backward may fail if the cursor's plan was not created with the "
"<symbol>CURSOR_OPT_SCROLL</symbol> option."
msgstr ""
"Выборка назад может не поддерживаться, если план курсора был создан без "
"параметра <symbol>CURSOR_OPT_SCROLL</symbol>."

#: spi.xml:2257(indexterm)
msgid "<primary>SPI_cursor_move</primary>"
msgstr "<primary>SPI_cursor_move</primary>"

#: spi.xml:2260(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_move"
msgstr "SPI_cursor_move"

#: spi.xml:2265(refname)
msgctxt "refname"
msgid "SPI_cursor_move"
msgstr "SPI_cursor_move"

#: spi.xml:2266(refpurpose) spi.xml:2440(refpurpose)
msgid "move a cursor"
msgstr "переместить курсор"

#: spi.xml:2270(synopsis)
#, no-wrap
msgid "void SPI_cursor_move(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"
msgstr "void SPI_cursor_move(Portal <placeholder-1/>, bool <placeholder-2/>, long <placeholder-3/>)"

#: spi.xml:2278(para)
msgid ""
"<function>SPI_cursor_move</function> skips over some number of rows in a "
"cursor. This is equivalent to a subset of the SQL command <command>MOVE</"
"command> (see <function>SPI_scroll_cursor_move</function> for more "
"functionality)."
msgstr ""
"<function>SPI_cursor_move</function> перемещает курсор на несколько строк. "
"Эта функция реализует подмножество возможностей SQL-команды <command>MOVE</"
"command> (расширенную функциональность предоставляет "
"<function>SPI_scroll_cursor_move</function>)."

#: spi.xml:2302(para)
msgid "true for move forward, false for move backward"
msgstr "true для перемещения вперёд, false — назад"

#: spi.xml:2311(para)
msgid "maximum number of rows to move"
msgstr "максимальное число строк, на какое возможно перемещение"

#: spi.xml:2322(para)
msgid ""
"Moving backward may fail if the cursor's plan was not created with the "
"<symbol>CURSOR_OPT_SCROLL</symbol> option."
msgstr ""
"Перемещение назад может не поддерживаться, если план курсора был создан без "
"параметра <symbol>CURSOR_OPT_SCROLL</symbol>."

#: spi.xml:2332(indexterm)
msgid "<primary>SPI_scroll_cursor_fetch</primary>"
msgstr "<primary>SPI_scroll_cursor_fetch</primary>"

#: spi.xml:2335(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_scroll_cursor_fetch"
msgstr "SPI_scroll_cursor_fetch"

#: spi.xml:2340(refname)
msgctxt "refname"
msgid "SPI_scroll_cursor_fetch"
msgstr "SPI_scroll_cursor_fetch"

#: spi.xml:2346(parameter) spi.xml:2374(parameter) spi.xml:2445(parameter)
#: spi.xml:2474(parameter)
msgid "direction"
msgstr "direction"

#: spi.xml:2345(synopsis)
#, no-wrap
msgid ""
"void SPI_scroll_cursor_fetch(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                             long <placeholder-3/>)"
msgstr ""
"void SPI_scroll_cursor_fetch(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                             long <placeholder-3/>)"

#: spi.xml:2354(para)
msgid ""
"<function>SPI_scroll_cursor_fetch</function> fetches some rows from a "
"cursor. This is equivalent to the SQL command <command>FETCH</command>."
msgstr ""
"<function>SPI_scroll_cursor_fetch</function> выбирает некоторое количество "
"строк через курсор. Её функциональность равнозначна <command>FETCH</command> "
"в SQL."

#: spi.xml:2374(literal) spi.xml:2474(literal)
msgid "FetchDirection <placeholder-1/>"
msgstr "FetchDirection <placeholder-1/>"

#: spi.xml:2376(para) spi.xml:2476(para)
msgid ""
"one of <symbol>FETCH_FORWARD</symbol>, <symbol>FETCH_BACKWARD</symbol>, "
"<symbol>FETCH_ABSOLUTE</symbol> or <symbol>FETCH_RELATIVE</symbol>"
msgstr ""
"один из вариантов: <symbol>FETCH_FORWARD</symbol>, <symbol>FETCH_BACKWARD</"
"symbol>, <symbol>FETCH_ABSOLUTE</symbol> или <symbol>FETCH_RELATIVE</symbol>"

#: spi.xml:2388(para)
msgid ""
"number of rows to fetch for <symbol>FETCH_FORWARD</symbol> or "
"<symbol>FETCH_BACKWARD</symbol>; absolute row number to fetch for "
"<symbol>FETCH_ABSOLUTE</symbol>; or relative row number to fetch for "
"<symbol>FETCH_RELATIVE</symbol>"
msgstr ""
"число строк, выбираемых с направлением <symbol>FETCH_FORWARD</symbol> или "
"<symbol>FETCH_BACKWARD</symbol>; абсолютный номер выбираемой строки с "
"вариантом <symbol>FETCH_ABSOLUTE</symbol>; либо относительный номер "
"выбираемой строки с вариантом <symbol>FETCH_RELATIVE</symbol>"

#: spi.xml:2413(para) spi.xml:2514(para)
msgid ""
"See the SQL <xref linkend=\"sql-fetch\"/> command for details of the "
"interpretation of the <parameter>direction</parameter> and <parameter>count</"
"parameter> parameters."
msgstr ""
"Подробнее о параметрах <parameter>direction</parameter> и <parameter>count</"
"parameter> рассказывается в описании SQL-команды <xref linkend=\"sql-fetch\"/"
">."

#: spi.xml:2420(para) spi.xml:2521(para)
msgid ""
"Direction values other than <symbol>FETCH_FORWARD</symbol> may fail if the "
"cursor's plan was not created with the <symbol>CURSOR_OPT_SCROLL</symbol> "
"option."
msgstr ""
"Варианты направления, отличные от <symbol>FETCH_FORWARD</symbol>, могут не "
"поддерживаться, если план курсора был создан без параметра "
"<symbol>CURSOR_OPT_SCROLL</symbol>."

#: spi.xml:2431(indexterm)
msgid "<primary>SPI_scroll_cursor_move</primary>"
msgstr "<primary>SPI_scroll_cursor_move</primary>"

#: spi.xml:2434(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_scroll_cursor_move"
msgstr "SPI_scroll_cursor_move"

#: spi.xml:2439(refname)
msgctxt "refname"
msgid "SPI_scroll_cursor_move"
msgstr "SPI_scroll_cursor_move"

#: spi.xml:2444(synopsis)
#, no-wrap
msgid ""
"void SPI_scroll_cursor_move(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                            long <placeholder-3/>)"
msgstr ""
"void SPI_scroll_cursor_move(Portal <placeholder-1/>, FetchDirection <placeholder-2/>,\n"
"                            long <placeholder-3/>)"

#: spi.xml:2453(para)
msgid ""
"<function>SPI_scroll_cursor_move</function> skips over some number of rows "
"in a cursor. This is equivalent to the SQL command <command>MOVE</command>."
msgstr ""
"<function>SPI_scroll_cursor_move</function> перемещает курсор на несколько "
"строк. Её функциональность равнозначна <command>MOVE</command> в SQL."

#: spi.xml:2488(para)
msgid ""
"number of rows to move for <symbol>FETCH_FORWARD</symbol> or "
"<symbol>FETCH_BACKWARD</symbol>; absolute row number to move to for "
"<symbol>FETCH_ABSOLUTE</symbol>; or relative row number to move to for "
"<symbol>FETCH_RELATIVE</symbol>"
msgstr ""
"число строк, на которое сдвигается курсор, с направлением "
"<symbol>FETCH_FORWARD</symbol> или <symbol>FETCH_BACKWARD</symbol>; "
"абсолютный номер строки, к которой переходит курсор, с направлением "
"<symbol>FETCH_ABSOLUTE</symbol>; либо относительный номер строки, к которой "
"переходит курсор, с направлением <symbol>FETCH_RELATIVE</symbol>"

#: spi.xml:2503(para)
msgid ""
"<varname>SPI_processed</varname> is set as in <function>SPI_execute</"
"function> if successful. <varname>SPI_tuptable</varname> is set to "
"<symbol>NULL</symbol>, since no rows are returned by this function."
msgstr ""
"В случае успеха переменная <varname>SPI_processed</varname> устанавливается "
"как в <function>SPI_execute</function>. В <varname>SPI_tuptable</varname> "
"оказывается <symbol>NULL</symbol>, так как эта функция не возвращает никакие "
"строки."

#: spi.xml:2532(indexterm)
msgid "<primary>SPI_cursor_close</primary>"
msgstr "<primary>SPI_cursor_close</primary>"

#: spi.xml:2535(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_cursor_close"
msgstr "SPI_cursor_close"

#: spi.xml:2540(refname)
msgctxt "refname"
msgid "SPI_cursor_close"
msgstr "SPI_cursor_close"

#: spi.xml:2541(refpurpose)
msgid "close a cursor"
msgstr "закрыть курсор"

#: spi.xml:2545(synopsis)
#, no-wrap
msgid "void SPI_cursor_close(Portal <placeholder-1/>)"
msgstr "void SPI_cursor_close(Portal <placeholder-1/>)"

#: spi.xml:2553(para)
msgid ""
"<function>SPI_cursor_close</function> closes a previously created cursor and "
"releases its portal storage."
msgstr ""
"<function>SPI_cursor_close</function> закрывает ранее созданный курсор и "
"освобождает память, занятую его порталом."

#: spi.xml:2558(para)
msgid ""
"All open cursors are closed automatically at the end of a transaction. "
"<function>SPI_cursor_close</function> need only be invoked if it is "
"desirable to release resources sooner."
msgstr ""
"Все открытые курсоры закрываются автоматически в конце транзакции. Вызывать "
"<function>SPI_cursor_close</function> может потребоваться, только если "
"возникает желание освободить ресурсы скорее."

#: spi.xml:2584(indexterm)
msgid "<primary>SPI_keepplan</primary>"
msgstr "<primary>SPI_keepplan</primary>"

#: spi.xml:2587(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_keepplan"
msgstr "SPI_keepplan"

#: spi.xml:2592(refname)
msgctxt "refname"
msgid "SPI_keepplan"
msgstr "SPI_keepplan"

#: spi.xml:2593(refpurpose) spi.xml:2662(refpurpose)
msgid "save a prepared statement"
msgstr "сохранить подготовленный оператор"

#: spi.xml:2597(synopsis)
#, no-wrap
msgid "int SPI_keepplan(SPIPlanPtr <placeholder-1/>)"
msgstr "int SPI_keepplan(SPIPlanPtr <placeholder-1/>)"

#: spi.xml:2605(para)
msgid ""
"<function>SPI_keepplan</function> saves a passed statement (prepared by "
"<function>SPI_prepare</function>) so that it will not be freed by "
"<function>SPI_finish</function> nor by the transaction manager. This gives "
"you the ability to reuse prepared statements in the subsequent invocations "
"of your procedure in the current session."
msgstr ""
"<function>SPI_keepplan</function> сохраняет переданный оператор "
"(подготовленный функцией <function>SPI_prepare</function>), чтобы он не был "
"ликвидирован функцией <function>SPI_finish</function> или диспетчером "
"транзакций. Это даёт возможность повторно использовать подготовленные "
"операторы при последующих вызовах вашей процедуры в текущем сеансе."

#: spi.xml:2621(para) spi.xml:2691(para)
msgid "the prepared statement to be saved"
msgstr "подготовленный оператор, который нужно сохранить"

#: spi.xml:2632(para) spi.xml:4026(para)
msgid ""
"0 on success; <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</"
"parameter> is <symbol>NULL</symbol> or invalid"
msgstr ""
"0 в случае успеха; <symbol>SPI_ERROR_ARGUMENT</symbol>, если "
"<parameter>plan</parameter> неверный или <symbol>NULL</symbol>"

#: spi.xml:2642(para)
msgid ""
"The passed-in statement is relocated to permanent storage by means of "
"pointer adjustment (no data copying is required). If you later wish to "
"delete it, use <function>SPI_freeplan</function> on it."
msgstr ""
"Переданный оператор перемещается в постоянное хранилище путём смены "
"указателя (копировать данные не требуется). Если позже вы захотите удалить "
"его, выполните для него <function>SPI_freeplan</function>."

#: spi.xml:2653(indexterm)
msgid "<primary>SPI_saveplan</primary>"
msgstr "<primary>SPI_saveplan</primary>"

#: spi.xml:2656(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_saveplan"
msgstr "SPI_saveplan"

#: spi.xml:2661(refname)
msgctxt "refname"
msgid "SPI_saveplan"
msgstr "SPI_saveplan"

#: spi.xml:2666(synopsis)
#, no-wrap
msgid "SPIPlanPtr SPI_saveplan(SPIPlanPtr <placeholder-1/>)"
msgstr "SPIPlanPtr SPI_saveplan(SPIPlanPtr <placeholder-1/>)"

#: spi.xml:2674(para)
msgid ""
"<function>SPI_saveplan</function> copies a passed statement (prepared by "
"<function>SPI_prepare</function>) into memory that will not be freed by "
"<function>SPI_finish</function> nor by the transaction manager, and returns "
"a pointer to the copied statement. This gives you the ability to reuse "
"prepared statements in the subsequent invocations of your procedure in the "
"current session."
msgstr ""
"<function>SPI_saveplan</function> копирует переданный оператор "
"(подготовленный функцией <function>SPI_prepare</function>) в память, чтобы "
"он не был ликвидирован функцией <function>SPI_finish</function> или "
"менеджером транзакций, и возвращает указатель на скопированный оператор. Это "
"даёт возможность повторно использовать подготовленные операторы при "
"последующих вызовах вашей процедуры в текущем сеансе."

#: spi.xml:2710(para)
msgid "if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid"
msgstr "если <parameter>plan</parameter> неверный или <symbol>NULL</symbol>"

#: spi.xml:2702(para)
msgid ""
"Pointer to the copied statement; or <symbol>NULL</symbol> if unsuccessful. "
"On error, <varname>SPI_result</varname> is set thus: <placeholder-1/>"
msgstr ""
"Указатель на скопированный оператор, либо <symbol>NULL</symbol> в случае "
"ошибки. При ошибке <varname>SPI_result</varname> принимает одно из этих "
"значений: <placeholder-1/>"

#: spi.xml:2731(para)
msgid ""
"The originally passed-in statement is not freed, so you might wish to do "
"<function>SPI_freeplan</function> on it to avoid leaking memory until "
"<function>SPI_finish</function>."
msgstr ""
"Изначально переданный оператор не освобождается, поэтому вы можете выполнить "
"<function>SPI_freeplan</function> для него, чтобы высвободить память до "
"<function>SPI_finish</function>."

#: spi.xml:2737(para)
msgid ""
"In most cases, <function>SPI_keepplan</function> is preferred to this "
"function, since it accomplishes largely the same result without needing to "
"physically copy the prepared statement's data structures."
msgstr ""
"В большинстве случаев <function>SPI_keepplan</function> предпочтительнее "
"данной функции, так как она даёт примерно тот же результат, но обходится без "
"физического копирования структур данных подготовленного оператора."

#: spi.xml:2748(title)
msgid "Interface Support Functions"
msgstr "Вспомогательные интерфейсные функции"

#: spi.xml:2750(para)
msgid ""
"The functions described here provide an interface for extracting information "
"from result sets returned by <function>SPI_execute</function> and other SPI "
"functions."
msgstr ""
"Функции, описанные здесь, предоставляют возможности для извлечения "
"информации из наборов результатов, возвращаемых <function>SPI_execute</"
"function> и другими функциями SPI."

#: spi.xml:2756(para)
msgid ""
"All functions described in this section can be used by both connected and "
"unconnected procedures."
msgstr ""
"Все функции, описанные в этом разделе, могут использоваться и в "
"подключённых, и в неподключённых процедурах."

#: spi.xml:2764(indexterm)
msgid "<primary>SPI_fname</primary>"
msgstr "<primary>SPI_fname</primary>"

#: spi.xml:2767(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_fname"
msgstr "SPI_fname"

#: spi.xml:2772(refname)
msgctxt "refname"
msgid "SPI_fname"
msgstr "SPI_fname"

#: spi.xml:2773(refpurpose)
msgid "determine the column name for the specified column number"
msgstr "определить имя столбца с заданным номером"

#: spi.xml:2778(parameter) spi.xml:2797(parameter) spi.xml:2845(parameter)
#: spi.xml:2872(parameter) spi.xml:2919(parameter) spi.xml:2953(parameter)
#: spi.xml:3003(parameter) spi.xml:3037(parameter) spi.xml:3098(parameter)
#: spi.xml:3117(parameter) spi.xml:3164(parameter) spi.xml:3182(parameter)
#: spi.xml:3652(parameter) spi.xml:3687(parameter)
msgid "rowdesc"
msgstr "rowdesc"

#: spi.xml:2778(parameter) spi.xml:2806(parameter) spi.xml:2919(parameter)
#: spi.xml:2962(parameter) spi.xml:3003(parameter) spi.xml:3046(parameter)
#: spi.xml:3098(parameter) spi.xml:3126(parameter) spi.xml:3164(parameter)
#: spi.xml:3191(parameter)
msgid "colnumber"
msgstr "colnumber"

#: spi.xml:2777(synopsis)
#, no-wrap
msgid "char * SPI_fname(TupleDesc <placeholder-1/>, int <placeholder-2/>)"
msgstr "char * SPI_fname(TupleDesc <placeholder-1/>, int <placeholder-2/>)"

#: spi.xml:2785(para)
msgid ""
"<function>SPI_fname</function> returns a copy of the column name of the "
"specified column. (You can use <function>pfree</function> to release the "
"copy of the name when you don't need it anymore.)"
msgstr ""
"<function>SPI_fname</function> возвращает копию имени столбца с заданным "
"номером. (Когда эта копия имени будет не нужна, её можно освободить с "
"помощью <function>pfree</function>.)"

#: spi.xml:2797(literal) spi.xml:2872(literal) spi.xml:2953(literal)
#: spi.xml:3037(literal) spi.xml:3117(literal) spi.xml:3182(literal)
#: spi.xml:3687(literal)
msgid "TupleDesc <placeholder-1/>"
msgstr "TupleDesc <placeholder-1/>"

#: spi.xml:2799(para) spi.xml:2874(para) spi.xml:2955(para) spi.xml:3039(para)
#: spi.xml:3119(para) spi.xml:3184(para)
msgid "input row description"
msgstr "описание строк"

#: spi.xml:2808(para) spi.xml:2964(para) spi.xml:3048(para) spi.xml:3128(para)
#: spi.xml:3193(para)
msgid "column number (count starts at 1)"
msgstr "номер столбца (начиная с 1)"

#: spi.xml:2819(para)
msgid ""
"The column name; <symbol>NULL</symbol> if <parameter>colnumber</parameter> "
"is out of range. <varname>SPI_result</varname> set to "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error."
msgstr ""
"Имя столбца; <symbol>NULL</symbol>, если <parameter>colnumber</parameter> "
"вне допустимого диапазона. В случае ошибки в <varname>SPI_result</varname> "
"устанавливается <symbol>SPI_ERROR_NOATTRIBUTE</symbol>."

#: spi.xml:2831(indexterm)
msgid "<primary>SPI_fnumber</primary>"
msgstr "<primary>SPI_fnumber</primary>"

#: spi.xml:2834(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_fnumber"
msgstr "SPI_fnumber"

#: spi.xml:2839(refname)
msgctxt "refname"
msgid "SPI_fnumber"
msgstr "SPI_fnumber"

#: spi.xml:2840(refpurpose)
msgid "determine the column number for the specified column name"
msgstr "определить номер столбца с заданным именем"

#: spi.xml:2845(parameter) spi.xml:2881(parameter)
msgid "colname"
msgstr "colname"

#: spi.xml:2844(synopsis)
#, no-wrap
msgid "int SPI_fnumber(TupleDesc <placeholder-1/>, const char * <placeholder-2/>)"
msgstr "int SPI_fnumber(TupleDesc <placeholder-1/>, const char * <placeholder-2/>)"

#: spi.xml:2852(para)
msgid ""
"<function>SPI_fnumber</function> returns the column number for the column "
"with the specified name."
msgstr ""
"<function>SPI_fnumber</function> возвращает номер столбца, имеющего заданное "
"имя."

#: spi.xml:2857(para)
msgid ""
"If <parameter>colname</parameter> refers to a system column (e.g., "
"<literal>oid</literal>) then the appropriate negative column number will be "
"returned. The caller should be careful to test the return value for exact "
"equality to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> to detect an error; "
"testing the result for less than or equal to 0 is not correct unless system "
"columns should be rejected."
msgstr ""
"Если <parameter>colname</parameter> ссылается на системный столбец "
"(например, <literal>oid</literal>), возвращается соответствующий "
"отрицательный номер столбца. Вызывающий должен проверять, не была ли "
"возвращена ошибка, сравнивая значение результата именно с "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>; проверка результата по условию "
"меньше или равно нулю не будет корректной, если только системные столбцы не "
"должны исключаться."

#: spi.xml:2883(para)
msgid "column name"
msgstr "имя столбца"

#: spi.xml:2894(para)
msgid ""
"Column number (count starts at 1), or <symbol>SPI_ERROR_NOATTRIBUTE</symbol> "
"if the named column was not found."
msgstr ""
"Номер столбца (начиная с 1), либо <symbol>SPI_ERROR_NOATTRIBUTE</symbol>, "
"если столбец с заданным именем не найден."

#: spi.xml:2905(indexterm)
msgid "<primary>SPI_getvalue</primary>"
msgstr "<primary>SPI_getvalue</primary>"

#: spi.xml:2908(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getvalue"
msgstr "SPI_getvalue"

#: spi.xml:2913(refname)
msgctxt "refname"
msgid "SPI_getvalue"
msgstr "SPI_getvalue"

#: spi.xml:2914(refpurpose)
msgid "return the string value of the specified column"
msgstr "получить строковое значение указанного столбца"

#: spi.xml:2919(parameter) spi.xml:2944(parameter) spi.xml:3003(parameter)
#: spi.xml:3028(parameter) spi.xml:3595(parameter) spi.xml:3615(parameter)
#: spi.xml:3652(parameter) spi.xml:3678(parameter) spi.xml:3727(parameter)
#: spi.xml:3758(parameter) spi.xml:3875(parameter) spi.xml:3899(parameter)
msgid "row"
msgstr "row"

#: spi.xml:2918(synopsis)
#, no-wrap
msgid "char * SPI_getvalue(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>)"
msgstr "char * SPI_getvalue(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>)"

#: spi.xml:2926(para)
msgid ""
"<function>SPI_getvalue</function> returns the string representation of the "
"value of the specified column."
msgstr ""
"<function>SPI_getvalue</function> возвращает строковое представление "
"значения указанного столбца."

#: spi.xml:2931(para)
msgid ""
"The result is returned in memory allocated using <function>palloc</"
"function>. (You can use <function>pfree</function> to release the memory "
"when you don't need it anymore.)"
msgstr ""
"Результат возвращается в памяти, размещённой функцией <function>palloc</"
"function>. (Когда он будет не нужен, эту память можно освободить с помощью "
"<function>pfree</function>.)"

#: spi.xml:2944(literal) spi.xml:3028(literal) spi.xml:3615(literal)
#: spi.xml:3678(literal) spi.xml:3758(literal) spi.xml:3899(literal)
msgid "HeapTuple <placeholder-1/>"
msgstr "HeapTuple <placeholder-1/>"

#: spi.xml:2946(para) spi.xml:3030(para)
msgid "input row to be examined"
msgstr "строка с нужными данными"

#: spi.xml:2975(para)
msgid ""
"Column value, or <symbol>NULL</symbol> if the column is null, "
"<parameter>colnumber</parameter> is out of range (<varname>SPI_result</"
"varname> is set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol>), or no output "
"function is available (<varname>SPI_result</varname> is set to "
"<symbol>SPI_ERROR_NOOUTFUNC</symbol>)."
msgstr ""
"Значение столбца, либо <symbol>NULL</symbol>, если столбец содержит NULL, "
"<parameter>colnumber</parameter> вне допустимого диапазона (в "
"<varname>SPI_result</varname> при этом устанавливается "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>) или если отсутствует функция вывода "
"(в <varname>SPI_result</varname> устанавливается "
"<symbol>SPI_ERROR_NOOUTFUNC</symbol>)."

#: spi.xml:2989(indexterm)
msgid "<primary>SPI_getbinval</primary>"
msgstr "<primary>SPI_getbinval</primary>"

#: spi.xml:2992(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getbinval"
msgstr "SPI_getbinval"

#: spi.xml:2997(refname)
msgctxt "refname"
msgid "SPI_getbinval"
msgstr "SPI_getbinval"

#: spi.xml:2998(refpurpose)
msgid "return the binary value of the specified column"
msgstr "получить двоичное значение указанного столбца"

#: spi.xml:3004(parameter) spi.xml:3055(parameter)
msgid "isnull"
msgstr "isnull"

#: spi.xml:3002(synopsis)
#, no-wrap
msgid ""
"Datum SPI_getbinval(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>,\n"
"                    bool * <placeholder-4/>)"
msgstr ""
"Datum SPI_getbinval(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>, int <placeholder-3/>,\n"
"                    bool * <placeholder-4/>)"

#: spi.xml:3011(para)
msgid ""
"<function>SPI_getbinval</function> returns the value of the specified column "
"in the internal form (as type <type>Datum</type>)."
msgstr ""
"<function>SPI_getbinval</function> возвращает значение указанного столбца во "
"внутренней форме (в структуре <type>Datum</type>)."

#: spi.xml:3016(para)
msgid ""
"This function does not allocate new space for the datum. In the case of a "
"pass-by-reference data type, the return value will be a pointer into the "
"passed row."
msgstr ""
"Это функция не выделяет новый блок памяти для данных. В случае с типом, "
"передаваемым по ссылке, возвращаемым значением будет указатель на переданную "
"строку данных."

#: spi.xml:3055(literal)
msgid "bool * <placeholder-1/>"
msgstr "bool * <placeholder-1/>"

#: spi.xml:3057(para)
msgid "flag for a null value in the column"
msgstr "признак того, что столбец содержит NULL"

#: spi.xml:3068(para)
msgid ""
"The binary value of the column is returned. The variable pointed to by "
"<parameter>isnull</parameter> is set to true if the column is null, else to "
"false."
msgstr ""
"Возвращается двоичное значение столбца. Если этот столбец содержит NULL, "
"переменной, на которую указывает <parameter>isnull</parameter>, "
"присваивается true; в противном случае — false."

#: spi.xml:3074(para)
msgid ""
"<varname>SPI_result</varname> is set to <symbol>SPI_ERROR_NOATTRIBUTE</"
"symbol> on error."
msgstr ""
"При ошибке в <varname>SPI_result</varname> устанавливается "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>."

#: spi.xml:3084(indexterm)
msgid "<primary>SPI_gettype</primary>"
msgstr "<primary>SPI_gettype</primary>"

#: spi.xml:3087(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_gettype"
msgstr "SPI_gettype"

#: spi.xml:3092(refname)
msgctxt "refname"
msgid "SPI_gettype"
msgstr "SPI_gettype"

#: spi.xml:3093(refpurpose)
msgid "return the data type name of the specified column"
msgstr "получить имя типа данных указанного столбца"

#: spi.xml:3097(synopsis)
#, no-wrap
msgid "char * SPI_gettype(TupleDesc <placeholder-1/>, int <placeholder-2/>)"
msgstr "char * SPI_gettype(TupleDesc <placeholder-1/>, int <placeholder-2/>)"

#: spi.xml:3105(para)
msgid ""
"<function>SPI_gettype</function> returns a copy of the data type name of the "
"specified column. (You can use <function>pfree</function> to release the "
"copy of the name when you don't need it anymore.)"
msgstr ""
"<function>SPI_gettype</function> возвращает копию имени типа данных "
"указанного столбца. (Когда эта копия имени будет не нужна, её можно "
"освободить с помощью <function>pfree</function>.)"

#: spi.xml:3139(para)
msgid ""
"The data type name of the specified column, or <symbol>NULL</symbol> on "
"error. <varname>SPI_result</varname> is set to "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error."
msgstr ""
"Имя типа данных указанного столбца, либо <symbol>NULL</symbol> в случае "
"ошибки. При ошибке в <varname>SPI_result</varname> устанавливается "
"<symbol>SPI_ERROR_NOATTRIBUTE</symbol>."

#: spi.xml:3150(indexterm)
msgid "<primary>SPI_gettypeid</primary>"
msgstr "<primary>SPI_gettypeid</primary>"

#: spi.xml:3153(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_gettypeid"
msgstr "SPI_gettypeid"

#: spi.xml:3158(refname)
msgctxt "refname"
msgid "SPI_gettypeid"
msgstr "SPI_gettypeid"

#: spi.xml:3159(acronym)
msgid "OID"
msgstr "OID"

#: spi.xml:3159(refpurpose)
msgid "return the data type <placeholder-1/> of the specified column"
msgstr "получить <placeholder-1/> типа данных указанного столбца"

#: spi.xml:3163(synopsis)
#, no-wrap
msgid "Oid SPI_gettypeid(TupleDesc <placeholder-1/>, int <placeholder-2/>)"
msgstr "Oid SPI_gettypeid(TupleDesc <placeholder-1/>, int <placeholder-2/>)"

#: spi.xml:3171(para)
msgid ""
"<function>SPI_gettypeid</function> returns the <acronym>OID</acronym> of the "
"data type of the specified column."
msgstr ""
"<function>SPI_gettypeid</function> возвращает <acronym>OID</acronym> типа "
"данных указанного столбца."

#: spi.xml:3204(para)
msgid ""
"The <acronym>OID</acronym> of the data type of the specified column or "
"<symbol>InvalidOid</symbol> on error. On error, <varname>SPI_result</"
"varname> is set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol>."
msgstr ""
"<acronym>OID</acronym> типа данных указанного столбца, либо "
"<symbol>InvalidOid</symbol> в случае ошибки. При ошибке в "
"<varname>SPI_result</varname> устанавливается <symbol>SPI_ERROR_NOATTRIBUTE</"
"symbol>."

#: spi.xml:3216(indexterm)
msgid "<primary>SPI_getrelname</primary>"
msgstr "<primary>SPI_getrelname</primary>"

#: spi.xml:3219(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getrelname"
msgstr "SPI_getrelname"

#: spi.xml:3224(refname)
msgctxt "refname"
msgid "SPI_getrelname"
msgstr "SPI_getrelname"

#: spi.xml:3225(refpurpose)
msgid "return the name of the specified relation"
msgstr "возвращает имя указанного отношения"

#: spi.xml:3230(parameter) spi.xml:3249(parameter) spi.xml:3283(parameter)
#: spi.xml:3304(parameter) spi.xml:3727(parameter) spi.xml:3747(parameter)
msgid "rel"
msgstr "rel"

#: spi.xml:3229(synopsis)
#, no-wrap
msgid "char * SPI_getrelname(Relation <placeholder-1/>)"
msgstr "char * SPI_getrelname(Relation <placeholder-1/>)"

#: spi.xml:3237(para)
msgid ""
"<function>SPI_getrelname</function> returns a copy of the name of the "
"specified relation. (You can use <function>pfree</function> to release the "
"copy of the name when you don't need it anymore.)"
msgstr ""
"<function>SPI_getrelname</function> возвращает копию имени указанного "
"отношения. (Когда эта копия имени будет не нужна, её можно освободить с "
"помощью <function>pfree</function>.)"

#: spi.xml:3249(literal) spi.xml:3304(literal) spi.xml:3747(literal)
msgid "Relation <placeholder-1/>"
msgstr "Relation <placeholder-1/>"

#: spi.xml:3251(para) spi.xml:3306(para)
msgid "input relation"
msgstr "целевое отношение"

#: spi.xml:3262(para)
msgid "The name of the specified relation."
msgstr "Имя указанного отношения."

#: spi.xml:3269(indexterm)
msgid "<primary>SPI_getnspname</primary>"
msgstr "<primary>SPI_getnspname</primary>"

#: spi.xml:3272(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_getnspname"
msgstr "SPI_getnspname"

#: spi.xml:3277(refname)
msgctxt "refname"
msgid "SPI_getnspname"
msgstr "SPI_getnspname"

#: spi.xml:3278(refpurpose)
msgid "return the namespace of the specified relation"
msgstr "возвращает пространство имён указанного отношения"

#: spi.xml:3282(synopsis)
#, no-wrap
msgid "char * SPI_getnspname(Relation <placeholder-1/>)"
msgstr "char * SPI_getnspname(Relation <placeholder-1/>)"

#: spi.xml:3290(para)
msgid ""
"<function>SPI_getnspname</function> returns a copy of the name of the "
"namespace that the specified <structname>Relation</structname> belongs to. "
"This is equivalent to the relation's schema. You should <function>pfree</"
"function> the return value of this function when you are finished with it."
msgstr ""
"<function>SPI_getnspname</function> возвращает копию имени пространства "
"имён, к которому принадлежит указанное отношение (<structname>Relation</"
"structname>). Пространство имён по-другому называется схемой отношения. "
"Когда значение, возвращённое этой функцией, будет не нужно, освободите его с "
"помощью <function>pfree</function>."

#: spi.xml:3317(para)
msgid "The name of the specified relation's namespace."
msgstr "Имя пространства имён указанного отношения."

#: spi.xml:3326(title)
msgid "Memory Management"
msgstr "Управление памятью"

#: spi.xml:3329(indexterm)
msgid "<primary>memory context</primary> <secondary>in SPI</secondary>"
msgstr "<primary>контекст памяти</primary> <secondary>в SPI</secondary>"

#: spi.xml:3328(para)
msgid ""
"<placeholder-1/> <productname>PostgreSQL</productname> allocates memory "
"within <firstterm>memory contexts</firstterm>, which provide a convenient "
"method of managing allocations made in many different places that need to "
"live for differing amounts of time. Destroying a context releases all the "
"memory that was allocated in it. Thus, it is not necessary to keep track of "
"individual objects to avoid memory leaks; instead only a relatively small "
"number of contexts have to be managed. <function>palloc</function> and "
"related functions allocate memory from the <quote>current</quote> context."
msgstr ""
"<placeholder-1/> <productname>PostgreSQL</productname> выделяет память в "
"<firstterm>контекстах памяти</firstterm>, и тем самым реализует удобный "
"способ управления выделением памяти в различных местах, с разными сроками "
"жизни выделенной памяти. При уничтожении контекста освобождается вся "
"выделенная в нём память. Таким образом, нет необходимости контролировать "
"каждый отдельный объект во избежание утечек памяти; вместо этого достаточно "
"управлять только небольшим числом контекстов. Функция <function>palloc</"
"function> и родственные ей освобождают память из <quote>текущего</quote> "
"контекста."

#: spi.xml:3344(para)
msgid ""
"<function>SPI_connect</function> creates a new memory context and makes it "
"current. <function>SPI_finish</function> restores the previous current "
"memory context and destroys the context created by <function>SPI_connect</"
"function>. These actions ensure that transient memory allocations made "
"inside your procedure are reclaimed at procedure exit, avoiding memory "
"leakage."
msgstr ""
"<function>SPI_connect</function> создаёт новый контекст памяти и делает его "
"текущим. <function>SPI_finish</function> восстанавливает контекст, который "
"был текущим до этого, и уничтожает контекст, созданный функцией "
"<function>SPI_connect</function>. Эти действия обеспечивают при выходе из "
"вашей процедуры освобождение временной памяти, выделенной внутри процедуры, "
"во избежание утечки памяти."

#: spi.xml:3353(para)
msgid ""
"However, if your procedure needs to return an object in allocated memory "
"(such as a value of a pass-by-reference data type), you cannot allocate that "
"memory using <function>palloc</function>, at least not while you are "
"connected to SPI. If you try, the object will be deallocated by "
"<function>SPI_finish</function>, and your procedure will not work reliably. "
"To solve this problem, use <function>SPI_palloc</function> to allocate "
"memory for your return object. <function>SPI_palloc</function> allocates "
"memory in the <quote>upper executor context</quote>, that is, the memory "
"context that was current when <function>SPI_connect</function> was called, "
"which is precisely the right context for a value returned from your "
"procedure."
msgstr ""
"Однако, если ваша процедура должна вернуть объект в выделенной памяти (как "
"значение типа, передаваемого по ссылке), эту память нельзя выделять через "
"<function>palloc</function>, как минимум пока установлено подключение к SPI. "
"Если вы попытаетесь это сделать, объект будет освобождён при вызове "
"<function>SPI_finish</function> и ваша процедура не будет работать надёжно. "
"Для решения этой проблемы выделяйте память для возвращаемого объекта, "
"используя <function>SPI_palloc</function>. <function>SPI_palloc</function> "
"выделяет память в <quote>верхнем контексте исполнителя</quote>, то есть, в "
"контексте памяти, который был текущим при вызове <function>SPI_connect</"
"function>; именно этот контекст подходит для значения, возвращаемого из "
"процедуры."

#: spi.xml:3368(para)
msgid ""
"If <function>SPI_palloc</function> is called while the procedure is not "
"connected to SPI, then it acts the same as a normal <function>palloc</"
"function>. Before a procedure connects to the SPI manager, the current "
"memory context is the upper executor context, so all allocations made by the "
"procedure via <function>palloc</function> or by SPI utility functions are "
"made in this context."
msgstr ""
"Если <function>SPI_palloc</function> вызывается, когда процедура не "
"подключена к SPI, она действует как обычная функция <function>palloc</"
"function>. До подключения процедуры к менеджеру SPI текущим контекстом "
"является верхний контекст исполнителя, так что все операции выделения "
"памяти, выполняемые процедурой через <function>palloc</function> или "
"служебные функции SPI, производятся в этом контексте."

#: spi.xml:3378(para)
msgid ""
"When <function>SPI_connect</function> is called, the private context of the "
"procedure, which is created by <function>SPI_connect</function>, is made the "
"current context. All allocations made by <function>palloc</function>, "
"<function>repalloc</function>, or SPI utility functions (except for "
"<function>SPI_copytuple</function>, <function>SPI_returntuple</function>, "
"<function>SPI_modifytuple</function>, and <function>SPI_palloc</function>) "
"are made in this context. When a procedure disconnects from the SPI manager "
"(via <function>SPI_finish</function>) the current context is restored to the "
"upper executor context, and all allocations made in the procedure memory "
"context are freed and cannot be used any more."
msgstr ""
"Когда вызывается <function>SPI_connect</function>, текущим контекстом "
"становится частный контекст процедуры, создаваемый в <function>SPI_connect</"
"function>. Все операции выделения памяти, выполняемые функциями "
"<function>palloc</function>, <function>repalloc</function> или служебными "
"функциями SPI (за исключением <function>SPI_copytuple</function>, "
"<function>SPI_returntuple</function>, <function>SPI_modifytuple</function> и "
"<function>SPI_palloc</function>), производятся в этом контексте. Когда "
"процедура отключается от менеджера SPI (выполняя <function>SPI_finish</"
"function>), текущим контекстом снова становится верхний контекст "
"исполнителя, а вся память, выделенная в контексте процедуры, освобождается, "
"так что использовать её дальше нельзя."

#: spi.xml:3394(para)
msgid ""
"All functions described in this section can be used by both connected and "
"unconnected procedures. In an unconnected procedure, they act the same as "
"the underlying ordinary server functions (<function>palloc</function>, etc.)."
msgstr ""
"Все функции, описанные в этом разделе, могут использоваться и в "
"подключённых, и в неподключённых процедурах. В неподключённой процедуре они "
"действуют как обычные низкоуровневые серверные функции (<function>palloc</"
"function> и т. д.)."

#: spi.xml:3404(indexterm)
msgid "<primary>SPI_palloc</primary>"
msgstr "<primary>SPI_palloc</primary>"

#: spi.xml:3407(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_palloc"
msgstr "SPI_palloc"

#: spi.xml:3412(refname)
msgctxt "refname"
msgid "SPI_palloc"
msgstr "SPI_palloc"

#: spi.xml:3413(refpurpose)
msgid "allocate memory in the upper executor context"
msgstr "выделить память в верхнем контексте исполнителя"

#: spi.xml:3418(parameter) spi.xml:3436(parameter) spi.xml:3472(parameter)
#: spi.xml:3505(parameter)
msgid "size"
msgstr "size"

#: spi.xml:3417(synopsis)
#, no-wrap
msgid "void * SPI_palloc(Size <placeholder-1/>)"
msgstr "void * SPI_palloc(Size <placeholder-1/>)"

#: spi.xml:3425(para)
msgid ""
"<function>SPI_palloc</function> allocates memory in the upper executor "
"context."
msgstr ""
"<function>SPI_palloc</function> выделяет память в верхнем контексте "
"исполнителя."

#: spi.xml:3436(literal) spi.xml:3505(literal)
msgid "Size <placeholder-1/>"
msgstr "Size <placeholder-1/>"

#: spi.xml:3438(para) spi.xml:3507(para)
msgid "size in bytes of storage to allocate"
msgstr "размер выделяемой памяти, в байтах"

#: spi.xml:3449(para)
msgid "pointer to new storage space of the specified size"
msgstr "указатель на выделенный блок памяти заданного размера"

#: spi.xml:3458(indexterm)
msgid "<primary>SPI_repalloc</primary>"
msgstr "<primary>SPI_repalloc</primary>"

#: spi.xml:3461(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_repalloc"
msgstr "SPI_repalloc"

#: spi.xml:3466(refname)
msgctxt "refname"
msgid "SPI_repalloc"
msgstr "SPI_repalloc"

#: spi.xml:3467(refpurpose)
msgid "reallocate memory in the upper executor context"
msgstr "поменять блок памяти в верхнем контексте исполнителя"

#: spi.xml:3472(parameter) spi.xml:3496(parameter) spi.xml:3542(parameter)
#: spi.xml:3567(parameter)
msgid "pointer"
msgstr "pointer"

#: spi.xml:3471(synopsis)
#, no-wrap
msgid "void * SPI_repalloc(void * <placeholder-1/>, Size <placeholder-2/>)"
msgstr "void * SPI_repalloc(void * <placeholder-1/>, Size <placeholder-2/>)"

#: spi.xml:3479(para)
msgid ""
"<function>SPI_repalloc</function> changes the size of a memory segment "
"previously allocated using <function>SPI_palloc</function>."
msgstr ""
"<function>SPI_repalloc</function> изменяет размер блока памяти, ранее "
"выделенного функцией <function>SPI_palloc</function>."

#: spi.xml:3484(para)
msgid ""
"This function is no longer different from plain <function>repalloc</"
"function>. It's kept just for backward compatibility of existing code."
msgstr ""
"Эта функция теперь не отличается от простой <function>repalloc</function>. "
"Она сохранена только для обратной совместимости с существующим кодом."

#: spi.xml:3498(para)
msgid "pointer to existing storage to change"
msgstr "указатель на существующий блок памяти, подлежащий изменению"

#: spi.xml:3518(para)
msgid ""
"pointer to new storage space of specified size with the contents copied from "
"the existing area"
msgstr ""
"указатель на новый блок памяти указанного размера, в который скопировано "
"содержимое прежнего блока"

#: spi.xml:3528(indexterm)
msgid "<primary>SPI_pfree</primary>"
msgstr "<primary>SPI_pfree</primary>"

#: spi.xml:3531(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_pfree"
msgstr "SPI_pfree"

#: spi.xml:3536(refname)
msgctxt "refname"
msgid "SPI_pfree"
msgstr "SPI_pfree"

#: spi.xml:3537(refpurpose)
msgid "free memory in the upper executor context"
msgstr "освободить память в верхнем контексте исполнителя"

#: spi.xml:3541(synopsis)
#, no-wrap
msgid "void SPI_pfree(void * <placeholder-1/>)"
msgstr "void SPI_pfree(void * <placeholder-1/>)"

#: spi.xml:3549(para)
msgid ""
"<function>SPI_pfree</function> frees memory previously allocated using "
"<function>SPI_palloc</function> or <function>SPI_repalloc</function>."
msgstr ""
"<function>SPI_pfree</function> освобождает память, ранее выделенную функцией "
"<function>SPI_palloc</function> или <function>SPI_repalloc</function>."

#: spi.xml:3555(para)
msgid ""
"This function is no longer different from plain <function>pfree</function>. "
"It's kept just for backward compatibility of existing code."
msgstr ""
"Эта функция теперь не отличается от простой <function>pfree</function>. Она "
"сохранена только для обратной совместимости с существующим кодом."

#: spi.xml:3569(para)
msgid "pointer to existing storage to free"
msgstr "указатель на существующий блок памяти, подлежащий освобождению"

#: spi.xml:3581(indexterm)
msgid "<primary>SPI_copytuple</primary>"
msgstr "<primary>SPI_copytuple</primary>"

#: spi.xml:3584(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_copytuple"
msgstr "SPI_copytuple"

#: spi.xml:3589(refname)
msgctxt "refname"
msgid "SPI_copytuple"
msgstr "SPI_copytuple"

#: spi.xml:3590(refpurpose)
msgid "make a copy of a row in the upper executor context"
msgstr "скопировать строку в верхнем контексте исполнителя"

#: spi.xml:3594(synopsis)
#, no-wrap
msgid "HeapTuple SPI_copytuple(HeapTuple <placeholder-1/>)"
msgstr "HeapTuple SPI_copytuple(HeapTuple <placeholder-1/>)"

#: spi.xml:3602(para)
msgid ""
"<function>SPI_copytuple</function> makes a copy of a row in the upper "
"executor context. This is normally used to return a modified row from a "
"trigger. In a function declared to return a composite type, use "
"<function>SPI_returntuple</function> instead."
msgstr ""
"<function>SPI_copytuple</function> делает копию строки в верхнем контексте "
"исполнителя. Обычно это применяется, когда нужно вернуть изменённую строку "
"из триггера. В функции, которая должна возвращать составной тип, нужно "
"использовать <function>SPI_returntuple</function>."

#: spi.xml:3617(para) spi.xml:3680(para)
msgid "row to be copied"
msgstr "строка, подлежащая копированию"

#: spi.xml:3628(para)
msgid ""
"the copied row; <symbol>NULL</symbol> only if <parameter>tuple</parameter> "
"is <symbol>NULL</symbol>"
msgstr ""
"скопированная строка; <symbol>NULL</symbol>, только если <parameter>tuple</"
"parameter> — <symbol>NULL</symbol>"

#: spi.xml:3638(indexterm)
msgid "<primary>SPI_returntuple</primary>"
msgstr "<primary>SPI_returntuple</primary>"

#: spi.xml:3641(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_returntuple"
msgstr "SPI_returntuple"

#: spi.xml:3646(refname)
msgctxt "refname"
msgid "SPI_returntuple"
msgstr "SPI_returntuple"

#: spi.xml:3647(refpurpose)
msgid "prepare to return a tuple as a Datum"
msgstr "подготовить строку для возврата в виде Datum"

#: spi.xml:3651(synopsis)
#, no-wrap
msgid "HeapTupleHeader SPI_returntuple(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>)"
msgstr "HeapTupleHeader SPI_returntuple(HeapTuple <placeholder-1/>, TupleDesc <placeholder-2/>)"

#: spi.xml:3659(para)
msgid ""
"<function>SPI_returntuple</function> makes a copy of a row in the upper "
"executor context, returning it in the form of a row type <type>Datum</type>. "
"The returned pointer need only be converted to <type>Datum</type> via "
"<function>PointerGetDatum</function> before returning."
msgstr ""
"<function>SPI_returntuple</function> делает копию строки в верхнем контексте "
"исполнителя и возвращает её в форме типа <type>Datum</type>. Чтобы выдать "
"результат, полученный указатель остаётся только преобразовать в <type>Datum</"
"type> функцией <function>PointerGetDatum</function>."

#: spi.xml:3666(para)
msgid ""
"Note that this should be used for functions that are declared to return "
"composite types. It is not used for triggers; use <function>SPI_copytuple</"
"function> for returning a modified row in a trigger."
msgstr ""
"Заметьте, что эту операцию следует применять в функциях, объявленных как "
"возвращающие составные типы. В триггерах она не применяется; чтобы вернуть "
"изменённую строку из триггера, используйте <function>SPI_copytuple</"
"function>."

#: spi.xml:3689(para)
msgid ""
"descriptor for row (pass the same descriptor each time for most effective "
"caching)"
msgstr ""
"дескриптор строки (передавайте каждый раз один дескриптор для более "
"эффективного кеширования)"

#: spi.xml:3701(para)
msgid ""
"<type>HeapTupleHeader</type> pointing to copied row; <symbol>NULL</symbol> "
"only if <parameter>row</parameter> or <parameter>rowdesc</parameter> is "
"<symbol>NULL</symbol>"
msgstr ""
"<type>HeapTupleHeader</type>, указывающий на скопированную строку; "
"<symbol>NULL</symbol>, только если параметр <parameter>row</parameter> или "
"<parameter>rowdesc</parameter> — <symbol>NULL</symbol>"

#: spi.xml:3713(indexterm)
msgid "<primary>SPI_modifytuple</primary>"
msgstr "<primary>SPI_modifytuple</primary>"

#: spi.xml:3716(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_modifytuple"
msgstr "SPI_modifytuple"

#: spi.xml:3721(refname)
msgctxt "refname"
msgid "SPI_modifytuple"
msgstr "SPI_modifytuple"

#: spi.xml:3722(refpurpose)
msgid "create a row by replacing selected fields of a given row"
msgstr "создать строку, заменяя отдельные поля в данной"

#: spi.xml:3727(parameter) spi.xml:3767(parameter)
msgid "ncols"
msgstr "ncols"

#: spi.xml:3728(parameter) spi.xml:3776(parameter)
msgid "colnum"
msgstr "colnum"

#: spi.xml:3726(synopsis)
#, no-wrap
msgid ""
"HeapTuple SPI_modifytuple(Relation <placeholder-1/>, HeapTuple <placeholder-2/>, int <placeholder-3/>,\n"
"                          int * <placeholder-4/>, Datum * <placeholder-5/>, const char * <placeholder-6/>)"
msgstr ""
"HeapTuple SPI_modifytuple(Relation <placeholder-1/>, HeapTuple <placeholder-2/>, int <placeholder-3/>,\n"
"                          int * <placeholder-4/>, Datum * <placeholder-5/>, const char * <placeholder-6/>)"

#: spi.xml:3735(para)
msgid ""
"<function>SPI_modifytuple</function> creates a new row by substituting new "
"values for selected columns, copying the original row's columns at other "
"positions. The input row is not modified."
msgstr ""
"<function>SPI_modifytuple</function> создаёт новую строку, подставляя новые "
"значения для указанных столбцов и копируя исходное содержимое остальных "
"столбцов. Исходная строка не изменяется."

#: spi.xml:3749(para)
msgid ""
"Used only as the source of the row descriptor for the row. (Passing a "
"relation rather than a row descriptor is a misfeature.)"
msgstr ""
"Используется только в качестве дескриптора строки. (Передача отношения "
"вместо собственно дескриптора строки — нехорошая особенность.)"

#: spi.xml:3760(para)
msgid "row to be modified"
msgstr "строка, подлежащая изменению"

#: spi.xml:3769(para)
msgid "number of columns to be changed"
msgstr "число изменяемых столбцов"

#: spi.xml:3776(literal)
msgid "int * <placeholder-1/>"
msgstr "int * <placeholder-1/>"

#: spi.xml:3778(para)
msgid ""
"an array of length <parameter>ncols</parameter>, containing the numbers of "
"the columns that are to be changed (column numbers start at 1)"
msgstr ""
"массив длины <parameter>ncols</parameter>, содержащий номера изменяемых "
"столбцов (начиная с 1)"

#: spi.xml:3788(para)
msgid ""
"an array of length <parameter>ncols</parameter>, containing the new values "
"for the specified columns"
msgstr ""
"массив длины <parameter>ncols</parameter>, содержащий новые значения "
"указанных столбцов"

#: spi.xml:3798(para)
msgid ""
"an array of length <parameter>ncols</parameter>, describing which new values "
"are null"
msgstr ""
"массив длины <parameter>ncols</parameter>, описывающий, в каких столбцах "
"передаётся NULL"

#: spi.xml:3803(para)
msgid ""
"If <parameter>nulls</parameter> is <symbol>NULL</symbol> then "
"<function>SPI_modifytuple</function> assumes that no new values are null. "
"Otherwise, each entry of the <parameter>nulls</parameter> array should be "
"<literal>'&nbsp;'</literal> if the corresponding new value is non-null, or "
"<literal>'n'</literal> if the corresponding new value is null. (In the "
"latter case, the actual value in the corresponding <parameter>values</"
"parameter> entry doesn't matter.) Note that <parameter>nulls</parameter> is "
"not a text string, just an array: it does not need a <literal>'\\0'</"
"literal> terminator."
msgstr ""
"Если в <parameter>nulls</parameter> передаётся <symbol>NULL</symbol>, "
"<function>SPI_modifytuple</function> считает, что ни один из параметров не "
"равен NULL. В противном случае элемент массива <parameter>nulls</parameter> "
"должен содержать <literal>'&nbsp;'</literal>, если значение соответствующего "
"параметра не NULL, либо <literal>'n'</literal>, если это значение — NULL. (В "
"последнем случае значение, переданное в соответствующем элементе "
"<parameter>values</parameter>, не учитывается.) Заметьте, что "
"<parameter>nulls</parameter> — это не текстовая строка, а просто массив: "
"ноль <literal>'\\0'</literal> в конце не нужен."

#: spi.xml:3822(para)
msgid ""
"new row with modifications, allocated in the upper executor context; "
"<symbol>NULL</symbol> only if <parameter>row</parameter> is <symbol>NULL</"
"symbol>"
msgstr ""
"новая строка с изменениями, размещённая в верхнем контексте исполнителя; "
"<symbol>NULL</symbol>, только если <parameter>row</parameter> — "
"<symbol>NULL</symbol>"

#: spi.xml:3834(para)
msgid ""
"if <parameter>rel</parameter> is <symbol>NULL</symbol>, or if "
"<parameter>row</parameter> is <symbol>NULL</symbol>, or if <parameter>ncols</"
"parameter> is less than or equal to 0, or if <parameter>colnum</parameter> "
"is <symbol>NULL</symbol>, or if <parameter>values</parameter> is "
"<symbol>NULL</symbol>."
msgstr ""
"если <parameter>rel</parameter> — <symbol>NULL</symbol>, либо "
"<parameter>row</parameter> — <symbol>NULL</symbol>, либо <parameter>ncols</"
"parameter> меньше или равно 0, либо <parameter>colnum</parameter> — "
"<symbol>NULL</symbol>, либо <parameter>values</parameter> — <symbol>NULL</"
"symbol>"

#: spi.xml:3844(symbol)
msgid "SPI_ERROR_NOATTRIBUTE"
msgstr "SPI_ERROR_NOATTRIBUTE"

#: spi.xml:3846(para)
msgid ""
"if <parameter>colnum</parameter> contains an invalid column number (less "
"than or equal to 0 or greater than the number of column in <parameter>row</"
"parameter>)"
msgstr ""
"если <parameter>colnum</parameter> содержит недопустимый номер столбца "
"(меньше или равен 0, либо больше числа столбцов в строке <parameter>row</"
"parameter>)"

#: spi.xml:3828(para)
msgid ""
"On error, <varname>SPI_result</varname> is set as follows: <placeholder-1/>"
msgstr ""
"В случае ошибки в <varname>SPI_result</varname> устанавливается: "
"<placeholder-1/>"

#: spi.xml:3861(indexterm)
msgid "<primary>SPI_freetuple</primary>"
msgstr "<primary>SPI_freetuple</primary>"

#: spi.xml:3864(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_freetuple"
msgstr "SPI_freetuple"

#: spi.xml:3869(refname)
msgctxt "refname"
msgid "SPI_freetuple"
msgstr "SPI_freetuple"

#: spi.xml:3870(refpurpose)
msgid "free a row allocated in the upper executor context"
msgstr "освободить строку, размещённую в верхнем контексте исполнителя"

#: spi.xml:3874(synopsis)
#, no-wrap
msgid "void SPI_freetuple(HeapTuple <placeholder-1/>)"
msgstr "void SPI_freetuple(HeapTuple <placeholder-1/>)"

#: spi.xml:3882(para)
msgid ""
"<function>SPI_freetuple</function> frees a row previously allocated in the "
"upper executor context."
msgstr ""
"<function>SPI_freetuple</function> освобождает строку, ранее размещённую в "
"верхнем контексте исполнителя."

#: spi.xml:3887(para)
msgid ""
"This function is no longer different from plain <function>heap_freetuple</"
"function>. It's kept just for backward compatibility of existing code."
msgstr ""
"Эта функция теперь не отличается от простой <function>heap_freetuple</"
"function>. Она сохранена только для обратной совместимости с существующим "
"кодом."

#: spi.xml:3901(para)
msgid "row to free"
msgstr "строка, подлежащая освобождению"

#: spi.xml:3913(indexterm)
msgid "<primary>SPI_freetuptable</primary>"
msgstr "<primary>SPI_freetuptable</primary>"

#: spi.xml:3916(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_freetuptable"
msgstr "SPI_freetuptable"

#: spi.xml:3921(refname)
msgctxt "refname"
msgid "SPI_freetuptable"
msgstr "SPI_freetuptable"

#: spi.xml:3922(function)
msgctxt "function"
msgid "SPI_execute"
msgstr "SPI_execute"

#: spi.xml:3922(refpurpose)
msgid "free a row set created by <placeholder-1/> or a similar function"
msgstr ""
"освободить набор строк, созданный <placeholder-1/> или подобной функцией"

#: spi.xml:3928(parameter) spi.xml:3966(parameter)
msgid "tuptable"
msgstr "tuptable"

#: spi.xml:3927(synopsis)
#, no-wrap
msgid "void SPI_freetuptable(SPITupleTable * <placeholder-1/>)"
msgstr "void SPI_freetuptable(SPITupleTable * <placeholder-1/>)"

#: spi.xml:3935(para)
msgid ""
"<function>SPI_freetuptable</function> frees a row set created by a prior SPI "
"command execution function, such as <function>SPI_execute</function>. "
"Therefore, this function is often called with the global variable "
"<varname>SPI_tuptable</varname> as argument."
msgstr ""
"<function>SPI_freetuptable</function> освобождает набор строк, созданных "
"предыдущей функцией SPI выполнения команд, например <function>SPI_execute</"
"function>. Таким образом, при вызове этой функции в качестве аргумента часто "
"передаётся глобальная переменная <varname>SPI_tuptable</varname>."

#: spi.xml:3943(para)
msgid ""
"This function is useful if a SPI procedure needs to execute multiple "
"commands and does not want to keep the results of earlier commands around "
"until it ends. Note that any unfreed row sets will be freed anyway at "
"<function>SPI_finish</function>. Also, if a subtransaction is started and "
"then aborted within execution of a SPI procedure, SPI automatically frees "
"any row sets created while the subtransaction was running."
msgstr ""
"Эта функция полезна, когда процедура, использующая SPI, должна выполнить "
"несколько команд, но не хочет сохранять результаты предыдущих команд до "
"завершения. Заметьте, что любые не освобождённые таким образом наборы строк "
"будут всё равно освобождены при выполнении <function>SPI_finish</function>. "
"Кроме того, если была запущена подтранзакция, а затем она прервалась в ходе "
"выполнения процедуры SPI, все наборы строк, созданные в рамках "
"подтранзакции, будут автоматически освобождены."

#: spi.xml:3953(para)
msgid ""
"Beginning in <productname>PostgreSQL</productname> 9.3, "
"<function>SPI_freetuptable</function> contains guard logic to protect "
"against duplicate deletion requests for the same row set. In previous "
"releases, duplicate deletions would lead to crashes."
msgstr ""
"Начиная с <productname>PostgreSQL</productname> версии 9.3, "
"<function>SPI_freetuptable</function> содержит защитную логику, "
"отфильтровывающую повторные запросы на удаление одного и того же набора "
"строк. В предыдущих версиях повторное удаление могло приводить к сбоям."

#: spi.xml:3966(literal)
msgid "SPITupleTable * <placeholder-1/>"
msgstr "SPITupleTable * <placeholder-1/>"

#: spi.xml:3968(para)
msgid "pointer to row set to free, or NULL to do nothing"
msgstr ""
"указатель на набор строк, который нужно освободить (если NULL, ничего не "
"происходит)"

#: spi.xml:3980(indexterm)
msgid "<primary>SPI_freeplan</primary>"
msgstr "<primary>SPI_freeplan</primary>"

#: spi.xml:3983(refentrytitle)
msgctxt "refentrytitle"
msgid "SPI_freeplan"
msgstr "SPI_freeplan"

#: spi.xml:3988(refname)
msgctxt "refname"
msgid "SPI_freeplan"
msgstr "SPI_freeplan"

#: spi.xml:3989(refpurpose)
msgid "free a previously saved prepared statement"
msgstr "освободить ранее сохранённый подготовленный оператор"

#: spi.xml:3993(synopsis)
#, no-wrap
msgid "int SPI_freeplan(SPIPlanPtr <placeholder-1/>)"
msgstr "int SPI_freeplan(SPIPlanPtr <placeholder-1/>)"

#: spi.xml:4001(para)
msgid ""
"<function>SPI_freeplan</function> releases a prepared statement previously "
"returned by <function>SPI_prepare</function> or saved by "
"<function>SPI_keepplan</function> or <function>SPI_saveplan</function>."
msgstr ""
"<function>SPI_freeplan</function> освобождает подготовленный оператор, до "
"этого выданный функцией <function>SPI_prepare</function> или сохранённый "
"функциями <function>SPI_keepplan</function> и <function>SPI_saveplan</"
"function>."

#: spi.xml:4015(para)
msgid "pointer to statement to free"
msgstr "указатель на оператор, подлежащий освобождению"

#: spi.xml:4037(title)
msgid "Visibility of Data Changes"
msgstr "Видимость изменений в данных"

#: spi.xml:4049(programlisting)
#, no-wrap
msgid "INSERT INTO a SELECT * FROM a;"
msgstr "INSERT INTO a SELECT * FROM a;"

#: spi.xml:4045(para)
msgid ""
"During the execution of an SQL command, any data changes made by the command "
"are invisible to the command itself. For example, in: <placeholder-1/> the "
"inserted rows are invisible to the <command>SELECT</command> part."
msgstr ""
"В процессе выполнения SQL-команды любые произведённые ей изменения не видны "
"для неё самой. Например, в команде: <placeholder-1/> вставляемые строки не "
"видны в части <command>SELECT</command>."

#: spi.xml:4058(para)
msgid ""
"Changes made by a command C are visible to all commands that are started "
"after C, no matter whether they are started inside C (during the execution "
"of C) or after C is done."
msgstr ""
"Изменения, произведённые командой К, видны во всех командах, запущенных "
"после К, независимо от того, были ли эти команды запущены из К (во время "
"выполнения К) или после завершения К."

#: spi.xml:4066(para)
msgid ""
"Commands executed via SPI inside a function called by an SQL command (either "
"an ordinary function or a trigger) follow one or the other of the above "
"rules depending on the read/write flag passed to SPI. Commands executed in "
"read-only mode follow the first rule: they cannot see changes of the calling "
"command. Commands executed in read-write mode follow the second rule: they "
"can see all changes made so far."
msgstr ""
"Команды, выполняемые через SPI внутри функции, вызванной SQL-командой (будь "
"то обычная функция или триггер), следуют одному или другому из "
"вышеприведённых правил в зависимости флага чтения/записи, переданного SPI. "
"Команды, выполняемые в режиме &laquo;только чтение&raquo;, следует первому "
"правилу: они не видят изменений, произведённых вызывающей командой. Команды, "
"выполняемые в режиме &laquo;чтение-запись&raquo;, следуют второму правилу: "
"они могут видеть все произведённые к этому времени изменения."

#: spi.xml:4078(para)
msgid ""
"All standard procedural languages set the SPI read-write mode depending on "
"the volatility attribute of the function. Commands of <literal>STABLE</"
"literal> and <literal>IMMUTABLE</literal> functions are done in read-only "
"mode, while commands of <literal>VOLATILE</literal> functions are done in "
"read-write mode. While authors of C functions are able to violate this "
"convention, it's unlikely to be a good idea to do so."
msgstr ""
"Все стандартные процедурные языки устанавливают режим чтения-записи в SPI в "
"зависимости от атрибута изменчивости функции. Команды функций "
"<literal>STABLE</literal> и <literal>IMMUTABLE</literal> выполняются в "
"режиме &laquo;только чтение&raquo;, тогда как команды функций "
"<literal>VOLATILE</literal> — в режиме &laquo;чтение-запись&raquo;. Хотя "
"авторы функций на C могут нарушить это соглашение, вряд ли это будет хорошей "
"идеей."

#: spi.xml:4039(para)
msgid ""
"The following rules govern the visibility of data changes in functions that "
"use SPI (or any other C function): <placeholder-1/>"
msgstr ""
"Видимость изменений в данных, которые производятся функциями, использующими "
"SPI, (или любыми другими функциями на C), описывается следующими правилами: "
"<placeholder-1/>"

#: spi.xml:4090(para)
msgid ""
"The next section contains an example that illustrates the application of "
"these rules."
msgstr ""
"В следующем разделе приводится пример, иллюстрирующий применение этих правил."

#: spi.xml:4097(title)
msgid "Examples"
msgstr "Примеры"

#: spi.xml:4099(para)
msgid ""
"This section contains a very simple example of SPI usage. The procedure "
"<function>execq</function> takes an SQL command as its first argument and a "
"row count as its second, executes the command using <function>SPI_exec</"
"function> and returns the number of rows that were processed by the command. "
"You can find more complex examples for SPI in the source tree in "
"<filename>src/test/regress/regress.c</filename> and in the <xref linkend="
"\"contrib-spi\"/> module."
msgstr ""
"Этот раздел содержит очень простой пример использования SPI. Процедура "
"<function>execq</function> принимает в качестве первого аргумента команду "
"SQL, а в качестве второго число строк, выполняет команду, вызывая "
"<function>SPI_exec</function>, и возвращает число строк, обработанных этой "
"командой. Более сложные примеры работы с SPI вы можете найти в <filename>src/"
"test/regress/regress.c</filename> в дереве исходного кода, а также в модуле "
"<xref linkend=\"contrib-spi\"/>."

#: spi.xml:4110(programlisting)
#, no-wrap
msgid ""
"#include \"postgres.h\"\n"
"\n"
"#include \"executor/spi.h\"\n"
"#include \"utils/builtins.h\"\n"
"\n"
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif\n"
"\n"
"int64 execq(text *sql, int cnt);\n"
"\n"
"int64\n"
"execq(text *sql, int cnt)\n"
"{\n"
"    char *command;\n"
"    int ret;\n"
"    uint64 proc;\n"
"\n"
"    /* Convert given text object to a C string */\n"
"    command = text_to_cstring(sql);\n"
"\n"
"    SPI_connect();\n"
"\n"
"    ret = SPI_exec(command, cnt);\n"
"\n"
"    proc = SPI_processed;\n"
"    /*\n"
"     * If some rows were fetched, print them via elog(INFO).\n"
"     */\n"
"    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)\n"
"    {\n"
"        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;\n"
"        SPITupleTable *tuptable = SPI_tuptable;\n"
"        char buf[8192];\n"
"        uint64 j;\n"
"\n"
"        for (j = 0; j &lt; proc; j++)\n"
"        {\n"
"            HeapTuple tuple = tuptable-&gt;vals[j];\n"
"            int i;\n"
"\n"
"            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)\n"
"                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), \" %s%s\",\n"
"                        SPI_getvalue(tuple, tupdesc, i),\n"
"                        (i == tupdesc-&gt;natts) ? \" \" : \" |\");\n"
"            elog(INFO, \"EXECQ: %s\", buf);\n"
"        }\n"
"    }\n"
"\n"
"    SPI_finish();\n"
"    pfree(command);\n"
"\n"
"    return (proc);\n"
"}"
msgstr ""
"#include \"postgres.h\"\n"
"\n"
"#include \"executor/spi.h\"\n"
"#include \"utils/builtins.h\"\n"
"\n"
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif\n"
"\n"
"int64 execq(text *sql, int cnt);\n"
"\n"
"int64\n"
"execq(text *sql, int cnt)\n"
"{\n"
"    char *command;\n"
"    int ret;\n"
"    uint64 proc;\n"
"\n"
"    /* Преобразовать данный текстовый объект в строку C */\n"
"    command = text_to_cstring(sql);\n"
"\n"
"    SPI_connect();\n"
"\n"
"    ret = SPI_exec(command, cnt);\n"
"\n"
"    proc = SPI_processed;\n"
"    /*\n"
"     * Если были выбраны какие-то строки, вывести их через elog(INFO).\n"
"     */\n"
"    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)\n"
"    {\n"
"        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;\n"
"        SPITupleTable *tuptable = SPI_tuptable;\n"
"        char buf[8192];\n"
"        uint64 j;\n"
"\n"
"        for (j = 0; j &lt; proc; j++)\n"
"        {\n"
"            HeapTuple tuple = tuptable-&gt;vals[j];\n"
"            int i;\n"
"\n"
"            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)\n"
"                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), \" %s%s\",\n"
"                        SPI_getvalue(tuple, tupdesc, i),\n"
"                        (i == tupdesc-&gt;natts) ? \" \" : \" |\");\n"
"            elog(INFO, \"EXECQ: %s\", buf);\n"
"        }\n"
"    }\n"
"\n"
"    SPI_finish();\n"
"    pfree(command);\n"
"\n"
"    return (proc);\n"
"}"

#: spi.xml:4167(para)
msgid ""
"(This function uses call convention version 0, to make the example easier to "
"understand. In real applications you should use the new version 1 interface.)"
msgstr ""
"(В этой функции используется соглашение о вызовах версии 0, чтобы этот "
"пример было легче понять. В реальных приложениях вы должны использовать "
"новый интерфейс версии 1.)"

#: spi.xml:4177(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION execq(text, integer) RETURNS int8\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C STRICT;"
msgstr ""
"CREATE FUNCTION execq(text, integer) RETURNS int8\n"
"    AS '<replaceable>имя_файла</replaceable>'\n"
"    LANGUAGE C STRICT;"

#: spi.xml:4173(para)
msgid ""
"This is how you declare the function after having compiled it into a shared "
"library (details are in <xref linkend=\"dfunc\"/>.): <placeholder-1/>"
msgstr ""
"Так эта функция будет объявляться после того, как она будет скомпилирована в "
"разделяемую библиотеку (подробности в <xref remap=\"6\" linkend=\"dfunc\"/"
">): <placeholder-1/>"

#: spi.xml:4187(programlisting)
#, no-wrap
msgid ""
"=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);\n"
" execq\n"
"-------\n"
"     0\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));\n"
"INSERT 0 1\n"
"=&gt; SELECT execq('SELECT * FROM a', 0);\n"
"INFO:  EXECQ:  0    -- inserted by execq\n"
"INFO:  EXECQ:  1    -- returned by execq and inserted by upper INSERT\n"
"\n"
" execq\n"
"-------\n"
"     2\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);\n"
" execq\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('SELECT * FROM a', 10);\n"
"INFO:  EXECQ:  0\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2    -- 0 + 2, only one row inserted - as specified\n"
"\n"
" execq\n"
"-------\n"
"     3              -- 10 is the max value only, 3 is the real number of rows\n"
"(1 row)\n"
"\n"
"=&gt; DELETE FROM a;\n"
"DELETE 3\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1                  -- no rows in a (0) + 1\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INFO:  EXECQ:  1\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2                  -- there was one row in a + 1\n"
"(2 rows)\n"
"\n"
"-- This demonstrates the data changes visibility rule:\n"
"\n"
"=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  2\n"
"INSERT 0 2\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2\n"
" 2                  -- 2 rows * 1 (x in first row)\n"
" 6                  -- 3 rows (2 + 1 just inserted) * 2 (x in second row)\n"
"(4 rows)               ^^^^^^\n"
"                       rows visible to execq() in different invocations"
msgstr ""
"=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);\n"
" execq\n"
"-------\n"
"     0\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));\n"
"INSERT 0 1\n"
"=&gt; SELECT execq('SELECT * FROM a', 0);\n"
"INFO:  EXECQ:  0    -- вставлено функцией execq\n"
"INFO:  EXECQ:  1    -- возвращено функцией execq и вставлено командой INSERT\n"
"\n"
" execq\n"
"-------\n"
"     2\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);\n"
" execq\n"
"-------\n"
"     1\n"
"(1 row)\n"
"\n"
"=&gt; SELECT execq('SELECT * FROM a', 10);\n"
"INFO:  EXECQ:  0\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2    -- 0 + 2, вставлена только одна строка - как указано\n"
"\n"
" execq\n"
"-------\n"
"     3              -- 10 — только максимальное значение, 3 — реальное число строк\n"
"(1 row)\n"
"\n"
"=&gt; DELETE FROM a;\n"
"DELETE 3\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1                  -- нет строк в a (0) + 1\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);\n"
"INFO:  EXECQ:  1\n"
"INSERT 0 1\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2                  -- была одна строка в a + 1\n"
"(2 rows)\n"
"\n"
"-- Этот пример демонстрирует правило видимости изменений в данных:\n"
"\n"
"=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  1\n"
"INFO:  EXECQ:  2\n"
"INFO:  EXECQ:  2\n"
"INSERT 0 2\n"
"=&gt; SELECT * FROM a;\n"
" x\n"
"---\n"
" 1\n"
" 2\n"
" 2                  -- 2 строки * 1 (x в первой в строке)\n"
" 6                  -- 3 строки (2 + 1 только вставленная) * 2 (x во второй строке)\n"
"(4 rows)               ^^^^^^\n"
"                       строки, видимые в execq() при разных вызовах"

#: spi.xml:4184(para)
msgid "Here is a sample session: <placeholder-1/>"
msgstr "Демонстрация использования: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: spi.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
