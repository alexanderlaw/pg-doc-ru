# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-08-09 15:59+0300\n"
"PO-Revision-Date: 2017-08-09 16:36+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ecpg.xml:5(title)
msgid "<application>ECPG</application> - Embedded <acronym>SQL</acronym> in C"
msgstr ""
"<application>ECPG</application> — встраиваемый <acronym>SQL</acronym> в C"

#: ecpg.xml:7(indexterm)
msgid "<primary>embedded SQL</primary><secondary>in C</secondary>"
msgstr "<primary>встраиваемый SQL</primary> <secondary>в C</secondary>"

#: ecpg.xml:8(indexterm)
msgid "<primary>C</primary>"
msgstr "<primary>C</primary>"

#: ecpg.xml:9(indexterm)
msgid "<primary>ECPG</primary>"
msgstr "<primary>ECPG</primary>"

#: ecpg.xml:11(para)
msgid ""
"This chapter describes the embedded <acronym>SQL</acronym> package for "
"<productname>PostgreSQL</productname>. It was written by Linus Tolke "
"(<email>linus@epact.se</email>) and Michael Meskes (<email>meskes@postgresql."
"org</email>). Originally it was written to work with <acronym>C</acronym>. "
"It also works with <acronym>C++</acronym>, but it does not recognize all "
"<acronym>C++</acronym> constructs yet."
msgstr ""
"В этой главе описывается встраиваемый <acronym>SQL</acronym> для "
"<productname>PostgreSQL</productname>. Авторы этой разработки: Линус Толке "
"(<email>linus@epact.se</email>) и Михаэль Мескес (<email>meskes@postgresql."
"org</email>). Изначально этот проект предназначался для <acronym>C</"
"acronym>. Сейчас он также работает с <acronym>C++</acronym>, но пока не "
"распознаёт все конструкции <acronym>C++</acronym>."

#: ecpg.xml:20(para)
msgid ""
"This documentation is quite incomplete. But since this interface is "
"standardized, additional information can be found in many resources about "
"SQL."
msgstr ""
"Эта документация не абсолютно полная, но так как этот интерфейс "
"стандартизирован, дополнительные сведения можно почерпнуть во многих "
"ресурсах, посвящённых SQL."

#: ecpg.xml:27(title)
msgid "The Concept"
msgstr "Концепция"

#: ecpg.xml:29(para)
msgid ""
"An embedded SQL program consists of code written in an ordinary programming "
"language, in this case C, mixed with SQL commands in specially marked "
"sections. To build the program, the source code (<filename>*.pgc</filename>) "
"is first passed through the embedded SQL preprocessor, which converts it to "
"an ordinary C program (<filename>*.c</filename>), and afterwards it can be "
"processed by a C compiler. (For details about the compiling and linking see "
"<xref linkend=\"ecpg-process\"/>). Converted ECPG applications call "
"functions in the libpq library through the embedded SQL library (ecpglib), "
"and communicate with the PostgreSQL server using the normal frontend-backend "
"protocol."
msgstr ""
"Программа со встраиваемым SQL состоит из кода, написанного на обычном языке "
"программирования, в данном случае, С, дополненного командами SQL в "
"специально обозначенных секциях. Чтобы собрать программу, её исходный код "
"(<filename>*.pgc</filename>) сначала нужно пропустить через препроцессор "
"встраиваемого SQL, который превратит её в обычную программу на C "
"(<filename>*.c</filename>), которую затем сможет обработать компилятор C. "
"(Подробнее компиляция и компоновка описывается в <xref remap=\"6\" linkend="
"\"ecpg-process\"/>). Преобразованные приложения ECPG вызывают функции в "
"библиотеке libpq через библиотеку встраиваемого SQL (ecpglib) и "
"взаимодействуют с сервером PostgreSQL по обычному клиент-серверному "
"протоколу."

#: ecpg.xml:41(para)
msgid ""
"Embedded <acronym>SQL</acronym> has advantages over other methods for "
"handling <acronym>SQL</acronym> commands from C code. First, it takes care "
"of the tedious passing of information to and from variables in your "
"<acronym>C</acronym> program. Second, the SQL code in the program is checked "
"at build time for syntactical correctness. Third, embedded <acronym>SQL</"
"acronym> in C is specified in the <acronym>SQL</acronym> standard and "
"supported by many other <acronym>SQL</acronym> database systems. The "
"<productname>PostgreSQL</productname> implementation is designed to match "
"this standard as much as possible, and it is usually possible to port "
"embedded <acronym>SQL</acronym> programs written for other SQL databases to "
"<productname>PostgreSQL</productname> with relative ease."
msgstr ""
"Встраиваемый <acronym>SQL</acronym> имеет ряд преимуществ по сравнению с "
"другими методами вызова команд <acronym>SQL</acronym> из кода C. Во-первых, "
"этот механизм берёт на себя заботу о передаче информации через переменные в "
"программе на <acronym>C</acronym>. Во-вторых, код SQL в программе "
"проверяется на синтаксическую правильность во время сборки. В-третьих, "
"встраиваемый <acronym>SQL</acronym> в C описан стандартом <acronym>SQL</"
"acronym> и поддерживается многими другими СУБД <acronym>SQL</acronym>. "
"Реализация в <productname>PostgreSQL</productname> разработана так, чтобы "
"максимально соответствовать этому стандарту, поэтому обычно достаточно легко "
"портировать в <productname>PostgreSQL</productname> программы с встраиваемым "
"<acronym>SQL</acronym>, написанные для других СУБД."

#: ecpg.xml:62(programlisting)
#, no-wrap
msgid "EXEC SQL ...;"
msgstr "EXEC SQL ...;"

#: ecpg.xml:57(para)
msgid ""
"As already stated, programs written for the embedded <acronym>SQL</acronym> "
"interface are normal C programs with special code inserted to perform "
"database-related actions. This special code always has the form: "
"<placeholder-1/> These statements syntactically take the place of a C "
"statement. Depending on the particular statement, they can appear at the "
"global level or within a function. Embedded <acronym>SQL</acronym> "
"statements follow the case-sensitivity rules of normal <acronym>SQL</"
"acronym> code, and not those of C. Also they allow nested C-style comments "
"that are part of the SQL standard. The C part of the program, however, "
"follows the C standard of not accepting nested comments."
msgstr ""
"Как уже сказано, программы, написанные для интерфейса встраиваемого "
"<acronym>SQL</acronym>, представляют собой обычные программы на C с "
"добавленным специальным кодом, который выполняет действия, связанные с базой "
"данных. Этот специальный код всегда имеет следующую форму: <placeholder-1/> "
"Такие операторы синтаксически занимают место операторов C. В зависимости от "
"конкретного оператора, они могут размещаться на глобальном уровне или внутри "
"функции. Встраиваемые операторы <acronym>SQL</acronym> следуют правилам "
"учёта регистра, принятым в обычном коде <acronym>SQL</acronym>, а не в C. "
"Они также допускают вложенные комментарии в стиле C, разрешённые стандартом "
"SQL. Однако остальная часть программы, написанная на C, в соответствии со "
"стандартом C содержать вложенные комментарии не может."

#: ecpg.xml:74(para)
msgid "The following sections explain all the embedded SQL statements."
msgstr "Все встраиваемые операторы SQL рассматриваются в следующих разделах."

#: ecpg.xml:80(title)
msgid "Managing Database Connections"
msgstr "Управление подключениями к базе данных"

#: ecpg.xml:82(para)
msgid ""
"This section describes how to open, close, and switch database connections."
msgstr ""
"В этом разделе описывается, как открывать, закрывать и переключать "
"подключения к базам данных."

#: ecpg.xml:88(title)
msgid "Connecting to the Database Server"
msgstr "Подключение к серверу баз данных"

#: ecpg.xml:92(programlisting)
#, no-wrap
msgid "EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;"
msgstr "EXEC SQL CONNECT TO <replaceable>цель-подключения</replaceable> <optional>AS <replaceable>имя-подключения</replaceable></optional> <optional>USER <replaceable>имя-пользователя</replaceable></optional>;"

#: ecpg.xml:101(replaceable) ecpg.xml:107(replaceable)
#: ecpg.xml:113(replaceable)
msgid "dbname"
msgstr "имя_бд"

#: ecpg.xml:101(replaceable) ecpg.xml:107(replaceable)
#: ecpg.xml:113(replaceable)
msgid "hostname"
msgstr "имя_сервера"

#: ecpg.xml:101(optional)
msgid "@<placeholder-1/>"
msgstr "@<placeholder-1/>"

#: ecpg.xml:101(replaceable) ecpg.xml:107(replaceable)
#: ecpg.xml:113(replaceable)
msgid "port"
msgstr "порт"

#: ecpg.xml:101(optional) ecpg.xml:107(optional) ecpg.xml:113(optional)
msgid ":<placeholder-1/>"
msgstr ":<placeholder-1/>"

#: ecpg.xml:107(optional) ecpg.xml:113(optional)
msgid "/<placeholder-1/>"
msgstr "/<placeholder-1/>"

#: ecpg.xml:107(replaceable) ecpg.xml:113(replaceable)
msgid "options"
msgstr "параметры"

#: ecpg.xml:107(optional) ecpg.xml:113(optional)
msgid "?<placeholder-1/>"
msgstr "?<placeholder-1/>"

#: ecpg.xml:107(literal)
msgid ""
"tcp:postgresql://<placeholder-1/><placeholder-2/><placeholder-3/"
"><placeholder-4/>"
msgstr ""
"tcp:postgresql://<placeholder-1/><placeholder-2/><placeholder-3/"
"><placeholder-4/>"

#: ecpg.xml:113(literal)
msgid ""
"unix:postgresql://<placeholder-1/><placeholder-2/><placeholder-3/"
"><placeholder-4/>"
msgstr ""
"unix:postgresql://<placeholder-1/><placeholder-2/><placeholder-3/"
"><placeholder-4/>"

#: ecpg.xml:118(simpara)
msgid "an SQL string literal containing one of the above forms"
msgstr "строковая константа SQL, содержащая одну из вышеприведённых записей"

#: ecpg.xml:124(simpara)
msgid ""
"a reference to a character variable containing one of the above forms (see "
"examples)"
msgstr ""
"ссылка на символьную переменную, содержащую одну из вышеприведённых записей "
"(см. примеры)"

#: ecpg.xml:131(literal) ecpg.xml:321(literal) ecpg.xml:6409(literal)
#: ecpg.xml:6824(literal) ecpg.xml:7375(literal)
msgid "DEFAULT"
msgstr "DEFAULT"

#: ecpg.xml:90(para)
msgid ""
"One connects to a database using the following statement: <placeholder-1/> "
"The <replaceable>target</replaceable> can be specified in the following "
"ways: <placeholder-2/> If you specify the connection target literally (that "
"is, not through a variable reference) and you don't quote the value, then "
"the case-insensitivity rules of normal SQL are applied. In that case you can "
"also double-quote the individual parameters separately as needed. In "
"practice, it is probably less error-prone to use a (single-quoted) string "
"literal or a variable reference. The connection target <literal>DEFAULT</"
"literal> initiates a connection to the default database under the default "
"user name. No separate user name or connection name can be specified in that "
"case."
msgstr ""
"Подключение к базе данных выполняется следующим оператором: <placeholder-1/> "
"<replaceable>Цель</replaceable> может задаваться следующими способами: "
"<placeholder-2/> Если цель подключения задаётся буквально (то есть не через "
"переменную) и значение не заключается в кавычки, регистр в этой строке не "
"учитывается, как в обычном SQL. В этом случае при необходимости также можно "
"заключить в двойные кавычки отдельные параметры. На практике, чтобы не "
"провоцировать ошибки, лучше заключать строку в апострофы, либо передавать её "
"в переменной. С целью подключения <literal>DEFAULT</literal> устанавливается "
"подключение к базе данных по умолчанию с именем пользователя по умолчанию. "
"Другое имя пользователя или имя подключения в этом случае указать нельзя."

#: ecpg.xml:153(replaceable) ecpg.xml:159(replaceable)
#: ecpg.xml:165(replaceable) ecpg.xml:171(replaceable)
msgid "username"
msgstr "имя_пользователя"

#: ecpg.xml:159(replaceable) ecpg.xml:165(replaceable)
#: ecpg.xml:171(replaceable)
msgid "password"
msgstr "пароль"

#: ecpg.xml:159(literal)
msgid "<placeholder-1/>/<placeholder-2/>"
msgstr "<placeholder-1/>/<placeholder-2/>"

#: ecpg.xml:165(literal)
msgid "<placeholder-1/> IDENTIFIED BY <placeholder-2/>"
msgstr "<placeholder-1/> IDENTIFIED BY <placeholder-2/>"

#: ecpg.xml:171(literal)
msgid "<placeholder-1/> USING <placeholder-2/>"
msgstr "<placeholder-1/> USING <placeholder-2/>"

#: ecpg.xml:147(para)
msgid ""
"There are also different ways to specify the user name: <placeholder-1/> As "
"above, the parameters <replaceable>username</replaceable> and "
"<replaceable>password</replaceable> can be an SQL identifier, an SQL string "
"literal, or a reference to a character variable."
msgstr ""
"Также разными способами можно указать имя пользователя: <placeholder-1/> В "
"показанных выше строках <replaceable>имя_пользователя</replaceable> и "
"<replaceable>пароль</replaceable> могут задаваться идентификатором или "
"строковой константой SQL, либо ссылкой на символьную переменную."

#: ecpg.xml:181(para)
msgid ""
"The <replaceable>connection-name</replaceable> is used to handle multiple "
"connections in one program. It can be omitted if a program uses only one "
"connection. The most recently opened connection becomes the current "
"connection, which is used by default when an SQL statement is to be executed "
"(see later in this chapter)."
msgstr ""
"Указание <replaceable>имя-подключения</replaceable> применяется, когда в "
"одной программе нужно использовать несколько подключений. Его можно "
"опустить, если программа работает только с одним подключением. Соединение, "
"открытое последним, становится текущим и будет использоваться по умолчанию "
"при выполнении операторов SQL (это описывается далее в этой главе)."

#: ecpg.xml:192(programlisting)
#, no-wrap
msgid ""
"EXEC SQL CONNECT TO mydb@sql.mydomain.com;\n"
"\n"
"EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;\n"
"\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"const char *target = \"mydb@sql.mydomain.com\";\n"
"const char *user = \"john\";\n"
"const char *passwd = \"secret\";\n"
"EXEC SQL END DECLARE SECTION;\n"
" ...\n"
"EXEC SQL CONNECT TO :target USER :user USING :passwd;\n"
"/* or EXEC SQL CONNECT TO :target USER :user/:passwd; */"
msgstr ""
"EXEC SQL CONNECT TO mydb@sql.mydomain.com;\n"
"\n"
"EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;\n"
"\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"const char *target = \"mydb@sql.mydomain.com\";\n"
"const char *user = \"john\";\n"
"const char *passwd = \"secret\";\n"
"EXEC SQL END DECLARE SECTION;\n"
" ...\n"
"EXEC SQL CONNECT TO :target USER :user USING :passwd;\n"
"/* или EXEC SQL CONNECT TO :target USER :user/:passwd; */"

#: ecpg.xml:190(para)
msgid ""
"Here are some examples of <command>CONNECT</command> statements: "
"<placeholder-1/> The last form makes use of the variant referred to above as "
"character variable reference. You will see in later sections how C variables "
"can be used in SQL statements when you prefix them with a colon."
msgstr ""
"Вот некоторые примеры оператора <command>CONNECT</command>: <placeholder-1/> "
"В последней форме используется вариант, названный выше ссылкой на символьную "
"переменную. В последующих разделах вы узнаете, как в SQL-операторах можно "
"использовать переменные C, приставляя перед именем двоеточие."

#: ecpg.xml:212(para)
msgid ""
"Be advised that the format of the connection target is not specified in the "
"SQL standard. So if you want to develop portable applications, you might "
"want to use something based on the last example above to encapsulate the "
"connection target string somewhere."
msgstr ""
"Учтите, что формат цели подключения не описывается в стандарте SQL. Поэтому, "
"если вы хотите разрабатывать переносимые приложения, имеет смысл применить "
"подход, показанный в последнем примере, и сформировать строку подключения "
"отдельно."

#: ecpg.xml:222(title)
msgid "Choosing a Connection"
msgstr "Выбор подключения"

#: ecpg.xml:224(para)
msgid ""
"SQL statements in embedded SQL programs are by default executed on the "
"current connection, that is, the most recently opened one. If an application "
"needs to manage multiple connections, then there are two ways to handle this."
msgstr ""
"SQL-операторы в программах со встраиваемым SQL по умолчанию выполняются с "
"текущим подключением, то есть с подключением, которое было открыто "
"последним. Если приложению нужно управлять несколькими подключениями, это "
"можно сделать двумя способами."

#: ecpg.xml:234(programlisting)
#, no-wrap
msgid "EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;"
msgstr "EXEC SQL AT <replaceable>имя-подключения</replaceable> SELECT ...;"

#: ecpg.xml:231(para)
msgid ""
"The first option is to explicitly choose a connection for each SQL "
"statement, for example: <placeholder-1/> This option is particularly "
"suitable if the application needs to use several connections in mixed order."
msgstr ""
"Первый вариант — явно выбирать подключение для каждого SQL-оператора, "
"например, так: <placeholder-1/> Этот вариант хорошо подходит для случаев, "
"когда приложению нужно использовать несколько подключений в смешанном "
"порядке."

#: ecpg.xml:241(para)
msgid ""
"If your application uses multiple threads of execution, they cannot share a "
"connection concurrently. You must either explicitly control access to the "
"connection (using mutexes) or use a connection for each thread."
msgstr ""
"Если ваше приложение выполняется в нескольких потоках, они не могут "
"использовать подключение одновременно. Поэтому вы должны либо явно управлять "
"доступом (используя мьютексы), либо использовать отдельные подключения для "
"каждого потока."

#: ecpg.xml:250(programlisting)
#, no-wrap
msgid "EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;"
msgstr "EXEC SQL SET CONNECTION <replaceable>имя-подключения</replaceable>;"

#: ecpg.xml:247(para)
msgid ""
"The second option is to execute a statement to switch the current "
"connection. That statement is: <placeholder-1/> This option is particularly "
"convenient if many statements are to be executed on the same connection."
msgstr ""
"Второй вариант — выполнять оператор, переключающий текущее подключение. Этот "
"оператор записывается так: <placeholder-1/> Этот вариант особенно удобен, "
"когда с одним подключением нужно выполнить несколько операторов."

#: ecpg.xml:257(para)
msgid ""
"Here is an example program managing multiple database connections: "
"<placeholder-1/> This example would produce this output: <screen>\n"
"current=testdb3 (should be testdb3)\n"
"current=testdb2 (should be testdb2)\n"
"current=testdb1 (should be testdb1)\n"
"</screen>"
msgstr ""
"Следующий пример программы демонстрирует управление несколькими "
"подключениями к базам данных: <placeholder-1/> Этот пример должен вывести "
"следующее: <screen>\n"
"current=testdb3 (should be testdb3)\n"
"current=testdb2 (should be testdb2)\n"
"current=testdb1 (should be testdb1)\n"
"</screen>"

#: ecpg.xml:302(title)
msgid "Closing a Connection"
msgstr "Закрытие подключения"

#: ecpg.xml:306(programlisting)
#, no-wrap
msgid "EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;"
msgstr "EXEC SQL DISCONNECT <optional><replaceable>подключение</replaceable></optional>;"

#: ecpg.xml:315(replaceable)
msgid "connection-name"
msgstr "имя-подключения"

#: ecpg.xml:327(literal) ecpg.xml:6811(literal)
msgid "CURRENT"
msgstr "CURRENT"

#: ecpg.xml:333(literal) ecpg.xml:6833(literal)
msgid "ALL"
msgstr "ALL"

#: ecpg.xml:304(para)
msgid ""
"To close a connection, use the following statement: <placeholder-1/> The "
"<replaceable>connection</replaceable> can be specified in the following "
"ways: <placeholder-2/> If no connection name is specified, the current "
"connection is closed."
msgstr ""
"Чтобы закрыть подключение, примените следующий оператор: <placeholder-1/> "
"<replaceable>Подключение</replaceable> можно задать следующими способами: "
"<placeholder-2/> Если имя подключения не задано, закрывается текущее "
"подключение."

#: ecpg.xml:342(para)
msgid ""
"It is good style that an application always explicitly disconnect from every "
"connection it opened."
msgstr ""
"Хорошим стилем считается, когда приложение явно закрывает каждое "
"подключение, которое оно открыло."

#: ecpg.xml:351(title)
msgid "Running SQL Commands"
msgstr "Запуск команд SQL"

#: ecpg.xml:353(para)
msgid ""
"Any SQL command can be run from within an embedded SQL application. Below "
"are some examples of how to do that."
msgstr ""
"В приложении со встраиваемым SQL можно запустить любую команду SQL. Ниже "
"приведены несколько примеров, показывающих как это делать."

#: ecpg.xml:359(title)
msgid "Executing SQL Statements"
msgstr "Выполнение операторов SQL"

#: ecpg.xml:363(programlisting)
#, no-wrap
msgid ""
"EXEC SQL CREATE TABLE foo (number integer, ascii char(16));\n"
"EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);\n"
"EXEC SQL COMMIT;"
msgstr ""
"EXEC SQL CREATE TABLE foo (number integer, ascii char(16));\n"
"EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);\n"
"EXEC SQL COMMIT;"

#: ecpg.xml:361(para)
msgid "Creating a table: <placeholder-1/>"
msgstr "Создание таблицы: <placeholder-1/>"

#: ecpg.xml:372(programlisting)
#, no-wrap
msgid ""
"EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');\n"
"EXEC SQL COMMIT;"
msgstr ""
"EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');\n"
"EXEC SQL COMMIT;"

#: ecpg.xml:370(para)
msgid "Inserting rows: <placeholder-1/>"
msgstr "Добавление строк: <placeholder-1/>"

#: ecpg.xml:380(programlisting)
#, no-wrap
msgid ""
"EXEC SQL DELETE FROM foo WHERE number = 9999;\n"
"EXEC SQL COMMIT;"
msgstr ""
"EXEC SQL DELETE FROM foo WHERE number = 9999;\n"
"EXEC SQL COMMIT;"

#: ecpg.xml:378(para)
msgid "Deleting rows: <placeholder-1/>"
msgstr "Удаление строк: <placeholder-1/>"

#: ecpg.xml:388(programlisting)
#, no-wrap
msgid ""
"EXEC SQL UPDATE foo\n"
"    SET ascii = 'foobar'\n"
"    WHERE number = 9999;\n"
"EXEC SQL COMMIT;"
msgstr ""
"EXEC SQL UPDATE foo\n"
"    SET ascii = 'foobar'\n"
"    WHERE number = 9999;\n"
"EXEC SQL COMMIT;"

#: ecpg.xml:386(para)
msgid "Updates: <placeholder-1/>"
msgstr "Изменение: <placeholder-1/>"

#: ecpg.xml:396(para)
msgid ""
"<literal>SELECT</literal> statements that return a single result row can "
"also be executed using <literal>EXEC SQL</literal> directly. To handle "
"result sets with multiple rows, an application has to use a cursor; see "
"<xref linkend=\"ecpg-cursors\"/> below. (As a special case, an application "
"can fetch multiple rows at once into an array host variable; see <xref "
"linkend=\"ecpg-variables-arrays\"/>.)"
msgstr ""
"Операторы <literal>SELECT</literal>, возвращающие одну строку результата, "
"также могут выполняться непосредственно командой <literal>EXEC SQL</"
"literal>. Чтобы обработать наборы результатов с несколькими строками, "
"приложение должно использовать курсоры; см. <xref remap=\"4\" linkend=\"ecpg-"
"cursors\"/> ниже. (В отдельных случаях приложение может выбрать сразу "
"несколько строк в переменную массива; см. <xref remap=\"4\" linkend=\"ecpg-"
"variables-arrays\"/>.)"

#: ecpg.xml:408(programlisting)
#, no-wrap
msgid "EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';"
msgstr "EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';"

#: ecpg.xml:406(para)
msgid "Single-row select: <placeholder-1/>"
msgstr "Выборка одной строки: <placeholder-1/>"

#: ecpg.xml:416(programlisting)
#, no-wrap
msgid "EXEC SQL SHOW search_path INTO :var;"
msgstr "EXEC SQL SHOW search_path INTO :var;"

#: ecpg.xml:413(para)
msgid ""
"Also, a configuration parameter can be retrieved with the <literal>SHOW</"
"literal> command: <placeholder-1/>"
msgstr ""
"Так же можно получить параметр конфигурации командой <literal>SHOW</"
"literal>: <placeholder-1/>"

#: ecpg.xml:421(para)
msgid ""
"The tokens of the form <literal>:<replaceable>something</replaceable></"
"literal> are <firstterm>host variables</firstterm>, that is, they refer to "
"variables in the C program. They are explained in <xref linkend=\"ecpg-"
"variables\"/>."
msgstr ""
"Идентификаторы вида <literal>:<replaceable>имя</replaceable></literal> "
"воспринимаются как <firstterm>переменные среды</firstterm>, то есть они "
"ссылаются на переменные программы C. Они рассматриваются в <xref remap=\"6\" "
"linkend=\"ecpg-variables\"/>."

#: ecpg.xml:431(title)
msgid "Using Cursors"
msgstr "Использование курсоров"

#: ecpg.xml:433(para)
msgid ""
"To retrieve a result set holding multiple rows, an application has to "
"declare a cursor and fetch each row from the cursor. The steps to use a "
"cursor are the following: declare a cursor, open it, fetch a row from the "
"cursor, repeat, and finally close it."
msgstr ""
"Чтобы получить набор результатов, содержащий несколько строк, приложение "
"должно объявить курсор и выбирать каждую строку через него. Использование "
"курсора подразумевает следующие шаги: объявление курсора, открытие его, "
"выборку строки через курсор, повторение предыдущего шага, и наконец, "
"закрытие курсора."

#: ecpg.xml:442(programlisting)
#, no-wrap
msgid ""
"EXEC SQL DECLARE foo_bar CURSOR FOR\n"
"    SELECT number, ascii FROM foo\n"
"    ORDER BY ascii;\n"
"EXEC SQL OPEN foo_bar;\n"
"EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;\n"
"...\n"
"EXEC SQL CLOSE foo_bar;\n"
"EXEC SQL COMMIT;"
msgstr ""
"EXEC SQL DECLARE foo_bar CURSOR FOR\n"
"    SELECT number, ascii FROM foo\n"
"    ORDER BY ascii;\n"
"EXEC SQL OPEN foo_bar;\n"
"EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;\n"
"...\n"
"EXEC SQL CLOSE foo_bar;\n"
"EXEC SQL COMMIT;"

#: ecpg.xml:440(para)
msgid "Select using cursors: <placeholder-1/>"
msgstr "Выборка с использованием курсоров: <placeholder-1/>"

#: ecpg.xml:454(para)
msgid ""
"For more details about declaration of the cursor, see <xref linkend=\"ecpg-"
"sql-declare\"/>, and see <xref linkend=\"sql-fetch\"/> for <literal>FETCH</"
"literal> command details."
msgstr ""
"Более подробно объявление курсора описывается в <xref remap=\"6\" linkend="
"\"ecpg-sql-declare\"/>, а команда <literal>FETCH</literal> описана в <xref "
"remap=\"6\" linkend=\"sql-fetch\"/>."

#: ecpg.xml:462(para)
msgid ""
"The ECPG <command>DECLARE</command> command does not actually cause a "
"statement to be sent to the PostgreSQL backend. The cursor is opened in the "
"backend (using the backend's <command>DECLARE</command> command) at the "
"point when the <command>OPEN</command> command is executed."
msgstr ""
"Команда <command>DECLARE</command> в ECPG на самом деле не передаёт этот "
"оператор серверу PostgreSQL. Курсор открывается на сервере (командой сервера "
"<command>DECLARE</command>) в момент, когда выполняется команда "
"<command>OPEN</command>."

#: ecpg.xml:473(title)
msgid "Managing Transactions"
msgstr "Управление транзакциями"

#: ecpg.xml:475(para)
msgid ""
"In the default mode, statements are committed only when <command>EXEC SQL "
"COMMIT</command> is issued. The embedded SQL interface also supports "
"autocommit of transactions (similar to <application>psql</application>'s "
"default behavior) via the <option>-t</option> command-line option to "
"<command>ecpg</command> (see <xref linkend=\"app-ecpg\"/>) or via the "
"<literal>EXEC SQL SET AUTOCOMMIT TO ON</literal> statement. In autocommit "
"mode, each command is automatically committed unless it is inside an "
"explicit transaction block. This mode can be explicitly turned off using "
"<literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>."
msgstr ""
"В режиме по умолчанию операторы фиксируются только когда выполняется "
"<command>EXEC SQL COMMIT</command>. Интерфейс встраиваемого SQL также "
"поддерживает автофиксацию транзакций (так работает <application>libpq</"
"application> по умолчанию); она включается аргументом командной строки "
"<option>-t</option> программы <command>ecpg</command> (см. <xref remap=\"4\" "
"linkend=\"app-ecpg\"/>) либо оператором <literal>EXEC SQL SET AUTOCOMMIT TO "
"ON</literal>. В режиме автофиксации каждая команда фиксируется "
"автоматически, если только она не помещена в явный блок транзакции. Этот "
"режим можно выключить явным образом, выполнив <literal>EXEC SQL SET "
"AUTOCOMMIT TO OFF</literal>."

#: ecpg.xml:493(literal)
msgid "EXEC SQL COMMIT"
msgstr "EXEC SQL COMMIT"

#: ecpg.xml:495(para)
msgid "Commit an in-progress transaction."
msgstr "Зафиксировать текущую транзакцию."

#: ecpg.xml:502(literal)
msgid "EXEC SQL ROLLBACK"
msgstr "EXEC SQL ROLLBACK"

#: ecpg.xml:504(para)
msgid "Roll back an in-progress transaction."
msgstr "Откатить текущую транзакцию."

#: ecpg.xml:511(literal)
msgid "EXEC SQL SET AUTOCOMMIT TO ON"
msgstr "EXEC SQL SET AUTOCOMMIT TO ON"

#: ecpg.xml:513(para)
msgid "Enable autocommit mode."
msgstr "Включить режим автофиксации."

#: ecpg.xml:520(literal)
msgid "SET AUTOCOMMIT TO OFF"
msgstr "SET AUTOCOMMIT TO OFF"

#: ecpg.xml:522(para)
msgid "Disable autocommit mode. This is the default."
msgstr "Отключить режим автофиксации. По умолчанию он отключён."

#: ecpg.xml:488(para)
msgid ""
"The following transaction management commands are available: <placeholder-1/>"
msgstr ""
"Поддерживаются следующие команды управления транзакциями: <placeholder-1/>"

#: ecpg.xml:532(title)
msgid "Prepared Statements"
msgstr "Подготовленные операторы"

#: ecpg.xml:534(para)
msgid ""
"When the values to be passed to an SQL statement are not known at compile "
"time, or the same statement is going to be used many times, then prepared "
"statements can be useful."
msgstr ""
"Когда значения, передаваемые оператору SQL, неизвестны во время компиляции, "
"или один и тот же оператор будет использоваться многократно, могут быть "
"полезны подготовленные операторы."

#: ecpg.xml:545(programlisting)
#, no-wrap
msgid "EXEC SQL PREPARE stmt1 FROM \"SELECT oid, datname FROM pg_database WHERE oid = ?\";"
msgstr "EXEC SQL PREPARE stmt1 FROM \"SELECT oid, datname FROM pg_database WHERE oid = ?\";"

#: ecpg.xml:540(para)
msgid ""
"The statement is prepared using the command <literal>PREPARE</literal>. For "
"the values that are not known yet, use the placeholder <quote><literal>?</"
"literal></quote>: <placeholder-1/>"
msgstr ""
"Оператор подготавливается командой <literal>PREPARE</literal>. Вместо "
"значений, которые ещё неизвестны, вставляются местозаполнители "
"<quote><literal>?</literal></quote>: <placeholder-1/>"

#: ecpg.xml:556(programlisting)
#, no-wrap
msgid "EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;"
msgstr "EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;"

#: ecpg.xml:550(para)
msgid ""
"If a statement returns a single row, the application can call "
"<literal>EXECUTE</literal> after <literal>PREPARE</literal> to execute the "
"statement, supplying the actual values for the placeholders with a "
"<literal>USING</literal> clause: <placeholder-1/>"
msgstr ""
"Если оператор возвращает одну строку, приложение может вызвать "
"<literal>EXECUTE</literal> после <literal>PREPARE</literal> для выполнения "
"этого оператора, указав фактические значения для местозаполнителей в "
"предложении <literal>USING</literal>: <placeholder-1/>"

#: ecpg.xml:566(programlisting)
#, no-wrap
msgid ""
"EXEC SQL PREPARE stmt1 FROM \"SELECT oid,datname FROM pg_database WHERE oid &gt; ?\";\n"
"EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;\n"
"\n"
"/* when end of result set reached, break out of while loop */\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"EXEC SQL OPEN foo_bar USING 100;\n"
"...\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;\n"
"    ...\n"
"}\n"
"EXEC SQL CLOSE foo_bar;"
msgstr ""
"EXEC SQL PREPARE stmt1 FROM \"SELECT oid,datname FROM pg_database WHERE oid &gt; ?\";\n"
"EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;\n"
"\n"
"/* по достижении конца набора результатов прервать цикл while */\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"EXEC SQL OPEN foo_bar USING 100;\n"
"...\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;\n"
"    ...\n"
"}\n"
"EXEC SQL CLOSE foo_bar;"

#: ecpg.xml:561(para)
msgid ""
"If a statement returns multiple rows, the application can use a cursor "
"declared based on the prepared statement. To bind input parameters, the "
"cursor must be opened with a <literal>USING</literal> clause: <placeholder-1/"
">"
msgstr ""
"Если оператор возвращает несколько строк, приложение может использовать "
"курсор, объявленный на базе подготовленного оператора. Чтобы привязать "
"входные параметры, курсор нужно открыть с предложением <literal>USING</"
"literal>: <placeholder-1/>"

#: ecpg.xml:587(programlisting) ecpg.xml:1814(programlisting)
#, no-wrap
msgid "EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;"
msgstr "EXEC SQL DEALLOCATE PREPARE <replaceable>имя</replaceable>;"

#: ecpg.xml:584(para) ecpg.xml:1811(para)
msgid ""
"When you don't need the prepared statement anymore, you should deallocate "
"it: <placeholder-1/>"
msgstr ""
"Когда подготовленный оператор больше не нужен, его следует освободить: "
"<placeholder-1/>"

#: ecpg.xml:592(para)
msgid ""
"For more details about <literal>PREPARE</literal>, see <xref linkend=\"ecpg-"
"sql-prepare\"/>. Also see <xref linkend=\"ecpg-dynamic\"/> for more details "
"about using placeholders and input parameters."
msgstr ""
"Подробнее оператор <literal>PREPARE</literal> описан в <xref remap=\"6\" "
"linkend=\"ecpg-sql-prepare\"/>. Также обратитесь к <xref remap=\"3\" linkend="
"\"ecpg-dynamic\"/> за дополнительными сведениями о местозаполнителях и "
"входных параметрах."

#: ecpg.xml:602(title)
msgid "Using Host Variables"
msgstr "Использование переменных среды"

#: ecpg.xml:604(para)
msgid ""
"In <xref linkend=\"ecpg-commands\"/> you saw how you can execute SQL "
"statements from an embedded SQL program. Some of those statements only used "
"fixed values and did not provide a way to insert user-supplied values into "
"statements or have the program process the values returned by the query. "
"Those kinds of statements are not really useful in real applications. This "
"section explains in detail how you can pass data between your C program and "
"the embedded SQL statements using a simple mechanism called <firstterm>host "
"variables</firstterm>. In an embedded SQL program we consider the SQL "
"statements to be <firstterm>guests</firstterm> in the C program code which "
"is the <firstterm>host language</firstterm>. Therefore the variables of the "
"C program are called <firstterm>host variables</firstterm>."
msgstr ""
"В <xref remap=\"6\" linkend=\"ecpg-commands\"/> вы увидели, как можно "
"выполнять операторы SQL в программе со встраиваемым SQL. Некоторые из этих "
"операторов использовали только фиксированные значения и не давали "
"возможности вставлять в операторы произвольные значения или обрабатывать "
"значения, возвращённые запросом. Операторы такого вида не очень полезны в "
"реальных приложениях. В этом разделе подробно описывается, как можно "
"передавать данные между программой на C и встраиваемыми операторами SQL, "
"используя простой механизм, так называемые <firstterm>переменные среды</"
"firstterm>. В программе со встраиваемым SQL мы считаем SQL-операторы "
"<firstterm>внедрёнными</firstterm> в код программы на C, <firstterm>языке "
"среды</firstterm>. Таким образом, переменные программы на C называются "
"<firstterm>переменными среды</firstterm>."

#: ecpg.xml:620(para)
msgid ""
"Another way to exchange values between PostgreSQL backends and ECPG "
"applications is the use of SQL descriptors, described in <xref linkend="
"\"ecpg-descriptors\"/>."
msgstr ""
"Ещё один способ передать значения данных между сервером PostgreSQL и "
"приложениями ECPG заключается в использовании дескрипторов SQL, как описано "
"в <xref remap=\"6\" linkend=\"ecpg-descriptors\"/>."

#: ecpg.xml:627(title)
msgid "Overview"
msgstr "Обзор"

#: ecpg.xml:636(programlisting)
#, no-wrap
msgid "EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);"
msgstr "EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);"

#: ecpg.xml:629(para)
msgid ""
"Passing data between the C program and the SQL statements is particularly "
"simple in embedded SQL. Instead of having the program paste the data into "
"the statement, which entails various complications, such as properly quoting "
"the value, you can simply write the name of a C variable into the SQL "
"statement, prefixed by a colon. For example: <placeholder-1/> This statement "
"refers to two C variables named <varname>v1</varname> and <varname>v2</"
"varname> and also uses a regular SQL string literal, to illustrate that you "
"are not restricted to use one kind of data or the other."
msgstr ""
"Передавать данные между программой C и операторами SQL во встраиваемом SQL "
"очень просто. Вместо того, чтобы вставлять данные в оператор, что влечёт "
"дополнительные усложнения, в частности нужно правильно заключать значения в "
"кавычки, можно просто записать имя переменной C в операторе SQL, предварив "
"его двоеточием. Например: <placeholder-1/> Этот оператор обращается к двум "
"переменным C с именами <varname>v1</varname> и <varname>v2</varname> и также "
"использует обычную строковую константу SQL, показывая тем самым, что можно "
"свободно сочетать разные виды данных."

#: ecpg.xml:645(para)
msgid ""
"This style of inserting C variables in SQL statements works anywhere a value "
"expression is expected in an SQL statement."
msgstr ""
"Этот метод включения переменных C в операторы SQL работает везде, где "
"оператор SQL принимает выражение значения."

#: ecpg.xml:652(title)
msgid "Declare Sections"
msgstr "Секции объявлений"

#: ecpg.xml:654(para)
msgid ""
"To pass data from the program to the database, for example as parameters in "
"a query, or to pass data from the database back to the program, the C "
"variables that are intended to contain this data need to be declared in "
"specially marked sections, so the embedded SQL preprocessor is made aware of "
"them."
msgstr ""
"Чтобы передать данные из программы в базу данных, например, в виде "
"параметров запроса, либо получить данные из базы данных в программе, "
"переменные C, которые должны содержать эти данные, нужно объявить в "
"специально помеченных секциях, чтобы препроцессор встраиваемого SQL знал о "
"них."

#: ecpg.xml:664(programlisting)
#, no-wrap
msgid "EXEC SQL BEGIN DECLARE SECTION;"
msgstr "EXEC SQL BEGIN DECLARE SECTION;"

#: ecpg.xml:668(programlisting)
#, no-wrap
msgid "EXEC SQL END DECLARE SECTION;"
msgstr "EXEC SQL END DECLARE SECTION;"

#: ecpg.xml:673(programlisting)
#, no-wrap
msgid ""
"int   x = 4;\n"
"char  foo[16], bar[16];"
msgstr ""
"int   x = 4;\n"
"char  foo[16], bar[16];"

#: ecpg.xml:682(programlisting)
#, no-wrap
msgid "EXEC SQL int i = 4;"
msgstr "EXEC SQL int i = 4;"

#: ecpg.xml:662(para)
msgid ""
"This section starts with: <placeholder-1/> and ends with: <placeholder-2/> "
"Between those lines, there must be normal C variable declarations, such as: "
"<placeholder-3/> As you can see, you can optionally assign an initial value "
"to the variable. The variable's scope is determined by the location of its "
"declaring section within the program. You can also declare variables with "
"the following syntax which implicitly creates a declare section: "
"<placeholder-4/> You can have as many declare sections in a program as you "
"like."
msgstr ""
"Секция начинается с: <placeholder-1/> и заканчивается командой: "
"<placeholder-2/> Между этими строками должны располагаться обычные "
"объявления переменных C, например: <placeholder-3/> Как здесь показано, "
"переменной можно присвоить начальное значение. Область видимости переменной "
"определяется расположением секции, в которой она объявляется в программе. Вы "
"также можете объявить переменную следующим образом (при этом неявно "
"создаётся секция объявлений): <placeholder-4/> Вы можете включать в "
"программу столько секций объявлений, сколько захотите."

#: ecpg.xml:688(para)
msgid ""
"The declarations are also echoed to the output file as normal C variables, "
"so there's no need to declare them again. Variables that are not intended to "
"be used in SQL commands can be declared normally outside these special "
"sections."
msgstr ""
"Эти объявления выводятся в результирующий файл как объявления обычных "
"переменных C, так что эти переменные не нужно объявлять снова. Переменные, "
"которые не предназначены для использования в командах SQL, можно объявить "
"как обычно вне этих специальных секций."

#: ecpg.xml:695(para)
msgid ""
"The definition of a structure or union also must be listed inside a "
"<literal>DECLARE</literal> section. Otherwise the preprocessor cannot handle "
"these types since it does not know the definition."
msgstr ""
"Определение структуры или объединения тоже должно размещаться в секции "
"<literal>DECLARE</literal>. В противном случае препроцессор не сможет "
"воспринять эти типы, так как не будет знать их определения."

#: ecpg.xml:703(title)
msgid "Retrieving Query Results"
msgstr "Получение результатов запроса"

#: ecpg.xml:705(para)
msgid ""
"Now you should be able to pass data generated by your program into an SQL "
"command. But how do you retrieve the results of a query? For that purpose, "
"embedded SQL provides special variants of the usual commands "
"<command>SELECT</command> and <command>FETCH</command>. These commands have "
"a special <literal>INTO</literal> clause that specifies which host variables "
"the retrieved values are to be stored in. <command>SELECT</command> is used "
"for a query that returns only single row, and <command>FETCH</command> is "
"used for a query that returns multiple rows, using a cursor."
msgstr ""
"Теперь вы умеете передавать данные, подготовленные вашей программой, в "
"команду SQL. Но как получить результаты запроса? Для этой цели во "
"встраиваемом SQL есть особые вариации обычных команд <command>SELECT</"
"command> и <command>FETCH</command>. У этих команд есть специальное "
"предложение <literal>INTO</literal>, определяющее, в какие переменные среды "
"будут помещены получаемые значения. <command>SELECT</command> используется "
"для запросов, возвращающих только одну строку, а <command>FETCH</command> "
"применяется с курсором для запросов, возвращающих несколько строк."

#: ecpg.xml:720(programlisting)
#, no-wrap
msgid ""
"/*\n"
" * assume this table:\n"
" * CREATE TABLE test1 (a int, b varchar(50));\n"
" */\n"
"\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int v1;\n"
"VARCHAR v2;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
" ...\n"
"\n"
"EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;"
msgstr ""
"/*\n"
" * предполагается существование такой таблицы:\n"
" * CREATE TABLE test1 (a int, b varchar(50));\n"
" */\n"
"\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int v1;\n"
"VARCHAR v2;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
" ...\n"
"\n"
"EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;"

#: ecpg.xml:718(para)
msgid ""
"Here is an example: <placeholder-1/> So the <literal>INTO</literal> clause "
"appears between the select list and the <literal>FROM</literal> clause. The "
"number of elements in the select list and the list after <literal>INTO</"
"literal> (also called the target list) must be equal."
msgstr ""
"Пример: <placeholder-1/> Предложение <literal>INTO</literal> размещается "
"между списком выборки и предложением <literal>FROM</literal>. Число "
"элементов в списке выборки должно равняться числу элементов в списке после "
"<literal>INTO</literal> (также называемом целевым списком)."

#: ecpg.xml:744(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int v1;\n"
"VARCHAR v2;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
" ...\n"
"\n"
"EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;\n"
"\n"
" ...\n"
"\n"
"do\n"
"{\n"
"    ...\n"
"    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;\n"
"    ...\n"
"} while (...);"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int v1;\n"
"VARCHAR v2;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
" ...\n"
"\n"
"EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;\n"
"\n"
" ...\n"
"\n"
"do\n"
"{\n"
"    ...\n"
"    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;\n"
"    ...\n"
"} while (...);"

#: ecpg.xml:742(para)
msgid ""
"Here is an example using the command <command>FETCH</command>: "
"<placeholder-1/> Here the <literal>INTO</literal> clause appears after all "
"the normal clauses."
msgstr ""
"Следующий пример демонстрирует использование команды <command>FETCH</"
"command>: <placeholder-1/> Здесь предложение <literal>INTO</literal> "
"размещается после всех остальных обычных предложений."

#: ecpg.xml:770(title)
msgid "Type Mapping"
msgstr "Сопоставление типов"

#: ecpg.xml:772(para)
msgid ""
"When ECPG applications exchange values between the PostgreSQL server and the "
"C application, such as when retrieving query results from the server or "
"executing SQL statements with input parameters, the values need to be "
"converted between PostgreSQL data types and host language variable types (C "
"language data types, concretely). One of the main points of ECPG is that it "
"takes care of this automatically in most cases."
msgstr ""
"Когда приложения ECPG передают данные между сервером PostgreSQL и программой "
"на C, например, получая результаты запроса с сервера или выполняя операторы "
"SQL с входными параметрам, эти данные должны преобразовываться из типов "
"PostgreSQL в типы переменных языка среды (а именно типы языка C) и наоборот. "
"Одно из главных качеств ECPG состоит в том, что в большинстве случаев он "
"делает это автоматически."

#: ecpg.xml:782(para)
msgid ""
"In this respect, there are two kinds of data types: Some simple PostgreSQL "
"data types, such as <type>integer</type> and <type>text</type>, can be read "
"and written by the application directly. Other PostgreSQL data types, such "
"as <type>timestamp</type> and <type>numeric</type> can only be accessed "
"through special library functions; see <xref linkend=\"ecpg-special-types\"/"
">."
msgstr ""
"В этом отношении можно выделить два вида типов данных. К первому относятся "
"простые типы данных PostgreSQL, такие как <type>integer</type> и <type>text</"
"type>, которые приложение может непосредственно читать и писать. С другими "
"типами данных, такими как <type>timestamp</type> и <type>numeric</type>, "
"можно работать только через специальные функции; см. <xref remap=\"4\" "
"linkend=\"ecpg-special-types\"/>."

#: ecpg.xml:792(para)
msgid ""
"<xref linkend=\"ecpg-datatype-hostvars-table\"/> shows which PostgreSQL data "
"types correspond to which C data types. When you wish to send or receive a "
"value of a given PostgreSQL data type, you should declare a C variable of "
"the corresponding C data type in the declare section."
msgstr ""
"В <xref remap=\"6\" linkend=\"ecpg-datatype-hostvars-table\"/> показано, как "
"типы данных PostgreSQL соответствуют типам данных C. Когда нужно передать "
"или получить значение определённого типа данных PostgreSQL, вы должны "
"объявить переменную C соответствующего типа C в секции объявлений."

#: ecpg.xml:801(title)
msgid "Mapping Between PostgreSQL Data Types and C Variable Types"
msgstr "Соответствие между типами данных PostgreSQL и типами переменных C"

#: ecpg.xml:805(entry)
msgid "PostgreSQL data type"
msgstr "Тип данных PostgreSQL"

#: ecpg.xml:806(entry)
msgid "Host variable type"
msgstr "Тип переменной среды"

#: ecpg.xml:812(type)
msgid "smallint"
msgstr "smallint"

#: ecpg.xml:813(type) ecpg.xml:848(type)
msgid "short"
msgstr "short"

#: ecpg.xml:817(type)
msgid "integer"
msgstr "integer"

#: ecpg.xml:818(type) ecpg.xml:853(type)
msgid "int"
msgstr "int"

#: ecpg.xml:822(type)
msgid "bigint"
msgstr "bigint"

#: ecpg.xml:823(type) ecpg.xml:858(type)
msgid "long long int"
msgstr "long long int"

#: ecpg.xml:827(type) ecpg.xml:828(type)
msgid "decimal"
msgstr "decimal"

#: ecpg.xml:828(para)
msgid ""
"This type can only be accessed through special library functions; see <xref "
"linkend=\"ecpg-special-types\"/>."
msgstr ""
"С этим типом можно работать только через специальные функции; см. <xref "
"remap=\"4\" linkend=\"ecpg-special-types\"/>."

#: ecpg.xml:832(type) ecpg.xml:833(type)
msgid "numeric"
msgstr "numeric"

#: ecpg.xml:837(type)
msgid "real"
msgstr "real"

#: ecpg.xml:838(type)
msgid "float"
msgstr "float"

#: ecpg.xml:842(type)
msgid "double precision"
msgstr "double precision"

#: ecpg.xml:843(type)
msgid "double"
msgstr "double"

#: ecpg.xml:847(type)
msgid "smallserial"
msgstr "smallserial"

#: ecpg.xml:852(type)
msgid "serial"
msgstr "serial"

#: ecpg.xml:857(type)
msgid "bigserial"
msgstr "bigserial"

#: ecpg.xml:862(type)
msgid "oid"
msgstr "oid"

#: ecpg.xml:863(type)
msgid "unsigned int"
msgstr "unsigned int"

#: ecpg.xml:867(entry)
msgid ""
"<type>character(<replaceable>n</replaceable>)</type>, "
"<type>varchar(<replaceable>n</replaceable>)</type>, <type>text</type>"
msgstr ""
"<type>character(<replaceable>n</replaceable>)</type>, "
"<type>varchar(<replaceable>n</replaceable>)</type>, <type>text</type>"

#: ecpg.xml:868(para)
msgid "declared in <filename>ecpglib.h</filename>"
msgstr "объявляется в <filename>ecpglib.h</filename>"

#: ecpg.xml:868(entry)
msgid ""
"<type>char[<replaceable>n</replaceable>+1]</type>, "
"<type>VARCHAR[<replaceable>n</replaceable>+1]</type><placeholder-1/>"
msgstr ""
"<type>char[<replaceable>n</replaceable>+1]</type>, "
"<type>VARCHAR[<replaceable>n</replaceable>+1]</type><placeholder-1/>"

#: ecpg.xml:872(type)
msgctxt "type"
msgid "name"
msgstr "name"

#: ecpg.xml:873(type)
msgid "char[NAMEDATALEN]"
msgstr "char[NAMEDATALEN]"

#: ecpg.xml:877(type) ecpg.xml:878(type)
msgid "timestamp"
msgstr "timestamp"

#: ecpg.xml:882(type) ecpg.xml:883(type)
msgctxt "type"
msgid "interval"
msgstr "interval"

#: ecpg.xml:887(type) ecpg.xml:888(type)
msgid "date"
msgstr "date"

#: ecpg.xml:892(type)
msgid "boolean"
msgstr "boolean"

#: ecpg.xml:893(type)
msgid "bool"
msgstr "bool"

#: ecpg.xml:893(para)
msgid "declared in <filename>ecpglib.h</filename> if not native"
msgstr ""
"объявляется в <filename>ecpglib.h</filename> при отсутствии стандартного "
"объявления"

#: ecpg.xml:900(title)
msgid "Handling Character Strings"
msgstr "Работа с символьными строками"

#: ecpg.xml:902(para)
msgid ""
"To handle SQL character string data types, such as <type>varchar</type> and "
"<type>text</type>, there are two possible ways to declare the host variables."
msgstr ""
"Для обработки типов символьных строк SQL, таких как <type>varchar</type> и "
"<type>text</type>, предлагаются два варианта объявления переменных среды."

#: ecpg.xml:912(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    char str[50];\n"
"EXEC SQL END DECLARE SECTION;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    char str[50];\n"
"EXEC SQL END DECLARE SECTION;"

#: ecpg.xml:908(para)
msgid ""
"One way is using <type>char[]</type>, an array of <type>char</type>, which "
"is the most common way to handle character data in C. <placeholder-1/> Note "
"that you have to take care of the length yourself. If you use this host "
"variable as the target variable of a query which returns a string with more "
"than 49 characters, a buffer overflow occurs."
msgstr ""
"Первый способ заключается в использовании <type>char[]</type>, массива "
"<type>char</type>, как чаще всего и представляются символьные данные в C. "
"<placeholder-1/> Заметьте, что о длине этого массива вы должны подумать "
"сами. Если вы укажете данную переменную среды в качестве целевой переменной "
"запроса, возвращающего строку длиннее 49 символов, произойдёт переполнение "
"буфера."

#: ecpg.xml:928(programlisting)
#, no-wrap
msgid "VARCHAR var[180];"
msgstr "VARCHAR var[180];"

#: ecpg.xml:932(programlisting)
#, no-wrap
msgid "struct varchar_var { int len; char arr[180]; } var;"
msgstr "struct varchar_var { int len; char arr[180]; } var;"

#: ecpg.xml:923(para)
msgid ""
"The other way is using the <type>VARCHAR</type> type, which is a special "
"type provided by ECPG. The definition on an array of type <type>VARCHAR</"
"type> is converted into a named <type>struct</type> for every variable. A "
"declaration like: <placeholder-1/> is converted into: <placeholder-2/> The "
"member <structfield>arr</structfield> hosts the string including a "
"terminating zero byte. Thus, to store a string in a <type>VARCHAR</type> "
"host variable, the host variable has to be declared with the length "
"including the zero byte terminator. The member <structfield>len</"
"structfield> holds the length of the string stored in the <structfield>arr</"
"structfield> without the terminating zero byte. When a host variable is used "
"as input for a query, if <literal>strlen(arr)</literal> and "
"<structfield>len</structfield> are different, the shorter one is used."
msgstr ""
"В качестве другого подхода можно использовать специальный тип <type>VARCHAR</"
"type>, представленный в ECPG. Определение массива типа <type>VARCHAR</type> "
"преобразуется в структуру (<type>struct</type>) с собственным именем для "
"каждой переменной. Объявление вида: <placeholder-1/> преобразуется в: "
"<placeholder-2/> Член структуры <structfield>arr</structfield> содержит "
"строку, включающую завершающий нулевой байт. Таким образом, чтобы сохранить "
"строку в переменной типа <type>VARCHAR</type>, эта переменная должна быть "
"объявлена с длиной, учитывающей завершающий нулевой байт. Член структуры "
"<structfield>len</structfield> содержит длину строки, сохранённой в "
"<structfield>arr</structfield>, без завершающего нулевого байта. Когда на "
"вход запросу подаётся переменная среды, у которой <literal>strlen(arr)</"
"literal> отличается от <structfield>len</structfield>, применяется "
"наименьшее значение."

#: ecpg.xml:947(para)
msgid ""
"<type>VARCHAR</type> can be written in upper or lower case, but not in mixed "
"case."
msgstr ""
"<type>VARCHAR</type> можно записать в верхнем или нижнем регистре, но не в "
"смешанном."

#: ecpg.xml:952(para)
msgid ""
"<type>char</type> and <type>VARCHAR</type> host variables can also hold "
"values of other SQL types, which will be stored in their string forms."
msgstr ""
"Переменные <type>char</type> и <type>VARCHAR</type> также могут содержать "
"значения других типов SQL в их строковом представлении."

#: ecpg.xml:960(title)
msgid "Accessing Special Data Types"
msgstr "Обработка специальных типов данных"

#: ecpg.xml:962(para)
msgid ""
"ECPG contains some special types that help you to interact easily with some "
"special data types from the PostgreSQL server. In particular, it has "
"implemented support for the <type>numeric</type>, <type>decimal</type>, "
"<type>date</type>, <type>timestamp</type>, and <type>interval</type> types. "
"These data types cannot usefully be mapped to primitive host variable types "
"(such as <type>int</type>, <type>long long int</type>, or <type>char[]</"
"type>), because they have a complex internal structure. Applications deal "
"with these types by declaring host variables in special types and accessing "
"them using functions in the pgtypes library. The pgtypes library, described "
"in detail in <xref linkend=\"ecpg-pgtypes\"/> contains basic functions to "
"deal with those types, such that you do not need to send a query to the SQL "
"server just for adding an interval to a time stamp for example."
msgstr ""
"ECPG представляет некоторые особые типы, которые должны помочь вам легко "
"оперировать некоторыми специальными типами данных PostgreSQL. В частности, в "
"нём реализована поддержка типов <type>numeric</type>, <type>decimal</type>, "
"<type>date</type>, <type>timestamp</type> и <type>interval</type>. Для этих "
"типов нельзя подобрать полезное соответствие с примитивными типами среды "
"(например, <type>int</type>, <type>long long int</type> или <type>char[]</"
"type>), так как они имеют сложную внутреннюю структуру. Приложения, "
"работающие с этими типами, должны объявлять переменные особых типов и "
"работать с ними, применяя функции из библиотеки pgtypes. Эта библиотека, "
"подробно описанная в <xref remap=\"6\" linkend=\"ecpg-pgtypes\"/> содержит "
"базовые функции для оперирования этими типами, чтобы вам не требовалось, "
"например, передавать запрос SQL-серверу, когда нужно просто добавить "
"интервал к значению времени."

#: ecpg.xml:980(para)
msgid ""
"The follow subsections describe these special data types. For more details "
"about pgtypes library functions, see <xref linkend=\"ecpg-pgtypes\"/>."
msgstr ""
"Эти особые типы данных описаны в следующих подразделах. Чтобы подробнее "
"узнать о функциях в библиотеке pgtypes, обратитесь к <xref remap=\"3\" "
"linkend=\"ecpg-pgtypes\"/>."

#: ecpg.xml:987(title)
msgid "timestamp, date"
msgstr "timestamp, date"

#: ecpg.xml:989(para)
msgid ""
"Here is a pattern for handling <type>timestamp</type> variables in the ECPG "
"host application."
msgstr ""
"Для работы с переменными <type>timestamp</type> в приложении ECPG "
"применяется следующая схема."

#: ecpg.xml:997(programlisting)
#, no-wrap
msgid "#include &lt;pgtypes_timestamp.h&gt;"
msgstr "#include &lt;pgtypes_timestamp.h&gt;"

#: ecpg.xml:994(para)
msgid ""
"First, the program has to include the header file for the <type>timestamp</"
"type> type: <placeholder-1/>"
msgstr ""
"Сначала в программу нужно включить заголовочный файл, чтобы получить "
"определение типа <type>timestamp</type>: <placeholder-1/>"

#: ecpg.xml:1005(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"timestamp ts;\n"
"EXEC SQL END DECLARE SECTION;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"timestamp ts;\n"
"EXEC SQL END DECLARE SECTION;"

#: ecpg.xml:1002(para)
msgid ""
"Next, declare a host variable as type <type>timestamp</type> in the declare "
"section: <placeholder-1/>"
msgstr ""
"Затем объявите в секции объявлений переменную типа <type>timestamp</type>: "
"<placeholder-1/>"

#: ecpg.xml:1018(programlisting)
#, no-wrap
msgid ""
"EXEC SQL SELECT now()::timestamp INTO :ts;\n"
"\n"
"printf(\"ts = %s\\n\", PGTYPEStimestamp_to_asc(ts));"
msgstr ""
"EXEC SQL SELECT now()::timestamp INTO :ts;\n"
"\n"
"printf(\"ts = %s\\n\", PGTYPEStimestamp_to_asc(ts));"

#: ecpg.xml:1012(para)
msgid ""
"And after reading a value into the host variable, process it using pgtypes "
"library functions. In following example, the <type>timestamp</type> value is "
"converted into text (ASCII) form with the "
"<function>PGTYPEStimestamp_to_asc()</function> function: <placeholder-1/> "
"This example will show some result like following: <screen>\n"
"ts = 2010-06-27 18:03:56.949343\n"
"</screen>"
msgstr ""
"Прочитав значение в эту переменную, выполняйте действия с ним, используя "
"функции в библиотеке pgtypes. В следующем примере значение <type>timestamp</"
"type> преобразуется в текстовый вид (ASCII) с помощью функции "
"<function>PGTYPEStimestamp_to_asc()</function>: <placeholder-1/> Этот пример "
"выведет такой результат: <screen>\n"
"ts = 2010-06-27 18:03:56.949343\n"
"</screen>"

#: ecpg.xml:1029(para)
msgid ""
"In addition, the DATE type can be handled in the same way. The program has "
"to include <filename>pgtypes_date.h</filename>, declare a host variable as "
"the date type and convert a DATE value into a text form using "
"<function>PGTYPESdate_to_asc()</function> function. For more details about "
"the pgtypes library functions, see <xref linkend=\"ecpg-pgtypes\"/>."
msgstr ""
"Таким же образом можно работать и с типом DATE. В программу нужно включить "
"<filename>pgtypes_date.h</filename>, объявить переменную типа date, и затем "
"можно будет преобразовать значение DATE в текстовый вид, используя функцию "
"<function>PGTYPESdate_to_asc()</function>. Чтобы подробнее узнать о функциях "
"в библиотеке pgtypes, обратитесь к <xref remap=\"3\" linkend=\"ecpg-pgtypes"
"\"/>."

#: ecpg.xml:1039(title)
msgctxt "title"
msgid "interval"
msgstr "interval"

#: ecpg.xml:1041(para)
msgid ""
"The handling of the <type>interval</type> type is also similar to the "
"<type>timestamp</type> and <type>date</type> types. It is required, however, "
"to allocate memory for an <type>interval</type> type value explicitly. In "
"other words, the memory space for the variable has to be allocated in the "
"heap memory, not in the stack memory."
msgstr ""
"Принцип работы с типом <type>interval</type> тот же, что и с типами "
"<type>timestamp</type> и <type>date</type>, однако для значения типа "
"<type>interval</type> нужно явно выделить память. Другими словами, блок "
"памяти для этой переменной должен размещаться в области кучи, а не в стеке."

#: ecpg.xml:1052(programlisting)
#, no-wrap
msgid ""
"#include &lt;stdio.h&gt;\n"
"#include &lt;stdlib.h&gt;\n"
"#include &lt;pgtypes_interval.h&gt;\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    interval *in;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb;\n"
"\n"
"    in = PGTYPESinterval_new();\n"
"    EXEC SQL SELECT '1 min'::interval INTO :in;\n"
"    printf(\"interval = %s\\n\", PGTYPESinterval_to_asc(in));\n"
"    PGTYPESinterval_free(in);\n"
"\n"
"    EXEC SQL COMMIT;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"    return 0;\n"
"}"
msgstr ""
"#include &lt;stdio.h&gt;\n"
"#include &lt;stdlib.h&gt;\n"
"#include &lt;pgtypes_interval.h&gt;\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    interval *in;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb;\n"
"\n"
"    in = PGTYPESinterval_new();\n"
"    EXEC SQL SELECT '1 min'::interval INTO :in;\n"
"    printf(\"interval = %s\\n\", PGTYPESinterval_to_asc(in));\n"
"    PGTYPESinterval_free(in);\n"
"\n"
"    EXEC SQL COMMIT;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"    return 0;\n"
"}"

#: ecpg.xml:1050(para)
msgid "Here is an example program: <placeholder-1/>"
msgstr "Пример программы: <placeholder-1/>"

#: ecpg.xml:1080(title)
msgid "numeric, decimal"
msgstr "numeric, decimal"

#: ecpg.xml:1082(para)
msgid ""
"The handling of the <type>numeric</type> and <type>decimal</type> types is "
"similar to the <type>interval</type> type: It requires defining a pointer, "
"allocating some memory space on the heap, and accessing the variable using "
"the pgtypes library functions. For more details about the pgtypes library "
"functions, see <xref linkend=\"ecpg-pgtypes\"/>."
msgstr ""
"Типы <type>numeric</type> и <type>decimal</type> обрабатываются так же, как "
"и тип <type>interval</type>: вы должны определить указатель, выделить "
"некоторое пространство памяти в куче и обращаться к переменной, используя "
"функции в библиотеке pgtypes. Чтобы подробнее узнать о функциях в библиотеке "
"pgtypes, обратитесь к <xref remap=\"3\" linkend=\"ecpg-pgtypes\"/>."

#: ecpg.xml:1092(para)
msgid ""
"No functions are provided specifically for the <type>decimal</type> type. An "
"application has to convert it to a <type>numeric</type> variable using a "
"pgtypes library function to do further processing."
msgstr ""
"Для типа <type>decimal</type> никакие специальные функции не реализованы. "
"Для дальнейшей обработки приложение должно преобразовать его в переменную "
"<type>numeric</type>, применив функцию из библиотеки pgtypes."

#: ecpg.xml:1102(programlisting)
#, no-wrap
msgid ""
"#include &lt;stdio.h&gt;\n"
"#include &lt;stdlib.h&gt;\n"
"#include &lt;pgtypes_numeric.h&gt;\n"
"\n"
"EXEC SQL WHENEVER SQLERROR STOP;\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    numeric *num;\n"
"    numeric *num2;\n"
"    decimal *dec;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb;\n"
"\n"
"    num = PGTYPESnumeric_new();\n"
"    dec = PGTYPESdecimal_new();\n"
"\n"
"    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;\n"
"\n"
"    printf(\"numeric = %s\\n\", PGTYPESnumeric_to_asc(num, 0));\n"
"    printf(\"numeric = %s\\n\", PGTYPESnumeric_to_asc(num, 1));\n"
"    printf(\"numeric = %s\\n\", PGTYPESnumeric_to_asc(num, 2));\n"
"\n"
"    /* Convert decimal to numeric to show a decimal value. */\n"
"    num2 = PGTYPESnumeric_new();\n"
"    PGTYPESnumeric_from_decimal(dec, num2);\n"
"\n"
"    printf(\"decimal = %s\\n\", PGTYPESnumeric_to_asc(num2, 0));\n"
"    printf(\"decimal = %s\\n\", PGTYPESnumeric_to_asc(num2, 1));\n"
"    printf(\"decimal = %s\\n\", PGTYPESnumeric_to_asc(num2, 2));\n"
"\n"
"    PGTYPESnumeric_free(num2);\n"
"    PGTYPESdecimal_free(dec);\n"
"    PGTYPESnumeric_free(num);\n"
"\n"
"    EXEC SQL COMMIT;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"    return 0;\n"
"}"
msgstr ""
"#include &lt;stdio.h&gt;\n"
"#include &lt;stdlib.h&gt;\n"
"#include &lt;pgtypes_numeric.h&gt;\n"
"\n"
"EXEC SQL WHENEVER SQLERROR STOP;\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    numeric *num;\n"
"    numeric *num2;\n"
"    decimal *dec;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb;\n"
"\n"
"    num = PGTYPESnumeric_new();\n"
"    dec = PGTYPESdecimal_new();\n"
"\n"
"    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;\n"
"\n"
"    printf(\"numeric = %s\\n\", PGTYPESnumeric_to_asc(num, 0));\n"
"    printf(\"numeric = %s\\n\", PGTYPESnumeric_to_asc(num, 1));\n"
"    printf(\"numeric = %s\\n\", PGTYPESnumeric_to_asc(num, 2));\n"
"\n"
"    /* Преобразовать decimal в numeric, чтобы вывести десятичное значение. */\n"
"    num2 = PGTYPESnumeric_new();\n"
"    PGTYPESnumeric_from_decimal(dec, num2);\n"
"\n"
"    printf(\"decimal = %s\\n\", PGTYPESnumeric_to_asc(num2, 0));\n"
"    printf(\"decimal = %s\\n\", PGTYPESnumeric_to_asc(num2, 1));\n"
"    printf(\"decimal = %s\\n\", PGTYPESnumeric_to_asc(num2, 2));\n"
"\n"
"    PGTYPESnumeric_free(num2);\n"
"    PGTYPESdecimal_free(dec);\n"
"    PGTYPESnumeric_free(num);\n"
"\n"
"    EXEC SQL COMMIT;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"    return 0;\n"
"}"

#: ecpg.xml:1099(para)
msgid ""
"Here is an example program handling <type>numeric</type> and <type>decimal</"
"type> type variables. <placeholder-1/>"
msgstr ""
"Следующий пример демонстрирует работу с переменными типов <type>numeric</"
"type> и <type>decimal</type>. <placeholder-1/>"

#: ecpg.xml:1151(title)
msgid "Host Variables with Nonprimitive Types"
msgstr "Переменные среды для непримитивных типов"

#: ecpg.xml:1153(para)
msgid ""
"As a host variable you can also use arrays, typedefs, structs, and pointers."
msgstr ""
"В качестве переменных среды также можно использовать массивы, определения "
"типов, структуры и указатели."

#: ecpg.xml:1159(title) ecpg.xml:1377(title)
msgid "Arrays"
msgstr "Массивы"

#: ecpg.xml:1161(para)
msgid ""
"There are two use cases for arrays as host variables. The first is a way to "
"store some text string in <type>char[]</type> or <type>VARCHAR[]</type>, as "
"explained in <xref linkend=\"ecpg-char\"/>. The second use case is to "
"retrieve multiple rows from a query result without using a cursor. Without "
"an array, to process a query result consisting of multiple rows, it is "
"required to use a cursor and the <command>FETCH</command> command. But with "
"array host variables, multiple rows can be received at once. The length of "
"the array has to be defined to be able to accommodate all rows, otherwise a "
"buffer overflow will likely occur."
msgstr ""
"Для применения массивов в качестве переменных среды есть два варианта "
"использования. Во-первых, в массиве <type>char[]</type> или <type>VARCHAR[]</"
"type> можно сохранить текстовую строку, как рассказывалось в <xref remap="
"\"6\" linkend=\"ecpg-char\"/>. Во-вторых, в массив можно получить несколько "
"строк из результата запроса, не используя курсор. Чтобы не применяя массивы, "
"обработать результат запроса, состоящий из нескольких строк, нужно "
"использовать курсор и команду <command>FETCH</command>. Но с переменными-"
"массивами несколько строк можно получить сразу. Длина определяемого массива "
"должна быть достаточной для размещения всех строк, иначе скорее всего "
"произойдёт переполнение буфера."

#: ecpg.xml:1179(programlisting)
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    int dbid[8];\n"
"    char dbname[8][16];\n"
"    int i;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    memset(dbname, 0, sizeof(char)* 16 * 8);\n"
"    memset(dbid, 0, sizeof(int) * 8);\n"
"\n"
"    EXEC SQL CONNECT TO testdb;\n"
"\n"
"    /* Retrieve multiple rows into arrays at once. */\n"
"    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;\n"
"\n"
"    for (i = 0; i &lt; 8; i++)\n"
"        printf(\"oid=%d, dbname=%s\\n\", dbid[i], dbname[i]);\n"
"\n"
"    EXEC SQL COMMIT;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    int dbid[8];\n"
"    char dbname[8][16];\n"
"    int i;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    memset(dbname, 0, sizeof(char)* 16 * 8);\n"
"    memset(dbid, 0, sizeof(int) * 8);\n"
"\n"
"    EXEC SQL CONNECT TO testdb;\n"
"\n"
"    /* Получить в массивы сразу несколько строк. */\n"
"    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;\n"
"\n"
"    for (i = 0; i &lt; 8; i++)\n"
"        printf(\"oid=%d, dbname=%s\\n\", dbid[i], dbname[i]);\n"
"\n"
"    EXEC SQL COMMIT;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"    return 0;\n"
"}"

#: ecpg.xml:1175(para)
msgid ""
"Following example scans the <literal>pg_database</literal> system table and "
"shows all OIDs and names of the available databases: <placeholder-1/> This "
"example shows following result. (The exact values depend on local "
"circumstances.) <screen>\n"
"oid=1, dbname=template1\n"
"oid=11510, dbname=template0\n"
"oid=11511, dbname=postgres\n"
"oid=313780, dbname=testdb\n"
"oid=0, dbname=\n"
"oid=0, dbname=\n"
"oid=0, dbname=\n"
"</screen>"
msgstr ""
"Следующий пример сканирует системную таблицу <literal>pg_database</literal> "
"и показывает все OID и имена доступных баз данных: <placeholder-1/> Этот "
"пример выводит следующий результат. (Точные значения зависят от локальных "
"обстоятельств.) <screen>\n"
"oid=1, dbname=template1\n"
"oid=11510, dbname=template0\n"
"oid=11511, dbname=postgres\n"
"oid=313780, dbname=testdb\n"
"oid=0, dbname=\n"
"oid=0, dbname=\n"
"oid=0, dbname=\n"
"</screen>"

#: ecpg.xml:1221(title)
msgid "Structures"
msgstr "Структуры"

#: ecpg.xml:1223(para)
msgid ""
"A structure whose member names match the column names of a query result, can "
"be used to retrieve multiple columns at once. The structure enables handling "
"multiple column values in a single host variable."
msgstr ""
"Для получения значений сразу нескольких столбцов можно применить структуру, "
"имена членов которой совпадают с именами столбцов результата запроса. "
"Структура позволяет обрабатывать значения нескольких столбцов в одной "
"переменной среды."

#: ecpg.xml:1240(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    typedef struct\n"
"    {\n"
"       int oid;\n"
"       char datname[65];\n"
"       long long int size;\n"
"    } dbinfo_t;\n"
"\n"
"    dbinfo_t dbval;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    memset(&amp;dbval, 0, sizeof(dbinfo_t));\n"
"\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;\n"
"    EXEC SQL OPEN cur1;\n"
"\n"
"    /* when end of result set reached, break out of while loop */\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        /* Fetch multiple columns into one structure. */\n"
"        EXEC SQL FETCH FROM cur1 INTO :dbval;\n"
"\n"
"        /* Print members of the structure. */\n"
"        printf(\"oid=%d, datname=%s, size=%lld\\n\", dbval.oid, dbval.datname, dbval.size);\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    typedef struct\n"
"    {\n"
"       int oid;\n"
"       char datname[65];\n"
"       long long int size;\n"
"    } dbinfo_t;\n"
"\n"
"    dbinfo_t dbval;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    memset(&amp;dbval, 0, sizeof(dbinfo_t));\n"
"\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;\n"
"    EXEC SQL OPEN cur1;\n"
"\n"
"    /* по достижении конца набора результатов прервать цикл while */\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        /* Выбрать несколько столбцов в одну структуру. */\n"
"        EXEC SQL FETCH FROM cur1 INTO :dbval;\n"
"\n"
"        /* Напечатать члены структуры. */\n"
"        printf(\"oid=%d, datname=%s, size=%lld\\n\", dbval.oid, dbval.datname, dbval.size);\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;"

#: ecpg.xml:1230(para)
msgid ""
"The following example retrieves OIDs, names, and sizes of the available "
"databases from the <literal>pg_database</literal> system table and using the "
"<function>pg_database_size()</function> function. In this example, a "
"structure variable <varname>dbinfo_t</varname> with members whose names "
"match each column in the <literal>SELECT</literal> result is used to "
"retrieve one result row without putting multiple host variables in the "
"<literal>FETCH</literal> statement. <placeholder-1/>"
msgstr ""
"Следующий пример получает значения OID, имена и размеры имеющихся баз данных "
"из системной таблицы <literal>pg_database</literal>, используя при этом "
"функцию <function>pg_database_size()</function>. В этом примере переменная "
"типа структуры <varname>dbinfo_t</varname> с членами, имена которых "
"соответствуют именам всех столбцов результата <literal>SELECT</literal>, "
"применяется для получения одной строки результата без вовлечения в оператор "
"<literal>FETCH</literal> нескольких переменных среды. <placeholder-1/>"

#: ecpg.xml:1273(para)
msgid ""
"This example shows following result. (The exact values depend on local "
"circumstances.) <screen>\n"
"oid=1, datname=template1, size=4324580\n"
"oid=11510, datname=template0, size=4243460\n"
"oid=11511, datname=postgres, size=4324580\n"
"oid=313780, datname=testdb, size=8183012\n"
"</screen>"
msgstr ""
"Этот пример показывает следующий результат. (Точные значения зависят от "
"локальных обстоятельств.) <screen>\n"
"oid=1, datname=template1, size=4324580\n"
"oid=11510, datname=template0, size=4243460\n"
"oid=11511, datname=postgres, size=4324580\n"
"oid=313780, datname=testdb, size=8183012\n"
"</screen>"

#: ecpg.xml:1290(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    typedef struct\n"
"    {\n"
"       int oid;\n"
"       char datname[65];\n"
"    } dbinfo_t;\n"
"\n"
"    dbinfo_t dbval;\n"
"    long long int size;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    memset(&amp;dbval, 0, sizeof(dbinfo_t));\n"
"\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;\n"
"    EXEC SQL OPEN cur1;\n"
"\n"
"    /* when end of result set reached, break out of while loop */\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        /* Fetch multiple columns into one structure. */\n"
"        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;\n"
"\n"
"        /* Print members of the structure. */\n"
"        printf(\"oid=%d, datname=%s, size=%lld\\n\", dbval.oid, dbval.datname, size);\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    typedef struct\n"
"    {\n"
"       int oid;\n"
"       char datname[65];\n"
"    } dbinfo_t;\n"
"\n"
"    dbinfo_t dbval;\n"
"    long long int size;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    memset(&amp;dbval, 0, sizeof(dbinfo_t));\n"
"\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;\n"
"    EXEC SQL OPEN cur1;\n"
"\n"
"    /* по достижении конца набора результатов прервать цикл while */\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        /* Выбрать несколько столбцов в одну структуру. */\n"
"        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;\n"
"\n"
"        /* Напечатать члены структуры. */\n"
"        printf(\"oid=%d, datname=%s, size=%lld\\n\", dbval.oid, dbval.datname, size);\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;"

#: ecpg.xml:1284(para)
msgid ""
"Structure host variables <quote>absorb</quote> as many columns as the "
"structure as fields. Additional columns can be assigned to other host "
"variables. For example, the above program could also be restructured like "
"this, with the <varname>size</varname> variable outside the structure: "
"<placeholder-1/>"
msgstr ""
"Переменные среды типа структуры <quote>вбирают в себя</quote> столько "
"столбцов, сколько полей содержит структура. Значения дополнительных столбцов "
"можно присвоить другим переменным среды. Например, приведённую выше "
"программу можно видоизменить следующим образом, разместив переменную "
"<varname>size</varname> вне структуры: <placeholder-1/>"

#: ecpg.xml:1325(title)
msgid "Typedefs"
msgstr "Определения типов"

#: ecpg.xml:1330(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    typedef char mychartype[40];\n"
"    typedef long serial_t;\n"
"EXEC SQL END DECLARE SECTION;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    typedef char mychartype[40];\n"
"    typedef long serial_t;\n"
"EXEC SQL END DECLARE SECTION;"

#: ecpg.xml:1337(programlisting)
#, no-wrap
msgid "EXEC SQL TYPE serial_t IS long;"
msgstr "EXEC SQL TYPE serial_t IS long;"

#: ecpg.xml:1327(para)
msgid ""
"Use the <literal>typedef</literal> keyword to map new types to already "
"existing types. <placeholder-1/> Note that you could also use: "
"<placeholder-2/> This declaration does not need to be part of a declare "
"section."
msgstr ""
"Чтобы сопоставить новые типы с уже существующими, используйте ключевое слово "
"<literal>typedef</literal>. <placeholder-1/> Заметьте, что вы также можете "
"написать: <placeholder-2/> Это объявление не обязательно должно находиться в "
"секции объявлений."

#: ecpg.xml:1345(title)
msgid "Pointers"
msgstr "Указатели"

#: ecpg.xml:1347(para)
msgid ""
"You can declare pointers to the most common types. Note however that you "
"cannot use pointers as target variables of queries without auto-allocation. "
"See <xref linkend=\"ecpg-descriptors\"/> for more information on auto-"
"allocation."
msgstr ""
"Вы можете объявлять указатели на самые распространённые типы. Учтите, "
"однако, что указатели нельзя использовать в качестве целевых переменных "
"запросов без автовыделения. За дополнительными сведениями об автовыделении "
"обратитесь к <xref remap=\"3\" linkend=\"ecpg-descriptors\"/>."

#: ecpg.xml:1355(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    int   *intp;\n"
"    char **charp;\n"
"EXEC SQL END DECLARE SECTION;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    int   *intp;\n"
"    char **charp;\n"
"EXEC SQL END DECLARE SECTION;"

#: ecpg.xml:1367(title)
msgid "Handling Nonprimitive SQL Data Types"
msgstr "Обработка непримитивных типов данных SQL"

#: ecpg.xml:1369(para)
msgid ""
"This section contains information on how to handle nonscalar and user-"
"defined SQL-level data types in ECPG applications. Note that this is "
"distinct from the handling of host variables of nonprimitive types, "
"described in the previous section."
msgstr ""
"В этом разделе описывается как работать с нескалярными и пользовательскими "
"типами уровня SQL в приложениях ECPG. Заметьте, что этот подход отличается "
"от использования переменных непримитивных типов, описанного в предыдущем "
"разделе."

#: ecpg.xml:1379(para)
msgid ""
"Multi-dimensional SQL-level arrays are not directly supported in ECPG. One-"
"dimensional SQL-level arrays can be mapped into C array host variables and "
"vice-versa. However, when creating a statement ecpg does not know the types "
"of the columns, so that it cannot check if a C array is input into a "
"corresponding SQL-level array. When processing the output of a SQL "
"statement, ecpg has the necessary information and thus checks if both are "
"arrays."
msgstr ""
"Многомерные массивы уровня SQL в ECPG напрямую не поддерживаются, но "
"одномерные массивы уровня SQL могут быть сопоставлены с переменными-"
"массивами среды C и наоборот. Однако учтите, что когда создаётся оператор, "
"ecpg не знает типов столбцов, поэтому не может проверить, вводится ли массив "
"C в соответствующий массив уровня SQL. Обрабатывая результат оператора SQL, "
"ecpg имеет необходимую информацию и таким образом может убедиться, что с "
"обеих сторон массивы."

#: ecpg.xml:1389(para)
msgid ""
"If a query accesses <emphasis>elements</emphasis> of an array separately, "
"then this avoids the use of arrays in ECPG. Then, a host variable with a "
"type that can be mapped to the element type should be used. For example, if "
"a column type is array of <type>integer</type>, a host variable of type "
"<type>int</type> can be used. Also if the element type is <type>varchar</"
"type> or <type>text</type>, a host variable of type <type>char[]</type> or "
"<type>VARCHAR[]</type> can be used."
msgstr ""
"Если запрос обращается к отдельным <emphasis>элементам</emphasis> массива, "
"это избавляет от необходимости применять массивы в ECPG. В этом случае "
"следует использовать переменную среды, имеющую тип, который можно "
"сопоставить типу элемента. Например, если типом столбца является массив "
"<type>integer</type>, можно использовать переменную среды типа <type>int</"
"type>. Аналогично, если тип элемента — <type>varchar</type> или <type>text</"
"type>, можно использовать переменную типа <type>char[]</type> или "
"<type>VARCHAR[]</type>."

#: ecpg.xml:1402(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE t3 (\n"
"    ii integer[]\n"
");\n"
"\n"
"testdb=&gt; SELECT * FROM t3;\n"
"     ii\n"
"-------------\n"
" {1,2,3,4,5}\n"
"(1 row)"
msgstr ""
"CREATE TABLE t3 (\n"
"    ii integer[]\n"
");\n"
"\n"
"testdb=&gt; SELECT * FROM t3;\n"
"     ii\n"
"-------------\n"
" {1,2,3,4,5}\n"
"(1 row)"

#: ecpg.xml:1417(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int ii;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH FROM cur1 INTO :ii ;\n"
"    printf(\"ii=%d\\n\", ii);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cur1;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int ii;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH FROM cur1 INTO :ii ;\n"
"    printf(\"ii=%d\\n\", ii);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cur1;"

#: ecpg.xml:1400(para)
msgid ""
"Here is an example. Assume the following table: <placeholder-1/> The "
"following example program retrieves the 4th element of the array and stores "
"it into a host variable of type <type>int</type>: <placeholder-2/> This "
"example shows the following result: <screen>\n"
"ii=4\n"
"</screen>"
msgstr ""
"Предположим, что у нас есть таблица: <placeholder-1/> Следующая программа "
"получает 4-ый элемент массива и сохраняет его в переменной среды, имеющей "
"тип <type>int</type>: <placeholder-2/> Этот пример выводит следующий "
"результат: <screen>\n"
"ii=4\n"
"</screen>"

#: ecpg.xml:1447(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int ii_a[8];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];\n"
"    ...\n"
"}"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int ii_a[8];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];\n"
"    ...\n"
"}"

#: ecpg.xml:1442(para)
msgid ""
"To map multiple array elements to the multiple elements in an array type "
"host variables each element of array column and each element of the host "
"variable array have to be managed separately, for example: <placeholder-1/>"
msgstr ""
"Чтобы сопоставить несколько элементов массива с несколькими элементами "
"переменной-массивом среды, каждый элемент массива SQL нужно по отдельности "
"связать с каждым элементом массива среды, например: <placeholder-1/>"

#: ecpg.xml:1467(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int ii_a[8];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* WRONG */\n"
"    EXEC SQL FETCH FROM cur1 INTO :ii_a;\n"
"    ...\n"
"}"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int ii_a[8];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* НЕПРАВИЛЬНО */\n"
"    EXEC SQL FETCH FROM cur1 INTO :ii_a;\n"
"    ...\n"
"}"

#: ecpg.xml:1465(para)
msgid ""
"Note again that <placeholder-1/> would not work correctly in this case, "
"because you cannot map an array type column to an array host variable "
"directly."
msgstr ""
"Ещё раз обратите внимание, что в этом случае вариант <placeholder-1/> не "
"будет работать корректно, так как столбец с типом массива нельзя напрямую "
"сопоставить с переменной-массивом среды."

#: ecpg.xml:1488(para)
msgid ""
"Another workaround is to store arrays in their external string "
"representation in host variables of type <type>char[]</type> or "
"<type>VARCHAR[]</type>. For more details about this representation, see "
"<xref linkend=\"arrays-input\"/>. Note that this means that the array cannot "
"be accessed naturally as an array in the host program (without further "
"processing that parses the text representation)."
msgstr ""
"Можно также применить обходное решение — хранить массивы в их внешнем "
"строковом представлении в переменных среды типа <type>char[]</type> или "
"<type>VARCHAR[]</type>. Более подробно это представление описывается в <xref "
"remap=\"6\" linkend=\"arrays-input\"/>. Заметьте, это означает, что с таким "
"массивом в программе нельзя будет работать естественным образом (без "
"дополнительного разбора текстового представления)."

#: ecpg.xml:1500(title)
msgid "Composite Types"
msgstr "Составные типы"

#: ecpg.xml:1502(para)
msgid ""
"Composite types are not directly supported in ECPG, but an easy workaround "
"is possible. The available workarounds are similar to the ones described for "
"arrays above: Either access each attribute separately or use the external "
"string representation."
msgstr ""
"Составные типы в ECPG напрямую не поддерживаются, но есть простое обходное "
"решение. Для решения этой проблемы можно применить те же подходы, что были "
"описаны выше для массивов: обращаться к каждому атрибуту по отдельности или "
"использовать внешнее строковое представление."

#: ecpg.xml:1512(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE comp_t AS (intval integer, textval varchar(32));\n"
"CREATE TABLE t4 (compval comp_t);\n"
"INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );"
msgstr ""
"CREATE TYPE comp_t AS (intval integer, textval varchar(32));\n"
"CREATE TABLE t4 (compval comp_t);\n"
"INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );"

#: ecpg.xml:1522(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int intval;\n"
"varchar textval[33];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"/* Put each element of the composite type column in the SELECT list. */\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* Fetch each element of the composite type column into host variables. */\n"
"    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;\n"
"\n"
"    printf(\"intval=%d, textval=%s\\n\", intval, textval.arr);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cur1;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int intval;\n"
"varchar textval[33];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"/* Указать каждый элемент столбца составного типа в списке SELECT. */\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* Выбрать каждый элемент столбца составного типа в переменную среды. */\n"
"    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;\n"
"\n"
"    printf(\"intval=%d, textval=%s\\n\", intval, textval.arr);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cur1;"

#: ecpg.xml:1510(para)
msgid ""
"For the following examples, assume the following type and table: "
"<placeholder-1/> The most obvious solution is to access each attribute "
"separately. The following program retrieves data from the example table by "
"selecting each attribute of the type <type>comp_t</type> separately: "
"<placeholder-2/>"
msgstr ""
"Для следующих примеров предполагается, что существует такой тип и таблица: "
"<placeholder-1/> Самое очевидное решение заключается в обращении к каждому "
"атрибуту по отдельности. Следующая программа получает данные из тестовой "
"таблицы, выбирая атрибуты типа <type>comp_t</type> по одному: <placeholder-2/"
">"

#: ecpg.xml:1556(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"typedef struct\n"
"{\n"
"    int intval;\n"
"    varchar textval[33];\n"
"} comp_t;\n"
"\n"
"comp_t compval;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"/* Put each element of the composite type column in the SELECT list. */\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* Put all values in the SELECT list into one structure. */\n"
"    EXEC SQL FETCH FROM cur1 INTO :compval;\n"
"\n"
"    printf(\"intval=%d, textval=%s\\n\", compval.intval, compval.textval.arr);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cur1;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"typedef struct\n"
"{\n"
"    int intval;\n"
"    varchar textval[33];\n"
"} comp_t;\n"
"\n"
"comp_t compval;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"/* Поместить каждый элемент составного типа в список SELECT. */\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* Поместить все значения списка SELECT в одну структуру. */\n"
"    EXEC SQL FETCH FROM cur1 INTO :compval;\n"
"\n"
"    printf(\"intval=%d, textval=%s\\n\", compval.intval, compval.textval.arr);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cur1;"

#: ecpg.xml:1589(programlisting)
#, no-wrap
msgid ""
"...\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* Put all values in the SELECT list into one structure. */\n"
"    EXEC SQL FETCH FROM cur1 INTO :compval;\n"
"\n"
"    printf(\"intval=%d, textval=%s\\n\", compval.intval, compval.textval.arr);\n"
"}\n"
"..."
msgstr ""
"...\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;\n"
"EXEC SQL OPEN cur1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    /* Выбрать все значения в списке SELECT в одну структуру. */\n"
"    EXEC SQL FETCH FROM cur1 INTO :compval;\n"
"\n"
"    printf(\"intval=%d, textval=%s\\n\", compval.intval, compval.textval.arr);\n"
"}\n"
"..."

#: ecpg.xml:1546(para)
msgid ""
"To enhance this example, the host variables to store values in the "
"<command>FETCH</command> command can be gathered into one structure. For "
"more details about the host variable in the structure form, see <xref "
"linkend=\"ecpg-variables-struct\"/>. To switch to the structure, the example "
"can be modified as below. The two host variables, <varname>intval</varname> "
"and <varname>textval</varname>, become members of the <structname>comp_t</"
"structname> structure, and the structure is specified on the <command>FETCH</"
"command> command. <placeholder-1/> Although a structure is used in the "
"<command>FETCH</command> command, the attribute names in the "
"<command>SELECT</command> clause are specified one by one. This can be "
"enhanced by using a <literal>*</literal> to ask for all attributes of the "
"composite type value. <placeholder-2/> This way, composite types can be "
"mapped into structures almost seamlessly, even though ECPG does not "
"understand the composite type itself."
msgstr ""
"В развитие этого примера, переменные среды, в которые помещаются результаты "
"команды <command>FETCH</command>, можно собрать в одну структуру. Подробнее "
"переменные среды в форме структуры описываются в <xref remap=\"6\" linkend="
"\"ecpg-variables-struct\"/>. Чтобы перейти к структуре, пример можно "
"изменить как показано ниже. Переменные среды, <varname>intval</varname> и "
"<varname>textval</varname>, становятся членами структуры <structname>comp_t</"
"structname>, и эта структура указывается в команде <command>FETCH</command>. "
"<placeholder-1/> Хотя в команде <command>FETCH</command> используется "
"структура, имена атрибутов в предложении <command>SELECT</command> задаются "
"по одному. Это можно дополнительно улучшить, написав <literal>*</literal>, "
"что будет обозначать все атрибуты значения составного типа. <placeholder-2/> "
"Таким образом составные типы можно сопоставить со структурами практически "
"прозрачно, хотя ECPG и не понимает составные типы."

#: ecpg.xml:1610(para)
msgid ""
"Finally, it is also possible to store composite type values in their "
"external string representation in host variables of type <type>char[]</type> "
"or <type>VARCHAR[]</type>. But that way, it is not easily possible to access "
"the fields of the value from the host program."
msgstr ""
"Наконец, также можно сохранить значения составного типа в их внешнем "
"строковом представлении в переменных среды типа <type>char[]</type> или "
"<type>VARCHAR[]</type>. Однако при таком подходе нет простой возможности "
"обращаться из программы к полям значения."

#: ecpg.xml:1620(title)
msgid "User-defined Base Types"
msgstr "Пользовательские базовые типы"

#: ecpg.xml:1622(para)
msgid ""
"New user-defined base types are not directly supported by ECPG. You can use "
"the external string representation and host variables of type <type>char[]</"
"type> or <type>VARCHAR[]</type>, and this solution is indeed appropriate and "
"sufficient for many types."
msgstr ""
"Определяемые пользователем базовые типы не поддерживаются ECPG напрямую. Для "
"них можно использовать внешнее строковое представление и переменные среды "
"типа <type>char[]</type> или <type>VARCHAR[]</type>, и это решение "
"действительно будет подходящим и достаточным для большинства типов."

#: ecpg.xml:1642(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    varchar a[64];\n"
"    varchar b[64];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');\n"
"\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;\n"
"    EXEC SQL OPEN cur1;\n"
"\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        EXEC SQL FETCH FROM cur1 INTO :a, :b;\n"
"        printf(\"a=%s, b=%s\\n\", a.arr, b.arr);\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    varchar a[64];\n"
"    varchar b[64];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');\n"
"\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;\n"
"    EXEC SQL OPEN cur1;\n"
"\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        EXEC SQL FETCH FROM cur1 INTO :a, :b;\n"
"        printf(\"a=%s, b=%s\\n\", a.arr, b.arr);\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;"

#: ecpg.xml:1629(para)
msgid ""
"Here is an example using the data type <type>complex</type> from the example "
"in <xref linkend=\"xtypes\"/>. The external string representation of that "
"type is <literal>(%lf,%lf)</literal>, which is defined in the functions "
"<function>complex_in()</function> and <function>complex_out()</function> "
"functions in <xref linkend=\"xtypes\"/>. The following example inserts the "
"complex type values <literal>(1,1)</literal> and <literal>(3,3)</literal> "
"into the columns <literal>a</literal> and <literal>b</literal>, and select "
"them from the table after that. <placeholder-1/> This example shows "
"following result: <screen>\n"
"a=(1,1), b=(3,3)\n"
"</screen>"
msgstr ""
"Следующий фрагмент кода демонстрирует использование типа данных "
"<type>complex</type> из примера в <xref remap=\"6\" linkend=\"xtypes\"/>. "
"Внешнее строковое представление этого типа имеет форму <literal>(%lf,%lf)</"
"literal> и определено в функциях <function>complex_in()</function> и "
"<function>complex_out()</function> в <xref remap=\"6\" linkend=\"xtypes\"/>. "
"Следующий пример вставляет значения комплексного типа <literal>(1,1)</"
"literal> и <literal>(3,3)</literal> в столбцы <literal>a</literal> и "
"<literal>b</literal>, а затем выбирает их из таблицы. <placeholder-1/> Этот "
"пример выводит следующий результат: <screen>\n"
"a=(1,1), b=(3,3)\n"
"</screen>"

#: ecpg.xml:1670(para)
msgid ""
"Another workaround is avoiding the direct use of the user-defined types in "
"ECPG and instead create a function or cast that converts between the user-"
"defined type and a primitive type that ECPG can handle. Note, however, that "
"type casts, especially implicit ones, should be introduced into the type "
"system very carefully."
msgstr ""
"Другое обходное решение состоит в том, чтобы избегать прямого использования "
"пользовательских типов в ECPG, а вместо этого создать функцию или "
"приведение, выполняющее преобразование между пользовательским типом и "
"примитивным типом, который может обработать ECPG. Заметьте однако, что "
"приведения типов, особенно неявные, нужно добавлять в систему типов очень "
"осторожно."

#: ecpg.xml:1680(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION create_complex(r double, i double) RETURNS complex\n"
"LANGUAGE SQL\n"
"IMMUTABLE\n"
"AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;"
msgstr ""
"CREATE FUNCTION create_complex(r double, i double) RETURNS complex\n"
"LANGUAGE SQL\n"
"IMMUTABLE\n"
"AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;"

#: ecpg.xml:1687(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"double a, b, c, d;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"a = 1;\n"
"b = 2;\n"
"c = 3;\n"
"d = 4;\n"
"\n"
"EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"double a, b, c, d;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"a = 1;\n"
"b = 2;\n"
"c = 3;\n"
"d = 4;\n"
"\n"
"EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));"

#: ecpg.xml:1700(programlisting)
#, no-wrap
msgid "EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');"
msgstr "EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');"

#: ecpg.xml:1678(para)
msgid ""
"For example, <placeholder-1/> After this definition, the following "
"<placeholder-2/> has the same effect as <placeholder-3/>"
msgstr ""
"Например: <placeholder-1/> После такого определения следующий код "
"<placeholder-2/> будет работать так же, как <placeholder-3/>"

#: ecpg.xml:1708(title)
msgid "Indicators"
msgstr "Индикаторы"

#: ecpg.xml:1721(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"VARCHAR val;\n"
"int val_ind;\n"
"EXEC SQL END DECLARE SECTION:\n"
"\n"
" ...\n"
"\n"
"EXEC SQL SELECT b INTO :val :val_ind FROM test1;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"VARCHAR val;\n"
"int val_ind;\n"
"EXEC SQL END DECLARE SECTION:\n"
"\n"
" ...\n"
"\n"
"EXEC SQL SELECT b INTO :val :val_ind FROM test1;"

#: ecpg.xml:1710(para)
msgid ""
"The examples above do not handle null values. In fact, the retrieval "
"examples will raise an error if they fetch a null value from the database. "
"To be able to pass null values to the database or retrieve null values from "
"the database, you need to append a second host variable specification to "
"each host variable that contains data. This second host variable is called "
"the <firstterm>indicator</firstterm> and contains a flag that tells whether "
"the datum is null, in which case the value of the real host variable is "
"ignored. Here is an example that handles the retrieval of null values "
"correctly: <placeholder-1/> The indicator variable <varname>val_ind</"
"varname> will be zero if the value was not null, and it will be negative if "
"the value was null."
msgstr ""
"Приведённые выше примеры никак не обрабатывали значения NULL. На самом деле, "
"в примерах с извлечением данных возникнет ошибка, если они выберут из базы "
"данных значение NULL. Чтобы можно было передавать значения NULL в базу "
"данных или получать их из базы данных, вы должны добавить объявление второй "
"переменной среды для каждой переменной среды, содержащей данные. Эта вторая "
"переменная среды называется <firstterm>индикатором</firstterm> и содержит "
"флаг, показывающий, что в данных передаётся NULL, и при этом значение "
"основной переменной среды игнорируется. Следующий пример демонстрирует "
"правильную обработку значений NULL: <placeholder-1/> Переменная индикатора "
"<varname>val_ind</varname> будет равна нулю, если значение не NULL, или "
"отрицательному числу, если NULL."

#: ecpg.xml:1736(para)
msgid ""
"The indicator has another function: if the indicator value is positive, it "
"means that the value is not null, but it was truncated when it was stored in "
"the host variable."
msgstr ""
"Индикатор выполняет ещё одну функцию: если он содержит положительное число, "
"это означает, что значение не NULL, но оно было обрезано, когда сохранялось "
"в переменной среды."

#: ecpg.xml:1742(para)
msgid ""
"If the argument <literal>-r no_indicator</literal> is passed to the "
"preprocessor <command>ecpg</command>, it works in <quote>no-indicator</"
"quote> mode. In no-indicator mode, if no indicator variable is specified, "
"null values are signaled (on input and output) for character string types as "
"empty string and for integer types as the lowest possible value for type "
"(for example, <symbol>INT_MIN</symbol> for <type>int</type>)."
msgstr ""
"Если препроцессору <command>ecpg</command> передаётся аргумент <literal>-r "
"no_indicator</literal>, он работает в режиме <quote>без индикатора</quote>. "
"В этом режиме, если переменная индикатора не определена, значения NULL "
"обозначаются (при вводе и выводе) для символьных строк пустой строкой, а для "
"целочисленных типов наименьшим возможным значением этого типа (например, "
"<symbol>INT_MIN</symbol> для <type>int</type>)."

#: ecpg.xml:1755(title)
msgid "Dynamic SQL"
msgstr "Динамический SQL"

#: ecpg.xml:1757(para)
msgid ""
"In many cases, the particular SQL statements that an application has to "
"execute are known at the time the application is written. In some cases, "
"however, the SQL statements are composed at run time or provided by an "
"external source. In these cases you cannot embed the SQL statements directly "
"into the C source code, but there is a facility that allows you to call "
"arbitrary SQL statements that you provide in a string variable."
msgstr ""
"Во многих случаях конкретные операторы SQL, которые должно выполнять "
"приложение, известны в момент написания приложения. В некоторых случаях, "
"однако, операторы SQL формируются во время выполнения или поступают из "
"внешнего источника. В этих случаях операторы SQL нельзя внедрить "
"непосредственно в исходный код C, но есть средство, позволяющее вызывать "
"произвольные операторы SQL, передаваемые в строковой переменной."

#: ecpg.xml:1768(title)
msgid "Executing Statements without a Result Set"
msgstr "Выполнение операторов без набора результатов"

#: ecpg.xml:1773(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"const char *stmt = \"CREATE TABLE test1 (...);\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL EXECUTE IMMEDIATE :stmt;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"const char *stmt = \"CREATE TABLE test1 (...);\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL EXECUTE IMMEDIATE :stmt;"

#: ecpg.xml:1770(para)
msgid ""
"The simplest way to execute an arbitrary SQL statement is to use the command "
"<command>EXECUTE IMMEDIATE</command>. For example: <placeholder-1/> "
"<command>EXECUTE IMMEDIATE</command> can be used for SQL statements that do "
"not return a result set (e.g., DDL, <command>INSERT</command>, "
"<command>UPDATE</command>, <command>DELETE</command>). You cannot execute "
"statements that retrieve data (e.g., <command>SELECT</command>) this way. "
"The next section describes how to do that."
msgstr ""
"Самый простой способ выполнить произвольный оператор SQL — применить команду "
"<command>EXECUTE IMMEDIATE</command>. Например: <placeholder-1/> "
"<command>EXECUTE IMMEDIATE</command> можно применять для SQL-операторов, "
"которые не возвращают набор результатов (например, DDL, <command>INSERT</"
"command>, <command>UPDATE</command>, <command>DELETE</command>). Выполнять "
"операторы, которые получают данные, (например, <command>SELECT</command>) "
"таким образом нельзя. Как выполнять такие операторы, рассказывается в "
"следующем разделе."

#: ecpg.xml:1790(title)
msgid "Executing a Statement with Input Parameters"
msgstr "Выполнение оператора с входными параметрами"

#: ecpg.xml:1800(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"const char *stmt = \"INSERT INTO test1 VALUES(?, ?);\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL PREPARE mystmt FROM :stmt;\n"
" ...\n"
"EXEC SQL EXECUTE mystmt USING 42, 'foobar';"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"const char *stmt = \"INSERT INTO test1 VALUES(?, ?);\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL PREPARE mystmt FROM :stmt;\n"
" ...\n"
"EXEC SQL EXECUTE mystmt USING 42, 'foobar';"

#: ecpg.xml:1792(para)
msgid ""
"A more powerful way to execute arbitrary SQL statements is to prepare them "
"once and execute the prepared statement as often as you like. It is also "
"possible to prepare a generalized version of a statement and then execute "
"specific versions of it by substituting parameters. When preparing the "
"statement, write question marks where you want to substitute parameters "
"later. For example: <placeholder-1/>"
msgstr ""
"Более эффективно выполнять произвольный оператор SQL можно, подготовив его "
"один раз, а затем запуская подготовленный оператор столько, сколько нужно. "
"Также можно подготовить обобщённую версию оператора, а затем выполнять "
"специализированные его версии, подставляя в него параметры. Подготавливая "
"оператор, поставьте знаки вопроса там, где позже хотите подставить "
"параметры. Например: <placeholder-1/>"

#: ecpg.xml:1821(title)
msgid "Executing a Statement with a Result Set"
msgstr "Выполнение оператора с набором результатов"

#: ecpg.xml:1823(para)
msgid ""
"To execute an SQL statement with a single result row, <command>EXECUTE</"
"command> can be used. To save the result, add an <literal>INTO</literal> "
"clause. <placeholder-1/> An <command>EXECUTE</command> command can have an "
"<literal>INTO</literal> clause, a <literal>USING</literal> clause, both, or "
"neither."
msgstr ""
"Для выполнения оператора SQL с одной строкой результата можно применить "
"команду <command>EXECUTE</command>. Чтобы сохранить результат, добавьте "
"предложение <literal>INTO</literal>. <placeholder-1/> Команда "
"<command>EXECUTE</command> может содержать предложение <literal>INTO</"
"literal> и/или предложение <literal>USING</literal>, либо не содержать ни "
"того, ни другого."

#: ecpg.xml:1849(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"char dbaname[128];\n"
"char datname[128];\n"
"char *stmt = \"SELECT u.usename as dbaname, d.datname \"\n"
"             \"  FROM pg_database d, pg_user u \"\n"
"             \"  WHERE d.datdba = u.usesysid\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"\n"
"EXEC SQL PREPARE stmt1 FROM :stmt;\n"
"\n"
"EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;\n"
"EXEC SQL OPEN cursor1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;\n"
"    printf(\"dbaname=%s, datname=%s\\n\", dbaname, datname);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cursor1;\n"
"\n"
"EXEC SQL COMMIT;\n"
"EXEC SQL DISCONNECT ALL;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"char dbaname[128];\n"
"char datname[128];\n"
"char *stmt = \"SELECT u.usename as dbaname, d.datname \"\n"
"             \"  FROM pg_database d, pg_user u \"\n"
"             \"  WHERE d.datdba = u.usesysid\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"\n"
"EXEC SQL PREPARE stmt1 FROM :stmt;\n"
"\n"
"EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;\n"
"EXEC SQL OPEN cursor1;\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"while (1)\n"
"{\n"
"    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;\n"
"    printf(\"dbaname=%s, datname=%s\\n\", dbaname, datname);\n"
"}\n"
"\n"
"EXEC SQL CLOSE cursor1;\n"
"\n"
"EXEC SQL COMMIT;\n"
"EXEC SQL DISCONNECT ALL;"

#: ecpg.xml:1844(para)
msgid ""
"If a query is expected to return more than one result row, a cursor should "
"be used, as in the following example. (See <xref linkend=\"ecpg-cursors\"/> "
"for more details about the cursor.) <placeholder-1/>"
msgstr ""
"Если ожидается, что запрос вернёт более одной строки результата, следует "
"применять курсор, как показано в следующем примере. (Подробно курсоры "
"описываются в <xref remap=\"6\" linkend=\"ecpg-cursors\"/>.) <placeholder-1/>"

#: ecpg.xml:1883(title)
msgid "pgtypes Library"
msgstr "Библиотека pgtypes"

#: ecpg.xml:1885(para)
msgid ""
"The pgtypes library maps <productname>PostgreSQL</productname> database "
"types to C equivalents that can be used in C programs. It also offers "
"functions to do basic calculations with those types within C, i.e., without "
"the help of the <productname>PostgreSQL</productname> server. See the "
"following example: <placeholder-1/>"
msgstr ""
"Библиотека pgtypes сопоставляет типы базы данных <productname>PostgreSQL</"
"productname> с их эквивалентами в C, которые можно использовать в программах "
"на C. Она также предлагает функции для выполнения простых вычислений с этими "
"типами в C, то есть без помощи сервера <productname>PostgreSQL</"
"productname>. Рассмотрите следующий пример: <placeholder-1/>"

#: ecpg.xml:1910(title)
msgid "The numeric Type"
msgstr "Тип numeric"

#: ecpg.xml:1911(para)
msgid ""
"The numeric type offers to do calculations with arbitrary precision. See "
"<xref linkend=\"datatype-numeric\"/> for the equivalent type in the "
"<productname>PostgreSQL</productname> server. Because of the arbitrary "
"precision this variable needs to be able to expand and shrink dynamically. "
"That's why you can only create numeric variables on the heap, by means of "
"the <function>PGTYPESnumeric_new</function> and "
"<function>PGTYPESnumeric_free</function> functions. The decimal type, which "
"is similar but limited in precision, can be created on the stack as well as "
"on the heap."
msgstr ""
"Тип numeric позволяет производить вычисления с фиксированной точностью. "
"Эквивалентный ему тип на сервере <productname>PostgreSQL</productname> "
"описан в <xref remap=\"6\" linkend=\"datatype-numeric\"/>. Ввиду того, что "
"переменная имеет фиксированную точность, она должна расширяться и сжиматься "
"динамически. Поэтому такие переменные можно создавать только в области кучи, "
"используя функции <function>PGTYPESnumeric_new</function> и "
"<function>PGTYPESnumeric_free</function>. Тип decimal подобен numeric, но "
"имеет ограниченную точность, и поэтому может размещаться и в области кучи, и "
"в стеке."

#: ecpg.xml:1925(function)
msgid "PGTYPESnumeric_new"
msgstr "PGTYPESnumeric_new"

#: ecpg.xml:1927(para)
msgid ""
"Request a pointer to a newly allocated numeric variable. <synopsis>\n"
"numeric *PGTYPESnumeric_new(void);\n"
"</synopsis>"
msgstr ""
"Запрашивает указатель на новую переменную, размещённую в памяти. <synopsis>\n"
"numeric *PGTYPESnumeric_new(void);\n"
"</synopsis>"

#: ecpg.xml:1937(function)
msgid "PGTYPESnumeric_free"
msgstr "PGTYPESnumeric_free"

#: ecpg.xml:1939(para)
msgid ""
"Free a numeric type, release all of its memory. <synopsis>\n"
"void PGTYPESnumeric_free(numeric *var);\n"
"</synopsis>"
msgstr ""
"Освобождает переменную типа numeric, высвобождая всю её память. <synopsis>\n"
"void PGTYPESnumeric_free(numeric *var);\n"
"</synopsis>"

#: ecpg.xml:1949(function)
msgid "PGTYPESnumeric_from_asc"
msgstr "PGTYPESnumeric_from_asc"

#: ecpg.xml:1951(para)
msgid ""
"Parse a numeric type from its string notation. <synopsis>\n"
"numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);\n"
"</synopsis> Valid formats are for example: <literal>-2</literal>, "
"<literal>.794</literal>, <literal>+3.44</literal>, <literal>592.49E07</"
"literal> or <literal>-32.84e-4</literal>. If the value could be parsed "
"successfully, a valid pointer is returned, else the NULL pointer. At the "
"moment ECPG always parses the complete string and so it currently does not "
"support to store the address of the first invalid character in "
"<literal>*endptr</literal>. You can safely set <literal>endptr</literal> to "
"NULL."
msgstr ""
"Разбирает числовой тип из строковой записи. <synopsis>\n"
"numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);\n"
"</synopsis> Допускаются в частности следующие форматы: <literal>-2</"
"literal>, <literal>.794</literal>, <literal>+3.44</literal>, "
"<literal>592.49E07</literal> и <literal>-32.84e-4</literal>. Если значение "
"удаётся разобрать успешно, возвращается действительный указатель, в "
"противном случае указатель NULL. На данный момент ECPG всегда разбирает "
"строку до конца, так что эта функция не может вернуть адрес первого "
"недопустимого символа в <literal>*endptr</literal>. Поэтому в "
"<literal>endptr</literal> свободно можно передать NULL."

#: ecpg.xml:1972(function)
msgid "PGTYPESnumeric_to_asc"
msgstr "PGTYPESnumeric_to_asc"

#: ecpg.xml:1974(para)
msgid ""
"Returns a pointer to a string allocated by <function>malloc</function> that "
"contains the string representation of the numeric type <literal>num</"
"literal>. <synopsis>\n"
"char *PGTYPESnumeric_to_asc(numeric *num, int dscale);\n"
"</synopsis> The numeric value will be printed with <literal>dscale</literal> "
"decimal digits, with rounding applied if necessary."
msgstr ""
"Возвращает указатель на строку, выделенную функцией <function>malloc</"
"function> и содержащую строковое представление значения <literal>num</"
"literal> числового типа. <synopsis>\n"
"char *PGTYPESnumeric_to_asc(numeric *num, int dscale);\n"
"</synopsis> Числовое значение будет выводиться с заданным в <literal>dscale</"
"literal> количеством цифр после запятой, округлённое при необходимости."

#: ecpg.xml:1987(function)
msgid "PGTYPESnumeric_add"
msgstr "PGTYPESnumeric_add"

#: ecpg.xml:1989(para)
msgid ""
"Add two numeric variables into a third one. <synopsis>\n"
"int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> The function adds the variables <literal>var1</literal> and "
"<literal>var2</literal> into the result variable <literal>result</literal>. "
"The function returns 0 on success and -1 in case of error."
msgstr ""
"Суммирует две числовые переменные и возвращает результат в третьей. "
"<synopsis>\n"
"int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> Эта функция суммирует переменные <literal>var1</literal> и "
"<literal>var2</literal> в результирующую переменную <literal>result</"
"literal>. Функция возвращает 0 в случае успеха и -1 при ошибке."

#: ecpg.xml:2003(function)
msgid "PGTYPESnumeric_sub"
msgstr "PGTYPESnumeric_sub"

#: ecpg.xml:2005(para)
msgid ""
"Subtract two numeric variables and return the result in a third one. "
"<synopsis>\n"
"int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> The function subtracts the variable <literal>var2</literal> from "
"the variable <literal>var1</literal>. The result of the operation is stored "
"in the variable <literal>result</literal>. The function returns 0 on success "
"and -1 in case of error."
msgstr ""
"Вычисляет разность двух числовых переменных и возвращает результат в "
"третьей. <synopsis>\n"
"int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> Эта функция вычитает переменную <literal>var2</literal> из "
"<literal>var1</literal>. Результат операции помещается в переменную "
"<literal>result</literal>. Функция возвращает 0 в случае успеха и -1 при "
"ошибке."

#: ecpg.xml:2019(function)
msgid "PGTYPESnumeric_mul"
msgstr "PGTYPESnumeric_mul"

#: ecpg.xml:2021(para)
msgid ""
"Multiply two numeric variables and return the result in a third one. "
"<synopsis>\n"
"int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> The function multiplies the variables <literal>var1</literal> "
"and <literal>var2</literal>. The result of the operation is stored in the "
"variable <literal>result</literal>. The function returns 0 on success and -1 "
"in case of error."
msgstr ""
"Перемножает две числовые переменные и возвращает результат в третьей. "
"<synopsis>\n"
"int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> Эта функция перемножает переменные <literal>var1</literal> и "
"<literal>var2</literal>. Результат операции сохраняется в переменной "
"<literal>result</literal>. Функция возвращает 0 в случае успеха и -1 при "
"ошибке."

#: ecpg.xml:2035(function)
msgid "PGTYPESnumeric_div"
msgstr "PGTYPESnumeric_div"

#: ecpg.xml:2037(para)
msgid ""
"Divide two numeric variables and return the result in a third one. "
"<synopsis>\n"
"int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> The function divides the variables <literal>var1</literal> by "
"<literal>var2</literal>. The result of the operation is stored in the "
"variable <literal>result</literal>. The function returns 0 on success and -1 "
"in case of error."
msgstr ""
"Вычисляет частное двух числовых переменных и возвращает результат в третьей. "
"<synopsis>\n"
"int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);\n"
"</synopsis> Эта функция делит переменную <literal>var1</literal> на "
"<literal>var2</literal>. Результат операции сохраняется в переменной "
"<literal>result</literal>. Функция возвращает 0 в случае успеха и -1 при "
"ошибке."

#: ecpg.xml:2051(function)
msgid "PGTYPESnumeric_cmp"
msgstr "PGTYPESnumeric_cmp"

#: ecpg.xml:2063(para)
msgid "1, if <literal>var1</literal> is bigger than <literal>var2</literal>"
msgstr "1, если <literal>var1</literal> больше <literal>var2</literal>"

#: ecpg.xml:2068(para)
msgid "-1, if <literal>var1</literal> is smaller than <literal>var2</literal>"
msgstr "-1, если <literal>var1</literal> меньше <literal>var2</literal>"

#: ecpg.xml:2073(para)
msgid "0, if <literal>var1</literal> and <literal>var2</literal> are equal"
msgstr "0, если <literal>var1</literal> и <literal>var2</literal> равны"

#: ecpg.xml:2053(para)
msgid ""
"Compare two numeric variables. <synopsis>\n"
"int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)\n"
"</synopsis> This function compares two numeric variables. In case of error, "
"<literal>INT_MAX</literal> is returned. On success, the function returns one "
"of three possible results: <placeholder-1/>"
msgstr ""
"Сравнивает две числовые переменные. <synopsis>\n"
"int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)\n"
"</synopsis> Эта функция производит сравнение двух числовых переменных. При "
"ошибке возвращается <literal>INT_MAX</literal>. В случае успеха функция "
"возвращает одно из трёх возможных значений: <placeholder-1/>"

#: ecpg.xml:2083(function)
msgid "PGTYPESnumeric_from_int"
msgstr "PGTYPESnumeric_from_int"

#: ecpg.xml:2085(para)
msgid ""
"Convert an int variable to a numeric variable. <synopsis>\n"
"int PGTYPESnumeric_from_int(signed int int_val, numeric *var);\n"
"</synopsis> This function accepts a variable of type signed int and stores "
"it in the numeric variable <literal>var</literal>. Upon success, 0 is "
"returned and -1 in case of a failure."
msgstr ""
"Преобразует переменную int в переменную numeric. <synopsis>\n"
"int PGTYPESnumeric_from_int(signed int int_val, numeric *var);\n"
"</synopsis> Эта функция принимает целочисленную переменную со знаком типа "
"signed int и сохраняет её значение в переменной <literal>var</literal> типа "
"numeric. Функция возвращает 0 в случае успеха и -1 при ошибке."

#: ecpg.xml:2098(function)
msgid "PGTYPESnumeric_from_long"
msgstr "PGTYPESnumeric_from_long"

#: ecpg.xml:2100(para)
msgid ""
"Convert a long int variable to a numeric variable. <synopsis>\n"
"int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);\n"
"</synopsis> This function accepts a variable of type signed long int and "
"stores it in the numeric variable <literal>var</literal>. Upon success, 0 is "
"returned and -1 in case of a failure."
msgstr ""
"Преобразует переменную long int в переменную numeric. <synopsis>\n"
"int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);\n"
"</synopsis> Эта функция принимает целочисленную переменную со знаком типа "
"signed long int и сохраняет её значение в переменной <literal>var</literal> "
"типа numeric. Функция возвращает 0 в случае успеха и -1 при ошибке."

#: ecpg.xml:2113(function)
msgid "PGTYPESnumeric_copy"
msgstr "PGTYPESnumeric_copy"

#: ecpg.xml:2115(para)
msgid ""
"Copy over one numeric variable into another one. <synopsis>\n"
"int PGTYPESnumeric_copy(numeric *src, numeric *dst);\n"
"</synopsis> This function copies over the value of the variable that "
"<literal>src</literal> points to into the variable that <literal>dst</"
"literal> points to. It returns 0 on success and -1 if an error occurs."
msgstr ""
"Копирует одну числовую переменную в другую. <synopsis>\n"
"int PGTYPESnumeric_copy(numeric *src, numeric *dst);\n"
"</synopsis> Эта функция копирует значение переменной, на которую указывает "
"<literal>src</literal>, в переменную, на которую указывает <literal>dst</"
"literal>. Она возвращает 0 в случае успеха и -1 при ошибке."

#: ecpg.xml:2128(function)
msgid "PGTYPESnumeric_from_double"
msgstr "PGTYPESnumeric_from_double"

#: ecpg.xml:2130(para)
msgid ""
"Convert a variable of type double to a numeric. <synopsis>\n"
"int  PGTYPESnumeric_from_double(double d, numeric *dst);\n"
"</synopsis> This function accepts a variable of type double and stores the "
"result in the variable that <literal>dst</literal> points to. It returns 0 "
"on success and -1 if an error occurs."
msgstr ""
"Преобразует переменную типа double в переменную numeric. <synopsis>\n"
"int  PGTYPESnumeric_from_double(double d, numeric *dst);\n"
"</synopsis> Эта функция принимает переменную типа double и сохраняет "
"преобразованное значение в переменной, на которую указывает <literal>dst</"
"literal>. Она возвращает 0 в случае успеха и -1 при ошибке."

#: ecpg.xml:2143(function)
msgid "PGTYPESnumeric_to_double"
msgstr "PGTYPESnumeric_to_double"

#: ecpg.xml:2145(para)
msgid ""
"Convert a variable of type numeric to double. <synopsis>\n"
"int PGTYPESnumeric_to_double(numeric *nv, double *dp)\n"
"</synopsis> The function converts the numeric value from the variable that "
"<literal>nv</literal> points to into the double variable that <literal>dp</"
"literal> points to. It returns 0 on success and -1 if an error occurs, "
"including overflow. On overflow, the global variable <literal>errno</"
"literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally."
msgstr ""
"Преобразует переменную типа numeric в переменную double. <synopsis>\n"
"int PGTYPESnumeric_to_double(numeric *nv, double *dp)\n"
"</synopsis> Эта функция преобразует значение типа numeric переменной, на "
"которую указывает <literal>nv</literal>, в переменную типа double, на "
"которую указывает <literal>dp</literal>. Она возвращает 0 в случае успеха и "
"-1 при ошибке, в том числе при переполнении. Если происходит переполнение, в "
"глобальной переменной <literal>errno</literal> дополнительно устанавливается "
"значение <literal>PGTYPES_NUM_OVERFLOW</literal>."

#: ecpg.xml:2160(function)
msgid "PGTYPESnumeric_to_int"
msgstr "PGTYPESnumeric_to_int"

#: ecpg.xml:2162(para)
msgid ""
"Convert a variable of type numeric to int. <synopsis>\n"
"int PGTYPESnumeric_to_int(numeric *nv, int *ip);\n"
"</synopsis> The function converts the numeric value from the variable that "
"<literal>nv</literal> points to into the integer variable that <literal>ip</"
"literal> points to. It returns 0 on success and -1 if an error occurs, "
"including overflow. On overflow, the global variable <literal>errno</"
"literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally."
msgstr ""
"Преобразует переменную типа numeric в переменную int. <synopsis>\n"
"int PGTYPESnumeric_to_int(numeric *nv, int *ip);\n"
"</synopsis> Эта функция преобразует значение типа numeric переменной, на "
"которую указывает <literal>nv</literal>, в целочисленную переменную, на "
"которую указывает <literal>ip</literal>. Она возвращает 0 в случае успеха и "
"-1 при ошибке, в том числе при переполнении. Если происходит переполнение, в "
"глобальной переменной <literal>errno</literal> дополнительно устанавливается "
"значение <literal>PGTYPES_NUM_OVERFLOW</literal>."

#: ecpg.xml:2177(function)
msgid "PGTYPESnumeric_to_long"
msgstr "PGTYPESnumeric_to_long"

#: ecpg.xml:2179(para)
msgid ""
"Convert a variable of type numeric to long. <synopsis>\n"
"int PGTYPESnumeric_to_long(numeric *nv, long *lp);\n"
"</synopsis> The function converts the numeric value from the variable that "
"<literal>nv</literal> points to into the long integer variable that "
"<literal>lp</literal> points to. It returns 0 on success and -1 if an error "
"occurs, including overflow. On overflow, the global variable <literal>errno</"
"literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally."
msgstr ""
"Преобразует переменную типа numeric в переменную long. <synopsis>\n"
"int PGTYPESnumeric_to_long(numeric *nv, long *lp);\n"
"</synopsis> Эта функция преобразует значение типа numeric переменной, на "
"которую указывает <literal>nv</literal>, в целочисленную переменную типа "
"long, на которую указывает <literal>lp</literal>. Она возвращает 0 в случае "
"успеха и -1 при ошибке, в том числе при переполнении. Если происходит "
"переполнение, в глобальной переменной <literal>errno</literal> дополнительно "
"устанавливается значение <literal>PGTYPES_NUM_OVERFLOW</literal>."

#: ecpg.xml:2195(function)
msgid "PGTYPESnumeric_to_decimal"
msgstr "PGTYPESnumeric_to_decimal"

#: ecpg.xml:2197(para)
msgid ""
"Convert a variable of type numeric to decimal. <synopsis>\n"
"int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);\n"
"</synopsis> The function converts the numeric value from the variable that "
"<literal>src</literal> points to into the decimal variable that "
"<literal>dst</literal> points to. It returns 0 on success and -1 if an error "
"occurs, including overflow. On overflow, the global variable <literal>errno</"
"literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally."
msgstr ""
"Преобразует переменную типа numeric в переменную decimal. <synopsis>\n"
"int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);\n"
"</synopsis> Эта функция преобразует значение типа numeric переменной, на "
"которую указывает <literal>src</literal>, в переменную типа decimal, на "
"которую указывает <literal>dst</literal>. Она возвращает 0 в случае успеха и "
"-1 при ошибке, в том числе при переполнении. Если происходит переполнение, в "
"глобальной переменной <literal>errno</literal> дополнительно устанавливается "
"значение <literal>PGTYPES_NUM_OVERFLOW</literal>."

#: ecpg.xml:2213(function)
msgid "PGTYPESnumeric_from_decimal"
msgstr "PGTYPESnumeric_from_decimal"

#: ecpg.xml:2215(para)
msgid ""
"Convert a variable of type decimal to numeric. <synopsis>\n"
"int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);\n"
"</synopsis> The function converts the decimal value from the variable that "
"<literal>src</literal> points to into the numeric variable that "
"<literal>dst</literal> points to. It returns 0 on success and -1 if an error "
"occurs. Since the decimal type is implemented as a limited version of the "
"numeric type, overflow cannot occur with this conversion."
msgstr ""
"Преобразует переменную типа decimal в переменную numeric. <synopsis>\n"
"int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);\n"
"</synopsis> Эта функция преобразует значение типа decimal переменной, на "
"которую указывает <literal>src</literal>, в переменную типа numeric, на "
"которую указывает <literal>dst</literal>. Она возвращает 0 в случае успеха и "
"-1 при ошибке. Так как тип decimal реализован как ограниченная версия типа "
"numeric, при таком преобразовании переполнение невозможно."

#: ecpg.xml:1921(para)
msgid ""
"The following functions can be used to work with the numeric type: "
"<placeholder-1/>"
msgstr ""
"Для работы с типом numeric можно использовать следующие функции: "
"<placeholder-1/>"

#: ecpg.xml:2233(title)
msgid "The date Type"
msgstr "Тип date"

#: ecpg.xml:2234(para)
msgid ""
"The date type in C enables your programs to deal with data of the SQL type "
"date. See <xref linkend=\"datatype-datetime\"/> for the equivalent type in "
"the <productname>PostgreSQL</productname> server."
msgstr ""
"Тип date, реализованный в C, позволяет программам работать с данными типа "
"date в SQL. Соответствующий тип сервера <productname>PostgreSQL</"
"productname> описан в <xref remap=\"6\" linkend=\"datatype-datetime\"/>."

#: ecpg.xml:2243(function)
msgid "PGTYPESdate_from_timestamp"
msgstr "PGTYPESdate_from_timestamp"

#: ecpg.xml:2245(para)
msgid ""
"Extract the date part from a timestamp. <synopsis>\n"
"date PGTYPESdate_from_timestamp(timestamp dt);\n"
"</synopsis> The function receives a timestamp as its only argument and "
"returns the extracted date part from this timestamp."
msgstr ""
"Извлекает часть даты из значения типа timestamp. <synopsis>\n"
"date PGTYPESdate_from_timestamp(timestamp dt);\n"
"</synopsis> Эта функция получает в единственном аргументе значение времени "
"типа timestamp и возвращает извлечённую из него дату."

#: ecpg.xml:2257(function)
msgid "PGTYPESdate_from_asc"
msgstr "PGTYPESdate_from_asc"

#: ecpg.xml:2259(para)
msgid ""
"Parse a date from its textual representation. <synopsis>\n"
"date PGTYPESdate_from_asc(char *str, char **endptr);\n"
"</synopsis> The function receives a C char* string <literal>str</literal> "
"and a pointer to a C char* string <literal>endptr</literal>. At the moment "
"ECPG always parses the complete string and so it currently does not support "
"to store the address of the first invalid character in <literal>*endptr</"
"literal>. You can safely set <literal>endptr</literal> to NULL."
msgstr ""
"Разбирает дату из её текстового представления. <synopsis>\n"
"date PGTYPESdate_from_asc(char *str, char **endptr);\n"
"</synopsis> Эта функция получает строку C char* <literal>str</literal> и "
"указатель на строку C char* <literal>endptr</literal>. На данный момент ECPG "
"всегда разбирает строку до конца, так что эта функция не может вернуть адрес "
"первого недопустимого символа в <literal>*endptr</literal>. Поэтому в "
"<literal>endptr</literal> свободно можно передать NULL."

#: ecpg.xml:2270(para)
msgid ""
"Note that the function always assumes MDY-formatted dates and there is "
"currently no variable to change that within ECPG."
msgstr ""
"Заметьте, что эта функция всегда подразумевает формат дат MDY (месяц-день-"
"год) и никакой переменной для изменения этого формата в ECPG нет."

#: ecpg.xml:2274(para)
msgid ""
"<xref linkend=\"ecpg-pgtypesdate-from-asc-table\"/> shows the allowed input "
"formats."
msgstr ""
"Все допустимые форматы ввода перечислены в <xref remap=\"6\" linkend=\"ecpg-"
"pgtypesdate-from-asc-table\"/>."

#: ecpg.xml:2278(title)
msgid "Valid Input Formats for <function>PGTYPESdate_from_asc</function>"
msgstr "Допустимые форматы ввода для <function>PGTYPESdate_from_asc</function>"

#: ecpg.xml:2282(entry) ecpg.xml:2756(entry)
msgid "Input"
msgstr "Ввод"

#: ecpg.xml:2283(entry) ecpg.xml:2540(entry) ecpg.xml:2631(entry)
#: ecpg.xml:2757(entry)
msgid "Result"
msgstr "Результат"

#: ecpg.xml:2288(literal) ecpg.xml:2289(literal) ecpg.xml:2293(literal)
#: ecpg.xml:2297(literal) ecpg.xml:2309(literal) ecpg.xml:2313(literal)
#: ecpg.xml:2317(literal) ecpg.xml:2321(literal) ecpg.xml:2325(literal)
#: ecpg.xml:2333(literal)
msgid "January 8, 1999"
msgstr "January 8, 1999"

#: ecpg.xml:2292(literal)
msgid "1999-01-08"
msgstr "1999-01-08"

#: ecpg.xml:2296(literal)
msgid "1/8/1999"
msgstr "1/8/1999"

#: ecpg.xml:2300(literal)
msgid "1/18/1999"
msgstr "1/18/1999"

#: ecpg.xml:2301(literal)
msgid "January 18, 1999"
msgstr "January 18, 1999"

#: ecpg.xml:2304(literal)
msgid "01/02/03"
msgstr "01/02/03"

#: ecpg.xml:2305(literal)
msgid "February 1, 2003"
msgstr "February 1, 2003"

#: ecpg.xml:2308(literal)
msgid "1999-Jan-08"
msgstr "1999-Jan-08"

#: ecpg.xml:2312(literal)
msgid "Jan-08-1999"
msgstr "Jan-08-1999"

#: ecpg.xml:2316(literal)
msgid "08-Jan-1999"
msgstr "08-Jan-1999"

#: ecpg.xml:2320(literal)
msgid "99-Jan-08"
msgstr "99-Jan-08"

#: ecpg.xml:2324(literal)
msgid "08-Jan-99"
msgstr "08-Jan-99"

#: ecpg.xml:2328(literal)
msgid "08-Jan-06"
msgstr "08-Jan-06"

#: ecpg.xml:2329(literal)
msgid "January 8, 2006"
msgstr "January 8, 2006"

#: ecpg.xml:2332(literal)
msgid "Jan-08-99"
msgstr "Jan-08-99"

#: ecpg.xml:2336(literal)
msgid "19990108"
msgstr "19990108"

#: ecpg.xml:2337(literal) ecpg.xml:2341(literal)
msgid "ISO 8601; January 8, 1999"
msgstr "ISO 8601; January 8, 1999"

#: ecpg.xml:2340(literal)
msgid "990108"
msgstr "990108"

#: ecpg.xml:2344(literal)
msgid "1999.008"
msgstr "1999.008"

# skip-rule: modified-nontranslatable
#: ecpg.xml:2345(literal)
msgid "year and day of year"
msgstr "год и день года"

#: ecpg.xml:2348(literal)
msgid "J2451187"
msgstr "J2451187"

# skip-rule: modified-nontranslatable
#: ecpg.xml:2349(literal)
msgid "Julian day"
msgstr "День по юлианскому календарю"

#: ecpg.xml:2352(literal)
msgid "January 8, 99 BC"
msgstr "January 8, 99 BC"

# skip-rule: modified-nontranslatable
#: ecpg.xml:2353(literal)
msgid "year 99 before the Common Era"
msgstr "99 год до нашей эры"

#: ecpg.xml:2362(function)
msgid "PGTYPESdate_to_asc"
msgstr "PGTYPESdate_to_asc"

#: ecpg.xml:2364(para)
msgid ""
"Return the textual representation of a date variable. <synopsis>\n"
"char *PGTYPESdate_to_asc(date dDate);\n"
"</synopsis> The function receives the date <literal>dDate</literal> as its "
"only parameter. It will output the date in the form <literal>1999-01-18</"
"literal>, i.e., in the <literal>YYYY-MM-DD</literal> format."
msgstr ""
"Возвращает текстовое представление переменной типа date. <synopsis>\n"
"char *PGTYPESdate_to_asc(date dDate);\n"
"</synopsis> Эта функция получает в качестве единственного параметра дату "
"<literal>dDate</literal> и выводит её в виде <literal>1999-01-18</literal>, "
"то есть в формате <literal>YYYY-MM-DD</literal>."

#: ecpg.xml:2377(function)
msgid "PGTYPESdate_julmdy"
msgstr "PGTYPESdate_julmdy"

#: ecpg.xml:2379(para)
msgid ""
"Extract the values for the day, the month and the year from a variable of "
"type date. <synopsis>\n"
"void PGTYPESdate_julmdy(date d, int *mdy);\n"
"</synopsis> The function receives the date <literal>d</literal> and a "
"pointer to an array of 3 integer values <literal>mdy</literal>. The variable "
"name indicates the sequential order: <literal>mdy[0]</literal> will be set "
"to contain the number of the month, <literal>mdy[1]</literal> will be set to "
"the value of the day and <literal>mdy[2]</literal> will contain the year."
msgstr ""
"Извлекает значения дня, месяца и года из переменной типа date. <synopsis>\n"
"void PGTYPESdate_julmdy(date d, int *mdy);\n"
"</synopsis> Эта функция получает дату <literal>d</literal> и указатель на 3 "
"целочисленных значения <literal>mdy</literal>. Имя переменной указывает на "
"порядок значений: в <literal>mdy[0]</literal> записывается номер месяца, в "
"<literal>mdy[1]</literal> — номер дня, а в <literal>mdy[2]</literal> — год."

#: ecpg.xml:2396(function)
msgid "PGTYPESdate_mdyjul"
msgstr "PGTYPESdate_mdyjul"

#: ecpg.xml:2398(para)
msgid ""
"Create a date value from an array of 3 integers that specify the day, the "
"month and the year of the date. <synopsis>\n"
"void PGTYPESdate_mdyjul(int *mdy, date *jdate);\n"
"</synopsis> The function receives the array of the 3 integers (<literal>mdy</"
"literal>) as its first argument and as its second argument a pointer to a "
"variable of type date that should hold the result of the operation."
msgstr ""
"Образует значение даты из массива 3 целых чисел, задающих день, месяц и год "
"даты. <synopsis>\n"
"void PGTYPESdate_mdyjul(int *mdy, date *jdate);\n"
"</synopsis> Эта функция получает в первом аргументе массив из 3 целых чисел "
"(<literal>mdy</literal>), а во втором указатель на переменную типа date, в "
"которую будет помещён результат операции."

#: ecpg.xml:2412(function)
msgid "PGTYPESdate_dayofweek"
msgstr "PGTYPESdate_dayofweek"

#: ecpg.xml:2424(para) ecpg.xml:8773(para)
msgid "0 - Sunday"
msgstr "0 — Воскресенье"

#: ecpg.xml:2429(para) ecpg.xml:8778(para)
msgid "1 - Monday"
msgstr "1 — Понедельник"

#: ecpg.xml:2434(para) ecpg.xml:8783(para)
msgid "2 - Tuesday"
msgstr "2 — Вторник"

#: ecpg.xml:2439(para) ecpg.xml:8788(para)
msgid "3 - Wednesday"
msgstr "3 — Среда"

#: ecpg.xml:2444(para) ecpg.xml:8793(para)
msgid "4 - Thursday"
msgstr "4 — Четверг"

#: ecpg.xml:2449(para) ecpg.xml:8798(para)
msgid "5 - Friday"
msgstr "5 — Пятница"

#: ecpg.xml:2454(para) ecpg.xml:8803(para)
msgid "6 - Saturday"
msgstr "6 — Суббота"

#: ecpg.xml:2414(para)
msgid ""
"Return a number representing the day of the week for a date value. "
"<synopsis>\n"
"int PGTYPESdate_dayofweek(date d);\n"
"</synopsis> The function receives the date variable <literal>d</literal> as "
"its only argument and returns an integer that indicates the day of the week "
"for this date. <placeholder-1/>"
msgstr ""
"Возвращает число, представляющее день недели для заданной даты. <synopsis>\n"
"int PGTYPESdate_dayofweek(date d);\n"
"</synopsis> Эта функция принимает в единственном аргументе переменную "
"<literal>d</literal> типа date и возвращает целое число, выражающее день "
"недели для этой даты. <placeholder-1/>"

#: ecpg.xml:2464(function)
msgid "PGTYPESdate_today"
msgstr "PGTYPESdate_today"

#: ecpg.xml:2466(para)
msgid ""
"Get the current date. <synopsis>\n"
"void PGTYPESdate_today(date *d);\n"
"</synopsis> The function receives a pointer to a date variable (<literal>d</"
"literal>) that it sets to the current date."
msgstr ""
"Выдаёт текущую дату. <synopsis>\n"
"void PGTYPESdate_today(date *d);\n"
"</synopsis> Эта функция получает указатель на переменную (<literal>d</"
"literal>) типа date, в которую будет записана текущая дата."

#: ecpg.xml:2478(function)
msgid "PGTYPESdate_fmt_asc"
msgstr "PGTYPESdate_fmt_asc"

#: ecpg.xml:2480(para)
msgid ""
"Convert a variable of type date to its textual representation using a format "
"mask. <synopsis>\n"
"int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);\n"
"</synopsis> The function receives the date to convert (<literal>dDate</"
"literal>), the format mask (<literal>fmtstring</literal>) and the string "
"that will hold the textual representation of the date (<literal>outbuf</"
"literal>)."
msgstr ""
"Преобразует переменную типа date в текстовое представление по маске формата. "
"<synopsis>\n"
"int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);\n"
"</synopsis> Эта функция принимает дату для преобразования (<literal>dDate</"
"literal>), маску формата (<literal>fmtstring</literal>) и строку, в которую "
"будет помещено текстовое представление даты (<literal>outbuf</literal>)."

#: ecpg.xml:2490(para) ecpg.xml:8727(para)
msgid "On success, 0 is returned and a negative value if an error occurred."
msgstr ""
"В случае успеха возвращается 0, а в случае ошибки — отрицательное значение."

#: ecpg.xml:2497(para)
msgid "<literal>dd</literal> - The number of the day of the month."
msgstr "<literal>dd</literal> — Номер дня в месяце."

#: ecpg.xml:2502(para)
msgid "<literal>mm</literal> - The number of the month of the year."
msgstr "<literal>mm</literal> — Номер месяца в году."

#: ecpg.xml:2507(para)
msgid "<literal>yy</literal> - The number of the year as a two digit number."
msgstr "<literal>yy</literal> — Номер года в виде двух цифр."

#: ecpg.xml:2512(para)
msgid ""
"<literal>yyyy</literal> - The number of the year as a four digit number."
msgstr "<literal>yyyy</literal> — Номер года в виде четырёх цифр."

#: ecpg.xml:2517(para)
msgid "<literal>ddd</literal> - The name of the day (abbreviated)."
msgstr "<literal>ddd</literal> — Название дня недели (сокращённое)."

#: ecpg.xml:2522(para)
msgid "<literal>mmm</literal> - The name of the month (abbreviated)."
msgstr "<literal>mmm</literal> — Название месяца (сокращённое)."

#: ecpg.xml:2493(para)
msgid ""
"The following literals are the field specifiers you can use: <placeholder-1/"
"> All other characters are copied 1:1 to the output string."
msgstr ""
"В строке формата можно использовать следующие коды полей: <placeholder-1/> "
"Все другие символы копируются в выводимую строку 1:1."

#: ecpg.xml:2529(para)
msgid ""
"<xref linkend=\"ecpg-pgtypesdate-fmt-asc-example-table\"/> indicates a few "
"possible formats. This will give you an idea of how to use this function. "
"All output lines are based on the same date: November 23, 1959."
msgstr ""
"В <xref remap=\"6\" linkend=\"ecpg-pgtypesdate-fmt-asc-example-table\"/> "
"перечислены несколько возможных форматов. Это даёт представление, как можно "
"использовать эту функцию. Все строки вывода даны для одной даты: 23 ноября "
"1959 г."

#: ecpg.xml:2535(title)
msgid "Valid Input Formats for <function>PGTYPESdate_fmt_asc</function>"
msgstr "Допустимые форматы ввода для <function>PGTYPESdate_fmt_asc</function>"

#: ecpg.xml:2539(entry) ecpg.xml:2629(entry)
msgid "Format"
msgstr "Формат"

#: ecpg.xml:2545(literal) ecpg.xml:2696(literal)
msgid "mmddyy"
msgstr "mmddyy"

#: ecpg.xml:2546(literal)
msgid "112359"
msgstr "112359"

#: ecpg.xml:2549(literal) ecpg.xml:2636(literal) ecpg.xml:2641(literal)
#: ecpg.xml:2646(literal) ecpg.xml:2651(literal)
msgid "ddmmyy"
msgstr "ddmmyy"

#: ecpg.xml:2550(literal)
msgid "231159"
msgstr "231159"

#: ecpg.xml:2553(literal)
msgid "yymmdd"
msgstr "yymmdd"

#: ecpg.xml:2554(literal)
msgid "591123"
msgstr "591123"

#: ecpg.xml:2557(literal) ecpg.xml:2661(literal) ecpg.xml:2671(literal)
#: ecpg.xml:2686(literal)
msgid "yy/mm/dd"
msgstr "yy/mm/dd"

#: ecpg.xml:2558(literal)
msgid "59/11/23"
msgstr "59/11/23"

#: ecpg.xml:2561(literal)
msgid "yy mm dd"
msgstr "yy mm dd"

#: ecpg.xml:2562(literal)
msgid "59 11 23"
msgstr "59 11 23"

#: ecpg.xml:2565(literal)
msgid "yy.mm.dd"
msgstr "yy.mm.dd"

#: ecpg.xml:2566(literal)
msgid "59.11.23"
msgstr "59.11.23"

#: ecpg.xml:2569(literal)
msgid ".mm.yyyy.dd."
msgstr ".mm.yyyy.dd."

#: ecpg.xml:2570(literal)
msgid ".11.1959.23."
msgstr ".11.1959.23."

#: ecpg.xml:2573(literal)
msgid "mmm. dd, yyyy"
msgstr "mmm. dd, yyyy"

#: ecpg.xml:2574(literal)
msgid "Nov. 23, 1959"
msgstr "Nov. 23, 1959"

#: ecpg.xml:2577(literal)
msgid "mmm dd yyyy"
msgstr "mmm dd yyyy"

#: ecpg.xml:2578(literal)
msgid "Nov 23 1959"
msgstr "Nov 23 1959"

#: ecpg.xml:2581(literal)
msgid "yyyy dd mm"
msgstr "yyyy dd mm"

#: ecpg.xml:2582(literal)
msgid "1959 23 11"
msgstr "1959 23 11"

#: ecpg.xml:2585(literal)
msgid "ddd, mmm. dd, yyyy"
msgstr "ddd, mmm. dd, yyyy"

#: ecpg.xml:2586(literal)
msgid "Mon, Nov. 23, 1959"
msgstr "Mon, Nov. 23, 1959"

#: ecpg.xml:2589(literal)
msgid "(ddd) mmm. dd, yyyy"
msgstr "(ddd) mmm. dd, yyyy"

#: ecpg.xml:2590(literal)
msgid "(Mon) Nov. 23, 1959"
msgstr "(Mon) Nov. 23, 1959"

#: ecpg.xml:2599(function)
msgid "PGTYPESdate_defmt_asc"
msgstr "PGTYPESdate_defmt_asc"

#: ecpg.xml:2601(para)
msgid ""
"Use a format mask to convert a C <type>char*</type> string to a value of "
"type date. <synopsis>\n"
"int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);\n"
"</synopsis> The function receives a pointer to the date value that should "
"hold the result of the operation (<literal>d</literal>), the format mask to "
"use for parsing the date (<literal>fmt</literal>) and the C char* string "
"containing the textual representation of the date (<literal>str</literal>). "
"The textual representation is expected to match the format mask. However you "
"do not need to have a 1:1 mapping of the string to the format mask. The "
"function only analyzes the sequential order and looks for the literals "
"<literal>yy</literal> or <literal>yyyy</literal> that indicate the position "
"of the year, <literal>mm</literal> to indicate the position of the month and "
"<literal>dd</literal> to indicate the position of the day."
msgstr ""
"Преобразует строку C <type>char*</type> в значение типа date по маске "
"формата. <synopsis>\n"
"int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);\n"
"</synopsis> Эта функция принимает указатель на переменную типа date "
"(<literal>d</literal>), в которую будет помещён результат операции, маску "
"формата для разбора даты (<literal>fmt</literal>) и строку C char*, "
"содержащую текстовое представление даты (<literal>str</literal>). Ожидается, "
"что текстовое представление будет соответствовать маске формата. Однако это "
"соответствие не обязательно должно быть точным. Данная функция анализирует "
"только порядок элементов и ищет в нём подстроки <literal>yy</literal> или "
"<literal>yyyy</literal>, обозначающие позицию года, подстроку <literal>mm</"
"literal>, обозначающую позицию месяца, и <literal>dd</literal>, обозначающую "
"позицию дня."

#: ecpg.xml:2620(para)
msgid ""
"<xref linkend=\"ecpg-rdefmtdate-example-table\"/> indicates a few possible "
"formats. This will give you an idea of how to use this function."
msgstr ""
"В <xref linkend=\"ecpg-rdefmtdate-example-table\"/> перечислены несколько "
"возможных форматов. Это даёт представление, как можно использовать эту "
"функцию."

#: ecpg.xml:2625(title)
msgid "Valid Input Formats for <function>rdefmtdate</function>"
msgstr "Допустимые форматы ввода для <function>rdefmtdate</function>"

#: ecpg.xml:2630(entry)
msgid "String"
msgstr "Строка"

#: ecpg.xml:2637(literal)
msgid "21-2-54"
msgstr "21-2-54"

#: ecpg.xml:2638(literal)
msgid "1954-02-21"
msgstr "1954-02-21"

#: ecpg.xml:2642(literal)
msgid "2-12-54"
msgstr "2-12-54"

#: ecpg.xml:2643(literal)
msgid "1954-12-02"
msgstr "1954-12-02"

#: ecpg.xml:2647(literal)
msgid "20111954"
msgstr "20111954"

#: ecpg.xml:2648(literal)
msgid "1954-11-20"
msgstr "1954-11-20"

#: ecpg.xml:2652(literal)
msgid "130464"
msgstr "130464"

#: ecpg.xml:2653(literal)
msgid "1964-04-13"
msgstr "1964-04-13"

#: ecpg.xml:2656(literal) ecpg.xml:2666(literal) ecpg.xml:2681(literal)
#: ecpg.xml:2691(literal)
msgid "mmm.dd.yyyy"
msgstr "mmm.dd.yyyy"

#: ecpg.xml:2657(literal)
msgid "MAR-12-1967"
msgstr "MAR-12-1967"

#: ecpg.xml:2658(literal)
msgid "1967-03-12"
msgstr "1967-03-12"

#: ecpg.xml:2662(literal)
msgid "1954, February 3rd"
msgstr "1954, February 3rd"

#: ecpg.xml:2663(literal)
msgid "1954-02-03"
msgstr "1954-02-03"

#: ecpg.xml:2667(literal)
msgid "041269"
msgstr "041269"

#: ecpg.xml:2668(literal)
msgid "1969-04-12"
msgstr "1969-04-12"

#: ecpg.xml:2672(literal)
msgid ""
"In the year 2525, in the month of July, mankind will be alive on the 28th day"
msgstr ""
"In the year 2525, in the month of July, mankind will be alive on the 28th day"

#: ecpg.xml:2673(literal) ecpg.xml:2678(literal)
msgid "2525-07-28"
msgstr "2525-07-28"

#: ecpg.xml:2676(literal)
msgid "dd-mm-yy"
msgstr "dd-mm-yy"

#: ecpg.xml:2677(literal)
msgid "I said on the 28th of July in the year 2525"
msgstr "I said on the 28th of July in the year 2525"

#: ecpg.xml:2682(literal)
msgid "9/14/58"
msgstr "9/14/58"

#: ecpg.xml:2683(literal)
msgid "1958-09-14"
msgstr "1958-09-14"

#: ecpg.xml:2687(literal)
msgid "47/03/29"
msgstr "47/03/29"

#: ecpg.xml:2688(literal)
msgid "1947-03-29"
msgstr "1947-03-29"

#: ecpg.xml:2692(literal)
msgid "oct 28 1975"
msgstr "oct 28 1975"

#: ecpg.xml:2693(literal)
msgid "1975-10-28"
msgstr "1975-10-28"

#: ecpg.xml:2697(literal)
msgid "Nov 14th, 1985"
msgstr "Nov 14th, 1985"

#: ecpg.xml:2698(literal)
msgid "1985-11-14"
msgstr "1985-11-14"

#: ecpg.xml:2239(para)
msgid ""
"The following functions can be used to work with the date type: "
"<placeholder-1/>"
msgstr ""
"Для работы с типом date можно использовать следующие функции: <placeholder-1/"
">"

#: ecpg.xml:2710(title)
msgid "The timestamp Type"
msgstr "Тип timestamp"

#: ecpg.xml:2711(para)
msgid ""
"The timestamp type in C enables your programs to deal with data of the SQL "
"type timestamp. See <xref linkend=\"datatype-datetime\"/> for the equivalent "
"type in the <productname>PostgreSQL</productname> server."
msgstr ""
"Тип timestamp, реализованный в C, позволяет программам работать с данными "
"типа timestamp в SQL. Соответствующий тип сервера <productname>PostgreSQL</"
"productname> описан в <xref remap=\"6\" linkend=\"datatype-datetime\"/>."

#: ecpg.xml:2720(function)
msgid "PGTYPEStimestamp_from_asc"
msgstr "PGTYPEStimestamp_from_asc"

#: ecpg.xml:2722(para)
msgid ""
"Parse a timestamp from its textual representation into a timestamp variable. "
"<synopsis>\n"
"timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);\n"
"</synopsis> The function receives the string to parse (<literal>str</"
"literal>) and a pointer to a C char* (<literal>endptr</literal>). At the "
"moment ECPG always parses the complete string and so it currently does not "
"support to store the address of the first invalid character in "
"<literal>*endptr</literal>. You can safely set <literal>endptr</literal> to "
"NULL."
msgstr ""
"Разбирает значение даты/времени из текстового представления в переменную "
"типа timestamp. <synopsis>\n"
"timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);\n"
"</synopsis> Эта функция получает строку (<literal>str</literal>), которую "
"нужно разобрать, и указатель на строку C char* (<literal>endptr</literal>). "
"На данный момент ECPG всегда разбирает строку до конца, так что эта функция "
"не может вернуть адрес первого недопустимого символа в <literal>*endptr</"
"literal>. Поэтому в <literal>endptr</literal> свободно можно передать NULL."

#: ecpg.xml:2735(para)
msgid ""
"The function returns the parsed timestamp on success. On error, "
"<literal>PGTYPESInvalidTimestamp</literal> is returned and <varname>errno</"
"varname> is set to <literal>PGTYPES_TS_BAD_TIMESTAMP</literal>. See <xref "
"linkend=\"pgtypesinvalidtimestamp\"/> for important notes on this value."
msgstr ""
"В случае успеха эта функция возвращает разобранное время, а в случае ошибки "
"возвращается <literal>PGTYPESInvalidTimestamp</literal> и в <varname>errno</"
"varname> устанавливается значение <literal>PGTYPES_TS_BAD_TIMESTAMP</"
"literal>. См. замечание относительно <xref linkend=\"pgtypesinvalidtimestamp"
"\"/>."

#: ecpg.xml:2740(para)
msgid ""
"In general, the input string can contain any combination of an allowed date "
"specification, a whitespace character and an allowed time specification. "
"Note that time zones are not supported by ECPG. It can parse them but does "
"not apply any calculation as the <productname>PostgreSQL</productname> "
"server does for example. Timezone specifiers are silently discarded."
msgstr ""
"Вообще вводимая строка может содержать допустимое указание даты, пробельные "
"символы и допустимое указание времени в любом сочетании. Заметьте, что "
"часовые пояса ECPG не поддерживает. Эта функция может разобрать их, но не "
"задействует их в вычислениях как это делает, например, сервер "
"<productname>PostgreSQL</productname>. Указания часового пояса во вводимой "
"строке просто игнорируются."

#: ecpg.xml:2748(para)
msgid ""
"<xref linkend=\"ecpg-pgtypestimestamp-from-asc-example-table\"/> contains a "
"few examples for input strings."
msgstr ""
"В <xref linkend=\"ecpg-pgtypestimestamp-from-asc-example-table\"/> приведены "
"несколько примеров вводимых строк."

#: ecpg.xml:2752(title)
msgid "Valid Input Formats for <function>PGTYPEStimestamp_from_asc</function>"
msgstr ""
"Допустимые форматы ввода для <function>PGTYPEStimestamp_from_asc</function>"

#: ecpg.xml:2762(literal) ecpg.xml:2763(literal) ecpg.xml:2767(literal)
msgid "1999-01-08 04:05:06"
msgstr "1999-01-08 04:05:06"

#: ecpg.xml:2766(literal)
msgid "January 8 04:05:06 1999 PST"
msgstr "January 8 04:05:06 1999 PST"

#: ecpg.xml:2770(literal)
msgid "1999-Jan-08 04:05:06.789-8"
msgstr "1999-Jan-08 04:05:06.789-8"

# skip-rule: modified-nontranslatable
#: ecpg.xml:2771(literal)
msgid "1999-01-08 04:05:06.789 (time zone specifier ignored)"
msgstr "1999-01-08 04:05:06.789 (указание часового пояса игнорируется)"

#: ecpg.xml:2774(literal)
msgid "J2451187 04:05-08:00"
msgstr "J2451187 04:05-08:00"

# skip-rule: modified-nontranslatable
#: ecpg.xml:2775(literal)
msgid "1999-01-08 04:05:00 (time zone specifier ignored)"
msgstr "1999-01-08 04:05:00 (указание часового пояса игнорируется)"

#: ecpg.xml:2784(function)
msgid "PGTYPEStimestamp_to_asc"
msgstr "PGTYPEStimestamp_to_asc"

#: ecpg.xml:2786(para)
msgid ""
"Converts a date to a C char* string. <synopsis>\n"
"char *PGTYPEStimestamp_to_asc(timestamp tstamp);\n"
"</synopsis> The function receives the timestamp <literal>tstamp</literal> as "
"its only argument and returns an allocated string that contains the textual "
"representation of the timestamp."
msgstr ""
"Преобразует значение даты в строку C char*. <synopsis>\n"
"char *PGTYPEStimestamp_to_asc(timestamp tstamp);\n"
"</synopsis> Эта функция принимает в качестве единственного аргумента "
"<literal>tstamp</literal> значение типа timestamp и возвращает размещённую в "
"памяти строку, содержащую текстовое представление даты/времени."

#: ecpg.xml:2799(function)
msgid "PGTYPEStimestamp_current"
msgstr "PGTYPEStimestamp_current"

#: ecpg.xml:2801(para)
msgid ""
"Retrieve the current timestamp. <synopsis>\n"
"void PGTYPEStimestamp_current(timestamp *ts);\n"
"</synopsis> The function retrieves the current timestamp and saves it into "
"the timestamp variable that <literal>ts</literal> points to."
msgstr ""
"Получает текущее время. <synopsis>\n"
"void PGTYPEStimestamp_current(timestamp *ts);\n"
"</synopsis> Эта функция получает текущее время и сохраняет его в переменной "
"типа timestamp, на которую указывает <literal>ts</literal>."

#: ecpg.xml:2813(function)
msgid "PGTYPEStimestamp_fmt_asc"
msgstr "PGTYPEStimestamp_fmt_asc"

#: ecpg.xml:2815(para)
msgid ""
"Convert a timestamp variable to a C char* using a format mask. <synopsis>\n"
"int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char "
"*fmtstr);\n"
"</synopsis> The function receives a pointer to the timestamp to convert as "
"its first argument (<literal>ts</literal>), a pointer to the output buffer "
"(<literal>output</literal>), the maximal length that has been allocated for "
"the output buffer (<literal>str_len</literal>) and the format mask to use "
"for the conversion (<literal>fmtstr</literal>)."
msgstr ""
"Преобразует переменную типа timestamp в строку C char* по маске формата. "
"<synopsis>\n"
"int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char "
"*fmtstr);\n"
"</synopsis> Эта функция получает в первом аргументе (<literal>ts</literal>) "
"указатель на переменную типа timestamp, а в последующих указатель на буфер "
"вывода (<literal>output</literal>), максимальную длину строки, которую может "
"принять буфер (<literal>str_len</literal>), и маску формата, с которой будет "
"выполняться преобразование (<literal>fmtstr</literal>)."

#: ecpg.xml:2826(para) ecpg.xml:3161(para) ecpg.xml:3208(para)
#: ecpg.xml:3228(para) ecpg.xml:8895(para) ecpg.xml:8916(para)
#: ecpg.xml:8937(para) ecpg.xml:8963(para)
msgid ""
"Upon success, the function returns 0 and a negative value if an error "
"occurred."
msgstr ""
"В случае успеха возвращается 0, а в случае ошибки — отрицательное значение."

#: ecpg.xml:2840(para)
msgid ""
"<literal>%A</literal> - is replaced by national representation of the full "
"weekday name."
msgstr ""
"<literal>%A</literal> — заменяется локализованным представлением полного "
"названия дня недели."

#: ecpg.xml:2846(para)
msgid ""
"<literal>%a</literal> - is replaced by national representation of the "
"abbreviated weekday name."
msgstr ""
"<literal>%a</literal> — заменяется локализованным представлением "
"сокращённого названия дня недели."

#: ecpg.xml:2852(para)
msgid ""
"<literal>%B</literal> - is replaced by national representation of the full "
"month name."
msgstr ""
"<literal>%B</literal> — заменяется локализованным представлением полного "
"названия месяца."

#: ecpg.xml:2858(para)
msgid ""
"<literal>%b</literal> - is replaced by national representation of the "
"abbreviated month name."
msgstr ""
"<literal>%b</literal> — заменяется локализованным представлением "
"сокращённого названия месяца."

#: ecpg.xml:2864(para)
msgid ""
"<literal>%C</literal> - is replaced by (year / 100) as decimal number; "
"single digits are preceded by a zero."
msgstr ""
"<literal>%C</literal> — заменяется столетием (год / 100) в виде десятичного "
"числа; одиночная цифра предваряется нулём."

#: ecpg.xml:2870(para)
msgid ""
"<literal>%c</literal> - is replaced by national representation of time and "
"date."
msgstr ""
"<literal>%c</literal> — заменяется локализованным представлением даты и "
"времени."

#: ecpg.xml:2876(para)
msgid "<literal>%D</literal> - is equivalent to <literal>%m/%d/%y</literal>."
msgstr "<literal>%D</literal> — равнозначно <literal>%m/%d/%y</literal>."

#: ecpg.xml:2882(para)
msgid ""
"<literal>%d</literal> - is replaced by the day of the month as a decimal "
"number (01-31)."
msgstr ""
"<literal>%d</literal> — заменяется днём месяца в виде десятичного числа "
"(01-31)."

#: ecpg.xml:2888(para)
msgid ""
"<literal>%E*</literal> <literal>%O*</literal> - POSIX locale extensions. The "
"sequences <literal>%Ec</literal> <literal>%EC</literal> <literal>%Ex</"
"literal> <literal>%EX</literal> <literal>%Ey</literal> <literal>%EY</"
"literal> <literal>%Od</literal> <literal>%Oe</literal> <literal>%OH</"
"literal> <literal>%OI</literal> <literal>%Om</literal> <literal>%OM</"
"literal> <literal>%OS</literal> <literal>%Ou</literal> <literal>%OU</"
"literal> <literal>%OV</literal> <literal>%Ow</literal> <literal>%OW</"
"literal> <literal>%Oy</literal> are supposed to provide alternative "
"representations."
msgstr ""
"<literal>%E*</literal> <literal>%O*</literal> — расширения локали POSIX. "
"Последовательности <literal>%Ec</literal> <literal>%EC</literal> <literal>"
"%Ex</literal> <literal>%EX</literal> <literal>%Ey</literal> <literal>%EY</"
"literal> <literal>%Od</literal> <literal>%Oe</literal> <literal>%OH</"
"literal> <literal>%OI</literal> <literal>%Om</literal> <literal>%OM</"
"literal> <literal>%OS</literal> <literal>%Ou</literal> <literal>%OU</"
"literal> <literal>%OV</literal> <literal>%Ow</literal> <literal>%OW</"
"literal> <literal>%Oy</literal> должны выводить альтернативные представления."

#: ecpg.xml:2912(para)
msgid ""
"Additionally <literal>%OB</literal> implemented to represent alternative "
"months names (used standalone, without day mentioned)."
msgstr ""
"Кроме того, альтернативные названия месяцев представляет код формата "
"<literal>%OB</literal> (используется отдельно, без упоминания дня)."

#: ecpg.xml:2918(para)
msgid ""
"<literal>%e</literal> - is replaced by the day of month as a decimal number "
"(1-31); single digits are preceded by a blank."
msgstr ""
"<literal>%e</literal> — заменяется днём в виде десятичного числа (1-31); "
"одиночная цифра предваряется пробелом."

#: ecpg.xml:2924(para)
msgid "<literal>%F</literal> - is equivalent to <literal>%Y-%m-%d</literal>."
msgstr "<literal>%F</literal> — равнозначно <literal>%Y-%m-%d</literal>."

#: ecpg.xml:2929(para)
msgid ""
"<literal>%G</literal> - is replaced by a year as a decimal number with "
"century. This year is the one that contains the greater part of the week "
"(Monday as the first day of the week)."
msgstr ""
"<literal>%G</literal> — заменяется годом в виде десятичного числа (со "
"столетием). При этом годом считается тот, что содержит наибольшую часть "
"недели (дни недели начинаются с понедельника)."

#: ecpg.xml:2936(para)
msgid ""
"<literal>%g</literal> - is replaced by the same year as in <literal>%G</"
"literal>, but as a decimal number without century (00-99)."
msgstr ""
"<literal>%g</literal> — заменяется тем же годом, что и <literal>%G</"
"literal>, но в виде десятичного числа без столетия (00-99)."

#: ecpg.xml:2943(para)
msgid ""
"<literal>%H</literal> - is replaced by the hour (24-hour clock) as a decimal "
"number (00-23)."
msgstr ""
"<literal>%H</literal> — заменяется часами (в 24-часовом формате) в виде "
"десятичного числа (00-23)."

#: ecpg.xml:2949(para)
msgid "<literal>%h</literal> - the same as <literal>%b</literal>."
msgstr "<literal>%h</literal> — равнозначно <literal>%b</literal>."

#: ecpg.xml:2954(para)
msgid ""
"<literal>%I</literal> - is replaced by the hour (12-hour clock) as a decimal "
"number (01-12)."
msgstr ""
"<literal>%I</literal> — заменяется часами (в 12-часовом формате) в виде "
"десятичного числа (01-12)."

#: ecpg.xml:2960(para)
msgid ""
"<literal>%j</literal> - is replaced by the day of the year as a decimal "
"number (001-366)."
msgstr ""
"<literal>%j</literal> — заменяется днём года в виде десятичного числа "
"(001-366)."

#: ecpg.xml:2966(para)
msgid ""
"<literal>%k</literal> - is replaced by the hour (24-hour clock) as a decimal "
"number (0-23); single digits are preceded by a blank."
msgstr ""
"<literal>%k</literal> — заменяется часами (в 24-часовом формате) в виде "
"десятичного числа (0-23); одиночная цифра предваряется пробелом."

#: ecpg.xml:2972(para)
msgid ""
"<literal>%l</literal> - is replaced by the hour (12-hour clock) as a decimal "
"number (1-12); single digits are preceded by a blank."
msgstr ""
"<literal>%l</literal> — заменяется часами (в 12-часовом формате) в виде "
"десятичного числа (1-12); одиночная цифра предваряется пробелом."

#: ecpg.xml:2978(para)
msgid ""
"<literal>%M</literal> - is replaced by the minute as a decimal number "
"(00-59)."
msgstr ""
"<literal>%M</literal> — заменяется минутами в виде десятичного числа (00-59)."

#: ecpg.xml:2984(para)
msgid ""
"<literal>%m</literal> - is replaced by the month as a decimal number (01-12)."
msgstr ""
"<literal>%m</literal> — заменяется номером месяца в виде десятичного числа "
"(01-12)."

#: ecpg.xml:2990(para)
msgid "<literal>%n</literal> - is replaced by a newline."
msgstr "<literal>%n</literal> — заменяется символом новой строки."

#: ecpg.xml:2995(para)
msgid "<literal>%O*</literal> - the same as <literal>%E*</literal>."
msgstr "<literal>%O*</literal> — равнозначно <literal>%E*</literal>."

#: ecpg.xml:3000(para)
msgid ""
"<literal>%p</literal> - is replaced by national representation of either "
"<quote>ante meridiem</quote> or <quote>post meridiem</quote> as appropriate."
msgstr ""
"<literal>%p</literal> — заменяется локализованным представлением <quote>до "
"полудня</quote> или <quote>после полудня</quote> в зависимости от времени."

#: ecpg.xml:3006(para)
msgid "<literal>%R</literal> - is equivalent to <literal>%H:%M</literal>."
msgstr "<literal>%R</literal> — равнозначно <literal>%H:%M</literal>."

#: ecpg.xml:3011(para)
msgid ""
"<literal>%r</literal> - is equivalent to <literal>%I:%M:%S %p</literal>."
msgstr "<literal>%r</literal> — равнозначно <literal>%I:%M:%S %p</literal>."

#: ecpg.xml:3017(para)
msgid ""
"<literal>%S</literal> - is replaced by the second as a decimal number "
"(00-60)."
msgstr ""
"<literal>%S</literal> — заменяется секундами в виде десятичного числа "
"(00-60)."

#: ecpg.xml:3023(para)
msgid ""
"<literal>%s</literal> - is replaced by the number of seconds since the "
"Epoch, UTC."
msgstr ""
"<literal>%s</literal> — заменяется числом секунд с начала эпохи, по мировому "
"времени (UTC)."

#: ecpg.xml:3029(para)
msgid "<literal>%T</literal> - is equivalent to <literal>%H:%M:%S</literal>"
msgstr "<literal>%T</literal> — равнозначно <literal>%H:%M:%S</literal>"

#: ecpg.xml:3034(para)
msgid "<literal>%t</literal> - is replaced by a tab."
msgstr "<literal>%t</literal> — заменяется символом табуляции."

#: ecpg.xml:3039(para)
msgid ""
"<literal>%U</literal> - is replaced by the week number of the year (Sunday "
"as the first day of the week) as a decimal number (00-53)."
msgstr ""
"<literal>%U</literal> — заменяется номером недели в году (первым днём недели "
"считается воскресенье) в виде десятичного числа (00-53)."

#: ecpg.xml:3045(para)
msgid ""
"<literal>%u</literal> - is replaced by the weekday (Monday as the first day "
"of the week) as a decimal number (1-7)."
msgstr ""
"<literal>%u</literal> — заменяется номером дня недели (первым днём недели "
"считается понедельник) в виде десятичного числа (1-7)."

#: ecpg.xml:3051(para)
msgid ""
"<literal>%V</literal> - is replaced by the week number of the year (Monday "
"as the first day of the week) as a decimal number (01-53). If the week "
"containing January 1 has four or more days in the new year, then it is week "
"1; otherwise it is the last week of the previous year, and the next week is "
"week 1."
msgstr ""
"<literal>%V</literal> — заменяется номером недели в году (первым днём недели "
"считается понедельник) в виде десятичного числа (01-53). Если к недели, "
"включающей 1 января, относятся 4 или больше дней нового года, она считается "
"неделей с номером 1; в противном случае это последняя неделя предыдущего "
"года, а неделей под номером 1 будет следующая."

#: ecpg.xml:3060(para)
msgid "<literal>%v</literal> - is equivalent to <literal>%e-%b-%Y</literal>."
msgstr "<literal>%v</literal> — равнозначно <literal>%e-%b-%Y</literal>."

#: ecpg.xml:3066(para)
msgid ""
"<literal>%W</literal> - is replaced by the week number of the year (Monday "
"as the first day of the week) as a decimal number (00-53)."
msgstr ""
"<literal>%W</literal> — заменяется номером недели в году (первым днём недели "
"считается понедельник) в виде десятичного числа (00-53)."

#: ecpg.xml:3072(para)
msgid ""
"<literal>%w</literal> - is replaced by the weekday (Sunday as the first day "
"of the week) as a decimal number (0-6)."
msgstr ""
"<literal>%w</literal> — заменяется номером дня недели (первым днём недели "
"считается воскресенье) в виде десятичного числа (0-6)."

#: ecpg.xml:3078(para)
msgid ""
"<literal>%X</literal> - is replaced by national representation of the time."
msgstr ""
"<literal>%X</literal> — заменяется локализованным представлением времени."

#: ecpg.xml:3084(para)
msgid ""
"<literal>%x</literal> - is replaced by national representation of the date."
msgstr "<literal>%x</literal> — заменяется локализованным представлением даты."

#: ecpg.xml:3090(para)
msgid ""
"<literal>%Y</literal> - is replaced by the year with century as a decimal "
"number."
msgstr ""
"<literal>%Y</literal> — заменяется годом со столетием в виде десятичного "
"числа."

#: ecpg.xml:3096(para)
msgid ""
"<literal>%y</literal> - is replaced by the year without century as a decimal "
"number (00-99)."
msgstr ""
"<literal>%y</literal> — заменяется годом без столетия в виде десятичного "
"числа (00-99)."

#: ecpg.xml:3102(para)
msgid "<literal>%Z</literal> - is replaced by the time zone name."
msgstr "<literal>%Z</literal> — заменяется названием часового пояса."

#: ecpg.xml:3107(para)
msgid ""
"<literal>%z</literal> - is replaced by the time zone offset from UTC; a "
"leading plus sign stands for east of UTC, a minus sign for west of UTC, "
"hours and minutes follow with two digits each and no delimiter between them "
"(common form for RFC 822 date headers)."
msgstr ""
"<literal>%z</literal> — заменяется смещением часового пояса от UTC; ведущий "
"знак плюс обозначает смещение к востоку от UTC, а знак минус — к западу, "
"часы и минуты задаются парами цифр без разделителя между ними (эта форма "
"установлена для даты в RFC 822)."

#: ecpg.xml:3115(para)
msgid ""
"<literal>%+</literal> - is replaced by national representation of the date "
"and time."
msgstr ""
"<literal>%+</literal> — заменяется локализованным представлением даты и "
"времени."

#: ecpg.xml:3121(para)
msgid ""
"<literal>%-*</literal> - GNU libc extension. Do not do any padding when "
"performing numerical outputs."
msgstr ""
"<literal>%-*</literal> — расширение GNU libc. Отключает дополнение чисел по "
"ширине при выводе."

#: ecpg.xml:3127(para)
msgid "$_* - GNU libc extension. Explicitly specify space for padding."
msgstr "$_* — расширение GNU libc. Явно включает дополнение пробелами."

#: ecpg.xml:3132(para)
msgid ""
"<literal>%0*</literal> - GNU libc extension. Explicitly specify zero for "
"padding."
msgstr ""
"<literal>%0*</literal> — расширение GNU libc. Явно включает дополнение "
"нулями."

#: ecpg.xml:3138(para)
msgid "<literal>%%</literal> - is replaced by <literal>%</literal>."
msgstr "<literal>%%</literal> — заменяется символом <literal>%</literal>."

#: ecpg.xml:2830(para)
msgid ""
"You can use the following format specifiers for the format mask. The format "
"specifiers are the same ones that are used in the <function>strftime</"
"function> function in <productname>libc</productname>. Any non-format "
"specifier will be copied into the output buffer. <placeholder-1/>"
msgstr ""
"В маске формата можно использовать коды формата, перечисленные ниже. Эти же "
"коды принимает функция <function>strftime</function> из библиотеки "
"<productname>libc</productname>. Любые символы, не относящиеся к кодам "
"формата, будут просто скопированы в буфер вывода. <placeholder-1/>"

#: ecpg.xml:3148(function)
msgid "PGTYPEStimestamp_sub"
msgstr "PGTYPEStimestamp_sub"

#: ecpg.xml:3150(para)
msgid ""
"Subtract one timestamp from another one and save the result in a variable of "
"type interval. <synopsis>\n"
"int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);\n"
"</synopsis> The function will subtract the timestamp variable that "
"<literal>ts2</literal> points to from the timestamp variable that "
"<literal>ts1</literal> points to and will store the result in the interval "
"variable that <literal>iv</literal> points to."
msgstr ""
"Вычитает одно значение времени из другого и сохраняет результат в переменной "
"типа interval. <synopsis>\n"
"int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);\n"
"</synopsis> Эта функция вычитает значение типа timestamp, на которое "
"указывает <literal>ts2</literal>, из значения timestamp, на которое "
"указывает <literal>ts1</literal>, и сохраняет результат в переменной типа "
"interval, на которую указывает <literal>iv</literal>."

#: ecpg.xml:3169(function)
msgid "PGTYPEStimestamp_defmt_asc"
msgstr "PGTYPEStimestamp_defmt_asc"

#: ecpg.xml:3171(para)
msgid ""
"Parse a timestamp value from its textual representation using a formatting "
"mask. <synopsis>\n"
"int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);\n"
"</synopsis> The function receives the textual representation of a timestamp "
"in the variable <literal>str</literal> as well as the formatting mask to use "
"in the variable <literal>fmt</literal>. The result will be stored in the "
"variable that <literal>d</literal> points to."
msgstr ""
"Разбирает значение типа timestamp из текстового представления с заданной "
"маской формата. <synopsis>\n"
"int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);\n"
"</synopsis> Эта функция получает текстовое представление даты/времени в "
"переменной <literal>str</literal>, а также маску формата для разбора в "
"переменной <literal>fmt</literal>. Результат будет сохранён в переменной, на "
"которую указывает <literal>d</literal>."

#: ecpg.xml:3182(para)
msgid ""
"If the formatting mask <literal>fmt</literal> is NULL, the function will "
"fall back to the default formatting mask which is <literal>%Y-%m-%d %H:%M:"
"%S</literal>."
msgstr ""
"Если вместо маски формата <literal>fmt</literal> передаётся NULL, эта "
"функция переходит к стандартной маске форматирования, а именно: <literal>%Y-"
"%m-%d %H:%M:%S</literal>."

#: ecpg.xml:3187(para)
msgid ""
"This is the reverse function to <xref linkend=\"pgtypestimestampfmtasc\"/>. "
"See the documentation there in order to find out about the possible "
"formatting mask entries."
msgstr ""
"Данная функция является обратной к функции <xref linkend="
"\"pgtypestimestampfmtasc\"/>. Обратитесь к её документации, чтобы узнать о "
"возможных вариантах маски формата."

#: ecpg.xml:3196(function)
msgid "PGTYPEStimestamp_add_interval"
msgstr "PGTYPEStimestamp_add_interval"

#: ecpg.xml:3198(para)
msgid ""
"Add an interval variable to a timestamp variable. <synopsis>\n"
"int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp "
"*tout);\n"
"</synopsis> The function receives a pointer to a timestamp variable "
"<literal>tin</literal> and a pointer to an interval variable <literal>span</"
"literal>. It adds the interval to the timestamp and saves the resulting "
"timestamp in the variable that <literal>tout</literal> points to."
msgstr ""
"Добавляет переменную типа interval к переменной типа timestamp. <synopsis>\n"
"int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp "
"*tout);\n"
"</synopsis> Эта функция получает указатель на переменную <literal>tin</"
"literal> типа timestamp и указатель на переменную <literal>span</literal> "
"типа interval. Она добавляет временной интервал к значению даты/времени и "
"сохраняет полученную дату/время в переменной типа timestamp, на которую "
"указывает <literal>tout</literal>."

#: ecpg.xml:3216(function)
msgid "PGTYPEStimestamp_sub_interval"
msgstr "PGTYPEStimestamp_sub_interval"

#: ecpg.xml:3218(para)
msgid ""
"Subtract an interval variable from a timestamp variable. <synopsis>\n"
"int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp "
"*tout);\n"
"</synopsis> The function subtracts the interval variable that <literal>span</"
"literal> points to from the timestamp variable that <literal>tin</literal> "
"points to and saves the result into the variable that <literal>tout</"
"literal> points to."
msgstr ""
"Вычитает переменную типа interval из переменной типа timestamp. <synopsis>\n"
"int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp "
"*tout);\n"
"</synopsis> Эта функция вычитает значение типа interval, на которое "
"указывает <literal>span</literal>, из значения типа timestamp, на которое "
"указывает <literal>tin</literal>, и сохраняет результат в переменной, на "
"которую указывает <literal>tout</literal>."

#: ecpg.xml:2716(para)
msgid ""
"The following functions can be used to work with the timestamp type: "
"<placeholder-1/>"
msgstr ""
"Для работы с типом timestamp можно использовать следующие функции: "
"<placeholder-1/>"

#: ecpg.xml:3239(title)
msgid "The interval Type"
msgstr "Тип interval"

#: ecpg.xml:3240(para)
msgid ""
"The interval type in C enables your programs to deal with data of the SQL "
"type interval. See <xref linkend=\"datatype-datetime\"/> for the equivalent "
"type in the <productname>PostgreSQL</productname> server."
msgstr ""
"Тип interval, реализованный в C, позволяет программам работать с данными "
"типа interval в SQL. Соответствующий тип сервера <productname>PostgreSQL</"
"productname> описан в <xref remap=\"6\" linkend=\"datatype-datetime\"/>."

#: ecpg.xml:3250(function)
msgid "PGTYPESinterval_new"
msgstr "PGTYPESinterval_new"

#: ecpg.xml:3252(para)
msgid ""
"Return a pointer to a newly allocated interval variable. <synopsis>\n"
"interval *PGTYPESinterval_new(void);\n"
"</synopsis>"
msgstr ""
"Возвращает указатель на новую переменную interval, размещённую в памяти. "
"<synopsis>\n"
"interval *PGTYPESinterval_new(void);\n"
"</synopsis>"

#: ecpg.xml:3262(function)
msgid "PGTYPESinterval_free"
msgstr "PGTYPESinterval_free"

#: ecpg.xml:3264(para)
msgid ""
"Release the memory of a previously allocated interval variable. <synopsis>\n"
"void PGTYPESinterval_new(interval *intvl);\n"
"</synopsis>"
msgstr ""
"Освобождает место, занимаемое ранее размещённой в памяти переменной типа "
"interval. <synopsis>\n"
"void PGTYPESinterval_new(interval *intvl);\n"
"</synopsis>"

#: ecpg.xml:3274(function)
msgid "PGTYPESinterval_from_asc"
msgstr "PGTYPESinterval_from_asc"

#: ecpg.xml:3276(para)
msgid ""
"Parse an interval from its textual representation. <synopsis>\n"
"interval *PGTYPESinterval_from_asc(char *str, char **endptr);\n"
"</synopsis> The function parses the input string <literal>str</literal> and "
"returns a pointer to an allocated interval variable. At the moment ECPG "
"always parses the complete string and so it currently does not support to "
"store the address of the first invalid character in <literal>*endptr</"
"literal>. You can safely set <literal>endptr</literal> to NULL."
msgstr ""
"Разбирает значение типа interval из его текстового представления. "
"<synopsis>\n"
"interval *PGTYPESinterval_from_asc(char *str, char **endptr);\n"
"</synopsis> Эта функция разбирает входную строку <literal>str</literal> и "
"возвращает указатель на размещённую в памяти переменную типа interval. На "
"данный момент ECPG всегда разбирает строку до конца, так что эта функция не "
"может вернуть адрес первого недопустимого символа в <literal>*endptr</"
"literal>. Поэтому в <literal>endptr</literal> свободно можно передать NULL."

#: ecpg.xml:3292(function)
msgid "PGTYPESinterval_to_asc"
msgstr "PGTYPESinterval_to_asc"

#: ecpg.xml:3294(para)
msgid ""
"Convert a variable of type interval to its textual representation. "
"<synopsis>\n"
"char *PGTYPESinterval_to_asc(interval *span);\n"
"</synopsis> The function converts the interval variable that <literal>span</"
"literal> points to into a C char*. The output looks like this example: "
"<literal>@ 1 day 12 hours 59 mins 10 secs</literal>."
msgstr ""
"Преобразует переменную типа interval в текстовое представление. <synopsis>\n"
"char *PGTYPESinterval_to_asc(interval *span);\n"
"</synopsis> Эта функция преобразует переменную типа interval, на которую "
"указывает <literal>span</literal>, в строку C char*. Её вывод выглядит "
"примерно так: <literal>@ 1 day 12 hours 59 mins 10 secs</literal>."

#: ecpg.xml:3307(function)
msgid "PGTYPESinterval_copy"
msgstr "PGTYPESinterval_copy"

#: ecpg.xml:3309(para)
msgid ""
"Copy a variable of type interval. <synopsis>\n"
"int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);\n"
"</synopsis> The function copies the interval variable that "
"<literal>intvlsrc</literal> points to into the variable that "
"<literal>intvldest</literal> points to. Note that you need to allocate the "
"memory for the destination variable before."
msgstr ""
"Копирует переменную типа interval. <synopsis>\n"
"int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);\n"
"</synopsis> Эта функция копирует переменную типа interval, на которую "
"указывает <literal>intvlsrc</literal>, в переменную, на которую указывает "
"<literal>intvldest</literal>. Заметьте, что для целевой переменной "
"необходимо предварительно выделить память."

#: ecpg.xml:3245(para)
msgid ""
"The following functions can be used to work with the interval type: "
"<placeholder-1/>"
msgstr ""
"Для работы с типом interval можно использовать следующие функции: "
"<placeholder-1/>"

#: ecpg.xml:3326(title)
msgid "The decimal Type"
msgstr "Тип decimal"

#: ecpg.xml:3327(para)
msgid ""
"The decimal type is similar to the numeric type. However it is limited to a "
"maximum precision of 30 significant digits. In contrast to the numeric type "
"which can be created on the heap only, the decimal type can be created "
"either on the stack or on the heap (by means of the functions "
"<function>PGTYPESdecimal_new</function> and <function>PGTYPESdecimal_free</"
"function>). There are a lot of other functions that deal with the decimal "
"type in the <productname>Informix</productname> compatibility mode described "
"in <xref linkend=\"ecpg-informix-compat\"/>."
msgstr ""
"Тип decimal похож на тип numeric, однако его максимальная точность "
"ограничена 30 значащими цифрами. В отличие от типа numeric, который можно "
"создать только в области кучи, тип decimal можно создать и в стеке, и в "
"области кучи (посредством функций <function>PGTYPESdecimal_new</function> и "
"<function>PGTYPESdecimal_free</function>). Для работы с типом decimal есть "
"много других функций, подключаемых в режиме совместимости с "
"<productname>Informix</productname>, описанном в <xref remap=\"6\" linkend="
"\"ecpg-informix-compat\"/>."

#: ecpg.xml:3343(function)
msgid "PGTYPESdecimal_new"
msgstr "PGTYPESdecimal_new"

#: ecpg.xml:3345(para)
msgid ""
"Request a pointer to a newly allocated decimal variable. <synopsis>\n"
"decimal *PGTYPESdecimal_new(void);\n"
"</synopsis>"
msgstr ""
"Запрашивает указатель на новую переменную decimal, размещённую в памяти. "
"<synopsis>\n"
"decimal *PGTYPESdecimal_new(void);\n"
"</synopsis>"

#: ecpg.xml:3355(function)
msgid "PGTYPESdecimal_free"
msgstr "PGTYPESdecimal_free"

#: ecpg.xml:3357(para)
msgid ""
"Free a decimal type, release all of its memory. <synopsis>\n"
"void PGTYPESdecimal_free(decimal *var);\n"
"</synopsis>"
msgstr ""
"Освобождает переменную типа decimal, высвобождая всю её память. <synopsis>\n"
"void PGTYPESdecimal_free(decimal *var);\n"
"</synopsis>"

#: ecpg.xml:3338(para)
msgid ""
"The following functions can be used to work with the decimal type and are "
"not only contained in the <literal>libcompat</literal> library. "
"<placeholder-1/>"
msgstr ""
"Для работы с типом decimal можно использовать следующие функции "
"(содержащиеся не в библиотеке <literal>libcompat</literal>). <placeholder-1/>"

#: ecpg.xml:3370(title)
msgid "errno Values of pgtypeslib"
msgstr "Значения errno, которые устанавливает pgtypeslib"

#: ecpg.xml:3374(literal)
msgid "PGTYPES_NUM_BAD_NUMERIC"
msgstr "PGTYPES_NUM_BAD_NUMERIC"

#: ecpg.xml:3376(para)
msgid ""
"An argument should contain a numeric variable (or point to a numeric "
"variable) but in fact its in-memory representation was invalid."
msgstr ""
"Аргумент должен содержать переменную типа numeric (либо указывать на "
"переменную типа numeric), но представление этого типа в памяти оказалось "
"некорректным."

#: ecpg.xml:3384(literal)
msgid "PGTYPES_NUM_OVERFLOW"
msgstr "PGTYPES_NUM_OVERFLOW"

#: ecpg.xml:3386(para)
msgid ""
"An overflow occurred. Since the numeric type can deal with almost arbitrary "
"precision, converting a numeric variable into other types might cause "
"overflow."
msgstr ""
"Произошло переполнение. Так как тип numeric может принимать значения "
"практически любой точности, при преобразовании этого типа в другие типы "
"возможно переполнение."

#: ecpg.xml:3395(literal)
msgid "PGTYPES_NUM_UNDERFLOW"
msgstr "PGTYPES_NUM_UNDERFLOW"

#: ecpg.xml:3397(para)
msgid ""
"An underflow occurred. Since the numeric type can deal with almost arbitrary "
"precision, converting a numeric variable into other types might cause "
"underflow."
msgstr ""
"Произошло антипереполнение. Так как тип numeric может принимать значения "
"практически любой точности, при преобразовании переменной этого типа в "
"другие типы возможно антипереполнение."

#: ecpg.xml:3406(literal)
msgid "PGTYPES_NUM_DIVIDE_ZERO"
msgstr "PGTYPES_NUM_DIVIDE_ZERO"

#: ecpg.xml:3408(para)
msgid "A division by zero has been attempted."
msgstr "Имела место попытка деления на ноль."

#: ecpg.xml:3415(literal)
msgid "PGTYPES_DATE_BAD_DATE"
msgstr "PGTYPES_DATE_BAD_DATE"

#: ecpg.xml:3417(para)
msgid ""
"An invalid date string was passed to the <function>PGTYPESdate_from_asc</"
"function> function."
msgstr ""
"Функции <function>PGTYPESdate_from_asc</function> передана некорректная "
"строка даты."

#: ecpg.xml:3425(literal)
msgid "PGTYPES_DATE_ERR_EARGS"
msgstr "PGTYPES_DATE_ERR_EARGS"

#: ecpg.xml:3427(para)
msgid ""
"Invalid arguments were passed to the <function>PGTYPESdate_defmt_asc</"
"function> function."
msgstr ""
"Функции <function>PGTYPESdate_defmt_asc</function> переданы некорректные "
"аргументы."

#: ecpg.xml:3435(literal)
msgid "PGTYPES_DATE_ERR_ENOSHORTDATE"
msgstr "PGTYPES_DATE_ERR_ENOSHORTDATE"

#: ecpg.xml:3437(para)
msgid ""
"An invalid token in the input string was found by the "
"<function>PGTYPESdate_defmt_asc</function> function."
msgstr ""
"В строке, переданной функции <function>PGTYPESdate_defmt_asc</function>, "
"оказался неправильный компонент даты."

#: ecpg.xml:3445(literal)
msgid "PGTYPES_INTVL_BAD_INTERVAL"
msgstr "PGTYPES_INTVL_BAD_INTERVAL"

#: ecpg.xml:3447(para)
msgid ""
"An invalid interval string was passed to the "
"<function>PGTYPESinterval_from_asc</function> function, or an invalid "
"interval value was passed to the <function>PGTYPESinterval_to_asc</function> "
"function."
msgstr ""
"Функции <function>PGTYPESinterval_from_asc</function> передана некорректная "
"строка, задающая интервал, либо функции <function>PGTYPESinterval_to_asc</"
"function> передано некорректное значение интервала."

#: ecpg.xml:3457(literal)
msgid "PGTYPES_DATE_ERR_ENOTDMY"
msgstr "PGTYPES_DATE_ERR_ENOTDMY"

#: ecpg.xml:3459(para)
msgid ""
"There was a mismatch in the day/month/year assignment in the "
"<function>PGTYPESdate_defmt_asc</function> function."
msgstr ""
"Обнаружено несоответствие при выводе компонентов день/месяц/год в функции "
"<function>PGTYPESdate_defmt_asc</function>."

#: ecpg.xml:3467(literal)
msgid "PGTYPES_DATE_BAD_DAY"
msgstr "PGTYPES_DATE_BAD_DAY"

#: ecpg.xml:3469(para)
msgid ""
"An invalid day of the month value was found by the "
"<function>PGTYPESdate_defmt_asc</function> function."
msgstr ""
"Функция <function>PGTYPESdate_defmt_asc</function> обнаружила некорректное "
"значение дня месяца."

#: ecpg.xml:3477(literal)
msgid "PGTYPES_DATE_BAD_MONTH"
msgstr "PGTYPES_DATE_BAD_MONTH"

#: ecpg.xml:3479(para)
msgid ""
"An invalid month value was found by the <function>PGTYPESdate_defmt_asc</"
"function> function."
msgstr ""
"Функция <function>PGTYPESdate_defmt_asc</function> обнаружила некорректное "
"значение месяца."

#: ecpg.xml:3487(literal)
msgid "PGTYPES_TS_BAD_TIMESTAMP"
msgstr "PGTYPES_TS_BAD_TIMESTAMP"

#: ecpg.xml:3489(para)
msgid ""
"An invalid timestamp string pass passed to the "
"<function>PGTYPEStimestamp_from_asc</function> function, or an invalid "
"timestamp value was passed to the <function>PGTYPEStimestamp_to_asc</"
"function> function."
msgstr ""
"Функции <function>PGTYPEStimestamp_from_asc</function> передана некорректная "
"строка даты/времени, либо функции <function>PGTYPEStimestamp_to_asc</"
"function> передано некорректное значение типа timestamp."

#: ecpg.xml:3499(literal)
msgid "PGTYPES_TS_ERR_EINFTIME"
msgstr "PGTYPES_TS_ERR_EINFTIME"

#: ecpg.xml:3501(para)
msgid ""
"An infinite timestamp value was encountered in a context that cannot handle "
"it."
msgstr ""
"Значение типа timestamp, представляющее бесконечность, получено в "
"недопустимом контексте."

#: ecpg.xml:3512(title)
msgid "Special Constants of pgtypeslib"
msgstr "Специальные константы pgtypeslib"

#: ecpg.xml:3516(literal)
msgid "PGTYPESInvalidTimestamp"
msgstr "PGTYPESInvalidTimestamp"

#: ecpg.xml:3518(para)
msgid ""
"A value of type timestamp representing an invalid time stamp. This is "
"returned by the function <function>PGTYPEStimestamp_from_asc</function> on "
"parse error. Note that due to the internal representation of the "
"<type>timestamp</type> data type, <literal>PGTYPESInvalidTimestamp</literal> "
"is also a valid timestamp at the same time. It is set to <literal>1899-12-31 "
"23:59:59</literal>. In order to detect errors, make sure that your "
"application does not only test for <literal>PGTYPESInvalidTimestamp</"
"literal> but also for <literal>errno != 0</literal> after each call to "
"<function>PGTYPEStimestamp_from_asc</function>."
msgstr ""
"Значение типа timestamp, представляющее недопустимое время. Это значение "
"возвращает функция <function>PGTYPEStimestamp_from_asc</function> при ошибке "
"разбора. Заметьте, что вследствие особенности внутреннего представления типа "
"<type>timestamp</type>, значение <literal>PGTYPESInvalidTimestamp</literal> "
"в то же время представляет корректное время (<literal>1899-12-31 23:59:59</"
"literal>). Поэтому для выявления ошибок необходимо, чтобы приложение не "
"только сравнивало результат функции с <literal>PGTYPESInvalidTimestamp</"
"literal>, но и проверяло условие <literal>errno != 0</literal> после каждого "
"вызова <function>PGTYPEStimestamp_from_asc</function>."

#: ecpg.xml:3538(title)
msgid "Using Descriptor Areas"
msgstr "Использование областей дескрипторов"

#: ecpg.xml:3540(para)
msgid ""
"An SQL descriptor area is a more sophisticated method for processing the "
"result of a <command>SELECT</command>, <command>FETCH</command> or a "
"<command>DESCRIBE</command> statement. An SQL descriptor area groups the "
"data of one row of data together with metadata items into one data "
"structure. The metadata is particularly useful when executing dynamic SQL "
"statements, where the nature of the result columns might not be known ahead "
"of time. PostgreSQL provides two ways to use Descriptor Areas: the named SQL "
"Descriptor Areas and the C-structure SQLDAs."
msgstr ""
"Области дескрипторов SQL дают возможности для более сложной обработки "
"результатов операторов <command>SELECT</command>, <command>FETCH</command> и "
"<command>DESCRIBE</command>. Область дескриптора SQL объединяет в одной "
"структуре данные одной строки и элементы метаданных. Эти метаданные особенно "
"полезны при выполнении динамических SQL-операторов, когда характер "
"результирующих столбцов может быть неизвестен заранее. PostgreSQL предлагает "
"два подхода к использованию областей дескрипторов: именованные области SQL-"
"дескрипторов и области SQLDA в структурах C."

#: ecpg.xml:3553(title)
msgid "Named SQL Descriptor Areas"
msgstr "Именованные области SQL-дескрипторов"

#: ecpg.xml:3555(para)
msgid ""
"A named SQL descriptor area consists of a header, which contains information "
"concerning the entire descriptor, and one or more item descriptor areas, "
"which basically each describe one column in the result row."
msgstr ""
"Именованная область SQL-дескриптора состоит из заголовка, содержащего "
"сведения обо всём дескрипторе, и одного или нескольких дескрипторов "
"элементов, которые по сути описывают отдельные столбцы в строке результата."

#: ecpg.xml:3564(programlisting)
#, no-wrap
msgid "EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;"
msgstr "EXEC SQL ALLOCATE DESCRIPTOR <replaceable>идентификатор</replaceable>;"

#: ecpg.xml:3571(programlisting)
#, no-wrap
msgid "EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;"
msgstr "EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>идентификатор</replaceable>;"

#: ecpg.xml:3562(para)
msgid ""
"Before you can use an SQL descriptor area, you need to allocate one: "
"<placeholder-1/> The identifier serves as the <quote>variable name</quote> "
"of the descriptor area. <remark>The scope of the allocated descriptor is "
"WHAT?.</remark> When you don't need the descriptor anymore, you should "
"deallocate it: <placeholder-2/>"
msgstr ""
"Прежде чем вы сможете использовать область SQL-дескриптора, её нужно "
"выделить: <placeholder-1/> Заданный идентификатор играет роль <quote>имени "
"переменной</quote> области дескриптора. <remark>Какова область видимости "
"выделенного дескриптора?</remark> Когда дескриптор оказывается ненужным, его "
"следует освободить: <placeholder-2/>"

#: ecpg.xml:3579(programlisting)
#, no-wrap
msgid "EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;"
msgstr "EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;"

#: ecpg.xml:3576(para)
msgid ""
"To use a descriptor area, specify it as the storage target in an "
"<literal>INTO</literal> clause, instead of listing host variables: "
"<placeholder-1/> If the result set is empty, the Descriptor Area will still "
"contain the metadata from the query, i.e. the field names."
msgstr ""
"Чтобы воспользоваться областью дескриптора, её нужно указать в качестве "
"целевого объекта в предложении <literal>INTO</literal>, вместо перечисления "
"переменных среды: <placeholder-1/> Если набор результатов пуст, в области "
"дескриптора будут, тем не менее, содержаться метаданные из запроса, то есть "
"имена полей."

#: ecpg.xml:3589(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"char *sql_stmt = \"SELECT * FROM table1\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL PREPARE stmt1 FROM :sql_stmt;\n"
"EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"char *sql_stmt = \"SELECT * FROM table1\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL PREPARE stmt1 FROM :sql_stmt;\n"
"EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;"

#: ecpg.xml:3586(para)
msgid ""
"For not yet executed prepared queries, the <command>DESCRIBE</command> "
"statement can be used to get the metadata of the result set: <placeholder-1/>"
msgstr ""
"Получить метаданные набора результатов для ещё не выполненных подготовленных "
"запросов можно, воспользовавшись оператором <command>DESCRIBE</command>: "
"<placeholder-1/>"

#: ecpg.xml:3599(para)
msgid ""
"Before PostgreSQL 9.0, the <literal>SQL</literal> keyword was optional, so "
"using <literal>DESCRIPTOR</literal> and <literal>SQL DESCRIPTOR</literal> "
"produced named SQL Descriptor Areas. Now it is mandatory, omitting the "
"<literal>SQL</literal> keyword produces SQLDA Descriptor Areas, see <xref "
"linkend=\"ecpg-sqlda-descriptors\"/>."
msgstr ""
"До PostgreSQL версии 9.0 ключевое слово <literal>SQL</literal> было "
"необязательным, так что предложения <literal>DESCRIPTOR</literal> и "
"<literal>SQL DESCRIPTOR</literal> создавали именованные области SQL-"
"дескрипторов. Теперь оно стало обязательным; без слова <literal>SQL</"
"literal> создаются области SQLDA, см. <xref remap=\"4\" linkend=\"ecpg-sqlda-"
"descriptors\"/>."

#: ecpg.xml:3607(para)
msgid ""
"In <command>DESCRIBE</command> and <command>FETCH</command> statements, the "
"<literal>INTO</literal> and <literal>USING</literal> keywords can be used to "
"similarly: they produce the result set and the metadata in a Descriptor Area."
msgstr ""
"В операторах <command>DESCRIBE</command> и <command>FETCH</command> ключевые "
"слова <literal>INTO</literal> и <literal>USING</literal> действуют примерно "
"одинаково: они указывают вывести набор результатов и метаданные в область "
"дескриптора."

#: ecpg.xml:3619(programlisting)
#, no-wrap
msgid "EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;"
msgstr "EXEC SQL GET DESCRIPTOR <replaceable>имя</replaceable> :<replaceable>переменная_среды</replaceable> = <replaceable>поле</replaceable>;"

#: ecpg.xml:3628(programlisting)
#, no-wrap
msgid "EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;"
msgstr "EXEC SQL GET DESCRIPTOR <replaceable>имя</replaceable> VALUE <replaceable>номер</replaceable> :<replaceable>переменная_среды</replaceable> = <replaceable>поле</replaceable>;"

#: ecpg.xml:3636(term)
msgid "<literal>CARDINALITY</literal> (integer)"
msgstr "<literal>CARDINALITY</literal> (integer)"

#: ecpg.xml:3638(para)
msgid "number of rows in the result set"
msgstr "число строк в наборе результатов"

#: ecpg.xml:3645(literal)
msgid "DATA"
msgstr "DATA"

#: ecpg.xml:3647(para)
msgid ""
"actual data item (therefore, the data type of this field depends on the "
"query)"
msgstr "собственно элемент данных (тип данных поля зависит от запроса)"

#: ecpg.xml:3655(term)
msgid "<literal>DATETIME_INTERVAL_CODE</literal> (integer)"
msgstr "<literal>DATETIME_INTERVAL_CODE</literal> (целое)"

#: ecpg.xml:3657(para)
msgid ""
"When <literal>TYPE</literal> is <literal>9</literal>, "
"<literal>DATETIME_INTERVAL_CODE</literal> will have a value of <literal>1</"
"literal> for <literal>DATE</literal>, <literal>2</literal> for "
"<literal>TIME</literal>, <literal>3</literal> for <literal>TIMESTAMP</"
"literal>, <literal>4</literal> for <literal>TIME WITH TIME ZONE</literal>, "
"or <literal>5</literal> for <literal>TIMESTAMP WITH TIME ZONE</literal>."
msgstr ""
"Когда <literal>TYPE</literal> равно <literal>9</literal>, "
"<literal>DATETIME_INTERVAL_CODE</literal> содержит значение <literal>1</"
"literal> для <literal>DATE</literal>, <literal>2</literal> для "
"<literal>TIME</literal>, <literal>3</literal> для <literal>TIMESTAMP</"
"literal>, <literal>4</literal> для <literal>TIME WITH TIME ZONE</literal>, "
"либо <literal>5</literal> для <literal>TIMESTAMP WITH TIME ZONE</literal>."

#: ecpg.xml:3670(term)
msgid "<literal>DATETIME_INTERVAL_PRECISION</literal> (integer)"
msgstr "<literal>DATETIME_INTERVAL_PRECISION</literal> (целое)"

#: ecpg.xml:3672(para) ecpg.xml:3690(para) ecpg.xml:3717(para)
msgid "not implemented"
msgstr "не реализовано"

#: ecpg.xml:3679(term)
msgid "<literal>INDICATOR</literal> (integer)"
msgstr "<literal>INDICATOR</literal> (целое)"

#: ecpg.xml:3681(para)
msgid "the indicator (indicating a null value or a value truncation)"
msgstr "индикатор (отмечающий значение NULL или усечение значения)"

#: ecpg.xml:3688(term)
msgid "<literal>KEY_MEMBER</literal> (integer)"
msgstr "<literal>KEY_MEMBER</literal> (целое)"

#: ecpg.xml:3697(term)
msgid "<literal>LENGTH</literal> (integer)"
msgstr "<literal>LENGTH</literal> (целое)"

#: ecpg.xml:3699(para) ecpg.xml:3744(para)
msgid "length of the datum in characters"
msgstr "длина данных в символах"

#: ecpg.xml:3706(term)
msgid "<literal>NAME</literal> (string)"
msgstr "<literal>NAME</literal> (строка)"

#: ecpg.xml:3708(para)
msgid "name of the column"
msgstr "имя столбца"

#: ecpg.xml:3715(term)
msgid "<literal>NULLABLE</literal> (integer)"
msgstr "<literal>NULLABLE</literal> (целое)"

#: ecpg.xml:3724(term)
msgid "<literal>OCTET_LENGTH</literal> (integer)"
msgstr "<literal>OCTET_LENGTH</literal> (целое)"

#: ecpg.xml:3726(para) ecpg.xml:3753(para)
msgid "length of the character representation of the datum in bytes"
msgstr "длина символьного представления данных в байтах"

#: ecpg.xml:3733(term)
msgid "<literal>PRECISION</literal> (integer)"
msgstr "<literal>PRECISION</literal> (целое)"

#: ecpg.xml:3735(para)
msgid "precision (for type <type>numeric</type>)"
msgstr "точность (для типа <type>numeric</type>)"

#: ecpg.xml:3742(term)
msgid "<literal>RETURNED_LENGTH</literal> (integer)"
msgstr "<literal>RETURNED_LENGTH</literal> (целое)"

#: ecpg.xml:3751(term)
msgid "<literal>RETURNED_OCTET_LENGTH</literal> (integer)"
msgstr "<literal>RETURNED_OCTET_LENGTH</literal> (целое)"

#: ecpg.xml:3760(term)
msgid "<literal>SCALE</literal> (integer)"
msgstr "<literal>SCALE</literal> (целое)"

#: ecpg.xml:3762(para)
msgid "scale (for type <type>numeric</type>)"
msgstr "масштаб (для типа <type>numeric</type>)"

#: ecpg.xml:3769(term)
msgid "<literal>TYPE</literal> (integer)"
msgstr "<literal>TYPE</literal> (целое)"

#: ecpg.xml:3771(para)
msgid "numeric code of the data type of the column"
msgstr "числовой код типа данных столбца"

#: ecpg.xml:3614(para)
msgid ""
"Now how do you get the data out of the descriptor area? You can think of the "
"descriptor area as a structure with named fields. To retrieve the value of a "
"field from the header and store it into a host variable, use the following "
"command: <placeholder-1/> Currently, there is only one header field defined: "
"<replaceable>COUNT</replaceable>, which tells how many item descriptor areas "
"exist (that is, how many columns are contained in the result). The host "
"variable needs to be of an integer type. To get a field from the item "
"descriptor area, use the following command: <placeholder-2/> "
"<replaceable>num</replaceable> can be a literal integer or a host variable "
"containing an integer. Possible fields are: <placeholder-3/>"
msgstr ""
"Возникает вопрос: а как же получить данные из области дескриптора? Область "
"дескриптора можно представить как структуру с именованными полями. Чтобы "
"получить значение поля из заголовка и сохранить его в переменной среды, "
"нужно выполнить команду: <placeholder-1/> В настоящее время определено "
"только одно поле заголовка: <replaceable>COUNT</replaceable>, которое "
"говорит, сколько областей дескрипторов элементов существует (то есть, "
"сколько столбцов содержится в результате). Переменная среды должна иметь "
"целочисленный тип. Чтобы получить поле из области дескриптора элемента, "
"нужно выполнить команду: <placeholder-2/> В качестве <replaceable>num</"
"replaceable> можно задать обычное целое или переменную среды, содержащую "
"целое число. Допустимые поля: <placeholder-3/>"

#: ecpg.xml:3787(programlisting)
#, no-wrap
msgid "EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;"
msgstr "EXEC SQL SET DESCRIPTOR <replaceable>имя</replaceable> VALUE <replaceable>номер</replaceable> <replaceable>поле</replaceable> = :<replaceable>переменная_среды</replaceable>;"

#: ecpg.xml:3779(para)
msgid ""
"In <command>EXECUTE</command>, <command>DECLARE</command> and <command>OPEN</"
"command> statements, the effect of the <literal>INTO</literal> and "
"<literal>USING</literal> keywords are different. A Descriptor Area can also "
"be manually built to provide the input parameters for a query or a cursor "
"and <literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal> "
"is the way to pass the input parameters into a parameterized query. The "
"statement to build a named SQL Descriptor Area is below: <placeholder-1/>"
msgstr ""
"В операторах <command>EXECUTE</command>, <command>DECLARE</command> и "
"<command>OPEN</command> ключевые слова <literal>INTO</literal> и "
"<literal>USING</literal> действуют по-разному. Область дескриптора также "
"можно сформировать вручную, чтобы передать входные параметры запросу или "
"курсору, а команда <literal>USING SQL DESCRIPTOR <replaceable>имя</"
"replaceable></literal> даёт возможность передать входные аргументы "
"параметризованному запросу. Оператор, формирующий именованную область SQL-"
"дескриптора, выглядит так: <placeholder-1/>"

#: ecpg.xml:3796(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int id[5];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;\n"
"\n"
"EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int id[5];\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;\n"
"\n"
"EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;"

#: ecpg.xml:3792(para)
msgid ""
"PostgreSQL supports retrieving more that one record in one <command>FETCH</"
"command> statement and storing the data in host variables in this case "
"assumes that the variable is an array. E.g.: <placeholder-1/>"
msgstr ""
"PostgreSQL поддерживает выборку сразу нескольких записей в одном операторе "
"<command>FETCH</command> и может сохранить их данные в переменной среды, "
"если эта переменная — массив. Например: <placeholder-1/>"

#: ecpg.xml:3811(title)
msgid "SQLDA Descriptor Areas"
msgstr "Области дескрипторов SQLDA"

#: ecpg.xml:3817(programlisting)
#, no-wrap
msgid ""
"EXEC SQL include sqlda.h;\n"
"sqlda_t         *mysqlda;\n"
"\n"
"EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;"
msgstr ""
"EXEC SQL include sqlda.h;\n"
"sqlda_t         *mysqlda;\n"
"\n"
"EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;"

#: ecpg.xml:3828(programlisting)
#, no-wrap
msgid "EXEC SQL DESCRIBE prepared_statement INTO mysqlda;"
msgstr "EXEC SQL DESCRIBE prepared_statement INTO mysqlda;"

#: ecpg.xml:3813(para)
msgid ""
"An SQLDA Descriptor Area is a C language structure which can be also used to "
"get the result set and the metadata of a query. One structure stores one "
"record from the result set. <placeholder-1/> Note that the <literal>SQL</"
"literal> keyword is omitted. The paragraphs about the use cases of the "
"<literal>INTO</literal> and <literal>USING</literal> keywords in <xref "
"linkend=\"ecpg-named-descriptors\"/> also apply here with an addition. In a "
"<command>DESCRIBE</command> statement the <literal>DESCRIPTOR</literal> "
"keyword can be completely omitted if the <literal>INTO</literal> keyword is "
"used: <placeholder-2/>"
msgstr ""
"Область дескриптора SQLDA представляет собой структуру языка C, в которую "
"можно получить набор результатов и метаданные запроса. Одна такая структура "
"содержит одну запись из набора данных. <placeholder-1/> Заметьте, что "
"ключевое слово <literal>SQL</literal> в этом случае опускается. Замечания "
"относительно применения ключевых слов <literal>INTO</literal> и "
"<literal>USING</literal> в <xref remap=\"6\" linkend=\"ecpg-named-descriptors"
"\"/> применимы и здесь, с дополнением. В операторе <command>DESCRIBE</"
"command> можно полностью опустить ключевое слово <literal>DESCRIPTOR</"
"literal>, если присутствует ключевое слово <literal>INTO</literal>: "
"<placeholder-2/>"

#: ecpg.xml:3834(para)
msgid "The general flow of a program that uses SQLDA is:"
msgstr "Общая схема использования SQLDA выглядит так:"

#: ecpg.xml:3837(simpara)
msgid "Prepare a query, and declare a cursor for it."
msgstr "Подготовить запрос и объявить курсор для него."

#: ecpg.xml:3838(simpara)
msgid "Declare an SQLDA for the result rows."
msgstr "Объявить SQLDA для строк результата."

#: ecpg.xml:3839(simpara)
msgid ""
"Declare an SQLDA for the input parameters, and initialize them (memory "
"allocation, parameter settings)."
msgstr ""
"Объявить SQLDA для входных параметров и инициализировать их (выделить "
"память, задать параметры)."

#: ecpg.xml:3840(simpara)
msgid "Open a cursor with the input SQLDA."
msgstr "Открыть курсор с входной SQLDA."

#: ecpg.xml:3841(simpara)
msgid "Fetch rows from the cursor, and store them into an output SQLDA."
msgstr "Выбрать строки из курсора и сохранить их в выходной SQLDA."

#: ecpg.xml:3842(simpara)
msgid ""
"Read values from the output SQLDA into the host variables (with conversion "
"if necessary)."
msgstr ""
"Прочитать значения из выходной SQLDA в переменные среды (и преобразовать при "
"необходимости)."

#: ecpg.xml:3843(simpara)
msgid "Close the cursor."
msgstr "Закрыть курсор."

#: ecpg.xml:3844(simpara)
msgid "Free the memory area allocated for the input SQLDA."
msgstr "Освободить область памяти, выделенную для входной SQLDA."

#: ecpg.xml:3848(title)
msgid "SQLDA Data Structure"
msgstr "Структура данных SQLDA"

#: ecpg.xml:3850(para)
msgid ""
"SQLDA uses three data structure types: <type>sqlda_t</type>, <type>sqlvar_t</"
"type>, and <type>struct sqlname</type>."
msgstr ""
"Для SQLDA используются три типа данных: <type>sqlda_t</type>, "
"<type>sqlvar_t</type> и <type>struct sqlname</type>."

#: ecpg.xml:3857(para)
msgid ""
"PostgreSQL's SQLDA has a similar data structure to the one in IBM DB2 "
"Universal Database, so some technical information on DB2's SQLDA could help "
"understanding PostgreSQL's one better."
msgstr ""
"Структура данных SQLDA в PostgreSQL подобна той, что используется в IBM DB2 "
"Universal Database, так что часть технической информации по SQLDA в DB2 "
"может быть полезна и для понимания устройства SQLDA в PostgreSQL."

#: ecpg.xml:3865(title)
msgid "sqlda_t Structure"
msgstr "Структура sqlda_t"

#: ecpg.xml:3867(para)
msgid ""
"The structure type <type>sqlda_t</type> is the type of the actual SQLDA. It "
"holds one record. And two or more <type>sqlda_t</type> structures can be "
"connected in a linked list with the pointer in the <structfield>desc_next</"
"structfield> field, thus representing an ordered collection of rows. So, "
"when two or more rows are fetched, the application can read them by "
"following the <structfield>desc_next</structfield> pointer in each "
"<type>sqlda_t</type> node."
msgstr ""
"Тип структуры <type>sqlda_t</type> представляет тип собственно SQLDA. Эта "
"структура описывает одну запись. Две или более структур <type>sqlda_t</type> "
"могут объединяться в связанный список по указателям в поле "
"<structfield>desc_next</structfield>, и таким образом образовывать "
"упорядоченный набор строк. Поэтому, когда выбираются две или более строк, "
"приложение может прочитать их, проследуя по указателям "
"<structfield>desc_next</structfield> во всех узлах <type>sqlda_t</type>."

#: ecpg.xml:3881(programlisting)
#, no-wrap
msgid ""
"struct sqlda_struct\n"
"{\n"
"    char            sqldaid[8];\n"
"    long            sqldabc;\n"
"    short           sqln;\n"
"    short           sqld;\n"
"    struct sqlda_struct *desc_next;\n"
"    struct sqlvar_struct sqlvar[1];\n"
"};\n"
"\n"
"typedef struct sqlda_struct sqlda_t;"
msgstr ""
"struct sqlda_struct\n"
"{\n"
"    char            sqldaid[8];\n"
"    long            sqldabc;\n"
"    short           sqln;\n"
"    short           sqld;\n"
"    struct sqlda_struct *desc_next;\n"
"    struct sqlvar_struct sqlvar[1];\n"
"};\n"
"\n"
"typedef struct sqlda_struct sqlda_t;"

#: ecpg.xml:3899(literal)
msgid "sqldaid"
msgstr "sqldaid"

#: ecpg.xml:3901(para)
msgid "It contains the literal string <literal>\"SQLDA \"</literal>."
msgstr "Содержит строковую константу <literal>\"SQLDA \"</literal>."

#: ecpg.xml:3908(literal)
msgid "sqldabc"
msgstr "sqldabc"

#: ecpg.xml:3910(para)
msgid "It contains the size of the allocated space in bytes."
msgstr "Содержит размер выделенного пространства в байтах."

#: ecpg.xml:3917(literal)
msgid "sqln"
msgstr "sqln"

#: ecpg.xml:3919(para)
msgid ""
"It contains the number of input parameters for a parameterized query in case "
"it's passed into <command>OPEN</command>, <command>DECLARE</command> or "
"<command>EXECUTE</command> statements using the <literal>USING</literal> "
"keyword. In case it's used as output of <command>SELECT</command>, "
"<command>EXECUTE</command> or <command>FETCH</command> statements, its value "
"is the same as <literal>sqld</literal> statement"
msgstr ""
"Содержит число входных параметров для параметризованного запроса, когда "
"передаётся в операторы <command>OPEN</command>, <command>DECLARE</command> "
"или <command>EXECUTE</command> с ключевым словом <literal>USING</literal>. В "
"структуре, выводимой операторами <command>SELECT</command>, "
"<command>EXECUTE</command> или <command>FETCH</command>, данное значение "
"совпадает с <literal>sqld</literal>."

#: ecpg.xml:3932(literal) ecpg.xml:7984(literal)
msgid "sqld"
msgstr "sqld"

#: ecpg.xml:3934(para)
msgid "It contains the number of fields in a result set."
msgstr "Содержит число полей в наборе результатов."

#: ecpg.xml:3941(literal) ecpg.xml:8020(literal)
msgid "desc_next"
msgstr "desc_next"

#: ecpg.xml:3943(para)
msgid ""
"If the query returns more than one record, multiple linked SQLDA structures "
"are returned, and <literal>desc_next</literal> holds a pointer to the next "
"entry in the list."
msgstr ""
"Если запрос выдаёт несколько записей, возвращается несколько связанных "
"структур SQLDA, а <literal>desc_next</literal> содержит указатель на "
"следующую запись в списке."

#: ecpg.xml:3951(literal) ecpg.xml:7993(literal)
msgid "sqlvar"
msgstr "sqlvar"

#: ecpg.xml:3953(para)
msgid "This is the array of the columns in the result set."
msgstr "Это массив столбцов в наборе результатов."

#: ecpg.xml:3879(para)
msgid ""
"The definition of <type>sqlda_t</type> is: <placeholder-1/> The meaning of "
"the fields is: <placeholder-2/>"
msgstr ""
"Тип <type>sqlda_t</type> определяется так: <placeholder-1/> Его поля имеют "
"следующее назначение: <placeholder-2/>"

#: ecpg.xml:3963(title)
msgid "sqlvar_t Structure"
msgstr "Структура sqlvar_t"

#: ecpg.xml:3970(programlisting)
#, no-wrap
msgid ""
"struct sqlvar_struct\n"
"{\n"
"    short          sqltype;\n"
"    short          sqllen;\n"
"    char          *sqldata;\n"
"    short         *sqlind;\n"
"    struct sqlname sqlname;\n"
"};\n"
"\n"
"typedef struct sqlvar_struct sqlvar_t;"
msgstr ""
"struct sqlvar_struct\n"
"{\n"
"    short          sqltype;\n"
"    short          sqllen;\n"
"    char          *sqldata;\n"
"    short         *sqlind;\n"
"    struct sqlname sqlname;\n"
"};\n"
"\n"
"typedef struct sqlvar_struct sqlvar_t;"

#: ecpg.xml:3987(literal) ecpg.xml:8044(literal)
msgid "sqltype"
msgstr "sqltype"

#: ecpg.xml:3989(para)
msgid ""
"Contains the type identifier of the field. For values, see <literal>enum "
"ECPGttype</literal> in <literal>ecpgtype.h</literal>."
msgstr ""
"Содержит идентификатор типа данного поля. Возможные значения перечислены в "
"<literal>enum ECPGttype</literal> в <literal>ecpgtype.h</literal>."

#: ecpg.xml:3997(literal) ecpg.xml:8053(literal)
msgid "sqllen"
msgstr "sqllen"

#: ecpg.xml:3999(para)
msgid ""
"Contains the binary length of the field. e.g. 4 bytes for <type>ECPGt_int</"
"type>."
msgstr ""
"Содержит двоичную длину поля, например, 4 байта для <type>ECPGt_int</type>."

#: ecpg.xml:4006(literal) ecpg.xml:8062(literal)
msgid "sqldata"
msgstr "sqldata"

#: ecpg.xml:4008(para)
msgid ""
"Points to the data. The format of the data is described in <xref linkend="
"\"ecpg-variables-type-mapping\"/>."
msgstr ""
"Указывает на данные. Формат данных описан в <xref remap=\"6\" linkend=\"ecpg-"
"variables-type-mapping\"/>."

#: ecpg.xml:4016(literal) ecpg.xml:8083(literal)
msgid "sqlind"
msgstr "sqlind"

#: ecpg.xml:4018(para)
msgid "Points to the null indicator. 0 means not null, -1 means null."
msgstr ""
"Указывает на индикатор NULL. 0 соответствует значению не NULL, -1 — NULL."

#: ecpg.xml:4026(literal) ecpg.xml:8099(literal)
msgid "sqlname"
msgstr "sqlname"

#: ecpg.xml:4028(para)
msgid "The name of the field."
msgstr "Имя поля."

#: ecpg.xml:3965(para)
msgid ""
"The structure type <type>sqlvar_t</type> holds a column value and metadata "
"such as type and length. The definition of the type is: <placeholder-1/> The "
"meaning of the fields is: <placeholder-2/>"
msgstr ""
"Тип структуры <type>sqlvar_t</type> содержит значение столбца и метаданные, "
"в частности, тип и длину. Эта структура определяется так: <placeholder-1/> "
"Её поля имеют следующее назначение: <placeholder-2/>"

#: ecpg.xml:4038(title)
msgid "struct sqlname Structure"
msgstr "Структура struct sqlname"

#: ecpg.xml:4044(programlisting)
#, no-wrap
msgid ""
"#define NAMEDATALEN 64\n"
"\n"
"struct sqlname\n"
"{\n"
"        short           length;\n"
"        char            data[NAMEDATALEN];\n"
"};"
msgstr ""
"#define NAMEDATALEN 64\n"
"\n"
"struct sqlname\n"
"{\n"
"        short           length;\n"
"        char            data[NAMEDATALEN];\n"
"};"

#: ecpg.xml:4056(literal)
msgid "length"
msgstr "length"

#: ecpg.xml:4058(para)
msgid "Contains the length of the field name."
msgstr "Содержит длину имени поля."

#: ecpg.xml:4064(literal)
msgid "data"
msgstr "data"

#: ecpg.xml:4066(para)
msgid "Contains the actual field name."
msgstr "Содержит собственно имя поля."

#: ecpg.xml:4040(para)
msgid ""
"A <type>struct sqlname</type> structure holds a column name. It is used as a "
"member of the <type>sqlvar_t</type> structure. The definition of the "
"structure is: <placeholder-1/> The meaning of the fields is: <placeholder-2/>"
msgstr ""
"Структура <type>struct sqlname</type> содержит имя столбца. Она включена в "
"<type>sqlvar_t</type> в качестве члена. Эта структура определена так: "
"<placeholder-1/> Её поля имеют следующее назначение: <placeholder-2/>"

#: ecpg.xml:4077(title)
msgid "Retrieving a Result Set Using an SQLDA"
msgstr "Получение набора результатов с применением SQLDA"

#: ecpg.xml:4080(para)
msgid "The general steps to retrieve a query result set through an SQLDA are:"
msgstr ""
"Чтобы получить набор результатов запроса через SQLDA, нужно проделать "
"примерно следующее:"

#: ecpg.xml:4084(simpara)
msgid "Declare an <type>sqlda_t</type> structure to receive the result set."
msgstr ""
"Объявить структуру <type>sqlda_t</type> для получения набора результатов."

#: ecpg.xml:4085(simpara)
msgid ""
"Execute <command>FETCH</command>/<command>EXECUTE</command>/"
"<command>DESCRIBE</command> commands to process a query specifying the "
"declared SQLDA."
msgstr ""
"Выполнить команды <command>FETCH</command>/<command>EXECUTE</command>/"
"<command>DESCRIBE</command> для обработки запроса с указанной SQLDA."

#: ecpg.xml:4086(simpara)
msgid ""
"Check the number of records in the result set by looking at "
"<structfield>sqln</structfield>, a member of the <type>sqlda_t</type> "
"structure."
msgstr ""
"Определить число записей в наборе результатов, прочитав <structfield>sqln</"
"structfield>, член структуры <type>sqlda_t</type>."

#: ecpg.xml:4087(simpara)
msgid ""
"Get the values of each column from <literal>sqlvar[0]</literal>, "
"<literal>sqlvar[1]</literal>, etc., members of the <type>sqlda_t</type> "
"structure."
msgstr ""
"Получить значения каждого столбца из элементов <literal>sqlvar[0]</literal>, "
"<literal>sqlvar[1]</literal> и т. д., составляющих массив, включённый в "
"структуру <type>sqlda_t</type>."

#: ecpg.xml:4088(simpara)
msgid ""
"Go to next row (<type>sqlda_t</type> structure) by following the "
"<structfield>desc_next</structfield> pointer, a member of the <type>sqlda_t</"
"type> structure."
msgstr ""
"Перейти к следующей строке (структуре <type>sqlda_t</type>) по указателю "
"<structfield>desc_next</structfield>, члену структуры <type>sqlda_t</type>."

#: ecpg.xml:4089(simpara)
msgid "Repeat above as you need."
msgstr "При необходимости повторить эти действия."

#: ecpg.xml:4092(para)
msgid "Here is an example retrieving a result set through an SQLDA."
msgstr "Далее показывается, как получить набор результатов через SQLDA."

#: ecpg.xml:4098(programlisting)
#, no-wrap
msgid "sqlda_t *sqlda1;"
msgstr "sqlda_t *sqlda1;"

#: ecpg.xml:4096(para)
msgid ""
"First, declare a <type>sqlda_t</type> structure to receive the result set. "
"<placeholder-1/>"
msgstr ""
"Сначала объявите структуру <type>sqlda_t</type>, в которую будет помещён "
"набор результатов. <placeholder-1/>"

#: ecpg.xml:4106(programlisting)
#, no-wrap
msgid "EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;"
msgstr "EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;"

#: ecpg.xml:4103(para)
msgid ""
"Next, specify the SQLDA in a command. This is a <command>FETCH</command> "
"command example. <placeholder-1/>"
msgstr ""
"Затем укажите эту SQLDA в команде. В данном примере это команда "
"<command>FETCH</command>. <placeholder-1/>"

#: ecpg.xml:4113(programlisting)
#, no-wrap
msgid ""
"sqlda_t *cur_sqlda;\n"
"\n"
"for (cur_sqlda = sqlda1;\n"
"     cur_sqlda != NULL;\n"
"     cur_sqlda = cur_sqlda-&gt;desc_next)\n"
"{\n"
"    ...\n"
"}"
msgstr ""
"sqlda_t *cur_sqlda;\n"
"\n"
"for (cur_sqlda = sqlda1;\n"
"     cur_sqlda != NULL;\n"
"     cur_sqlda = cur_sqlda-&gt;desc_next)\n"
"{\n"
"    ...\n"
"}"

#: ecpg.xml:4111(para)
msgid ""
"Run a loop following the linked list to retrieve the rows. <placeholder-1/>"
msgstr ""
"Обработайте все строки в цикле с переходом по связанному списку. "
"<placeholder-1/>"

#: ecpg.xml:4128(programlisting)
#, no-wrap
msgid ""
"for (i = 0; i &lt; cur_sqlda-&gt;sqld; i++)\n"
"{\n"
"    sqlvar_t v = cur_sqlda-&gt;sqlvar[i];\n"
"    char *sqldata = v.sqldata;\n"
"    short sqllen  = v.sqllen;\n"
"    ...\n"
"}"
msgstr ""
"for (i = 0; i &lt; cur_sqlda-&gt;sqld; i++)\n"
"{\n"
"    sqlvar_t v = cur_sqlda-&gt;sqlvar[i];\n"
"    char *sqldata = v.sqldata;\n"
"    short sqllen  = v.sqllen;\n"
"    ...\n"
"}"

#: ecpg.xml:4125(para)
msgid ""
"Inside the loop, run another loop to retrieve each column data "
"(<type>sqlvar_t</type> structure) of the row. <placeholder-1/>"
msgstr ""
"Внутри этого цикла реализуйте ещё один цикл чтения данных каждого столбца "
"(структуры <type>sqlvar_t</type>) в строке. <placeholder-1/>"

#: ecpg.xml:4144(programlisting)
#, no-wrap
msgid ""
"char var_buf[1024];\n"
"\n"
"switch (v.sqltype)\n"
"{\n"
"    case ECPGt_char:\n"
"        memset(&amp;var_buf, 0, sizeof(var_buf));\n"
"        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));\n"
"        break;\n"
"\n"
"    case ECPGt_int: /* integer */\n"
"        memcpy(&amp;intval, sqldata, sqllen);\n"
"        snprintf(var_buf, sizeof(var_buf), \"%d\", intval);\n"
"        break;\n"
"\n"
"    ...\n"
"}"
msgstr ""
"char var_buf[1024];\n"
"\n"
"switch (v.sqltype)\n"
"{\n"
"    case ECPGt_char:\n"
"        memset(&amp;var_buf, 0, sizeof(var_buf));\n"
"        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));\n"
"        break;\n"
"\n"
"    case ECPGt_int: /* integer */\n"
"        memcpy(&amp;intval, sqldata, sqllen);\n"
"        snprintf(var_buf, sizeof(var_buf), \"%d\", intval);\n"
"        break;\n"
"\n"
"    ...\n"
"}"

#: ecpg.xml:4139(para)
msgid ""
"To get a column value, check the <structfield>sqltype</structfield> value, a "
"member of the <type>sqlvar_t</type> structure. Then, switch to an "
"appropriate way, depending on the column type, to copy data from the "
"<structfield>sqlvar</structfield> field to a host variable. <placeholder-1/>"
msgstr ""
"Чтобы получить значение столбца, прочитайте значение поля "
"<structfield>sqltype</structfield>, члена структуры <type>sqlvar_t</type>. "
"Затем выберите подходящий способ, в зависимости от типа столбца, копирования "
"данных из поля <structfield>sqlvar</structfield> в переменную среды. "
"<placeholder-1/>"

#: ecpg.xml:4166(title)
msgid "Passing Query Parameters Using an SQLDA"
msgstr "Передача значений параметров через SQLDA"

#: ecpg.xml:4169(para)
msgid ""
"The general steps to use an SQLDA to pass input parameters to a prepared "
"query are:"
msgstr ""
"Чтобы передать параметры подготовленному запросу через SQLDA, нужно "
"проделать примерно следующее:"

#: ecpg.xml:4173(simpara)
msgid "Create a prepared query (prepared statement)"
msgstr "Создать подготовленный запрос (подготовленный оператор)"

#: ecpg.xml:4174(simpara)
msgid "Declare a sqlda_t structure as an input SQLDA."
msgstr "Объявить структуру sqlda_t в качестве входной SQLDA."

#: ecpg.xml:4175(simpara)
msgid "Allocate memory area (as sqlda_t structure) for the input SQLDA."
msgstr "Выделить область памяти (структуру sqlda_t) для входной SQLDA."

#: ecpg.xml:4176(simpara)
msgid "Set (copy) input values in the allocated memory."
msgstr "Установить (скопировать) входные значения в выделенной памяти."

#: ecpg.xml:4177(simpara)
msgid "Open a cursor with specifying the input SQLDA."
msgstr "Открыть курсор, указав входную SQLDA."

#: ecpg.xml:4180(para)
msgid "Here is an example."
msgstr "Рассмотрим это на примере."

#: ecpg.xml:4186(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"char query[1024] = \"SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL PREPARE stmt1 FROM :query;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"char query[1024] = \"SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)\";\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL PREPARE stmt1 FROM :query;"

#: ecpg.xml:4184(para)
msgid "First, create a prepared statement. <placeholder-1/>"
msgstr "Сначала создайте подготовленный оператор. <placeholder-1/>"

#: ecpg.xml:4203(programlisting)
#, no-wrap
msgid ""
"sqlda_t *sqlda2;\n"
"\n"
"sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"\n"
"sqlda2-&gt;sqln = 2; /* number of input variables */"
msgstr ""
"sqlda_t *sqlda2;\n"
"\n"
"sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"\n"
"sqlda2-&gt;sqln = 2; /* число входных переменных */"

#: ecpg.xml:4195(para)
msgid ""
"Next, allocate memory for an SQLDA, and set the number of input parameters "
"in <structfield>sqln</structfield>, a member variable of the <type>sqlda_t</"
"type> structure. When two or more input parameters are required for the "
"prepared query, the application has to allocate additional memory space "
"which is calculated by (nr. of params - 1) * sizeof(sqlvar_t). The example "
"shown here allocates memory space for two input parameters. <placeholder-1/>"
msgstr ""
"Затем выделите память для SQLDA и установите число входных параметров в поле "
"<structfield>sqln</structfield>, члене структуры <type>sqlda_t</type>. Когда "
"для подготовленного запроса требуются два или более входных параметров, "
"приложение должно выделить дополнительное место в памяти, размер которого "
"вычисляется как (число параметров - 1) * sizeof(sqlvar_t). В показанном "
"здесь примере выделяется место для двух параметров. <placeholder-1/>"

#: ecpg.xml:4220(programlisting)
#, no-wrap
msgid ""
"sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;\n"
"sqlda2-&gt;sqlvar[0].sqldata = \"postgres\";\n"
"sqlda2-&gt;sqlvar[0].sqllen  = 8;\n"
"\n"
"int intval = 1;\n"
"sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;\n"
"sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;\n"
"sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);"
msgstr ""
"sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;\n"
"sqlda2-&gt;sqlvar[0].sqldata = \"postgres\";\n"
"sqlda2-&gt;sqlvar[0].sqllen  = 8;\n"
"\n"
"int intval = 1;\n"
"sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;\n"
"sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;\n"
"sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);"

#: ecpg.xml:4213(para)
msgid ""
"After memory allocation, store the parameter values into the "
"<literal>sqlvar[]</literal> array. (This is same array used for retrieving "
"column values when the SQLDA is receiving a result set.) In this example, "
"the input parameters are <literal>\"postgres\"</literal>, having a string "
"type, and <literal>1</literal>, having an integer type. <placeholder-1/>"
msgstr ""
"Выделив память, сохраните значения параметров в массиве <literal>sqlvar[]</"
"literal>. (Этот же массив используется для значений столбцов, когда SQLDA "
"получает набор результатов.) В данном примере передаются два параметра: "
"<literal>\"postgres\"</literal> (строкового типа) и <literal>1</literal> "
"(целочисленного типа). <placeholder-1/>"

#: ecpg.xml:4236(programlisting)
#, no-wrap
msgid "EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;"
msgstr "EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;"

#: ecpg.xml:4232(para)
msgid ""
"By opening a cursor and specifying the SQLDA that was set up beforehand, the "
"input parameters are passed to the prepared statement. <placeholder-1/>"
msgstr ""
"Откройте курсор с указанием ранее созданной SQLDA, чтобы входные параметры "
"были переданы подготовленному оператору. <placeholder-1/>"

#: ecpg.xml:4245(programlisting)
#, no-wrap
msgid "free(sqlda2);"
msgstr "free(sqlda2);"

#: ecpg.xml:4241(para)
msgid ""
"Finally, after using input SQLDAs, the allocated memory space must be freed "
"explicitly, unlike SQLDAs used for receiving query results. <placeholder-1/>"
msgstr ""
"Наконец, закончив использование входных SQLDA, необходимо явно освободить "
"выделенную для них память, в отличие от SQLDA, получающих результаты "
"запросов. <placeholder-1/>"

#: ecpg.xml:4252(title)
msgid "A Sample Application Using SQLDA"
msgstr "Пример приложения, использующего SQLDA"

#: ecpg.xml:4254(para)
msgid ""
"Here is an example program, which describes how to fetch access statistics "
"of the databases, specified by the input parameters, from the system "
"catalogs."
msgstr ""
"Представленный здесь пример программы показывает, как выбрать из системных "
"каталогов статистику доступа к базам данных, определённых входными "
"параметрами."

#: ecpg.xml:4260(para)
msgid ""
"This application joins two system tables, pg_database and pg_stat_database "
"on the database OID, and also fetches and shows the database statistics "
"which are retrieved by two input parameters (a database <literal>postgres</"
"literal>, and OID <literal>1</literal>)."
msgstr ""
"Это приложение соединяет записи двух системных таблиц, pg_database и "
"pg_stat_database по OID базы данных, и также выбирает и показывает "
"статистику, принимая два входных параметра (база данных <literal>postgres</"
"literal> и OID <literal>1</literal>)."

#: ecpg.xml:4269(programlisting)
#, no-wrap
msgid ""
"EXEC SQL include sqlda.h;\n"
"\n"
"sqlda_t *sqlda1; /* an output descriptor */\n"
"sqlda_t *sqlda2; /* an input descriptor  */"
msgstr ""
"EXEC SQL include sqlda.h;\n"
"\n"
"sqlda_t *sqlda1; /* выходной дескриптор */\n"
"sqlda_t *sqlda2; /* входной дескриптор */"

#: ecpg.xml:4267(para)
msgid ""
"First, declare an SQLDA for input and an SQLDA for output. <placeholder-1/>"
msgstr ""
"Сначала создайте SQLDA для ввода параметров и SQLDA для вывода результатов. "
"<placeholder-1/>"

#: ecpg.xml:4280(programlisting)
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char query[1024] = \"SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )\";\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"\n"
"    EXEC SQL PREPARE stmt1 FROM :query;\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char query[1024] = \"SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )\";\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"\n"
"    EXEC SQL PREPARE stmt1 FROM :query;\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;"

#: ecpg.xml:4277(para)
msgid ""
"Next, connect to the database, prepare a statement, and declare a cursor for "
"the prepared statement. <placeholder-1/>"
msgstr ""
"Затем подключитесь к базе данных, подготовьте оператор и объявите курсор для "
"подготовленного оператора. <placeholder-1/>"

#: ecpg.xml:4303(programlisting)
#, no-wrap
msgid ""
"    /* Create SQLDA structure for input parameters. */\n"
"    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    sqlda2-&gt;sqln = 2; /* number of input variables */\n"
"\n"
"    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;\n"
"    sqlda2-&gt;sqlvar[0].sqldata = \"postgres\";\n"
"    sqlda2-&gt;sqlvar[0].sqllen  = 8;\n"
"\n"
"    intval = 1;\n"
"    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;\n"
"    sqlda2-&gt;sqlvar[1].sqldata = (char *)&amp;intval;\n"
"    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);"
msgstr ""
"    /* Создать структуру SQLDA для входных параметров. */\n"
"    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    sqlda2-&gt;sqln = 2; /* number of input variables */\n"
"\n"
"    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;\n"
"    sqlda2-&gt;sqlvar[0].sqldata = \"postgres\";\n"
"    sqlda2-&gt;sqlvar[0].sqllen  = 8;\n"
"\n"
"    intval = 1;\n"
"    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;\n"
"    sqlda2-&gt;sqlvar[1].sqldata = (char *)&amp;intval;\n"
"    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);"

#: ecpg.xml:4295(para)
msgid ""
"Next, put some values in the input SQLDA for the input parameters. Allocate "
"memory for the input SQLDA, and set the number of input parameters to "
"<literal>sqln</literal>. Store type, value, and value length into "
"<literal>sqltype</literal>, <literal>sqldata</literal>, and <literal>sqllen</"
"literal> in the <literal>sqlvar</literal> structure. <placeholder-1/>"
msgstr ""
"Затем запишите некоторые значения параметров во входную SQLDA. Выделите "
"память для входной SQLDA и установите количество параметров в <literal>sqln</"
"literal>. Запишите тип, значение и длину значения в поля <literal>sqltype</"
"literal>, <literal>sqldata</literal> и <literal>sqllen</literal> структуры "
"<literal>sqlvar</literal>. <placeholder-1/>"

#: ecpg.xml:4324(programlisting)
#, no-wrap
msgid ""
"    /* Open a cursor with input parameters. */\n"
"    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;"
msgstr ""
"    /* Открыть курсор с входными параметрами. */\n"
"    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;"

#: ecpg.xml:4320(para)
msgid ""
"After setting up the input SQLDA, open a cursor with the input SQLDA. "
"<placeholder-1/>"
msgstr "Подготовив входную SQLDA, откройте курсор с ней. <placeholder-1/>"

#: ecpg.xml:4334(programlisting)
#, no-wrap
msgid ""
"    while (1)\n"
"    {\n"
"        sqlda_t *cur_sqlda;\n"
"\n"
"        /* Assign descriptor to the cursor  */\n"
"        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;"
msgstr ""
"    while (1)\n"
"    {\n"
"        sqlda_t *cur_sqlda;\n"
"\n"
"        /* Назначить дескриптор курсору */\n"
"        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;"

#: ecpg.xml:4330(para)
msgid ""
"Fetch rows into the output SQLDA from the opened cursor. (Generally, you "
"have to call <command>FETCH</command> repeatedly in the loop, to fetch all "
"rows in the result set.) <placeholder-1/>"
msgstr ""
"Выберите строки из открытого курсора в выходную SQLDA. (Обычно, чтобы "
"выбрать все строки в наборе результатов, нужно повторять <command>FETCH</"
"command> в цикле.) <placeholder-1/>"

#: ecpg.xml:4347(programlisting)
#, no-wrap
msgid ""
"    for (cur_sqlda = sqlda1 ;\n"
"         cur_sqlda != NULL ;\n"
"         cur_sqlda = cur_sqlda-&gt;desc_next)\n"
"    {\n"
"        ..."
msgstr ""
"    for (cur_sqlda = sqlda1 ;\n"
"         cur_sqlda != NULL ;\n"
"         cur_sqlda = cur_sqlda-&gt;desc_next)\n"
"    {\n"
"        ..."

#: ecpg.xml:4344(para)
msgid ""
"Next, retrieve the fetched records from the SQLDA, by following the linked "
"list of the <type>sqlda_t</type> structure. <placeholder-1/>"
msgstr ""
"Затем прочитайте выбранные записи из SQLDA, следуя по связанному списку "
"структуры <type>sqlda_t</type>. <placeholder-1/>"

#: ecpg.xml:4362(programlisting)
#, no-wrap
msgid ""
"        /* Print every column in a row. */\n"
"        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)\n"
"        {\n"
"            sqlvar_t v = sqlda1-&gt;sqlvar[i];\n"
"            char *sqldata = v.sqldata;\n"
"            short sqllen  = v.sqllen;\n"
"\n"
"            strncpy(name_buf, v.sqlname.data, v.sqlname.length);\n"
"            name_buf[v.sqlname.length] = '\\0';"
msgstr ""
"        /* Вывести каждый столбец в строке. */\n"
"        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)\n"
"        {\n"
"            sqlvar_t v = sqlda1-&gt;sqlvar[i];\n"
"            char *sqldata = v.sqldata;\n"
"            short sqllen  = v.sqllen;\n"
"\n"
"            strncpy(name_buf, v.sqlname.data, v.sqlname.length);\n"
"            name_buf[v.sqlname.length] = '\\0';"

#: ecpg.xml:4356(para)
msgid ""
"Read each columns in the first record. The number of columns is stored in "
"<structfield>sqld</structfield>, the actual data of the first column is "
"stored in <literal>sqlvar[0]</literal>, both members of the <type>sqlda_t</"
"type> structure. <placeholder-1/>"
msgstr ""
"Прочитайте все столбцы первой записи. Количество столбцов хранится в поле "
"<structfield>sqld</structfield>, а данные первого столбца в "
"<literal>sqlvar[0]</literal>, оба эти поля — члены структуры <type>sqlda_t</"
"type>. <placeholder-1/>"

#: ecpg.xml:4379(programlisting)
#, no-wrap
msgid ""
"            switch (v.sqltype) {\n"
"                int intval;\n"
"                double doubleval;\n"
"                unsigned long long int longlongval;\n"
"\n"
"                case ECPGt_char:\n"
"                    memset(&amp;var_buf, 0, sizeof(var_buf));\n"
"                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));\n"
"                    break;\n"
"\n"
"                case ECPGt_int: /* integer */\n"
"                    memcpy(&amp;intval, sqldata, sqllen);\n"
"                    snprintf(var_buf, sizeof(var_buf), \"%d\", intval);\n"
"                    break;\n"
"\n"
"                ...\n"
"\n"
"                default:\n"
"                    ...\n"
"            }\n"
"\n"
"            printf(\"%s = %s (type: %d)\\n\", name_buf, var_buf, v.sqltype);\n"
"        }"
msgstr ""
"            switch (v.sqltype) {\n"
"                int intval;\n"
"                double doubleval;\n"
"                unsigned long long int longlongval;\n"
"\n"
"                case ECPGt_char:\n"
"                    memset(&amp;var_buf, 0, sizeof(var_buf));\n"
"                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));\n"
"                    break;\n"
"\n"
"                case ECPGt_int: /* integer */\n"
"                    memcpy(&amp;intval, sqldata, sqllen);\n"
"                    snprintf(var_buf, sizeof(var_buf), \"%d\", intval);\n"
"                    break;\n"
"\n"
"                ...\n"
"\n"
"                default:\n"
"                    ...\n"
"            }\n"
"\n"
"            printf(\"%s = %s (type: %d)\\n\", name_buf, var_buf, v.sqltype);\n"
"        }"

#: ecpg.xml:4375(para)
msgid ""
"Now, the column data is stored in the variable <varname>v</varname>. Copy "
"every datum into host variables, looking at <literal>v.sqltype</literal> for "
"the type of the column. <placeholder-1/>"
msgstr ""
"Теперь данные столбцов сохранены в переменной <varname>v</varname>. "
"Скопируйте все элементы данных в переменные среды, определив тип столбца по "
"полю <literal>v.sqltype</literal>. <placeholder-1/>"

#: ecpg.xml:4409(programlisting)
#, no-wrap
msgid ""
"    EXEC SQL CLOSE cur1;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DISCONNECT ALL;"
msgstr ""
"    EXEC SQL CLOSE cur1;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DISCONNECT ALL;"

#: ecpg.xml:4406(para)
msgid ""
"Close the cursor after processing all of records, and disconnect from the "
"database. <placeholder-1/>"
msgstr ""
"Закончив обработку всех записей, закройте курсор и отключитесь от базы "
"данных. <placeholder-1/>"

#: ecpg.xml:4417(para)
msgid ""
"The whole program is shown in <xref linkend=\"ecpg-sqlda-example-example\"/>."
msgstr ""
"Вся программа показана в <xref remap=\"6\" linkend=\"ecpg-sqlda-example-"
"example\"/>."

#: ecpg.xml:4423(title)
msgid "Example SQLDA Program"
msgstr "Пример программы на базе SQLDA"

#: ecpg.xml:4424(programlisting)
#, no-wrap
msgid ""
"#include &lt;stdlib.h&gt;\n"
"#include &lt;string.h&gt;\n"
"#include &lt;stdlib.h&gt;\n"
"#include &lt;stdio.h&gt;\n"
"#include &lt;unistd.h&gt;\n"
"\n"
"EXEC SQL include sqlda.h;\n"
"\n"
"sqlda_t *sqlda1; /* descriptor for output */\n"
"sqlda_t *sqlda2; /* descriptor for input */\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"EXEC SQL WHENEVER SQLERROR STOP;\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char query[1024] = \"SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )\";\n"
"\n"
"    int intval;\n"
"    unsigned long long int longlongval;\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;\n"
"\n"
"    EXEC SQL PREPARE stmt1 FROM :query;\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;\n"
"\n"
"    /* Create a SQLDA structure for an input parameter */\n"
"    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    sqlda2-&gt;sqln = 2; /* a number of input variables */\n"
"\n"
"    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;\n"
"    sqlda2-&gt;sqlvar[0].sqldata = \"postgres\";\n"
"    sqlda2-&gt;sqlvar[0].sqllen  = 8;\n"
"\n"
"    intval = 1;\n"
"    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;\n"
"    sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;\n"
"    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);\n"
"\n"
"    /* Open a cursor with input parameters. */\n"
"    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;\n"
"\n"
"    while (1)\n"
"    {\n"
"        sqlda_t *cur_sqlda;\n"
"\n"
"        /* Assign descriptor to the cursor  */\n"
"        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;\n"
"\n"
"        for (cur_sqlda = sqlda1 ;\n"
"             cur_sqlda != NULL ;\n"
"             cur_sqlda = cur_sqlda-&gt;desc_next)\n"
"        {\n"
"            int i;\n"
"            char name_buf[1024];\n"
"            char var_buf[1024];\n"
"\n"
"            /* Print every column in a row. */\n"
"            for (i=0 ; i&lt;cur_sqlda-&gt;sqld ; i++)\n"
"            {\n"
"                sqlvar_t v = cur_sqlda-&gt;sqlvar[i];\n"
"                char *sqldata = v.sqldata;\n"
"                short sqllen  = v.sqllen;\n"
"\n"
"                strncpy(name_buf, v.sqlname.data, v.sqlname.length);\n"
"                name_buf[v.sqlname.length] = '\\0';\n"
"\n"
"                switch (v.sqltype)\n"
"                {\n"
"                    case ECPGt_char:\n"
"                        memset(&amp;var_buf, 0, sizeof(var_buf));\n"
"                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );\n"
"                        break;\n"
"\n"
"                    case ECPGt_int: /* integer */\n"
"                        memcpy(&amp;intval, sqldata, sqllen);\n"
"                        snprintf(var_buf, sizeof(var_buf), \"%d\", intval);\n"
"                        break;\n"
"\n"
"                    case ECPGt_long_long: /* bigint */\n"
"                        memcpy(&amp;longlongval, sqldata, sqllen);\n"
"                        snprintf(var_buf, sizeof(var_buf), \"%lld\", longlongval);\n"
"                        break;\n"
"\n"
"                    default:\n"
"                    {\n"
"                        int i;\n"
"                        memset(var_buf, 0, sizeof(var_buf));\n"
"                        for (i = 0; i &lt; sqllen; i++)\n"
"                        {\n"
"                            char tmpbuf[16];\n"
"                            snprintf(tmpbuf, sizeof(tmpbuf), \"%02x \", (unsigned char) sqldata[i]);\n"
"                            strncat(var_buf, tmpbuf, sizeof(var_buf));\n"
"                        }\n"
"                    }\n"
"                        break;\n"
"                }\n"
"\n"
"                printf(\"%s = %s (type: %d)\\n\", name_buf, var_buf, v.sqltype);\n"
"            }\n"
"\n"
"            printf(\"\\n\");\n"
"        }\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DISCONNECT ALL;\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#include &lt;stdlib.h&gt;\n"
"#include &lt;string.h&gt;\n"
"#include &lt;stdlib.h&gt;\n"
"#include &lt;stdio.h&gt;\n"
"#include &lt;unistd.h&gt;\n"
"\n"
"EXEC SQL include sqlda.h;\n"
"\n"
"sqlda_t *sqlda1; /* дескриптор для выходных данных */\n"
"sqlda_t *sqlda2; /* дескриптор для входных данных */\n"
"\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"EXEC SQL WHENEVER SQLERROR STOP;\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char query[1024] = \"SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )\";\n"
"\n"
"    int intval;\n"
"    unsigned long long int longlongval;\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;\n"
"\n"
"    EXEC SQL PREPARE stmt1 FROM :query;\n"
"    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;\n"
"\n"
"    /* Создать структуру SQLDA для входных параметров */\n"
"    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));\n"
"    sqlda2-&gt;sqln = 2; /* число входных переменных */\n"
"\n"
"    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;\n"
"    sqlda2-&gt;sqlvar[0].sqldata = \"postgres\";\n"
"    sqlda2-&gt;sqlvar[0].sqllen  = 8;\n"
"\n"
"    intval = 1;\n"
"    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;\n"
"    sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;\n"
"    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);\n"
"\n"
"    /* Открыть курсор с входными параметрами. */\n"
"    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;\n"
"\n"
"    while (1)\n"
"    {\n"
"        sqlda_t *cur_sqlda;\n"
"\n"
"        /* Присвоить дескриптор курсору */\n"
"        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;\n"
"\n"
"        for (cur_sqlda = sqlda1 ;\n"
"             cur_sqlda != NULL ;\n"
"             cur_sqlda = cur_sqlda-&gt;desc_next)\n"
"        {\n"
"            int i;\n"
"            char name_buf[1024];\n"
"            char var_buf[1024];\n"
"\n"
"            /* Напечатать каждый столбец в строке. */\n"
"            for (i=0 ; i&lt;cur_sqlda-&gt;sqld ; i++)\n"
"            {\n"
"                sqlvar_t v = cur_sqlda-&gt;sqlvar[i];\n"
"                char *sqldata = v.sqldata;\n"
"                short sqllen  = v.sqllen;\n"
"\n"
"                strncpy(name_buf, v.sqlname.data, v.sqlname.length);\n"
"                name_buf[v.sqlname.length] = '\\0';\n"
"\n"
"                switch (v.sqltype)\n"
"                {\n"
"                    case ECPGt_char:\n"
"                        memset(&amp;var_buf, 0, sizeof(var_buf));\n"
"                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );\n"
"                        break;\n"
"\n"
"                    case ECPGt_int: /* integer */\n"
"                        memcpy(&amp;intval, sqldata, sqllen);\n"
"                        snprintf(var_buf, sizeof(var_buf), \"%d\", intval);\n"
"                        break;\n"
"\n"
"                    case ECPGt_long_long: /* bigint */\n"
"                        memcpy(&amp;longlongval, sqldata, sqllen);\n"
"                        snprintf(var_buf, sizeof(var_buf), \"%lld\", longlongval);\n"
"                        break;\n"
"\n"
"                    default:\n"
"                    {\n"
"                        int i;\n"
"                        memset(var_buf, 0, sizeof(var_buf));\n"
"                        for (i = 0; i &lt; sqllen; i++)\n"
"                        {\n"
"                            char tmpbuf[16];\n"
"                            snprintf(tmpbuf, sizeof(tmpbuf), \"%02x \", (unsigned char) sqldata[i]);\n"
"                            strncat(var_buf, tmpbuf, sizeof(var_buf));\n"
"                        }\n"
"                    }\n"
"                        break;\n"
"                }\n"
"\n"
"                printf(\"%s = %s (type: %d)\\n\", name_buf, var_buf, v.sqltype);\n"
"            }\n"
"\n"
"            printf(\"\\n\");\n"
"        }\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur1;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DISCONNECT ALL;\n"
"\n"
"    return 0;\n"
"}"

#: ecpg.xml:4543(para)
msgid ""
"The output of this example should look something like the following (some "
"numbers will vary)."
msgstr ""
"Вывод этой программы должен быть примерно таким (некоторые числа будут "
"меняться)."

#: ecpg.xml:4548(screen)
#, no-wrap
msgid ""
"oid = 1 (type: 1)\n"
"datname = template1 (type: 1)\n"
"datdba = 10 (type: 1)\n"
"encoding = 0 (type: 5)\n"
"datistemplate = t (type: 1)\n"
"datallowconn = t (type: 1)\n"
"datconnlimit = -1 (type: 5)\n"
"datlastsysoid = 11510 (type: 1)\n"
"datfrozenxid = 379 (type: 1)\n"
"dattablespace = 1663 (type: 1)\n"
"datconfig =  (type: 1)\n"
"datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)\n"
"datid = 1 (type: 1)\n"
"datname = template1 (type: 1)\n"
"numbackends = 0 (type: 5)\n"
"xact_commit = 113606 (type: 9)\n"
"xact_rollback = 0 (type: 9)\n"
"blks_read = 130 (type: 9)\n"
"blks_hit = 7341714 (type: 9)\n"
"tup_returned = 38262679 (type: 9)\n"
"tup_fetched = 1836281 (type: 9)\n"
"tup_inserted = 0 (type: 9)\n"
"tup_updated = 0 (type: 9)\n"
"tup_deleted = 0 (type: 9)\n"
"\n"
"oid = 11511 (type: 1)\n"
"datname = postgres (type: 1)\n"
"datdba = 10 (type: 1)\n"
"encoding = 0 (type: 5)\n"
"datistemplate = f (type: 1)\n"
"datallowconn = t (type: 1)\n"
"datconnlimit = -1 (type: 5)\n"
"datlastsysoid = 11510 (type: 1)\n"
"datfrozenxid = 379 (type: 1)\n"
"dattablespace = 1663 (type: 1)\n"
"datconfig =  (type: 1)\n"
"datacl =  (type: 1)\n"
"datid = 11511 (type: 1)\n"
"datname = postgres (type: 1)\n"
"numbackends = 0 (type: 5)\n"
"xact_commit = 221069 (type: 9)\n"
"xact_rollback = 18 (type: 9)\n"
"blks_read = 1176 (type: 9)\n"
"blks_hit = 13943750 (type: 9)\n"
"tup_returned = 77410091 (type: 9)\n"
"tup_fetched = 3253694 (type: 9)\n"
"tup_inserted = 0 (type: 9)\n"
"tup_updated = 0 (type: 9)\n"
"tup_deleted = 0 (type: 9)"
msgstr ""
"oid = 1 (type: 1)\n"
"datname = template1 (type: 1)\n"
"datdba = 10 (type: 1)\n"
"encoding = 0 (type: 5)\n"
"datistemplate = t (type: 1)\n"
"datallowconn = t (type: 1)\n"
"datconnlimit = -1 (type: 5)\n"
"datlastsysoid = 11510 (type: 1)\n"
"datfrozenxid = 379 (type: 1)\n"
"dattablespace = 1663 (type: 1)\n"
"datconfig =  (type: 1)\n"
"datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)\n"
"datid = 1 (type: 1)\n"
"datname = template1 (type: 1)\n"
"numbackends = 0 (type: 5)\n"
"xact_commit = 113606 (type: 9)\n"
"xact_rollback = 0 (type: 9)\n"
"blks_read = 130 (type: 9)\n"
"blks_hit = 7341714 (type: 9)\n"
"tup_returned = 38262679 (type: 9)\n"
"tup_fetched = 1836281 (type: 9)\n"
"tup_inserted = 0 (type: 9)\n"
"tup_updated = 0 (type: 9)\n"
"tup_deleted = 0 (type: 9)\n"
"\n"
"oid = 11511 (type: 1)\n"
"datname = postgres (type: 1)\n"
"datdba = 10 (type: 1)\n"
"encoding = 0 (type: 5)\n"
"datistemplate = f (type: 1)\n"
"datallowconn = t (type: 1)\n"
"datconnlimit = -1 (type: 5)\n"
"datlastsysoid = 11510 (type: 1)\n"
"datfrozenxid = 379 (type: 1)\n"
"dattablespace = 1663 (type: 1)\n"
"datconfig =  (type: 1)\n"
"datacl =  (type: 1)\n"
"datid = 11511 (type: 1)\n"
"datname = postgres (type: 1)\n"
"numbackends = 0 (type: 5)\n"
"xact_commit = 221069 (type: 9)\n"
"xact_rollback = 18 (type: 9)\n"
"blks_read = 1176 (type: 9)\n"
"blks_hit = 13943750 (type: 9)\n"
"tup_returned = 77410091 (type: 9)\n"
"tup_fetched = 3253694 (type: 9)\n"
"tup_inserted = 0 (type: 9)\n"
"tup_updated = 0 (type: 9)\n"
"tup_deleted = 0 (type: 9)"

#: ecpg.xml:4605(title)
msgid "Error Handling"
msgstr "Обработка ошибок"

#: ecpg.xml:4614(simpara)
msgid ""
"Callbacks can be configured to handle warning and error conditions using the "
"<literal>WHENEVER</literal> command."
msgstr ""
"Можно настроить функции-обработчики для обработки предупреждений и ошибок, "
"воспользовавшись командой <literal>WHENEVER</literal>."

#: ecpg.xml:4621(simpara)
msgid ""
"Detailed information about the error or warning can be obtained from the "
"<varname>sqlca</varname> variable."
msgstr ""
"Подробную информацию об ошибке или предупреждении можно получить через "
"переменную <varname>sqlca</varname>."

#: ecpg.xml:4607(para)
msgid ""
"This section describes how you can handle exceptional conditions and "
"warnings in an embedded SQL program. There are two nonexclusive facilities "
"for this. <placeholder-1/>"
msgstr ""
"В этом разделе описывается, как можно обрабатывать исключительные условия и "
"предупреждения в программе со встраиваемым SQL. Для этого предназначены два "
"средства, которые могут дополнять друг друга. <placeholder-1/>"

#: ecpg.xml:4630(title)
msgid "Setting Callbacks"
msgstr "Установка обработчиков"

#: ecpg.xml:4636(programlisting)
#, no-wrap
msgid "EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;"
msgstr "EXEC SQL WHENEVER <replaceable>условие</replaceable> <replaceable>действие</replaceable>;"

#: ecpg.xml:4632(para)
msgid ""
"One simple method to catch errors and warnings is to set a specific action "
"to be executed whenever a particular condition occurs. In general: "
"<placeholder-1/>"
msgstr ""
"Один простой метод перехвата ошибок и предупреждений заключается в "
"назначении определённого действия, которое будет выполняться при некотором "
"условии. В общем виде: <placeholder-1/>"

#: ecpg.xml:4646(literal)
msgid "SQLERROR"
msgstr "SQLERROR"

#: ecpg.xml:4648(para)
msgid ""
"The specified action is called whenever an error occurs during the execution "
"of an SQL statement."
msgstr ""
"Указанное действие вызывается, когда при выполнении оператора SQL происходит "
"ошибка."

#: ecpg.xml:4656(literal)
msgid "SQLWARNING"
msgstr "SQLWARNING"

#: ecpg.xml:4658(para)
msgid ""
"The specified action is called whenever a warning occurs during the "
"execution of an SQL statement."
msgstr ""
"Указанное действие вызывается, когда при выполнении оператора SQL выдаётся "
"предупреждение."

#: ecpg.xml:4666(literal)
msgid "NOT FOUND"
msgstr "NOT FOUND"

#: ecpg.xml:4668(para)
msgid ""
"The specified action is called whenever an SQL statement retrieves or "
"affects zero rows. (This condition is not an error, but you might be "
"interested in handling it specially.)"
msgstr ""
"Указанное действие вызывается, когда оператор SQL получает или обрабатывает "
"ноль строк. (Это обстоятельство не считается ошибкой, но бывает полезно "
"отследить его.)"

#: ecpg.xml:4641(para)
msgid ""
"<replaceable>condition</replaceable> can be one of the following: "
"<placeholder-1/>"
msgstr ""
"Здесь <replaceable>условие</replaceable> может быть следующим: "
"<placeholder-1/>"

#: ecpg.xml:4683(literal)
msgid "CONTINUE"
msgstr "CONTINUE"

#: ecpg.xml:4685(para)
msgid ""
"This effectively means that the condition is ignored. This is the default."
msgstr ""
"Это фактически означает, что условие игнорируется. Это поведение по "
"умолчанию."

#: ecpg.xml:4693(replaceable) ecpg.xml:4694(replaceable)
msgid "label"
msgstr "метка"

#: ecpg.xml:4693(literal)
msgid "GOTO <placeholder-1/>"
msgstr "GOTO <placeholder-1/>"

#: ecpg.xml:4694(literal)
msgid "GO TO <placeholder-1/>"
msgstr "GO TO <placeholder-1/>"

#: ecpg.xml:4696(para)
msgid ""
"Jump to the specified label (using a C <literal>goto</literal> statement)."
msgstr ""
"Перейти к указанной метке (используя оператор <literal>goto</literal> языка "
"C)."

#: ecpg.xml:4704(literal)
msgid "SQLPRINT"
msgstr "SQLPRINT"

#: ecpg.xml:4706(para)
msgid ""
"Print a message to standard error. This is useful for simple programs or "
"during prototyping. The details of the message cannot be configured."
msgstr ""
"Вывести сообщение в устройство стандартного вывода. Это полезно для простых "
"программ или при разработке прототипов. Содержание этого сообщения не "
"настраивается."

#: ecpg.xml:4715(literal)
msgid "STOP"
msgstr "STOP"

#: ecpg.xml:4717(para)
msgid "Call <literal>exit(1)</literal>, which will terminate the program."
msgstr ""
"Вызвать <literal>exit(1)</literal>, что приведёт к завершению программы."

#: ecpg.xml:4725(literal)
msgid "DO BREAK"
msgstr "DO BREAK"

#: ecpg.xml:4727(para)
msgid ""
"Execute the C statement <literal>break</literal>. This should only be used "
"in loops or <literal>switch</literal> statements."
msgstr ""
"Выполнить оператор <literal>break</literal> языка C. Этот вариант следует "
"использовать только в циклах или операторах <literal>switch</literal>."

#: ecpg.xml:4735(replaceable) ecpg.xml:4736(replaceable)
#: ecpg.xml:5580(replaceable) ecpg.xml:5591(replaceable)
#: ecpg.xml:5613(replaceable) ecpg.xml:6225(replaceable)
#: ecpg.xml:6249(replaceable) ecpg.xml:6514(replaceable)
#: ecpg.xml:6532(replaceable) ecpg.xml:7233(replaceable)
msgctxt "replaceable"
msgid "name"
msgstr "имя"

#: ecpg.xml:4735(replaceable) ecpg.xml:4736(replaceable)
msgid "args"
msgstr "аргументы"

#: ecpg.xml:4735(literal)
msgid "CALL <placeholder-1/> (<placeholder-2/>)"
msgstr "CALL <placeholder-1/> (<placeholder-2/>)"

#: ecpg.xml:4736(literal)
msgid "DO <placeholder-1/> (<placeholder-2/>)"
msgstr "DO <placeholder-1/> (<placeholder-2/>)"

#: ecpg.xml:4738(para)
msgid "Call the specified C functions with the specified arguments."
msgstr "Вызвать указанные функции C с заданными аргументами."

#: ecpg.xml:4678(para)
msgid ""
"<replaceable>action</replaceable> can be one of the following: "
"<placeholder-1/> The SQL standard only provides for the actions "
"<literal>CONTINUE</literal> and <literal>GOTO</literal> (and <literal>GO TO</"
"literal>)."
msgstr ""
"<replaceable>действие</replaceable> может быть следующим: <placeholder-1/> В "
"стандарте SQL описаны только действия <literal>CONTINUE</literal> и "
"<literal>GOTO</literal> (и <literal>GO TO</literal>)."

#: ecpg.xml:4754(programlisting)
#, no-wrap
msgid ""
"EXEC SQL WHENEVER SQLWARNING SQLPRINT;\n"
"EXEC SQL WHENEVER SQLERROR STOP;"
msgstr ""
"EXEC SQL WHENEVER SQLWARNING SQLPRINT;\n"
"EXEC SQL WHENEVER SQLERROR STOP;"

#: ecpg.xml:4750(para)
msgid ""
"Here is an example that you might want to use in a simple program. It prints "
"a simple message when a warning occurs and aborts the program when an error "
"happens: <placeholder-1/>"
msgstr ""
"Ниже показан простой пример использования этих команд. Эта конструкция "
"выводит простое сообщение при выдаче предупреждения и прерывает программу в "
"случае ошибки: <placeholder-1/>"

#: ecpg.xml:4770(programlisting)
#, no-wrap
msgid ""
"/*\n"
" * WRONG\n"
" */\n"
"int main(int argc, char *argv[])\n"
"{\n"
"    ...\n"
"    if (verbose) {\n"
"        EXEC SQL WHENEVER SQLWARNING SQLPRINT;\n"
"    }\n"
"    ...\n"
"    EXEC SQL SELECT ...;\n"
"    ...\n"
"}"
msgstr ""
"/*\n"
" * НЕПРАВИЛЬНО\n"
" */\n"
"int main(int argc, char *argv[])\n"
"{\n"
"    ...\n"
"    if (verbose) {\n"
"        EXEC SQL WHENEVER SQLWARNING SQLPRINT;\n"
"    }\n"
"    ...\n"
"    EXEC SQL SELECT ...;\n"
"    ...\n"
"}"

#: ecpg.xml:4786(programlisting)
#, no-wrap
msgid ""
"/*\n"
" * WRONG\n"
" */\n"
"int main(int argc, char *argv[])\n"
"{\n"
"    ...\n"
"    set_error_handler();\n"
"    ...\n"
"    EXEC SQL SELECT ...;\n"
"    ...\n"
"}\n"
"\n"
"static void set_error_handler(void)\n"
"{\n"
"    EXEC SQL WHENEVER SQLERROR STOP;\n"
"}"
msgstr ""
"/*\n"
" * НЕПРАВИЛЬНО\n"
" */\n"
"int main(int argc, char *argv[])\n"
"{\n"
"    ...\n"
"    set_error_handler();\n"
"    ...\n"
"    EXEC SQL SELECT ...;\n"
"    ...\n"
"}\n"
"\n"
"static void set_error_handler(void)\n"
"{\n"
"    EXEC SQL WHENEVER SQLERROR STOP;\n"
"}"

#: ecpg.xml:4760(para)
msgid ""
"The statement <literal>EXEC SQL WHENEVER</literal> is a directive of the SQL "
"preprocessor, not a C statement. The error or warning actions that it sets "
"apply to all embedded SQL statements that appear below the point where the "
"handler is set, unless a different action was set for the same condition "
"between the first <literal>EXEC SQL WHENEVER</literal> and the SQL statement "
"causing the condition, regardless of the flow of control in the C program. "
"So neither of the two following C program excerpts will have the desired "
"effect: <placeholder-1/> <placeholder-2/>"
msgstr ""
"Оператор <literal>EXEC SQL WHENEVER</literal> является директивой "
"препроцессора SQL, а не оператором языка C. Устанавливаемое им действие при "
"ошибках или предупреждениях применяется ко всем встраиваемым операторам SQL "
"ниже точки, где устанавливается обработчик, если только это действие не было "
"изменено после первой команды <literal>EXEC SQL WHENEVER</literal>, и до SQL-"
"оператора, вызвавшего это условие, вне зависимости от хода выполнения "
"программы на C. Поэтому обе следующие программы на C не дадут желаемого "
"эффекта: <placeholder-1/> <placeholder-2/>"

#: ecpg.xml:4808(title)
msgid "sqlca"
msgstr "sqlca"

#: ecpg.xml:4815(programlisting)
#, no-wrap
msgid ""
"struct\n"
"{\n"
"    char sqlcaid[8];\n"
"    long sqlabc;\n"
"    long sqlcode;\n"
"    struct\n"
"    {\n"
"        int sqlerrml;\n"
"        char sqlerrmc[SQLERRMC_LEN];\n"
"    } sqlerrm;\n"
"    char sqlerrp[8];\n"
"    long sqlerrd[6];\n"
"    char sqlwarn[8];\n"
"    char sqlstate[5];\n"
"} sqlca;"
msgstr ""
"struct\n"
"{\n"
"    char sqlcaid[8];\n"
"    long sqlabc;\n"
"    long sqlcode;\n"
"    struct\n"
"    {\n"
"        int sqlerrml;\n"
"        char sqlerrmc[SQLERRMC_LEN];\n"
"    } sqlerrm;\n"
"    char sqlerrp[8];\n"
"    long sqlerrd[6];\n"
"    char sqlwarn[8];\n"
"    char sqlstate[5];\n"
"} sqlca;"

#: ecpg.xml:4810(para)
msgid ""
"For more powerful error handling, the embedded SQL interface provides a "
"global variable with the name <varname>sqlca</varname> (SQL communication "
"area) that has the following structure: <placeholder-1/> (In a multithreaded "
"program, every thread automatically gets its own copy of <varname>sqlca</"
"varname>. This works similarly to the handling of the standard C global "
"variable <varname>errno</varname>.)"
msgstr ""
"Для более гибкой обработки ошибок в интерфейсе встраиваемого SQL "
"представлена глобальная переменная с именем <varname>sqlca</varname> (SQL "
"Communication Area, Область сведений SQL), имеющая следующую структуру: "
"<placeholder-1/> (В многопоточной программе каждый поток автоматически "
"получает собственную копию <varname>sqlca</varname>. Это работает подобно "
"стандартной в C глобальной переменной <varname>errno</varname>.)"

#: ecpg.xml:4838(para)
msgid ""
"<varname>sqlca</varname> covers both warnings and errors. If multiple "
"warnings or errors occur during the execution of a statement, then "
"<varname>sqlca</varname> will only contain information about the last one."
msgstr ""
"Структура <varname>sqlca</varname> покрывает и предупреждения, и ошибки. "
"Если в процессе выполнения оператора выдаётся несколько предупреждений или "
"ошибок, <varname>sqlca</varname> будет содержать сведения только о "
"последнем(ей) из них."

#: ecpg.xml:4845(para)
msgid ""
"If no error occurred in the last <acronym>SQL</acronym> statement, "
"<literal>sqlca.sqlcode</literal> will be 0 and <literal>sqlca.sqlstate</"
"literal> will be <literal>\"00000\"</literal>. If a warning or error "
"occurred, then <literal>sqlca.sqlcode</literal> will be negative and "
"<literal>sqlca.sqlstate</literal> will be different from <literal>\"00000\"</"
"literal>. A positive <literal>sqlca.sqlcode</literal> indicates a harmless "
"condition, such as that the last query returned zero rows. <literal>sqlcode</"
"literal> and <literal>sqlstate</literal> are two different error code "
"schemes; details appear below."
msgstr ""
"Если последний оператор <acronym>SQL</acronym> выполняется без ошибки, "
"<literal>sqlca.sqlcode</literal> будет содержать 0, а <literal>sqlca."
"sqlstate</literal> — <literal>\"00000\"</literal>. Если выдаётся "
"предупреждение или ошибка, в <literal>sqlca.sqlcode</literal> будет "
"содержаться отрицательное число, а <literal>sqlca.sqlstate</literal> будет "
"отличаться от <literal>\"00000\"</literal>. Положительное значение "
"<literal>sqlca.sqlcode</literal> устанавливается при нейтральном событии, "
"например, когда последний запрос возвращает ноль строк. Поля "
"<literal>sqlcode</literal> и <literal>sqlstate</literal> представляют две "
"различные схемы кодов ошибок; подробнее они описаны ниже."

#: ecpg.xml:4859(para)
msgid ""
"If the last SQL statement was successful, then <literal>sqlca.sqlerrd[1]</"
"literal> contains the OID of the processed row, if applicable, and "
"<literal>sqlca.sqlerrd[2]</literal> contains the number of processed or "
"returned rows, if applicable to the command."
msgstr ""
"Если последний оператор SQL был успешным, в <literal>sqlca.sqlerrd[1]</"
"literal> содержится OID обработанной строки (если это уместно), а в "
"<literal>sqlca.sqlerrd[2]</literal> количество обработанных или возвращённых "
"строк (если это уместно для команды)."

#: ecpg.xml:4867(para)
msgid ""
"In case of an error or warning, <literal>sqlca.sqlerrm.sqlerrmc</literal> "
"will contain a string that describes the error. The field <literal>sqlca."
"sqlerrm.sqlerrml</literal> contains the length of the error message that is "
"stored in <literal>sqlca.sqlerrm.sqlerrmc</literal> (the result of "
"<function>strlen()</function>, not really interesting for a C programmer). "
"Note that some messages are too long to fit in the fixed-size "
"<literal>sqlerrmc</literal> array; they will be truncated."
msgstr ""
"В случае ошибки или предупреждения <literal>sqlca.sqlerrm.sqlerrmc</literal> "
"будет содержать строку, описывающую ошибку. Поле <literal>sqlca.sqlerrm."
"sqlerrml</literal> содержит длину сообщения об ошибке, которое хранится в "
"<literal>sqlca.sqlerrm.sqlerrmc</literal> (результат функции "
"<function>strlen()</function>, который не очень интересен для программиста "
"C). Заметьте, что некоторые сообщения могут не умещаться в массив "
"<literal>sqlerrmc</literal> фиксированного размера; они будут обрезаться."

#: ecpg.xml:4879(para)
msgid ""
"In case of a warning, <literal>sqlca.sqlwarn[2]</literal> is set to "
"<literal>W</literal>. (In all other cases, it is set to something different "
"from <literal>W</literal>.) If <literal>sqlca.sqlwarn[1]</literal> is set to "
"<literal>W</literal>, then a value was truncated when it was stored in a "
"host variable. <literal>sqlca.sqlwarn[0]</literal> is set to <literal>W</"
"literal> if any of the other elements are set to indicate a warning."
msgstr ""
"В случае предупреждения, в <literal>sqlca.sqlwarn[2]</literal> записывается "
"символ <literal>W</literal>. (Во всех других случаях значение будет отличным "
"от <literal>W</literal>.) Символ <literal>W</literal> в <literal>sqlca."
"sqlwarn[1]</literal> показывает, что значение было обрезано при сохранении в "
"переменной среды. <literal>W</literal> в <literal>sqlca.sqlwarn[0]</literal> "
"устанавливается, если предупреждение отмечается в каком-либо другом элементе "
"массива."

#: ecpg.xml:4890(para)
msgid ""
"The fields <structfield>sqlcaid</structfield>, <structfield>sqlcabc</"
"structfield>, <structfield>sqlerrp</structfield>, and the remaining elements "
"of <structfield>sqlerrd</structfield> and <structfield>sqlwarn</structfield> "
"currently contain no useful information."
msgstr ""
"Поля <structfield>sqlcaid</structfield>, <structfield>sqlcabc</structfield>, "
"<structfield>sqlerrp</structfield> и остальные элементы "
"<structfield>sqlerrd</structfield> и <structfield>sqlwarn</structfield> в "
"настоящее время не содержат полезной информации."

#: ecpg.xml:4899(para)
msgid ""
"The structure <varname>sqlca</varname> is not defined in the SQL standard, "
"but is implemented in several other SQL database systems. The definitions "
"are similar at the core, but if you want to write portable applications, "
"then you should investigate the different implementations carefully."
msgstr ""
"Структура <varname>sqlca</varname> не определена в стандарте SQL, но "
"реализована в нескольких других СУБД SQL. Принципиально она определяется "
"одинаково, но если вы хотите, чтобы ваши приложения были переносимыми, "
"тщательно изучите различия реализаций."

#: ecpg.xml:4914(programlisting)
#, no-wrap
msgid ""
"EXEC SQL WHENEVER SQLERROR CALL print_sqlca();\n"
"\n"
"void\n"
"print_sqlca()\n"
"{\n"
"    fprintf(stderr, \"==== sqlca ====\\n\");\n"
"    fprintf(stderr, \"sqlcode: %ld\\n\", sqlca.sqlcode);\n"
"    fprintf(stderr, \"sqlerrm.sqlerrml: %d\\n\", sqlca.sqlerrm.sqlerrml);\n"
"    fprintf(stderr, \"sqlerrm.sqlerrmc: %s\\n\", sqlca.sqlerrm.sqlerrmc);\n"
"    fprintf(stderr, \"sqlerrd: %ld %ld %ld %ld %ld %ld\\n\", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],\n"
"                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);\n"
"    fprintf(stderr, \"sqlwarn: %d %d %d %d %d %d %d %d\\n\", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],\n"
"                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],\n"
"                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);\n"
"    fprintf(stderr, \"sqlstate: %5s\\n\", sqlca.sqlstate);\n"
"    fprintf(stderr, \"===============\\n\");\n"
"}"
msgstr ""
"EXEC SQL WHENEVER SQLERROR CALL print_sqlca();\n"
"\n"
"void\n"
"print_sqlca()\n"
"{\n"
"    fprintf(stderr, \"==== sqlca ====\\n\");\n"
"    fprintf(stderr, \"sqlcode: %ld\\n\", sqlca.sqlcode);\n"
"    fprintf(stderr, \"sqlerrm.sqlerrml: %d\\n\", sqlca.sqlerrm.sqlerrml);\n"
"    fprintf(stderr, \"sqlerrm.sqlerrmc: %s\\n\", sqlca.sqlerrm.sqlerrmc);\n"
"    fprintf(stderr, \"sqlerrd: %ld %ld %ld %ld %ld %ld\\n\", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],\n"
"                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);\n"
"    fprintf(stderr, \"sqlwarn: %d %d %d %d %d %d %d %d\\n\", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],\n"
"                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],\n"
"                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);\n"
"    fprintf(stderr, \"sqlstate: %5s\\n\", sqlca.sqlstate);\n"
"    fprintf(stderr, \"===============\\n\");\n"
"}"

#: ecpg.xml:4907(para)
msgid ""
"Here is one example that combines the use of <literal>WHENEVER</literal> and "
"<varname>sqlca</varname>, printing out the contents of <varname>sqlca</"
"varname> when an error occurs. This is perhaps useful for debugging or "
"prototyping applications, before installing a more <quote>user-friendly</"
"quote> error handler. <placeholder-1/> The result could look as follows "
"(here an error due to a misspelled table name): <screen>\n"
"==== sqlca ====\n"
"sqlcode: -400\n"
"sqlerrm.sqlerrml: 49\n"
"sqlerrm.sqlerrmc: relation \"pg_databasep\" does not exist on line 38\n"
"sqlerrd: 0 0 0 0 0 0\n"
"sqlwarn: 0 0 0 0 0 0 0 0\n"
"sqlstate: 42P01\n"
"===============\n"
"</screen>"
msgstr ""
"В следующем примере, демонстрирующем применение <literal>WHENEVER</literal> "
"в сочетании с <varname>sqlca</varname>, выводится содержимое <varname>sqlca</"
"varname> при возникновении ошибки. Это может быть полезно для отладки или в "
"прототипах, пока не реализован более <quote>дружественный пользователю</"
"quote> обработчик ошибок. <placeholder-1/> Результат может выглядеть "
"следующим образом (при ошибке, вызванной опечаткой в имени таблицы): "
"<screen>\n"
"==== sqlca ====\n"
"sqlcode: -400\n"
"sqlerrm.sqlerrml: 49\n"
"sqlerrm.sqlerrmc: relation \"pg_databasep\" does not exist on line 38\n"
"sqlerrd: 0 0 0 0 0 0\n"
"sqlwarn: 0 0 0 0 0 0 0 0\n"
"sqlstate: 42P01\n"
"===============\n"
"</screen>"

#: ecpg.xml:4951(title)
msgid "<literal>SQLSTATE</literal> vs. <literal>SQLCODE</literal>"
msgstr "<literal>SQLSTATE</literal> и <literal>SQLCODE</literal>"

#: ecpg.xml:4953(para)
msgid ""
"The fields <literal>sqlca.sqlstate</literal> and <literal>sqlca.sqlcode</"
"literal> are two different schemes that provide error codes. Both are "
"derived from the SQL standard, but <literal>SQLCODE</literal> has been "
"marked deprecated in the SQL-92 edition of the standard and has been dropped "
"in later editions. Therefore, new applications are strongly encouraged to "
"use <literal>SQLSTATE</literal>."
msgstr ""
"Поля <literal>sqlca.sqlstate</literal> и <literal>sqlca.sqlcode</literal> "
"отражают две различные схемы, представляющие коды ошибок. Обе схемы пришли "
"из стандарта SQL, но схема <literal>SQLCODE</literal> была признана "
"устаревшей в редакции SQL-92 и исключена в последующих редакциях. Поэтому в "
"новых приложениях настоятельно рекомендуется использовать <literal>SQLSTATE</"
"literal>."

#: ecpg.xml:4963(para)
msgid ""
"<literal>SQLSTATE</literal> is a five-character array. The five characters "
"contain digits or upper-case letters that represent codes of various error "
"and warning conditions. <literal>SQLSTATE</literal> has a hierarchical "
"scheme: the first two characters indicate the general class of the "
"condition, the last three characters indicate a subclass of the general "
"condition. A successful state is indicated by the code <literal>00000</"
"literal>. The <literal>SQLSTATE</literal> codes are for the most part "
"defined in the SQL standard. The <productname>PostgreSQL</productname> "
"server natively supports <literal>SQLSTATE</literal> error codes; therefore "
"a high degree of consistency can be achieved by using this error code scheme "
"throughout all applications. For further information see <xref linkend="
"\"errcodes-appendix\"/>."
msgstr ""
"<literal>SQLSTATE</literal> задаётся в массиве из пяти символов. Эти пять "
"символов содержат цифры или буквы в верхнем регистре, представляющие коды "
"различных условий ошибок и предупреждений. <literal>SQLSTATE</literal> "
"определяется по иерархической схеме: первые два символа обозначают общий "
"класс условия, а следующие три — подкласс общего условия. Успешное состояние "
"обозначается кодом <literal>00000</literal>. По большей части коды "
"<literal>SQLSTATE</literal> определены в стандарте SQL. Сервер "
"<productname>PostgreSQL</productname> поддерживает коды ошибок "
"<literal>SQLSTATE</literal> естественным образом; поэтому используя во всех "
"приложениях именно эту схему кодов ошибок, можно добиться высокой степени "
"согласованности. За дальнейшими сведениями обратитесь к <xref remap=\"3\" "
"linkend=\"errcodes-appendix\"/>."

#: ecpg.xml:4980(para)
msgid ""
"<literal>SQLCODE</literal>, the deprecated error code scheme, is a simple "
"integer. A value of 0 indicates success, a positive value indicates success "
"with additional information, a negative value indicates an error. The SQL "
"standard only defines the positive value +100, which indicates that the last "
"command returned or affected zero rows, and no specific negative values. "
"Therefore, this scheme can only achieve poor portability and does not have a "
"hierarchical code assignment. Historically, the embedded SQL processor for "
"<productname>PostgreSQL</productname> has assigned some specific "
"<literal>SQLCODE</literal> values for its use, which are listed below with "
"their numeric value and their symbolic name. Remember that these are not "
"portable to other SQL implementations. To simplify the porting of "
"applications to the <literal>SQLSTATE</literal> scheme, the corresponding "
"<literal>SQLSTATE</literal> is also listed. There is, however, no one-to-one "
"or one-to-many mapping between the two schemes (indeed it is many-to-many), "
"so you should consult the global <literal>SQLSTATE</literal> listing in "
"<xref linkend=\"errcodes-appendix\"/> in each case."
msgstr ""
"<literal>SQLCODE</literal> — устаревшая схема, в которой коды ошибок "
"представлены просто целыми числами. Значение 0 обозначает успешное "
"завершение, положительное значение — успешное завершение с дополнительной "
"информацией, а отрицательное говорит об ошибке. В стандарте SQL определено "
"только положительное значение +100, показывающее, что последняя команда "
"вернула или затронула ноль строк, но отрицательные значения не определены. "
"Таким образом, с этой схемой нельзя рассчитывать на переносимость и она не "
"имеет иерархической структуры. Исторически сложилось, что процессор "
"встраиваемого SQL для <productname>PostgreSQL</productname> назначает "
"некоторые определённые значения <literal>SQLCODE</literal> для собственного "
"использования; они перечислены ниже с числовыми значениями и символьными "
"именами. Помните, что эти коды несовместимы с другими реализациями SQL. "
"Поэтому для упрощения перевода приложений на схему <literal>SQLSTATE</"
"literal> вместе с этими кодами перечисляются соответствующие значения "
"<literal>SQLSTATE</literal>. Однако однозначного соответствия один-к-одному "
"или один-ко-многим между этими двумя схемами не существует (на самом деле "
"это соответствие многие-ко-многим), поэтому следует свериться со списком "
"<literal>SQLSTATE</literal> в <xref remap=\"6\" linkend=\"errcodes-appendix"
"\"/> в каждом случае."

#: ecpg.xml:5007(term)
msgid "0 (<symbol>ECPG_NO_ERROR</symbol>)"
msgstr "0 (<symbol>ECPG_NO_ERROR</symbol>)"

#: ecpg.xml:5009(para)
msgid "Indicates no error. (SQLSTATE 00000)"
msgstr "Показывает, что ошибки нет. (SQLSTATE 00000)"

#: ecpg.xml:5016(term)
msgid "100 (<symbol>ECPG_NOT_FOUND</symbol>)"
msgstr "100 (<symbol>ECPG_NOT_FOUND</symbol>)"

#: ecpg.xml:5018(para)
msgid ""
"This is a harmless condition indicating that the last command retrieved or "
"processed zero rows, or that you are at the end of the cursor. (SQLSTATE "
"02000)"
msgstr ""
"Это нейтральное условие, показывающее, что последняя команда вернула или "
"обработала ноль строк, либо курсор достиг конца. (SQLSTATE 02000)"

#: ecpg.xml:5027(programlisting)
#, no-wrap
msgid ""
"while (1)\n"
"{\n"
"    EXEC SQL FETCH ... ;\n"
"    if (sqlca.sqlcode == ECPG_NOT_FOUND)\n"
"        break;\n"
"}"
msgstr ""
"while (1)\n"
"{\n"
"    EXEC SQL FETCH ... ;\n"
"    if (sqlca.sqlcode == ECPG_NOT_FOUND)\n"
"        break;\n"
"}"

#: ecpg.xml:5024(para)
msgid ""
"When processing a cursor in a loop, you could use this code as a way to "
"detect when to abort the loop, like this: <placeholder-1/> But "
"<literal>WHENEVER NOT FOUND DO BREAK</literal> effectively does this "
"internally, so there is usually no advantage in writing this out explicitly."
msgstr ""
"Выбирая данные из курсора в цикле, можно проверять этот код, чтобы понять, "
"когда нужно прервать цикл, следующим образом: <placeholder-1/> Но "
"<literal>WHENEVER NOT FOUND DO BREAK</literal> внутри по сути делает это же, "
"поэтому такое явное условие обычно ничем не лучше."

#: ecpg.xml:5043(term)
msgid "-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)"
msgstr "-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)"

#: ecpg.xml:5045(para)
msgid ""
"Indicates that your virtual memory is exhausted. The numeric value is "
"defined as <literal>-ENOMEM</literal>. (SQLSTATE YE001)"
msgstr ""
"Указывает, что закончилась виртуальная память. Числовое значение определено "
"как <literal>-ENOMEM</literal>. (SQLSTATE YE001)"

#: ecpg.xml:5054(term)
msgid "-200 (<symbol>ECPG_UNSUPPORTED</symbol>)"
msgstr "-200 (<symbol>ECPG_UNSUPPORTED</symbol>)"

#: ecpg.xml:5056(para)
msgid ""
"Indicates the preprocessor has generated something that the library does not "
"know about. Perhaps you are running incompatible versions of the "
"preprocessor and the library. (SQLSTATE YE002)"
msgstr ""
"Указывает, что препроцессор сгенерировал код, который не понимает "
"библиотека. Возможно, вы используете несовместимые версии препроцессора и "
"библиотеки. (SQLSTATE YE002)"

#: ecpg.xml:5066(term)
msgid "-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)"
msgstr "-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)"

#: ecpg.xml:5068(para)
msgid ""
"This means that the command specified more host variables than the command "
"expected. (SQLSTATE 07001 or 07002)"
msgstr ""
"Это означает, что в команде было указано больше переменных среды, чем она "
"ожидает. (SQLSTATE 07001 или 07002)"

#: ecpg.xml:5076(term)
msgid "-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)"
msgstr "-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)"

#: ecpg.xml:5078(para)
msgid ""
"This means that the command specified fewer host variables than the command "
"expected. (SQLSTATE 07001 or 07002)"
msgstr ""
"Это означает, что в команде было указано меньше переменных среды, чем она "
"ожидает. (SQLSTATE 07001 или 07002)"

#: ecpg.xml:5086(term)
msgid "-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)"
msgstr "-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)"

#: ecpg.xml:5088(para)
msgid ""
"This means a query has returned multiple rows but the statement was only "
"prepared to store one result row (for example, because the specified "
"variables are not arrays). (SQLSTATE 21000)"
msgstr ""
"Это означает, что запрос вернул несколько строк, но оператор был подготовлен "
"только для одной строки результата (например, потому что переданные "
"переменные — не массивы). (SQLSTATE 21000)"

#: ecpg.xml:5097(term)
msgid "-204 (<symbol>ECPG_INT_FORMAT</symbol>)"
msgstr "-204 (<symbol>ECPG_INT_FORMAT</symbol>)"

#: ecpg.xml:5099(para)
msgid ""
"The host variable is of type <type>int</type> and the datum in the database "
"is of a different type and contains a value that cannot be interpreted as an "
"<type>int</type>. The library uses <function>strtol()</function> for this "
"conversion. (SQLSTATE 42804)"
msgstr ""
"Переменная среды типа <type>int</type> и данные в базе имеют разные типы, и "
"в этих данных содержится значение, которое нельзя преобразовать в <type>int</"
"type>. Для этого преобразования библиотека использует функцию "
"<function>strtol()</function>. (SQLSTATE 42804)"

#: ecpg.xml:5110(term)
msgid "-205 (<symbol>ECPG_UINT_FORMAT</symbol>)"
msgstr "-205 (<symbol>ECPG_UINT_FORMAT</symbol>)"

#: ecpg.xml:5112(para)
msgid ""
"The host variable is of type <type>unsigned int</type> and the datum in the "
"database is of a different type and contains a value that cannot be "
"interpreted as an <type>unsigned int</type>. The library uses "
"<function>strtoul()</function> for this conversion. (SQLSTATE 42804)"
msgstr ""
"Переменная среды типа <type>unsigned int</type> и данные в базе имеют разные "
"типы, и в этих данных содержится значение, которое нельзя преобразовать в "
"<type>unsigned int</type>. Для этого преобразования библиотека использует "
"функцию <function>strtoul()</function>. (SQLSTATE 42804)"

#: ecpg.xml:5123(term)
msgid "-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)"
msgstr "-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)"

#: ecpg.xml:5125(para)
msgid ""
"The host variable is of type <type>float</type> and the datum in the "
"database is of another type and contains a value that cannot be interpreted "
"as a <type>float</type>. The library uses <function>strtod()</function> for "
"this conversion. (SQLSTATE 42804)"
msgstr ""
"Переменная среды типа <type>float</type> и данные в базе имеют разные типы, "
"и в этих данных содержится значение, которое нельзя преобразовать во "
"<type>float</type>. Для этого преобразования библиотека использует функцию "
"<function>strtod()</function>. (SQLSTATE 42804)"

#: ecpg.xml:5136(term)
msgid "-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)"
msgstr "-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)"

#: ecpg.xml:5138(para)
msgid ""
"The host variable is of type <type>numeric</type> and the datum in the "
"database is of another type and contains a value that cannot be interpreted "
"as a <type>numeric</type> value. (SQLSTATE 42804)"
msgstr ""
"Переменная среды типа <type>numeric</type> и данные в базе имеют разные "
"типы, и в этих данных содержится значение, которое нельзя преобразовать в "
"<type>numeric</type>. (SQLSTATE 42804)"

#: ecpg.xml:5148(term)
msgid "-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)"
msgstr "-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)"

#: ecpg.xml:5150(para)
msgid ""
"The host variable is of type <type>interval</type> and the datum in the "
"database is of another type and contains a value that cannot be interpreted "
"as an <type>interval</type> value. (SQLSTATE 42804)"
msgstr ""
"Переменная среды типа <type>interval</type> и данные в базе имеют разные "
"типы, и в этих данных содержится значение, которое нельзя преобразовать в "
"<type>interval</type>. (SQLSTATE 42804)"

#: ecpg.xml:5160(term)
msgid "-209 (<symbol>ECPG_DATE_FORMAT</symbol>)"
msgstr "-209 (<symbol>ECPG_DATE_FORMAT</symbol>)"

#: ecpg.xml:5162(para)
msgid ""
"The host variable is of type <type>date</type> and the datum in the database "
"is of another type and contains a value that cannot be interpreted as a "
"<type>date</type> value. (SQLSTATE 42804)"
msgstr ""
"Переменная среды типа <type>date</type> и данные в базе имеют разные типы, и "
"в этих данных содержится значение, которое нельзя преобразовать в "
"<type>date</type>. (SQLSTATE 42804)"

#: ecpg.xml:5172(term)
msgid "-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)"
msgstr "-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)"

#: ecpg.xml:5174(para)
msgid ""
"The host variable is of type <type>timestamp</type> and the datum in the "
"database is of another type and contains a value that cannot be interpreted "
"as a <type>timestamp</type> value. (SQLSTATE 42804)"
msgstr ""
"Переменная среды типа <type>timestamp</type> и данные в базе имеют разные "
"типы, и в этих данных содержится значение, которое нельзя преобразовать в "
"<type>timestamp</type>. (SQLSTATE 42804)"

#: ecpg.xml:5184(term)
msgid "-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)"
msgstr "-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)"

#: ecpg.xml:5186(para)
msgid ""
"This means the host variable is of type <type>bool</type> and the datum in "
"the database is neither <literal>'t'</literal> nor <literal>'f'</literal>. "
"(SQLSTATE 42804)"
msgstr ""
"Это означает, что переменная среды имеет тип <type>bool</type>, а значение в "
"базе данных отличается от <literal>'t'</literal> или <literal>'f'</literal>. "
"(SQLSTATE 42804)"

#: ecpg.xml:5195(term)
msgid "-212 (<symbol>ECPG_EMPTY</symbol>)"
msgstr "-212 (<symbol>ECPG_EMPTY</symbol>)"

#: ecpg.xml:5197(para)
msgid ""
"The statement sent to the <productname>PostgreSQL</productname> server was "
"empty. (This cannot normally happen in an embedded SQL program, so it might "
"point to an internal error.) (SQLSTATE YE002)"
msgstr ""
"Серверу <productname>PostgreSQL</productname> был передан пустой оператор. "
"(Этого обычно не должно происходить в программе со встраиваемым SQL, так что "
"это может указывать на внутреннюю ошибку.) (SQLSTATE YE002)"

#: ecpg.xml:5207(term)
msgid "-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)"
msgstr "-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)"

#: ecpg.xml:5209(para)
msgid ""
"A null value was returned and no null indicator variable was supplied. "
"(SQLSTATE 22002)"
msgstr ""
"Возвращено значение NULL, но переменная-индикатор NULL не задана. (SQLSTATE "
"22002)"

#: ecpg.xml:5217(term)
msgid "-214 (<symbol>ECPG_NO_ARRAY</symbol>)"
msgstr "-214 (<symbol>ECPG_NO_ARRAY</symbol>)"

#: ecpg.xml:5219(para)
msgid ""
"An ordinary variable was used in a place that requires an array. (SQLSTATE "
"42804)"
msgstr ""
"Там, где требуется массив, была передана обычная переменная. (SQLSTATE 42804)"

#: ecpg.xml:5227(term)
msgid "-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)"
msgstr "-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)"

#: ecpg.xml:5229(para)
msgid ""
"The database returned an ordinary variable in a place that requires array "
"value. (SQLSTATE 42804)"
msgstr ""
"База данных возвратила обычную переменную там, где требуется значение-"
"массив. (SQLSTATE 42804)"

#: ecpg.xml:5237(term)
msgid "-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)"
msgstr "-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)"

#: ecpg.xml:5239(para)
msgid "The value could not be inserted into the array. (SQLSTATE 42804)"
msgstr "Не удалось вставить значение в массив. (SQLSTATE 42804)"

#: ecpg.xml:5247(term)
msgid "-220 (<symbol>ECPG_NO_CONN</symbol>)"
msgstr "-220 (<symbol>ECPG_NO_CONN</symbol>)"

#: ecpg.xml:5249(para)
msgid ""
"The program tried to access a connection that does not exist. (SQLSTATE "
"08003)"
msgstr ""
"Программа попыталась использовать несуществующее подключение. (SQLSTATE "
"08003)"

#: ecpg.xml:5257(term)
msgid "-221 (<symbol>ECPG_NOT_CONN</symbol>)"
msgstr "-221 (<symbol>ECPG_NOT_CONN</symbol>)"

#: ecpg.xml:5259(para)
msgid ""
"The program tried to access a connection that does exist but is not open. "
"(This is an internal error.) (SQLSTATE YE002)"
msgstr ""
"Программа попыталась использовать подключение, которое существует, но не "
"было открыто. (Это внутренняя ошибка.) (SQLSTATE YE002)"

#: ecpg.xml:5267(term)
msgid "-230 (<symbol>ECPG_INVALID_STMT</symbol>)"
msgstr "-230 (<symbol>ECPG_INVALID_STMT</symbol>)"

#: ecpg.xml:5269(para)
msgid ""
"The statement you are trying to use has not been prepared. (SQLSTATE 26000)"
msgstr ""
"Оператор, который вы пытаетесь выполнить, не был подготовлен. (SQLSTATE "
"26000)"

#: ecpg.xml:5277(term)
msgid "-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)"
msgstr "-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)"

#: ecpg.xml:5279(para)
msgid ""
"Duplicate key error, violation of unique constraint (Informix compatibility "
"mode). (SQLSTATE 23505)"
msgstr ""
"Ошибка повторяющегося ключа, нарушение ограничения уникальности (режим "
"совместимости с Informix). (SQLSTATE 23505)"

#: ecpg.xml:5287(term)
msgid "-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)"
msgstr "-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)"

#: ecpg.xml:5289(para)
msgid ""
"The descriptor specified was not found. The statement you are trying to use "
"has not been prepared. (SQLSTATE 33000)"
msgstr ""
"Указанный дескриптор не найден. Оператор, который вы пытаетесь использовать, "
"не был подготовлен. (SQLSTATE 33000)"

#: ecpg.xml:5297(term)
msgid "-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)"
msgstr "-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)"

#: ecpg.xml:5299(para)
msgid "The descriptor index specified was out of range. (SQLSTATE 07009)"
msgstr "Указанный индекс дескриптора вне диапазона. (SQLSTATE 07009)"

#: ecpg.xml:5307(term)
msgid "-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)"
msgstr "-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)"

#: ecpg.xml:5309(para)
msgid ""
"An invalid descriptor item was requested. (This is an internal error.) "
"(SQLSTATE YE002)"
msgstr ""
"Запрошен неверный элемент дескриптора. (Это внутренняя ошибка.) (SQLSTATE "
"YE002)"

#: ecpg.xml:5317(term)
msgid "-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)"
msgstr "-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)"

#: ecpg.xml:5319(para)
msgid ""
"During the execution of a dynamic statement, the database returned a numeric "
"value and the host variable was not numeric. (SQLSTATE 07006)"
msgstr ""
"При выполнении динамического оператора база данных возвратила числовое "
"значение, тогда как переменная среды — не числовая. (SQLSTATE 07006)"

#: ecpg.xml:5328(term)
msgid "-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)"
msgstr "-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)"

#: ecpg.xml:5330(para)
msgid ""
"During the execution of a dynamic statement, the database returned a non-"
"numeric value and the host variable was numeric. (SQLSTATE 07006)"
msgstr ""
"При выполнении динамического оператора база данных возвратила не числовое "
"значение, тогда как переменная среды — числовая. (SQLSTATE 07006)"

#: ecpg.xml:5339(term)
msgid "-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)"
msgstr "-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)"

#: ecpg.xml:5341(para)
msgid ""
"A result of the subquery is not single row (Informix compatibility mode). "
"(SQLSTATE 21000)"
msgstr ""
"Результат подзапроса представлен не одной строкой (режим совместимости с "
"Informix). (SQLSTATE 21000)"

#: ecpg.xml:5349(term)
msgid "-400 (<symbol>ECPG_PGSQL</symbol>)"
msgstr "-400 (<symbol>ECPG_PGSQL</symbol>)"

#: ecpg.xml:5351(para)
msgid ""
"Some error caused by the <productname>PostgreSQL</productname> server. The "
"message contains the error message from the <productname>PostgreSQL</"
"productname> server."
msgstr ""
"Ошибка произошла на стороне сервера <productname>PostgreSQL</productname>. В "
"тексте ошибки содержится сообщение об ошибке от сервера "
"<productname>PostgreSQL</productname>."

#: ecpg.xml:5360(term)
msgid "-401 (<symbol>ECPG_TRANS</symbol>)"
msgstr "-401 (<symbol>ECPG_TRANS</symbol>)"

#: ecpg.xml:5362(para)
msgid ""
"The <productname>PostgreSQL</productname> server signaled that we cannot "
"start, commit, or rollback the transaction. (SQLSTATE 08007)"
msgstr ""
"Сервер <productname>PostgreSQL</productname> сообщает, что клиент не может "
"запускать, фиксировать или отменять транзакцию. (SQLSTATE 08007)"

#: ecpg.xml:5371(term)
msgid "-402 (<symbol>ECPG_CONNECT</symbol>)"
msgstr "-402 (<symbol>ECPG_CONNECT</symbol>)"

#: ecpg.xml:5373(para)
msgid ""
"The connection attempt to the database did not succeed. (SQLSTATE 08001)"
msgstr "Попытка подключения к базе данных была неудачной. (SQLSTATE 08001)"

#: ecpg.xml:5381(term)
msgid "-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)"
msgstr "-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)"

#: ecpg.xml:5383(para)
msgid "Duplicate key error, violation of unique constraint. (SQLSTATE 23505)"
msgstr ""
"Ошибка повторяющегося ключа, нарушение ограничения уникальности. (SQLSTATE "
"23505)"

#: ecpg.xml:5391(term)
msgid "-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)"
msgstr "-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)"

#: ecpg.xml:5393(para)
msgid "A result for the subquery is not single row. (SQLSTATE 21000)"
msgstr "Результат подзапроса представлен не одной строкой. (SQLSTATE 21000)"

#: ecpg.xml:5422(term)
msgid "-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)"
msgstr "-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)"

#: ecpg.xml:5424(para)
msgid "An invalid cursor name was specified. (SQLSTATE 34000)"
msgstr "Указано неверное имя курсора. (SQLSTATE 34000)"

#: ecpg.xml:5431(term)
msgid "-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)"
msgstr "-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)"

#: ecpg.xml:5433(para)
msgid "Transaction is in progress. (SQLSTATE 25001)"
msgstr "Транзакция в процессе выполнения. (SQLSTATE 25001)"

#: ecpg.xml:5440(term)
msgid "-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)"
msgstr "-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)"

#: ecpg.xml:5442(para)
msgid "There is no active (in-progress) transaction. (SQLSTATE 25P01)"
msgstr "Нет активной (выполняющейся) транзакции. (SQLSTATE 25P01)"

#: ecpg.xml:5449(term)
msgid "-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)"
msgstr "-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)"

#: ecpg.xml:5451(para)
msgid "An existing cursor name was specified. (SQLSTATE 42P03)"
msgstr "Было указано имя существующего курсора. (SQLSTATE 42P03)"

#: ecpg.xml:5002(para)
msgid ""
"These are the assigned <literal>SQLCODE</literal> values: <placeholder-1/>"
msgstr ""
"<literal>SQLCODE</literal> может принимать следующие значения: "
"<placeholder-1/>"

#: ecpg.xml:5463(title)
msgid "Preprocessor Directives"
msgstr "Директивы препроцессора"

#: ecpg.xml:5465(para)
msgid ""
"Several preprocessor directives are available that modify how the "
"<command>ecpg</command> preprocessor parses and processes a file."
msgstr ""
"Препроцессор <command>ecpg</command> поддерживает ряд директив, которые "
"позволяют управлять разбором и обработкой исходных файлов."

#: ecpg.xml:5472(title)
msgid "Including Files"
msgstr "Включение файлов"

#: ecpg.xml:5476(programlisting)
#, no-wrap
msgid ""
"EXEC SQL INCLUDE <replaceable>filename</replaceable>;\n"
"EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;\n"
"EXEC SQL INCLUDE \"<replaceable>filename</replaceable>\";"
msgstr ""
"EXEC SQL INCLUDE <replaceable>имя_файла</replaceable>;\n"
"EXEC SQL INCLUDE &lt;<replaceable>имя_файла</replaceable>&gt;;\n"
"EXEC SQL INCLUDE \"<replaceable>имя_файла</replaceable>\";"

#: ecpg.xml:5474(para)
msgid ""
"To include an external file into your embedded SQL program, use: "
"<placeholder-1/> The embedded SQL preprocessor will look for a file named "
"<literal><replaceable>filename</replaceable>.h</literal>, preprocess it, and "
"include it in the resulting C output. Thus, embedded SQL statements in the "
"included file are handled correctly."
msgstr ""
"Для включения внешнего файла в программу со встраиваемым SQL, используется "
"конструкция: <placeholder-1/> Встретив такую директиву, препроцессор "
"встраиваемого SQL будет искать файл <literal><replaceable>имя_файла</"
"replaceable>.h</literal>, обрабатывать его и включать в выходной код C. В "
"результате встраиваемые операторы SQL во включённом таким образом файле "
"будут обработаны корректно."

#: ecpg.xml:5492(simpara)
msgid "current directory"
msgstr "текущий каталог"

#: ecpg.xml:5493(filename)
msgid "/usr/local/include"
msgstr "/usr/local/include"

#: ecpg.xml:5494(simpara)
msgid ""
"PostgreSQL include directory, defined at build time (e.g., <filename>/usr/"
"local/pgsql/include</filename>)"
msgstr ""
"каталог включаемых файлов PostgreSQL, определённый во время сборки "
"(например, <filename>/usr/local/pgsql/include</filename>)"

#: ecpg.xml:5495(filename)
msgid "/usr/include"
msgstr "/usr/include"

#: ecpg.xml:5487(para)
msgid ""
"The <command>ecpg</command> preprocessor will search a file at several "
"directories in following order: <placeholder-1/> But when <literal>EXEC SQL "
"INCLUDE \"<replaceable>filename</replaceable>\"</literal> is used, only the "
"current directory is searched."
msgstr ""
"Препроцессор <command>ecpg</command> будет искать указанный файл в "
"нескольких каталогах в следующем порядке: <placeholder-1/> Но когда "
"используется форма <literal>EXEC SQL INCLUDE \"<replaceable>имя_файла</"
"replaceable>\"</literal>, просматривается только текущий каталог."

#: ecpg.xml:5503(para)
msgid ""
"In each directory, the preprocessor will first look for the file name as "
"given, and if not found will append <literal>.h</literal> to the file name "
"and try again (unless the specified file name already has that suffix)."
msgstr ""
"В каждом каталоге препроцессор будет сначала искать файл с заданным именем, "
"а если не обнаружит его, попытается найти файл с добавленным расширением "
"<literal>.h</literal> (если только заданное имя файла уже не содержит это "
"расширение)."

#: ecpg.xml:5512(programlisting)
#, no-wrap
msgid "#include &lt;<replaceable>filename</replaceable>.h&gt;"
msgstr "#include &lt;<replaceable>имя_файла</replaceable>.h&gt;"

#: ecpg.xml:5510(para)
msgid ""
"Note that <command>EXEC SQL INCLUDE</command> is <emphasis>not</emphasis> "
"the same as: <placeholder-1/> because this file would not be subject to SQL "
"command preprocessing. Naturally, you can continue to use the C "
"<literal>#include</literal> directive to include other header files."
msgstr ""
"Заметьте, что команда <command>EXEC SQL INCLUDE</command> <emphasis>не</"
"emphasis> равнозначна включению: <placeholder-1/> так как во втором случае "
"включаемый файл не проходит через препроцессор SQL-команд. Естественно, "
"директиву C <literal>#include</literal> можно по-прежнему применять для "
"включения других заголовочных файлов."

#: ecpg.xml:5522(para)
msgid ""
"The include file name is case-sensitive, even though the rest of the "
"<literal>EXEC SQL INCLUDE</literal> command follows the normal SQL case-"
"sensitivity rules."
msgstr ""
"Имя включаемого файла чувствительно к регистру, несмотря на то, что "
"остальная команда <literal>EXEC SQL INCLUDE</literal> подчиняется обычным "
"правилам чувствительности к регистру SQL."

#: ecpg.xml:5531(title)
msgid "The define and undef Directives"
msgstr "Директивы define и undef"

#: ecpg.xml:5535(programlisting)
#, no-wrap
msgid ""
"EXEC SQL DEFINE <replaceable>name</replaceable>;\n"
"EXEC SQL DEFINE <replaceable>name</replaceable> <replaceable>value</replaceable>;"
msgstr ""
"EXEC SQL DEFINE <replaceable>имя</replaceable>;\n"
"EXEC SQL DEFINE <replaceable>имя</replaceable> <replaceable>значение</replaceable>;"

#: ecpg.xml:5540(programlisting)
#, no-wrap
msgid "EXEC SQL DEFINE HAVE_FEATURE;"
msgstr "EXEC SQL DEFINE HAVE_FEATURE;"

#: ecpg.xml:5544(programlisting)
#, no-wrap
msgid ""
"EXEC SQL DEFINE MYNUMBER 12;\n"
"EXEC SQL DEFINE MYSTRING 'abc';"
msgstr ""
"EXEC SQL DEFINE MYNUMBER 12;\n"
"EXEC SQL DEFINE MYSTRING 'abc';"

#: ecpg.xml:5549(programlisting)
#, no-wrap
msgid "EXEC SQL UNDEF MYNUMBER;"
msgstr "EXEC SQL UNDEF MYNUMBER;"

#: ecpg.xml:5532(para)
msgid ""
"Similar to the directive <literal>#define</literal> that is known from C, "
"embedded SQL has a similar concept: <placeholder-1/> So you can define a "
"name: <placeholder-2/> And you can also define constants: <placeholder-3/> "
"Use <literal>undef</literal> to remove a previous definition: <placeholder-4/"
">"
msgstr ""
"Во встраиваемом SQL есть конструкция, подобная директиве <literal>#define</"
"literal>, известной в C: <placeholder-1/> Используя её, можно определить "
"имя: <placeholder-2/> И также можно определить константы: <placeholder-3/> "
"Удалить предыдущее определение позволяет команда <literal>undef</literal>: "
"<placeholder-4/>"

#: ecpg.xml:5560(programlisting)
#, no-wrap
msgid ""
"EXEC SQL DEFINE MYNUMBER 12;\n"
"...\n"
"EXEC SQL UPDATE Tbl SET col = MYNUMBER;"
msgstr ""
"EXEC SQL DEFINE MYNUMBER 12;\n"
"...\n"
"EXEC SQL UPDATE Tbl SET col = MYNUMBER;"

#: ecpg.xml:5554(para)
msgid ""
"Of course you can continue to use the C versions <literal>#define</literal> "
"and <literal>#undef</literal> in your embedded SQL program. The difference "
"is where your defined values get evaluated. If you use <literal>EXEC SQL "
"DEFINE</literal> then the <command>ecpg</command> preprocessor evaluates the "
"defines and substitutes the values. For example if you write: <placeholder-1/"
"> then <command>ecpg</command> will already do the substitution and your C "
"compiler will never see any name or identifier <literal>MYNUMBER</literal>. "
"Note that you cannot use <literal>#define</literal> for a constant that you "
"are going to use in an embedded SQL query because in this case the embedded "
"SQL precompiler is not able to see this declaration."
msgstr ""
"Разумеется, в программе со встраиваемым SQL можно продолжать использовать "
"версии <literal>#define</literal> и <literal>#undef</literal> языка C. "
"Отличие состоит в том, когда вычисляются определяемые значения. Когда "
"применяется команда <literal>EXEC SQL DEFINE</literal>, вычислять "
"определения и подставлять значения будет препроцессор <command>ecpg</"
"command>. Например, если написать: <placeholder-1/> подстановку выполнит "
"<command>ecpg</command> и компилятор C никогда не увидит имени или "
"идентификатора <literal>MYNUMBER</literal>. Заметьте, что с другой стороны "
"<literal>#define</literal> не подходит для определения константы, которую вы "
"хотите использовать во встраиваемом SQL, так как препроцессор встраиваемого "
"SQL не сможет увидеть это определение."

#: ecpg.xml:5574(title)
msgid "ifdef, ifndef, else, elif, and endif Directives"
msgstr "Директивы ifdef, ifndef, else, elif и endif"

#: ecpg.xml:5580(literal)
msgid "EXEC SQL ifdef <placeholder-1/>;"
msgstr "EXEC SQL ifdef <placeholder-1/>;"

#: ecpg.xml:5582(para)
msgid ""
"Checks a <replaceable>name</replaceable> and processes subsequent lines if "
"<replaceable>name</replaceable> has been created with <literal>EXEC SQL "
"define <replaceable>name</replaceable></literal>."
msgstr ""
"Проверяет <replaceable>имя</replaceable> и обрабатывает последующие строки, "
"если <replaceable>имя</replaceable> было определено командой <literal>EXEC "
"SQL define <replaceable>имя</replaceable></literal>."

#: ecpg.xml:5591(literal)
msgid "EXEC SQL ifndef <placeholder-1/>;"
msgstr "EXEC SQL ifndef <placeholder-1/>;"

#: ecpg.xml:5593(para)
msgid ""
"Checks a <replaceable>name</replaceable> and processes subsequent lines if "
"<replaceable>name</replaceable> has <emphasis>not</emphasis> been created "
"with <literal>EXEC SQL define <replaceable>name</replaceable></literal>."
msgstr ""
"Проверяет <replaceable>имя</replaceable> и обрабатывает последующие строки, "
"если <replaceable>имя</replaceable> <emphasis>не</emphasis> было определено "
"командой <literal>EXEC SQL define <replaceable>имя</replaceable></literal>."

#: ecpg.xml:5602(literal)
msgid "EXEC SQL else;"
msgstr "EXEC SQL else;"

#: ecpg.xml:5604(para)
msgid ""
"Starts processing an alternative section to a section introduced by either "
"<literal>EXEC SQL ifdef <replaceable>name</replaceable></literal> or "
"<literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>."
msgstr ""
"Начинает альтернативную ветвь условия, открытого командой <literal>EXEC SQL "
"ifdef <replaceable>имя</replaceable></literal> или <literal>EXEC SQL ifndef "
"<replaceable>имя</replaceable></literal>."

#: ecpg.xml:5613(literal)
msgid "EXEC SQL elif <placeholder-1/>;"
msgstr "EXEC SQL elif <placeholder-1/>;"

#: ecpg.xml:5615(para)
msgid ""
"Checks <replaceable>name</replaceable> and starts an alternative section if "
"<replaceable>name</replaceable> has been created with <literal>EXEC SQL "
"define <replaceable>name</replaceable></literal>."
msgstr ""
"Проверяет <replaceable>имя</replaceable> и начинает альтернативную ветвь "
"условия, если <replaceable>имя</replaceable> было определено командой "
"<literal>EXEC SQL define <replaceable>имя</replaceable></literal>."

#: ecpg.xml:5624(literal)
msgid "EXEC SQL endif;"
msgstr "EXEC SQL endif;"

#: ecpg.xml:5626(para)
msgid "Ends an alternative section."
msgstr "Завершает ветвь условия."

#: ecpg.xml:5575(para)
msgid ""
"You can use the following directives to compile code sections conditionally: "
"<placeholder-1/>"
msgstr ""
"Для условной компиляции блоков кода можно использовать следующие указания: "
"<placeholder-1/>"

#: ecpg.xml:5636(programlisting)
#, no-wrap
msgid ""
"EXEC SQL ifndef TZVAR;\n"
"EXEC SQL SET TIMEZONE TO 'GMT';\n"
"EXEC SQL elif TZNAME;\n"
"EXEC SQL SET TIMEZONE TO TZNAME;\n"
"EXEC SQL else;\n"
"EXEC SQL SET TIMEZONE TO TZVAR;\n"
"EXEC SQL endif;"
msgstr ""
"EXEC SQL ifndef TZVAR;\n"
"EXEC SQL SET TIMEZONE TO 'GMT';\n"
"EXEC SQL elif TZNAME;\n"
"EXEC SQL SET TIMEZONE TO TZNAME;\n"
"EXEC SQL else;\n"
"EXEC SQL SET TIMEZONE TO TZVAR;\n"
"EXEC SQL endif;"

#: ecpg.xml:5634(para)
msgid "Example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#: ecpg.xml:5651(title)
msgid "Processing Embedded SQL Programs"
msgstr "Компиляция программ со встраиваемым SQL"

#: ecpg.xml:5653(para)
msgid ""
"Now that you have an idea how to form embedded SQL C programs, you probably "
"want to know how to compile them. Before compiling you run the file through "
"the embedded <acronym>SQL</acronym> <acronym>C</acronym> preprocessor, which "
"converts the <acronym>SQL</acronym> statements you used to special function "
"calls. After compiling, you must link with a special library that contains "
"the needed functions. These functions fetch information from the arguments, "
"perform the <acronym>SQL</acronym> command using the <application>libpq</"
"application> interface, and put the result in the arguments specified for "
"output."
msgstr ""
"Теперь, когда вы получили представление, как писать программы на C со "
"встраиваемым SQL, вы наверное хотите узнать, как их компилировать. Прежде "
"чем компилировать код C, необходимо пропустить исходный файл через "
"препроцессор встраиваемого <acronym>SQL</acronym> в <acronym>C</acronym>, "
"который преобразует записанные вами операторы <acronym>SQL</acronym> в "
"вызовы специальных функций. После компиляции полученный объектный код нужно "
"скомпоновать со специальной библиотекой, содержащей необходимые функции. Эти "
"функции получают информацию из аргументов, выполняют команды <acronym>SQL</"
"acronym> через интерфейс <application>libpq</application>, и помещают "
"результат в аргументы, заданные для вывода."

#: ecpg.xml:5673(programlisting)
#, no-wrap
msgid "ecpg prog1.pgc"
msgstr "ecpg prog1.pgc"

#: ecpg.xml:5666(para)
msgid ""
"The preprocessor program is called <filename>ecpg</filename> and is included "
"in a normal <productname>PostgreSQL</productname> installation. Embedded SQL "
"programs are typically named with an extension <filename>.pgc</filename>. If "
"you have a program file called <filename>prog1.pgc</filename>, you can "
"preprocess it by simply calling: <placeholder-1/> This will create a file "
"called <filename>prog1.c</filename>. If your input files do not follow the "
"suggested naming pattern, you can specify the output file explicitly using "
"the <option>-o</option> option."
msgstr ""
"Программа препроцессора называется <filename>ecpg</filename> и входит в "
"состав обычной инсталляции <productname>PostgreSQL</productname>. Программам "
"со встраиваемым SQL, как правило, даются имена с расширением <filename>.pgc</"
"filename>. Если вы создали код программы в файле <filename>prog1.pgc</"
"filename>, вы можете обработать его, просто выполнив: <placeholder-1/> При "
"этом будет создан файл <filename>prog1.c</filename>. Если имена входных "
"файлов не следуют этому соглашению, имя выходного файла можно задать явно в "
"аргументе <option>-o</option>."

#: ecpg.xml:5684(programlisting)
#, no-wrap
msgid "cc -c prog1.c"
msgstr "cc -c prog1.c"

#: ecpg.xml:5682(para)
msgid ""
"The preprocessed file can be compiled normally, for example: <placeholder-1/"
"> The generated C source files include header files from the "
"<productname>PostgreSQL</productname> installation, so if you installed "
"<productname>PostgreSQL</productname> in a location that is not searched by "
"default, you have to add an option such as <literal>-I/usr/local/pgsql/"
"include</literal> to the compilation command line."
msgstr ""
"Обработанный препроцессором файл можно скомпилировать обычным образом, "
"например, так: <placeholder-1/> В сгенерированные исходные файлы C "
"включаются заголовочные файлы из инсталляции <productname>PostgreSQL</"
"productname>, поэтому если вы установили <productname>PostgreSQL</"
"productname> так, что соответствующий каталог не просматривается по "
"умолчанию, вам придётся добавить указание вида <literal>-I/usr/local/pgsql/"
"include</literal> в командную строку компиляции."

#: ecpg.xml:5698(programlisting)
#, no-wrap
msgid "cc -o myprog prog1.o prog2.o ... -lecpg"
msgstr "cc -o myprog prog1.o prog2.o ... -lecpg"

#: ecpg.xml:5695(para)
msgid ""
"To link an embedded SQL program, you need to include the <filename>libecpg</"
"filename> library, like so: <placeholder-1/> Again, you might have to add an "
"option like <literal>-L/usr/local/pgsql/lib</literal> to that command line."
msgstr ""
"Чтобы скомпоновать программу со встраиваемым SQL, необходимо подключить "
"библиотеку <filename>libecpg</filename> примерно так: <placeholder-1/> "
"Возможно, и для этого понадобится добавить в командную строку указание вида "
"<literal>-L/usr/local/pgsql/lib</literal>."

#: ecpg.xml:5707(indexterm)
msgid ""
"<primary>pg_config</primary><secondary sortas=\"ecpg\">with ecpg</secondary>"
msgstr ""
"<primary>pg_config</primary> <secondary sortas=\"ecpg\">с ecpg</secondary>"

#: ecpg.xml:5709(indexterm)
msgid ""
"<primary>pkg-config</primary><secondary sortas=\"ecpg\">with ecpg</secondary>"
msgstr ""
"<primary>pkg-config</primary> <secondary sortas=\"ecpg\">с ecpg</secondary>"

#: ecpg.xml:5705(para)
msgid ""
"You can use <command>pg_config</command><placeholder-1/> or <command>pkg-"
"config</command><placeholder-2/> with package name <literal>libecpg</"
"literal> to get the paths for your installation."
msgstr ""
"Чтобы узнать пути вашей инсталляции, можно воспользоваться командой "
"<command>pg_config</command><placeholder-1/> или <command>pkg-config</"
"command><placeholder-2/> (в качестве имени пакета нужно указать "
"<literal>libecpg</literal>)."

#: ecpg.xml:5718(programlisting)
#, no-wrap
msgid ""
"ECPG = ecpg\n"
"\n"
"%.c: %.pgc\n"
"        $(ECPG) $&lt;"
msgstr ""
"ECPG = ecpg\n"
"\n"
"%.c: %.pgc\n"
"        $(ECPG) $&lt;"

#: ecpg.xml:5714(para)
msgid ""
"If you manage the build process of a larger project using <application>make</"
"application>, it might be convenient to include the following implicit rule "
"to your makefiles: <placeholder-1/>"
msgstr ""
"Если вы организуете процесс сборки большого проекта с применением "
"<application>make</application>, может быть удобно включить в ваши сборочные "
"файлы следующее неявное правило: <placeholder-1/>"

#: ecpg.xml:5726(para)
msgid ""
"The complete syntax of the <command>ecpg</command> command is detailed in "
"<xref linkend=\"app-ecpg\"/>."
msgstr ""
"Полный синтаксис вызова команды <command>ecpg</command> приведён в описании "
"<xref linkend=\"app-ecpg\"/>."

#: ecpg.xml:5731(para)
msgid ""
"The <application>ecpg</application> library is thread-safe by default. "
"However, you might need to use some threading command-line options to "
"compile your client code."
msgstr ""
"Библиотека <application>ecpg</application> по умолчанию потокобезопасна. "
"Однако для компиляции клиентского кода могут потребоваться параметры "
"командной строки для настройки многопоточности."

#: ecpg.xml:5739(title)
msgid "Library Functions"
msgstr "Библиотечные функции"

#: ecpg.xml:5741(para)
msgid ""
"The <filename>libecpg</filename> library primarily contains <quote>hidden</"
"quote> functions that are used to implement the functionality expressed by "
"the embedded SQL commands. But there are some functions that can usefully be "
"called directly. Note that this makes your code unportable."
msgstr ""
"Библиотека <filename>libecpg</filename> в основном содержит <quote>скрытые</"
"quote> функции, применяемые для реализации функциональности, выражаемой "
"встраиваемыми командами SQL. Но есть также некоторые функции, которые можно "
"вызывать напрямую. Заметьте, что код, задействующий эти функции, будет "
"непереносимым."

#: ecpg.xml:5751(para)
msgid ""
"<function>ECPGdebug(int <replaceable>on</replaceable>, FILE "
"*<replaceable>stream</replaceable>)</function> turns on debug logging if "
"called with the first argument non-zero. Debug logging is done on "
"<replaceable>stream</replaceable>. The log contains all <acronym>SQL</"
"acronym> statements with all the input variables inserted, and the results "
"from the <productname>PostgreSQL</productname> server. This can be very "
"useful when searching for errors in your <acronym>SQL</acronym> statements."
msgstr ""
"<function>ECPGdebug(int <replaceable>вкл</replaceable>, FILE "
"*<replaceable>поток</replaceable>)</function> с первым аргументом, отличным "
"от нуля, включает вывод отладочных сообщений в заданный <replaceable>поток</"
"replaceable>. Журнал сообщений, полученный таким образом, будет содержать "
"все операторы <acronym>SQL</acronym> с заданными входными переменными и "
"результаты, выданные сервером <productname>PostgreSQL</productname>. Это "
"может быть очень полезно для поиска ошибок в командах <acronym>SQL</acronym>."

#: ecpg.xml:5763(para)
msgid ""
"On Windows, if the <application>ecpg</application> libraries and an "
"application are compiled with different flags, this function call will crash "
"the application because the internal representation of the <literal>FILE</"
"literal> pointers differ. Specifically, multithreaded/single-threaded, "
"release/debug, and static/dynamic flags should be the same for the library "
"and all applications using that library."
msgstr ""
"В Windows, если библиотека <application>ecpg</application> и приложение "
"скомпилированы с разными флагами, эта функция может вызвать крах приложения "
"из-за различий внутреннего представления указателей <literal>FILE</literal>. "
"В частности, флаги многопоточной/однопоточной, выпускаемой/отладочной или "
"статической/динамической сборки должны быть одинаковыми для библиотеки и "
"всех использующих её приложений."

#: ecpg.xml:5776(para)
msgid ""
"<function>ECPGget_PGconn(const char *<replaceable>connection_name</"
"replaceable>) </function> returns the library database connection handle "
"identified by the given name. If <replaceable>connection_name</replaceable> "
"is set to <literal>NULL</literal>, the current connection handle is "
"returned. If no connection handle can be identified, the function returns "
"<literal>NULL</literal>. The returned connection handle can be used to call "
"any other functions from <application>libpq</application>, if necessary."
msgstr ""
"<function>ECPGget_PGconn(const char *<replaceable>имя_подключения</"
"replaceable>) </function> возвращает указатель на подключение к базе данных, "
"имеющее заданное имя. Если аргумент <replaceable>имя_подключения</"
"replaceable> равен <literal>NULL</literal>, возвращается указатель на "
"текущее подключение. Если определить подключение не удаётся, возвращается "
"<literal>NULL</literal>. Полученный указатель на подключение, если "
"требуется, можно использовать при вызове любых других функций "
"<application>libpq</application>."

#: ecpg.xml:5785(para)
msgid ""
"It is a bad idea to manipulate database connection handles made from "
"<application>ecpg</application> directly with <application>libpq</"
"application> routines."
msgstr ""
"Манипулировать подключениями, открытыми средствами <application>ecpg</"
"application>, напрямую через <application>libpq</application> не следует."

#: ecpg.xml:5793(para)
msgid ""
"<function>ECPGtransactionStatus(const char *<replaceable>connection_name</"
"replaceable>)</function> returns the current transaction status of the given "
"connection identified by <replaceable>connection_name</replaceable>. See "
"<xref linkend=\"libpq-status\"/> and libpq's "
"<function>PQtransactionStatus()</function> for details about the returned "
"status codes."
msgstr ""
"<function>ECPGtransactionStatus(const char *<replaceable>имя_подключения</"
"replaceable>)</function> возвращает состояние текущей транзакции для "
"подключения, на которое указывает <replaceable>имя_подключения</"
"replaceable>. Возвращаемые коды состояния перечислены в описании входящей в "
"libpq функции <function>PQtransactionStatus()</function> в <xref remap=\"6\" "
"linkend=\"libpq-status\"/>."

#: ecpg.xml:5801(para)
msgid ""
"<function>ECPGstatus(int <replaceable>lineno</replaceable>, const char* "
"<replaceable>connection_name</replaceable>)</function> returns true if you "
"are connected to a database and false if not. <replaceable>connection_name</"
"replaceable> can be <literal>NULL</literal> if a single connection is being "
"used."
msgstr ""
"<function>ECPGstatus(int <replaceable>номер_строки</replaceable>, const "
"char* <replaceable>имя_подключения</replaceable>)</function> возвращает true "
"при наличии подключения к базе данных и false в противном случае. В "
"аргументе <replaceable>имя_подключения</replaceable> можно передать "
"<literal>NULL</literal>, если применяется одно подключение."

#: ecpg.xml:5813(title)
msgid "Large Objects"
msgstr "Большие объекты"

#: ecpg.xml:5815(para)
msgid ""
"Large objects are not directly supported by ECPG, but ECPG application can "
"manipulate large objects through the libpq large object functions, obtaining "
"the necessary <type>PGconn</type> object by calling the "
"<function>ECPGget_PGconn()</function> function. (However, use of the "
"<function>ECPGget_PGconn()</function> function and touching <type>PGconn</"
"type> objects directly should be done very carefully and ideally not mixed "
"with other ECPG database access calls.)"
msgstr ""
"ECPG не поддерживает большие объекты напрямую, но приложение на базе ECPG "
"может работать с большими объектами, используя предназначенные для этого "
"функции, получив необходимый объект <type>PGconn</type> в результате вызова "
"<function>ECPGget_PGconn()</function>. (Однако использовать функцию "
"<function>ECPGget_PGconn()</function> и напрямую воздействовать на объекты "
"<type>PGconn</type> следует очень осторожно; в идеале стоит исключить при "
"этом другие обращения к базе данных через ECPG.)"

#: ecpg.xml:5826(para)
msgid ""
"For more details about the <function>ECPGget_PGconn()</function>, see <xref "
"linkend=\"ecpg-library\"/>. For information about the large object function "
"interface, see <xref linkend=\"largeobjects\"/>."
msgstr ""
"Подробнее функция <function>ECPGget_PGconn()</function> описана в <xref "
"remap=\"6\" linkend=\"ecpg-library\"/>. Интерфейс функций для работы с "
"большими объектами рассмотрен в <xref remap=\"6\" linkend=\"largeobjects\"/>."

#: ecpg.xml:5832(para)
msgid ""
"Large object functions have to be called in a transaction block, so when "
"autocommit is off, <command>BEGIN</command> commands have to be issued "
"explicitly."
msgstr ""
"Функции для работы с большими объектами должны вызываться в блоке "
"транзакций, поэтому если режим автофиксации отключён, необходимо явно "
"выдавать команды <command>BEGIN</command>."

#: ecpg.xml:5838(para)
msgid ""
"<xref linkend=\"ecpg-lo-example\"/> shows an example program that "
"illustrates how to create, write, and read a large object in an ECPG "
"application."
msgstr ""
"В <xref remap=\"6\" linkend=\"ecpg-lo-example\"/> приведён пример программы, "
"показывающий, как создать, записать и прочитать большой объект в приложении "
"ECPG."

#: ecpg.xml:5845(title)
msgid "ECPG Program Accessing Large Objects"
msgstr "Программа на базе ECPG, работающая с большими объектами"

#: ecpg.xml:5927(title)
msgid "<acronym>C++</acronym> Applications"
msgstr "Приложения на <acronym>C++</acronym>"

#: ecpg.xml:5929(para)
msgid ""
"ECPG has some limited support for C++ applications. This section describes "
"some caveats."
msgstr ""
"ECPG обеспечивает поддержку языка C++ в ограниченном объёме. Некоторые её "
"особенности описаны в этом разделе."

#: ecpg.xml:5934(para)
msgid ""
"The <command>ecpg</command> preprocessor takes an input file written in C "
"(or something like C) and embedded SQL commands, converts the embedded SQL "
"commands into C language chunks, and finally generates a <filename>.c</"
"filename> file. The header file declarations of the library functions used "
"by the C language chunks that <command>ecpg</command> generates are wrapped "
"in <literal>extern \"C\" { ... }</literal> blocks when used under C++, so "
"they should work seamlessly in C++."
msgstr ""
"Препроцессор <command>ecpg</command> принимает входной файл, написанный на C "
"(или языке, подобном C) со встраиваемыми командами SQL, преобразует "
"встроенные команды SQL в конструкции языка C и в результате формирует файл "
"<filename>.c</filename>. Объявления библиотечных функций, вызываемых в "
"конструкциях C, которые генерирует <command>ecpg</command>, заворачиваются в "
"блоки <literal>extern \"C\" { ... }</literal> при использовании C++, так что "
"они должны прозрачно работать в C++."

#: ecpg.xml:5945(para)
msgid ""
"In general, however, the <command>ecpg</command> preprocessor only "
"understands C; it does not handle the special syntax and reserved words of "
"the C++ language. So, some embedded SQL code written in C++ application code "
"that uses complicated features specific to C++ might fail to be preprocessed "
"correctly or might not work as expected."
msgstr ""
"Однако вообще говоря, препроцессор <command>ecpg</command> понимает только "
"C; он не воспринимает особый синтаксис и зарезервированные слова языка C++. "
"Поэтому какой-то код SQL, встроенный в код приложения на C++, в котором "
"используются сложные особенности C++, может корректно не обработаться "
"препроцессором или не работать как ожидается."

#: ecpg.xml:5954(para)
msgid ""
"A safe way to use the embedded SQL code in a C++ application is hiding the "
"ECPG calls in a C module, which the C++ application code calls into to "
"access the database, and linking that together with the rest of the C++ "
"code. See <xref linkend=\"ecpg-cpp-and-c\"/> about that."
msgstr ""
"Надёжный подход к применению внедрённого кода SQL в приложении на C++ "
"заключается в том, чтобы скрыть вызовы ECPG в модуле C, который будет "
"вызываться приложением на C++ для работы с базой данных и который будет "
"скомпонован с остальным кодом C++. Подробнее это описано в <xref remap=\"6\" "
"linkend=\"ecpg-cpp-and-c\"/>."

#: ecpg.xml:5963(title)
msgid "Scope for Host Variables"
msgstr "Область видимости переменных среды"

#: ecpg.xml:5965(para)
msgid ""
"The <command>ecpg</command> preprocessor understands the scope of variables "
"in C. In the C language, this is rather simple because the scopes of "
"variables is based on their code blocks. In C++, however, the class member "
"variables are referenced in a different code block from the declared "
"position, so the <command>ecpg</command> preprocessor will not understand "
"the scope of the class member variables."
msgstr ""
"Препроцессор <command>ecpg</command> имеет понимание области видимости "
"переменных в C. С языком C это довольно просто, так как область видимости "
"переменных определяется их блоками кода. В C++, однако, переменные-члены "
"класса задействуются не в том блоке кода, в каком они объявлены, так что "
"препроцессор <command>ecpg</command> не сможет корректно определить область "
"видимости таких переменных."

#: ecpg.xml:5981(programlisting)
#, no-wrap
msgid ""
"class TestCpp\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char dbname[1024];\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"  public:\n"
"    TestCpp();\n"
"    void test();\n"
"    ~TestCpp();\n"
"};\n"
"\n"
"TestCpp::TestCpp()\n"
"{\n"
"    EXEC SQL CONNECT TO testdb1;\n"
"}\n"
"\n"
"void Test::test()\n"
"{\n"
"    EXEC SQL SELECT current_database() INTO :dbname;\n"
"    printf(\"current_database = %s\\n\", dbname);\n"
"}\n"
"\n"
"TestCpp::~TestCpp()\n"
"{\n"
"    EXEC SQL DISCONNECT ALL;\n"
"}"
msgstr ""
"class TestCpp\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char dbname[1024];\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"  public:\n"
"    TestCpp();\n"
"    void test();\n"
"    ~TestCpp();\n"
"};\n"
"\n"
"TestCpp::TestCpp()\n"
"{\n"
"    EXEC SQL CONNECT TO testdb1;\n"
"}\n"
"\n"
"void Test::test()\n"
"{\n"
"    EXEC SQL SELECT current_database() INTO :dbname;\n"
"    printf(\"current_database = %s\\n\", dbname);\n"
"}\n"
"\n"
"TestCpp::~TestCpp()\n"
"{\n"
"    EXEC SQL DISCONNECT ALL;\n"
"}"

#: ecpg.xml:5975(para)
msgid ""
"For example, in the following case, the <command>ecpg</command> preprocessor "
"cannot find any declaration for the variable <literal>dbname</literal> in "
"the <literal>test</literal> method, so an error will occur. <placeholder-1/> "
"This code will result in an error like this: <screen>\n"
"<userinput>ecpg test_cpp.pgc</userinput>\n"
"test_cpp.pgc:28: ERROR: variable \"dbname\" is not declared\n"
"</screen>"
msgstr ""
"Например, в следующем случае препроцессор <command>ecpg</command> не сможет "
"найти определение переменной <literal>dbname</literal> в методе "
"<literal>test</literal>, так что произойдёт ошибка. <placeholder-1/> При "
"обработке данного кода будет выдано сообщение: <screen>\n"
"<userinput>ecpg test_cpp.pgc</userinput>\n"
"test_cpp.pgc:28: ERROR: variable \"dbname\" is not declared\n"
"</screen>\n"
"(test_cpp.pgc:28: ОШИБКА: переменная \"dbname\" не объявлена)"

#: ecpg.xml:6024(programlisting)
#, no-wrap
msgid ""
"void TestCpp::test()\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char tmp[1024];\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL SELECT current_database() INTO :tmp;\n"
"    strlcpy(dbname, tmp, sizeof(tmp));\n"
"\n"
"    printf(\"current_database = %s\\n\", dbname);\n"
"}"
msgstr ""
"void TestCpp::test()\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char tmp[1024];\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL SELECT current_database() INTO :tmp;\n"
"    strlcpy(dbname, tmp, sizeof(tmp));\n"
"\n"
"    printf(\"current_database = %s\\n\", dbname);\n"
"}"

#: ecpg.xml:6018(para)
msgid ""
"To avoid this scope issue, the <literal>test</literal> method could be "
"modified to use a local variable as intermediate storage. But this approach "
"is only a poor workaround, because it uglifies the code and reduces "
"performance. <placeholder-1/>"
msgstr ""
"Для решения этой проблемы можно немного изменить метод <literal>test</"
"literal> и задействовать в нём локальную переменную для промежуточного "
"хранения. Но предложенный подход нельзя считать хорошим, так как это портит "
"код и снижает производительность. <placeholder-1/>"

#: ecpg.xml:6041(title)
msgid "C++ Application Development with External C Module"
msgstr "Разработка приложения на C++ с внешним модулем на C"

#: ecpg.xml:6043(para)
msgid ""
"If you understand these technical limitations of the <command>ecpg</command> "
"preprocessor in C++, you might come to the conclusion that linking C objects "
"and C++ objects at the link stage to enable C++ applications to use ECPG "
"features could be better than writing some embedded SQL commands in C++ code "
"directly. This section describes a way to separate some embedded SQL "
"commands from C++ application code with a simple example. In this example, "
"the application is implemented in C++, while C and ECPG is used to connect "
"to the PostgreSQL server."
msgstr ""
"Если вы поняли технические ограничения препроцессора <command>ecpg</command> "
"с C++, вы можете прийти к заключению, что для использования ECPG в "
"приложениях на C++ лучше связывать код C с кодом C++ на стадии компоновки, а "
"не внедрять команды SQL непосредственно в код на C++. В данном разделе "
"показывается, как отделить встраиваемые команды SQL от кода приложения на C+"
"+, на простом примере. В этом примере приложение реализуется на C++, а "
"взаимодействие с сервером PostgreSQL построено на C и ECPG."

#: ecpg.xml:6061(filename)
msgid "test_mod.pgc"
msgstr "test_mod.pgc"

#: ecpg.xml:6068(programlisting)
#, no-wrap
msgid ""
"#include \"test_mod.h\"\n"
"#include &lt;stdio.h&gt;\n"
"\n"
"void\n"
"db_connect()\n"
"{\n"
"    EXEC SQL CONNECT TO testdb1;\n"
"}\n"
"\n"
"void\n"
"db_test()\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char dbname[1024];\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL SELECT current_database() INTO :dbname;\n"
"    printf(\"current_database = %s\\n\", dbname);\n"
"}\n"
"\n"
"void\n"
"db_disconnect()\n"
"{\n"
"    EXEC SQL DISCONNECT ALL;\n"
"}"
msgstr ""
"#include \"test_mod.h\"\n"
"#include &lt;stdio.h&gt;\n"
"\n"
"void\n"
"db_connect()\n"
"{\n"
"    EXEC SQL CONNECT TO testdb1;\n"
"}\n"
"\n"
"void\n"
"db_test()\n"
"{\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char dbname[1024];\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL SELECT current_database() INTO :dbname;\n"
"    printf(\"current_database = %s\\n\", dbname);\n"
"}\n"
"\n"
"void\n"
"db_disconnect()\n"
"{\n"
"    EXEC SQL DISCONNECT ALL;\n"
"}"

#: ecpg.xml:6063(para)
msgid ""
"A sub-routine module to execute SQL commands embedded in C. It is going to "
"be converted into <filename>test_mod.c</filename> by the preprocessor. "
"<placeholder-1/>"
msgstr ""
"Модуль подпрограмм будет выполнять SQL-команды, встроенные в C. Этот код "
"нужно будет преобразовать в <filename>test_mod.c</filename> с помощью "
"препроцессора. <placeholder-1/>"

#: ecpg.xml:6100(filename)
msgid "test_mod.h"
msgstr "test_mod.h"

#: ecpg.xml:6109(programlisting)
#, no-wrap
msgid ""
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"void db_connect();\n"
"void db_test();\n"
"void db_disconnect();\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif"
msgstr ""
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"void db_connect();\n"
"void db_test();\n"
"void db_disconnect();\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif"

#: ecpg.xml:6102(para)
msgid ""
"A header file with declarations of the functions in the C module "
"(<filename>test_mod.pgc</filename>). It is included by <filename>test_cpp."
"cpp</filename>. This file has to have an <literal>extern \"C\"</literal> "
"block around the declarations, because it will be linked from the C++ "
"module. <placeholder-1/>"
msgstr ""
"Заголовочный файл с объявлениями функций в модуле на языке C "
"(<filename>test_mod.pgc</filename>). Он включается в <filename>test_cpp.cpp</"
"filename>. Объявления в этом файле должны заключаться в блок <literal>extern "
"\"C\"</literal>, так как он будет связываться с модулем C++. <placeholder-1/>"

#: ecpg.xml:6127(filename)
msgid "test_cpp.cpp"
msgstr "test_cpp.cpp"

#: ecpg.xml:6134(programlisting)
#, no-wrap
msgid ""
"#include \"test_mod.h\"\n"
"\n"
"class TestCpp\n"
"{\n"
"  public:\n"
"    TestCpp();\n"
"    void test();\n"
"    ~TestCpp();\n"
"};\n"
"\n"
"TestCpp::TestCpp()\n"
"{\n"
"    db_connect();\n"
"}\n"
"\n"
"void\n"
"TestCpp::test()\n"
"{\n"
"    db_test();\n"
"}\n"
"\n"
"TestCpp::~TestCpp()\n"
"{\n"
"    db_disconnect();\n"
"}\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"    TestCpp *t = new TestCpp();\n"
"\n"
"    t-&gt;test();\n"
"    return 0;\n"
"}"
msgstr ""
"#include \"test_mod.h\"\n"
"\n"
"class TestCpp\n"
"{\n"
"  public:\n"
"    TestCpp();\n"
"    void test();\n"
"    ~TestCpp();\n"
"};\n"
"\n"
"TestCpp::TestCpp()\n"
"{\n"
"    db_connect();\n"
"}\n"
"\n"
"void\n"
"TestCpp::test()\n"
"{\n"
"    db_test();\n"
"}\n"
"\n"
"TestCpp::~TestCpp()\n"
"{\n"
"    db_disconnect();\n"
"}\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"    TestCpp *t = new TestCpp();\n"
"\n"
"    t-&gt;test();\n"
"    return 0;\n"
"}"

#: ecpg.xml:6129(para)
msgid ""
"The main code for the application, including the <function>main</function> "
"routine, and in this example a C++ class. <placeholder-1/>"
msgstr ""
"Основной код приложения, содержащий функцию <function>main</function>, а "
"также, в данном примере, класс C++. <placeholder-1/>"

#: ecpg.xml:6055(para)
msgid ""
"Three kinds of files have to be created: a C file (<filename>*.pgc</"
"filename>), a header file, and a C++ file: <placeholder-1/>"
msgstr ""
"Для сборки нужно создать три типа файлов: файл на C (<filename>*.pgc</"
"filename>), заголовочный файл и файл на C++: <placeholder-1/>"

#: ecpg.xml:6182(programlisting)
#, no-wrap
msgid ""
"ecpg -o test_mod.c test_mod.pgc\n"
"cc -c test_mod.c -o test_mod.o"
msgstr ""
"ecpg -o test_mod.c test_mod.pgc\n"
"cc -c test_mod.c -o test_mod.o"

#: ecpg.xml:6176(para)
msgid ""
"To build the application, proceed as follows. Convert <filename>test_mod."
"pgc</filename> into <filename>test_mod.c</filename> by running "
"<command>ecpg</command>, and generate <filename>test_mod.o</filename> by "
"compiling <filename>test_mod.c</filename> with the C compiler: "
"<placeholder-1/>"
msgstr ""
"Для сборки приложения проделайте следующее. Преобразуйте <filename>test_mod."
"pgc</filename> в <filename>test_mod.c</filename> с помощью <command>ecpg</"
"command>, а затем получите <filename>test_mod.o</filename>, скомпилировав "
"<filename>test_mod.c</filename> компилятором C: <placeholder-1/>"

#: ecpg.xml:6191(programlisting)
#, no-wrap
msgid "c++ -c test_cpp.cpp -o test_cpp.o"
msgstr "c++ -c test_cpp.cpp -o test_cpp.o"

#: ecpg.xml:6188(para)
msgid ""
"Next, generate <filename>test_cpp.o</filename> by compiling "
"<filename>test_cpp.cpp</filename> with the C++ compiler: <placeholder-1/>"
msgstr ""
"После этого получите <filename>test_cpp.o</filename>, скомпилировав "
"<filename>test_cpp.cpp</filename> компилятором C++: <placeholder-1/>"

#: ecpg.xml:6200(programlisting)
#, no-wrap
msgid "c++ test_cpp.o test_mod.o -lecpg -o test_cpp"
msgstr "c++ test_cpp.o test_mod.o -lecpg -o test_cpp"

#: ecpg.xml:6196(para)
msgid ""
"Finally, link these object files, <filename>test_cpp.o</filename> and "
"<filename>test_mod.o</filename>, into one executable, using the C++ compiler "
"driver: <placeholder-1/>"
msgstr ""
"Наконец, свяжите полученные объектные файлы, <filename>test_cpp.o</filename> "
"и <filename>test_mod.o</filename>, в один исполняемый файл, выполнив "
"компоновку под управлением компилятора C++: <placeholder-1/>"

#: ecpg.xml:6208(title)
msgid "Embedded SQL Commands"
msgstr "Команды встраиваемого SQL"

#: ecpg.xml:6210(para)
msgid ""
"This section describes all SQL commands that are specific to embedded SQL. "
"Also refer to the SQL commands listed in <xref linkend=\"sql-commands\"/>, "
"which can also be used in embedded SQL, unless stated otherwise."
msgstr ""
"В этом разделе описаны все команды, предназначенные специально для "
"встраиваемого SQL. В <xref remap=\"6\" linkend=\"sql-commands\"/> также "
"описаны обычные команды SQL, которые можно использовать и как встраиваемые, "
"если явно не отмечено обратное."

#: ecpg.xml:6219(refname)
msgid "ALLOCATE DESCRIPTOR"
msgstr "ALLOCATE DESCRIPTOR"

#: ecpg.xml:6220(refpurpose)
msgid "allocate an SQL descriptor area"
msgstr "выделить область SQL-дескриптора"

#: ecpg.xml:6224(synopsis)
#, no-wrap
msgid "ALLOCATE DESCRIPTOR <placeholder-1/>"
msgstr "ALLOCATE DESCRIPTOR <placeholder-1/>"

#: ecpg.xml:6230(title) ecpg.xml:6304(title) ecpg.xml:6519(title)
#: ecpg.xml:6586(title) ecpg.xml:6698(title) ecpg.xml:6788(title)
#: ecpg.xml:6895(title) ecpg.xml:6957(title) ecpg.xml:7146(title)
#: ecpg.xml:7238(title) ecpg.xml:7317(title) ecpg.xml:7351(title)
#: ecpg.xml:7426(title) ecpg.xml:7541(title) ecpg.xml:7679(title)
#: ecpg.xml:7745(title)
msgid "Description"
msgstr "Описание"

#: ecpg.xml:6232(para)
msgid ""
"<command>ALLOCATE DESCRIPTOR</command> allocates a new named SQL descriptor "
"area, which can be used to exchange data between the PostgreSQL server and "
"the host program."
msgstr ""
"<command>ALLOCATE DESCRIPTOR</command> выделяет новую именованную область "
"SQL-дескриптора, через которую можно обмениваться данными между сервером "
"PostgreSQL и программой на C."

#: ecpg.xml:6238(para)
msgid ""
"Descriptor areas should be freed after use using the <command>DEALLOCATE "
"DESCRIPTOR</command> command."
msgstr ""
"После использования области дескрипторов должны освобождаться командой "
"<command>DEALLOCATE DESCRIPTOR</command>."

#: ecpg.xml:6245(title) ecpg.xml:6313(title) ecpg.xml:6528(title)
#: ecpg.xml:6602(title) ecpg.xml:6708(title) ecpg.xml:6797(title)
#: ecpg.xml:6905(title) ecpg.xml:6979(title) ecpg.xml:7159(title)
#: ecpg.xml:7250(title) ecpg.xml:7361(title) ecpg.xml:7443(title)
#: ecpg.xml:7556(title) ecpg.xml:7689(title) ecpg.xml:7754(title)
msgid "Parameters"
msgstr "Параметры"

#: ecpg.xml:6251(para)
msgid ""
"A name of SQL descriptor, case sensitive. This can be an SQL identifier or a "
"host variable."
msgstr ""
"Имя SQL-дескриптора, задаётся с учётом регистра. Это может быть "
"идентификатор SQL или переменная среды."

#: ecpg.xml:6261(title) ecpg.xml:6420(title) ecpg.xml:6545(title)
#: ecpg.xml:6644(title) ecpg.xml:6743(title) ecpg.xml:6844(title)
#: ecpg.xml:6921(title) ecpg.xml:7036(title) ecpg.xml:7197(title)
#: ecpg.xml:7276(title) ecpg.xml:7386(title) ecpg.xml:7500(title)
#: ecpg.xml:7580(title) ecpg.xml:7713(title) ecpg.xml:7763(title)
msgid "Examples"
msgstr "Примеры"

#: ecpg.xml:6263(programlisting)
#, no-wrap
msgid "EXEC SQL ALLOCATE DESCRIPTOR mydesc;"
msgstr "EXEC SQL ALLOCATE DESCRIPTOR mydesc;"

#: ecpg.xml:6269(title) ecpg.xml:6487(title) ecpg.xml:6553(title)
#: ecpg.xml:6665(title) ecpg.xml:6755(title) ecpg.xml:6865(title)
#: ecpg.xml:6935(title) ecpg.xml:7114(title) ecpg.xml:7208(title)
#: ecpg.xml:7288(title) ecpg.xml:7330(title) ecpg.xml:7395(title)
#: ecpg.xml:7511(title) ecpg.xml:7658(title) ecpg.xml:7724(title)
#: ecpg.xml:7813(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ecpg.xml:6271(para)
msgid ""
"<command>ALLOCATE DESCRIPTOR</command> is specified in the SQL standard."
msgstr ""
"Команда <command>ALLOCATE DESCRIPTOR</command> описана в стандарте SQL."

#: ecpg.xml:6278(title) ecpg.xml:6497(title) ecpg.xml:6562(title)
#: ecpg.xml:6673(title) ecpg.xml:6763(title) ecpg.xml:6873(title)
#: ecpg.xml:7122(title) ecpg.xml:7216(title) ecpg.xml:7296(title)
#: ecpg.xml:7403(title) ecpg.xml:7519(title)
msgid "See Also"
msgstr "См. также"

#: ecpg.xml:6290(refname)
msgid "CONNECT"
msgstr "CONNECT"

#: ecpg.xml:6291(refpurpose)
msgid "establish a database connection"
msgstr "установить подключение к базе данных"

#: ecpg.xml:6296(replaceable) ecpg.xml:6299(replaceable)
#: ecpg.xml:6317(replaceable)
msgid "connection_target"
msgstr "цель_подключения"

#: ecpg.xml:6296(replaceable) ecpg.xml:6780(replaceable)
#: ecpg.xml:6801(replaceable) ecpg.xml:7346(replaceable)
#: ecpg.xml:7365(replaceable)
msgid "connection_name"
msgstr "имя_подключения"

#: ecpg.xml:6296(replaceable) ecpg.xml:6298(replaceable)
#: ecpg.xml:6388(replaceable)
msgid "connection_user"
msgstr "пользователь_подключения"

#: ecpg.xml:6295(synopsis)
#, no-wrap
msgid ""
"CONNECT TO <placeholder-1/> [ AS <placeholder-2/> ] [ USER <placeholder-3/> ]\n"
"CONNECT TO DEFAULT\n"
"CONNECT <placeholder-4/>\n"
"DATABASE <placeholder-5/>"
msgstr ""
"CONNECT TO <placeholder-1/> [ AS <placeholder-2/> ] [ USER <placeholder-3/> ]\n"
"CONNECT TO DEFAULT\n"
"CONNECT <placeholder-4/>\n"
"DATABASE <placeholder-5/>"

#: ecpg.xml:6306(para)
msgid ""
"The <command>CONNECT</command> command establishes a connection between the "
"client and the PostgreSQL server."
msgstr ""
"Команда <command>CONNECT</command> устанавливает подключение клиента к "
"серверу PostgreSQL."

#: ecpg.xml:6326(term)
msgid ""
"[ <replaceable>database_name</replaceable> ] [ <literal>@</"
"literal><replaceable>host</replaceable> ] [ <literal>:</"
"literal><replaceable>port</replaceable> ]"
msgstr ""
"[ <replaceable>имя_бд</replaceable> ] [ <literal>@</"
"literal><replaceable>сервер</replaceable> ] [ <literal>:</"
"literal><replaceable>порт</replaceable> ]"

#: ecpg.xml:6328(para) ecpg.xml:6346(para)
msgid "Connect over TCP/IP"
msgstr "Подключение по TCP/IP"

#: ecpg.xml:6335(term)
msgid ""
"<literal>unix:postgresql://</literal><replaceable>host</replaceable> "
"[ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> "
"[ <replaceable>database_name</replaceable> ] [ <literal>?</"
"literal><replaceable>connection_option</replaceable> ]"
msgstr ""
"<literal>unix:postgresql://</literal><replaceable>сервер</replaceable> "
"[ <literal>:</literal><replaceable>порт</replaceable> ] <literal>/</literal> "
"[ <replaceable>имя_бд</replaceable> ] [ <literal>?</"
"literal><replaceable>параметр_подключения</replaceable> ]"

#: ecpg.xml:6337(para)
msgid "Connect over Unix-domain sockets"
msgstr "Подключение через доменные сокеты Unix"

#: ecpg.xml:6344(term)
msgid ""
"<literal>tcp:postgresql://</literal><replaceable>host</replaceable> "
"[ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> "
"[ <replaceable>database_name</replaceable> ] [ <literal>?</"
"literal><replaceable>connection_option</replaceable> ]"
msgstr ""
"<literal>tcp:postgresql://</literal><replaceable>сервер</replaceable> "
"[ <literal>:</literal><replaceable>порт</replaceable> ] <literal>/</literal> "
"[ <replaceable>имя_бд</replaceable> ] [ <literal>?</"
"literal><replaceable>параметр_подключения</replaceable> ]"

#: ecpg.xml:6353(term)
msgid "SQL string constant"
msgstr "Строковая константа SQL"

#: ecpg.xml:6355(para)
msgid "containing a value in one of the above forms"
msgstr "содержащая значение в одной из показанных выше форм"

#: ecpg.xml:6362(term)
msgid "host variable"
msgstr "переменная среды"

#: ecpg.xml:6364(para)
msgid ""
"host variable of type <type>char[]</type> or <type>VARCHAR[]</type> "
"containing a value in one of the above forms"
msgstr ""
"переменная среды типа <type>char[]</type> или <type>VARCHAR[]</type>, "
"содержащая значение в одной из показанных выше форм"

#: ecpg.xml:6319(para)
msgid ""
"<replaceable class=\"parameter\">connection_target</replaceable> specifies "
"the target server of the connection on one of several forms. <placeholder-1/>"
msgstr ""
"<replaceable class=\"parameter\">цель_соединения</replaceable> задаёт "
"целевой сервер и базу для подключения в одной из нескольких форм. "
"<placeholder-1/>"

#: ecpg.xml:6377(replaceable)
msgid "connection_object"
msgstr "объект_соединения"

#: ecpg.xml:6379(para)
msgid ""
"An optional identifier for the connection, so that it can be referred to in "
"other commands. This can be an SQL identifier or a host variable."
msgstr ""
"Необязательный идентификатор подключения, позволяющий обращаться к этому "
"подключению в других командах. Это может быть идентификатор SQL или "
"переменная среды."

#: ecpg.xml:6390(para)
msgid "The user name for the database connection."
msgstr "Имя пользователя для подключения к базе данных."

#: ecpg.xml:6394(para)
msgid ""
"This parameter can also specify user name and password, using one the forms "
"<literal><replaceable>user_name</replaceable>/<replaceable>password</"
"replaceable></literal>, <literal><replaceable>user_name</replaceable> "
"IDENTIFIED BY <replaceable>password</replaceable></literal>, or "
"<literal><replaceable>user_name</replaceable> USING <replaceable>password</"
"replaceable></literal>."
msgstr ""
"В этом параметре также можно передать имя и пароль одним из следующих "
"способов: <literal><replaceable>имя_пользователя</replaceable>/"
"<replaceable>пароль</replaceable></literal>, "
"<literal><replaceable>имя_пользователя</replaceable> IDENTIFIED BY "
"<replaceable>пароль</replaceable></literal> или "
"<literal><replaceable>имя_пользователя</replaceable> USING "
"<replaceable>пароль</replaceable></literal>."

#: ecpg.xml:6401(para)
msgid ""
"User name and password can be SQL identifiers, string constants, or host "
"variables."
msgstr ""
"В качестве имени пользователя и пароля можно задать идентификаторы SQL, "
"строковые константы или переменные среды."

#: ecpg.xml:6411(para)
msgid "Use all default connection parameters, as defined by libpq."
msgstr ""
"Использовать все параметры подключения по умолчанию, которые определены "
"библиотекой libpq."

#: ecpg.xml:6424(programlisting)
#, no-wrap
msgid ""
"EXEC SQL CONNECT TO \"connectdb\" AS main;\n"
"EXEC SQL CONNECT TO \"connectdb\" AS second;\n"
"EXEC SQL CONNECT TO \"unix:postgresql://200.46.204.71/connectdb\" AS main USER connectuser;\n"
"EXEC SQL CONNECT TO \"unix:postgresql://localhost/connectdb\" AS main USER connectuser;\n"
"EXEC SQL CONNECT TO 'connectdb' AS main;\n"
"EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;\n"
"EXEC SQL CONNECT TO :db AS :id;\n"
"EXEC SQL CONNECT TO :db USER connectuser USING :pw;\n"
"EXEC SQL CONNECT TO @localhost AS main USER connectdb;\n"
"EXEC SQL CONNECT TO REGRESSDB1 as main;\n"
"EXEC SQL CONNECT TO AS main USER connectdb;\n"
"EXEC SQL CONNECT TO connectdb AS :id;\n"
"EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;\n"
"EXEC SQL CONNECT TO connectdb AS main;\n"
"EXEC SQL CONNECT TO connectdb@localhost AS main;\n"
"EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;\n"
"EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;\n"
"EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY \"connectpw\";\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING \"connectpw\";\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;"
msgstr ""
"EXEC SQL CONNECT TO \"connectdb\" AS main;\n"
"EXEC SQL CONNECT TO \"connectdb\" AS second;\n"
"EXEC SQL CONNECT TO \"unix:postgresql://200.46.204.71/connectdb\" AS main USER connectuser;\n"
"EXEC SQL CONNECT TO \"unix:postgresql://localhost/connectdb\" AS main USER connectuser;\n"
"EXEC SQL CONNECT TO 'connectdb' AS main;\n"
"EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;\n"
"EXEC SQL CONNECT TO :db AS :id;\n"
"EXEC SQL CONNECT TO :db USER connectuser USING :pw;\n"
"EXEC SQL CONNECT TO @localhost AS main USER connectdb;\n"
"EXEC SQL CONNECT TO REGRESSDB1 as main;\n"
"EXEC SQL CONNECT TO AS main USER connectdb;\n"
"EXEC SQL CONNECT TO connectdb AS :id;\n"
"EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;\n"
"EXEC SQL CONNECT TO connectdb AS main;\n"
"EXEC SQL CONNECT TO connectdb@localhost AS main;\n"
"EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;\n"
"EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;\n"
"EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY \"connectpw\";\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING \"connectpw\";\n"
"EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;"

#: ecpg.xml:6422(para)
msgid ""
"Here a several variants for specifying connection parameters: <placeholder-1/"
">"
msgstr "Несколько вариантов указания параметров подключения: <placeholder-1/>"

#: ecpg.xml:6454(programlisting)
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    char *dbname     = \"testdb\";    /* database name */\n"
"    char *user       = \"testuser\";  /* connection user name */\n"
"    char *connection = \"tcp:postgresql://localhost:5432/testdb\";\n"
"                                    /* connection string */\n"
"    char ver[256];                  /* buffer to store the version string */\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    ECPGdebug(1, stderr);\n"
"\n"
"    EXEC SQL CONNECT TO :dbname USER :user;\n"
"    EXEC SQL SELECT version() INTO :ver;\n"
"    EXEC SQL DISCONNECT;\n"
"\n"
"    printf(\"version: %s\\n\", ver);\n"
"\n"
"    EXEC SQL CONNECT TO :connection USER :user;\n"
"    EXEC SQL SELECT version() INTO :ver;\n"
"    EXEC SQL DISCONNECT;\n"
"\n"
"    printf(\"version: %s\\n\", ver);\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    char *dbname     = \"testdb\";    /* имя базы данных */\n"
"    char *user       = \"testuser\";  /* имя пользователя подключения */\n"
"    char *connection = \"tcp:postgresql://localhost:5432/testdb\";\n"
"                                    /* строка подключения */\n"
"    char ver[256];                  /* буфер для хранения строки версии */\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    ECPGdebug(1, stderr);\n"
"\n"
"    EXEC SQL CONNECT TO :dbname USER :user;\n"
"    EXEC SQL SELECT version() INTO :ver;\n"
"    EXEC SQL DISCONNECT;\n"
"\n"
"    printf(\"version: %s\\n\", ver);\n"
"\n"
"    EXEC SQL CONNECT TO :connection USER :user;\n"
"    EXEC SQL SELECT version() INTO :ver;\n"
"    EXEC SQL DISCONNECT;\n"
"\n"
"    printf(\"version: %s\\n\", ver);\n"
"\n"
"    return 0;\n"
"}"

#: ecpg.xml:6451(para)
msgid ""
"Here is an example program that illustrates the use of host variables to "
"specify connection parameters: <placeholder-1/>"
msgstr ""
"Следующий пример программы демонстрирует применение переменных среды для "
"определения параметров подключения: <placeholder-1/>"

#: ecpg.xml:6489(para)
msgid ""
"<command>CONNECT</command> is specified in the SQL standard, but the format "
"of the connection parameters is implementation-specific."
msgstr ""
"Команда <command>CONNECT</command> описана в стандарте SQL, но формат "
"параметров подключения определяется реализацией."

#: ecpg.xml:6508(refname)
msgid "DEALLOCATE DESCRIPTOR"
msgstr "DEALLOCATE DESCRIPTOR"

#: ecpg.xml:6509(refpurpose)
msgid "deallocate an SQL descriptor area"
msgstr "освободить область SQL-дескриптора"

#: ecpg.xml:6513(synopsis)
#, no-wrap
msgid "DEALLOCATE DESCRIPTOR <placeholder-1/>"
msgstr "DEALLOCATE DESCRIPTOR <placeholder-1/>"

#: ecpg.xml:6521(para)
msgid ""
"<command>DEALLOCATE DESCRIPTOR</command> deallocates a named SQL descriptor "
"area."
msgstr ""
"<command>DEALLOCATE DESCRIPTOR</command> освобождает область именованного "
"SQL-дескриптора."

#: ecpg.xml:6534(para)
msgid ""
"The name of the descriptor which is going to be deallocated. It is case "
"sensitive. This can be an SQL identifier or a host variable."
msgstr ""
"Имя дескриптора, подлежащего освобождению, задаётся с учётом регистра. Это "
"может быть идентификатор SQL или переменная среды."

#: ecpg.xml:6547(programlisting)
#, no-wrap
msgid "EXEC SQL DEALLOCATE DESCRIPTOR mydesc;"
msgstr "EXEC SQL DEALLOCATE DESCRIPTOR mydesc;"

#: ecpg.xml:6555(para)
msgid ""
"<command>DEALLOCATE DESCRIPTOR</command> is specified in the SQL standard."
msgstr ""
"Команда <command>DEALLOCATE DESCRIPTOR</command> описана в стандарте SQL."

#: ecpg.xml:6574(refname)
msgid "DECLARE"
msgstr "DECLARE"

#: ecpg.xml:6575(refpurpose)
msgid "define a cursor"
msgstr "определить курсор"

#: ecpg.xml:6580(replaceable) ecpg.xml:6581(replaceable)
#: ecpg.xml:6606(replaceable) ecpg.xml:7139(replaceable)
#: ecpg.xml:7140(replaceable) ecpg.xml:7141(replaceable)
#: ecpg.xml:7163(replaceable)
msgid "cursor_name"
msgstr "имя_курсора"

#: ecpg.xml:6580(replaceable) ecpg.xml:6616(replaceable)
#: ecpg.xml:6691(replaceable) ecpg.xml:6692(replaceable)
#: ecpg.xml:6693(replaceable) ecpg.xml:6712(replaceable)
#: ecpg.xml:7254(replaceable)
msgid "prepared_name"
msgstr "подготовленный_оператор"

#: ecpg.xml:6581(replaceable) ecpg.xml:6626(replaceable)
msgid "query"
msgstr "запрос"

#: ecpg.xml:6579(synopsis)
#, no-wrap
msgid ""
"DECLARE <placeholder-1/> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <placeholder-2/>\n"
"DECLARE <placeholder-3/> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <placeholder-4/>"
msgstr ""
"DECLARE <placeholder-1/> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <placeholder-2/>\n"
"DECLARE <placeholder-3/> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <placeholder-4/>"

#: ecpg.xml:6588(para)
msgid ""
"<command>DECLARE</command> declares a cursor for iterating over the result "
"set of a prepared statement. This command has slightly different semantics "
"from the direct SQL command <command>DECLARE</command>: Whereas the latter "
"executes a query and prepares the result set for retrieval, this embedded "
"SQL command merely declares a name as a <quote>loop variable</quote> for "
"iterating over the result set of a query; the actual execution happens when "
"the cursor is opened with the <command>OPEN</command> command."
msgstr ""
"<command>DECLARE</command> объявляет курсор для прохода по набору "
"результатов подготовленного оператора. Эта команда несколько отличается от "
"обычной SQL-команды <command>DECLARE</command>: тогда как последняя "
"выполняет запрос и подготавливает набор результатов для получения, "
"встраиваемая SQL-команда просто объявляет имя в качестве <quote>переменной "
"цикла</quote> для прохода по набору результатов запроса; фактически запрос "
"выполнится, когда курсор будет открыт командой <command>OPEN</command>."

#: ecpg.xml:6608(para)
msgid ""
"A cursor name, case sensitive. This can be an SQL identifier or a host "
"variable."
msgstr ""
"Имя курсора, задаётся с учётом регистра. Это может быть идентификатор SQL "
"или переменная среды."

#: ecpg.xml:6618(para)
msgid ""
"The name of a prepared query, either as an SQL identifier or a host variable."
msgstr ""
"Имя подготовленного запроса, задаваемое SQL-идентификатором или переменной "
"среды."

#: ecpg.xml:6628(para)
msgid ""
"A <xref linkend=\"sql-select\"/> or <xref linkend=\"sql-values\"/> command "
"which will provide the rows to be returned by the cursor."
msgstr ""
"Команда <xref linkend=\"sql-select\"/> или <xref linkend=\"sql-values\"/>, "
"выдающая строки, которые будут получены через курсор."

#: ecpg.xml:6637(para)
msgid ""
"For the meaning of the cursor options, see <xref linkend=\"sql-declare\"/>."
msgstr ""
"Параметры курсора рассматриваются в описании <xref linkend=\"sql-declare\"/>."

#: ecpg.xml:6648(programlisting)
#, no-wrap
msgid ""
"EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;\n"
"EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();"
msgstr ""
"EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;\n"
"EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;\n"
"EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();"

#: ecpg.xml:6646(para)
msgid "Examples declaring a cursor for a query: <placeholder-1/>"
msgstr "Примеры объявления курсора для запроса: <placeholder-1/>"

#: ecpg.xml:6657(programlisting)
#, no-wrap
msgid ""
"EXEC SQL PREPARE stmt1 AS SELECT version();\n"
"EXEC SQL DECLARE cur1 CURSOR FOR stmt1;"
msgstr ""
"EXEC SQL PREPARE stmt1 AS SELECT version();\n"
"EXEC SQL DECLARE cur1 CURSOR FOR stmt1;"

#: ecpg.xml:6655(para)
msgid ""
"An example declaring a cursor for a prepared statement: <placeholder-1/>"
msgstr ""
"Пример объявления курсора для подготовленного оператора: <placeholder-1/>"

#: ecpg.xml:6667(para)
msgid "<command>DECLARE</command> is specified in the SQL standard."
msgstr "Команда <command>DECLARE</command> описана в стандарте SQL."

#: ecpg.xml:6685(refname)
msgid "DESCRIBE"
msgstr "DESCRIBE"

#: ecpg.xml:6686(refpurpose)
msgid "obtain information about a prepared statement or result set"
msgstr "получить информацию о подготовленном операторе или наборе результатов"

#: ecpg.xml:6691(replaceable) ecpg.xml:6692(replaceable)
#: ecpg.xml:6722(replaceable) ecpg.xml:6951(replaceable)
#: ecpg.xml:6952(replaceable) ecpg.xml:6983(replaceable)
#: ecpg.xml:7141(replaceable) ecpg.xml:7184(replaceable)
#: ecpg.xml:7420(replaceable) ecpg.xml:7421(replaceable)
#: ecpg.xml:7447(replaceable)
msgid "descriptor_name"
msgstr "имя_дескриптора"

#: ecpg.xml:6693(replaceable) ecpg.xml:6732(replaceable)
msgid "sqlda_name"
msgstr "имя_sqlda"

#: ecpg.xml:6690(synopsis)
#, no-wrap
msgid ""
"DESCRIBE [ OUTPUT ] <placeholder-1/> USING [ SQL ] DESCRIPTOR <placeholder-2/>\n"
"DESCRIBE [ OUTPUT ] <placeholder-3/> INTO [ SQL ] DESCRIPTOR <placeholder-4/>\n"
"DESCRIBE [ OUTPUT ] <placeholder-5/> INTO <placeholder-6/>"
msgstr ""
"DESCRIBE [ OUTPUT ] <placeholder-1/> USING [ SQL ] DESCRIPTOR <placeholder-2/>\n"
"DESCRIBE [ OUTPUT ] <placeholder-3/> INTO [ SQL ] DESCRIPTOR <placeholder-4/>\n"
"DESCRIBE [ OUTPUT ] <placeholder-5/> INTO <placeholder-6/>"

#: ecpg.xml:6700(para)
msgid ""
"<command>DESCRIBE</command> retrieves metadata information about the result "
"columns contained in a prepared statement, without actually fetching a row."
msgstr ""
"<command>DESCRIBE</command> получает метаданные о результирующих столбцах, "
"содержащихся в подготовленном операторе, не считывая собственно строки "
"результата."

#: ecpg.xml:6714(para)
msgid ""
"The name of a prepared statement. This can be an SQL identifier or a host "
"variable."
msgstr ""
"Имя подготовленного оператора. Это может быть идентификатор SQL или "
"переменная среды."

#: ecpg.xml:6724(para)
msgid ""
"A descriptor name. It is case sensitive. It can be an SQL identifier or a "
"host variable."
msgstr ""
"Имя дескриптора, задаётся с учётом регистра. Это может быть идентификатор "
"SQL или переменная среды."

#: ecpg.xml:6734(para)
msgid "The name of an SQLDA variable."
msgstr "Имя переменной SQLDA."

#: ecpg.xml:6745(programlisting)
#, no-wrap
msgid ""
"EXEC SQL ALLOCATE DESCRIPTOR mydesc;\n"
"EXEC SQL PREPARE stmt1 FROM :sql_stmt;\n"
"EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;\n"
"EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;\n"
"EXEC SQL DEALLOCATE DESCRIPTOR mydesc;"
msgstr ""
"EXEC SQL ALLOCATE DESCRIPTOR mydesc;\n"
"EXEC SQL PREPARE stmt1 FROM :sql_stmt;\n"
"EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;\n"
"EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;\n"
"EXEC SQL DEALLOCATE DESCRIPTOR mydesc;"

#: ecpg.xml:6757(para)
msgid "<command>DESCRIBE</command> is specified in the SQL standard."
msgstr "Команда <command>DESCRIBE</command> описана в стандарте SQL."

#: ecpg.xml:6774(refname)
msgid "DISCONNECT"
msgstr "DISCONNECT"

#: ecpg.xml:6775(refpurpose)
msgid "terminate a database connection"
msgstr "закрыть подключение к базе данных"

#: ecpg.xml:6779(synopsis)
#, no-wrap
msgid ""
"DISCONNECT <placeholder-1/>\n"
"DISCONNECT [ CURRENT ]\n"
"DISCONNECT DEFAULT\n"
"DISCONNECT ALL"
msgstr ""
"DISCONNECT <placeholder-1/>\n"
"DISCONNECT [ CURRENT ]\n"
"DISCONNECT DEFAULT\n"
"DISCONNECT ALL"

#: ecpg.xml:6790(para)
msgid ""
"<command>DISCONNECT</command> closes a connection (or all connections) to "
"the database."
msgstr ""
"<command>DISCONNECT</command> закрывает подключение (или все подключения) к "
"базе данных."

#: ecpg.xml:6803(para) ecpg.xml:7367(para)
msgid ""
"A database connection name established by the <command>CONNECT</command> "
"command."
msgstr ""
"Имя подключения к базе данных устанавливается командой <command>CONNECT</"
"command>."

#: ecpg.xml:6813(para)
msgid ""
"Close the <quote>current</quote> connection, which is either the most "
"recently opened connection, or the connection set by the <command>SET "
"CONNECTION</command> command. This is also the default if no argument is "
"given to the <command>DISCONNECT</command> command."
msgstr ""
"Закрывает <quote>текущее</quote> подключение, то есть подключение, открытое "
"последним, либо установленное командой <command>SET CONNECTION</command>. "
"Текущее подключение подразумевается по умолчанию, если <command>DISCONNECT</"
"command> выполняется без аргументов."

#: ecpg.xml:6826(para)
msgid "Close the default connection."
msgstr "Закрывает подключение по умолчанию."

#: ecpg.xml:6835(para)
msgid "Close all open connections."
msgstr "Закрывает все открытые подключения."

#: ecpg.xml:6846(programlisting)
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;\n"
"    EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"    EXEC SQL CONNECT TO testdb AS con2 USER testuser;\n"
"    EXEC SQL CONNECT TO testdb AS con3 USER testuser;\n"
"\n"
"    EXEC SQL DISCONNECT CURRENT;  /* close con3          */\n"
"    EXEC SQL DISCONNECT DEFAULT;  /* close DEFAULT       */\n"
"    EXEC SQL DISCONNECT ALL;      /* close con2 and con1 */\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;\n"
"    EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"    EXEC SQL CONNECT TO testdb AS con2 USER testuser;\n"
"    EXEC SQL CONNECT TO testdb AS con3 USER testuser;\n"
"\n"
"    EXEC SQL DISCONNECT CURRENT;  /* закрывает con3          */\n"
"    EXEC SQL DISCONNECT DEFAULT;  /* закрывает DEFAULT       */\n"
"    EXEC SQL DISCONNECT ALL;      /* закрывает con2 и con1 */\n"
"\n"
"    return 0;\n"
"}"

#: ecpg.xml:6867(para)
msgid "<command>DISCONNECT</command> is specified in the SQL standard."
msgstr "Команда <command>DISCONNECT</command> описана в стандарте SQL."

#: ecpg.xml:6884(refname)
msgid "EXECUTE IMMEDIATE"
msgstr "EXECUTE IMMEDIATE"

#: ecpg.xml:6885(refpurpose)
msgid "dynamically prepare and execute a statement"
msgstr "динамически подготовить и выполнить оператор"

#: ecpg.xml:6890(replaceable) ecpg.xml:6909(replaceable)
#: ecpg.xml:7233(replaceable) ecpg.xml:7263(replaceable)
msgid "string"
msgstr "строка"

#: ecpg.xml:6889(synopsis)
#, no-wrap
msgid "EXECUTE IMMEDIATE <placeholder-1/>"
msgstr "EXECUTE IMMEDIATE <placeholder-1/>"

#: ecpg.xml:6897(para)
msgid ""
"<command>EXECUTE IMMEDIATE</command> immediately prepares and executes a "
"dynamically specified SQL statement, without retrieving result rows."
msgstr ""
"<command>EXECUTE IMMEDIATE</command> немедленно подготавливает и выполняет "
"динамически задаваемый оператор SQL, не получая при этом строки результата."

#: ecpg.xml:6911(para)
msgid ""
"A literal C string or a host variable containing the SQL statement to be "
"executed."
msgstr ""
"Строковая константа C или переменная среды, содержащая SQL-оператор, который "
"нужно выполнить."

#: ecpg.xml:6927(programlisting)
#, no-wrap
msgid ""
"sprintf(command, \"INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')\");\n"
"EXEC SQL EXECUTE IMMEDIATE :command;"
msgstr ""
"sprintf(command, \"INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')\");\n"
"EXEC SQL EXECUTE IMMEDIATE :command;"

#: ecpg.xml:6923(para)
msgid ""
"Here is an example that executes an <command>INSERT</command> statement "
"using <command>EXECUTE IMMEDIATE</command> and a host variable named "
"<varname>command</varname>: <placeholder-1/>"
msgstr ""
"Пример выполнения оператора <command>INSERT</command> с применением команды "
"<command>EXECUTE IMMEDIATE</command> и переменной среды <varname>command</"
"varname>: <placeholder-1/>"

#: ecpg.xml:6937(para)
msgid "<command>EXECUTE IMMEDIATE</command> is specified in the SQL standard."
msgstr "Команда <command>EXECUTE IMMEDIATE</command> описана в стандарте SQL."

#: ecpg.xml:6945(refname)
msgid "GET DESCRIPTOR"
msgstr "GET DESCRIPTOR"

#: ecpg.xml:6946(refpurpose)
msgid "get information from an SQL descriptor area"
msgstr "получить информацию из области дескриптора SQL"

#: ecpg.xml:6951(replaceable) ecpg.xml:6952(replaceable)
msgid ":cvariable"
msgstr ":cvariable"

#: ecpg.xml:6951(replaceable) ecpg.xml:6992(replaceable)
#: ecpg.xml:7420(replaceable) ecpg.xml:7456(replaceable)
msgid "descriptor_header_item"
msgstr "элемент_заголовка_дескриптора"

#: ecpg.xml:6952(replaceable) ecpg.xml:7003(replaceable)
msgid "column_number"
msgstr "номер_столбца"

#: ecpg.xml:6952(replaceable) ecpg.xml:7013(replaceable)
#: ecpg.xml:7421(replaceable) ecpg.xml:7477(replaceable)
msgid "descriptor_item"
msgstr "элемент_дескриптора"

#: ecpg.xml:6950(synopsis)
#, no-wrap
msgid ""
"GET DESCRIPTOR <placeholder-1/> <placeholder-2/> = <placeholder-3/> [, ... ]\n"
"GET DESCRIPTOR <placeholder-4/> VALUE <placeholder-5/> <placeholder-6/> = <placeholder-7/> [, ... ]"
msgstr ""
"GET DESCRIPTOR <placeholder-1/> <placeholder-2/> = <placeholder-3/> [, ... ]\n"
"GET DESCRIPTOR <placeholder-4/> VALUE <placeholder-5/> <placeholder-6/> = <placeholder-7/> [, ... ]"

#: ecpg.xml:6959(para)
msgid ""
"<command>GET DESCRIPTOR</command> retrieves information about a query result "
"set from an SQL descriptor area and stores it into host variables. A "
"descriptor area is typically populated using <command>FETCH</command> or "
"<command>SELECT</command> before using this command to transfer the "
"information into host language variables."
msgstr ""
"<command>GET DESCRIPTOR</command> получает информацию о наборе результатов "
"запроса из области дескриптора SQL и сохраняет её в переменные среды. "
"Область дескриптора обычно предварительно заполняется командами "
"<command>FETCH</command> или <command>SELECT</command>, чтобы из неё можно "
"было перенести сопутствующую информацию в переменные среды."

#: ecpg.xml:6968(para)
msgid ""
"This command has two forms: The first form retrieves descriptor "
"<quote>header</quote> items, which apply to the result set in its entirety. "
"One example is the row count. The second form, which requires the column "
"number as additional parameter, retrieves information about a particular "
"column. Examples are the column name and the actual column value."
msgstr ""
"Эта команда имеет две формы: первая форма выдаёт элементы из "
"<quote>заголовка</quote> дескриптора, который относится ко всему набору "
"результатов в целом. Например, это число строк. Другая форма, требующая "
"указания в дополнительном параметре номера столбца, выдаёт информацию о "
"конкретном столбце строки. В качестве примеров можно привести имя столбца и "
"фактическое значение в этом столбце."

#: ecpg.xml:6985(para) ecpg.xml:7449(para)
msgid "A descriptor name."
msgstr "Имя дескриптора."

#: ecpg.xml:6994(para)
msgid ""
"A token identifying which header information item to retrieve. Only "
"<literal>COUNT</literal>, to get the number of columns in the result set, is "
"currently supported."
msgstr ""
"Идентификатор, определяющий, какой элемент заголовка нужно получить. В "
"настоящее время поддерживается только <literal>COUNT</literal>, позволяющий "
"получить число столбцов в наборе результатов."

#: ecpg.xml:7005(para)
msgid ""
"The number of the column about which information is to be retrieved. The "
"count starts at 1."
msgstr ""
"Номер столбца, информацию о котором нужно получить. Нумерация начинается с 1."

#: ecpg.xml:7015(para)
msgid ""
"A token identifying which item of information about a column to retrieve. "
"See <xref linkend=\"ecpg-named-descriptors\"/> for a list of supported items."
msgstr ""
"Идентификатор, определяющий, какой элемент информации о столбце нужно "
"получить. Список поддерживаемых элементов приведён в <xref remap=\"6\" "
"linkend=\"ecpg-named-descriptors\"/>."

#: ecpg.xml:7024(replaceable)
msgid "cvariable"
msgstr "cvariable"

#: ecpg.xml:7026(para)
msgid ""
"A host variable that will receive the data retrieved from the descriptor "
"area."
msgstr ""
"Переменная среды, в которую будут сохранены данные, полученные из области "
"дескриптора."

#: ecpg.xml:7040(programlisting)
#, no-wrap
msgid "EXEC SQL GET DESCRIPTOR d :d_count = COUNT;"
msgstr "EXEC SQL GET DESCRIPTOR d :d_count = COUNT;"

#: ecpg.xml:7038(para)
msgid ""
"An example to retrieve the number of columns in a result set: <placeholder-1/"
">"
msgstr "Пример получения числа столбцов в наборе результатов: <placeholder-1/>"

#: ecpg.xml:7047(programlisting)
#, no-wrap
msgid "EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;"
msgstr "EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;"

#: ecpg.xml:7045(para)
msgid ""
"An example to retrieve a data length in the first column: <placeholder-1/>"
msgstr "Пример получения размера данных в первом столбце: <placeholder-1/>"

#: ecpg.xml:7055(programlisting)
#, no-wrap
msgid "EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;"
msgstr "EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;"

#: ecpg.xml:7052(para)
msgid ""
"An example to retrieve the data body of the second column as a string: "
"<placeholder-1/>"
msgstr ""
"Пример получения содержимого данных второго столбца в виде строки: "
"<placeholder-1/>"

#: ecpg.xml:7064(programlisting)
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    int  d_count;\n"
"    char d_data[1024];\n"
"    int  d_returned_octet_length;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"    EXEC SQL ALLOCATE DESCRIPTOR d;\n"
"\n"
"    /* Declare, open a cursor, and assign a descriptor to the cursor  */\n"
"    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();\n"
"    EXEC SQL OPEN cur;\n"
"    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;\n"
"\n"
"    /* Get a number of total columns */\n"
"    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;\n"
"    printf(\"d_count                 = %d\\n\", d_count);\n"
"\n"
"    /* Get length of a returned column */\n"
"    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;\n"
"    printf(\"d_returned_octet_length = %d\\n\", d_returned_octet_length);\n"
"\n"
"    /* Fetch the returned column as a string */\n"
"    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;\n"
"    printf(\"d_data                  = %s\\n\", d_data);\n"
"\n"
"    /* Closing */\n"
"    EXEC SQL CLOSE cur;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DEALLOCATE DESCRIPTOR d;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    int  d_count;\n"
"    char d_data[1024];\n"
"    int  d_returned_octet_length;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb AS con1 USER testuser;\n"
"    EXEC SQL ALLOCATE DESCRIPTOR d;\n"
"\n"
"    /* Объявить, открыть курсор и присвоить ему дескриптор */\n"
"    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();\n"
"    EXEC SQL OPEN cur;\n"
"    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;\n"
"\n"
"    /* Получить общее число столбцов */\n"
"    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;\n"
"    printf(\"d_count                 = %d\\n\", d_count);\n"
"\n"
"    /* Получить размер возвращённого столбца */\n"
"    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;\n"
"    printf(\"d_returned_octet_length = %d\\n\", d_returned_octet_length);\n"
"\n"
"    /* Выбрать возвращённый столбец в виде строки */\n"
"    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;\n"
"    printf(\"d_data                  = %s\\n\", d_data);\n"
"\n"
"    /* Закрытие */\n"
"    EXEC SQL CLOSE cur;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DEALLOCATE DESCRIPTOR d;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"\n"
"    return 0;\n"
"}"

#: ecpg.xml:7060(para)
msgid ""
"Here is an example for a whole procedure of executing <literal>SELECT "
"current_database();</literal> and showing the number of columns, the column "
"data length, and the column data: <placeholder-1/> When the example is "
"executed, the result will look like this: <screen>\n"
"d_count                 = 1\n"
"d_returned_octet_length = 6\n"
"d_data                  = testdb\n"
"</screen>"
msgstr ""
"Следующий пример демонстрирует всю процедуру выполнения <literal>SELECT "
"current_database();</literal> и вывода числа столбцов, длины данных в "
"столбце и содержимого столбца: <placeholder-1/> При выполнении этого примера "
"будет получен такой результат: <screen>\n"
"d_count                 = 1\n"
"d_returned_octet_length = 6\n"
"d_data                  = testdb\n"
"</screen>"

#: ecpg.xml:7116(para)
msgid "<command>GET DESCRIPTOR</command> is specified in the SQL standard."
msgstr "Команда <command>GET DESCRIPTOR</command> описана в стандарте SQL."

#: ecpg.xml:7133(refname)
msgid "OPEN"
msgstr "OPEN"

#: ecpg.xml:7134(refpurpose)
msgid "open a dynamic cursor"
msgstr "открыть динамический курсор"

#: ecpg.xml:7140(replaceable) ecpg.xml:7173(replaceable)
#: ecpg.xml:7420(replaceable) ecpg.xml:7421(replaceable)
#: ecpg.xml:7488(replaceable)
msgid "value"
msgstr "значение"

#: ecpg.xml:7138(synopsis)
#, no-wrap
msgid ""
"OPEN <placeholder-1/>\n"
"OPEN <placeholder-2/> USING <placeholder-3/> [, ... ]\n"
"OPEN <placeholder-4/> USING SQL DESCRIPTOR <placeholder-5/>"
msgstr ""
"OPEN <placeholder-1/>\n"
"OPEN <placeholder-2/> USING <placeholder-3/> [, ... ]\n"
"OPEN <placeholder-4/> USING SQL DESCRIPTOR <placeholder-5/>"

#: ecpg.xml:7148(para)
msgid ""
"<command>OPEN</command> opens a cursor and optionally binds actual values to "
"the placeholders in the cursor's declaration. The cursor must previously "
"have been declared with the <command>DECLARE</command> command. The "
"execution of <command>OPEN</command> causes the query to start executing on "
"the server."
msgstr ""
"<command>OPEN</command> открывает курсор и в дополнение может связывать "
"фактические значения с местозаполнителями в объявлении курсора. Курсор "
"должен быть предварительно объявлен командой <command>DECLARE</command>. "
"Команда <command>OPEN</command> запускает выполнение запроса на сервере."

#: ecpg.xml:7165(para)
msgid ""
"The name of the cursor to be opened. This can be an SQL identifier or a host "
"variable."
msgstr ""
"Имя открываемого курсора. Этот может быть идентификатор SQL или переменная "
"среды."

#: ecpg.xml:7175(para)
msgid ""
"A value to be bound to a placeholder in the cursor. This can be an SQL "
"constant, a host variable, or a host variable with indicator."
msgstr ""
"Значение, связываемое с местозаполнителем в курсоре. Это может быть "
"константа SQL, переменная среды или переменная среды с индикатором."

#: ecpg.xml:7186(para)
msgid ""
"The name of a descriptor containing values to be bound to the placeholders "
"in the cursor. This can be an SQL identifier or a host variable."
msgstr ""
"Имя дескриптора, содержащего значения, которые должны быть связаны с "
"местозаполнителями в курсоре. Это может быть идентификатор SQL или "
"переменная среды."

#: ecpg.xml:7199(programlisting)
#, no-wrap
msgid ""
"EXEC SQL OPEN a;\n"
"EXEC SQL OPEN d USING 1, 'test';\n"
"EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;\n"
"EXEC SQL OPEN :curname1;"
msgstr ""
"EXEC SQL OPEN a;\n"
"EXEC SQL OPEN d USING 1, 'test';\n"
"EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;\n"
"EXEC SQL OPEN :curname1;"

#: ecpg.xml:7210(para)
msgid "<command>OPEN</command> is specified in the SQL standard."
msgstr "Команда <command>OPEN</command> описана в стандарте SQL."

#: ecpg.xml:7227(refname)
msgid "PREPARE"
msgstr "PREPARE"

#: ecpg.xml:7228(refpurpose)
msgid "prepare a statement for execution"
msgstr "подготовить оператор к выполнению"

#: ecpg.xml:7232(synopsis)
#, no-wrap
msgid "PREPARE <placeholder-1/> FROM <placeholder-2/>"
msgstr "PREPARE <placeholder-1/> FROM <placeholder-2/>"

#: ecpg.xml:7240(para)
msgid ""
"<command>PREPARE</command> prepares a statement dynamically specified as a "
"string for execution. This is different from the direct SQL statement <xref "
"linkend=\"sql-prepare\"/>, which can also be used in embedded programs. The "
"<xref linkend=\"sql-execute\"/> command is used to execute either kind of "
"prepared statement."
msgstr ""
"Команда <command>PREPARE</command> подготавливает к выполнению динамический "
"оператор, задаваемый в виде строки. Она отличается от обычного SQL-оператора "
"<xref linkend=\"sql-prepare\"/>, который также можно использовать во "
"встраиваемых командах. Для обоих типов подготовленных операторов применяется "
"команда <xref linkend=\"sql-execute\"/>."

#: ecpg.xml:7256(para)
msgid "An identifier for the prepared query."
msgstr "Идентификатор для подготовленного запроса."

#: ecpg.xml:7265(para)
msgid ""
"A literal C string or a host variable containing a preparable statement, one "
"of the SELECT, INSERT, UPDATE, or DELETE."
msgstr ""
"Строковая константа C или переменная среды, содержащая подготавливаемый "
"оператор: SELECT, INSERT, UPDATE или DELETE."

#: ecpg.xml:7277(programlisting)
#, no-wrap
msgid ""
"char *stmt = \"SELECT * FROM test1 WHERE a = ? AND b = ?\";\n"
"\n"
"EXEC SQL ALLOCATE DESCRIPTOR outdesc;\n"
"EXEC SQL PREPARE foo FROM :stmt;\n"
"\n"
"EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;"
msgstr ""
"char *stmt = \"SELECT * FROM test1 WHERE a = ? AND b = ?\";\n"
"\n"
"EXEC SQL ALLOCATE DESCRIPTOR outdesc;\n"
"EXEC SQL PREPARE foo FROM :stmt;\n"
"\n"
"EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;"

#: ecpg.xml:7290(para)
msgid "<command>PREPARE</command> is specified in the SQL standard."
msgstr "Команда <command>PREPARE</command> описана в стандарте SQL."

#: ecpg.xml:7306(refname)
msgid "SET AUTOCOMMIT"
msgstr "SET AUTOCOMMIT"

#: ecpg.xml:7307(refpurpose)
msgid "set the autocommit behavior of the current session"
msgstr "установить режим автофиксации для текущего сеанса"

#: ecpg.xml:7311(synopsis)
#, no-wrap
msgid "SET AUTOCOMMIT { = | TO } { ON | OFF }"
msgstr "SET AUTOCOMMIT { = | TO } { ON | OFF }"

#: ecpg.xml:7319(para)
msgid ""
"<command>SET AUTOCOMMIT</command> sets the autocommit behavior of the "
"current database session. By default, embedded SQL programs are "
"<emphasis>not</emphasis> in autocommit mode, so <command>COMMIT</command> "
"needs to be issued explicitly when desired. This command can change the "
"session to autocommit mode, where each individual statement is committed "
"implicitly."
msgstr ""
"<command>SET AUTOCOMMIT</command> устанавливает режим автофиксации для "
"текущего сеанса использования базы данных. По умолчанию программы со "
"встраиваемым SQL работают <emphasis>не</emphasis> в режиме автофиксации, так "
"что в определённые моменты нужно явно выполнять <command>COMMIT</command>. "
"Эта команда может переключить сеанс в режим автофиксации, когда неявно "
"фиксируется каждый отдельный оператор."

#: ecpg.xml:7332(para)
msgid "<command>SET AUTOCOMMIT</command> is an extension of PostgreSQL ECPG."
msgstr "<command>SET AUTOCOMMIT</command> — расширение PostgreSQL ECPG."

#: ecpg.xml:7340(refname)
msgid "SET CONNECTION"
msgstr "SET CONNECTION"

#: ecpg.xml:7341(refpurpose)
msgid "select a database connection"
msgstr "выбрать подключение к базе данных"

#: ecpg.xml:7345(synopsis)
#, no-wrap
msgid "SET CONNECTION [ TO | = ] <placeholder-1/>"
msgstr "SET CONNECTION [ TO | = ] <placeholder-1/>"

#: ecpg.xml:7353(para)
msgid ""
"<command>SET CONNECTION</command> sets the <quote>current</quote> database "
"connection, which is the one that all commands use unless overridden."
msgstr ""
"<command>SET CONNECTION</command> устанавливает <quote>текущее</quote> "
"подключение к базе данных, которое будет использоваться командами, не "
"задающими подключение явно."

#: ecpg.xml:7377(para)
msgid "Set the connection to the default connection."
msgstr "Устанавливает заданное подключение подключением по умолчанию."

#: ecpg.xml:7388(programlisting)
#, no-wrap
msgid ""
"EXEC SQL SET CONNECTION TO con2;\n"
"EXEC SQL SET CONNECTION = con1;"
msgstr ""
"EXEC SQL SET CONNECTION TO con2;\n"
"EXEC SQL SET CONNECTION = con1;"

#: ecpg.xml:7397(para)
msgid "<command>SET CONNECTION</command> is specified in the SQL standard."
msgstr "Команда <command>SET CONNECTION</command> описана в стандарте SQL."

#: ecpg.xml:7414(refname)
msgid "SET DESCRIPTOR"
msgstr "SET DESCRIPTOR"

#: ecpg.xml:7415(refpurpose)
msgid "set information in an SQL descriptor area"
msgstr "внести информацию в область дескриптора SQL"

#: ecpg.xml:7421(replaceable) ecpg.xml:7467(replaceable)
msgid "number"
msgstr "номер"

#: ecpg.xml:7419(synopsis)
#, no-wrap
msgid ""
"SET DESCRIPTOR <placeholder-1/> <placeholder-2/> = <placeholder-3/> [, ... ]\n"
"SET DESCRIPTOR <placeholder-4/> VALUE <placeholder-5/> <placeholder-6/> = <placeholder-7/> [, ...]"
msgstr ""
"SET DESCRIPTOR <placeholder-1/> <placeholder-2/> = <placeholder-3/> [, ... ]\n"
"SET DESCRIPTOR <placeholder-4/> VALUE <placeholder-5/> <placeholder-6/> = <placeholder-7/> [, ...]"

#: ecpg.xml:7428(para)
msgid ""
"<command>SET DESCRIPTOR</command> populates an SQL descriptor area with "
"values. The descriptor area is then typically used to bind parameters in a "
"prepared query execution."
msgstr ""
"<command>SET DESCRIPTOR</command> заполняет область SQL-дескриптора "
"значениями. Заполненная область дескриптора обычно применяется для "
"привязывания параметров при выполнении подготовленного запроса."

#: ecpg.xml:7434(para)
msgid ""
"This command has two forms: The first form applies to the descriptor "
"<quote>header</quote>, which is independent of a particular datum. The "
"second form assigns values to particular datums, identified by number."
msgstr ""
"Эта команда имеет две формы: первая применяется к <quote>заголовку</quote> "
"дескриптора, который не зависит от конкретных данных. Вторая форма "
"устанавливает значения для определённых полей по номерам."

#: ecpg.xml:7458(para)
msgid ""
"A token identifying which header information item to set. Only "
"<literal>COUNT</literal>, to set the number of descriptor items, is "
"currently supported."
msgstr ""
"Идентификатор, определяющий, какой элемент заголовка нужно задать. В "
"настоящее время поддерживается только <literal>COUNT</literal>, позволяющий "
"задать число элементов в дескрипторе."

#: ecpg.xml:7469(para)
msgid "The number of the descriptor item to set. The count starts at 1."
msgstr ""
"Номер элемента дескриптора, для которого задаётся значение. Нумерация "
"начинается с 1."

#: ecpg.xml:7479(para)
msgid ""
"A token identifying which item of information to set in the descriptor. See "
"<xref linkend=\"ecpg-named-descriptors\"/> for a list of supported items."
msgstr ""
"Идентификатор, определяющий, какой элемент нужно установить в дескрипторе. "
"Список поддерживаемых элементов приведён в <xref remap=\"6\" linkend=\"ecpg-"
"named-descriptors\"/>."

#: ecpg.xml:7490(para)
msgid ""
"A value to store into the descriptor item. This can be an SQL constant or a "
"host variable."
msgstr ""
"Значение, которое нужно поместить в элемент дескриптора. Это может быть "
"константа SQL или переменная среды."

#: ecpg.xml:7501(programlisting)
#, no-wrap
msgid ""
"EXEC SQL SET DESCRIPTOR indesc COUNT = 1;\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;"
msgstr ""
"EXEC SQL SET DESCRIPTOR indesc COUNT = 1;\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';\n"
"EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;"

#: ecpg.xml:7513(para)
msgid "<command>SET DESCRIPTOR</command> is specified in the SQL standard."
msgstr "Команда <command>SET DESCRIPTOR</command> описана в стандарте SQL."

#: ecpg.xml:7530(refname)
msgid "TYPE"
msgstr "TYPE"

#: ecpg.xml:7531(refpurpose)
msgid "define a new data type"
msgstr "создать новый тип данных"

#: ecpg.xml:7536(replaceable) ecpg.xml:7560(replaceable)
msgid "type_name"
msgstr "имя_типа"

#: ecpg.xml:7536(replaceable) ecpg.xml:7569(replaceable)
#: ecpg.xml:7674(replaceable) ecpg.xml:7702(replaceable)
msgid "ctype"
msgstr "тип_С"

#: ecpg.xml:7535(synopsis)
#, no-wrap
msgid "TYPE <placeholder-1/> IS <placeholder-2/>"
msgstr "TYPE <placeholder-1/> IS <placeholder-2/>"

#: ecpg.xml:7543(para)
msgid ""
"The <command>TYPE</command> command defines a new C type. It is equivalent "
"to putting a <literal>typedef</literal> into a declare section."
msgstr ""
"Команда <command>TYPE</command> определяет новый тип C. Она равнозначна "
"добавлению <literal>typedef</literal> в секции объявлений."

#: ecpg.xml:7549(para)
msgid ""
"This command is only recognized when <command>ecpg</command> is run with the "
"<option>-c</option> option."
msgstr ""
"Эта команда принимается, только когда <command>ecpg</command> запускается с "
"параметром <option>-c</option>."

#: ecpg.xml:7562(para)
msgid "The name for the new type. It must be a valid C type name."
msgstr "Имя нового типа. Это имя должно быть допустимым для типа в языке C."

#: ecpg.xml:7571(para) ecpg.xml:7704(para)
msgid "A C type specification."
msgstr "Определение типа C."

#: ecpg.xml:7582(programlisting)
#, no-wrap
msgid ""
"EXEC SQL TYPE customer IS\n"
"    struct\n"
"    {\n"
"        varchar name[50];\n"
"        int     phone;\n"
"    };\n"
"\n"
"EXEC SQL TYPE cust_ind IS\n"
"    struct ind\n"
"    {\n"
"        short   name_ind;\n"
"        short   phone_ind;\n"
"    };\n"
"\n"
"EXEC SQL TYPE c IS char reference;\n"
"EXEC SQL TYPE ind IS union { int integer; short smallint; };\n"
"EXEC SQL TYPE intarray IS int[AMOUNT];\n"
"EXEC SQL TYPE str IS varchar[BUFFERSIZ];\n"
"EXEC SQL TYPE string IS char[11];"
msgstr ""
"EXEC SQL TYPE customer IS\n"
"    struct\n"
"    {\n"
"        varchar name[50];\n"
"        int     phone;\n"
"    };\n"
"\n"
"EXEC SQL TYPE cust_ind IS\n"
"    struct ind\n"
"    {\n"
"        short   name_ind;\n"
"        short   phone_ind;\n"
"    };\n"
"\n"
"EXEC SQL TYPE c IS char reference;\n"
"EXEC SQL TYPE ind IS union { int integer; short smallint; };\n"
"EXEC SQL TYPE intarray IS int[AMOUNT];\n"
"EXEC SQL TYPE str IS varchar[BUFFERSIZ];\n"
"EXEC SQL TYPE string IS char[11];"

#: ecpg.xml:7607(programlisting)
#, no-wrap
msgid ""
"EXEC SQL WHENEVER SQLERROR SQLPRINT;\n"
"\n"
"EXEC SQL TYPE tt IS\n"
"    struct\n"
"    {\n"
"        varchar v[256];\n"
"        int     i;\n"
"    };\n"
"\n"
"EXEC SQL TYPE tt_ind IS\n"
"    struct ind {\n"
"        short   v_ind;\n"
"        short   i_ind;\n"
"    };\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    tt t;\n"
"    tt_ind t_ind;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb AS con1;\n"
"\n"
"    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;\n"
"\n"
"    printf(\"t.v = %s\\n\", t.v.arr);\n"
"    printf(\"t.i = %d\\n\", t.i);\n"
"\n"
"    printf(\"t_ind.v_ind = %d\\n\", t_ind.v_ind);\n"
"    printf(\"t_ind.i_ind = %d\\n\", t_ind.i_ind);\n"
"\n"
"    EXEC SQL DISCONNECT con1;\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"EXEC SQL WHENEVER SQLERROR SQLPRINT;\n"
"\n"
"EXEC SQL TYPE tt IS\n"
"    struct\n"
"    {\n"
"        varchar v[256];\n"
"        int     i;\n"
"    };\n"
"\n"
"EXEC SQL TYPE tt_ind IS\n"
"    struct ind {\n"
"        short   v_ind;\n"
"        short   i_ind;\n"
"    };\n"
"\n"
"int\n"
"main(void)\n"
"{\n"
"EXEC SQL BEGIN DECLARE SECTION;\n"
"    tt t;\n"
"    tt_ind t_ind;\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"    EXEC SQL CONNECT TO testdb AS con1;\n"
"\n"
"    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;\n"
"\n"
"    printf(\"t.v = %s\\n\", t.v.arr);\n"
"    printf(\"t.i = %d\\n\", t.i);\n"
"\n"
"    printf(\"t_ind.v_ind = %d\\n\", t_ind.v_ind);\n"
"    printf(\"t_ind.i_ind = %d\\n\", t_ind.i_ind);\n"
"\n"
"    EXEC SQL DISCONNECT con1;\n"
"\n"
"    return 0;\n"
"}"

#: ecpg.xml:7604(para)
msgid ""
"Here is an example program that uses <command>EXEC SQL TYPE</command>: "
"<placeholder-1/> The output from this program looks like this: <screen>\n"
"t.v = testdb\n"
"t.i = 256\n"
"t_ind.v_ind = 0\n"
"t_ind.i_ind = 0\n"
"</screen>"
msgstr ""
"Пример программы, в которой используется <command>EXEC SQL TYPE</command>: "
"<placeholder-1/> Эта программа выдаёт следующее: <screen>\n"
"t.v = testdb\n"
"t.i = 256\n"
"t_ind.v_ind = 0\n"
"t_ind.i_ind = 0\n"
"</screen>"

#: ecpg.xml:7660(para)
msgid "The <command>TYPE</command> command is a PostgreSQL extension."
msgstr "Команда <command>TYPE</command> — расширение PostgreSQL."

#: ecpg.xml:7668(refname)
msgid "VAR"
msgstr "VAR"

#: ecpg.xml:7669(refpurpose)
msgid "define a variable"
msgstr "определить переменную"

#: ecpg.xml:7674(replaceable) ecpg.xml:7693(replaceable)
msgid "varname"
msgstr "имя_переменной"

#: ecpg.xml:7673(synopsis)
#, no-wrap
msgid "VAR <placeholder-1/> IS <placeholder-2/>"
msgstr "VAR <placeholder-1/> IS <placeholder-2/>"

#: ecpg.xml:7681(para)
msgid ""
"The <command>VAR</command> command assigns a new C data type to a host "
"variable. The host variable must be previously declared in a declare section."
msgstr ""
"Команда <command>VAR</command> назначает переменной среды новый тип данных "
"C. Переменная среды должна быть объявлена ранее в секции объявлений."

#: ecpg.xml:7695(para)
msgid "A C variable name."
msgstr "Имя переменной C."

#: ecpg.xml:7715(programlisting)
#, no-wrap
msgid ""
"Exec sql begin declare section;\n"
"short a;\n"
"exec sql end declare section;\n"
"EXEC SQL VAR a IS int;"
msgstr ""
"Exec sql begin declare section;\n"
"short a;\n"
"exec sql end declare section;\n"
"EXEC SQL VAR a IS int;"

#: ecpg.xml:7726(para)
msgid "The <command>VAR</command> command is a PostgreSQL extension."
msgstr "Команда <command>VAR</command> — расширение PostgreSQL."

#: ecpg.xml:7734(refname)
msgid "WHENEVER"
msgstr "WHENEVER"

#: ecpg.xml:7735(refpurpose)
msgid ""
"specify the action to be taken when an SQL statement causes a specific class "
"condition to be raised"
msgstr ""
"определить действие, которое должно выполняться, когда при обработке SQL-"
"оператора возникает определённое условие"

#: ecpg.xml:7740(replaceable)
msgid "action"
msgstr "действие"

#: ecpg.xml:7739(synopsis)
#, no-wrap
msgid "WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <placeholder-1/>"
msgstr "WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <placeholder-1/>"

#: ecpg.xml:7747(para)
msgid ""
"Define a behavior which is called on the special cases (Rows not found, SQL "
"warnings or errors) in the result of SQL execution."
msgstr ""
"Устанавливает поведение в случае определённых условий (строки не найдены, "
"выданы предупреждения или ошибки SQL и т. д.), возникающих в ходе выполнения "
"SQL."

#: ecpg.xml:7756(para)
msgid ""
"See <xref linkend=\"ecpg-whenever\"/> for a description of the parameters."
msgstr ""
"Описание параметров приведено в <xref remap=\"6\" linkend=\"ecpg-whenever\"/"
">."

#: ecpg.xml:7765(programlisting)
#, no-wrap
msgid ""
"EXEC SQL WHENEVER NOT FOUND CONTINUE;\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"EXEC SQL WHENEVER SQLWARNING SQLPRINT;\n"
"EXEC SQL WHENEVER SQLWARNING DO warn();\n"
"EXEC SQL WHENEVER SQLERROR sqlprint;\n"
"EXEC SQL WHENEVER SQLERROR CALL print2();\n"
"EXEC SQL WHENEVER SQLERROR DO handle_error(\"select\");\n"
"EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);\n"
"EXEC SQL WHENEVER SQLERROR DO sqlprint();\n"
"EXEC SQL WHENEVER SQLERROR GOTO error_label;\n"
"EXEC SQL WHENEVER SQLERROR STOP;"
msgstr ""
"EXEC SQL WHENEVER NOT FOUND CONTINUE;\n"
"EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"EXEC SQL WHENEVER SQLWARNING SQLPRINT;\n"
"EXEC SQL WHENEVER SQLWARNING DO warn();\n"
"EXEC SQL WHENEVER SQLERROR sqlprint;\n"
"EXEC SQL WHENEVER SQLERROR CALL print2();\n"
"EXEC SQL WHENEVER SQLERROR DO handle_error(\"select\");\n"
"EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);\n"
"EXEC SQL WHENEVER SQLERROR DO sqlprint();\n"
"EXEC SQL WHENEVER SQLERROR GOTO error_label;\n"
"EXEC SQL WHENEVER SQLERROR STOP;"

#: ecpg.xml:7782(programlisting)
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL CONNECT TO testdb AS con1;\n"
"    EXEC SQL ALLOCATE DESCRIPTOR d;\n"
"    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;\n"
"    EXEC SQL OPEN cur;\n"
"\n"
"    /* when end of result set reached, break out of while loop */\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;\n"
"        ...\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DEALLOCATE DESCRIPTOR d;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    EXEC SQL CONNECT TO testdb AS con1;\n"
"    EXEC SQL ALLOCATE DESCRIPTOR d;\n"
"    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;\n"
"    EXEC SQL OPEN cur;\n"
"\n"
"    /* по достижении конца набора результатов прервать цикл while */\n"
"    EXEC SQL WHENEVER NOT FOUND DO BREAK;\n"
"\n"
"    while (1)\n"
"    {\n"
"        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;\n"
"        ...\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE cur;\n"
"    EXEC SQL COMMIT;\n"
"\n"
"    EXEC SQL DEALLOCATE DESCRIPTOR d;\n"
"    EXEC SQL DISCONNECT ALL;\n"
"\n"
"    return 0;\n"
"}"

#: ecpg.xml:7779(para)
msgid ""
"A typical application is the use of <literal>WHENEVER NOT FOUND BREAK</"
"literal> to handle looping through result sets: <placeholder-1/>"
msgstr ""
"Типичное применение конструкция <literal>WHENEVER NOT FOUND BREAK</literal> "
"находит в обработке результатов запроса в цикле: <placeholder-1/>"

#: ecpg.xml:7815(para)
msgid ""
"<command>WHENEVER</command> is specified in the SQL standard, but most of "
"the actions are PostgreSQL extensions."
msgstr ""
"Команда <command>WHENEVER</command> описана в стандарте SQL, но большинство "
"действий относятся к расширениям PostgreSQL."

#: ecpg.xml:7824(title)
msgid "<productname>Informix</productname> Compatibility Mode"
msgstr "Режим совместимости с <productname>Informix</productname>"

#: ecpg.xml:7831(programlisting)
#, no-wrap
msgid ""
"$int j = 3;\n"
"$CONNECT TO :dbname;\n"
"$CREATE TABLE test(i INT PRIMARY KEY, j INT);\n"
"$INSERT INTO test(i, j) VALUES (7, :j);\n"
"$COMMIT;"
msgstr ""
"$int j = 3;\n"
"$CONNECT TO :dbname;\n"
"$CREATE TABLE test(i INT PRIMARY KEY, j INT);\n"
"$INSERT INTO test(i, j) VALUES (7, :j);\n"
"$COMMIT;"

#: ecpg.xml:7825(para)
msgid ""
"<command>ecpg</command> can be run in a so-called <firstterm>Informix "
"compatibility mode</firstterm>. If this mode is active, it tries to behave "
"as if it were the <productname>Informix</productname> precompiler for "
"<productname>Informix</productname> E/SQL. Generally spoken this will allow "
"you to use the dollar sign instead of the <literal>EXEC SQL</literal> "
"primitive to introduce embedded SQL commands: <placeholder-1/>"
msgstr ""
"Препроцессор <command>ecpg</command> может работать в так называемом "
"<firstterm>режиме совместимости с Informix</firstterm>. Если этот режим "
"включён, <command>ecpg</command> старается работать как предкомпилятор "
"<productname>Informix</productname> для кода <productname>Informix</"
"productname> E/SQL. Вообще говоря, это позволяет записывать встраиваемые "
"команды SQL, используя знак доллара вместо слов <literal>EXEC SQL</literal>: "
"<placeholder-1/>"

#: ecpg.xml:7841(para)
msgid ""
"There must not be any white space between the <literal>$</literal> and a "
"following preprocessor directive, that is, <literal>include</literal>, "
"<literal>define</literal>, <literal>ifdef</literal>, etc. Otherwise, the "
"preprocessor will parse the token as a host variable."
msgstr ""
"Между <literal>$</literal> и последующей директивой препроцессора (в "
"частности, <literal>include</literal>, <literal>define</literal>, "
"<literal>ifdef</literal> и т. п.) не должно быть пробельных символов. В "
"противном случае препроцессор воспримет следующее слово как имя переменной "
"среды."

#: ecpg.xml:7850(para)
msgid ""
"There are two compatibility modes: <literal>INFORMIX</literal>, "
"<literal>INFORMIX_SE</literal>"
msgstr ""
"Поддерживаются два режима совместимости: <literal>INFORMIX</literal> и "
"<literal>INFORMIX_SE</literal>"

#: ecpg.xml:7853(para)
msgid ""
"When linking programs that use this compatibility mode, remember to link "
"against <literal>libcompat</literal> that is shipped with ECPG."
msgstr ""
"При компоновке программ, использующих этот режим совместимости, обязательно "
"подключите библиотеку <literal>libcompat</literal>, поставляемую с ECPG."

#: ecpg.xml:7857(para)
msgid ""
"Besides the previously explained syntactic sugar, the <productname>Informix</"
"productname> compatibility mode ports some functions for input, output and "
"transformation of data as well as embedded SQL statements known from E/SQL "
"to ECPG."
msgstr ""
"Помимо ранее упомянутого синтаксического сахара, режим совместимости с "
"<productname>Informix</productname> приносит из E/SQL в ECPG набор функций "
"для ввода, вывода и преобразования данных, а также встраиваемые операторы "
"SQL."

#: ecpg.xml:7862(para)
msgid ""
"<productname>Informix</productname> compatibility mode is closely connected "
"to the pgtypeslib library of ECPG. pgtypeslib maps SQL data types to data "
"types within the C host program and most of the additional functions of the "
"<productname>Informix</productname> compatibility mode allow you to operate "
"on those C host program types. Note however that the extent of the "
"compatibility is limited. It does not try to copy <productname>Informix</"
"productname> behavior; it allows you to do more or less the same operations "
"and gives you functions that have the same name and the same basic behavior "
"but it is no drop-in replacement if you are using <productname>Informix</"
"productname> at the moment. Moreover, some of the data types are different. "
"For example, <productname>PostgreSQL's</productname> datetime and interval "
"types do not know about ranges like for example <literal>YEAR TO MINUTE</"
"literal> so you won't find support in ECPG for that either."
msgstr ""
"Режим совместимости с <productname>Informix</productname> тесно связан с "
"библиотекой pgtypeslib из ECPG. Библиотека pgtypeslib сопоставляет типы "
"данных SQL с типами данных в ведущей программе на C, а большинство "
"дополнительных функций режима совместимости с <productname>Informix</"
"productname> позволяют работать с этими типами C. Заметьте, однако, что "
"степень совместимости ограничена. ECPG не пытается копировать поведение "
"<productname>Informix</productname>; вы можете выполнять примерно те же "
"операции и пользоваться функции с теми же именами и с тем же поведением, но "
"если вы используете <productname>Informix</productname>, просто заменить "
"одно средство другим на данный момент нельзя. Более того, есть различия и в "
"типах данных. В частности, типы даты и интервала в <productname>PostgreSQL</"
"productname> не воспринимают диапазоны, как например, <literal>YEAR TO "
"MINUTE</literal>, так что и в ECPG это не будет поддерживаться."

#: ecpg.xml:7878(title)
msgid "Additional Types"
msgstr "Дополнительные типы"

#: ecpg.xml:7883(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"string userid; /* this variable will contain trimmed data */\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL FETCH MYCUR INTO :userid;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"string userid; /* эта переменная будет содержать обрезанные данные */\n"
"EXEC SQL END DECLARE SECTION;\n"
"\n"
"EXEC SQL FETCH MYCUR INTO :userid;"

#: ecpg.xml:7879(para)
msgid ""
"The Informix-special \"string\" pseudo-type for storing right-trimmed "
"character string data is now supported in Informix-mode without using "
"<literal>typedef</literal>. In fact, in Informix-mode, ECPG refuses to "
"process source files that contain <literal>typedef sometype string;</"
"literal> <placeholder-1/>"
msgstr ""
"Теперь в режиме Informix без указания <literal>typedef</literal> "
"поддерживается специальный псевдотип Informix \"string\" для хранения "
"символьной строки, обрезаемой справа. На самом деле, в режиме Informix ECPG "
"откажется обрабатывать исходные файлы, содержащие определение типа "
"<literal>typedef некоторый_тип string;</literal> <placeholder-1/>"

#: ecpg.xml:7894(title)
msgid "Additional/Missing Embedded SQL Statements"
msgstr "Дополнительные/недостающие операторы встраиваемого SQL"

#: ecpg.xml:7898(literal)
msgid "CLOSE DATABASE"
msgstr "CLOSE DATABASE"

#: ecpg.xml:7903(programlisting)
#, no-wrap
msgid ""
"$CLOSE DATABASE;                /* close the current connection */\n"
"EXEC SQL CLOSE DATABASE;"
msgstr ""
"$CLOSE DATABASE;                /* закрыть текущее подключение */\n"
"EXEC SQL CLOSE DATABASE;"

#: ecpg.xml:7900(para)
msgid ""
"This statement closes the current connection. In fact, this is a synonym for "
"ECPG's <literal>DISCONNECT CURRENT</literal>: <placeholder-1/>"
msgstr ""
"Этот оператор закрывает текущее подключение. Фактически это синоним команды "
"<literal>DISCONNECT CURRENT</literal> в ECPG: <placeholder-1/>"

# skip-rule: modified-nontranslatable
#: ecpg.xml:7911(literal)
msgid "FREE cursor_name"
msgstr "FREE имя_курсора"

#: ecpg.xml:7913(para)
msgid ""
"Due to the differences how ECPG works compared to Informix's ESQL/C (i.e. "
"which steps are purely grammar transformations and which steps rely on the "
"underlying run-time library) there is no <literal>FREE cursor_name</literal> "
"statement in ECPG. This is because in ECPG, <literal>DECLARE CURSOR</"
"literal> doesn't translate to a function call into the run-time library that "
"uses to the cursor name. This means that there's no run-time bookkeeping of "
"SQL cursors in the ECPG run-time library, only in the PostgreSQL server."
msgstr ""
"Из-за различий в подходах ECPG и ESQL/C Informix (т. е. другого разделения "
"на чисто грамматические преобразования и вызовы нижележащей библиотеки "
"времени выполнения), в ECPG нет оператора <literal>FREE имя_курсора</"
"literal>. Это связано с тем, что в ECPG команда <literal>DECLARE CURSOR</"
"literal> не сводится к вызову функции в библиотеке времени выполнения, "
"которая бы принимала имя курсора. Это значит, что курсоры SQL в библиотеке "
"ECPG не требуют обслуживания, оно требуется только на уровне сервера "
"PostgreSQL."

# skip-rule: modified-nontranslatable
#: ecpg.xml:7924(literal)
msgid "FREE statement_name"
msgstr "FREE имя_оператора"

#: ecpg.xml:7926(para)
msgid ""
"<literal>FREE statement_name</literal> is a synonym for <literal>DEALLOCATE "
"PREPARE statement_name</literal>."
msgstr ""
"Команда <literal>FREE имя_оператора</literal> является синонимом команды "
"<literal>DEALLOCATE PREPARE имя_оператора</literal>."

#: ecpg.xml:7936(title)
msgid "Informix-compatible SQLDA Descriptor Areas"
msgstr "Области дескрипторов SQLDA, совместимые с Informix"

#: ecpg.xml:7940(programlisting)
#, no-wrap
msgid ""
"struct sqlvar_compat\n"
"{\n"
"    short   sqltype;\n"
"    int     sqllen;\n"
"    char   *sqldata;\n"
"    short  *sqlind;\n"
"    char   *sqlname;\n"
"    char   *sqlformat;\n"
"    short   sqlitype;\n"
"    short   sqlilen;\n"
"    char   *sqlidata;\n"
"    int     sqlxid;\n"
"    char   *sqltypename;\n"
"    short   sqltypelen;\n"
"    short   sqlownerlen;\n"
"    short   sqlsourcetype;\n"
"    char   *sqlownername;\n"
"    int     sqlsourceid;\n"
"    char   *sqlilongdata;\n"
"    int     sqlflags;\n"
"    void   *sqlreserved;\n"
"};\n"
"\n"
"struct sqlda_compat\n"
"{\n"
"    short  sqld;\n"
"    struct sqlvar_compat *sqlvar;\n"
"    char   desc_name[19];\n"
"    short  desc_occ;\n"
"    struct sqlda_compat *desc_next;\n"
"    void  *reserved;\n"
"};\n"
"\n"
"typedef struct sqlvar_compat    sqlvar_t;\n"
"typedef struct sqlda_compat     sqlda_t;"
msgstr ""
"struct sqlvar_compat\n"
"{\n"
"    short   sqltype;\n"
"    int     sqllen;\n"
"    char   *sqldata;\n"
"    short  *sqlind;\n"
"    char   *sqlname;\n"
"    char   *sqlformat;\n"
"    short   sqlitype;\n"
"    short   sqlilen;\n"
"    char   *sqlidata;\n"
"    int     sqlxid;\n"
"    char   *sqltypename;\n"
"    short   sqltypelen;\n"
"    short   sqlownerlen;\n"
"    short   sqlsourcetype;\n"
"    char   *sqlownername;\n"
"    int     sqlsourceid;\n"
"    char   *sqlilongdata;\n"
"    int     sqlflags;\n"
"    void   *sqlreserved;\n"
"};\n"
"\n"
"struct sqlda_compat\n"
"{\n"
"    short  sqld;\n"
"    struct sqlvar_compat *sqlvar;\n"
"    char   desc_name[19];\n"
"    short  desc_occ;\n"
"    struct sqlda_compat *desc_next;\n"
"    void  *reserved;\n"
"};\n"
"\n"
"typedef struct sqlvar_compat    sqlvar_t;\n"
"typedef struct sqlda_compat     sqlda_t;"

#: ecpg.xml:7937(para)
msgid ""
"Informix-compatible mode supports a different structure than the one "
"described in <xref linkend=\"ecpg-sqlda-descriptors\"/>. See below: "
"<placeholder-1/>"
msgstr ""
"Режим совместимости с Informix поддерживает структуру, отличную от описанной "
"в <xref remap=\"6\" linkend=\"ecpg-sqlda-descriptors\"/>. См. ниже: "
"<placeholder-1/>"

#: ecpg.xml:7986(para)
msgid "The number of fields in the <literal>SQLDA</literal> descriptor."
msgstr "Число полей в дескрипторе <literal>SQLDA</literal>."

#: ecpg.xml:7995(para)
msgid "Pointer to the per-field properties."
msgstr "Указатель на свойства по полям."

#: ecpg.xml:8002(literal)
msgid "desc_name"
msgstr "desc_name"

#: ecpg.xml:8004(para)
msgid "Unused, filled with zero-bytes."
msgstr "Не используется, заполняется нулями."

#: ecpg.xml:8011(literal)
msgid "desc_occ"
msgstr "desc_occ"

#: ecpg.xml:8013(para)
msgid "Size of the allocated structure."
msgstr "Размер структуры в памяти."

#: ecpg.xml:8022(para)
msgid ""
"Pointer to the next SQLDA structure if the result set contains more than one "
"record."
msgstr ""
"Указатель на следующую структуру SQLDA, если набор результатов содержит "
"больше одной записи."

#: ecpg.xml:8029(literal)
msgid "reserved"
msgstr "reserved"

#: ecpg.xml:8031(para)
msgid "Unused pointer, contains NULL. Kept for Informix-compatibility."
msgstr ""
"Неиспользуемый указатель, содержит NULL. Сохраняется для совместимости с "
"Informix."

#: ecpg.xml:8046(para)
msgid "Type of the field. Constants are in <literal>sqltypes.h</literal>"
msgstr ""
"Тип поля. Соответствующие константы представлены в <literal>sqltypes.h</"
"literal>"

#: ecpg.xml:8055(para)
msgid "Length of the field data."
msgstr "Длина данных поля."

#: ecpg.xml:8067(programlisting)
#, no-wrap
msgid ""
"int intval;\n"
"\n"
"switch (sqldata-&gt;sqlvar[i].sqltype)\n"
"{\n"
"    case SQLINTEGER:\n"
"        intval = *(int *)sqldata-&gt;sqlvar[i].sqldata;\n"
"        break;\n"
"  ...\n"
"}"
msgstr ""
"int intval;\n"
"\n"
"switch (sqldata-&gt;sqlvar[i].sqltype)\n"
"{\n"
"    case SQLINTEGER:\n"
"        intval = *(int *)sqldata-&gt;sqlvar[i].sqldata;\n"
"        break;\n"
"  ...\n"
"}"

#: ecpg.xml:8064(para)
msgid ""
"Pointer to the field data. The pointer is of <literal>char *</literal> type, "
"the data pointed by it is in a binary format. Example: <placeholder-1/>"
msgstr ""
"Указатель на данные поля. Этот указатель имеет тип <literal>char *</"
"literal>, но он указывает на данные в двоичном формате. Например: "
"<placeholder-1/>"

#: ecpg.xml:8090(programlisting)
#, no-wrap
msgid ""
"if (*(int2 *)sqldata-&gt;sqlvar[i].sqlind != 0)\n"
"    printf(\"value is NULL\\n\");"
msgstr ""
"if (*(int2 *)sqldata-&gt;sqlvar[i].sqlind != 0)\n"
"    printf(\"value is NULL\\n\");"

#: ecpg.xml:8085(para)
msgid ""
"Pointer to the NULL indicator. If returned by DESCRIBE or FETCH then it's "
"always a valid pointer. If used as input for <literal>EXECUTE ... USING "
"sqlda;</literal> then NULL-pointer value means that the value for this field "
"is non-NULL. Otherwise a valid pointer and <literal>sqlitype</literal> has "
"to be properly set. Example: <placeholder-1/>"
msgstr ""
"Указатель на индикатор NULL. Если возвращается командами DESCRIBE или FETCH, "
"это всегда действительный указатель. Если передаётся на вход команде "
"<literal>EXECUTE ... USING sqlda;</literal>, NULL вместо указателя означает, "
"что значение этого поля отлично от NULL. Чтобы обозначить NULL в поле, "
"необходимо корректно установить этот указатель и <literal>sqlitype</"
"literal>. Например: <placeholder-1/>"

#: ecpg.xml:8101(para)
msgid "Name of the field. 0-terminated string."
msgstr "Имя поля, в виде строки с завершающим 0."

#: ecpg.xml:8108(literal)
msgid "sqlformat"
msgstr "sqlformat"

#: ecpg.xml:8110(para)
msgid ""
"Reserved in Informix, value of <function>PQfformat()</function> for the "
"field."
msgstr ""
"Зарезервировано в Informix, значение <function>PQfformat()</function> для "
"данного поля."

#: ecpg.xml:8117(literal)
msgid "sqlitype"
msgstr "sqlitype"

#: ecpg.xml:8119(para)
msgid ""
"Type of the NULL indicator data. It's always SQLSMINT when returning data "
"from the server. When the <literal>SQLDA</literal> is used for a "
"parameterized query, the data is treated according to the set type."
msgstr ""
"Тип данных индикатора NULL. При получении данных с сервера это всегда "
"SQLSMINT. Когда <literal>SQLDA</literal> используется в параметризованном "
"запросе, данные индикатора обрабатываются в соответствии с указанным здесь "
"типом."

#: ecpg.xml:8128(literal)
msgid "sqlilen"
msgstr "sqlilen"

#: ecpg.xml:8130(para)
msgid "Length of the NULL indicator data."
msgstr "Длина данных индикатора NULL."

#: ecpg.xml:8137(literal)
msgid "sqlxid"
msgstr "sqlxid"

#: ecpg.xml:8139(para)
msgid "Extended type of the field, result of <function>PQftype()</function>."
msgstr ""
"Расширенный тип поля, результат функции <function>PQftype()</function>."

#: ecpg.xml:8146(literal)
msgid "sqltypename"
msgstr "sqltypename"

#: ecpg.xml:8147(literal)
msgid "sqltypelen"
msgstr "sqltypelen"

#: ecpg.xml:8148(literal)
msgid "sqlownerlen"
msgstr "sqlownerlen"

#: ecpg.xml:8149(literal)
msgid "sqlsourcetype"
msgstr "sqlsourcetype"

#: ecpg.xml:8150(literal)
msgid "sqlownername"
msgstr "sqlownername"

#: ecpg.xml:8151(literal)
msgid "sqlsourceid"
msgstr "sqlsourceid"

#: ecpg.xml:8152(literal)
msgid "sqlflags"
msgstr "sqlflags"

#: ecpg.xml:8153(literal)
msgid "sqlreserved"
msgstr "sqlreserved"

#: ecpg.xml:8155(para)
msgid "Unused."
msgstr "Не используются."

#: ecpg.xml:8162(literal)
msgid "sqlilongdata"
msgstr "sqlilongdata"

#: ecpg.xml:8164(para)
msgid ""
"It equals to <literal>sqldata</literal> if <literal>sqllen</literal> is "
"larger than 32kB."
msgstr ""
"Совпадает с <literal>sqldata</literal>, если <literal>sqllen</literal> "
"превышает 32 Кбайта."

#: ecpg.xml:8173(programlisting)
#, no-wrap
msgid ""
"EXEC SQL INCLUDE sqlda.h;\n"
"\n"
"    sqlda_t        *sqlda; /* This doesn't need to be under embedded DECLARE SECTION */\n"
"\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char *prep_stmt = \"select * from table1\";\n"
"    int i;\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    ...\n"
"\n"
"    EXEC SQL PREPARE mystmt FROM :prep_stmt;\n"
"\n"
"    EXEC SQL DESCRIBE mystmt INTO sqlda;\n"
"\n"
"    printf(\"# of fields: %d\\n\", sqlda-&gt;sqld);\n"
"    for (i = 0; i &lt; sqlda-&gt;sqld; i++)\n"
"      printf(\"field %d: \\\"%s\\\"\\n\", sqlda-&gt;sqlvar[i]-&gt;sqlname);\n"
"\n"
"    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;\n"
"    EXEC SQL OPEN mycursor;\n"
"    EXEC SQL WHENEVER NOT FOUND GOTO out;\n"
"\n"
"    while (1)\n"
"    {\n"
"      EXEC SQL FETCH mycursor USING sqlda;\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE mycursor;\n"
"\n"
"    free(sqlda); /* The main structure is all to be free(),\n"
"                  * sqlda and sqlda-&gt;sqlvar is in one allocated area */"
msgstr ""
"EXEC SQL INCLUDE sqlda.h;\n"
"\n"
"    sqlda_t        *sqlda; /* Это объявление не обязательно должно быть внутри DECLARE SECTION */\n"
"\n"
"    EXEC SQL BEGIN DECLARE SECTION;\n"
"    char *prep_stmt = \"select * from table1\";\n"
"    int i;\n"
"    EXEC SQL END DECLARE SECTION;\n"
"\n"
"    ...\n"
"\n"
"    EXEC SQL PREPARE mystmt FROM :prep_stmt;\n"
"\n"
"    EXEC SQL DESCRIBE mystmt INTO sqlda;\n"
"\n"
"    printf(\"# of fields: %d\\n\", sqlda-&gt;sqld);\n"
"    for (i = 0; i &lt; sqlda-&gt;sqld; i++)\n"
"      printf(\"field %d: \\\"%s\\\"\\n\", sqlda-&gt;sqlvar[i]-&gt;sqlname);\n"
"\n"
"    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;\n"
"    EXEC SQL OPEN mycursor;\n"
"    EXEC SQL WHENEVER NOT FOUND GOTO out;\n"
"\n"
"    while (1)\n"
"    {\n"
"      EXEC SQL FETCH mycursor USING sqlda;\n"
"    }\n"
"\n"
"    EXEC SQL CLOSE mycursor;\n"
"\n"
"    free(sqlda); /* Освобождать нужно только основную структуру,\n"
"                  * sqlda и sqlda-&gt;sqlvar находятся в одной выделенной области. */"

#: ecpg.xml:7979(para)
msgid ""
"The global properties are: <placeholder-1/> The per-field properties are "
"below, they are stored in the <literal>sqlvar</literal> array: "
"<placeholder-2/> Example: <placeholder-3/> For more information, see the "
"<literal>sqlda.h</literal> header and the <literal>src/interfaces/ecpg/test/"
"compat_informix/sqlda.pgc</literal> regression test."
msgstr ""
"Глобальные свойства: <placeholder-1/> Свойства, относящиеся к полям, описаны "
"ниже, они хранятся в массиве <literal>sqlvar</literal>: <placeholder-2/> "
"Например: <placeholder-3/> Дополнительную информацию можно найти в "
"заголовочном файле <literal>sqlda.h</literal> и в регрессионном тесте "
"<literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>."

#: ecpg.xml:8213(title)
msgid "Additional Functions"
msgstr "Дополнительные функции"

#: ecpg.xml:8217(function)
msgid "decadd"
msgstr "decadd"

#: ecpg.xml:8219(para)
msgid ""
"Add two decimal type values. <synopsis>\n"
"int decadd(decimal *arg1, decimal *arg2, decimal *sum);\n"
"</synopsis> The function receives a pointer to the first operand of type "
"decimal (<literal>arg1</literal>), a pointer to the second operand of type "
"decimal (<literal>arg2</literal>) and a pointer to a value of type decimal "
"that will contain the sum (<literal>sum</literal>). On success, the function "
"returns 0. <symbol>ECPG_INFORMIX_NUM_OVERFLOW</symbol> is returned in case "
"of overflow and <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</symbol> in case of "
"underflow. -1 is returned for other failures and <varname>errno</varname> is "
"set to the respective <varname>errno</varname> number of the pgtypeslib."
msgstr ""
"Складывает два значения типа decimal. <synopsis>\n"
"int decadd(decimal *arg1, decimal *arg2, decimal *sum);\n"
"</synopsis> Эта функция получает указатель на первый операнд типа decimal "
"(<literal>arg1</literal>), указатель на второй операнд типа decimal "
"(<literal>arg2</literal>) и указатель на переменную типа decimal, в которую "
"будет записана сумма (<literal>sum</literal>). В случае успеха эта функция "
"возвращает 0. <symbol>ECPG_INFORMIX_NUM_OVERFLOW</symbol> возвращается в "
"случае переполнения, а <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</symbol> в случае "
"антипереполнения. При любых других ошибках возвращается -1, а в "
"<varname>errno</varname> устанавливается код <varname>errno</varname> из "
"pgtypeslib."

#: ecpg.xml:8237(function)
msgid "deccmp"
msgstr "deccmp"

#: ecpg.xml:8250(para)
msgid ""
"1, if the value that <literal>arg1</literal> points to is bigger than the "
"value that <literal>var2</literal> points to"
msgstr ""
"1, если значение, на которое указывает <literal>arg1</literal>, больше "
"значения, на которое указывает <literal>var2</literal>"

#: ecpg.xml:8256(para)
msgid ""
"-1, if the value that <literal>arg1</literal> points to is smaller than the "
"value that <literal>arg2</literal> points to"
msgstr ""
"-1, если значение, на которое указывает <literal>arg1</literal>, меньше "
"значения, на которое указывает <literal>arg2</literal>"

#: ecpg.xml:8261(para)
msgid ""
"0, if the value that <literal>arg1</literal> points to and the value that "
"<literal>arg2</literal> points to are equal"
msgstr ""
"0, если значение, на которое указывает <literal>arg1</literal>, равно "
"значению, на которое указывает <literal>arg2</literal>"

#: ecpg.xml:8239(para)
msgid ""
"Compare two variables of type decimal. <synopsis>\n"
"int deccmp(decimal *arg1, decimal *arg2);\n"
"</synopsis> The function receives a pointer to the first decimal value "
"(<literal>arg1</literal>), a pointer to the second decimal value "
"(<literal>arg2</literal>) and returns an integer value that indicates which "
"is the bigger value. <placeholder-1/>"
msgstr ""
"Сравнивает два значения типа decimal. <synopsis>\n"
"int deccmp(decimal *arg1, decimal *arg2);\n"
"</synopsis> Эта функция получает указатель на первое значение типа decimal "
"(<literal>arg1</literal>), указатель на второе значение типа decimal "
"(<literal>arg2</literal>) и возвращает целое, отражающее результат сравнения "
"этих чисел. <placeholder-1/>"

#: ecpg.xml:8272(function)
msgid "deccopy"
msgstr "deccopy"

#: ecpg.xml:8274(para)
msgid ""
"Copy a decimal value. <synopsis>\n"
"void deccopy(decimal *src, decimal *target);\n"
"</synopsis> The function receives a pointer to the decimal value that should "
"be copied as the first argument (<literal>src</literal>) and a pointer to "
"the target structure of type decimal (<literal>target</literal>) as the "
"second argument."
msgstr ""
"Копирует значение типа decimal. <synopsis>\n"
"void deccopy(decimal *src, decimal *target);\n"
"</synopsis> Функция принимает в первом аргументе (<literal>src</literal>) "
"указатель на значение decimal, которое должно быть скопировано, а во втором "
"аргументе (<literal>target</literal>) принимает указатель на структуру типа "
"decimal для скопированного значения."

#: ecpg.xml:8288(function)
msgid "deccvasc"
msgstr "deccvasc"

#: ecpg.xml:8290(para)
msgid ""
"Convert a value from its ASCII representation into a decimal type. "
"<synopsis>\n"
"int deccvasc(char *cp, int len, decimal *np);\n"
"</synopsis> The function receives a pointer to string that contains the "
"string representation of the number to be converted (<literal>cp</literal>) "
"as well as its length <literal>len</literal>. <literal>np</literal> is a "
"pointer to the decimal value that saves the result of the operation."
msgstr ""
"Преобразует значение из представления ASCII в тип decimal. <synopsis>\n"
"int deccvasc(char *cp, int len, decimal *np);\n"
"</synopsis> Эта функция получает указатель на строку, содержащую строковое "
"представление числа, которое нужно преобразовать, (<literal>cp</literal>), а "
"также его длину <literal>len</literal>. В <literal>np</literal> передаётся "
"указатель на переменную типа decimal, в которую будет помещён результат "
"преобразования."

#: ecpg.xml:8300(para)
msgid ""
"Valid formats are for example: <literal>-2</literal>, <literal>.794</"
"literal>, <literal>+3.44</literal>, <literal>592.49E07</literal> or "
"<literal>-32.84e-4</literal>."
msgstr ""
"Допустимыми являются, например следующие форматы: <literal>-2</literal>, "
"<literal>.794</literal>, <literal>+3.44</literal>, <literal>592.49E07</"
"literal> или <literal>-32.84e-4</literal>."

#: ecpg.xml:8308(para)
msgid ""
"The function returns 0 on success. If overflow or underflow occurred, "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or "
"<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> is returned. If the ASCII "
"representation could not be parsed, <literal>ECPG_INFORMIX_BAD_NUMERIC</"
"literal> is returned or <literal>ECPG_INFORMIX_BAD_EXPONENT</literal> if "
"this problem occurred while parsing the exponent."
msgstr ""
"В случае успеха эта функция возвращает 0. При переполнении или "
"антипереполнении возвращается <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> "
"или <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно. Если "
"разобрать ASCII-представление не удаётся, возвращается "
"<literal>ECPG_INFORMIX_BAD_NUMERIC</literal> или "
"<literal>ECPG_INFORMIX_BAD_EXPONENT</literal>, если не удаётся разобрать "
"компонент экспоненты."

#: ecpg.xml:8321(function)
msgid "deccvdbl"
msgstr "deccvdbl"

#: ecpg.xml:8323(para)
msgid ""
"Convert a value of type double to a value of type decimal. <synopsis>\n"
"int deccvdbl(double dbl, decimal *np);\n"
"</synopsis> The function receives the variable of type double that should be "
"converted as its first argument (<literal>dbl</literal>). As the second "
"argument (<literal>np</literal>), the function receives a pointer to the "
"decimal variable that should hold the result of the operation."
msgstr ""
"Преобразует значение double в значение типа decimal. <synopsis>\n"
"int deccvdbl(double dbl, decimal *np);\n"
"</synopsis> Данная функция принимает в первом аргументе (<literal>dbl</"
"literal>) переменную типа double, которая должна быть преобразована. Во "
"втором аргументе (<literal>np</literal>) она принимает указатель на "
"переменную decimal, в которую будет помещён результат операции."

#: ecpg.xml:8333(para) ecpg.xml:8353(para) ecpg.xml:8373(para)
msgid ""
"The function returns 0 on success and a negative value if the conversion "
"failed."
msgstr ""
"Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если "
"выполнить преобразование не удалось."

#: ecpg.xml:8341(function)
msgid "deccvint"
msgstr "deccvint"

#: ecpg.xml:8343(para)
msgid ""
"Convert a value of type int to a value of type decimal. <synopsis>\n"
"int deccvint(int in, decimal *np);\n"
"</synopsis> The function receives the variable of type int that should be "
"converted as its first argument (<literal>in</literal>). As the second "
"argument (<literal>np</literal>), the function receives a pointer to the "
"decimal variable that should hold the result of the operation."
msgstr ""
"Преобразует значение int в значение типа decimal. <synopsis>\n"
"int deccvint(int in, decimal *np);\n"
"</synopsis> Данная функция принимает в первом аргументе (<literal>in</"
"literal>) переменную типа int, которая должна быть преобразована. Во втором "
"аргументе (<literal>np</literal>) она принимает указатель на переменную "
"decimal, в которую будет помещён результат операции."

#: ecpg.xml:8361(function)
msgid "deccvlong"
msgstr "deccvlong"

#: ecpg.xml:8363(para)
msgid ""
"Convert a value of type long to a value of type decimal. <synopsis>\n"
"int deccvlong(long lng, decimal *np);\n"
"</synopsis> The function receives the variable of type long that should be "
"converted as its first argument (<literal>lng</literal>). As the second "
"argument (<literal>np</literal>), the function receives a pointer to the "
"decimal variable that should hold the result of the operation."
msgstr ""
"Преобразует значение long в значение типа decimal. <synopsis>\n"
"int deccvlong(long lng, decimal *np);\n"
"</synopsis> Данная функция принимает в первом аргументе (<literal>lng</"
"literal>) переменную типа long, которая должна быть преобразована. Во втором "
"аргументе (<literal>np</literal>) она принимает указатель на переменную "
"decimal, в которую будет помещён результат операции."

#: ecpg.xml:8381(function)
msgid "decdiv"
msgstr "decdiv"

#: ecpg.xml:8383(para)
msgid ""
"Divide two variables of type decimal. <synopsis>\n"
"int decdiv(decimal *n1, decimal *n2, decimal *result);\n"
"</synopsis> The function receives pointers to the variables that are the "
"first (<literal>n1</literal>) and the second (<literal>n2</literal>) "
"operands and calculates <literal>n1</literal>/<literal>n2</literal>. "
"<literal>result</literal> is a pointer to the variable that should hold the "
"result of the operation."
msgstr ""
"Делит одну переменную типа decimal на другую. <synopsis>\n"
"int decdiv(decimal *n1, decimal *n2, decimal *result);\n"
"</synopsis> Эта функция получает указатели на переменные (<literal>n1</"
"literal> и <literal>n2</literal>) и вычисляет частное <literal>n1</literal>/"
"<literal>n2</literal>. В <literal>result</literal> передаётся указатель на "
"переменную, в которую будет помещён результат операции."

#: ecpg.xml:8393(para)
msgid ""
"On success, 0 is returned and a negative value if the division fails. If "
"overflow or underflow occurred, the function returns "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or "
"<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively. If an attempt "
"to divide by zero is observed, the function returns "
"<literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>."
msgstr ""
"В случае успеха возвращается 0, а при ошибке — отрицательное значение. В "
"случае переполнения или антипереполнения данная функция возвращает "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> или "
"<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно. При попытке "
"деления на ноль возвращается <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>."

#: ecpg.xml:8405(function)
msgid "decmul"
msgstr "decmul"

#: ecpg.xml:8407(para)
msgid ""
"Multiply two decimal values. <synopsis>\n"
"int decmul(decimal *n1, decimal *n2, decimal *result);\n"
"</synopsis> The function receives pointers to the variables that are the "
"first (<literal>n1</literal>) and the second (<literal>n2</literal>) "
"operands and calculates <literal>n1</literal>*<literal>n2</literal>. "
"<literal>result</literal> is a pointer to the variable that should hold the "
"result of the operation."
msgstr ""
"Перемножает два значения типа decimal. <synopsis>\n"
"int decmul(decimal *n1, decimal *n2, decimal *result);\n"
"</synopsis> Эта функция получает указатели на переменные (<literal>n1</"
"literal> и <literal>n2</literal>) и вычисляет произведение <literal>n1</"
"literal>*<literal>n2</literal>. В <literal>result</literal> передаётся "
"указатель на переменную, в которую будет помещён результат операции."

#: ecpg.xml:8417(para)
msgid ""
"On success, 0 is returned and a negative value if the multiplication fails. "
"If overflow or underflow occurred, the function returns "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or "
"<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively."
msgstr ""
"В случае успеха возвращается 0, а при ошибке — отрицательное значение. В "
"случае переполнения или антипереполнения данная функция возвращает "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> или "
"<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно."

#: ecpg.xml:8427(function)
msgid "decsub"
msgstr "decsub"

#: ecpg.xml:8429(para)
msgid ""
"Subtract one decimal value from another. <synopsis>\n"
"int decsub(decimal *n1, decimal *n2, decimal *result);\n"
"</synopsis> The function receives pointers to the variables that are the "
"first (<literal>n1</literal>) and the second (<literal>n2</literal>) "
"operands and calculates <literal>n1</literal>-<literal>n2</literal>. "
"<literal>result</literal> is a pointer to the variable that should hold the "
"result of the operation."
msgstr ""
"Вычитает одно значение типа decimal из другого. <synopsis>\n"
"int decsub(decimal *n1, decimal *n2, decimal *result);\n"
"</synopsis> Эта функция получает указатели на переменные (<literal>n1</"
"literal> и <literal>n2</literal>) и вычисляет разность <literal>n1</literal>-"
"<literal>n2</literal>. В <literal>result</literal> передаётся указатель на "
"переменную, в которую будет помещён результат операции."

#: ecpg.xml:8439(para)
msgid ""
"On success, 0 is returned and a negative value if the subtraction fails. If "
"overflow or underflow occurred, the function returns "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or "
"<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively."
msgstr ""
"В случае успеха возвращается 0, а при ошибке — отрицательное значение. В "
"случае переполнения или антипереполнения данная функция возвращает "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> или "
"<literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>, соответственно."

#: ecpg.xml:8449(function)
msgid "dectoasc"
msgstr "dectoasc"

#: ecpg.xml:8451(para)
msgid ""
"Convert a variable of type decimal to its ASCII representation in a C char* "
"string. <synopsis>\n"
"int dectoasc(decimal *np, char *cp, int len, int right)\n"
"</synopsis> The function receives a pointer to a variable of type decimal "
"(<literal>np</literal>) that it converts to its textual representation. "
"<literal>cp</literal> is the buffer that should hold the result of the "
"operation. The parameter <literal>right</literal> specifies, how many digits "
"right of the decimal point should be included in the output. The result will "
"be rounded to this number of decimal digits. Setting <literal>right</"
"literal> to -1 indicates that all available decimal digits should be "
"included in the output. If the length of the output buffer, which is "
"indicated by <literal>len</literal> is not sufficient to hold the textual "
"representation including the trailing zero byte, only a single <literal>*</"
"literal> character is stored in the result and -1 is returned."
msgstr ""
"Преобразует переменную типа decimal в представление ASCII (в строку C "
"char*). <synopsis>\n"
"int dectoasc(decimal *np, char *cp, int len, int right)\n"
"</synopsis> Эта функция получает указатель на переменную типа decimal "
"(<literal>np</literal>), которая будет преобразована в текстовое "
"представление. Аргумент <literal>cp</literal> указывает на буфер, в который "
"будет помещён результат операции. Аргумент <literal>right</literal> "
"определяет, сколько должно выводиться цифр правее десятичной точки. "
"Результат будет округлён до этого числа десятичных цифр. Значение "
"<literal>right</literal>, равное -1, указывает, что выводиться должны все "
"имеющиеся десятичные цифры. Если длина выходного буфера, которую задаёт "
"<literal>len</literal>, недостаточна для помещения в него текстового "
"представления, включая завершающий нулевой байт, в буфере сохраняется один "
"знак <literal>*</literal> и возвращается -1."

#: ecpg.xml:8470(para)
msgid ""
"The function returns either -1 if the buffer <literal>cp</literal> was too "
"small or <literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal> if memory was "
"exhausted."
msgstr ""
"Эта функция возвращает -1, если буфер <literal>cp</literal> слишком мал, "
"либо <literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal> при нехватке памяти."

#: ecpg.xml:8479(function)
msgid "dectodbl"
msgstr "dectodbl"

#: ecpg.xml:8481(para)
msgid ""
"Convert a variable of type decimal to a double. <synopsis>\n"
"int dectodbl(decimal *np, double *dblp);\n"
"</synopsis> The function receives a pointer to the decimal value to convert "
"(<literal>np</literal>) and a pointer to the double variable that should "
"hold the result of the operation (<literal>dblp</literal>)."
msgstr ""
"Преобразует переменную типа decimal в тип double. <synopsis>\n"
"int dectodbl(decimal *np, double *dblp);\n"
"</synopsis> Эта функция получает указатель (<literal>np</literal>) на "
"значение decimal, которое нужно преобразовать, и указатель (<literal>dblp</"
"literal>) на переменную double, в которую будет помещён результат операции."

#: ecpg.xml:8490(para)
msgid ""
"On success, 0 is returned and a negative value if the conversion failed."
msgstr ""
"В случае успеха возвращается 0, или отрицательное значение, если выполнить "
"преобразование не удалось."

#: ecpg.xml:8498(function)
msgid "dectoint"
msgstr "dectoint"

#: ecpg.xml:8500(para)
msgid ""
"Convert a variable to type decimal to an integer. <synopsis>\n"
"int dectoint(decimal *np, int *ip);\n"
"</synopsis> The function receives a pointer to the decimal value to convert "
"(<literal>np</literal>) and a pointer to the integer variable that should "
"hold the result of the operation (<literal>ip</literal>)."
msgstr ""
"Преобразует переменную типа decimal в тип integer. <synopsis>\n"
"int dectoint(decimal *np, int *ip);\n"
"</synopsis> Эта функция получает указатель (<literal>np</literal>) на "
"значение decimal, которое нужно преобразовать, и указатель (<literal>ip</"
"literal>) на целочисленную переменную, в которую будет помещён результат "
"операции."

#: ecpg.xml:8509(para) ecpg.xml:8535(para)
msgid ""
"On success, 0 is returned and a negative value if the conversion failed. If "
"an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> is "
"returned."
msgstr ""
"В случае успеха возвращается 0, или отрицательное значение, если выполнить "
"преобразование не удалось. В случае переполнения возвращается "
"<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>."

#: ecpg.xml:8514(para)
msgid ""
"Note that the ECPG implementation differs from the <productname>Informix</"
"productname> implementation. <productname>Informix</productname> limits an "
"integer to the range from -32767 to 32767, while the limits in the ECPG "
"implementation depend on the architecture (<literal>-INT_MAX .. INT_MAX</"
"literal>)."
msgstr ""
"Заметьте, что реализация ECPG отличается от реализации "
"<productname>Informix</productname>. В <productname>Informix</productname> "
"целое ограничивается диапазоном -32767 .. 32767, тогда как в ECPG "
"ограничение зависит от архитектуры (<literal>-INT_MAX .. INT_MAX</literal>)."

#: ecpg.xml:8524(function)
msgid "dectolong"
msgstr "dectolong"

#: ecpg.xml:8526(para)
msgid ""
"Convert a variable to type decimal to a long integer. <synopsis>\n"
"int dectolong(decimal *np, long *lngp);\n"
"</synopsis> The function receives a pointer to the decimal value to convert "
"(<literal>np</literal>) and a pointer to the long variable that should hold "
"the result of the operation (<literal>lngp</literal>)."
msgstr ""
"Преобразует переменную типа decimal в тип long. <synopsis>\n"
"int dectolong(decimal *np, long *lngp);\n"
"</synopsis> Эта функция получает указатель (<literal>np</literal>) на "
"значение decimal, которое нужно преобразовать, и указатель (<literal>lngp</"
"literal>) на переменную типа long, в которую будет помещён результат "
"операции."

#: ecpg.xml:8540(para)
msgid ""
"Note that the ECPG implementation differs from the <productname>Informix</"
"productname> implementation. <productname>Informix</productname> limits a "
"long integer to the range from -2,147,483,647 to 2,147,483,647, while the "
"limits in the ECPG implementation depend on the architecture (<literal>-"
"LONG_MAX .. LONG_MAX</literal>)."
msgstr ""
"Заметьте, что реализация ECPG отличается от реализации "
"<productname>Informix</productname>. В <productname>Informix</productname> "
"длинное целое ограничено диапазоном -2&nbsp;147&nbsp;483&nbsp;647 .. "
"2&nbsp;147&nbsp;483&nbsp;647, тогда как в ECPG ограничение зависит от "
"архитектуры (<literal>-LONG_MAX .. LONG_MAX</literal>)."

#: ecpg.xml:8551(function)
msgid "rdatestr"
msgstr "rdatestr"

#: ecpg.xml:8553(para)
msgid ""
"Converts a date to a C char* string. <synopsis>\n"
"int rdatestr(date d, char *str);\n"
"</synopsis> The function receives two arguments, the first one is the date "
"to convert (<literal>d</literal>) and the second one is a pointer to the "
"target string. The output format is always <literal>yyyy-mm-dd</literal>, so "
"you need to allocate at least 11 bytes (including the zero-byte terminator) "
"for the string."
msgstr ""
"Преобразует дату в строку C char*. <synopsis>\n"
"int rdatestr(date d, char *str);\n"
"</synopsis> Эта функция принимает два аргумента. В первом (<literal>d</"
"literal>) передаётся дата, которую нужно преобразовать, а во втором "
"указатель на целевую строку. Результат всегда выводится в формате "
"<literal>yyyy-mm-dd</literal>, так что для этой строки нужно выделить "
"минимум 11 байт (включая завершающий нулевой байт)."

#: ecpg.xml:8564(para) ecpg.xml:8843(para) ecpg.xml:8874(para)
msgid ""
"The function returns 0 on success and a negative value in case of error."
msgstr ""
"Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное "
"значение."

#: ecpg.xml:8568(para)
msgid ""
"Note that ECPG's implementation differs from the <productname>Informix</"
"productname> implementation. In <productname>Informix</productname> the "
"format can be influenced by setting environment variables. In ECPG however, "
"you cannot change the output format."
msgstr ""
"Заметьте, что реализация ECPG отличается от реализации "
"<productname>Informix</productname>. В <productname>Informix</productname> "
"формат вывода можно изменить переменными окружения, а в ECPG он фиксирован."

#: ecpg.xml:8578(function)
msgid "rstrdate"
msgstr "rstrdate"

#: ecpg.xml:8580(para)
msgid ""
"Parse the textual representation of a date. <synopsis>\n"
"int rstrdate(char *str, date *d);\n"
"</synopsis> The function receives the textual representation of the date to "
"convert (<literal>str</literal>) and a pointer to a variable of type date "
"(<literal>d</literal>). This function does not allow you to specify a format "
"mask. It uses the default format mask of <productname>Informix</productname> "
"which is <literal>mm/dd/yyyy</literal>. Internally, this function is "
"implemented by means of <function>rdefmtdate</function>. Therefore, "
"<function>rstrdate</function> is not faster and if you have the choice you "
"should opt for <function>rdefmtdate</function> which allows you to specify "
"the format mask explicitly."
msgstr ""
"Разбирает текстовое представление даты. <synopsis>\n"
"int rstrdate(char *str, date *d);\n"
"</synopsis> Эта функция получает текстовое представление (<literal>str</"
"literal>) даты, которую нужно преобразовать, и указатель на переменную типа "
"date (<literal>d</literal>). Для данной функции нельзя задать маску формата. "
"Она использует стандартную маску формата <productname>Informix</"
"productname>, а именно: <literal>mm/dd/yyyy</literal>. Внутри эта функция "
"вызывает <function>rdefmtdate</function>. Таким образом, <function>rstrdate</"
"function> не будет быстрее, и если у вас есть выбор, используйте функцию "
"<function>rdefmtdate</function>, которая позволяет явно задать маску формата."

#: ecpg.xml:8595(para)
msgid ""
"The function returns the same values as <function>rdefmtdate</function>."
msgstr ""
"Эта функция возвращает те же значения, что и <function>rdefmtdate</function>."

#: ecpg.xml:8602(function)
msgid "rtoday"
msgstr "rtoday"

#: ecpg.xml:8604(para)
msgid ""
"Get the current date. <synopsis>\n"
"void rtoday(date *d);\n"
"</synopsis> The function receives a pointer to a date variable (<literal>d</"
"literal>) that it sets to the current date."
msgstr ""
"Выдаёт текущую дату. <synopsis>\n"
"void rtoday(date *d);\n"
"</synopsis> Эта функция получает указатель на переменную (<literal>d</"
"literal>) типа date, в которую будет записана текущая дата."

#: ecpg.xml:8612(para)
msgid ""
"Internally this function uses the <xref linkend=\"pgtypesdatetoday\"/> "
"function."
msgstr "Внутри эта функция вызывает <xref linkend=\"pgtypesdatetoday\"/>."

#: ecpg.xml:8620(function)
msgid "rjulmdy"
msgstr "rjulmdy"

#: ecpg.xml:8622(para)
msgid ""
"Extract the values for the day, the month and the year from a variable of "
"type date. <synopsis>\n"
"int rjulmdy(date d, short mdy[3]);\n"
"</synopsis> The function receives the date <literal>d</literal> and a "
"pointer to an array of 3 short integer values <literal>mdy</literal>. The "
"variable name indicates the sequential order: <literal>mdy[0]</literal> will "
"be set to contain the number of the month, <literal>mdy[1]</literal> will be "
"set to the value of the day and <literal>mdy[2]</literal> will contain the "
"year."
msgstr ""
"Извлекает значения дня, месяца и года из переменной типа date. <synopsis>\n"
"int rjulmdy(date d, short mdy[3]);\n"
"</synopsis> Эта функция получает дату <literal>d</literal> и указатель на 3 "
"коротких целочисленных значения <literal>mdy</literal>. Имя переменной "
"указывает на порядок значений: в <literal>mdy[0]</literal> записывается "
"номер месяца, в <literal>mdy[1]</literal> — номер дня, а в <literal>mdy[2]</"
"literal> — год."

#: ecpg.xml:8634(para)
msgid "The function always returns 0 at the moment."
msgstr "В текущем состоянии эта функция всегда возвращает 0."

#: ecpg.xml:8637(para)
msgid ""
"Internally the function uses the <xref linkend=\"pgtypesdatejulmdy\"/> "
"function."
msgstr "Внутри эта функция вызывает <xref linkend=\"pgtypesdatejulmdy\"/>."

#: ecpg.xml:8645(function)
msgid "rdefmtdate"
msgstr "rdefmtdate"

#: ecpg.xml:8647(para)
msgid ""
"Use a format mask to convert a character string to a value of type date. "
"<synopsis>\n"
"int rdefmtdate(date *d, char *fmt, char *str);\n"
"</synopsis> The function receives a pointer to the date value that should "
"hold the result of the operation (<literal>d</literal>), the format mask to "
"use for parsing the date (<literal>fmt</literal>) and the C char* string "
"containing the textual representation of the date (<literal>str</literal>). "
"The textual representation is expected to match the format mask. However you "
"do not need to have a 1:1 mapping of the string to the format mask. The "
"function only analyzes the sequential order and looks for the literals "
"<literal>yy</literal> or <literal>yyyy</literal> that indicate the position "
"of the year, <literal>mm</literal> to indicate the position of the month and "
"<literal>dd</literal> to indicate the position of the day."
msgstr ""
"Преобразует символьную строку в значение типа date по маске формата. "
"<synopsis>\n"
"int rdefmtdate(date *d, char *fmt, char *str);\n"
"</synopsis> Эта функция принимает указатель на переменную типа date "
"(<literal>d</literal>), в которую будет помещён результат операции, маску "
"формата для разбора даты (<literal>fmt</literal>) и строку C char*, "
"содержащую текстовое представление даты (<literal>str</literal>). Ожидается, "
"что текстовое представление будет соответствовать маске формата. Однако это "
"соответствие не обязательно должно быть точным. Данная функция анализирует "
"только порядок элементов и ищет в нём подстроки <literal>yy</literal> или "
"<literal>yyyy</literal>, обозначающие позицию года, подстроку <literal>mm</"
"literal>, обозначающую позицию месяца, и <literal>dd</literal>, обозначающую "
"позицию дня."

#: ecpg.xml:8669(para)
msgid "0 - The function terminated successfully."
msgstr "0 — Функция выполнена успешно."

#: ecpg.xml:8674(para)
msgid ""
"<literal>ECPG_INFORMIX_ENOSHORTDATE</literal> - The date does not contain "
"delimiters between day, month and year. In this case the input string must "
"be exactly 6 or 8 bytes long but isn't."
msgstr ""
"<literal>ECPG_INFORMIX_ENOSHORTDATE</literal> — Дата не содержит "
"разделителей между днём, месяцем и годом. С таким форматом входная строка "
"должна быть длиной ровно 6 или 8 байт, но это не так."

#: ecpg.xml:8681(para)
msgid ""
"<literal>ECPG_INFORMIX_ENOTDMY</literal> - The format string did not "
"correctly indicate the sequential order of year, month and day."
msgstr ""
"<literal>ECPG_INFORMIX_ENOTDMY</literal> — Строка формата не определяет "
"корректно последовательный порядок года, месяца и дня."

#: ecpg.xml:8687(para)
msgid ""
"<literal>ECPG_INFORMIX_BAD_DAY</literal> - The input string does not contain "
"a valid day."
msgstr ""
"<literal>ECPG_INFORMIX_BAD_DAY</literal> — Во входной строке отсутствует "
"корректное указание дня."

#: ecpg.xml:8693(para)
msgid ""
"<literal>ECPG_INFORMIX_BAD_MONTH</literal> - The input string does not "
"contain a valid month."
msgstr ""
"<literal>ECPG_INFORMIX_BAD_MONTH</literal> — Во входной строке отсутствует "
"корректное указание месяца."

#: ecpg.xml:8699(para)
msgid ""
"<literal>ECPG_INFORMIX_BAD_YEAR</literal> - The input string does not "
"contain a valid year."
msgstr ""
"<literal>ECPG_INFORMIX_BAD_YEAR</literal> — Во входной строке отсутствует "
"корректное указание года."

#: ecpg.xml:8665(para)
msgid "The function returns the following values: <placeholder-1/>"
msgstr "Эта функция возвращает следующие значения: <placeholder-1/>"

#: ecpg.xml:8706(para)
msgid ""
"Internally this function is implemented to use the <xref linkend="
"\"pgtypesdatedefmtasc\"/> function. See the reference there for a table of "
"example input."
msgstr ""
"В реализации этой функции вызывается <xref linkend=\"pgtypesdatedefmtasc\"/"
">. Примеры вводимых строк приведены в таблице в её описании."

#: ecpg.xml:8715(function)
msgid "rfmtdate"
msgstr "rfmtdate"

#: ecpg.xml:8717(para)
msgid ""
"Convert a variable of type date to its textual representation using a format "
"mask. <synopsis>\n"
"int rfmtdate(date d, char *fmt, char *str);\n"
"</synopsis> The function receives the date to convert (<literal>d</"
"literal>), the format mask (<literal>fmt</literal>) and the string that will "
"hold the textual representation of the date (<literal>str</literal>)."
msgstr ""
"Преобразует переменную типа date в текстовое представление по маске формата. "
"<synopsis>\n"
"int rfmtdate(date d, char *fmt, char *str);\n"
"</synopsis> Эта функция принимает дату для преобразования (<literal>d</"
"literal>), маску формата (<literal>fmt</literal>) и строку, в которую будет "
"помещено текстовое представление даты (<literal>str</literal>)."

#: ecpg.xml:8730(para)
msgid ""
"Internally this function uses the <xref linkend=\"pgtypesdatefmtasc\"/> "
"function, see the reference there for examples."
msgstr ""
"Внутри эта функция вызывает <xref linkend=\"pgtypesdatefmtasc\"/>, примеры "
"форматов можно найти в её описании."

#: ecpg.xml:8738(function)
msgid "rmdyjul"
msgstr "rmdyjul"

#: ecpg.xml:8740(para)
msgid ""
"Create a date value from an array of 3 short integers that specify the day, "
"the month and the year of the date. <synopsis>\n"
"int rmdyjul(short mdy[3], date *d);\n"
"</synopsis> The function receives the array of the 3 short integers "
"(<literal>mdy</literal>) and a pointer to a variable of type date that "
"should hold the result of the operation."
msgstr ""
"Образует значение даты из массива 3 коротких целых, задающих день, месяц и "
"год даты. <synopsis>\n"
"int rmdyjul(short mdy[3], date *d);\n"
"</synopsis> Эта функция получает в первом аргументе массив из 3 коротких "
"целых (<literal>mdy</literal>), а во втором указатель на переменную типа "
"date, в которую будет помещён результат операции."

#: ecpg.xml:8750(para)
msgid "Currently the function returns always 0."
msgstr "В настоящее время эта функция всегда возвращает 0."

#: ecpg.xml:8753(para)
msgid ""
"Internally the function is implemented to use the function <xref linkend="
"\"pgtypesdatemdyjul\"/>."
msgstr ""
"В реализации этой функции вызывается <xref linkend=\"pgtypesdatemdyjul\"/>."

#: ecpg.xml:8761(function)
msgid "rdayofweek"
msgstr "rdayofweek"

#: ecpg.xml:8763(para)
msgid ""
"Return a number representing the day of the week for a date value. "
"<synopsis>\n"
"int rdayofweek(date d);\n"
"</synopsis> The function receives the date variable <literal>d</literal> as "
"its only argument and returns an integer that indicates the day of the week "
"for this date. <placeholder-1/>"
msgstr ""
"Возвращает число, представляющее день недели для заданной даты. <synopsis>\n"
"int rdayofweek(date d);\n"
"</synopsis> Эта функция принимает в единственном аргументе переменную "
"<literal>d</literal> типа date и возвращает целое число, выражающее день "
"недели для этой даты. <placeholder-1/>"

#: ecpg.xml:8809(para)
msgid ""
"Internally the function is implemented to use the function <xref linkend="
"\"pgtypesdatedayofweek\"/>."
msgstr ""
"В реализации этой функции вызывается <xref linkend=\"pgtypesdatedayofweek\"/"
">."

#: ecpg.xml:8817(function)
msgid "dtcurrent"
msgstr "dtcurrent"

#: ecpg.xml:8819(para)
msgid ""
"Retrieve the current timestamp. <synopsis>\n"
"void dtcurrent(timestamp *ts);\n"
"</synopsis> The function retrieves the current timestamp and saves it into "
"the timestamp variable that <literal>ts</literal> points to."
msgstr ""
"Получает текущее время. <synopsis>\n"
"void dtcurrent(timestamp *ts);\n"
"</synopsis> Эта функция получает текущее время и сохраняет его в переменной "
"типа timestamp, на которую указывает <literal>ts</literal>."

#: ecpg.xml:8831(function)
msgid "dtcvasc"
msgstr "dtcvasc"

#: ecpg.xml:8833(para)
msgid ""
"Parses a timestamp from its textual representation into a timestamp "
"variable. <synopsis>\n"
"int dtcvasc(char *str, timestamp *ts);\n"
"</synopsis> The function receives the string to parse (<literal>str</"
"literal>) and a pointer to the timestamp variable that should hold the "
"result of the operation (<literal>ts</literal>)."
msgstr ""
"Разбирает время из текстового представления в переменную типа timestamp. "
"<synopsis>\n"
"int dtcvasc(char *str, timestamp *ts);\n"
"</synopsis> Эта функция получает строку (<literal>str</literal>), которую "
"нужно разобрать, и указатель на переменную типа timestamp, в которую будет "
"помещён результат операции (<literal>ts</literal>)."

#: ecpg.xml:8847(para)
msgid ""
"Internally this function uses the <xref linkend=\"pgtypestimestampfromasc\"/"
"> function. See the reference there for a table with example inputs."
msgstr ""
"Внутри эта функция вызывает <xref linkend=\"pgtypestimestampfromasc\"/>. "
"Примеры вводимых строк приведены в таблице в её описании."

#: ecpg.xml:8856(function)
msgid "dtcvfmtasc"
msgstr "dtcvfmtasc"

#: ecpg.xml:8858(para)
msgid ""
"Parses a timestamp from its textual representation using a format mask into "
"a timestamp variable. <synopsis>\n"
"dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)\n"
"</synopsis> The function receives the string to parse (<literal>inbuf</"
"literal>), the format mask to use (<literal>fmtstr</literal>) and a pointer "
"to the timestamp variable that should hold the result of the operation "
"(<literal>dtvalue</literal>)."
msgstr ""
"Разбирает время из текстового представления в переменную типа timestamp по "
"маске формата. <synopsis>\n"
"dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)\n"
"</synopsis> Эта функция получает строку (<literal>inbuf</literal>), которую "
"нужно разобрать, маску формата (<literal>fmtstr</literal>) и указатель на "
"переменную timestamp, в которой будет содержаться результат операции "
"(<literal>dtvalue</literal>)."

#: ecpg.xml:8869(para)
msgid ""
"This function is implemented by means of the <xref linkend="
"\"pgtypestimestampdefmtasc\"/> function. See the documentation there for a "
"list of format specifiers that can be used."
msgstr ""
"В реализации этой функции используется <xref linkend="
"\"pgtypestimestampdefmtasc\"/>. Список допустимых кодов формата приведён в "
"её описании."

#: ecpg.xml:8882(function)
msgid "dtsub"
msgstr "dtsub"

#: ecpg.xml:8884(para)
msgid ""
"Subtract one timestamp from another and return a variable of type interval. "
"<synopsis>\n"
"int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);\n"
"</synopsis> The function will subtract the timestamp variable that "
"<literal>ts2</literal> points to from the timestamp variable that "
"<literal>ts1</literal> points to and will store the result in the interval "
"variable that <literal>iv</literal> points to."
msgstr ""
"Вычитает одно значение времени из другого и возвращает переменную типа "
"interval. <synopsis>\n"
"int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);\n"
"</synopsis> Эта функция вычитает значение timestamp, на которое указывает "
"<literal>ts2</literal>, из значения timestamp, на которое указывает "
"<literal>ts1</literal>, и сохраняет результат в переменной типа interval, на "
"которую указывает <literal>iv</literal>."

#: ecpg.xml:8903(function)
msgid "dttoasc"
msgstr "dttoasc"

#: ecpg.xml:8905(para)
msgid ""
"Convert a timestamp variable to a C char* string. <synopsis>\n"
"int dttoasc(timestamp *ts, char *output);\n"
"</synopsis> The function receives a pointer to the timestamp variable to "
"convert (<literal>ts</literal>) and the string that should hold the result "
"of the operation (<literal>output</literal>). It converts <literal>ts</"
"literal> to its textual representation according to the SQL standard, which "
"is be <literal>YYYY-MM-DD HH:MM:SS</literal>."
msgstr ""
"Преобразует переменную типа timestamp в строку C char*. <synopsis>\n"
"int dttoasc(timestamp *ts, char *output);\n"
"</synopsis> Эта функция получает указатель (<literal>ts</literal>) на "
"переменную типа timestamp, которую нужно преобразовать, и строку "
"(<literal>output</literal>) для сохранения результата операции. Она "
"преобразует <literal>ts</literal> в текстовое представление согласно "
"стандарту SQL, то есть по маске <literal>YYYY-MM-DD HH:MM:SS</literal>."

#: ecpg.xml:8924(function)
msgid "dttofmtasc"
msgstr "dttofmtasc"

#: ecpg.xml:8926(para)
msgid ""
"Convert a timestamp variable to a C char* using a format mask. <synopsis>\n"
"int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);\n"
"</synopsis> The function receives a pointer to the timestamp to convert as "
"its first argument (<literal>ts</literal>), a pointer to the output buffer "
"(<literal>output</literal>), the maximal length that has been allocated for "
"the output buffer (<literal>str_len</literal>) and the format mask to use "
"for the conversion (<literal>fmtstr</literal>)."
msgstr ""
"Преобразует переменную типа timestamp в строку C char* по маске формата. "
"<synopsis>\n"
"int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);\n"
"</synopsis> Эта функция получает в первом аргументе (<literal>ts</literal>) "
"указатель на переменную типа timestamp, а в последующих указатель на буфер "
"вывода (<literal>output</literal>), максимальную длину строки, которую может "
"принять буфер (<literal>str_len</literal>), и маску формата, с которой будет "
"выполняться преобразование (<literal>fmtstr</literal>)."

#: ecpg.xml:8941(para)
msgid ""
"Internally, this function uses the <xref linkend=\"pgtypestimestampfmtasc\"/"
"> function. See the reference there for information on what format mask "
"specifiers can be used."
msgstr ""
"Внутри эта функция использует <xref linkend=\"pgtypestimestampfmtasc\"/>. "
"Примеры допустимых масок формата можно найти в её описании."

#: ecpg.xml:8950(function)
msgid "intoasc"
msgstr "intoasc"

#: ecpg.xml:8952(para)
msgid ""
"Convert an interval variable to a C char* string. <synopsis>\n"
"int intoasc(interval *i, char *str);\n"
"</synopsis> The function receives a pointer to the interval variable to "
"convert (<literal>i</literal>) and the string that should hold the result of "
"the operation (<literal>str</literal>). It converts <literal>i</literal> to "
"its textual representation according to the SQL standard, which is be "
"<literal>YYYY-MM-DD HH:MM:SS</literal>."
msgstr ""
"Преобразует переменную типа interval в строку C char*. <synopsis>\n"
"int intoasc(interval *i, char *str);\n"
"</synopsis> Эта функция получает указатель (<literal>i</literal>) на "
"переменную типа interval, которую нужно преобразовать, и строку "
"(<literal>str</literal>) для сохранения результата операции. Она преобразует "
"<literal>i</literal> в текстовое представление согласно стандарту SQL, то "
"есть по маске <literal>YYYY-MM-DD HH:MM:SS</literal>."

#: ecpg.xml:8971(function)
msgid "rfmtlong"
msgstr "rfmtlong"

#: ecpg.xml:8973(para)
msgid ""
"Convert a long integer value to its textual representation using a format "
"mask. <synopsis>\n"
"int rfmtlong(long lng_val, char *fmt, char *outbuf);\n"
"</synopsis> The function receives the long value <literal>lng_val</literal>, "
"the format mask <literal>fmt</literal> and a pointer to the output buffer "
"<literal>outbuf</literal>. It converts the long value according to the "
"format mask to its textual representation."
msgstr ""
"Преобразует длинное целое в текстовое представление по маске формата. "
"<synopsis>\n"
"int rfmtlong(long lng_val, char *fmt, char *outbuf);\n"
"</synopsis> Эта функция принимает значение типа long (<literal>lng_val</"
"literal>), маску формата (<literal>fmt</literal>) и указатель на выходной "
"буфер (<literal>outbuf</literal>). Она преобразует длинное целое в его "
"текстовое представление согласно заданной маске формата."

#: ecpg.xml:8989(para)
msgid ""
"<literal>*</literal> (asterisk) - if this position would be blank otherwise, "
"fill it with an asterisk."
msgstr ""
"<literal>*</literal> (звёздочка) — если в данной позиции будет пусто, "
"заполнить её звёздочкой."

#: ecpg.xml:8995(para)
msgid ""
"<literal>&amp;</literal> (ampersand) - if this position would be blank "
"otherwise, fill it with a zero."
msgstr ""
"<literal>&amp;</literal> (амперсанд) — если в данной позиции будет пусто, "
"заполнить её нулём."

#: ecpg.xml:9001(para)
msgid "<literal>#</literal> - turn leading zeroes into blanks."
msgstr "<literal>#</literal> — заменить ведущие нули пробелами."

#: ecpg.xml:9006(para)
msgid "<literal>&lt;</literal> - left-justify the number in the string."
msgstr "<literal>&lt;</literal> — выровнять число в строке по левой стороне."

#: ecpg.xml:9011(para)
msgid ""
"<literal>,</literal> (comma) - group numbers of four or more digits into "
"groups of three digits separated by a comma."
msgstr ""
"<literal>,</literal> (запятая) — сгруппировать числа, содержащие четыре и "
"более цифр, в группы по три цифры через запятую."

#: ecpg.xml:9017(para)
msgid ""
"<literal>.</literal> (period) - this character separates the whole-number "
"part of the number from the fractional part."
msgstr ""
"<literal>.</literal> (точка) — этот символ отделяет целую часть числа от "
"дробной."

#: ecpg.xml:9023(para)
msgid ""
"<literal>-</literal> (minus) - the minus sign appears if the number is a "
"negative value."
msgstr ""
"<literal>-</literal> (минус) — с отрицательным числом должен выводиться знак "
"минус."

#: ecpg.xml:9029(para)
msgid ""
"<literal>+</literal> (plus) - the plus sign appears if the number is a "
"positive value."
msgstr ""
"<literal>+</literal> (плюс) — с положительным числом должен выводиться знак "
"плюс."

#: ecpg.xml:9035(para)
msgid ""
"<literal>(</literal> - this replaces the minus sign in front of the negative "
"number. The minus sign will not appear."
msgstr ""
"<literal>(</literal> — это символ заменяет знак минус перед отрицательным "
"числом. Сам знак минус выводиться не будет."

#: ecpg.xml:9041(para)
msgid ""
"<literal>)</literal> - this character replaces the minus and is printed "
"behind the negative value."
msgstr ""
"<literal>)</literal> — этот символ заменяет минус и выводится после "
"отрицательного числа."

#: ecpg.xml:9047(para)
msgid "<literal>$</literal> - the currency symbol."
msgstr "<literal>$</literal> — символ денежной суммы."

#: ecpg.xml:8984(para)
msgid ""
"The format mask can be composed of the following format specifying "
"characters: <placeholder-1/>"
msgstr ""
"Маску формата можно составить из следующих символов, определяющих формат: "
"<placeholder-1/>"

#: ecpg.xml:9057(function)
msgid "rupshift"
msgstr "rupshift"

#: ecpg.xml:9059(para)
msgid ""
"Convert a string to upper case. <synopsis>\n"
"void rupshift(char *str);\n"
"</synopsis> The function receives a pointer to the string and transforms "
"every lower case character to upper case."
msgstr ""
"Приводит строку к верхнему регистру. <synopsis>\n"
"void rupshift(char *str);\n"
"</synopsis> Эта функция получает указатель на строку и приводит в ней каждый "
"символ в нижнем регистре к верхнему регистру."

#: ecpg.xml:9071(function)
msgid "byleng"
msgstr "byleng"

#: ecpg.xml:9073(para)
msgid ""
"Return the number of characters in a string without counting trailing "
"blanks. <synopsis>\n"
"int byleng(char *str, int len);\n"
"</synopsis> The function expects a fixed-length string as its first argument "
"(<literal>str</literal>) and its length as its second argument "
"(<literal>len</literal>). It returns the number of significant characters, "
"that is the length of the string without trailing blanks."
msgstr ""
"Возвращает число символов в строке, не считая завершающих пробелов. "
"<synopsis>\n"
"int byleng(char *str, int len);\n"
"</synopsis> Эта функция принимает в первом аргументе (<literal>str</"
"literal>) строку фиксированной длины, а во втором (<literal>len</literal>) "
"её длину. Она возвращает число значимых символов, то есть длину строки без "
"завершающих пробелов."

#: ecpg.xml:9088(function)
msgid "ldchar"
msgstr "ldchar"

#: ecpg.xml:9090(para)
msgid ""
"Copy a fixed-length string into a null-terminated string. <synopsis>\n"
"void ldchar(char *src, int len, char *dest);\n"
"</synopsis> The function receives the fixed-length string to copy "
"(<literal>src</literal>), its length (<literal>len</literal>) and a pointer "
"to the destination memory (<literal>dest</literal>). Note that you need to "
"reserve at least <literal>len+1</literal> bytes for the string that "
"<literal>dest</literal> points to. The function copies at most <literal>len</"
"literal> bytes to the new location (less if the source string has trailing "
"blanks) and adds the null-terminator."
msgstr ""
"Копирует строку фиксированной длины в строку с завершающим нулём. "
"<synopsis>\n"
"void ldchar(char *src, int len, char *dest);\n"
"</synopsis> Эта функция принимает строку фиксированной длины (<literal>src</"
"literal>), которую нужно скопировать, её длину (<literal>len</literal>) и "
"указатель на целевой буфер в памяти (<literal>dest</literal>). Учтите, что "
"для буфера, на который указывает <literal>dest</literal>, необходимо "
"выделить как минимум <literal>len+1</literal> байт. Данная функция копирует "
"в новую область не больше <literal>len</literal> байт (меньше, если в "
"исходной строке есть завершающие пробелы) и добавляет завершающий 0."

#: ecpg.xml:9107(function)
msgid "rgetmsg"
msgstr "rgetmsg"

#: ecpg.xml:9109(para)
msgid ""
"<synopsis>\n"
"int rgetmsg(int msgnum, char *s, int maxsize);\n"
"</synopsis> This function exists but is not implemented at the moment!"
msgstr ""
"<synopsis>\n"
"int rgetmsg(int msgnum, char *s, int maxsize);\n"
"</synopsis> Эта функция определена, но не реализована на данный момент!"

#: ecpg.xml:9119(function)
msgid "rtypalign"
msgstr "rtypalign"

#: ecpg.xml:9121(para)
msgid ""
"<synopsis>\n"
"int rtypalign(int offset, int type);\n"
"</synopsis> This function exists but is not implemented at the moment!"
msgstr ""
"<synopsis>\n"
"int rtypalign(int offset, int type);\n"
"</synopsis> Эта функция определена, но не реализована на данный момент!"

#: ecpg.xml:9131(function)
msgid "rtypmsize"
msgstr "rtypmsize"

#: ecpg.xml:9133(para)
msgid ""
"<synopsis>\n"
"int rtypmsize(int type, int len);\n"
"</synopsis> This function exists but is not implemented at the moment!"
msgstr ""
"<synopsis>\n"
"int rtypmsize(int type, int len);\n"
"</synopsis> Эта функция определена, но не реализована на данный момент!"

#: ecpg.xml:9143(function)
msgid "rtypwidth"
msgstr "rtypwidth"

#: ecpg.xml:9145(para)
msgid ""
"<synopsis>\n"
"int rtypwidth(int sqltype, int sqllen);\n"
"</synopsis> This function exists but is not implemented at the moment!"
msgstr ""
"<synopsis>\n"
"int rtypwidth(int sqltype, int sqllen);\n"
"</synopsis> Эта функция определена, но не реализована на данный момент!"

#: ecpg.xml:9155(function)
msgid "rsetnull"
msgstr "rsetnull"

#: ecpg.xml:9157(para)
msgid ""
"Set a variable to NULL. <synopsis>\n"
"int rsetnull(int t, char *ptr);\n"
"</synopsis> The function receives an integer that indicates the type of the "
"variable and a pointer to the variable itself that is cast to a C char* "
"pointer."
msgstr ""
"Присваивает переменной NULL. <synopsis>\n"
"int rsetnull(int t, char *ptr);\n"
"</synopsis> Эта функция получает целое, определяющее тип переменной, и "
"указатель на саму переменную, приведённый к указателю C char*."

#: ecpg.xml:9170(para)
msgid ""
"<literal>CCHARTYPE</literal> - For a variable of type <type>char</type> or "
"<type>char*</type>"
msgstr ""
"<literal>CCHARTYPE</literal> — для переменной типа <type>char</type> или "
"<type>char*</type>"

#: ecpg.xml:9175(para)
msgid ""
"<literal>CSHORTTYPE</literal> - For a variable of type <type>short int</type>"
msgstr ""
"<literal>CSHORTTYPE</literal> — для переменной типа <type>short int</type>"

#: ecpg.xml:9180(para)
msgid "<literal>CINTTYPE</literal> - For a variable of type <type>int</type>"
msgstr "<literal>CINTTYPE</literal> — для переменной типа <type>int</type>"

#: ecpg.xml:9185(para)
msgid ""
"<literal>CBOOLTYPE</literal> - For a variable of type <type>boolean</type>"
msgstr ""
"<literal>CBOOLTYPE</literal> — для переменной типа <type>boolean</type>"

#: ecpg.xml:9190(para)
msgid ""
"<literal>CFLOATTYPE</literal> - For a variable of type <type>float</type>"
msgstr "<literal>CFLOATTYPE</literal> — для переменной типа <type>float</type>"

#: ecpg.xml:9195(para)
msgid "<literal>CLONGTYPE</literal> - For a variable of type <type>long</type>"
msgstr "<literal>CLONGTYPE</literal> — для переменной типа <type>long</type>"

#: ecpg.xml:9200(para)
msgid ""
"<literal>CDOUBLETYPE</literal> - For a variable of type <type>double</type>"
msgstr ""
"<literal>CDOUBLETYPE</literal> — для переменной типа <type>double</type>"

#: ecpg.xml:9205(para)
msgid ""
"<literal>CDECIMALTYPE</literal> - For a variable of type <type>decimal</type>"
msgstr ""
"<literal>CDECIMALTYPE</literal> — для переменной типа <type>decimal</type>"

#: ecpg.xml:9210(para)
msgid "<literal>CDATETYPE</literal> - For a variable of type <type>date</type>"
msgstr "<literal>CDATETYPE</literal> — для переменной типа <type>date</type>"

#: ecpg.xml:9215(para)
msgid ""
"<literal>CDTIMETYPE</literal> - For a variable of type <type>timestamp</type>"
msgstr ""
"<literal>CDTIMETYPE</literal> — для переменной типа <type>timestamp</type>"

#: ecpg.xml:9166(para)
msgid "The following types exist: <placeholder-1/>"
msgstr "Определены следующие типы: <placeholder-1/>"

#: ecpg.xml:9222(para)
msgid "Here is an example of a call to this function: <placeholder-1/>"
msgstr "Примеры вызова этой функции: <placeholder-1/>"

#: ecpg.xml:9239(function)
msgid "risnull"
msgstr "risnull"

#: ecpg.xml:9241(para)
msgid ""
"Test if a variable is NULL. <synopsis>\n"
"int risnull(int t, char *ptr);\n"
"</synopsis> The function receives the type of the variable to test "
"(<literal>t</literal>) as well a pointer to this variable (<literal>ptr</"
"literal>). Note that the latter needs to be cast to a char*. See the "
"function <xref linkend=\"rsetnull\"/> for a list of possible variable types."
msgstr ""
"Проверяет содержимое переменной на NULL. <synopsis>\n"
"int risnull(int t, char *ptr);\n"
"</synopsis> Эта функция получает тип проверяемой переменной (<literal>t</"
"literal>), а также указатель на неё (<literal>ptr</literal>). Заметьте, что "
"этот указатель нужно привести к char*. Список возможных типов переменных "
"приведён в описании функции <xref linkend=\"rsetnull\"/>."

#: ecpg.xml:9251(para)
msgid "Here is an example of how to use this function: <placeholder-1/>"
msgstr "Примеры использования этой функции: <placeholder-1/>"

#: ecpg.xml:9271(title)
msgid "Additional Constants"
msgstr "Дополнительные константы"

#: ecpg.xml:9281(literal)
msgid "ECPG_INFORMIX_NUM_OVERFLOW"
msgstr "ECPG_INFORMIX_NUM_OVERFLOW"

#: ecpg.xml:9283(para)
msgid ""
"Functions return this value if an overflow occurred in a calculation. "
"Internally it is defined as -1200 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение, если при вычислении происходит "
"переполнение. Внутри оно представляется числом -1200 (определение "
"<productname>Informix</productname>)."

#: ecpg.xml:9292(literal)
msgid "ECPG_INFORMIX_NUM_UNDERFLOW"
msgstr "ECPG_INFORMIX_NUM_UNDERFLOW"

#: ecpg.xml:9294(para)
msgid ""
"Functions return this value if an underflow occurred in a calculation. "
"Internally it is defined as -1201 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение, если при вычислении происходит "
"антипереполнение. Внутри оно представляется числом -1201 (определение "
"<productname>Informix</productname>)."

#: ecpg.xml:9302(literal)
msgid "ECPG_INFORMIX_DIVIDE_ZERO"
msgstr "ECPG_INFORMIX_DIVIDE_ZERO"

#: ecpg.xml:9304(para)
msgid ""
"Functions return this value if an attempt to divide by zero is observed. "
"Internally it is defined as -1202 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение при попытке деления на ноль. Внутри оно "
"представляется числом -1202 (определение <productname>Informix</"
"productname>)."

#: ecpg.xml:9312(literal)
msgid "ECPG_INFORMIX_BAD_YEAR"
msgstr "ECPG_INFORMIX_BAD_YEAR"

#: ecpg.xml:9314(para)
msgid ""
"Functions return this value if a bad value for a year was found while "
"parsing a date. Internally it is defined as -1204 (the "
"<productname>Informix</productname> definition)."
msgstr ""
"Функции возвращают это значение, если при разборе даты встретилось "
"некорректное указание года. Внутри оно представляется числом -1204 "
"(определение <productname>Informix</productname>)."

#: ecpg.xml:9323(literal)
msgid "ECPG_INFORMIX_BAD_MONTH"
msgstr "ECPG_INFORMIX_BAD_MONTH"

#: ecpg.xml:9325(para)
msgid ""
"Functions return this value if a bad value for a month was found while "
"parsing a date. Internally it is defined as -1205 (the "
"<productname>Informix</productname> definition)."
msgstr ""
"Функции возвращают это значение, если при разборе даты встретилось "
"некорректное указание месяца. Внутри оно представляется числом -1205 "
"(определение <productname>Informix</productname>)."

#: ecpg.xml:9334(literal)
msgid "ECPG_INFORMIX_BAD_DAY"
msgstr "ECPG_INFORMIX_BAD_DAY"

#: ecpg.xml:9336(para)
msgid ""
"Functions return this value if a bad value for a day was found while parsing "
"a date. Internally it is defined as -1206 (the <productname>Informix</"
"productname> definition)."
msgstr ""
"Функции возвращают это значение, если при разборе даты встретилось "
"некорректное указание дня. Внутри оно представляется числом -1206 "
"(определение <productname>Informix</productname>)."

#: ecpg.xml:9345(literal)
msgid "ECPG_INFORMIX_ENOSHORTDATE"
msgstr "ECPG_INFORMIX_ENOSHORTDATE"

#: ecpg.xml:9347(para)
msgid ""
"Functions return this value if a parsing routine needs a short date "
"representation but did not get the date string in the right length. "
"Internally it is defined as -1209 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение, если процедуре разбора даты требуется "
"короткая запись даты, но строка даты имеет неподходящую длину. Внутри оно "
"представляется числом -1209 (определение <productname>Informix</"
"productname>)."

#: ecpg.xml:9356(literal)
msgid "ECPG_INFORMIX_DATE_CONVERT"
msgstr "ECPG_INFORMIX_DATE_CONVERT"

#: ecpg.xml:9358(para)
msgid ""
"Functions return this value if an error occurred during date formatting. "
"Internally it is defined as -1210 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение, если при форматировании даты происходит "
"ошибка. Внутри оно представляется числом -1210 (определение "
"<productname>Informix</productname>)."

#: ecpg.xml:9367(literal)
msgid "ECPG_INFORMIX_OUT_OF_MEMORY"
msgstr "ECPG_INFORMIX_OUT_OF_MEMORY"

#: ecpg.xml:9369(para)
msgid ""
"Functions return this value if memory was exhausted during their operation. "
"Internally it is defined as -1211 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение, если им не хватает памяти для выполнения "
"операций. Внутри оно представляется числом -1211 (определение "
"<productname>Informix</productname>)."

#: ecpg.xml:9378(literal)
msgid "ECPG_INFORMIX_ENOTDMY"
msgstr "ECPG_INFORMIX_ENOTDMY"

#: ecpg.xml:9380(para)
msgid ""
"Functions return this value if a parsing routine was supposed to get a "
"format mask (like <literal>mmddyy</literal>) but not all fields were listed "
"correctly. Internally it is defined as -1212 (the <productname>Informix</"
"productname> definition)."
msgstr ""
"Функции возвращают это значение, если процедура разбора должна была получить "
"маску формата (например, <literal>mmddyy</literal>), но не все поля были "
"записаны правильно. Внутри оно представляется числом -1212 (определение "
"<productname>Informix</productname>)."

#: ecpg.xml:9389(literal)
msgid "ECPG_INFORMIX_BAD_NUMERIC"
msgstr "ECPG_INFORMIX_BAD_NUMERIC"

#: ecpg.xml:9391(para)
msgid ""
"Functions return this value either if a parsing routine cannot parse the "
"textual representation for a numeric value because it contains errors or if "
"a routine cannot complete a calculation involving numeric variables because "
"at least one of the numeric variables is invalid. Internally it is defined "
"as -1213 (the <productname>Informix</productname> definition)."
msgstr ""
"Функции возвращают это значение, если процедура разбора не может получить "
"числовое значение из текстового представления, потому что оно некорректно, "
"либо если процедура вычисления не может произвести операцию с числовыми "
"переменными из-за недопустимого значения минимум одной из этих переменных. "
"Внутри оно представляется числом -1213 (определение <productname>Informix</"
"productname>)."

#: ecpg.xml:9402(literal)
msgid "ECPG_INFORMIX_BAD_EXPONENT"
msgstr "ECPG_INFORMIX_BAD_EXPONENT"

#: ecpg.xml:9404(para)
msgid ""
"Functions return this value if a parsing routine cannot parse an exponent. "
"Internally it is defined as -1216 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение, если процедура разбора не может воспринять "
"экспоненту в числе. Внутри оно представляется числом -1216 (определение "
"<productname>Informix</productname>)."

#: ecpg.xml:9413(literal)
msgid "ECPG_INFORMIX_BAD_DATE"
msgstr "ECPG_INFORMIX_BAD_DATE"

#: ecpg.xml:9415(para)
msgid ""
"Functions return this value if a parsing routine cannot parse a date. "
"Internally it is defined as -1218 (the <productname>Informix</productname> "
"definition)."
msgstr ""
"Функции возвращают это значение, если процедура разбора не может разобрать "
"дату. Внутри оно представляется числом -1218 (определение "
"<productname>Informix</productname>)."

#: ecpg.xml:9424(literal)
msgid "ECPG_INFORMIX_EXTRA_CHARS"
msgstr "ECPG_INFORMIX_EXTRA_CHARS"

#: ecpg.xml:9426(para)
msgid ""
"Functions return this value if a parsing routine is passed extra characters "
"it cannot parse. Internally it is defined as -1264 (the "
"<productname>Informix</productname> definition)."
msgstr ""
"Функции возвращают это значение, если процедуре разбора передаются "
"посторонние символы, которая она не может разобрать. Внутри оно "
"представляется числом -1264 (определение <productname>Informix</"
"productname>)."

#: ecpg.xml:9272(para)
msgid ""
"Note that all constants here describe errors and all of them are defined to "
"represent negative values. In the descriptions of the different constants "
"you can also find the value that the constants represent in the current "
"implementation. However you should not rely on this number. You can however "
"rely on the fact all of them are defined to represent negative values. "
"<placeholder-1/>"
msgstr ""
"Заметьте, что все эти константы относятся к ошибкам и все они представлены "
"отрицательными значениями. Из описаний различных констант вы также можете "
"узнать, какими именно числами они представлены в текущей реализации. Однако "
"полагаться на эти числа не следует. Тем не менее, вы можете рассчитывать на "
"то, что все эти значения будут отрицательными. <placeholder-1/>"

#: ecpg.xml:9439(title)
msgid "Internals"
msgstr "Внутреннее устройство"

#: ecpg.xml:9441(para)
msgid ""
"This section explains how <application>ECPG</application> works internally. "
"This information can occasionally be useful to help users understand how to "
"use <application>ECPG</application>."
msgstr ""
"В этом разделе рассказывается, как препроцессор <application>ECPG</"
"application> устроен внутри. Эта информация может оказаться полезной для "
"пользователей, желающих понять, как использовать <application>ECPG</"
"application>."

#: ecpg.xml:9447(para)
msgid ""
"The first four lines written by <command>ecpg</command> to the output are "
"fixed lines. Two are comments and two are include lines necessary to "
"interface to the library. Then the preprocessor reads through the file and "
"writes output. Normally it just echoes everything to the output."
msgstr ""
"Первые четыре строки, которые <command>ecpg</command> записывает в вывод, "
"фиксированы. Первые две строки содержат комментарии, а следующие две "
"директивы включения, подключающие интерфейс к библиотеке. Затем препроцессор "
"прочитывает файл и продолжает запись в вывод. Обычно он просто печатает всё "
"в устройство вывода."

#: ecpg.xml:9455(para)
msgid ""
"When it sees an <command>EXEC SQL</command> statement, it intervenes and "
"changes it. The command starts with <command>EXEC SQL</command> and ends "
"with <command>;</command>. Everything in between is treated as an "
"<acronym>SQL</acronym> statement and parsed for variable substitution."
msgstr ""
"Встречая команду <command>EXEC SQL</command>, он вмешивается и изменяет её. "
"Данная команда начинается со слов <command>EXEC SQL</command> и "
"заканчивается знаком <command>;</command>. Всё между ними воспринимается как "
"оператор <acronym>SQL</acronym> и разбирается для подстановки переменных."

#: ecpg.xml:9463(para)
msgid ""
"Variable substitution occurs when a symbol starts with a colon (<literal>:</"
"literal>). The variable with that name is looked up among the variables that "
"were previously declared within a <literal>EXEC SQL DECLARE</literal> "
"section."
msgstr ""
"Подстановка переменных имеет место, когда символ начинается с двоеточия "
"(<literal>:</literal>). ECPG будет искать переменную с таким именем среди "
"переменных, ранее объявленных в секции <literal>EXEC SQL DECLARE</literal>."

#: ecpg.xml:9470(para)
msgid ""
"The most important function in the library is <function>ECPGdo</function>, "
"which takes care of executing most commands. It takes a variable number of "
"arguments. This can easily add up to 50 or so arguments, and we hope this "
"will not be a problem on any platform."
msgstr ""
"Самая важная функция в библиотеке — <function>ECPGdo</function>, которая "
"осуществляет выполнение большинства команд. Она принимает переменное число "
"аргументов (это число легко может достигать 50, и мы надеемся, что это не "
"приведёт к проблемам ни на какой платформе)."

#: ecpg.xml:9483(term)
msgid "A line number"
msgstr "Номер строки"

#: ecpg.xml:9485(para)
msgid ""
"This is the line number of the original line; used in error messages only."
msgstr "Номер исходной строки; используется только в сообщениях об ошибках."

#: ecpg.xml:9493(term)
msgid "A string"
msgstr "Строка"

#: ecpg.xml:9495(para)
msgid ""
"This is the <acronym>SQL</acronym> command that is to be issued. It is "
"modified by the input variables, i.e., the variables that where not known at "
"compile time but are to be entered in the command. Where the variables "
"should go the string contains <literal>?</literal>."
msgstr ""
"Команда <acronym>SQL</acronym>, которая должна быть выполнена. На её "
"содержимое влияют входные переменные, то есть переменные, добавленные в "
"команду, но неизвестные во время компиляции. Места, в которые должны "
"вставляться переменные, обозначаются знаками <literal>?</literal>."

#: ecpg.xml:9506(term)
msgid "Input variables"
msgstr "Входные переменные"

#: ecpg.xml:9508(para)
msgid "Every input variable causes ten arguments to be created. (See below.)"
msgstr ""
"Для каждой входной переменной формируются десять аргументов. (См. ниже.)"

#: ecpg.xml:9515(parameter)
msgid "ECPGt_EOIT"
msgstr "ECPGt_EOIT"

#: ecpg.xml:9517(para)
msgid "An <type>enum</type> telling that there are no more input variables."
msgstr ""
"Перечисление (<type>enum</type>), показывающее, что больше входных "
"переменных нет."

#: ecpg.xml:9525(term)
msgid "Output variables"
msgstr "Выходные переменные"

#: ecpg.xml:9527(para)
msgid ""
"Every output variable causes ten arguments to be created. (See below.) These "
"variables are filled by the function."
msgstr ""
"Для каждой входной переменной формируются десять аргументов. (См. ниже.) Эти "
"переменные заполняются данной функцией."

#: ecpg.xml:9535(parameter)
msgid "ECPGt_EORT"
msgstr "ECPGt_EORT"

#: ecpg.xml:9537(para)
msgid "An <type>enum</type> telling that there are no more variables."
msgstr ""
"Перечисление (<type>enum</type>), показывающее, что больше выходных "
"переменных нет."

#: ecpg.xml:9478(para)
msgid "The arguments are: <placeholder-1/>"
msgstr "Ей передаются следующие аргументы: <placeholder-1/>"

#: ecpg.xml:9551(para)
msgid "The type as a special symbol."
msgstr "Тип в виде специального символа."

#: ecpg.xml:9557(para)
msgid "A pointer to the value or a pointer to the pointer."
msgstr "Указатель на значение или указатель на указатель."

#: ecpg.xml:9563(para)
msgid ""
"The size of the variable if it is a <type>char</type> or <type>varchar</"
"type>."
msgstr ""
"Размер переменной, если она имеет тип <type>char</type> или <type>varchar</"
"type>."

#: ecpg.xml:9569(para)
msgid "The number of elements in the array (for array fetches)."
msgstr "Число элементов в массиве (при выборке данных в массив)."

#: ecpg.xml:9575(para)
msgid "The offset to the next element in the array (for array fetches)."
msgstr "Смещение следующего элемента в массиве (при выборке данных в массив)."

#: ecpg.xml:9581(para)
msgid "The type of the indicator variable as a special symbol."
msgstr "Тип переменной-индикатора в виде специального символа."

#: ecpg.xml:9587(para)
msgid "A pointer to the indicator variable."
msgstr "Указатель на переменную-индикатор."

#: ecpg.xml:9593(para)
msgid "0"
msgstr "0"

#: ecpg.xml:9599(para)
msgid "The number of elements in the indicator array (for array fetches)."
msgstr "Число элементов в массиве индикаторов (при выборке данных в массив)."

#: ecpg.xml:9605(para)
msgid ""
"The offset to the next element in the indicator array (for array fetches)."
msgstr ""
"Смещение следующего элемента в массиве индикаторов (при выборке данных в "
"массив)."

#: ecpg.xml:9545(para)
msgid ""
"For every variable that is part of the <acronym>SQL</acronym> command, the "
"function gets ten arguments: <placeholder-1/>"
msgstr ""
"Для каждой переменной, включённой в команду <acronym>SQL</acronym>, эта "
"функция принимает десять аргументов: <placeholder-1/>"

#: ecpg.xml:9616(programlisting)
#, no-wrap
msgid "EXEC SQL OPEN <replaceable>cursor</replaceable>;"
msgstr "EXEC SQL OPEN <replaceable>курсор</replaceable>;"

#: ecpg.xml:9613(para)
msgid ""
"Note that not all SQL commands are treated in this way. For instance, an "
"open cursor statement like: <placeholder-1/> is not copied to the output. "
"Instead, the cursor's <command>DECLARE</command> command is used at the "
"position of the <command>OPEN</command> command because it indeed opens the "
"cursor."
msgstr ""
"Заметьте, что не все команды SQL обрабатываются таким образом. Например, "
"команда открытия курсора вида: <placeholder-1/> не копируется в вывод. "
"Вместо этого в позиции команды <command>OPEN</command> применяется команда "
"<command>DECLARE</command> этого курсора, так как на самом деле курсор "
"открывает она."

#: ecpg.xml:9628(programlisting)
#, no-wrap
msgid ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int index;\n"
"int result;\n"
"EXEC SQL END DECLARE SECTION;\n"
"...\n"
"EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;"
msgstr ""
"EXEC SQL BEGIN DECLARE SECTION;\n"
"int index;\n"
"int result;\n"
"EXEC SQL END DECLARE SECTION;\n"
"...\n"
"EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;"

#: ecpg.xml:9624(para)
msgid ""
"Here is a complete example describing the output of the preprocessor of a "
"file <filename>foo.pgc</filename> (details might change with each particular "
"version of the preprocessor): <placeholder-1/> is translated into: "
"<placeholder-2/> (The indentation here is added for readability and not "
"something the preprocessor does.)"
msgstr ""
"Ниже показан полный пример, демонстрирующий результат обработки "
"препроцессором файла <filename>foo.pgc</filename> (детали могут меняться от "
"версии к версии препроцессора): <placeholder-1/> преобразуется в: "
"<placeholder-2/> (Отступы здесь добавлены для читаемости, препроцессор их не "
"вставляет.)"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ecpg.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
