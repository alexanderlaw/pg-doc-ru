# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:14+0300\n"
"PO-Revision-Date: 2017-06-24 06:07+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:5(title)
msgid "SP-GiST Indexes"
msgstr "Индексы SP-GiST"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:7(indexterm)
msgid "<primary>index</primary> <secondary>SP-GiST</secondary>"
msgstr "<primary>индекс</primary> <secondary>SP-GiST</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:13(title)
msgid "Introduction"
msgstr "Введение"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:15(para)
msgid ""
"<acronym>SP-GiST</acronym> is an abbreviation for space-partitioned "
"<acronym>GiST</acronym>. <acronym>SP-GiST</acronym> supports partitioned "
"search trees, which facilitate development of a wide range of different non-"
"balanced data structures, such as quad-trees, k-d trees, and radix trees "
"(tries). The common feature of these structures is that they repeatedly "
"divide the search space into partitions that need not be of equal size. "
"Searches that are well matched to the partitioning rule can be very fast."
msgstr ""
"Аббревиатура <acronym>SP-GiST</acronym> расшифровывается как <quote>Space-"
"Partitioned <acronym>GiST</acronym></quote> (GiST с разбиением "
"пространства). <acronym>SP-GiST</acronym> поддерживает деревья поиска с "
"разбиением, что облегчает разработку широкого спектра различных "
"несбалансированных структур данных, в том числе деревьев квадрантов, а также "
"k-мерных и префиксных деревьев. Общей характеристикой этих структур является "
"то, что они последовательно разбивают пространство поиска на сегменты, "
"которые не обязательно должны быть равного размера. При этом поиск, хорошо "
"соответствующий правилу разбиения, с таким индексом может быть очень быстрым."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:26(para)
msgid ""
"These popular data structures were originally developed for in-memory usage. "
"In main memory, they are usually designed as a set of dynamically allocated "
"nodes linked by pointers. This is not suitable for direct storing on disk, "
"since these chains of pointers can be rather long which would require too "
"many disk accesses. In contrast, disk-based data structures should have a "
"high fanout to minimize I/O. The challenge addressed by <acronym>SP-GiST</"
"acronym> is to map search tree nodes to disk pages in such a way that a "
"search need access only a few disk pages, even if it traverses many nodes."
msgstr ""
"Эти популярные структуры данных изначально конструировались для работы в "
"памяти. При таком применении они обычно представляются в виде набора "
"динамически выделяемых узлов, связываемых указателями. Однако подобную схему "
"нельзя в таком виде перенести на диск, так как цепочки указателей могут быть "
"довольно длинными, и поэтому потребуется слишком много обращений к диску. "
"Структуры данных для хранения на диске, напротив, должны иметь большую "
"разветвлённость для минимизации объёма ввода/вывода. Для решения этой задачи "
"<acronym>SP-GiST</acronym> сопоставляет узлы дерева поиска со страницами на "
"диске так, чтобы при поиске требовалось обращаться только к нескольким "
"страницам на диске, даже если при этом нужно просмотреть множество узлов."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:38(para)
msgid ""
"Like <acronym>GiST</acronym>, <acronym>SP-GiST</acronym> is meant to allow "
"the development of custom data types with the appropriate access methods, by "
"an expert in the domain of the data type, rather than a database expert."
msgstr ""
"Как и <acronym>GiST</acronym>, <acronym>SP-GiST</acronym> призван дать "
"возможность разрабатывать дополнительные типы данных с соответствующими "
"методами доступа экспертам в предметной области типа данных, а не "
"специалистам по СУБД."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:44(para)
msgid ""
"Some of the information here is derived from Purdue University's SP-GiST "
"Indexing Project <ulink url=\"http://www.cs.purdue.edu/spgist/\">web site</"
"ulink>. The <acronym>SP-GiST</acronym> implementation in "
"<productname>PostgreSQL</productname> is primarily maintained by Teodor "
"Sigaev and Oleg Bartunov, and there is more information on their <ulink url="
"\"http://www.sai.msu.su/~megera/wiki/spgist_dev\">web site</ulink>."
msgstr ""
"Представленная здесь информация частично позаимствована с <ulink url="
"\"http://www.cs.purdue.edu/spgist/\">сайта</ulink> Проекта индексации SP-"
"GiST Университета Пердью. Сопровождением реализации <acronym>SP-GiST</"
"acronym> в <productname>PostgreSQL</productname> в основном занимаются Фёдор "
"Сигаев и Олег Бартунов; дополнительные сведения можно получить на их <ulink "
"url=\"http://www.sai.msu.su/~megera/wiki/spgist_dev\">сайте</ulink>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:58(title)
msgid "Built-in Operator Classes"
msgstr "Встроенные классы операторов"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:60(para)
msgid ""
"The core <productname>PostgreSQL</productname> distribution includes the "
"<acronym>SP-GiST</acronym> operator classes shown in <xref linkend=\"spgist-"
"builtin-opclasses-table\"/>."
msgstr ""
"В базовый дистрибутив <productname>PostgreSQL</productname> включены классы "
"операторов <acronym>SP-GiST</acronym>, перечисленные в <xref remap=\"6\" "
"linkend=\"spgist-builtin-opclasses-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:67(title)
msgid "Built-in <acronym>SP-GiST</acronym> Operator Classes"
msgstr "Встроенные классы операторов <acronym>SP-GiST</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:71(entry)
msgid "Name"
msgstr "Имя"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:72(entry)
msgid "Indexed Data Type"
msgstr "Индексируемый тип данных"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:73(entry)
msgid "Indexable Operators"
msgstr "Индексируемые операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:78(literal)
msgid "kd_point_ops"
msgstr "kd_point_ops"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:79(type) spgist.xml:91(type)
msgid "point"
msgstr "point"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:81(literal) spgist.xml:93(literal) spgist.xml:109(literal)
#: spgist.xml:120(literal) spgist.xml:159(literal)
msgid "&lt;&lt;"
msgstr "&lt;&lt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:82(literal) spgist.xml:94(literal) spgist.xml:110(literal)
#: spgist.xml:127(literal)
msgid "&lt;@"
msgstr "&lt;@"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:83(literal) spgist.xml:95(literal)
msgid "&lt;^"
msgstr "&lt;^"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:84(literal) spgist.xml:96(literal) spgist.xml:112(literal)
#: spgist.xml:124(literal) spgist.xml:154(literal)
msgid "&gt;&gt;"
msgstr "&gt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:85(literal) spgist.xml:97(literal)
msgid "&gt;^"
msgstr "&gt;^"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:86(literal) spgist.xml:98(literal) spgist.xml:125(literal)
msgid "~="
msgstr "~="

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:90(literal)
msgid "quad_point_ops"
msgstr "quad_point_ops"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:102(literal)
msgid "range_ops"
msgstr "range_ops"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:103(entry)
msgid "any range type"
msgstr "любой тип диапазона"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:105(literal) spgist.xml:122(literal) spgist.xml:153(literal)
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:106(literal) spgist.xml:121(literal)
msgid "&amp;&lt;"
msgstr "&amp;&lt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:107(literal) spgist.xml:123(literal)
msgid "&amp;&gt;"
msgstr "&amp;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:108(literal)
msgid "-|-"
msgstr "-|-"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:111(literal) spgist.xml:140(literal) spgist.xml:163(literal)
msgid "="
msgstr "="

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:113(literal) spgist.xml:126(literal)
msgid "@&gt;"
msgstr "@&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:117(literal)
msgid "box_ops"
msgstr "box_ops"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:118(type)
msgid "box"
msgstr "box"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:128(literal)
msgid "&amp;&lt;|"
msgstr "&amp;&lt;|"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:129(literal)
msgid "&lt;&lt;|"
msgstr "&lt;&lt;|"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:130(literal)
msgid "|&gt;&gt;"
msgstr "|&gt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:131(literal)
msgid "|&amp;&gt;"
msgstr "|&amp;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:135(literal)
msgid "text_ops"
msgstr "text_ops"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:136(type)
msgid "text"
msgstr "text"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:138(literal) spgist.xml:161(literal)
msgid "&lt;"
msgstr "&lt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:139(literal) spgist.xml:162(literal)
msgid "&lt;="
msgstr "&lt;="

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:141(literal) spgist.xml:156(literal)
msgid "&gt;"
msgstr "&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:142(literal) spgist.xml:157(literal)
msgid "&gt;="
msgstr "&gt;="

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:143(literal)
msgid "~&lt;=~"
msgstr "~&lt;=~"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:144(literal)
msgid "~&lt;~"
msgstr "~&lt;~"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:145(literal)
msgid "~&gt;=~"
msgstr "~&gt;=~"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:146(literal)
msgid "~&gt;~"
msgstr "~&gt;~"

#. +> REL_10
#: spgist.xml:150(literal)
msgid "inet_ops"
msgstr "inet_ops"

#. +> REL_10
#: spgist.xml:151(entry)
msgid "<type>inet</type>, <type>cidr</type>"
msgstr "<type>inet</type>, <type>cidr</type>"

#. +> REL_10
#: spgist.xml:155(literal)
msgid "&gt;&gt;="
msgstr "&gt;&gt;="

#. +> REL_10
#: spgist.xml:158(literal)
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#. +> REL_10
#: spgist.xml:160(literal)
msgid "&lt;&lt;="
msgstr "&lt;&lt;="

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:170(para)
msgid ""
"Of the two operator classes for type <type>point</type>, "
"<literal>quad_point_ops</literal> is the default. <literal>kd_point_ops</"
"literal> supports the same operators but uses a different index data "
"structure which may offer better performance in some applications."
msgstr ""
"Из двух классов операторов для типа <type>point</type> классом по умолчанию "
"является <literal>quad_point_ops</literal>. Класс <literal>kd_point_ops</"
"literal> поддерживает те же операторы, но использует другую структуру данных "
"индекса, которая может дать выигрыш в скорости для некоторых приложений."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:180(title)
msgid "Extensibility"
msgstr "Расширяемость"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:182(para)
msgid ""
"<acronym>SP-GiST</acronym> offers an interface with a high level of "
"abstraction, requiring the access method developer to implement only methods "
"specific to a given data type. The <acronym>SP-GiST</acronym> core is "
"responsible for efficient disk mapping and searching the tree structure. It "
"also takes care of concurrency and logging considerations."
msgstr ""
"<acronym>SP-GiST</acronym> предлагает интерфейс с высоким уровнем абстракции "
"и таким образом требует от разработчика метода доступа реализовать только "
"методы, специфичные для конкретного типа данных. Ядро <acronym>SP-GiST</"
"acronym> отвечает за эффективную схему обращений к диску и поиск в структуре "
"дерева, а также берёт на себя заботу о параллельном доступе и поддержке "
"журнала."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:190(para)
msgid ""
"Leaf tuples of an <acronym>SP-GiST</acronym> tree contain values of the same "
"data type as the indexed column. Leaf tuples at the root level will always "
"contain the original indexed data value, but leaf tuples at lower levels "
"might contain only a compressed representation, such as a suffix. In that "
"case the operator class support functions must be able to reconstruct the "
"original value using information accumulated from the inner tuples that are "
"passed through to reach the leaf level."
msgstr ""
"Кортежи в листьях дерева <acronym>SP-GiST</acronym> содержат значения того "
"же типа данных, что и индексируемый столбец. На верхнем уровне эти кортежи "
"содержат всегда исходное индексируемое значение данных, но на более нижних "
"могут содержать только сокращённое представление, например, суффикс. В этом "
"случае опорные функции класса операторов должны уметь восстанавливать "
"исходное значение, собирая его из внутренних кортежей, которые нужно пройти "
"для достижения уровня конкретного листа."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:200(para)
msgid ""
"Inner tuples are more complex, since they are branching points in the search "
"tree. Each inner tuple contains a set of one or more <firstterm>nodes</"
"firstterm>, which represent groups of similar leaf values. A node contains a "
"downlink that leads either to another, lower-level inner tuple, or to a "
"short list of leaf tuples that all lie on the same index page. Each node "
"normally has a <firstterm>label</firstterm> that describes it; for example, "
"in a radix tree the node label could be the next character of the string "
"value. (Alternatively, an operator class can omit the node labels, if it "
"works with a fixed set of nodes for all inner tuples; see <xref linkend="
"\"spgist-null-labels\"/>.) Optionally, an inner tuple can have a "
"<firstterm>prefix</firstterm> value that describes all its members. In a "
"radix tree this could be the common prefix of the represented strings. The "
"prefix value is not necessarily really a prefix, but can be any data needed "
"by the operator class; for example, in a quad-tree it can store the central "
"point that the four quadrants are measured with respect to. A quad-tree "
"inner tuple would then also contain four nodes corresponding to the "
"quadrants around this central point."
msgstr ""
"Внутренние кортежи устроены сложнее, так как они представляют собой точки "
"разветвления в дереве поиска. Каждый внутренний кортеж содержит набор из "
"одного или нескольких <firstterm>узлов</firstterm>, представляющих группы "
"сходных значений листьев. Узел содержит ответвление, приводящее либо к "
"другому, внутреннему кортежу нижнего уровня, либо к короткому списку "
"кортежей в листьях, лежащих в одной странице индекса. Для каждого узла "
"обычно задаётся <firstterm>метка</firstterm>, описывающая его; например, в "
"префиксном дереве меткой может быть очередной символ в строковом значении. "
"(С другой стороны, класс операторов может опускать метки узлов, если он "
"имеет дело с фиксированным набором узлов во всех внутренних кортежах; см. "
"<xref remap=\"4\" linkend=\"spgist-null-labels\"/>.) Дополнительно "
"внутренний кортеж может хранить <firstterm>префикс</firstterm>, описывающий "
"все его члены. В префиксном дереве это может быть общий префикс всех "
"представленных ниже строк. Значением префикса не обязательно должен быть "
"префикс, а могут быть любые данные, требующиеся классу операторов; например, "
"в дереве квадрантов это может быть центральная точка, от которой отмеряются "
"четыре квадранта. В этом случае внутренний кортеж дерева квадрантов будет "
"также содержать четыре узла, соответствующие квадрантам вокруг этой "
"центральной точки."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:221(para)
msgid ""
"Some tree algorithms require knowledge of level (or depth) of the current "
"tuple, so the <acronym>SP-GiST</acronym> core provides the possibility for "
"operator classes to manage level counting while descending the tree. There "
"is also support for incrementally reconstructing the represented value when "
"that is needed, and for passing down additional data (called "
"<firstterm>traverse values</firstterm>) during a tree descent."
msgstr ""
"Некоторые алгоритмы деревьев требует знания уровня (или глубины) текущего "
"кортежа, так что ядро <acronym>SP-GiST</acronym> даёт возможность классам "
"операторов контролировать число уровней при спуске по дереву. Также имеется "
"поддержка пошагового восстановления представленного значения, когда это "
"требуется, и передачи вниз дополнительных данных (так называемых "
"<firstterm>переходящих значений</firstterm>) при спуске."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:231(para)
msgid ""
"The <acronym>SP-GiST</acronym> core code takes care of null entries. "
"Although <acronym>SP-GiST</acronym> indexes do store entries for nulls in "
"indexed columns, this is hidden from the index operator class code: no null "
"index entries or search conditions will ever be passed to the operator class "
"methods. (It is assumed that <acronym>SP-GiST</acronym> operators are strict "
"and so cannot succeed for null values.) Null values are therefore not "
"discussed further here."
msgstr ""
"Ядро <acronym>SP-GiST</acronym> берёт на себя заботу о значениях NULL. Хотя "
"в индексах <acronym>SP-GiST</acronym> не хранятся записи для NULL в "
"индексируемых столбцах, это скрыто от кода класса операторов; записи "
"индексов или условия поиска с NULL никогда не передаются методам класса "
"операторов. (Предполагается, что операторы <acronym>SP-GiST</acronym> "
"строгие и не могут возвращать положительный результат для значений NULL.) "
"Поэтому значения NULL здесь больше обсуждаться не будут."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:242(para)
msgid ""
"There are five user-defined methods that an index operator class for "
"<acronym>SP-GiST</acronym> must provide. All five follow the convention of "
"accepting two <type>internal</type> arguments, the first of which is a "
"pointer to a C struct containing input values for the support method, while "
"the second argument is a pointer to a C struct where output values must be "
"placed. Four of the methods just return <type>void</type>, since all their "
"results appear in the output struct; but <function>leaf_consistent</"
"function> additionally returns a <type>boolean</type> result. The methods "
"must not modify any fields of their input structs. In all cases, the output "
"struct is initialized to zeroes before calling the user-defined method."
msgstr ""
"Класс операторов индекса для <acronym>SP-GiST</acronym> должен предоставить "
"реализации пяти методов. Все пять методов должны по единому соглашению "
"принимать два аргумента <type>internal</type>, первым из которых будет "
"указатель на структуру C, содержащую входные значения для опорного метода, а "
"вторым — указатель на структуру C, в которую должны помещаться выходные "
"значения. Четыре из этих методов должны возвращать просто <type>void</type>, "
"так как их результаты помещаются в выходную структуру; однако "
"<function>leaf_consistent</function> дополнительно возвращает результат "
"<type>boolean</type>. Эти методы не должны менять никакие поля в их входных "
"структурах. Выходная структура всегда обнуляется перед вызовом "
"пользовательского метода."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:256(para)
msgid "The five user-defined methods are:"
msgstr "Пользователь должен определить следующие пять методов:"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:262(function)
msgid "config"
msgstr "config"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:264(para)
msgid ""
"Returns static information about the index implementation, including the "
"data type OIDs of the prefix and node label data types."
msgstr ""
"Возвращает статическую информацию о реализации индекса, включая OID типов "
"данных префикса и метки узла."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:270(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_config(internal, internal) RETURNS void ..."
msgstr "CREATE FUNCTION my_config(internal, internal) RETURNS void ..."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:277(programlisting)
#, no-wrap
msgid ""
"typedef struct spgConfigIn\n"
"{\n"
"    Oid         attType;        /* Data type to be indexed */\n"
"} spgConfigIn;\n"
"\n"
"typedef struct spgConfigOut\n"
"{\n"
"    Oid         prefixType;     /* Data type of inner-tuple prefixes */\n"
"    Oid         labelType;      /* Data type of inner-tuple node labels */\n"
"    bool        canReturnData;  /* Opclass can reconstruct original data */\n"
"    bool        longValuesOK;   /* Opclass can cope with values &gt; 1 page */\n"
"} spgConfigOut;"
msgstr ""
"typedef struct spgConfigIn\n"
"{\n"
"    Oid         attType;        /* Индексируемый тип данных */\n"
"} spgConfigIn;\n"
"\n"
"typedef struct spgConfigOut\n"
"{\n"
"    Oid         prefixType;     /* Тип данных префикса во внутренних кортежах */\n"
"    Oid         labelType;      /* Тип данных метки узла во внутренних кортежах */\n"
"    bool        canReturnData;  /* Класс операторов может восстановить исходные данные */\n"
"    bool        longValuesOK;   /* Класс может принимать значения, не умещающиеся на 1 странице */\n"
"} spgConfigOut;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:268(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> The first argument is a pointer to a "
"<structname>spgConfigIn</structname> C struct, containing input data for the "
"function. The second argument is a pointer to a <structname>spgConfigOut</"
"structname> C struct, which the function must fill with result data. "
"<placeholder-2/> <structfield>attType</structfield> is passed in order to "
"support polymorphic index operator classes; for ordinary fixed-data-type "
"operator classes, it will always have the same value and so can be ignored."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> В первом аргументе передаётся указатель на структуру "
"<structname>spgConfigIn</structname> языка C, содержащие входные данные для "
"функции. Во втором аргументе передаётся указатель на структуру "
"<structname>spgConfigOut</structname> языка C, в которую функция должна "
"поместить результат. <placeholder-2/> Поле <structfield>attType</"
"structfield> передаётся для поддержки полиморфных классов операторов; для "
"обычных классов операторов с фиксированным типом оно будет всегда содержать "
"одно значение и поэтому его можно просто игнорировать."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:297(para)
msgid ""
"For operator classes that do not use prefixes, <structfield>prefixType</"
"structfield> can be set to <literal>VOIDOID</literal>. Likewise, for "
"operator classes that do not use node labels, <structfield>labelType</"
"structfield> can be set to <literal>VOIDOID</literal>. "
"<structfield>canReturnData</structfield> should be set true if the operator "
"class is capable of reconstructing the originally-supplied index value. "
"<structfield>longValuesOK</structfield> should be set true only when the "
"<structfield>attType</structfield> is of variable length and the operator "
"class is capable of segmenting long values by repeated suffixing (see <xref "
"linkend=\"spgist-limits\"/>)."
msgstr ""
"Для классов операторов, не использующих префиксы, в <structfield>prefixType</"
"structfield> можно установить <literal>VOIDOID</literal>. Подобным образом, "
"для классов операторов, не использующих метки узлов, в "
"<structfield>labelType</structfield> тоже можно установить <literal>VOIDOID</"
"literal>. Признак <structfield>canReturnData</structfield> следует "
"установить, если класс операторов может восстановить изначально переданное в "
"индекс значение. Признак <structfield>longValuesOK</structfield> должен "
"устанавливаться, только если <structfield>attType</structfield> переменной "
"длины и класс операторов может фрагментировать длинные значения, повторяя "
"суффиксы (см. <xref remap=\"4\" linkend=\"spgist-limits\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:313(function)
msgid "choose"
msgstr "choose"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:315(para)
msgid "Chooses a method for inserting a new value into an inner tuple."
msgstr "Выбирает метод для добавления нового значения во внутренний кортеж."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:321(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_choose(internal, internal) RETURNS void ..."
msgstr "CREATE FUNCTION my_choose(internal, internal) RETURNS void ..."

#. +> REL_10
#: spgist.xml:328(programlisting)
#, no-wrap
msgid ""
"typedef struct spgChooseIn\n"
"{\n"
"    Datum       datum;          /* original datum to be indexed */\n"
"    Datum       leafDatum;      /* current datum to be stored at leaf */\n"
"    int         level;          /* current level (counting from zero) */\n"
"\n"
"    /* Data from current inner tuple */\n"
"    bool        allTheSame;     /* tuple is marked all-the-same? */\n"
"    bool        hasPrefix;      /* tuple has a prefix? */\n"
"    Datum       prefixDatum;    /* if so, the prefix value */\n"
"    int         nNodes;         /* number of nodes in the inner tuple */\n"
"    Datum      *nodeLabels;     /* node label values (NULL if none) */\n"
"} spgChooseIn;\n"
"\n"
"typedef enum spgChooseResultType\n"
"{\n"
"    spgMatchNode = 1,           /* descend into existing node */\n"
"    spgAddNode,                 /* add a node to the inner tuple */\n"
"    spgSplitTuple               /* split inner tuple (change its prefix) */\n"
"} spgChooseResultType;\n"
"\n"
"typedef struct spgChooseOut\n"
"{\n"
"    spgChooseResultType resultType;     /* action code, see above */\n"
"    union\n"
"    {\n"
"        struct                  /* results for spgMatchNode */\n"
"        {\n"
"            int         nodeN;      /* descend to this node (index from 0) */\n"
"            int         levelAdd;   /* increment level by this much */\n"
"            Datum       restDatum;  /* new leaf datum */\n"
"        }           matchNode;\n"
"        struct                  /* results for spgAddNode */\n"
"        {\n"
"            Datum       nodeLabel;  /* new node's label */\n"
"            int         nodeN;      /* where to insert it (index from 0) */\n"
"        }           addNode;\n"
"        struct                  /* results for spgSplitTuple */\n"
"        {\n"
"            /* Info to form new upper-level inner tuple with one child tuple */\n"
"            bool        prefixHasPrefix;    /* tuple should have a prefix? */\n"
"            Datum       prefixPrefixDatum;  /* if so, its value */\n"
"            int         prefixNNodes;       /* number of nodes */\n"
"            Datum      *prefixNodeLabels;   /* their labels (or NULL for\n"
"                                             * no labels) */\n"
"            int         childNodeN;         /* which node gets child tuple */\n"
"\n"
"            /* Info to form new lower-level inner tuple with all old nodes */\n"
"            bool        postfixHasPrefix;   /* tuple should have a prefix? */\n"
"            Datum       postfixPrefixDatum; /* if so, its value */\n"
"        }           splitTuple;\n"
"    }           result;\n"
"} spgChooseOut;"
msgstr ""
"typedef struct spgChooseIn\n"
"{\n"
"    Datum       datum;          /* исходное значение, которое должно индексироваться */\n"
"    Datum       leafDatum;      /* текущее значение, которое должно сохраниться в листе */\n"
"    int         level;          /* текущий уровень (начиная с нуля) */\n"
"\n"
"    /* Данные из текущего внутреннего кортежа */\n"
"    bool        allTheSame;     /* кортеж с признаком все-равны? */\n"
"    bool        hasPrefix;      /* у кортежа есть префикс? */\n"
"    Datum       prefixDatum;    /* если да, то это значение префикса */\n"
"    int         nNodes;         /* число узлов во внутреннем кортеже */\n"
"    Datum      *nodeLabels;     /* значения меток узлов (NULL, если их нет) */\n"
"} spgChooseIn;\n"
"\n"
"typedef enum spgChooseResultType\n"
"{\n"
"    spgMatchNode = 1,           /* спуститься в существующий узел */\n"
"    spgAddNode,                 /* добавить узел во внутренний кортеж */\n"
"    spgSplitTuple               /* разделить внутренний кортеж (изменить его префикс) */\n"
"} spgChooseResultType;\n"
"\n"
"typedef struct spgChooseOut\n"
"{\n"
"    spgChooseResultType resultType;     /* код действия, см. выше */\n"
"    union\n"
"    {\n"
"        struct                  /* результаты для spgMatchNode */\n"
"        {\n"
"            int         nodeN;      /* спуститься к этому узлу (нумерация с 0) */\n"
"            int         levelAdd;   /* шаг увеличения уровня */\n"
"            Datum       restDatum;  /* новое значение листа */\n"
"        }           matchNode;\n"
"        struct                  /* результаты для spgAddNode */\n"
"        {\n"
"            Datum       nodeLabel;  /* метка нового узла */\n"
"            int         nodeN;      /* куда вставлять её (нумерация с 0) */\n"
"        }           addNode;\n"
"        struct                  /* результаты для spgSplitTuple */\n"
"        {\n"
"            /* Информация для формирования нового внутреннего кортежа верхнего уровня с одним дочерним кортежем */\n"
"            bool        prefixHasPrefix;    /* кортеж должен иметь префикс? */\n"
"            Datum       prefixPrefixDatum;  /* если да, его значение */\n"
"            int         prefixNNodes;       /* число узлов */\n"
"            Datum      *prefixNodeLabels;   /* их метки (или NULL, если\n"
"                                             * меток нет) */\n"
"            int         childNodeN;         /* узел, который получит дочерний кортеж */\n"
"\n"
"            /* Информация для формирования нового внутреннего кортежа нижнего уровня со всеми старыми узлами */\n"
"            bool        postfixHasPrefix;   /* кортеж должен иметь префикс? */\n"
"            Datum       postfixPrefixDatum; /* если да, его значение */\n"
"        }           splitTuple;\n"
"    }           result;\n"
"} spgChooseOut;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:319(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> The first argument is a pointer to a "
"<structname>spgChooseIn</structname> C struct, containing input data for the "
"function. The second argument is a pointer to a <structname>spgChooseOut</"
"structname> C struct, which the function must fill with result data. "
"<placeholder-2/> <structfield>datum</structfield> is the original datum that "
"was to be inserted into the index. <structfield>leafDatum</structfield> is "
"initially the same as <structfield>datum</structfield>, but can change at "
"lower levels of the tree if the <function>choose</function> or "
"<function>picksplit</function> methods change it. When the insertion search "
"reaches a leaf page, the current value of <structfield>leafDatum</"
"structfield> is what will be stored in the newly created leaf tuple. "
"<structfield>level</structfield> is the current inner tuple's level, "
"starting at zero for the root level. <structfield>allTheSame</structfield> "
"is true if the current inner tuple is marked as containing multiple "
"equivalent nodes (see <xref linkend=\"spgist-all-the-same\"/>). "
"<structfield>hasPrefix</structfield> is true if the current inner tuple "
"contains a prefix; if so, <structfield>prefixDatum</structfield> is its "
"value. <structfield>nNodes</structfield> is the number of child nodes "
"contained in the inner tuple, and <structfield>nodeLabels</structfield> is "
"an array of their label values, or NULL if there are no labels."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> В первом аргументе передаётся указатель на структуру "
"<structname>spgChooseIn</structname> языка C, содержащую входные данные для "
"функции. Во втором аргументе передаётся указатель на структуру "
"<structname>spgChooseOut</structname>, в которую функция должна поместить "
"результат. <placeholder-2/> В <structfield>datum</structfield> задаётся "
"исходное значение, которое должно быть вставлено в индекс. Значение "
"<structfield>leafDatum</structfield> изначально совпадает с "
"<structfield>datum</structfield>, но может быть другим на низких уровнях "
"дерева, если его изменят методы <function>choose</function> или "
"<function>picksplit</function>. Когда поиск места добавления достигает "
"страницы уровня листа, в создаваемом кортеже листа будет сохранено текущее "
"значение <structfield>leafDatum</structfield>. В <structfield>level</"
"structfield> задаётся текущий уровень внутреннего кортежа, начиная с нуля "
"для уровня корня. Признак <structfield>allTheSame</structfield> "
"устанавливается, если текущий внутренний кортеж содержит несколько "
"равнозначных узлов (см. <xref remap=\"4\" linkend=\"spgist-all-the-same\"/"
">). Признак <structfield>hasPrefix</structfield> устанавливается, если "
"текущий внутренний кортеж содержит префикс; в этом случае в "
"<structfield>prefixDatum</structfield> задаётся его значение. Поле "
"<structfield>nNodes</structfield> задаёт число дочерних узлов, содержащихся "
"во внутреннем кортеже, а <structfield>nodeLabels</structfield> представляет "
"массив их меток, или NULL, если меток у них нет."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:406(para)
msgid ""
"The <function>choose</function> function can determine either that the new "
"value matches one of the existing child nodes, or that a new child node must "
"be added, or that the new value is inconsistent with the tuple prefix and so "
"the inner tuple must be split to create a less restrictive prefix."
msgstr ""
"Функция <function>choose</function> может определить, соответствует ли новое "
"значение одному из существующих дочерних узлов, или что нужно добавить новый "
"дочерний узел, или что новое значение не согласуется с префиксом кортежа и "
"внутренний кортеж нужно разделить, чтобы получить менее ограничивающий "
"префикс."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:414(para)
msgid ""
"If the new value matches one of the existing child nodes, set "
"<structfield>resultType</structfield> to <literal>spgMatchNode</literal>. "
"Set <structfield>nodeN</structfield> to the index (from zero) of that node "
"in the node array. Set <structfield>levelAdd</structfield> to the increment "
"in <structfield>level</structfield> caused by descending through that node, "
"or leave it as zero if the operator class does not use levels. Set "
"<structfield>restDatum</structfield> to equal <structfield>datum</"
"structfield> if the operator class does not modify datums from one level to "
"the next, or otherwise set it to the modified value to be used as "
"<structfield>leafDatum</structfield> at the next level."
msgstr ""
"Если новое значение соответствует одному из существующих дочерних узлов, "
"установите в <structfield>resultType</structfield> значение "
"<literal>spgMatchNode</literal>. Установите в <structfield>nodeN</"
"structfield> номер этого узла в массиве узлов (нумерация начинается с нуля). "
"Установите в <structfield>levelAdd</structfield> значение, на которое должен "
"увеличиваться уровень (<structfield>level</structfield>) при спуске через "
"этот узел, либо оставьте его нулевым, если класс операторов не отслеживает "
"уровни. Установите <structfield>restDatum</structfield>, равным "
"<structfield>datum</structfield>, если класс операторов не меняет значения "
"данных от уровня к следующему, а в противном случае запишите в него "
"изменённое значение, которое должно использоваться в качестве "
"<structfield>leafDatum</structfield> на следующем уровне."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:428(para)
msgid ""
"If a new child node must be added, set <structfield>resultType</structfield> "
"to <literal>spgAddNode</literal>. Set <structfield>nodeLabel</structfield> "
"to the label to be used for the new node, and set <structfield>nodeN</"
"structfield> to the index (from zero) at which to insert the node in the "
"node array. After the node has been added, the <function>choose</function> "
"function will be called again with the modified inner tuple; that call "
"should result in an <literal>spgMatchNode</literal> result."
msgstr ""
"Если нужно добавить новый дочерний узел, установите в "
"<structfield>resultType</structfield> значение <literal>spgAddNode</"
"literal>. В <structfield>nodeLabel</structfield> задайте метку для нового "
"узла, а в <structfield>nodeN</structfield> позицию (отсчитываемую от нуля), "
"в которую должен вставляться узел в массиве узлов. После того, как узел "
"будет добавлен, функция <function>choose</function> вызывается снова с "
"изменённым внутренним кортежем; в результате этого вызова должен быть "
"получен результат <literal>spgMatchNode</literal>."

#. +> REL_10
#: spgist.xml:439(para)
msgid ""
"If the new value is inconsistent with the tuple prefix, set "
"<structfield>resultType</structfield> to <literal>spgSplitTuple</literal>. "
"This action moves all the existing nodes into a new lower-level inner tuple, "
"and replaces the existing inner tuple with a tuple having a single downlink "
"pointing to the new lower-level inner tuple. Set "
"<structfield>prefixHasPrefix</structfield> to indicate whether the new upper "
"tuple should have a prefix, and if so set <structfield>prefixPrefixDatum</"
"structfield> to the prefix value. This new prefix value must be sufficiently "
"less restrictive than the original to accept the new value to be indexed. "
"Set <structfield>prefixNNodes</structfield> to the number of nodes needed in "
"the new tuple, and set <structfield>prefixNodeLabels</structfield> to a "
"palloc'd array holding their labels, or to NULL if node labels are not "
"required. Note that the total size of the new upper tuple must be no more "
"than the total size of the tuple it is replacing; this constrains the "
"lengths of the new prefix and new labels. Set <structfield>childNodeN</"
"structfield> to the index (from zero) of the node that will downlink to the "
"new lower-level inner tuple. Set <structfield>postfixHasPrefix</structfield> "
"to indicate whether the new lower-level inner tuple should have a prefix, "
"and if so set <structfield>postfixPrefixDatum</structfield> to the prefix "
"value. The combination of these two prefixes and the downlink node's label "
"(if any) must have the same meaning as the original prefix, because there is "
"no opportunity to alter the node labels that are moved to the new lower-"
"level tuple, nor to change any child index entries. After the node has been "
"split, the <function>choose</function> function will be called again with "
"the replacement inner tuple. That call may return an <literal>spgAddNode</"
"literal> result, if no suitable node was created by the "
"<literal>spgSplitTuple</literal> action. Eventually <function>choose</"
"function> must return <literal>spgMatchNode</literal> to allow the insertion "
"to descend to the next level."
msgstr ""
"Если новое значение не согласуется с префиксом кортежа, установите в "
"<structfield>resultType</structfield> значение <literal>spgSplitTuple</"
"literal>. Это действие приводит к перемещению всех существующих узлов в "
"новый внутренний кортеж нижнего уровня и замене существующего внутреннего "
"кортежа кортежем, содержащим одну ссылку вниз на новый внутренний кортеж. "
"Установите признак <structfield>prefixHasPrefix</structfield>, чтобы "
"указать, должен ли новый верхний кортеж иметь префикс, и если да, задайте в "
"<structfield>prefixPrefixDatum</structfield> значение префикса. Это новое "
"значение префикса должно быть в достаточной мере менее ограничивающим, чем "
"исходное, чтобы в индекс было принято новое значение. Запишите в "
"<structfield>prefixNNodes</structfield> число требующихся узлов в новом "
"кортеже, а в <structfield>prefixNodeLabels</structfield> — указатель на "
"выделенный через palloc массив с их метками или NULL, если метки узлов не "
"нужны. Заметьте, что общий размер нового кортежа верхнего уровня не должен "
"превышать общий размер кортежа, который он замещает; это ограничивает длины "
"нового префикса и новых меток. Установите в <structfield>childNodeN</"
"structfield> индекс (начиная с нуля) узла, который будет ссылаться на новый "
"внутренний кортеж нижнего уровня. Установите признак "
"<structfield>postfixHasPrefix</structfield>, чтобы указать, должен ли новый "
"внутренний кортеж нижнего уровня иметь префикс, и если да, задайте в "
"<structfield>postfixPrefixDatum</structfield> значение префикса. Сочетание "
"этих двух префиксов и метки узла, ссылающегося вниз, (если она есть) должно "
"иметь то же значение, что и исходный префикс, так как нет возможности ни "
"изменить метки узлов, перемещённых в новый кортеж нижнего уровня, ни "
"изменить какие-либо нижние записи индекса. После того, как узел разделён, "
"функция <function>choose</function> будет вызвана снова с заменяемым "
"внутренним кортежем. При этом вызове может быть возвращён результат "
"<literal>spgAddNode</literal>, если подходящий узел не был создан действием "
"<literal>spgSplitTuple</literal>. В конце концов <function>choose</function> "
"должна вернуть <literal>spgMatchNode</literal>, чтобы операция добавления "
"могла перейти на следующий уровень."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:476(function)
msgid "picksplit"
msgstr "picksplit"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:478(para)
msgid "Decides how to create a new inner tuple over a set of leaf tuples."
msgstr ""
"Выбирает, как создать новый внутренний кортеж по набору кортежей в листьях."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:484(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ..."
msgstr "CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ..."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:491(programlisting)
#, no-wrap
msgid ""
"typedef struct spgPickSplitIn\n"
"{\n"
"    int         nTuples;        /* number of leaf tuples */\n"
"    Datum      *datums;         /* their datums (array of length nTuples) */\n"
"    int         level;          /* current level (counting from zero) */\n"
"} spgPickSplitIn;\n"
"\n"
"typedef struct spgPickSplitOut\n"
"{\n"
"    bool        hasPrefix;      /* new inner tuple should have a prefix? */\n"
"    Datum       prefixDatum;    /* if so, its value */\n"
"\n"
"    int         nNodes;         /* number of nodes for new inner tuple */\n"
"    Datum      *nodeLabels;     /* their labels (or NULL for no labels) */\n"
"\n"
"    int        *mapTuplesToNodes;   /* node index for each leaf tuple */\n"
"    Datum      *leafTupleDatums;    /* datum to store in each new leaf tuple */\n"
"} spgPickSplitOut;"
msgstr ""
"typedef struct spgPickSplitIn\n"
"{\n"
"    int         nTuples;        /* число кортежей в листьях */\n"
"    Datum      *datums;         /* их значения (массив длины nTuples) */\n"
"    int         level;          /* текущий уровень (отсчитывая от 0) */\n"
"} spgPickSplitIn;\n"
"\n"
"typedef struct spgPickSplitOut\n"
"{\n"
"    bool        hasPrefix;      /* новый внутренний кортеж должен иметь префикс? */\n"
"    Datum       prefixDatum;    /* если да, его значение */\n"
"\n"
"    int         nNodes;         /* число узлов для нового внутреннего кортежа */\n"
"    Datum      *nodeLabels;     /* их метки (или NULL, если их нет) */\n"
"\n"
"    int        *mapTuplesToNodes;   /* номер узла для каждого кортежа в листе */\n"
"    Datum      *leafTupleDatums;    /* значения, помещаемые в каждый новый кортеж */\n"
"} spgPickSplitOut;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:482(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> The first argument is a pointer to a "
"<structname>spgPickSplitIn</structname> C struct, containing input data for "
"the function. The second argument is a pointer to a "
"<structname>spgPickSplitOut</structname> C struct, which the function must "
"fill with result data. <placeholder-2/> <structfield>nTuples</structfield> "
"is the number of leaf tuples provided. <structfield>datums</structfield> is "
"an array of their datum values. <structfield>level</structfield> is the "
"current level that all the leaf tuples share, which will become the level of "
"the new inner tuple."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> В первом аргументе передаётся указатель на структуру "
"<structname>spgPickSplitIn</structname> языка C, содержащую входные данные "
"для функции. Во втором аргументе передаётся указатель на структуру "
"<structname>spgPickSplitOut</structname> языка C, в которую функция должна "
"поместить результат. <placeholder-2/> В <structfield>nTuples</structfield> "
"задаётся число предоставленных кортежей уровня листьев, а "
"<structfield>datums</structfield> — массив их значений данных. В "
"<structfield>level</structfield> указывается текущий уровень, который должны "
"разделять все кортежи листьев, и который станет уровнем нового внутреннего "
"кортежа."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:518(para)
msgid ""
"Set <structfield>hasPrefix</structfield> to indicate whether the new inner "
"tuple should have a prefix, and if so set <structfield>prefixDatum</"
"structfield> to the prefix value. Set <structfield>nNodes</structfield> to "
"indicate the number of nodes that the new inner tuple will contain, and set "
"<structfield>nodeLabels</structfield> to an array of their label values, or "
"to NULL if node labels are not required. Set <structfield>mapTuplesToNodes</"
"structfield> to an array that gives the index (from zero) of the node that "
"each leaf tuple should be assigned to. Set <structfield>leafTupleDatums</"
"structfield> to an array of the values to be stored in the new leaf tuples "
"(these will be the same as the input <structfield>datums</structfield> if "
"the operator class does not modify datums from one level to the next). Note "
"that the <function>picksplit</function> function is responsible for "
"palloc'ing the <structfield>nodeLabels</structfield>, "
"<structfield>mapTuplesToNodes</structfield> and "
"<structfield>leafTupleDatums</structfield> arrays."
msgstr ""
"Установите признак <structfield>hasPrefix</structfield>, чтобы указать, "
"должен ли новый внутренний кортеж иметь префикс, и если да, задайте в "
"<structfield>prefixDatum</structfield> значение префикса. Установите в "
"<structfield>nNodes</structfield> количество узлов, которые будут "
"содержаться во внутреннем кортеже, а в <structfield>nodeLabels</structfield> "
"— массив значений их меток либо NULL, если узлам не нужны метки. Поместите в "
"<structfield>mapTuplesToNodes</structfield> указатель на массив, назначающий "
"номера узлов (начиная с нуля) каждому кортежу листа. В "
"<structfield>leafTupleDatums</structfield> передайте массив значений, "
"которые должны быть сохранены в новых кортежах листьев (они будут совпадать "
"со входными значениями (<structfield>datums</structfield>), если класс "
"операторов не изменяет значения от уровня к следующему). Заметьте, что "
"функция <function>picksplit</function> сама должна выделить память, "
"используя palloc, для массивов <structfield>nodeLabels</structfield>, "
"<structfield>mapTuplesToNodes</structfield> и <structfield>leafTupleDatums</"
"structfield>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:538(para)
msgid ""
"If more than one leaf tuple is supplied, it is expected that the "
"<function>picksplit</function> function will classify them into more than "
"one node; otherwise it is not possible to split the leaf tuples across "
"multiple pages, which is the ultimate purpose of this operation. Therefore, "
"if the <function>picksplit</function> function ends up placing all the leaf "
"tuples in the same node, the core SP-GiST code will override that decision "
"and generate an inner tuple in which the leaf tuples are assigned at random "
"to several identically-labeled nodes. Such a tuple is marked "
"<literal>allTheSame</literal> to signify that this has happened. The "
"<function>choose</function> and <function>inner_consistent</function> "
"functions must take suitable care with such inner tuples. See <xref linkend="
"\"spgist-all-the-same\"/> for more information."
msgstr ""
"Если передаётся несколько кортежей листьев, ожидается, что функция "
"<function>picksplit</function> классифицирует их и разделит на несколько "
"узлов; иначе нельзя будет разнести кортежи листьев по разным страницам, что "
"является конечной целью этой операции. Таким образом, если "
"<function>picksplit</function> в итоге помещает все кортежи листьев в один "
"узел, ядро SP-GiST меняет это решение и создаёт внутренний кортеж, в котором "
"кортежи листьев связываются случайным образом с несколькими узлами с "
"одинаковыми метками. Такой кортеж помечается флагом <literal>allTheSame</"
"literal>, показывающим, что все узлы равны. Функции <function>choose</"
"function> и <function>inner_consistent</function> должны работать с такими "
"внутренними кортежами особым образом. За дополнительными сведениями "
"обратитесь к <xref remap=\"3\" linkend=\"spgist-all-the-same\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:554(para)
msgid ""
"<function>picksplit</function> can be applied to a single leaf tuple only in "
"the case that the <function>config</function> function set "
"<structfield>longValuesOK</structfield> to true and a larger-than-a-page "
"input value has been supplied. In this case the point of the operation is to "
"strip off a prefix and produce a new, shorter leaf datum value. The call "
"will be repeated until a leaf datum short enough to fit on a page has been "
"produced. See <xref linkend=\"spgist-limits\"/> for more information."
msgstr ""
"<function>picksplit</function> может применяться к одному кортежу на уровне "
"листьев, только когда функция <function>config</function> установила в "
"<structfield>longValuesOK</structfield> значение true и было передано "
"входное значение, большее страницы. В этом случае цель операции — отделить "
"префикс и получить новое, более короткое значение для листа. Этот вызов "
"будет повторяться, пока значение уровня листа не уменьшится настолько, чтобы "
"уместиться в странице. За дополнительными сведениями обратитесь к <xref "
"remap=\"3\" linkend=\"spgist-limits\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:568(function)
msgid "inner_consistent"
msgstr "inner_consistent"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:570(para)
msgid "Returns set of nodes (branches) to follow during tree search."
msgstr "Возвращает набор узлов (ветвей), по которым надо продолжать поиск."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:576(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ..."
msgstr "CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ..."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:584(programlisting)
#, no-wrap
msgid ""
"typedef struct spgInnerConsistentIn\n"
"{\n"
"    ScanKey     scankeys;       /* array of operators and comparison values */\n"
"    int         nkeys;          /* length of array */\n"
"\n"
"    Datum       reconstructedValue;     /* value reconstructed at parent */\n"
"    void       *traversalValue; /* opclass-specific traverse value */\n"
"    MemoryContext traversalMemoryContext;   /* put new traverse values here */\n"
"    int         level;          /* current level (counting from zero) */\n"
"    bool        returnData;     /* original data must be returned? */\n"
"\n"
"    /* Data from current inner tuple */\n"
"    bool        allTheSame;     /* tuple is marked all-the-same? */\n"
"    bool        hasPrefix;      /* tuple has a prefix? */\n"
"    Datum       prefixDatum;    /* if so, the prefix value */\n"
"    int         nNodes;         /* number of nodes in the inner tuple */\n"
"    Datum      *nodeLabels;     /* node label values (NULL if none) */\n"
"} spgInnerConsistentIn;\n"
"\n"
"typedef struct spgInnerConsistentOut\n"
"{\n"
"    int         nNodes;         /* number of child nodes to be visited */\n"
"    int        *nodeNumbers;    /* their indexes in the node array */\n"
"    int        *levelAdds;      /* increment level by this much for each */\n"
"    Datum      *reconstructedValues;    /* associated reconstructed values */\n"
"    void      **traversalValues;        /* opclass-specific traverse values */\n"
"} spgInnerConsistentOut;"
msgstr ""
"typedef struct spgInnerConsistentIn\n"
"{\n"
"    ScanKey     scankeys;       /* массив операторов и искомых значений */\n"
"    int         nkeys;          /* длина массива */\n"
"\n"
"    Datum       reconstructedValue;     /* значение, восстановленное для родителя */\n"
"    void       *traversalValue; /* переходящее значение, специфичное для класса операторов */\n"
"    MemoryContext traversalMemoryContext;   /* переходящие значения нужно помещать сюда */\n"
"    int         level;          /* текущий уровень (отсчитывается от нуля) */\n"
"    bool        returnData;     /* нужно ли возвращать исходные данные? */\n"
"\n"
"    /* Данные из текущего внутреннего кортежа */\n"
"    bool        allTheSame;     /* кортеж с признаком все-равны? */\n"
"    bool        hasPrefix;      /* у кортежа есть префикс? */\n"
"    Datum       prefixDatum;    /* если да, то это значение префикса */\n"
"    int         nNodes;         /* число узлов во внутреннем кортеже */\n"
"    Datum      *nodeLabels;     /* значения меток узлов (NULL, если их нет) */\n"
"} spgInnerConsistentIn;\n"
"\n"
"typedef struct spgInnerConsistentOut\n"
"{\n"
"    int         nNodes;         /* число дочерних узлов, которые нужно посетить */\n"
"    int        *nodeNumbers;    /* их номера в массиве узлов */\n"
"    int        *levelAdds;      /* шаги увеличения уровня для этих узлов */\n"
"    Datum      *reconstructedValues;    /* связанные восстановленные значения */\n"
"    void      **traversalValues;        /* переходящие значения, специфичные для класса операторов */\n"
"} spgInnerConsistentOut;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:574(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> The first argument is a pointer to a "
"<structname>spgInnerConsistentIn</structname> C struct, containing input "
"data for the function. The second argument is a pointer to a "
"<structname>spgInnerConsistentOut</structname> C struct, which the function "
"must fill with result data. <placeholder-2/> The array "
"<structfield>scankeys</structfield>, of length <structfield>nkeys</"
"structfield>, describes the index search condition(s). These conditions are "
"combined with AND &mdash; only index entries that satisfy all of them are "
"interesting. (Note that <structfield>nkeys</structfield> = 0 implies that "
"all index entries satisfy the query.) Usually the consistent function only "
"cares about the <structfield>sk_strategy</structfield> and "
"<structfield>sk_argument</structfield> fields of each array entry, which "
"respectively give the indexable operator and comparison value. In particular "
"it is not necessary to check <structfield>sk_flags</structfield> to see if "
"the comparison value is NULL, because the SP-GiST core code will filter out "
"such conditions. <structfield>reconstructedValue</structfield> is the value "
"reconstructed for the parent tuple; it is <literal>(Datum) 0</literal> at "
"the root level or if the <function>inner_consistent</function> function did "
"not provide a value at the parent level. <structfield>traversalValue</"
"structfield> is a pointer to any traverse data passed down from the previous "
"call of <function>inner_consistent</function> on the parent index tuple, or "
"NULL at the root level. <structfield>traversalMemoryContext</structfield> is "
"the memory context in which to store output traverse values (see below). "
"<structfield>level</structfield> is the current inner tuple's level, "
"starting at zero for the root level. <structfield>returnData</structfield> "
"is <literal>true</literal> if reconstructed data is required for this query; "
"this will only be so if the <function>config</function> function asserted "
"<structfield>canReturnData</structfield>. <structfield>allTheSame</"
"structfield> is true if the current inner tuple is marked <quote>all-the-"
"same</quote>; in this case all the nodes have the same label (if any) and so "
"either all or none of them match the query (see <xref linkend=\"spgist-all-"
"the-same\"/>). <structfield>hasPrefix</structfield> is true if the current "
"inner tuple contains a prefix; if so, <structfield>prefixDatum</structfield> "
"is its value. <structfield>nNodes</structfield> is the number of child nodes "
"contained in the inner tuple, and <structfield>nodeLabels</structfield> is "
"an array of their label values, or NULL if the nodes do not have labels."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> В первом аргументе передаётся указатель на структуру "
"<structname>spgInnerConsistentIn</structname> языка C, содержащую входные "
"данные для функции. Во втором аргументе передаётся указатель на структуру "
"<structname>spgInnerConsistentOut</structname> языка C, в которую функция "
"должна поместить результат. <placeholder-2/> Массив <structfield>scankeys</"
"structfield> длины <structfield>nkeys</structfield> описывает условия поиска "
"по индексу. Эти условия объединяются операцией И &mdash; найдены должны быть "
"только те записи, которые удовлетворяют всем условиям. (Заметьте, что с "
"<structfield>nkeys</structfield> = 0 подразумевается, что запросу "
"удовлетворяют все записи в индексе.) Обычно эту функцию интересуют только "
"поля <structfield>sk_strategy</structfield> и <structfield>sk_argument</"
"structfield> в каждой записи массива, в которых определяется соответственно "
"индексируемый оператор и искомое значение. В частности, нет необходимости "
"проверять <structfield>sk_flags</structfield>, чтобы распознать NULL в "
"искомом значении, так как ядро SP-GiST отфильтрует такие условия. В "
"<structfield>reconstructedValue</structfield> передаётся значение, "
"восстановленное для родительского кортежа; это может быть <literal>(Datum) "
"0</literal> на уровне корня или если функция <function>inner_consistent</"
"function> не установила значение на предыдущем уровне. В "
"<structfield>traversalValue</structfield> передаётся указатель на "
"переходящие данные, полученные из предыдущего вызова "
"<function>inner_consistent</function> для родительского кортежа индекса, "
"либо NULL на уровне корня. Поле <structfield>traversalMemoryContext</"
"structfield> указывает на контекст памяти, в котором нужно сохранить "
"выходные переходящие данные (см. ниже). В <structfield>level</structfield> "
"передаётся уровень текущего внутреннего кортежа (уровень корня считается "
"нулевым). Флаг <structfield>returnData</structfield> устанавливается, когда "
"для этого запроса нужно получить восстановленные данные; это возможно, "
"только если функция <function>config</function> установила признак "
"<structfield>canReturnData</structfield>. Признак <structfield>allTheSame</"
"structfield> устанавливается, если текущий внутренний кортеж имеет пометку "
"<quote>все-равны</quote>; в этом случае все узлы имеют одну метку (если "
"имеют) и значит, либо все они, либо никакой не соответствует запросу (см. "
"<xref remap=\"4\" linkend=\"spgist-all-the-same\"/>). Признак "
"<structfield>hasPrefix</structfield> устанавливается, если текущий "
"внутренний кортеж содержит префикс; в этом случае в "
"<structfield>prefixDatum</structfield> находится его значение. В "
"<structfield>nNodes</structfield> задаётся число дочерних узлов, "
"содержащихся во внутреннем кортеже, а в <structfield>nodeLabels</"
"structfield> — массив их меток либо NULL, если они не имеют меток."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:652(para)
msgid ""
"<structfield>nNodes</structfield> must be set to the number of child nodes "
"that need to be visited by the search, and <structfield>nodeNumbers</"
"structfield> must be set to an array of their indexes. If the operator class "
"keeps track of levels, set <structfield>levelAdds</structfield> to an array "
"of the level increments required when descending to each node to be visited. "
"(Often these increments will be the same for all the nodes, but that's not "
"necessarily so, so an array is used.) If value reconstruction is needed, set "
"<structfield>reconstructedValues</structfield> to an array of the values "
"reconstructed for each child node to be visited; otherwise, leave "
"<structfield>reconstructedValues</structfield> as NULL. If it is desired to "
"pass down additional out-of-band information (<quote>traverse values</"
"quote>) to lower levels of the tree search, set "
"<structfield>traversalValues</structfield> to an array of the appropriate "
"traverse values, one for each child node to be visited; otherwise, leave "
"<structfield>traversalValues</structfield> as NULL. Note that the "
"<function>inner_consistent</function> function is responsible for palloc'ing "
"the <structfield>nodeNumbers</structfield>, <structfield>levelAdds</"
"structfield>, <structfield>reconstructedValues</structfield>, and "
"<structfield>traversalValues</structfield> arrays in the current memory "
"context. However, any output traverse values pointed to by the "
"<structfield>traversalValues</structfield> array should be allocated in "
"<structfield>traversalMemoryContext</structfield>. Each traverse value must "
"be a single palloc'd chunk."
msgstr ""
"В <structfield>nNodes</structfield> нужно записать число дочерних узлов, "
"которые потребуется посетить при поиске, а в <structfield>nodeNumbers</"
"structfield> — массив их индексов. Если класс операторов отслеживает уровни, "
"в <structfield>levelAdds</structfield> нужно передать массив с шагами "
"увеличения уровня при посещении каждого узла. (Часто шаг будет одним для "
"всех узлов, но может быть и по-другому, поэтому применяется массив.) Если "
"потребовалось восстановить значения, поместите в "
"<structfield>reconstructedValues</structfield> указатель на массив значений, "
"восстановленных для каждого дочернего узла, который нужно посетить; в "
"противном случае оставьте <structfield>reconstructedValues</structfield> "
"равным NULL. Если желательно передать дополнительные данные "
"(<quote>переходящие значения</quote>) на нижние уровни при поиске по дереву, "
"поместите в <structfield>traversalValues</structfield> указатель на массив "
"соответствующих переходящих значений, по одному для каждого дочернего узла, "
"который нужно посетить; в противном случае оставьте в "
"<structfield>traversalValues</structfield> значение NULL. Заметьте, что "
"функция <function>inner_consistent</function> сама должна выделять память, "
"используя palloc, для массивов <structfield>nodeNumbers</structfield>, "
"<structfield>levelAdds</structfield>, <structfield>distances</structfield>, "
"<structfield>reconstructedValues</structfield> и "
"<structfield>traversalValues</structfield> в текущем контексте памяти. "
"Однако выходные переходящие значения, на которые указывает массив "
"<structfield>traversalValues</structfield>, должны размещаться в контексте "
"<structfield>traversalMemoryContext</structfield>. При этом каждое "
"переходящее значения должно располагаться в отдельном блоке памяти palloc."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:684(function)
msgid "leaf_consistent"
msgstr "leaf_consistent"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:686(para)
msgid "Returns true if a leaf tuple satisfies a query."
msgstr "Возвращает true, если кортеж листа удовлетворяет запросу."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:692(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ..."
msgstr "CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ..."

#. +> REL_10
#: spgist.xml:699(programlisting)
#, no-wrap
msgid ""
"typedef struct spgLeafConsistentIn\n"
"{\n"
"    ScanKey     scankeys;       /* array of operators and comparison values */\n"
"    int         nkeys;          /* length of array */\n"
"\n"
"    Datum       reconstructedValue;     /* value reconstructed at parent */\n"
"    void       *traversalValue; /* opclass-specific traverse value */\n"
"    int         level;          /* current level (counting from zero) */\n"
"    bool        returnData;     /* original data must be returned? */\n"
"\n"
"    Datum       leafDatum;      /* datum in leaf tuple */\n"
"} spgLeafConsistentIn;\n"
"\n"
"typedef struct spgLeafConsistentOut\n"
"{\n"
"    Datum       leafValue;      /* reconstructed original data, if any */\n"
"    bool        recheck;        /* set true if operator must be rechecked */\n"
"} spgLeafConsistentOut;"
msgstr ""
"typedef struct spgLeafConsistentIn\n"
"{\n"
"    ScanKey     scankeys;       /* массив операторов и искомых значений */\n"
"    int         nkeys;          /* длина массива */\n"
"\n"
"    Datum       reconstructedValue;     /* значение, восстановленное для родителя */\n"
"    void       *traversalValue; /* переходящее значение, специфичное для класса операторов */\n"
"    int         level;          /* текущий уровень (отсчитывая от нуля) */\n"
"    bool        returnData;     /* нужно ли возвращать исходные данные? */\n"
"\n"
"    Datum       leafDatum;      /* значение в кортеже листа */\n"
"} spgLeafConsistentIn;\n"
"\n"
"typedef struct spgLeafConsistentOut\n"
"{\n"
"    Datum       leafValue;      /* восстановленные исходные данные, при наличии */\n"
"    bool        recheck;        /* true, если оператор нужно перепроверить */\n"
"} spgLeafConsistentOut;"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:690(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> The first argument is a pointer to a "
"<structname>spgLeafConsistentIn</structname> C struct, containing input data "
"for the function. The second argument is a pointer to a "
"<structname>spgLeafConsistentOut</structname> C struct, which the function "
"must fill with result data. <placeholder-2/> The array "
"<structfield>scankeys</structfield>, of length <structfield>nkeys</"
"structfield>, describes the index search condition(s). These conditions are "
"combined with AND &mdash; only index entries that satisfy all of them "
"satisfy the query. (Note that <structfield>nkeys</structfield> = 0 implies "
"that all index entries satisfy the query.) Usually the consistent function "
"only cares about the <structfield>sk_strategy</structfield> and "
"<structfield>sk_argument</structfield> fields of each array entry, which "
"respectively give the indexable operator and comparison value. In particular "
"it is not necessary to check <structfield>sk_flags</structfield> to see if "
"the comparison value is NULL, because the SP-GiST core code will filter out "
"such conditions. <structfield>reconstructedValue</structfield> is the value "
"reconstructed for the parent tuple; it is <literal>(Datum) 0</literal> at "
"the root level or if the <function>inner_consistent</function> function did "
"not provide a value at the parent level. <structfield>traversalValue</"
"structfield> is a pointer to any traverse data passed down from the previous "
"call of <function>inner_consistent</function> on the parent index tuple, or "
"NULL at the root level. <structfield>level</structfield> is the current leaf "
"tuple's level, starting at zero for the root level. <structfield>returnData</"
"structfield> is <literal>true</literal> if reconstructed data is required "
"for this query; this will only be so if the <function>config</function> "
"function asserted <structfield>canReturnData</structfield>. "
"<structfield>leafDatum</structfield> is the key value stored in the current "
"leaf tuple."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> В первом аргументе передаётся указатель на структуру "
"<structname>spgLeafConsistentIn</structname> языка C, содержащую входные "
"данные для функции. Во втором аргументе передаётся указатель на структуру "
"<structname>spgLeafConsistentOut</structname> языка C, в которую функция "
"должна поместить результат. <placeholder-2/> Массив <structfield>scankeys</"
"structfield> длины <structfield>nkeys</structfield> описывает условия поиска "
"по индексу. Эти условия объединяются операцией И &mdash; запросу "
"удовлетворяют только те записи в индексе, которые удовлетворяют всем этим "
"условиям. (Заметьте, что с <structfield>nkeys</structfield> = 0 "
"подразумевается, что запросу удовлетворяют все записи в индексе.) Обычно эту "
"функцию интересуют только поля <structfield>sk_strategy</structfield> и "
"<structfield>sk_argument</structfield> в каждой записи массива, в которых "
"определяются соответственно индексируемый оператор и искомое значение. В "
"частности, нет необходимости проверять <structfield>sk_flags</structfield>, "
"чтобы распознать NULL в искомом значении, так как ядро SP-GiST отфильтрует "
"такие условия. В <structfield>reconstructedValue</structfield> передаётся "
"значение, восстановленное для родительского кортежа; это может быть "
"<literal>(Datum) 0</literal> на уровне корня или если функция "
"<function>inner_consistent</function> не установила значение на предыдущем "
"уровне. В <structfield>traversalValue</structfield> передаётся указатель на "
"переходящие данные, полученные из предыдущего вызова "
"<function>inner_consistent</function> для родительского кортежа индекса, "
"либо NULL на уровне корня. В <structfield>level</structfield> передаётся "
"уровень текущего внутреннего кортежа (уровень корня считается нулевым). Флаг "
"<structfield>returnData</structfield> устанавливается, когда для этого "
"запроса нужно получить восстановленные данные; это возможно, только если "
"функция <function>config</function> установила признак "
"<structfield>canReturnData</structfield>. В <structfield>leafDatum</"
"structfield> передаётся значение ключа, записанное в текущем кортеже листа."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:747(para)
msgid ""
"The function must return <literal>true</literal> if the leaf tuple matches "
"the query, or <literal>false</literal> if not. In the <literal>true</"
"literal> case, if <structfield>returnData</structfield> is <literal>true</"
"literal> then <structfield>leafValue</structfield> must be set to the value "
"originally supplied to be indexed for this leaf tuple. Also, "
"<structfield>recheck</structfield> may be set to <literal>true</literal> if "
"the match is uncertain and so the operator(s) must be re-applied to the "
"actual heap tuple to verify the match."
msgstr ""
"Эта функция должна вернуть <literal>true</literal>, если кортеж листа "
"соответствует запросу, или <literal>false</literal> в противном случае. В "
"случае положительного результата, если в поле <structfield>returnData</"
"structfield> передано <literal>true</literal>, нужно поместить в "
"<structfield>leafValue</structfield> значение, изначально переданное для "
"индексации в этот кортеж. Кроме того, флагу <structfield>recheck</"
"structfield> можно присвоить <literal>true</literal>, если соответствие "
"неточное, так что для установления точного результата проверки нужно "
"повторно применить оператор(ы) к актуальному кортежу данных."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:761(para)
msgid ""
"All the SP-GiST support methods are normally called in a short-lived memory "
"context; that is, <varname>CurrentMemoryContext</varname> will be reset "
"after processing of each tuple. It is therefore not very important to worry "
"about pfree'ing everything you palloc. (The <function>config</function> "
"method is an exception: it should try to avoid leaking memory. But usually "
"the <function>config</function> method need do nothing but assign constants "
"into the passed parameter struct.)"
msgstr ""
"Все опорные методы SP-GiST обычно вызываются в кратковременных контекстах "
"памяти; то есть <varname>CurrentMemoryContext</varname> сбрасывается после "
"обработки каждого кортежа. Таким образом, можно не заботиться об "
"освобождении любых блоков памяти, выделенных функцией palloc. (Метод "
"<function>config</function> является исключением: в нём нужно не допускать "
"утечек памяти. Но обычно метод <function>config</function> не делает ничего, "
"кроме как присваивает константы переданной структуре параметров.)"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:771(para)
msgid ""
"If the indexed column is of a collatable data type, the index collation will "
"be passed to all the support methods, using the standard "
"<function>PG_GET_COLLATION()</function> mechanism."
msgstr ""
"Если индексируемый столбец имеет сортируемый тип данных, правило сортировки "
"индекса будет передаваться всем опорным методам, используя стандартный "
"механизм <function>PG_GET_COLLATION()</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:780(title)
msgid "Implementation"
msgstr "Реализация"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:782(para)
msgid ""
"This section covers implementation details and other tricks that are useful "
"for implementers of <acronym>SP-GiST</acronym> operator classes to know."
msgstr ""
"В этом разделе освещаются тонкости реализации и особенности, о которых "
"полезно знать тем, кто будет реализовывать классы операторов <acronym>SP-"
"GiST</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:789(title)
msgid "SP-GiST Limits"
msgstr "Ограничения SP-GiST"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:791(para)
msgid ""
"Individual leaf tuples and inner tuples must fit on a single index page (8kB "
"by default). Therefore, when indexing values of variable-length data types, "
"long values can only be supported by methods such as radix trees, in which "
"each level of the tree includes a prefix that is short enough to fit on a "
"page, and the final leaf level includes a suffix also short enough to fit on "
"a page. The operator class should set <structfield>longValuesOK</"
"structfield> to TRUE only if it is prepared to arrange for this to happen. "
"Otherwise, the <acronym>SP-GiST</acronym> core will reject any request to "
"index a value that is too large to fit on an index page."
msgstr ""
"Отдельные кортежи листьев и внутренние кортежи должны умещаться в одной "
"странице индекса (по умолчанию её размер 8 Кбайт). Таким образом при "
"индексировании значений типов данных переменной длины большие значения могут "
"поддерживаться только такими схемами, как префиксные деревья, в которых "
"каждый уровень дерева включает префикс, достаточно короткий для помещения в "
"страницу, и на конечном уровне листьев содержится суффикс, который также "
"достаточно мал, чтобы поместиться в странице. Класс операторов должен "
"устанавливать признак <structfield>longValuesOK</structfield>, только если "
"он готов организовывать такую структуру. Если этот признак не установлен, "
"ядро <acronym>SP-GiST</acronym> не примет запрос на индексацию значения, "
"которое слишком велико для одной страницы индекса."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:804(para)
msgid ""
"Likewise, it is the operator class's responsibility that inner tuples do not "
"grow too large to fit on an index page; this limits the number of child "
"nodes that can be used in one inner tuple, as well as the maximum size of a "
"prefix value."
msgstr ""
"Также класс операторов должен отвечать за то, чтобы внутренние кортежи при "
"расширении не выходили за пределы страницы индекса; это ограничивает число "
"дочерних узлов, которые могут принадлежать одному внутреннему кортежу, а "
"также максимальный размер значения префикса."

#. +> REL9_6_3 REL9_6
#: spgist.xml:804(para)
msgid ""
"Some tree algorithms use a fixed set of nodes for each inner tuple; for "
"example, in a quad-tree there are always exactly four nodes corresponding to "
"the four quadrants around the inner tuple's centroid point. In such a case "
"the code typically works with the nodes by number, and there is no need for "
"explicit node labels. To suppress node labels (and thereby save some space), "
"the <function>picksplit</function> function can return NULL for the "
"<structfield>nodeLabels</structfield> array. This will in turn result in "
"<structfield>nodeLabels</structfield> being NULL during subsequent calls to "
"<function>choose</function> and <function>inner_consistent</function>. In "
"principle, node labels could be used for some inner tuples and omitted for "
"others in the same index."
msgstr ""
"В некоторых древовидных схемах каждый внутренний кортеж содержит "
"фиксированный набор узлов; например, в дереве квадрантов это всегда четыре "
"узла, соответствующие четырём квадрантам вокруг центральной точки "
"внутреннего кортежа. В таком случае код обычно работает с узлами по номерам "
"и необходимости в явных метках узлов нет. Чтобы убрать метки узлов (и таким "
"образом сэкономить место), функция <function>picksplit</function> может "
"возвратить NULL вместо массива <structfield>nodeLabels</structfield>. В "
"результате при последующих вызовах функций <function>choose</function> и "
"<function>inner_consistent</function> им вместо <structfield>nodeLabels</"
"structfield> будет передаваться NULL. В принципе метки узлов могут "
"применяться для одних внутренних кортежей и опускаться для других в том же "
"индексе."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:811(para)
msgid ""
"Another limitation is that when an inner tuple's node points to a set of "
"leaf tuples, those tuples must all be in the same index page. (This is a "
"design decision to reduce seeking and save space in the links that chain "
"such tuples together.) If the set of leaf tuples grows too large for a page, "
"a split is performed and an intermediate inner tuple is inserted. For this "
"to fix the problem, the new inner tuple <emphasis>must</emphasis> divide the "
"set of leaf values into more than one node group. If the operator class's "
"<function>picksplit</function> function fails to do that, the <acronym>SP-"
"GiST</acronym> core resorts to extraordinary measures described in <xref "
"linkend=\"spgist-all-the-same\"/>."
msgstr ""
"Ещё одно ограничение состоит в том, что когда узел внутреннего кортежа "
"указывает на набор кортежей листьев, все эти кортежи должны находиться в "
"одной странице индекса. (Это конструктивное ограничение введено для "
"оптимизации позиционирования и экономии места на ссылках, связывающих такие "
"кортежи вместе.) Если набор кортежей листьев оказывается слишком большим для "
"одной страницы, выполняется разделение и вставляется промежуточный "
"внутренний кортеж. Чтобы устранить возникшую проблему, новый внутренний "
"кортеж <emphasis>должен</emphasis> разделять набор значений в листе на "
"несколько групп узлов. Если функция <function>picksplit</function> класса "
"операторов не может сделать это, ядро <acronym>SP-GiST</acronym> переходит к "
"чрезвычайным мерам, описанным в <xref remap=\"6\" linkend=\"spgist-all-the-"
"same\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:826(title)
msgid "SP-GiST Without Node Labels"
msgstr "SP-GiST без меток узлов"

#. +> REL_10
#: spgist.xml:828(para)
msgid ""
"Some tree algorithms use a fixed set of nodes for each inner tuple; for "
"example, in a quad-tree there are always exactly four nodes corresponding to "
"the four quadrants around the inner tuple's centroid point. In such a case "
"the code typically works with the nodes by number, and there is no need for "
"explicit node labels. To suppress node labels (and thereby save some space), "
"the <function>picksplit</function> function can return NULL for the "
"<structfield>nodeLabels</structfield> array, and likewise the "
"<function>choose</function> function can return NULL for the "
"<structfield>prefixNodeLabels</structfield> array during a "
"<literal>spgSplitTuple</literal> action. This will in turn result in "
"<structfield>nodeLabels</structfield> being NULL during subsequent calls to "
"<function>choose</function> and <function>inner_consistent</function>. In "
"principle, node labels could be used for some inner tuples and omitted for "
"others in the same index."
msgstr ""
"В некоторых древовидных схемах каждый внутренний кортеж содержит "
"фиксированный набор узлов; например, в дереве квадрантов это всегда четыре "
"узла, соответствующие четырём квадрантам вокруг центральной точки "
"внутреннего кортежа. В таком случае код обычно работает с узлами по номерам "
"и необходимости в явных метках узлов нет. Чтобы убрать метки узлов (и таким "
"образом сэкономить место), функция <function>picksplit</function> может "
"возвратить NULL вместо массива <structfield>nodeLabels</structfield>, а "
"функция <function>choose</function> аналогично может возвратить NULL вместо "
"массива <structfield>prefixNodeLabels</structfield> во время действия "
"<literal>spgSplitTuple</literal>. В результате при последующих вызовах "
"функций <function>choose</function> и <function>inner_consistent</function> "
"им вместо <structfield>nodeLabels</structfield> будет передаваться NULL. В "
"принципе метки узлов могут применяться для одних внутренних кортежей и "
"отсутствовать у других в том же индексе."

#. +> REL_10
#: spgist.xml:845(para)
msgid ""
"When working with an inner tuple having unlabeled nodes, it is an error for "
"<function>choose</function> to return <literal>spgAddNode</literal>, since "
"the set of nodes is supposed to be fixed in such cases."
msgstr ""
"Когда внутренний кортеж содержит узлы без меток, функция <function>choose</"
"function> не может выбрать действие <literal>spgAddNode</literal>, так как в "
"этом случае предполагается, что набор узлов фиксированный."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:853(title)
msgid "<quote>All-the-same</quote> Inner Tuples"
msgstr "Внутренние кортежи <quote>все-равны</quote>"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:855(para)
msgid ""
"The <acronym>SP-GiST</acronym> core can override the results of the operator "
"class's <function>picksplit</function> function when <function>picksplit</"
"function> fails to divide the supplied leaf values into at least two node "
"categories. When this happens, the new inner tuple is created with multiple "
"nodes that each have the same label (if any) that <function>picksplit</"
"function> gave to the one node it did use, and the leaf values are divided "
"at random among these equivalent nodes. The <literal>allTheSame</literal> "
"flag is set on the inner tuple to warn the <function>choose</function> and "
"<function>inner_consistent</function> functions that the tuple does not have "
"the node set that they might otherwise expect."
msgstr ""
"Ядро <acronym>SP-GiST</acronym> может переопределить результаты функции "
"<function>picksplit</function> класса операторов, когда эта функция не может "
"разделить поступившие значения листьев на минимум две категории узлов. Когда "
"это происходит, создаётся новый внутренний кортеж с несколькими узлами, "
"каждый из которых имеет одну метку (если имеет), которую "
"<function>picksplit</function> дала одному узлу, а значения листьев "
"распределяются случайно между этими равнозначными узлами. Для этого "
"внутреннего кортежа устанавливается флаг <literal>allTheSame</literal>, "
"который предупреждает функции <function>choose</function> и "
"<function>inner_consistent</function>, что кортеж не содержит набор узлов, "
"который они обычно ожидают."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:868(para)
msgid ""
"When dealing with an <literal>allTheSame</literal> tuple, a "
"<function>choose</function> result of <literal>spgMatchNode</literal> is "
"interpreted to mean that the new value can be assigned to any of the "
"equivalent nodes; the core code will ignore the supplied <structfield>nodeN</"
"structfield> value and descend into one of the nodes at random (so as to "
"keep the tree balanced). It is an error for <function>choose</function> to "
"return <literal>spgAddNode</literal>, since that would make the nodes not "
"all equivalent; the <literal>spgSplitTuple</literal> action must be used if "
"the value to be inserted doesn't match the existing nodes."
msgstr ""
"Когда обрабатывается кортеж с флагом <literal>allTheSame</literal>, "
"выбранное функцией <function>choose</function> действие "
"<literal>spgMatchNode</literal> воспринимается как указание, что новое "
"значение можно присвоить одному из равнозначных узлов; код ядра будет "
"игнорировать полученное значение <structfield>nodeN</structfield> и "
"спустится в один из узлов, выбранный случайно (чтобы дерево было "
"сбалансированным). Будет считаться ошибкой, если <function>choose</function> "
"выберет действие <literal>spgAddNode</literal>, так как при этом не все узлы "
"окажутся равны; если добавляемое значение не соответствует существующим "
"узлам, должно выбираться действие <literal>spgSplitTuple</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:880(para)
msgid ""
"When dealing with an <literal>allTheSame</literal> tuple, the "
"<function>inner_consistent</function> function should return either all or "
"none of the nodes as targets for continuing the index search, since they are "
"all equivalent. This may or may not require any special-case code, depending "
"on how much the <function>inner_consistent</function> function normally "
"assumes about the meaning of the nodes."
msgstr ""
"Также, когда обрабатывается кортеж с флагом <literal>allTheSame</literal>, "
"функция <function>inner_consistent</function> должна вернуть все или не "
"возвращать никакие узлы для продолжения поиска по индексу, так как все узлы "
"равнозначны. Для этого может потребоваться, а может и не потребоваться код "
"обработки особого случая, в зависимости от того, как "
"<function>inner_consistent</function> обычно воспринимает узлы."

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:893(title)
msgid "Examples"
msgstr "Примеры"

#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:895(para)
msgid ""
"The <productname>PostgreSQL</productname> source distribution includes "
"several examples of index operator classes for <acronym>SP-GiST</acronym>, "
"as described in <xref linkend=\"spgist-builtin-opclasses-table\"/>. Look "
"into <filename>src/backend/access/spgist/</filename> and <filename>src/"
"backend/utils/adt/</filename> to see the code."
msgstr ""
"Дистрибутив исходного кода <productname>PostgreSQL</productname> содержит "
"несколько примеров классов операторов индекса <acronym>SP-GiST</acronym>, "
"перечисленных в <xref remap=\"6\" linkend=\"spgist-builtin-opclasses-table\"/"
">. Код их реализации вы можете найти в <filename>src/backend/access/spgist/</"
"filename> и <filename>src/backend/utils/adt/</filename>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: spgist.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: spgist.xml:311(programlisting)
#, no-wrap
msgid ""
"typedef struct spgChooseIn\n"
"{\n"
"    Datum       datum;          /* original datum to be indexed */\n"
"    Datum       leafDatum;      /* current datum to be stored at leaf */\n"
"    int         level;          /* current level (counting from zero) */\n"
"\n"
"    /* Data from current inner tuple */\n"
"    bool        allTheSame;     /* tuple is marked all-the-same? */\n"
"    bool        hasPrefix;      /* tuple has a prefix? */\n"
"    Datum       prefixDatum;    /* if so, the prefix value */\n"
"    int         nNodes;         /* number of nodes in the inner tuple */\n"
"    Datum      *nodeLabels;     /* node label values (NULL if none) */\n"
"} spgChooseIn;\n"
"\n"
"typedef enum spgChooseResultType\n"
"{\n"
"    spgMatchNode = 1,           /* descend into existing node */\n"
"    spgAddNode,                 /* add a node to the inner tuple */\n"
"    spgSplitTuple               /* split inner tuple (change its prefix) */\n"
"} spgChooseResultType;\n"
"\n"
"typedef struct spgChooseOut\n"
"{\n"
"    spgChooseResultType resultType;     /* action code, see above */\n"
"    union\n"
"    {\n"
"        struct                  /* results for spgMatchNode */\n"
"        {\n"
"            int         nodeN;      /* descend to this node (index from 0) */\n"
"            int         levelAdd;   /* increment level by this much */\n"
"            Datum       restDatum;  /* new leaf datum */\n"
"        }           matchNode;\n"
"        struct                  /* results for spgAddNode */\n"
"        {\n"
"            Datum       nodeLabel;  /* new node's label */\n"
"            int         nodeN;      /* where to insert it (index from 0) */\n"
"        }           addNode;\n"
"        struct                  /* results for spgSplitTuple */\n"
"        {\n"
"            /* Info to form new inner tuple with one node */\n"
"            bool        prefixHasPrefix;    /* tuple should have a prefix? */\n"
"            Datum       prefixPrefixDatum;  /* if so, its value */\n"
"            Datum       nodeLabel;          /* node's label */\n"
"\n"
"            /* Info to form new lower-level inner tuple with all old nodes */\n"
"            bool        postfixHasPrefix;   /* tuple should have a prefix? */\n"
"            Datum       postfixPrefixDatum; /* if so, its value */\n"
"        }           splitTuple;\n"
"    }           result;\n"
"} spgChooseOut;"
msgstr ""
"typedef struct spgChooseIn\n"
"{\n"
"    Datum       datum;          /* исходное значение, которое должно индексироваться */\n"
"    Datum       leafDatum;      /* текущее значение, которое должно сохраниться в листе */\n"
"    int         level;          /* текущий уровень (начиная с нуля) */\n"
"\n"
"    /* Данные из текущего внутреннего кортежа */\n"
"    bool        allTheSame;     /* кортеж с признаком все-равны? */\n"
"    bool        hasPrefix;      /* у кортежа есть префикс? */\n"
"    Datum       prefixDatum;    /* если да, то это значение префикса */\n"
"    int         nNodes;         /* число узлов во внутреннем кортеже */\n"
"    Datum      *nodeLabels;     /* значения меток узлов (NULL, если их нет) */\n"
"} spgChooseIn;\n"
"\n"
"typedef enum spgChooseResultType\n"
"{\n"
"    spgMatchNode = 1,           /* спуститься в существующий узел */\n"
"    spgAddNode,                 /* добавить узел во внутренний кортеж */\n"
"    spgSplitTuple               /* разделить внутренний кортеж (изменить его префикс) */\n"
"} spgChooseResultType;\n"
"\n"
"typedef struct spgChooseOut\n"
"{\n"
"    spgChooseResultType resultType;     /* код действия, см. выше */\n"
"    union\n"
"    {\n"
"        struct                  /* результаты для spgMatchNode */\n"
"        {\n"
"            int         nodeN;      /* спуститься к этому узлу (нумерация с 0) */\n"
"            int         levelAdd;   /* шаг увеличения уровня */\n"
"            Datum       restDatum;  /* новое значение листа */\n"
"        }           matchNode;\n"
"        struct                  /* результаты для spgAddNode */\n"
"        {\n"
"            Datum       nodeLabel;  /* метка нового узла */\n"
"            int         nodeN;      /* куда вставлять её (нумерация с 0) */\n"
"        }           addNode;\n"
"        struct                  /* результаты для spgSplitTuple */\n"
"        {\n"
"            /* Информация для формирования нового внутреннего кортежа с одним узлом */\n"
"            bool        prefixHasPrefix;    /* кортеж должен иметь префикс? */\n"
"            Datum       prefixPrefixDatum;  /* если да, его значение */\n"
"            Datum       nodeLabel;          /* метка узла */\n"
"\n"
"            /* Информация для формирования нового внутреннего кортежа нижнего уровня со всеми старыми узлами */\n"
"            bool        postfixHasPrefix;   /* кортеж должен иметь префикс? */\n"
"            Datum       postfixPrefixDatum; /* если да, его значение */\n"
"        }           splitTuple;\n"
"    }           result;\n"
"} spgChooseOut;"

#. +> REL9_6_3 REL9_6
#: spgist.xml:419(para)
msgid ""
"If the new value is inconsistent with the tuple prefix, set "
"<structfield>resultType</structfield> to <literal>spgSplitTuple</literal>. "
"This action moves all the existing nodes into a new lower-level inner tuple, "
"and replaces the existing inner tuple with a tuple having a single node that "
"links to the new lower-level inner tuple. Set <structfield>prefixHasPrefix</"
"structfield> to indicate whether the new upper tuple should have a prefix, "
"and if so set <structfield>prefixPrefixDatum</structfield> to the prefix "
"value. This new prefix value must be sufficiently less restrictive than the "
"original to accept the new value to be indexed, and it should be no longer "
"than the original prefix. Set <structfield>nodeLabel</structfield> to the "
"label to be used for the node that will point to the new lower-level inner "
"tuple. Set <structfield>postfixHasPrefix</structfield> to indicate whether "
"the new lower-level inner tuple should have a prefix, and if so set "
"<structfield>postfixPrefixDatum</structfield> to the prefix value. The "
"combination of these two prefixes and the additional label must have the "
"same meaning as the original prefix, because there is no opportunity to "
"alter the node labels that are moved to the new lower-level tuple, nor to "
"change any child index entries. After the node has been split, the "
"<function>choose</function> function will be called again with the "
"replacement inner tuple. That call will usually result in an "
"<literal>spgAddNode</literal> result, since presumably the node label added "
"in the split step will not match the new value; so after that, there will be "
"a third call that finally returns <literal>spgMatchNode</literal> and allows "
"the insertion to descend to the leaf level."
msgstr ""
"Если новое значение не согласуется с префиксом кортежа, установите в "
"<structfield>resultType</structfield> значение <literal>spgSplitTuple</"
"literal>. Это действие приводит к перемещению всех существующих узлов в "
"новый внутренний кортеж нижнего уровня и замене существующего внутреннего "
"кортежа кортежем с одним узлом, указывающим на добавленный кортеж под ним. "
"Установите признак <structfield>prefixHasPrefix</structfield>, чтобы "
"указать, должен ли новый верхний кортеж иметь префикс, и если да, задайте в "
"<structfield>prefixPrefixDatum</structfield> значение префикса. Это новое "
"значение префикса должно быть в достаточной степени менее ограничивающим, "
"чем исходное, чтобы было принято новое значение, и оно должно быть не "
"длиннее исходного префикса. Установите в <structfield>nodeLabel</"
"structfield> метку, которая будет назначена узлу, указывающему на новый "
"внутренний кортеж нижнего уровня. Установите признак "
"<structfield>postfixHasPrefix</structfield>, чтобы указать, должен ли новый "
"нижний кортеж иметь префикс, и если да, задайте в "
"<structfield>postfixPrefixDatum</structfield> значение префикса. Сочетание "
"этих двух префиксов и дополнительной метки должно иметь то же значение, что "
"и исходный префикс, так как нет возможности ни изменить метку узлов, "
"перемещённых в новый кортеж нижнего уровня, ни изменить записи дочерних "
"узлов. После того, как узел разделён, функция <function>choose</function> "
"будет вызвана снова с заменяемым внутренним кортежем. Этот вызов обычно "
"должен возвратить результат <literal>spgAddNode</literal>, так как метка "
"узла, добавленная на этапе разделения, предположительно не будет "
"соответствовать новому значению; так что за этим последует третий вызов, "
"который наконец вернёт <literal>spgMatchNode</literal> и позволит операции "
"добавления перейти к уровню листьев."

#. +> REL9_6_3 REL9_6
#: spgist.xml:675(programlisting)
#, no-wrap
msgid ""
"typedef struct spgLeafConsistentIn\n"
"{\n"
"    ScanKey     scankeys;       /* array of operators and comparison values */\n"
"    int         nkeys;          /* length of array */\n"
"\n"
"    void       *traversalValue; /* opclass-specific traverse value */\n"
"    Datum       reconstructedValue;     /* value reconstructed at parent */\n"
"    int         level;          /* current level (counting from zero) */\n"
"    bool        returnData;     /* original data must be returned? */\n"
"\n"
"    Datum       leafDatum;      /* datum in leaf tuple */\n"
"} spgLeafConsistentIn;\n"
"\n"
"typedef struct spgLeafConsistentOut\n"
"{\n"
"    Datum       leafValue;      /* reconstructed original data, if any */\n"
"    bool        recheck;        /* set true if operator must be rechecked */\n"
"} spgLeafConsistentOut;"
msgstr ""
"typedef struct spgLeafConsistentIn\n"
"{\n"
"    ScanKey     scankeys;       /* массив операторов и искомых значений */\n"
"    int         nkeys;          /* длина массива */\n"
"\n"
"    void       *traversalValue; /* переходящее значение, специфичное для класса операторов */\n"
"    Datum       reconstructedValue;     /* значение, восстановленное для родителя */\n"
"    int         level;          /* текущий уровень (отсчитывая от нуля) */\n"
"    bool        returnData;     /* нужно ли возвращать исходные данные? */\n"
"\n"
"    Datum       leafDatum;      /* значение в кортеже листа */\n"
"} spgLeafConsistentIn;\n"
"\n"
"typedef struct spgLeafConsistentOut\n"
"{\n"
"    Datum       leafValue;      /* восстановленные исходные данные, при наличии */\n"
"    bool        recheck;        /* true, если оператор нужно перепроверить */\n"
"} spgLeafConsistentOut;"

#. +> REL9_6_3 REL9_6
#: spgist.xml:818(para)
msgid ""
"When working with an inner tuple having unlabeled nodes, it is an error for "
"<function>choose</function> to return <literal>spgAddNode</literal>, since "
"the set of nodes is supposed to be fixed in such cases. Also, there is no "
"provision for generating an unlabeled node in <literal>spgSplitTuple</"
"literal> actions, since it is expected that an <literal>spgAddNode</literal> "
"action will be needed as well."
msgstr ""
"Когда внутренний кортеж содержит узлы без меток, функция <function>choose</"
"function> не может выбрать действие <literal>spgAddNode</literal>, так как в "
"этом случае предполагается, что набор узлов фиксированный. Также нельзя "
"сгенерировать узел без метки в действиях <literal>spgSplitTuple</literal>, "
"потому что, как ожидается, при этом потребуется действие "
"<literal>spgAddNode</literal>."
