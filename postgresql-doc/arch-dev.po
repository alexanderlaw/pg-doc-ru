# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:31+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: arch-dev.xml:5(title)
msgid "Overview of PostgreSQL Internals"
msgstr "Обзор внутреннего устройства PostgreSQL"

#: arch-dev.xml:8(title)
msgid "Author"
msgstr "Автор"

#: arch-dev.xml:9(para)
msgid ""
"This chapter originated as part of <xref linkend=\"sim98\"/>, Stefan "
"Simkovics' Master's Thesis prepared at Vienna University of Technology under "
"the direction of O.Univ.Prof.Dr. Georg Gottlob and Univ.Ass. Mag. Katrin "
"Seyr."
msgstr ""
"Основой этой главы послужил материал дипломной работы <xref linkend="
"\"sim98\"/>, написанной Стефаном Симковичем (Stefan Simkovics) в Венском "
"техническом университете под руководством профессора Георга Готлоба (Georg "
"Gottlob) и его ассистентки Катрин Сейр (Katrin Seyr)."

#: arch-dev.xml:17(para)
msgid ""
"This chapter gives an overview of the internal structure of the backend of "
"<productname>PostgreSQL</productname>. After having read the following "
"sections you should have an idea of how a query is processed. This chapter "
"does not aim to provide a detailed description of the internal operation of "
"<productname>PostgreSQL</productname>, as such a document would be very "
"extensive. Rather, this chapter is intended to help the reader understand "
"the general sequence of operations that occur within the backend from the "
"point at which a query is received, to the point at which the results are "
"returned to the client."
msgstr ""
"В этой главе даётся обзор внутренней организации сервера "
"<productname>PostgreSQL</productname>. Прочитав следующие разделы, вы "
"получите представление о том, как обрабатывается запрос. Здесь мы не "
"стремились подробно описывать внутренние операции <productname>PostgreSQL</"
"productname>, так как это заняло бы слишком большой объём. Основная цель "
"этой главы другая — помочь читателю понять общую последовательность "
"действий, выполняемых сервером с момента получения запроса до момента выдачи "
"результатов клиенту."

#: arch-dev.xml:31(title)
msgid "The Path of a Query"
msgstr "Путь запроса"

#: arch-dev.xml:33(para)
msgid ""
"Here we give a short overview of the stages a query has to pass in order to "
"obtain a result."
msgstr ""
"Ниже мы кратко опишем этапы, которые проходит запрос для получения "
"результата."

#: arch-dev.xml:40(para)
msgid ""
"A connection from an application program to the <productname>PostgreSQL</"
"productname> server has to be established. The application program transmits "
"a query to the server and waits to receive the results sent back by the "
"server."
msgstr ""
"Прикладная программа устанавливает подключение к серверу "
"<productname>PostgreSQL</productname>. Эта программа передаёт запрос на "
"сервер и ждёт от него результатов."

#: arch-dev.xml:49(para)
msgid ""
"The <firstterm>parser stage</firstterm> checks the query transmitted by the "
"application program for correct syntax and creates a <firstterm>query tree</"
"firstterm>."
msgstr ""
"На <firstterm>этапе разбора запроса</firstterm> сервер выполняет "
"синтаксическую проверку запроса, переданного прикладной программой, и "
"создаёт <firstterm>дерево запроса</firstterm>."

#: arch-dev.xml:58(para)
msgid ""
"The <firstterm>rewrite system</firstterm> takes the query tree created by "
"the parser stage and looks for any <firstterm>rules</firstterm> (stored in "
"the <firstterm>system catalogs</firstterm>) to apply to the query tree. It "
"performs the transformations given in the <firstterm>rule bodies</firstterm>."
msgstr ""
"<firstterm>Система правил</firstterm> принимает дерево запроса, созданное на "
"стадии разбора, и ищет в <firstterm>системных каталогах</firstterm> "
"<firstterm>правила</firstterm> для применения к этому дереву. Обнаружив "
"подходящие правила, она выполняет преобразования, заданные в <firstterm>теле "
"правил</firstterm>."

#: arch-dev.xml:67(para)
msgid ""
"One application of the rewrite system is in the realization of "
"<firstterm>views</firstterm>. Whenever a query against a view (i.e., a "
"<firstterm>virtual table</firstterm>) is made, the rewrite system rewrites "
"the user's query to a query that accesses the <firstterm>base tables</"
"firstterm> given in the <firstterm>view definition</firstterm> instead."
msgstr ""
"Одно из применений системы правил заключается в реализации "
"<firstterm>представлений</firstterm>. Когда выполняется запрос к "
"представлению (т. е. <firstterm>виртуальной таблице</firstterm>), система "
"правил преобразует запрос пользователя в запрос, обращающийся не к "
"представлению, а к <firstterm>базовым таблицам</firstterm> из "
"<firstterm>определения представления</firstterm>."

#: arch-dev.xml:79(para)
msgid ""
"The <firstterm>planner/optimizer</firstterm> takes the (rewritten) query "
"tree and creates a <firstterm>query plan</firstterm> that will be the input "
"to the <firstterm>executor</firstterm>."
msgstr ""
"<firstterm>Планировщик/оптимизатор</firstterm> принимает дерево запроса "
"(возможно, переписанное) и создаёт <firstterm>план запроса</firstterm>, "
"который будет передан <firstterm>исполнителю</firstterm>."

#: arch-dev.xml:86(para)
msgid ""
"It does so by first creating all possible <firstterm>paths</firstterm> "
"leading to the same result. For example if there is an index on a relation "
"to be scanned, there are two paths for the scan. One possibility is a simple "
"sequential scan and the other possibility is to use the index. Next the cost "
"for the execution of each path is estimated and the cheapest path is chosen. "
"The cheapest path is expanded into a complete plan that the executor can use."
msgstr ""
"Он выбирает план, сначала рассматривая все возможные варианты получения "
"одного и того же результата. Например, если для обрабатываемого отношения "
"создан индекс, прочитать отношение можно двумя способами. Во-первых, можно "
"выполнить простое последовательное сканирование, а во-вторых, можно "
"использовать индекс. Затем оценивается стоимость каждого варианта и "
"выбирается самый дешёвый. Затем выбранный вариант разворачивается в "
"полноценный план, который сможет использовать исполнитель."

#: arch-dev.xml:98(para)
msgid ""
"The executor recursively steps through the <firstterm>plan tree</firstterm> "
"and retrieves rows in the way represented by the plan. The executor makes "
"use of the <firstterm>storage system</firstterm> while scanning relations, "
"performs <firstterm>sorts</firstterm> and <firstterm>joins</firstterm>, "
"evaluates <firstterm>qualifications</firstterm> and finally hands back the "
"rows derived."
msgstr ""
"Исполнитель рекурсивно проходит по <firstterm>дереву плана</firstterm> и "
"получает строки тем способом, который указан в плане. Он сканирует "
"отношения, обращаясь к <firstterm>системе хранения</firstterm>, выполняет "
"<firstterm>сортировку</firstterm> и <firstterm>соединения</firstterm>, "
"вычисляет <firstterm>условия фильтра</firstterm> и, наконец, возвращает "
"полученные строки."

#: arch-dev.xml:110(para)
msgid ""
"In the following sections we will cover each of the above listed items in "
"more detail to give a better understanding of <productname>PostgreSQL</"
"productname>'s internal control and data structures."
msgstr ""
"В следующих разделах мы более подробно рассмотрим каждый из этих этапов, "
"чтобы дать представление о внутренних механизмах и структурах данных "
"<productname>PostgreSQL</productname>."

#: arch-dev.xml:118(title)
msgid "How Connections are Established"
msgstr "Как устанавливаются соединения"

#: arch-dev.xml:120(para)
msgid ""
"<productname>PostgreSQL</productname> is implemented using a simple "
"<quote>process per user</quote> client/server model. In this model there is "
"one <firstterm>client process</firstterm> connected to exactly one "
"<firstterm>server process</firstterm>. As we do not know ahead of time how "
"many connections will be made, we have to use a <firstterm>master process</"
"firstterm> that spawns a new server process every time a connection is "
"requested. This master process is called <literal>postgres</literal> and "
"listens at a specified TCP/IP port for incoming connections. Whenever a "
"request for a connection is detected the <literal>postgres</literal> process "
"spawns a new server process. The server tasks communicate with each other "
"using <firstterm>semaphores</firstterm> and <firstterm>shared memory</"
"firstterm> to ensure data integrity throughout concurrent data access."
msgstr ""
"<productname>PostgreSQL</productname> реализует простую клиент-серверную "
"модель по схеме <quote>процесс для пользователя</quote>. В такой схеме один "
"<firstterm>клиентский процесс</firstterm> подключается к одному отдельному "
"<firstterm>серверному процессу</firstterm>. Так как мы не знаем заранее, "
"сколько подключений будет, нам нужен <firstterm>главный процесс</firstterm>, "
"который будет запускать новый процесс при каждом запросе подключения. "
"Главный процесс называется <literal>postgres</literal> и принимает входящие "
"подключения в заданном порту TCP/IP. Получив запрос на подключение, процесс "
"<literal>postgres</literal> порождает новый серверный процесс. Серверные "
"задачи взаимодействуют между собой через <firstterm>семафоры</firstterm> и "
"<firstterm>разделяемую память</firstterm>, чтобы обеспечить целостность "
"данных при одновременном обращении к ним."

#: arch-dev.xml:137(para)
msgid ""
"The client process can be any program that understands the "
"<productname>PostgreSQL</productname> protocol described in <xref linkend="
"\"protocol\"/>. Many clients are based on the C-language library "
"<application>libpq</application>, but several independent implementations of "
"the protocol exist, such as the Java <application>JDBC</application> driver."
msgstr ""
"Клиентским процессом может быть любая программа, которая понимает протокол "
"<productname>PostgreSQL</productname>, описанный в <xref remap=\"6\" linkend="
"\"protocol\"/>. Многие клиенты базируются на библиотеке <application>libpq</"
"application> для языка C, но есть и другие независимые реализации этого "
"протокола, например, драйвер <application>JDBC</application> для Java."

#: arch-dev.xml:146(para)
msgid ""
"Once a connection is established the client process can send a query to the "
"<firstterm>backend</firstterm> (server). The query is transmitted using "
"plain text, i.e., there is no parsing done in the <firstterm>frontend</"
"firstterm> (client). The server parses the query, creates an "
"<firstterm>execution plan</firstterm>, executes the plan and returns the "
"retrieved rows to the client by transmitting them over the established "
"connection."
msgstr ""
"Установив подключение, клиентский процесс может передать запрос серверу. "
"Запрос передаётся в обычном текстовом виде, клиент не занимается его "
"анализом. Сервер разбирает запрос, строит <firstterm>план выполнения</"
"firstterm>, выполняет его и возвращает полученные строки клиенту, передавая "
"их через установленное подключение."

#: arch-dev.xml:157(title)
msgid "The Parser Stage"
msgstr "Этап разбора"

#: arch-dev.xml:164(para)
msgid ""
"The <firstterm>parser</firstterm> defined in <filename>gram.y</filename> and "
"<filename>scan.l</filename> is built using the Unix tools "
"<application>bison</application> and <application>flex</application>."
msgstr ""
"<firstterm>Разбор</firstterm>, алгоритм которого описан в <filename>gram.y</"
"filename> и <filename>scan.l</filename>, а программный код генерируется "
"инструментами Unix <application>bison</application> и <application>flex</"
"application>."

#: arch-dev.xml:172(para)
msgid ""
"The <firstterm>transformation process</firstterm> does modifications and "
"augmentations to the data structures returned by the parser."
msgstr ""
"<firstterm>Преобразование</firstterm>, в процессе которого модифицируются и "
"дополняются структуры данных, полученные после разбора запроса."

#: arch-dev.xml:159(para)
msgid ""
"The <firstterm>parser stage</firstterm> consists of two parts: "
"<placeholder-1/>"
msgstr ""
"<firstterm>Этап разбора</firstterm> разделяется на две части: <placeholder-1/"
">"

#: arch-dev.xml:181(title)
msgid "Parser"
msgstr "Разбор"

#: arch-dev.xml:183(para)
msgid ""
"The parser has to check the query string (which arrives as plain text) for "
"valid syntax. If the syntax is correct a <firstterm>parse tree</firstterm> "
"is built up and handed back; otherwise an error is returned. The parser and "
"lexer are implemented using the well-known Unix tools <application>bison</"
"application> and <application>flex</application>."
msgstr ""
"При разборе проверяется сначала синтаксис строки запроса (поступающей в виде "
"неструктурированного текста). Если он правильный, строится <firstterm>дерево "
"запроса</firstterm> и передаётся дальше, в противном случае возвращается "
"ошибка. Лексический и синтаксический анализ реализован с применением хорошо "
"известных средств Unix <application>bison</application> и <application>flex</"
"application>."

#: arch-dev.xml:192(para)
msgid ""
"The <firstterm>lexer</firstterm> is defined in the file <filename>scan.l</"
"filename> and is responsible for recognizing <firstterm>identifiers</"
"firstterm>, the <firstterm>SQL key words</firstterm> etc. For every key word "
"or identifier that is found, a <firstterm>token</firstterm> is generated and "
"handed to the parser."
msgstr ""
"<firstterm>Лексическая структура</firstterm> определяется в файле "
"<filename>scan.l</filename> и описывает <firstterm>идентификаторы</"
"firstterm>, <firstterm>ключевые слова SQL</firstterm> и т. д. Для каждого "
"найденного ключевого слова или идентификатора генерируется <firstterm>символ "
"языка</firstterm>, который затем передаётся синтаксическому анализатору."

#: arch-dev.xml:201(para)
msgid ""
"The parser is defined in the file <filename>gram.y</filename> and consists "
"of a set of <firstterm>grammar rules</firstterm> and <firstterm>actions</"
"firstterm> that are executed whenever a rule is fired. The code of the "
"actions (which is actually C code) is used to build up the parse tree."
msgstr ""
"Синтаксис языка определён в файле <filename>gram.y</filename> в виде набора "
"<firstterm>грамматических правил</firstterm> и <firstterm>действий</"
"firstterm>, которые должны выполняться при срабатывании правил. Для "
"построения дерева разбора используется код действий (это действительно код "
"на C)."

#: arch-dev.xml:221(para)
msgid ""
"The mentioned transformations and compilations are normally done "
"automatically using the <firstterm>makefiles</firstterm> shipped with the "
"<productname>PostgreSQL</productname> source distribution."
msgstr ""
"Упомянутые преобразования и компиляция обычно производятся автоматически "
"сборочными файлами <firstterm>Makefile</firstterm>, поставляемыми в составе "
"дистрибутива <productname>PostgreSQL</productname>."

#: arch-dev.xml:209(para)
msgid ""
"The file <filename>scan.l</filename> is transformed to the C source file "
"<filename>scan.c</filename> using the program <application>flex</"
"application> and <filename>gram.y</filename> is transformed to "
"<filename>gram.c</filename> using <application>bison</application>. After "
"these transformations have taken place a normal C compiler can be used to "
"create the parser. Never make any changes to the generated C files as they "
"will be overwritten the next time <application>flex</application> or "
"<application>bison</application> is called. <placeholder-1/>"
msgstr ""
"Файл <filename>scan.l</filename> преобразуется в программу на C "
"<filename>scan.c</filename> с помощью <application>flex</application>, а "
"<filename>gram.y</filename> — в <filename>gram.c</filename> с помощью "
"<application>bison</application>. После этих преобразований исполняемый код "
"анализатора создаётся обычным компилятором C. Никогда не вносите коррективы "
"в сгенерированные файлы C, так как они будут перезаписаны при следующем "
"вызове <application>flex</application> или <application>bison</application>. "
"<placeholder-1/>"

#: arch-dev.xml:230(para)
msgid ""
"A detailed description of <application>bison</application> or the grammar "
"rules given in <filename>gram.y</filename> would be beyond the scope of this "
"paper. There are many books and documents dealing with <application>flex</"
"application> and <application>bison</application>. You should be familiar "
"with <application>bison</application> before you start to study the grammar "
"given in <filename>gram.y</filename> otherwise you won't understand what "
"happens there."
msgstr ""
"Подробное описание <application>bison</application> и грамматических правил "
"в <filename>gram.y</filename> выходит за рамки данной главы. Узнать больше о "
"<application>flex</application> и <application>bison</application> можно из "
"книг и документации. Изучение грамматики, описанной в <filename>gram.y</"
"filename>, следует начать со знакомства с <application>bison</application>, "
"иначе будет трудно понять, что там происходит."

#: arch-dev.xml:244(title)
msgid "Transformation Process"
msgstr "Преобразование"

#: arch-dev.xml:246(para)
msgid ""
"The parser stage creates a parse tree using only fixed rules about the "
"syntactic structure of SQL. It does not make any lookups in the system "
"catalogs, so there is no possibility to understand the detailed semantics of "
"the requested operations. After the parser completes, the "
"<firstterm>transformation process</firstterm> takes the tree handed back by "
"the parser as input and does the semantic interpretation needed to "
"understand which tables, functions, and operators are referenced by the "
"query. The data structure that is built to represent this information is "
"called the <firstterm>query tree</firstterm>."
msgstr ""
"На этой стадии дерево разбора создаётся только с фиксированными знаниями о "
"синтаксической структуре SQL. При его создании не просматриваются системные "
"каталоги, что не даёт возможность понять конкретную семантику запрошенной "
"операции. После этого выполняется <firstterm>процедура преобразования</"
"firstterm>, которая принимает дерево разбора от анализатора и выполняет "
"семантический анализ, необходимый для понимания, к каким именно таблицам, "
"функциям и операторам обращается запрос. Структура данных, которая создаётся "
"для представления этой информации, называется <firstterm>деревом запроса</"
"firstterm>."

#: arch-dev.xml:258(para)
msgid ""
"The reason for separating raw parsing from semantic analysis is that system "
"catalog lookups can only be done within a transaction, and we do not wish to "
"start a transaction immediately upon receiving a query string. The raw "
"parsing stage is sufficient to identify the transaction control commands "
"(<command>BEGIN</command>, <command>ROLLBACK</command>, etc), and these can "
"then be correctly executed without any further analysis. Once we know that "
"we are dealing with an actual query (such as <command>SELECT</command> or "
"<command>UPDATE</command>), it is okay to start a transaction if we're not "
"already in one. Only then can the transformation process be invoked."
msgstr ""
"Синтетический разбор отделён от семантического анализа, потому что "
"обращаться к системным каталогам можно только внутри транзакции, а начинать "
"транзакцию сразу после получения строки с запросом нежелательно. "
"Синтетического разбора достаточно, чтобы распознать команды управления "
"транзакциями (<command>BEGIN</command>, <command>ROLLBACK</command> и т. "
"д.), поэтому их можно выполнить без дальнейшего анализа. Убедившись, что мы "
"имеем дело с собственно запросом (например, <command>SELECT</command> или "
"<command>UPDATE</command>), можно начинать транзакцию, если она ещё не "
"начата. Только после этого можно переходить к процедуре преобразования."

#: arch-dev.xml:271(para)
msgid ""
"The query tree created by the transformation process is structurally similar "
"to the raw parse tree in most places, but it has many differences in detail. "
"For example, a <structname>FuncCall</structname> node in the parse tree "
"represents something that looks syntactically like a function call. This "
"might be transformed to either a <structname>FuncExpr</structname> or "
"<structname>Aggref</structname> node depending on whether the referenced "
"name turns out to be an ordinary function or an aggregate function. Also, "
"information about the actual data types of columns and expression results is "
"added to the query tree."
msgstr ""
"Дерево запроса, создаваемое процедурой преобразования, по структуре во "
"многом похоже на дерево разбора, но отличается во многих деталях. Например, "
"узел <structname>FuncCall</structname> в дереве разбора представляет то, что "
"по синтаксису похоже на вызов функции. Этот узел может быть преобразован в "
"узел <structname>FuncExpr</structname> или <structname>Aggref</structname> в "
"зависимости от того, какой (обычной или агрегатной) окажется функция с "
"заданным именем. Кроме того, в дерево запроса добавляется информация о "
"фактических типах данных столбцов и результатов выражений."

#: arch-dev.xml:286(title)
msgid "The <productname>PostgreSQL</productname> Rule System"
msgstr "Система правил <productname>PostgreSQL</productname>"

#: arch-dev.xml:297(para)
msgid ""
"The first one worked using <firstterm>row level</firstterm> processing and "
"was implemented deep in the <firstterm>executor</firstterm>. The rule system "
"was called whenever an individual row had been accessed. This implementation "
"was removed in 1995 when the last official release of the "
"<productname>Berkeley Postgres</productname> project was transformed into "
"<productname>Postgres95</productname>."
msgstr ""
"Первый вариант производил обработку на <firstterm>уровне строк</firstterm> и "
"был внедрён глубоко в <firstterm>исполнителе</firstterm>. Этот обработчик "
"правил вызывался при обращении к каждой отдельной строке. Эта реализация "
"была ликвидирована в 1995 г., когда последний официальный выпуск "
"<productname>Berkeley Postgres</productname> превратился в "
"<productname>Postgres95</productname>."

#: arch-dev.xml:308(para)
msgid ""
"The second implementation of the rule system is a technique called "
"<firstterm>query rewriting</firstterm>. The <firstterm>rewrite system</"
"firstterm> is a module that exists between the <firstterm>parser stage</"
"firstterm> and the <firstterm>planner/optimizer</firstterm>. This technique "
"is still implemented."
msgstr ""
"Во втором воплощении системы правил применили так называемое "
"<firstterm>переписывание запроса</firstterm>. <firstterm>Система "
"переписывания</firstterm> реализована в механизме, внедрённом между "
"<firstterm>анализатором</firstterm> и <firstterm>планировщиком/"
"оптимизатором</firstterm>. Этот механизм работает и сегодня."

#: arch-dev.xml:288(para)
msgid ""
"<productname>PostgreSQL</productname> supports a powerful <firstterm>rule "
"system</firstterm> for the specification of <firstterm>views</firstterm> and "
"ambiguous <firstterm>view updates</firstterm>. Originally the "
"<productname>PostgreSQL</productname> rule system consisted of two "
"implementations: <placeholder-1/>"
msgstr ""
"<productname>PostgreSQL</productname> поддерживает мощную <firstterm>систему "
"правил</firstterm> для создания <firstterm>представлений</firstterm> и "
"возможности <firstterm>изменения представлений</firstterm>. Система правил "
"<productname>PostgreSQL</productname> претерпела две реализации: "
"<placeholder-1/>"

#: arch-dev.xml:319(para)
msgid ""
"The query rewriter is discussed in some detail in <xref linkend=\"rules\"/>, "
"so there is no need to cover it here. We will only point out that both the "
"input and the output of the rewriter are query trees, that is, there is no "
"change in the representation or level of semantic detail in the trees. "
"Rewriting can be thought of as a form of macro expansion."
msgstr ""
"Механизм переписывания запросов подробно обсуждается в <xref remap=\"6\" "
"linkend=\"rules\"/>, так что здесь мы его не рассматриваем. Мы только "
"отметим, что и на входе, и на выходе у него деревья запросов, то есть "
"представление или уровень семантической детализации он не меняет. "
"Переписывание запроса можно считать формой расширения макросов."

#: arch-dev.xml:331(title)
msgid "Planner/Optimizer"
msgstr "Планировщик/оптимизатор"

#: arch-dev.xml:333(para)
msgid ""
"The task of the <firstterm>planner/optimizer</firstterm> is to create an "
"optimal execution plan. A given SQL query (and hence, a query tree) can be "
"actually executed in a wide variety of different ways, each of which will "
"produce the same set of results. If it is computationally feasible, the "
"query optimizer will examine each of these possible execution plans, "
"ultimately selecting the execution plan that is expected to run the fastest."
msgstr ""
"Задача <firstterm>планировщика/оптимизатора</firstterm> — построить "
"наилучший план выполнения. Определённый SQL-запрос (а значит, и дерево "
"запроса) на самом деле можно выполнить самыми разными способами, при этом "
"получая одни и те же результаты. Если это не требует больших вычислений, "
"оптимизатор запросов будет перебирать все возможные варианты планов, чтобы в "
"итоге выбрать тот, который должен выполниться быстрее остальных."

#: arch-dev.xml:344(para)
msgid ""
"In some situations, examining each possible way in which a query can be "
"executed would take an excessive amount of time and memory space. In "
"particular, this occurs when executing queries involving large numbers of "
"join operations. In order to determine a reasonable (not necessarily "
"optimal) query plan in a reasonable amount of time, <productname>PostgreSQL</"
"productname> uses a <firstterm>Genetic Query Optimizer</firstterm> (see "
"<xref linkend=\"geqo\"/>) when the number of joins exceeds a threshold (see "
"<xref linkend=\"guc-geqo-threshold\"/>)."
msgstr ""
"В некоторых ситуациях рассмотрение всех возможных вариантов выполнения "
"запросов занимает слишком много времени и памяти. В частности, это имеет "
"место при выполнении запросов с большим количеством операций соединения. "
"Поэтому, чтобы выбрать разумный (но не обязательно наилучший) план запроса "
"за приемлемое время, <productname>PostgreSQL</productname> использует "
"<firstterm>генетический оптимизатор запросов</firstterm> (см. <xref remap="
"\"4\" linkend=\"geqo\"/>), когда количество соединений превышает некоторый "
"предел (см. <xref remap=\"4\" linkend=\"guc-geqo-threshold\"/>)."

#: arch-dev.xml:356(para)
msgid ""
"The planner's search procedure actually works with data structures called "
"<firstterm>paths</firstterm>, which are simply cut-down representations of "
"plans containing only as much information as the planner needs to make its "
"decisions. After the cheapest path is determined, a full-fledged "
"<firstterm>plan tree</firstterm> is built to pass to the executor. This "
"represents the desired execution plan in sufficient detail for the executor "
"to run it. In the rest of this section we'll ignore the distinction between "
"paths and plans."
msgstr ""
"Процедура поиска лучшего плана на самом деле работает со структурами данных, "
"называемыми <firstterm>путями</firstterm>, которые представляют собой "
"упрощённые схемы планов, содержащие минимум информации, необходимый "
"планировщику для принятия решений. Когда наиболее выгодный план выбран, "
"строится полноценное <firstterm>дерево плана</firstterm>, которое и "
"передаётся исполнителю. Оно описывает желаемый план выполнения достаточно "
"подробно, чтобы исполнитель мог обработать его. В продолжении этого раздела "
"мы будем считать, что планы и пути по сути одно и то же."

#: arch-dev.xml:368(title)
msgid "Generating Possible Plans"
msgstr "Выработка возможных планов"

#: arch-dev.xml:370(para)
msgid ""
"The planner/optimizer starts by generating plans for scanning each "
"individual relation (table) used in the query. The possible plans are "
"determined by the available indexes on each relation. There is always the "
"possibility of performing a sequential scan on a relation, so a sequential "
"scan plan is always created. Assume an index is defined on a relation (for "
"example a B-tree index) and a query contains the restriction "
"<literal>relation.attribute OPR constant</literal>. If <literal>relation."
"attribute</literal> happens to match the key of the B-tree index and "
"<literal>OPR</literal> is one of the operators listed in the index's "
"<firstterm>operator class</firstterm>, another plan is created using the B-"
"tree index to scan the relation. If there are further indexes present and "
"the restrictions in the query happen to match a key of an index, further "
"plans will be considered. Index scan plans are also generated for indexes "
"that have a sort ordering that can match the query's <literal>ORDER BY</"
"literal> clause (if any), or a sort ordering that might be useful for merge "
"joining (see below)."
msgstr ""
"Сначала планировщик/оптимизатор вырабатывает планы для сканирования каждого "
"отдельного отношения (таблицы), используемого в запросе. Множество возможных "
"планов определяется в зависимости от наличия индексов в каждом отношении. "
"Произвести последовательное сканирование отношения можно в любом случае, так "
"что план последовательного сканирования создаётся всегда. Предположим, что "
"для отношения создан индекс (например, индекс-B-дерево) и запрос содержит "
"ограничение <literal>отношение.атрибут ОПЕР константа</literal>. Если "
"окажется, что <literal>отношение.атрибут</literal> совпадает с ключом "
"индекса-B-дерева и <literal>ОПЕР</literal> — один из операторов, входящих в "
"<firstterm>класс операторов</firstterm> индекса, создаётся ещё один план, c "
"использованием индекса-B-дерева для чтения отношения. Если находятся другие "
"индексы, ключи которых соответствуют ограничениям запроса, могут добавиться "
"и другие планы. Планы сканирования индекса также создаются для индексов, "
"если их порядок сортировки соответствует предложению <literal>ORDER BY</"
"literal> (если оно есть), или этот порядок может быть полезен для соединения "
"слиянием (см. ниже)."

#: arch-dev.xml:399(para)
msgid ""
"<firstterm>nested loop join</firstterm>: The right relation is scanned once "
"for every row found in the left relation. This strategy is easy to implement "
"but can be very time consuming. (However, if the right relation can be "
"scanned with an index scan, this can be a good strategy. It is possible to "
"use values from the current row of the left relation as keys for the index "
"scan of the right.)"
msgstr ""
"<firstterm>соединение с вложенным циклом</firstterm>: Правое отношение "
"сканируется один раз для каждой строки, найденной в левом отношении. Эту "
"стратегию легко реализовать, но она может быть очень трудоёмкой. (Однако, "
"если правое отношение можно сканировать по индексу, эта стратегия может быть "
"удачной. Тогда значения из текущей строки левого отношения могут "
"использоваться как ключи для сканирования по индексу справа.)"

#: arch-dev.xml:410(para)
msgid ""
"<firstterm>merge join</firstterm>: Each relation is sorted on the join "
"attributes before the join starts. Then the two relations are scanned in "
"parallel, and matching rows are combined to form join rows. This kind of "
"join is more attractive because each relation has to be scanned only once. "
"The required sorting might be achieved either by an explicit sort step, or "
"by scanning the relation in the proper order using an index on the join key."
msgstr ""
"<firstterm>соединение слиянием</firstterm>: Каждое отношение сортируется по "
"атрибутам соединения до начала соединения. Затем два отношения сканируются "
"параллельно и соответствующие строки, объединяясь, формируют строки "
"соединения. Этот тип соединения более привлекательный, так как каждое "
"отношение сканируется только один раз. Требуемый порядок сортировки можно "
"получить, либо добавив явный этап сортировки, либо просканировав отношение в "
"нужном порядке, используя индекс по ключу соединения."

#: arch-dev.xml:423(para)
msgid ""
"<firstterm>hash join</firstterm>: the right relation is first scanned and "
"loaded into a hash table, using its join attributes as hash keys. Next the "
"left relation is scanned and the appropriate values of every row found are "
"used as hash keys to locate the matching rows in the table."
msgstr ""
"<firstterm>соединение по хешу</firstterm>: сначала сканируется правое "
"отношение и формируется хеш-таблица, ключ в которой вычисляется по атрибутам "
"соединения. Затем сканируется левое отношение и по тем же атрибутам в каждой "
"строке вычисляется ключ для поиска в этой хеш-таблице соответствующих строк "
"справа."

#: arch-dev.xml:391(para)
msgid ""
"If the query requires joining two or more relations, plans for joining "
"relations are considered after all feasible plans have been found for "
"scanning single relations. The three available join strategies are: "
"<placeholder-1/>"
msgstr ""
"Если в запросе требуется соединить два или несколько отношений, после того, "
"как будут определены все подходящие планы сканирования отдельных отношений, "
"рассматриваются планы соединения. При этом возможны три стратегии "
"соединения: <placeholder-1/>"

#: arch-dev.xml:434(para)
msgid ""
"When the query involves more than two relations, the final result must be "
"built up by a tree of join steps, each with two inputs. The planner examines "
"different possible join sequences to find the cheapest one."
msgstr ""
"Когда в запросе задействованы более двух отношений, окончательный результат "
"должен быть получен из дерева с узлами соединения, имеющими по два входа. "
"Планировщик рассматривает все возможные последовательности соединения и "
"выбирает самую выгодную."

# well-spelled: атр
#: arch-dev.xml:441(para)
msgid ""
"If the query uses fewer than <xref linkend=\"guc-geqo-threshold\"/> "
"relations, a near-exhaustive search is conducted to find the best join "
"sequence. The planner preferentially considers joins between any two "
"relations for which there exist a corresponding join clause in the "
"<literal>WHERE</literal> qualification (i.e., for which a restriction like "
"<literal>where rel1.attr1=rel2.attr2</literal> exists). Join pairs with no "
"join clause are considered only when there is no other choice, that is, a "
"particular relation has no available join clauses to any other relation. All "
"possible plans are generated for every join pair considered by the planner, "
"and the one that is (estimated to be) the cheapest is chosen."
msgstr ""
"Если число задействованных в запросе отношений меньше <xref linkend=\"guc-"
"geqo-threshold\"/>, для поиска оптимальной последовательности соединений "
"производится практически полный перебор. Планировщик отдаёт предпочтение "
"соединениям между двумя отношениями, для которых есть соответствующее "
"предложение соединения в условии <literal>WHERE</literal> (то есть, для "
"которых находится ограничение вида <literal>where табл1.атр1=табл2.атр2</"
"literal>). Пары соединения без подобного предложения рассматриваются, только "
"если нет другого выбора, то есть когда для определённого отношения не "
"находятся предложения соединения с каким-либо другим отношением. Планировщик "
"рассматривает все возможные планы для каждой пары соединения и выбирает "
"самый выгодный из них (по его оценке)."

#: arch-dev.xml:455(para)
msgid ""
"When <varname>geqo_threshold</varname> is exceeded, the join sequences "
"considered are determined by heuristics, as described in <xref linkend=\"geqo"
"\"/>. Otherwise the process is the same."
msgstr ""
"Если <varname>geqo_threshold</varname> превышается, последовательность "
"соединений выбирается эвристическим путём, как описано в <xref remap=\"6\" "
"linkend=\"geqo\"/>. В остальном процесс планирования тот же."

#: arch-dev.xml:461(para)
msgid ""
"The finished plan tree consists of sequential or index scans of the base "
"relations, plus nested-loop, merge, or hash join nodes as needed, plus any "
"auxiliary steps needed, such as sort nodes or aggregate-function calculation "
"nodes. Most of these plan node types have the additional ability to do "
"<firstterm>selection</firstterm> (discarding rows that do not meet a "
"specified Boolean condition) and <firstterm>projection</firstterm> "
"(computation of a derived column set based on given column values, that is, "
"evaluation of scalar expressions where needed). One of the responsibilities "
"of the planner is to attach selection conditions from the <literal>WHERE</"
"literal> clause and computation of required output expressions to the most "
"appropriate nodes of the plan tree."
msgstr ""
"Законченное дерево плана содержит узлы сканирования по индексу или "
"последовательного сканирования базовых отношений, плюс узлы соединения с "
"вложенным циклом, соединения слиянием или соединения по хешу (если "
"требуется), плюс, возможно, узлы дополнительных действий, например, "
"сортировки или вычисления агрегатных функций. Большинство из этих узлов "
"могут дополнительно производить <firstterm>отбор</firstterm> (отбрасывать "
"строки, не удовлетворяющие заданному логическому условию) и "
"<firstterm>расчёты</firstterm> (вычислять производный набор столбцов по "
"значениям заданных столбцов, то есть вычислять скалярные выражения). Одна из "
"задач планировщика — добавить условия отбора из предложения <literal>WHERE</"
"literal> и вычисления требуемых выходных выражений к наиболее подходящим "
"узлам дерева плана."

#: arch-dev.xml:480(title)
msgid "Executor"
msgstr "Исполнитель"

#: arch-dev.xml:482(para)
msgid ""
"The <firstterm>executor</firstterm> takes the plan created by the planner/"
"optimizer and recursively processes it to extract the required set of rows. "
"This is essentially a demand-pull pipeline mechanism. Each time a plan node "
"is called, it must deliver one more row, or report that it is done "
"delivering rows."
msgstr ""
"<firstterm>Исполнитель</firstterm> принимает план, созданный планировщиком/"
"исполнителем и обрабатывает его рекурсивно, чтобы получить требуемый набор "
"строк. Обработка выполняется по конвейеру, с получением данных по "
"требованию. При вызове любого узла плана он должен выдать очередную строку, "
"либо сообщить, что выдача строк завершена."

#: arch-dev.xml:490(para)
msgid ""
"To provide a concrete example, assume that the top node is a "
"<literal>MergeJoin</literal> node. Before any merge can be done two rows "
"have to be fetched (one from each subplan). So the executor recursively "
"calls itself to process the subplans (it starts with the subplan attached to "
"<literal>lefttree</literal>). The new top node (the top node of the left "
"subplan) is, let's say, a <literal>Sort</literal> node and again recursion "
"is needed to obtain an input row. The child node of the <literal>Sort</"
"literal> might be a <literal>SeqScan</literal> node, representing actual "
"reading of a table. Execution of this node causes the executor to fetch a "
"row from the table and return it up to the calling node. The <literal>Sort</"
"literal> node will repeatedly call its child to obtain all the rows to be "
"sorted. When the input is exhausted (as indicated by the child node "
"returning a NULL instead of a row), the <literal>Sort</literal> code "
"performs the sort, and finally is able to return its first output row, "
"namely the first one in sorted order. It keeps the remaining rows stored so "
"that it can deliver them in sorted order in response to later demands."
msgstr ""
"В качестве более конкретного примера, давайте предположим, что верхним узлом "
"плана оказался узел <literal>MergeJoin</literal>. Для того чтобы выполнить "
"какое-либо соединение, необходимо выбрать две строки (одну из каждого "
"вложенного плана). Поэтому исполнитель рекурсивно вызывает себя для "
"обработки вложенных планов (он начинает с плана <literal>левого дерева</"
"literal>). Новый верхний узел (верхний узел левого вложенного плана) может "
"быть, например, узлом <literal>Sort</literal>, и тогда для получения входной "
"строки снова требуется рекурсия. Дочерним узлом <literal>Sort</literal> "
"может быть узел <literal>SeqScan</literal>, представляющий собственно чтение "
"таблицы. В результате выполнения этого узла исполнитель выбирает одну строку "
"из таблицы и возвращает её вызывающему узлу. Узел <literal>Sort</literal>, в "
"свою очередь, будет продолжать вызывать дочерний узел, пока не получит все "
"строки для сортировки. Когда строки закончатся (дочерний узел сообщит об "
"этом, возвратив NULL вместо строки), узел <literal>Sort</literal> выполнит "
"сортировку, и наконец сможет выдать свою первую строку, а именно строку "
"первую по порядку сортировки. Остальные строки будут сохраняться в нём, "
"чтобы он мог выдавать их по порядку при последующих вызовах."

#: arch-dev.xml:511(para)
msgid ""
"The <literal>MergeJoin</literal> node similarly demands the first row from "
"its right subplan. Then it compares the two rows to see if they can be "
"joined; if so, it returns a join row to its caller. On the next call, or "
"immediately if it cannot join the current pair of inputs, it advances to the "
"next row of one table or the other (depending on how the comparison came "
"out), and again checks for a match. Eventually, one subplan or the other is "
"exhausted, and the <literal>MergeJoin</literal> node returns NULL to "
"indicate that no more join rows can be formed."
msgstr ""
"Узел <literal>MergeJoin</literal> подобным образом затребует первую строку и "
"у вложенного плана справа. Затем он сравнивает две строки и определяет, "
"можно ли их соединить; если да, он возвращает соединённую строки вызывающему "
"узлу. При следующем вызове, или немедленно, если он не может соединить "
"текущую пару поступивших строк, он переходит к следующей строке в одном "
"отношении или в другом (в зависимости от результата сравнения) и снова "
"проверяет соответствие. В конце концов, данные в одном или другом вложенном "
"плане заканчиваются и узел <literal>MergeJoin</literal> возвращает NULL, "
"показывая тем самым, что другие строки соединения получить нельзя."

#: arch-dev.xml:523(para)
msgid ""
"Complex queries can involve many levels of plan nodes, but the general "
"approach is the same: each node computes and returns its next output row "
"each time it is called. Each node is also responsible for applying any "
"selection or projection expressions that were assigned to it by the planner."
msgstr ""
"Сложные запросы могут содержать много уровней вложенности узлов плана, но "
"общий подход тот же: каждый узел вычисляет и возвращает следующую полученную "
"строку при очередном вызове. Каждый узел также должен производить отбор и "
"расчёты, которые были назначены ему планировщиком."

#: arch-dev.xml:531(para)
msgid ""
"The executor mechanism is used to evaluate all four basic SQL query types: "
"<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</"
"command>, and <command>DELETE</command>. For <command>SELECT</command>, the "
"top-level executor code only needs to send each row returned by the query "
"plan tree off to the client. For <command>INSERT</command>, each returned "
"row is inserted into the target table specified for the <command>INSERT</"
"command>. This is done in a special top-level plan node called "
"<literal>ModifyTable</literal>. (A simple <command>INSERT ... VALUES</"
"command> command creates a trivial plan tree consisting of a single "
"<literal>Result</literal> node, which computes just one result row, and "
"<literal>ModifyTable</literal> above it to perform the insertion. But "
"<command>INSERT ... SELECT</command> can demand the full power of the "
"executor mechanism.) For <command>UPDATE</command>, the planner arranges "
"that each computed row includes all the updated column values, plus the "
"<firstterm>TID</firstterm> (tuple ID, or row ID) of the original target row; "
"this data is fed into a <literal>ModifyTable</literal> node, which uses the "
"information to create a new updated row and mark the old row deleted. For "
"<command>DELETE</command>, the only column that is actually returned by the "
"plan is the TID, and the <literal>ModifyTable</literal> node simply uses the "
"TID to visit each target row and mark it deleted."
msgstr ""
"Механизм исполнителя применяется для обработки всех четырёх основных типов "
"SQL-запросов: <command>SELECT</command>, <command>INSERT</command>, "
"<command>UPDATE</command> и <command>DELETE</command>. С <command>SELECT</"
"command> код исполнителя верхнего уровня должен только выдать клиенту все "
"строки, полученные от дерева плана запроса. С <command>INSERT</command> все "
"полученные строки вставляются в целевую таблицу <command>INSERT</command>. "
"Эта операция выполняется в специальном узле на верхнем уровне плана запроса, "
"называемом <literal>ModifyTable</literal>. (Простая команда "
"<command>INSERT ... VALUES</command> создаёт простейшее дерево плана, "
"состоящее из одного узла <literal>Result</literal>, который вычисляет одну "
"строку результата, и узла <literal>ModifyTable</literal> над ним, который "
"осуществляет добавление. Но с <command>INSERT ... SELECT</command> могут "
"быть востребованы все возможности механизма исполнителя.) С <command>UPDATE</"
"command> планировщик делает так, чтобы каждая вычисленная строка включала "
"значения всех изменённых столбцов плюс <firstterm>TID</firstterm> (Tuple ID, "
"идентификатор кортежа) исходной целевой строки; эти данные подаются в узел "
"<literal>ModifyTable</literal>, который использует эту информацию, чтобы "
"создать новую изменённую строку и пометить старую строку как удалённую. С "
"<command>DELETE</command> план фактически возвращает только один столбец, "
"TID, а узел <literal>ModifyTable</literal> использует значение TID, чтобы "
"найти каждую целевую строку и пометить её как удалённую."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: arch-dev.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
