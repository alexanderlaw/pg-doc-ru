# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-21 15:24+0300\n"
"PO-Revision-Date: 2017-09-22 17:57+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:5(title)
msgid "Triggers"
msgstr "Триггеры"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:7(indexterm)
msgid "<primary>trigger</primary>"
msgstr "<primary>trigger</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:11(para)
msgid ""
"This chapter provides general information about writing trigger functions. "
"Trigger functions can be written in most of the available procedural "
"languages, including <application>PL/pgSQL</application> (<xref linkend="
"\"plpgsql\"/>), <application>PL/Tcl</application> (<xref linkend=\"pltcl\"/"
">), <application>PL/Perl</application> (<xref linkend=\"plperl\"/>), and "
"<application>PL/Python</application> (<xref linkend=\"plpython\"/>). After "
"reading this chapter, you should consult the chapter for your favorite "
"procedural language to find out the language-specific details of writing a "
"trigger in it."
msgstr ""
"В этой главе содержится общая информация о разработке триггерных функций. "
"Триггерные функции могут быть написаны на большинстве доступных процедурных "
"языков, включая <application>PL/pgSQL</application> (<xref linkend=\"plpgsql"
"\"/>), <application>PL/Tcl</application> (<xref linkend=\"pltcl\"/>), "
"<application>PL/Perl</application> (<xref linkend=\"plperl\"/>) и "
"<application>PL/Python</application> (<xref linkend=\"plpython\"/>). После "
"прочтения этого раздела, следует обратиться к разделу, посвящённому любимому "
"процедурному языку, чтобы узнать специфические для него детали разработки "
"триггеров."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:24(para)
msgid ""
"It is also possible to write a trigger function in C, although most people "
"find it easier to use one of the procedural languages. It is not currently "
"possible to write a trigger function in the plain SQL function language."
msgstr ""
"Триггерные функции можно писать и на C, хотя большинство людей находит, что "
"проще использовать один из процедурных языков. В настоящее время невозможно "
"написать триггерную функцию на чистом SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:32(title)
msgid "Overview of Trigger Behavior"
msgstr "Обзор механизма работы триггеров"

#. +> REL_10
#: trigger.xml:34(para)
msgid ""
"A trigger is a specification that the database should automatically execute "
"a particular function whenever a certain type of operation is performed. "
"Triggers can be attached to tables (partitioned or not), views, and foreign "
"tables."
msgstr ""
"Триггер является указанием, что база данных должна автоматически выполнить "
"заданную функцию, всякий раз когда выполнен определённый тип операции. "
"Триггеры можно использовать с таблицами (секционированными и обычными), с "
"представлениями и с внешними таблицами."

#. +> REL9_6_3 REL9_6
#: trigger.xml:34(para)
msgid ""
"A trigger is a specification that the database should automatically execute "
"a particular function whenever a certain type of operation is performed. "
"Triggers can be attached to tables, views, and foreign tables."
msgstr ""
"Триггер является указанием, что база данных должна автоматически выполнить "
"заданную функцию, всякий раз когда выполнен определённый тип операции. "
"Триггеры можно использовать с таблицами, с представлениями и с внешними "
"таблицами."

#. +> REL_10
#: trigger.xml:41(para)
msgid ""
"On tables and foreign tables, triggers can be defined to execute either "
"before or after any <command>INSERT</command>, <command>UPDATE</command>, or "
"<command>DELETE</command> operation, either once per modified row, or once "
"per <acronym>SQL</acronym> statement. <command>UPDATE</command> triggers can "
"moreover be set to fire only if certain columns are mentioned in the "
"<literal>SET</literal> clause of the <command>UPDATE</command> statement. "
"Triggers can also fire for <command>TRUNCATE</command> statements. If a "
"trigger event occurs, the trigger's function is called at the appropriate "
"time to handle the event."
msgstr ""
"Для обычных и сторонних таблиц можно определять триггеры, которые будут "
"срабатывать до или после любой из команд <command>INSERT</command>, "
"<command>UPDATE</command> или <command>DELETE</command>; либо один раз для "
"каждой модифицируемой строки, либо один раз для оператора <acronym>SQL</"
"acronym>. Триггеры на <command>UPDATE</command> можно установить так, чтобы "
"они срабатывали, только когда в предложении <literal>SET</literal> оператора "
"<command>UPDATE</command> упоминаются определённые столбцы. Также триггеры "
"могут срабатывать для операторов <command>TRUNCATE</command>. Если "
"происходит событие триггера, для обработки этого события в установленный "
"момент времени вызывается функция триггера."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:54(para)
msgid ""
"On views, triggers can be defined to execute instead of <command>INSERT</"
"command>, <command>UPDATE</command>, or <command>DELETE</command> "
"operations. <literal>INSTEAD OF</literal> triggers are fired once for each "
"row that needs to be modified in the view. It is the responsibility of the "
"trigger's function to perform the necessary modifications to the underlying "
"base tables and, where appropriate, return the modified row as it will "
"appear in the view. Triggers on views can also be defined to execute once "
"per <acronym>SQL</acronym> statement, before or after <command>INSERT</"
"command>, <command>UPDATE</command>, or <command>DELETE</command> operations."
msgstr ""
"Для представлений триггеры могут быть определены вместо команд "
"<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>. Триггеры <literal>INSTEAD OF</literal> запускаются один раз для "
"каждой строки, которую необходимо изменить в представлении. Именно "
"триггерная функция отвечает за выполнение необходимых изменений в базовых "
"таблицах и, где это уместно, возвращает изменённую строку в том виде, как "
"она будет отображаться в представлении. Триггеры на представления также "
"можно определять для срабатывания только один раз на <acronym>SQL</acronym>-"
"оператор, до или после команд <command>INSERT</command>, <command>UPDATE</"
"command> или <command>DELETE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:68(para)
msgid ""
"The trigger function must be defined before the trigger itself can be "
"created. The trigger function must be declared as a function taking no "
"arguments and returning type <literal>trigger</literal>. (The trigger "
"function receives its input through a specially-passed "
"<structname>TriggerData</structname> structure, not in the form of ordinary "
"function arguments.)"
msgstr ""
"Триггерная функция должна быть создана до триггера. Она должна быть "
"объявлена без аргументов и возвращать тип <literal>trigger</literal>. "
"(Триггерная функция получает данные на вход посредством специально "
"переданной структуры <structname>TriggerData</structname>, а не в форме "
"обычных аргументов.)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:77(para)
msgid ""
"Once a suitable trigger function has been created, the trigger is "
"established with <xref linkend=\"sql-createtrigger\"/>. The same trigger "
"function can be used for multiple triggers."
msgstr ""
"После создания триггерной функции создаётся триггер с помощью <xref linkend="
"\"sql-createtrigger\"/>. Одна и та же триггерная функция может быть "
"использована для нескольких триггеров."

#. +> REL_10
#: trigger.xml:84(para)
msgid ""
"<productname>PostgreSQL</productname> offers both <firstterm>per-row</"
"firstterm> triggers and <firstterm>per-statement</firstterm> triggers. With "
"a per-row trigger, the trigger function is invoked once for each row that is "
"affected by the statement that fired the trigger. In contrast, a per-"
"statement trigger is invoked only once when an appropriate statement is "
"executed, regardless of the number of rows affected by that statement. In "
"particular, a statement that affects zero rows will still result in the "
"execution of any applicable per-statement triggers. These two types of "
"triggers are sometimes called <firstterm>row-level</firstterm> triggers and "
"<firstterm>statement-level</firstterm> triggers, respectively. Triggers on "
"<command>TRUNCATE</command> may only be defined at statement level, not per-"
"row."
msgstr ""
"<productname>PostgreSQL</productname> предлагает как <firstterm>построчные</"
"firstterm>, так и <firstterm>операторные</firstterm> триггеры. В случае "
"построчного триггера триггерная функция вызывается один раз для каждой "
"строки, затронутой оператором, запустившим триггер. Операторный же триггер, "
"напротив, вызывается только один раз при выполнении соответствующего "
"оператора, независимо от количества строк, которые он затрагивает. В "
"частности оператор, который не затрагивает никаких строк, всё равно приведёт "
"к срабатыванию операторного триггера. Эти два типа триггеров также называют "
"триггерами <firstterm>уровня строк</firstterm> и триггерами "
"<firstterm>уровня оператора</firstterm>, соответственно. Триггеры на "
"<command>TRUNCATE</command> могут быть определены только на уровне "
"оператора, а не на уровне строк."

#. +> REL_10
#: trigger.xml:100(para)
msgid ""
"Triggers are also classified according to whether they fire "
"<firstterm>before</firstterm>, <firstterm>after</firstterm>, or "
"<firstterm>instead of</firstterm> the operation. These are referred to as "
"<literal>BEFORE</literal> triggers, <literal>AFTER</literal> triggers, and "
"<literal>INSTEAD OF</literal> triggers respectively. Statement-level "
"<literal>BEFORE</literal> triggers naturally fire before the statement "
"starts to do anything, while statement-level <literal>AFTER</literal> "
"triggers fire at the very end of the statement. These types of triggers may "
"be defined on tables, views, or foreign tables. Row-level <literal>BEFORE</"
"literal> triggers fire immediately before a particular row is operated on, "
"while row-level <literal>AFTER</literal> triggers fire at the end of the "
"statement (but before any statement-level <literal>AFTER</literal> "
"triggers). These types of triggers may only be defined on non-partitioned "
"tables and foreign tables, not views. <literal>INSTEAD OF</literal> triggers "
"may only be defined on views, and only at row level; they fire immediately "
"as each row in the view is identified as needing to be operated on."
msgstr ""
"Триггеры также классифицируются в соответствии с тем, срабатывают ли они до, "
"после или вместо операции. Они называются триггерами <literal>BEFORE</"
"literal>, <literal>AFTER</literal> и <literal>INSTEAD OF</literal>, "
"соответственно. Триггеры <literal>BEFORE</literal> уровня оператора "
"срабатывают до того, как оператор начинает делать что-либо, тогда как "
"триггеры <literal>AFTER</literal> уровня оператора срабатывают в самом конце "
"работы оператора. Эти типы триггеров могут быть определены для таблиц, "
"представлений или сторонних таблиц. Триггеры <literal>BEFORE</literal> "
"уровня строки срабатывают непосредственно перед обработкой конкретной "
"строки, в то время как триггеры <literal>AFTER</literal> уровня строки "
"срабатывают в конце работы всего оператора (но до любого из триггеров "
"<literal>AFTER</literal> уровня оператора). Эти типы триггеров могут "
"определяться только для несекционированных таблиц и сторонних таблиц, но не "
"для представлений. Триггеры <literal>INSTEAD OF</literal> могут определяться "
"только для представлений и только на уровне строк: они срабатывают для "
"каждой строки сразу после того как строка представления идентифицирована как "
"подлежащая обработке."

#. +> REL_10
#: trigger.xml:119(para)
msgid ""
"A statement that targets a parent table in an inheritance or partitioning "
"hierarchy does not cause the statement-level triggers of affected child "
"tables to be fired; only the parent table's statement-level triggers are "
"fired. However, row-level triggers of any affected child tables will be "
"fired."
msgstr ""
"Оператор, нацеленный на родительскую таблицу в иерархии наследования или "
"секционирования, не вызывает срабатывания триггеров уровня оператора для "
"задействованных дочерних таблиц; срабатывать будут только такие триггеры для "
"родительской таблицы. Однако если для этих дочерних таблиц установлены "
"триггеры уровня строк, они будут срабатывать."

#. +> REL_10
#: trigger.xml:127(para)
msgid ""
"If an <command>INSERT</command> contains an <literal>ON CONFLICT DO UPDATE</"
"literal> clause, it is possible that the effects of row-level "
"<literal>BEFORE</literal> <command>INSERT</command> triggers and row-level "
"<literal>BEFORE</literal> <command>UPDATE</command> triggers can both be "
"applied in a way that is apparent from the final state of the updated row, "
"if an <varname>EXCLUDED</varname> column is referenced. There need not be an "
"<varname>EXCLUDED</varname> column reference for both sets of row-level "
"<literal>BEFORE</literal> triggers to execute, though. The possibility of "
"surprising outcomes should be considered when there are both "
"<literal>BEFORE</literal> <command>INSERT</command> and <literal>BEFORE</"
"literal> <command>UPDATE</command> row-level triggers that change a row "
"being inserted/updated (this can be problematic even if the modifications "
"are more or less equivalent, if they're not also idempotent). Note that "
"statement-level <command>UPDATE</command> triggers are executed when "
"<literal>ON CONFLICT DO UPDATE</literal> is specified, regardless of whether "
"or not any rows were affected by the <command>UPDATE</command> (and "
"regardless of whether the alternative <command>UPDATE</command> path was "
"ever taken). An <command>INSERT</command> with an <literal>ON CONFLICT DO "
"UPDATE</literal> clause will execute statement-level <literal>BEFORE</"
"literal> <command>INSERT</command> triggers first, then statement-level "
"<literal>BEFORE</literal> <command>UPDATE</command> triggers, followed by "
"statement-level <literal>AFTER</literal> <command>UPDATE</command> triggers "
"and finally statement-level <literal>AFTER</literal> <command>INSERT</"
"command> triggers."
msgstr ""
"Если запрос <command>INSERT</command> содержит предложение <literal>ON "
"CONFLICT DO UPDATE</literal>, возможно совместное применение и триггеров "
"уровня строк <literal>BEFORE</literal> <command>INSERT</command>, и "
"триггеров уровня строк <literal>BEFORE</literal> <command>UPDATE</command>, "
"которое отразится в окончательном состоянии изменяемой строки, если в "
"запросе задействуются столбцы <varname>EXCLUDED</varname>. При этом "
"обращение к <varname>EXCLUDED</varname> не обязательно должно иметь место в "
"обоих наборах триггеров <literal>BEFORE</literal> на уровне строк. Следует "
"рассмотреть возможность получения неожиданного результата, когда имеются и "
"триггеры <literal>BEFORE</literal> <command>INSERT</command>, и "
"<literal>BEFORE</literal> <command>UPDATE</command> на уровне строки, и они "
"вместе модифицируют добавляемую/изменяемую строку (проблемы возможны, даже "
"если изменения более или менее равнозначные, но при этом не идемпотентные). "
"Заметьте, что триггеры <command>UPDATE</command> уровня оператора вызываются "
"при <literal>ON CONFLICT DO UPDATE</literal> независимо от того, будут ли "
"изменены какие-либо строки в результате <command>UPDATE</command> (и даже в "
"случае, когда альтернативный путь <command>UPDATE</command> вообще не "
"выбирается). При выполнении запроса <command>INSERT</command> с предложением "
"<literal>ON CONFLICT DO UPDATE</literal> сначала выполняются триггеры "
"<literal>BEFORE</literal> <command>INSERT</command>, затем триггеры "
"<literal>BEFORE</literal> <command>UPDATE</command>, потом триггеры "
"<literal>AFTER</literal> <command>UPDATE</command> и, наконец, "
"<literal>AFTER</literal> <command>INSERT</command> (речь идёт о триггерах на "
"уровне операторов)."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:167(para)
msgid ""
"It can return <symbol>NULL</symbol> to skip the operation for the current "
"row. This instructs the executor to not perform the row-level operation that "
"invoked the trigger (the insertion, modification, or deletion of a "
"particular table row)."
msgstr ""
"Можно вернуть <symbol>NULL</symbol>, чтобы пропустить операцию для текущей "
"строки. Это указывает исполнителю запросов, что не нужно выполнять операцию "
"со строкой вызвавшей триггер (вставку, изменение или удаление конкретной "
"строки в таблице)."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:176(para)
msgid ""
"For row-level <command>INSERT</command> and <command>UPDATE</command> "
"triggers only, the returned row becomes the row that will be inserted or "
"will replace the row being updated. This allows the trigger function to "
"modify the row being inserted or updated."
msgstr ""
"Возвращаемая строка для триггеров <command>INSERT</command> или "
"<command>UPDATE</command> будет именно той, которая будет вставлена или "
"обновлена в таблице. Это позволяет триггерной функции изменять вставляемую "
"или обновляемую строку."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:157(para)
msgid ""
"Trigger functions invoked by per-statement triggers should always return "
"<symbol>NULL</symbol>. Trigger functions invoked by per-row triggers can "
"return a table row (a value of type <structname>HeapTuple</structname>) to "
"the calling executor, if they choose. A row-level trigger fired before an "
"operation has the following choices: <placeholder-1/> A row-level "
"<literal>BEFORE</literal> trigger that does not intend to cause either of "
"these behaviors must be careful to return as its result the same row that "
"was passed in (that is, the <varname>NEW</varname> row for <command>INSERT</"
"command> and <command>UPDATE</command> triggers, the <varname>OLD</varname> "
"row for <command>DELETE</command> triggers)."
msgstr ""
"Триггерные функции, вызываемые триггерами операторов, должны всегда "
"возвращать <symbol>NULL</symbol>. Триггерные функции, вызываемые триггерами "
"строк, могут вернуть строку таблицы (значение типа <structname>HeapTuple</"
"structname>). У триггера уровня строки, срабатывающего до операции, есть "
"следующий выбор: <placeholder-1/> Если в триггере <literal>BEFORE</literal> "
"уровня строки не планируется использовать любой из этих вариантов, то нужно "
"аккуратно вернуть в качестве результата ту же строку, которая была передана "
"на вход (то есть строку <varname>NEW</varname> для триггеров "
"<command>INSERT</command> и <command>UPDATE</command>, или строку "
"<varname>OLD</varname> для триггеров <command>DELETE</command>)."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:194(para)
msgid ""
"A row-level <literal>INSTEAD OF</literal> trigger should either return "
"<symbol>NULL</symbol> to indicate that it did not modify any data from the "
"view's underlying base tables, or it should return the view row that was "
"passed in (the <varname>NEW</varname> row for <command>INSERT</command> and "
"<command>UPDATE</command> operations, or the <varname>OLD</varname> row for "
"<command>DELETE</command> operations). A nonnull return value is used to "
"signal that the trigger performed the necessary data modifications in the "
"view. This will cause the count of the number of rows affected by the "
"command to be incremented. For <command>INSERT</command> and "
"<command>UPDATE</command> operations, the trigger may modify the "
"<varname>NEW</varname> row before returning it. This will change the data "
"returned by <command>INSERT RETURNING</command> or <command>UPDATE "
"RETURNING</command>, and is useful when the view will not show exactly the "
"same data that was provided."
msgstr ""
"<literal>INSTEAD OF</literal> триггер уровня строки должен вернуть либо "
"<symbol>NULL</symbol>, чтобы указать, что он не модифицирует базовые таблицы "
"представления, либо он должен вернуть строку представления, полученную на "
"входе (строку <varname>NEW</varname> для операций <command>INSERT</command> "
"и <command>UPDATE</command> или строку <varname>OLD</varname> для операций "
"<command>DELETE</command>). Отличное от <symbol>NULL</symbol> возвращаемое "
"значение сигнализирует, что триггер выполнил необходимые изменения данных в "
"представлении. Это приведёт к увеличению счётчика количества строк, "
"затронутых командой. Для операций <command>INSERT</command> и "
"<command>UPDATE</command> триггер может изменить строку <varname>NEW</"
"varname> перед тем как её вернуть. Это изменит данные, возвращаемые "
"<command>INSERT RETURNING</command> или <command>UPDATE RETURNING</command>, "
"и полезно для того, чтобы не показывать уже не актуальные первоначальные "
"данные."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:213(para)
msgid ""
"The return value is ignored for row-level triggers fired after an operation, "
"and so they can return <symbol>NULL</symbol>."
msgstr ""
"Возвращаемое значение игнорируется для триггеров уровня строки, вызываемых "
"после операции, поэтому они могут возвращать <symbol>NULL</symbol>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:218(para)
msgid ""
"If more than one trigger is defined for the same event on the same relation, "
"the triggers will be fired in alphabetical order by trigger name. In the "
"case of <literal>BEFORE</literal> and <literal>INSTEAD OF</literal> "
"triggers, the possibly-modified row returned by each trigger becomes the "
"input to the next trigger. If any <literal>BEFORE</literal> or "
"<literal>INSTEAD OF</literal> trigger returns <symbol>NULL</symbol>, the "
"operation is abandoned for that row and subsequent triggers are not fired "
"(for that row)."
msgstr ""
"Если есть несколько триггеров на одно и то же событие для одной и той же "
"таблицы, то они будут вызываться в алфавитном порядке по имени триггера. Для "
"триггеров <literal>BEFORE</literal> и <literal>INSTEAD OF</literal> "
"потенциально изменённая строка, возвращаемая одним триггером, становится "
"входящей строкой для следующего триггера. Если любой из триггеров "
"<literal>BEFORE</literal> или <literal>INSTEAD OF</literal> возвращает "
"<symbol>NULL</symbol>, операция для этой строки прекращается и последующие "
"триггеры (для этой строки) не срабатывают."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:229(para)
msgid ""
"A trigger definition can also specify a Boolean <literal>WHEN</literal> "
"condition, which will be tested to see whether the trigger should be fired. "
"In row-level triggers the <literal>WHEN</literal> condition can examine the "
"old and/or new values of columns of the row. (Statement-level triggers can "
"also have <literal>WHEN</literal> conditions, although the feature is not so "
"useful for them.) In a <literal>BEFORE</literal> trigger, the <literal>WHEN</"
"literal> condition is evaluated just before the function is or would be "
"executed, so using <literal>WHEN</literal> is not materially different from "
"testing the same condition at the beginning of the trigger function. "
"However, in an <literal>AFTER</literal> trigger, the <literal>WHEN</literal> "
"condition is evaluated just after the row update occurs, and it determines "
"whether an event is queued to fire the trigger at the end of statement. So "
"when an <literal>AFTER</literal> trigger's <literal>WHEN</literal> condition "
"does not return true, it is not necessary to queue an event nor to re-fetch "
"the row at end of statement. This can result in significant speedups in "
"statements that modify many rows, if the trigger only needs to be fired for "
"a few of the rows. <literal>INSTEAD OF</literal> triggers do not support "
"<literal>WHEN</literal> conditions."
msgstr ""
"В определении триггера можно указать логическое условие <literal>WHEN</"
"literal>, которое будет проверяться, чтобы посмотреть, нужно ли запускать "
"триггер. В триггерах уровня строки в условии <literal>WHEN</literal> можно "
"проверять старые и/или новые значения столбцов строки. (В триггерах уровня "
"оператора также можно использовать условие <literal>WHEN</literal>, хотя в "
"этом случае это не так полезно.) В триггерах <literal>BEFORE</literal> "
"условие <literal>WHEN</literal> вычисляется непосредственно перед тем, как "
"триггерная функция будет выполнена, поэтому использование <literal>WHEN</"
"literal> существенно не отличается от выполнения той же проверки в самом "
"начале триггерной функции. Однако, в триггерах <literal>AFTER</literal> "
"условие <literal>WHEN</literal> вычисляется сразу после обновления строки и "
"от этого зависит, будет ли поставлено в очередь событие запуска триггера в "
"конце оператора или нет. Поэтому, когда условие <literal>WHEN</literal> в "
"триггере <literal>AFTER</literal> не возвращает истину, не требуется ни "
"постановка события в очередь, ни повторная выборка этой строки в конце "
"оператора. Это может существенно ускорить работу операторов, изменяющих "
"большое количество строк, с триггером, который должен сработать только для "
"нескольких. В триггерах <literal>INSTEAD OF</literal> не поддерживается "
"использование условий <literal>WHEN</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:252(para)
msgid ""
"Typically, row-level <literal>BEFORE</literal> triggers are used for "
"checking or modifying the data that will be inserted or updated. For "
"example, a <literal>BEFORE</literal> trigger might be used to insert the "
"current time into a <type>timestamp</type> column, or to check that two "
"elements of the row are consistent. Row-level <literal>AFTER</literal> "
"triggers are most sensibly used to propagate the updates to other tables, or "
"make consistency checks against other tables. The reason for this division "
"of labor is that an <literal>AFTER</literal> trigger can be certain it is "
"seeing the final value of the row, while a <literal>BEFORE</literal> trigger "
"cannot; there might be other <literal>BEFORE</literal> triggers firing after "
"it. If you have no specific reason to make a trigger <literal>BEFORE</"
"literal> or <literal>AFTER</literal>, the <literal>BEFORE</literal> case is "
"more efficient, since the information about the operation doesn't have to be "
"saved until end of statement."
msgstr ""
"Как правило, триггеры <literal>BEFORE</literal> уровня строки используются "
"для проверки или модификации данных, которые будут вставлены или изменены. "
"Например, триггер <literal>BEFORE</literal> можно использовать для вставки "
"текущего времени в столбец <type>timestamp</type> или проверки, что два "
"элемента строки согласованы между собой. Триггеры <literal>AFTER</literal> "
"уровня строки наиболее разумно использовать для каскадного обновления данных "
"в других таблицах или проверки согласованности сделанных изменений с данными "
"в других таблицах. Причина для такого разделения работы в том, что триггер "
"<literal>AFTER</literal> видит окончательное значение строки, в то время как "
"для триггера <literal>BEFORE</literal> это не так, ведь могут быть другие "
"триггеры <literal>BEFORE</literal>, которые сработают позже. Если нет особых "
"причин для выбора между триггерами <literal>BEFORE</literal> или "
"<literal>AFTER</literal>, то триггер <literal>BEFORE</literal> "
"предпочтительнее, так как не требует сохранения информации об операции до "
"конца работы оператора."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:269(para)
msgid ""
"If a trigger function executes SQL commands then these commands might fire "
"triggers again. This is known as cascading triggers. There is no direct "
"limitation on the number of cascade levels. It is possible for cascades to "
"cause a recursive invocation of the same trigger; for example, an "
"<command>INSERT</command> trigger might execute a command that inserts an "
"additional row into the same table, causing the <command>INSERT</command> "
"trigger to be fired again. It is the trigger programmer's responsibility to "
"avoid infinite recursion in such scenarios."
msgstr ""
"Если триггерная функция выполняет команды SQL, эти команды могут заново "
"запускать триггеры. Это известно как каскадные триггеры. Прямых ограничений "
"на количество каскадных уровней не существует. Вполне возможно, что "
"каскадные вызовы приведут к рекурсивному срабатыванию одного и того же "
"триггера. Например, в триггере <command>INSERT</command> может выполняться "
"команда, которая добавляет строку в эту же таблицу, тем самым опять вызывая "
"триггер на <command>INSERT</command>. Обязанность программиста не допускать "
"бесконечную рекурсию в таких случаях."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:282(indexterm)
msgid ""
"<primary>trigger</primary> <secondary>arguments for trigger functions</"
"secondary>"
msgstr ""
"<primary>Триггер</primary> <secondary>Аргументы для триггерных функций</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:281(para)
msgid ""
"<placeholder-1/> When a trigger is being defined, arguments can be specified "
"for it. The purpose of including arguments in the trigger definition is to "
"allow different triggers with similar requirements to call the same "
"function. As an example, there could be a generalized trigger function that "
"takes as its arguments two column names and puts the current user in one and "
"the current time stamp in the other. Properly written, this trigger function "
"would be independent of the specific table it is triggering on. So the same "
"function could be used for <command>INSERT</command> events on any table "
"with suitable columns, to automatically track creation of records in a "
"transaction table for example. It could also be used to track last-update "
"events if defined as an <command>UPDATE</command> trigger."
msgstr ""
"<placeholder-1/> При определении триггера можно указывать аргументы. Цель "
"включения аргументов в определение триггера в том, чтобы позволить разным "
"триггерам с аналогичными требованиями вызывать одну и ту же функцию. В "
"качестве примера можно создать обобщенную триггерную функцию, которая "
"принимает два аргумента с именами столбцов и записывает текущего "
"пользователя в первый аргумент и текущий штамп времени во второй. При "
"правильном написании такая триггерная функция будет независима от конкретной "
"таблицы, для которой она будет запускаться. Таким образом, одна и та же "
"функция может использоваться при выполнении <command>INSERT</command> в "
"любую таблицу с соответствующими столбцами, чтобы, например, автоматически "
"отслеживать создание записей в транзакционной таблице. Для триггеров "
"<command>UPDATE</command> аргументы также могут использоваться для "
"отслеживания последних сделанных изменений."

#. +> REL_10
#: trigger.xml:302(para)
msgid ""
"Each programming language that supports triggers has its own method for "
"making the trigger input data available to the trigger function. This input "
"data includes the type of trigger event (e.g., <command>INSERT</command> or "
"<command>UPDATE</command>) as well as any arguments that were listed in "
"<command>CREATE TRIGGER</command>. For a row-level trigger, the input data "
"also includes the <varname>NEW</varname> row for <command>INSERT</command> "
"and <command>UPDATE</command> triggers, and/or the <varname>OLD</varname> "
"row for <command>UPDATE</command> and <command>DELETE</command> triggers."
msgstr ""
"У каждого языка программирования, поддерживающего триггеры, есть свой "
"собственный метод доступа из триггерной функции к входным данным триггера. "
"Входные данные триггера включают в себя тип события (например, "
"<command>INSERT</command> или <command>UPDATE</command>), а также любые "
"аргументы, перечисленные в <command>CREATE TRIGGER</command>. Для триггеров "
"уровня строки входные данные также включают строку <varname>NEW</varname> "
"для триггеров <command>INSERT</command> и <command>UPDATE</command> и/или "
"строку <varname>OLD</varname> для триггеров <command>UPDATE</command> и "
"<command>DELETE</command>."

#. +> REL_10
#: trigger.xml:314(para)
msgid ""
"By default, statement-level triggers do not have any way to examine the "
"individual row(s) modified by the statement. But an <literal>AFTER "
"STATEMENT</literal> trigger can request that <firstterm>transition tables</"
"firstterm> be created to make the sets of affected rows available to the "
"trigger. <literal>AFTER ROW</literal> triggers can also request transition "
"tables, so that they can see the total changes in the table as well as the "
"change in the individual row they are currently being fired for. The method "
"for examining the transition tables again depends on the programming "
"language that is being used, but the typical approach is to make the "
"transition tables act like read-only temporary tables that can be accessed "
"by SQL commands issued within the trigger function."
msgstr ""
"Триггеры уровня оператора по умолчанию не имеют возможностей для проверки "
"отдельных строк, модифицированных оператором. Но триггер <literal>AFTER "
"STATEMENT</literal> может запросить создание для него <firstterm>переходных "
"таблиц</firstterm>, чтобы ему были доступны наборы затрагиваемых операцией "
"строк. Триггерам <literal>AFTER ROW</literal> также могут предоставляться "
"переходные таблицы, чтобы они могли видеть все изменения в таблице, а не "
"только изменения в отдельных строках, для которых они срабатывают. Метод "
"обращения к переходным таблицам определяется применяемым языком "
"программирования, но обычно переходные таблицы представляются как временные "
"таблицы только для чтения, к которым в триггерной функции можно обращаться, "
"выполняя SQL-команды."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:331(title)
msgid "Visibility of Data Changes"
msgstr "Видимость изменений в данных"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:343(para)
msgid ""
"Statement-level triggers follow simple visibility rules: none of the changes "
"made by a statement are visible to statement-level <literal>BEFORE</literal> "
"triggers, whereas all modifications are visible to statement-level "
"<literal>AFTER</literal> triggers."
msgstr ""
"Триггеры уровня оператора следуют простым правилам видимости: никакие из "
"изменений, произведённых оператором, не видны в триггерах <literal>BEFORE</"
"literal>, тогда как в триггерах <literal>AFTER</literal> видны все изменения."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:353(para)
msgid ""
"The data change (insertion, update, or deletion) causing the trigger to fire "
"is naturally <emphasis>not</emphasis> visible to SQL commands executed in a "
"row-level <literal>BEFORE</literal> trigger, because it hasn't happened yet."
msgstr ""
"Изменение данных (вставка, обновление или удаление), заставляющее сработать "
"триггер, <emphasis>не видно</emphasis> для команд SQL, выполняемых в "
"триггере <literal>BEFORE</literal> уровня строки, потому что это изменение "
"ещё не произошло."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:362(para)
msgid ""
"However, SQL commands executed in a row-level <literal>BEFORE</literal> "
"trigger <emphasis>will</emphasis> see the effects of data changes for rows "
"previously processed in the same outer command. This requires caution, since "
"the ordering of these change events is not in general predictable; a SQL "
"command that affects multiple rows can visit the rows in any order."
msgstr ""
"Тем не менее, команды SQL, выполняемые в триггере <literal>BEFORE</literal> "
"уровня строки, <emphasis>будут</emphasis> видеть изменения данных в строках, "
"которые уже были обработаны в этом операторе. Это требует осторожности, так "
"как порядок обработки строк в целом непредсказуемый; команда SQL, "
"обрабатывающая множество строк, может делать это в любом порядке."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:373(para)
msgid ""
"Similarly, a row-level <literal>INSTEAD OF</literal> trigger will see the "
"effects of data changes made by previous firings of <literal>INSTEAD OF</"
"literal> triggers in the same outer command."
msgstr ""
"Аналогично, триггер <literal>INSTEAD OF</literal> уровня строки увидит "
"изменения данных, внесённые при предыдущих вызовах триггера <literal>INSTEAD "
"OF</literal> для этой же внешней команды."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:381(para)
msgid ""
"When a row-level <literal>AFTER</literal> trigger is fired, all data changes "
"made by the outer command are already complete, and are visible to the "
"invoked trigger function."
msgstr ""
"Когда срабатывает триггер <literal>AFTER</literal> уровня строки, все "
"изменения сделанные оператором уже выполнены и видны в вызываемой триггерной "
"функции."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:333(para)
msgid ""
"If you execute SQL commands in your trigger function, and these commands "
"access the table that the trigger is for, then you need to be aware of the "
"data visibility rules, because they determine whether these SQL commands "
"will see the data change that the trigger is fired for. Briefly: "
"<placeholder-1/>"
msgstr ""
"Если в триггерной функции выполняются SQL-команды и эти команды обращаются к "
"таблице, на которую создан триггер, то необходимо знать правила видимости "
"данных, потому что они определяют, будут ли видеть эти SQL-команды изменения "
"в данных, для которых сработал триггер. Кратко: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:391(para)
msgid ""
"If your trigger function is written in any of the standard procedural "
"languages, then the above statements apply only if the function is declared "
"<literal>VOLATILE</literal>. Functions that are declared <literal>STABLE</"
"literal> or <literal>IMMUTABLE</literal> will not see changes made by the "
"calling command in any case."
msgstr ""
"Если триггерная функция написана на одном из стандартных процедурных языков, "
"вышеприведённые утверждения применимы, только если функция объявлена как "
"<literal>VOLATILE</literal>. Функции объявленные как <literal>STABLE</"
"literal> или <literal>IMMUTABLE</literal> в любом случае не будут видеть "
"изменений, сделанных вызывающим оператором."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:399(para)
msgid ""
"Further information about data visibility rules can be found in <xref "
"linkend=\"spi-visibility\"/>. The example in <xref linkend=\"trigger-example"
"\"/> contains a demonstration of these rules."
msgstr ""
"Дополнительную информацию о правилах видимости данных можно найти в <xref "
"remap=\"6\" linkend=\"spi-visibility\"/>. Пример в <xref remap=\"6\" linkend="
"\"trigger-example\"/> содержит демонстрацию этих правил."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:407(title)
msgid "Writing Trigger Functions in C"
msgstr "Триггерные функции на языке C"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:409(indexterm)
msgid "<primary>trigger</primary> <secondary>in C</secondary>"
msgstr "<primary>Триггер</primary> <secondary>на C</secondary>"

#. +> REL_10
#: trigger.xml:414(indexterm)
msgid ""
"<primary>transition tables</primary> <secondary>referencing from C trigger</"
"secondary>"
msgstr ""
"<primary>таблицы перехода</primary> <secondary>обращение из триггера на C</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:419(para)
msgid ""
"This section describes the low-level details of the interface to a trigger "
"function. This information is only needed when writing trigger functions in "
"C. If you are using a higher-level language then these details are handled "
"for you. In most cases you should consider using a procedural language "
"before writing your triggers in C. The documentation of each procedural "
"language explains how to write a trigger in that language."
msgstr ""
"Этот раздел описывает низкоуровневые детали интерфейса для триггерной "
"функции. Эта информация необходима только при разработке триггерных функций "
"на C. При использовании языка более высокого уровня эти детали "
"обрабатываются автоматически. В большинстве случаев необходимо рассмотреть "
"использование процедурного языка, прежде чем начать разрабатывать триггеры "
"на C. В документации по каждому процедурному языку объясняется как создавать "
"триггеры на этом языке."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:429(para)
msgid ""
"Trigger functions must use the <quote>version 1</quote> function manager "
"interface."
msgstr ""
"Триггерные функции должны использовать интерфейс функций <quote>версии 1</"
"quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:440(programlisting)
#, no-wrap
msgid "CALLED_AS_TRIGGER(fcinfo)"
msgstr "CALLED_AS_TRIGGER(fcinfo)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:444(programlisting)
#, no-wrap
msgid "((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))"
msgstr "((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:434(para)
msgid ""
"When a function is called by the trigger manager, it is not passed any "
"normal arguments, but it is passed a <quote>context</quote> pointer pointing "
"to a <structname>TriggerData</structname> structure. C functions can check "
"whether they were called from the trigger manager or not by executing the "
"macro: <placeholder-1/> which expands to: <placeholder-2/> If this returns "
"true, then it is safe to cast <literal>fcinfo-&gt;context</literal> to type "
"<literal>TriggerData *</literal> and make use of the pointed-to "
"<structname>TriggerData</structname> structure. The function must "
"<emphasis>not</emphasis> alter the <structname>TriggerData</structname> "
"structure or any of the data it points to."
msgstr ""
"Когда функция вызывается диспетчером триггеров, ей не передаются обычные "
"аргументы, но передаётся указатель <quote>context</quote>, ссылающийся на "
"структуру <structname>TriggerData</structname>. Функции на C могут "
"проверить, вызваны ли они диспетчером триггеров или нет, выполнив макрос: "
"<placeholder-1/> который разворачивается в: <placeholder-2/> Если "
"возвращается истина, то <literal>fcinfo-&gt;context</literal> можно "
"безопасно привести к типу <literal>TriggerData *</literal> и использовать "
"указатель на структуру <structname>TriggerData</structname>. Функция "
"<emphasis>не</emphasis> должна изменять структуру <structname>TriggerData</"
"structname> или любые данные, которые на неё указывают."

#. +> REL_10
#: trigger.xml:459(programlisting)
#, no-wrap
msgid ""
"typedef struct TriggerData\n"
"{\n"
"    NodeTag          type;\n"
"    TriggerEvent     tg_event;\n"
"    Relation         tg_relation;\n"
"    HeapTuple        tg_trigtuple;\n"
"    HeapTuple        tg_newtuple;\n"
"    Trigger         *tg_trigger;\n"
"    Buffer           tg_trigtuplebuf;\n"
"    Buffer           tg_newtuplebuf;\n"
"    Tuplestorestate *tg_oldtable;\n"
"    Tuplestorestate *tg_newtable;\n"
"} TriggerData;"
msgstr ""
"typedef struct TriggerData\n"
"{\n"
"    NodeTag          type;\n"
"    TriggerEvent     tg_event;\n"
"    Relation         tg_relation;\n"
"    HeapTuple        tg_trigtuple;\n"
"    HeapTuple        tg_newtuple;\n"
"    Trigger         *tg_trigger;\n"
"    Buffer           tg_trigtuplebuf;\n"
"    Buffer           tg_newtuplebuf;\n"
"    Tuplestorestate *tg_oldtable;\n"
"    Tuplestorestate *tg_newtable;\n"
"} TriggerData;"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:479(structfield)
msgid "type"
msgstr "type"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:481(para)
msgid "Always <literal>T_TriggerData</literal>."
msgstr "Всегда <literal>T_TriggerData</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:488(structfield)
msgid "tg_event"
msgstr "tg_event"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:496(literal)
msgid "TRIGGER_FIRED_BEFORE(tg_event)"
msgstr "TRIGGER_FIRED_BEFORE(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:498(para)
msgid "Returns true if the trigger fired before the operation."
msgstr "Возвращает истину, если триггер сработал до операции."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:505(literal)
msgid "TRIGGER_FIRED_AFTER(tg_event)"
msgstr "TRIGGER_FIRED_AFTER(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:507(para)
msgid "Returns true if the trigger fired after the operation."
msgstr "Возвращает истину, если триггер сработал после операции."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:514(literal)
msgid "TRIGGER_FIRED_INSTEAD(tg_event)"
msgstr "TRIGGER_FIRED_INSTEAD(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:516(para)
msgid "Returns true if the trigger fired instead of the operation."
msgstr "Возвращает истину, если триггер сработал вместо операции."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:523(literal)
msgid "TRIGGER_FIRED_FOR_ROW(tg_event)"
msgstr "TRIGGER_FIRED_FOR_ROW(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:525(para)
msgid "Returns true if the trigger fired for a row-level event."
msgstr "Возвращает истину, если триггер сработал на уровне строки."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:532(literal)
msgid "TRIGGER_FIRED_FOR_STATEMENT(tg_event)"
msgstr "TRIGGER_FIRED_FOR_STATEMENT(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:534(para)
msgid "Returns true if the trigger fired for a statement-level event."
msgstr "Возвращает истину, если триггер сработал на уровне оператора."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:541(literal)
msgid "TRIGGER_FIRED_BY_INSERT(tg_event)"
msgstr "TRIGGER_FIRED_BY_INSERT(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:543(para)
msgid ""
"Returns true if the trigger was fired by an <command>INSERT</command> "
"command."
msgstr ""
"Возвращает истину, если триггер сработал для операции <command>INSERT</"
"command>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:550(literal)
msgid "TRIGGER_FIRED_BY_UPDATE(tg_event)"
msgstr "TRIGGER_FIRED_BY_UPDATE(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:552(para)
msgid ""
"Returns true if the trigger was fired by an <command>UPDATE</command> "
"command."
msgstr ""
"Возвращает истину, если триггер сработал для операции <command>UPDATE</"
"command>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:559(literal)
msgid "TRIGGER_FIRED_BY_DELETE(tg_event)"
msgstr "TRIGGER_FIRED_BY_DELETE(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:561(para)
msgid ""
"Returns true if the trigger was fired by a <command>DELETE</command> command."
msgstr ""
"Возвращает истину, если триггер сработал для операции <command>DELETE</"
"command>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:568(literal)
msgid "TRIGGER_FIRED_BY_TRUNCATE(tg_event)"
msgstr "TRIGGER_FIRED_BY_TRUNCATE(tg_event)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:570(para)
msgid ""
"Returns true if the trigger was fired by a <command>TRUNCATE</command> "
"command."
msgstr ""
"Возвращает истину, если триггер сработал для операции <command>TRUNCATE</"
"command>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:490(para)
msgid ""
"Describes the event for which the function is called. You can use the "
"following macros to examine <literal>tg_event</literal>: <placeholder-1/>"
msgstr ""
"Описывает событие, для которого вызывается функция. Можно использовать "
"следующие макросы для получения информации о <literal>tg_event</literal>: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:581(structfield)
msgid "tg_relation"
msgstr "tg_relation"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:583(para)
msgid ""
"A pointer to a structure describing the relation that the trigger fired for. "
"Look at <filename>utils/rel.h</filename> for details about this structure. "
"The most interesting things are <literal>tg_relation-&gt;rd_att</literal> "
"(descriptor of the relation tuples) and <literal>tg_relation-&gt;rd_rel-&gt;"
"relname</literal> (relation name; the type is not <type>char*</type> but "
"<type>NameData</type>; use <literal>SPI_getrelname(tg_relation)</literal> to "
"get a <type>char*</type> if you need a copy of the name)."
msgstr ""
"Указатель на структуру, описывающую таблицу, для которой сработал триггер. "
"Подробнее об этой структуре в <filename>utils/rel.h</filename>. Самое "
"интересное здесь это <literal>tg_relation-&gt;rd_att</literal> (дескриптор "
"записей таблицы) и <literal>tg_relation-&gt;rd_rel-&gt;relname</literal> "
"(имя таблицы; имеет тип <type>NameData</type>, а не <type>char*</type>; "
"используйте <literal>SPI_getrelname(tg_relation)</literal>, чтобы получить "
"тип <type>char*</type> если потребуется копия имени)."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:598(structfield)
msgid "tg_trigtuple"
msgstr "tg_trigtuple"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:600(para)
msgid ""
"A pointer to the row for which the trigger was fired. This is the row being "
"inserted, updated, or deleted. If this trigger was fired for an "
"<command>INSERT</command> or <command>DELETE</command> then this is what you "
"should return from the function if you don't want to replace the row with a "
"different one (in the case of <command>INSERT</command>) or skip the "
"operation. For triggers on foreign tables, values of system columns herein "
"are unspecified."
msgstr ""
"Указатель на строку, для которой сработал триггер. Это строка, которая "
"вставляется, обновляется или удаляется. При срабатывании триггера для "
"<command>INSERT</command> или <command>DELETE</command> это значение нужно "
"вернуть из функции, только если не планируется изменять строку (в случае "
"<command>INSERT</command>) или пропускать операцию для этой строки."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:614(structfield)
msgid "tg_newtuple"
msgstr "tg_newtuple"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:616(para)
msgid ""
"A pointer to the new version of the row, if the trigger was fired for an "
"<command>UPDATE</command>, and <symbol>NULL</symbol> if it is for an "
"<command>INSERT</command> or a <command>DELETE</command>. This is what you "
"have to return from the function if the event is an <command>UPDATE</"
"command> and you don't want to replace this row by a different one or skip "
"the operation. For triggers on foreign tables, values of system columns "
"herein are unspecified."
msgstr ""
"Для триггера на <command>UPDATE</command> это указатель на новую версию "
"строки либо <symbol>NULL</symbol>, если триггер на <command>INSERT</command> "
"или <command>DELETE</command>. Это значение нужно вернуть из функции в "
"случае <command>UPDATE</command>, если не планируется изменять строку или "
"пропускать операцию для этой строки."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:630(structfield)
msgid "tg_trigger"
msgstr "tg_trigger"

#. +> REL_10
#: trigger.xml:636(programlisting)
#, no-wrap
msgid ""
"typedef struct Trigger\n"
"{\n"
"    Oid         tgoid;\n"
"    char       *tgname;\n"
"    Oid         tgfoid;\n"
"    int16       tgtype;\n"
"    char        tgenabled;\n"
"    bool        tgisinternal;\n"
"    Oid         tgconstrrelid;\n"
"    Oid         tgconstrindid;\n"
"    Oid         tgconstraint;\n"
"    bool        tgdeferrable;\n"
"    bool        tginitdeferred;\n"
"    int16       tgnargs;\n"
"    int16       tgnattr;\n"
"    int16      *tgattr;\n"
"    char      **tgargs;\n"
"    char       *tgqual;\n"
"    char       *tgoldtable;\n"
"    char       *tgnewtable;\n"
"} Trigger;"
msgstr ""
"typedef struct Trigger\n"
"{\n"
"    Oid         tgoid;\n"
"    char       *tgname;\n"
"    Oid         tgfoid;\n"
"    int16       tgtype;\n"
"    char        tgenabled;\n"
"    bool        tgisinternal;\n"
"    Oid         tgconstrrelid;\n"
"    Oid         tgconstrindid;\n"
"    Oid         tgconstraint;\n"
"    bool        tgdeferrable;\n"
"    bool        tginitdeferred;\n"
"    int16       tgnargs;\n"
"    int16       tgnattr;\n"
"    int16      *tgattr;\n"
"    char      **tgargs;\n"
"    char       *tgqual;\n"
"    char       *tgoldtable;\n"
"    char       *tgnewtable;\n"
"} Trigger;"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:632(para)
msgid ""
"A pointer to a structure of type <structname>Trigger</structname>, defined "
"in <filename>utils/reltrigger.h</filename>: <placeholder-1/> where "
"<structfield>tgname</structfield> is the trigger's name, "
"<structfield>tgnargs</structfield> is the number of arguments in "
"<structfield>tgargs</structfield>, and <structfield>tgargs</structfield> is "
"an array of pointers to the arguments specified in the <command>CREATE "
"TRIGGER</command> statement. The other members are for internal use only."
msgstr ""
"Указатель на структуру с типом <structname>Trigger</structname>, "
"определённую в <filename>utils/reltrigger.h</filename>: <placeholder-1/> где "
"<structfield>tgname</structfield> — имя триггера, <structfield>tgnargs</"
"structfield> — количество аргументов в <structfield>tgargs</structfield>, и "
"<structfield>tgargs</structfield> — массив указателей на аргументы, "
"указанные в команде <command>CREATE TRIGGER</command>. Остальные члены "
"структуры предназначены для внутреннего использования."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:671(structfield)
msgid "tg_trigtuplebuf"
msgstr "tg_trigtuplebuf"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:673(para)
msgid ""
"The buffer containing <structfield>tg_trigtuple</structfield>, or "
"<symbol>InvalidBuffer</symbol> if there is no such tuple or it is not stored "
"in a disk buffer."
msgstr ""
"Буфер, содержащий <structfield>tg_trigtuple</structfield>, или содержащий "
"<symbol>InvalidBuffer</symbol> — если нет такой строки или она не хранится в "
"дисковом буфере."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:681(structfield)
msgid "tg_newtuplebuf"
msgstr "tg_newtuplebuf"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:683(para)
msgid ""
"The buffer containing <structfield>tg_newtuple</structfield>, or "
"<symbol>InvalidBuffer</symbol> if there is no such tuple or it is not stored "
"in a disk buffer."
msgstr ""
"Буфер, содержащий <structfield>tg_newtuple</structfield>, или содержащий "
"<symbol>InvalidBuffer</symbol> — если нет такой строки или она не хранится в "
"дисковом буфере."

#. +> REL_10
#: trigger.xml:691(structfield)
msgid "tg_oldtable"
msgstr "tg_oldtable"

#. +> REL_10
#: trigger.xml:693(para)
msgid ""
"A pointer to a structure of type <structname>Tuplestorestate</structname> "
"containing zero or more rows in the format specified by "
"<structfield>tg_relation</structfield>, or a <symbol>NULL</symbol> pointer "
"if there is no <literal>OLD TABLE</literal> transition relation."
msgstr ""
"Указатель на структуру типа <structname>Tuplestorestate</structname>, "
"содержащую ноль или несколько строк в формате, определяемом содержимым "
"<structfield>tg_relation</structfield>, или указатель <symbol>NULL</symbol>, "
"если переходное отношение <literal>OLD TABLE</literal> отсутствует."

#. +> REL_10
#: trigger.xml:703(structfield)
msgid "tg_newtable"
msgstr "tg_newtable"

#. +> REL_10
#: trigger.xml:705(para)
msgid ""
"A pointer to a structure of type <structname>Tuplestorestate</structname> "
"containing zero or more rows in the format specified by "
"<structfield>tg_relation</structfield>, or a <symbol>NULL</symbol> pointer "
"if there is no <literal>NEW TABLE</literal> transition relation."
msgstr ""
"Указатель на структуру типа <structname>Tuplestorestate</structname>, "
"содержащую ноль или несколько строк в формате, определяемом содержимым "
"<structfield>tg_relation</structfield>, или указатель <symbol>NULL</symbol>, "
"если переходное отношение <literal>NEW TABLE</literal> отсутствует."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:455(para)
msgid ""
"<structname>struct TriggerData</structname> is defined in <filename>commands/"
"trigger.h</filename>: <placeholder-1/> where the members are defined as "
"follows: <placeholder-2/>"
msgstr ""
"<structname>struct TriggerData</structname> определяется в "
"<filename>commands/trigger.h</filename>: <placeholder-1/> где элементы "
"определяются следующим образом: <placeholder-2/>"

#. +> REL_10
#: trigger.xml:717(para)
msgid ""
"To allow queries issued through SPI to reference transition tables, see "
"<xref linkend=\"spi-spi-register-trigger-data\"/>."
msgstr ""
"Чтобы обращаться к переходным таблицам в запросах, выполняемых через SPI, "
"используйте <xref linkend=\"spi-spi-register-trigger-data\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:722(para)
msgid ""
"A trigger function must return either a <structname>HeapTuple</structname> "
"pointer or a <symbol>NULL</symbol> pointer (<emphasis>not</emphasis> an SQL "
"null value, that is, do not set <parameter>isNull</parameter> true). Be "
"careful to return either <structfield>tg_trigtuple</structfield> or "
"<structfield>tg_newtuple</structfield>, as appropriate, if you don't want to "
"modify the row being operated on."
msgstr ""
"Триггерная функция должна возвращать указатель <structname>HeapTuple</"
"structname> или указатель <symbol>NULL</symbol> (но <emphasis>не</emphasis> "
"SQL значение <literal>null</literal>, то есть не нужно устанавливать "
"<parameter>isNull</parameter> в истину). Не забудьте, что если не планируете "
"менять обрабатываемую триггером строку, то нужно вернуть либо "
"<structfield>tg_trigtuple</structfield>, либо <structfield>tg_newtuple</"
"structfield>."

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:733(title)
msgid "A Complete Trigger Example"
msgstr "Полный пример триггера"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:735(para)
msgid ""
"Here is a very simple example of a trigger function written in C. (Examples "
"of triggers written in procedural languages can be found in the "
"documentation of the procedural languages.)"
msgstr ""
"Вот очень простой пример триггерной функции, написанной на C. (Примеры "
"триггеров для процедурных языков могут быть найдены в документации на "
"процедурные языки.)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:741(para)
msgid ""
"The function <function>trigf</function> reports the number of rows in the "
"table <structname>ttest</structname> and skips the actual operation if the "
"command attempts to insert a null value into the column <structfield>x</"
"structfield>. (So the trigger acts as a not-null constraint but doesn't "
"abort the transaction.)"
msgstr ""
"Функция <function>trigf</function> сообщает количество строк в таблице "
"<structname>ttest</structname> и пропускает операцию для строки при попытке "
"вставить пустое значение в столбец <structfield>x</structfield>. (Таким "
"образом, триггер действует как ограничение <literal>NOT NULL</literal>, но "
"не прерывает транзакцию.)"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:751(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE ttest (\n"
"    x integer\n"
");"
msgstr ""
"CREATE TABLE ttest (\n"
"    x integer\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:749(para)
msgid "First, the table definition: <placeholder-1/>"
msgstr "Вначале определение таблицы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:758(para)
msgid "This is the source code of the trigger function: <placeholder-1/>"
msgstr "Теперь исходный код триггерной функции: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:840(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION trigf() RETURNS trigger\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C;\n"
"\n"
"CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest\n"
"    FOR EACH ROW EXECUTE PROCEDURE trigf();\n"
"\n"
"CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest\n"
"    FOR EACH ROW EXECUTE PROCEDURE trigf();"
msgstr ""
"CREATE FUNCTION trigf() RETURNS trigger\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C;\n"
"\n"
"CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest\n"
"    FOR EACH ROW EXECUTE PROCEDURE trigf();\n"
"\n"
"CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest\n"
"    FOR EACH ROW EXECUTE PROCEDURE trigf();"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:837(para)
msgid ""
"After you have compiled the source code (see <xref linkend=\"dfunc\"/>), "
"declare the function and the triggers: <placeholder-1/>"
msgstr ""
"После компиляции исходного кода (см. <xref remap=\"4\" linkend=\"dfunc\"/>) "
"объявляем функцию и триггеры: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:853(para)
msgid ""
"Now you can test the operation of the trigger: <screen>\n"
"=&gt; INSERT INTO ttest VALUES (NULL);\n"
"INFO:  trigf (fired before): there are 0 rows in ttest\n"
"INSERT 0 0\n"
"\n"
"-- Insertion skipped and AFTER trigger is not fired\n"
"\n"
"=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
"(0 rows)\n"
"\n"
"=&gt; INSERT INTO ttest VALUES (1);\n"
"INFO:  trigf (fired before): there are 0 rows in ttest\n"
"INFO:  trigf (fired after ): there are 1 rows in ttest\n"
"                                       ^^^^^^^^\n"
"                             remember what we said about visibility.\n"
"INSERT 167793 1\n"
"vac=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
" 1\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;\n"
"INFO:  trigf (fired before): there are 1 rows in ttest\n"
"INFO:  trigf (fired after ): there are 2 rows in ttest\n"
"                                       ^^^^^^\n"
"                             remember what we said about visibility.\n"
"INSERT 167794 1\n"
"=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
" 1\n"
" 2\n"
"(2 rows)\n"
"\n"
"=&gt; UPDATE ttest SET x = NULL WHERE x = 2;\n"
"INFO:  trigf (fired before): there are 2 rows in ttest\n"
"UPDATE 0\n"
"=&gt; UPDATE ttest SET x = 4 WHERE x = 2;\n"
"INFO:  trigf (fired before): there are 2 rows in ttest\n"
"INFO:  trigf (fired after ): there are 2 rows in ttest\n"
"UPDATE 1\n"
"vac=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
" 1\n"
" 4\n"
"(2 rows)\n"
"\n"
"=&gt; DELETE FROM ttest;\n"
"INFO:  trigf (fired before): there are 2 rows in ttest\n"
"INFO:  trigf (fired before): there are 1 rows in ttest\n"
"INFO:  trigf (fired after ): there are 0 rows in ttest\n"
"INFO:  trigf (fired after ): there are 0 rows in ttest\n"
"                                       ^^^^^^\n"
"                             remember what we said about visibility.\n"
"DELETE 2\n"
"=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
"(0 rows)\n"
"</screen>"
msgstr ""
"Теперь можно проверить работу триггера: <screen>\n"
"=&gt; INSERT INTO ttest VALUES (NULL);\n"
"\n"
"INFO:  trigf (fired before): there are 0 rows in ttest\n"
"INSERT 0 0\n"
"\n"
"-- Вставка записи пропущена (NULL значение), поэтому AFTER триггер не "
"сработал\n"
"\n"
"=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
"(0 rows)\n"
"\n"
"=&gt; INSERT INTO ttest VALUES (1);\n"
"INFO:  trigf (fired before): there are 0 rows in ttest\n"
"INFO:  trigf (fired after ): there are 1 rows in ttest\n"
"                                                ^^^^^^^\n"
"                                   вспомним, что говорили о видимости\n"
"INSERT 167793 1\n"
"vac=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
" 1\n"
"(1 row)\n"
"\n"
"=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;\n"
"INFO:  trigf (fired before): there are 1 rows in ttest\n"
"INFO:  trigf (fired after ): there are 2 rows in ttest\n"
"                                                ^^^^^^^\n"
"                                   вспомним, что говорили о видимости\n"
"INSERT 167794 1\n"
"=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
" 1\n"
" 2\n"
"(2 rows)\n"
"\n"
"=&gt; UPDATE ttest SET x = NULL WHERE x = 2;\n"
"INFO:  trigf (fired before): there are 2 rows in ttest\n"
"UPDATE 0\n"
"=&gt; UPDATE ttest SET x = 4 WHERE x = 2;\n"
"INFO:  trigf (fired before): there are 2 rows in ttest\n"
"INFO:  trigf (fired after ): there are 2 rows in ttest\n"
"UPDATE 1\n"
"vac=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
" 1\n"
" 4\n"
"(2 rows)\n"
"\n"
"=&gt; DELETE FROM ttest;\n"
"INFO:  trigf (fired before): there are 2 rows in ttest\n"
"INFO:  trigf (fired before): there are 1 rows in ttest\n"
"INFO:  trigf (fired after ): there are 0 rows in ttest\n"
"INFO:  trigf (fired after ): there are 0 rows in ttest\n"
"                                                ^^^^^^^\n"
"                                   вспомним, что говорили о видимости\n"
"DELETE 2\n"
"=&gt; SELECT * FROM ttest;\n"
" x\n"
"---\n"
"(0 rows)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:922(para)
msgid ""
"There are more complex examples in <filename>src/test/regress/regress.c</"
"filename> and in <xref linkend=\"contrib-spi\"/>."
msgstr ""
"Более сложные примеры можно найти в <filename>src/test/regress/regress.c</"
"filename> и в <xref remap=\"6\" linkend=\"contrib-spi\"/>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: trigger.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: trigger.xml:40(para)
msgid ""
"On tables and foreign tables, triggers can be defined to execute either "
"before or after any <command>INSERT</command>, <command>UPDATE</command>, or "
"<command>DELETE</command> operation, either once per modified row, or once "
"per <acronym>SQL</acronym> statement. If an <command>INSERT</command> "
"contains an <literal>ON CONFLICT DO UPDATE</literal> clause, it is possible "
"that the effects of a BEFORE insert trigger and a BEFORE update trigger can "
"both be applied together, if a reference to an <varname>EXCLUDED</varname> "
"column appears. <command>UPDATE</command> triggers can moreover be set to "
"fire only if certain columns are mentioned in the <literal>SET</literal> "
"clause of the <command>UPDATE</command> statement. Triggers can also fire "
"for <command>TRUNCATE</command> statements. If a trigger event occurs, the "
"trigger's function is called at the appropriate time to handle the event. "
"Foreign tables do not support the TRUNCATE statement at all."
msgstr ""
"Для обычных и сторонних таблиц можно определять триггеры, которые будут "
"срабатывать до или после любой из команд <command>INSERT</command>, "
"<command>UPDATE</command> или <command>DELETE</command>; либо один раз для "
"каждой модифицируемой строки, либо один раз для оператора <acronym>SQL</"
"acronym>. С запросом <command>INSERT</command>, содержащим предложение "
"<literal>ON CONFLICT DO UPDATE</literal>, возможна ситуация, когда проявится "
"действие сразу двух триггеров BEFORE INSERT и BEFORE UPDATE, если запрос "
"обращается к столбцам <varname>EXCLUDED</varname>. Более того, триггеры "
"<command>UPDATE</command> можно установить так, чтобы они срабатывали, "
"только когда в предложении <literal>SET</literal> оператора <command>UPDATE</"
"command> упоминаются определённые столбцы. Также триггеры могут срабатывать "
"для операторов <command>TRUNCATE</command> (сторонние таблицы не "
"поддерживают этот оператор вовсе). Когда происходит событие триггера, для "
"обработки этого события в установленный момент времени вызывается функция "
"триггера."

#. +> REL9_6_3 REL9_6
#: trigger.xml:87(para)
msgid ""
"<productname>PostgreSQL</productname> offers both <firstterm>per-row</"
"firstterm> triggers and <firstterm>per-statement</firstterm> triggers. With "
"a per-row trigger, the trigger function is invoked once for each row that is "
"affected by the statement that fired the trigger. In contrast, a per-"
"statement trigger is invoked only once when an appropriate statement is "
"executed, regardless of the number of rows affected by that statement. In "
"particular, a statement that affects zero rows will still result in the "
"execution of any applicable per-statement triggers. These two types of "
"triggers are sometimes called <firstterm>row-level</firstterm> triggers and "
"<firstterm>statement-level</firstterm> triggers, respectively. Triggers on "
"<command>TRUNCATE</command> may only be defined at statement level. On "
"views, triggers that fire before or after may only be defined at statement "
"level, while triggers that fire instead of an <command>INSERT</command>, "
"<command>UPDATE</command>, or <command>DELETE</command> may only be defined "
"at row level."
msgstr ""
"<productname>PostgreSQL</productname> предлагает как <firstterm>построчные</"
"firstterm> триггеры, так и <firstterm>операторные</firstterm> триггеры. В "
"случае построчного триггера, триггерная функция вызывается один раз для "
"каждой строки, затронутой оператором, запустившим триггер. В "
"противоположность этому, операторный триггер вызывается только один раз при "
"выполнении соответствующего оператора, независимо от количества строк, "
"которые он затрагивает. В частности оператор, который вообще не затрагивает "
"строк, все равно приведёт к срабатыванию операторного триггера. Эти два типа "
"триггеров иногда называют триггерами <firstterm>уровня строк </firstterm> и "
"триггерами <firstterm>уровня оператора</firstterm> соответственно. Триггеры "
"на <command>TRUNCATE</command> могут быть определены только на уровне "
"оператора. Триггеры для представлений, срабатывающие до или после, могут "
"быть определены только на уровне оператора, в то время как триггеры, "
"срабатывающие вместо команд <command>INSERT</command>, <command>UPDATE</"
"command> или <command>DELETE</command>, могут быть определены только на "
"уровне строк."

#. +> REL9_6_3 REL9_6
#: trigger.xml:106(para)
msgid ""
"Triggers are also classified according to whether they fire "
"<firstterm>before</firstterm>, <firstterm>after</firstterm>, or "
"<firstterm>instead of</firstterm> the operation. These are referred to as "
"<literal>BEFORE</literal> triggers, <literal>AFTER</literal> triggers, and "
"<literal>INSTEAD OF</literal> triggers respectively. Statement-level "
"<literal>BEFORE</literal> triggers naturally fire before the statement "
"starts to do anything, while statement-level <literal>AFTER</literal> "
"triggers fire at the very end of the statement. These types of triggers may "
"be defined on tables or views. Row-level <literal>BEFORE</literal> triggers "
"fire immediately before a particular row is operated on, while row-level "
"<literal>AFTER</literal> triggers fire at the end of the statement (but "
"before any statement-level <literal>AFTER</literal> triggers). These types "
"of triggers may only be defined on tables and foreign tables. Row-level "
"<literal>INSTEAD OF</literal> triggers may only be defined on views, and "
"fire immediately as each row in the view is identified as needing to be "
"operated on."
msgstr ""
"Триггеры также классифицируются в соответствии с тем, срабатывают ли они "
"<firstterm>до</firstterm>, <firstterm>после</firstterm> или "
"<firstterm>вместо</firstterm> операции. Они называются триггерами "
"<literal>BEFORE</literal>, <literal>AFTER</literal> и <literal>INSTEAD OF</"
"literal>, соответственно. Триггеры <literal>BEFORE</literal> уровня "
"оператора срабатывают до того, как оператор начинает делать что-либо, в то "
"время как триггеры <literal>AFTER</literal> уровня оператора срабатывают в "
"самом конце работы оператора. Эти типы триггеров могут быть определены для "
"таблиц или представлений. Триггеры <literal>BEFORE</literal> уровня строки "
"срабатывают непосредственно перед обработкой конкретной строки, в то время "
"как триггеры <literal>AFTER</literal> уровня строки срабатывают в конце "
"работы всего оператора (но до любого из триггеров <literal>AFTER</literal> "
"уровня оператора). Эти типы триггеров могут определяться только для таблиц и "
"сторонних таблиц. Триггеры <literal>INSTEAD OF</literal> уровня строки могут "
"определяться только для представлений и срабатывают для каждой строки, сразу "
"после того как строка представления идентифицирована как нуждающаяся в "
"обработке."

#. +> REL9_6_3 REL9_6
#: trigger.xml:125(para)
msgid ""
"If an <command>INSERT</command> contains an <literal>ON CONFLICT DO UPDATE</"
"literal> clause, it is possible that the effects of all row-level "
"<literal>BEFORE</literal> <command>INSERT</command> triggers and all row-"
"level <literal>BEFORE</literal> <command>UPDATE</command> triggers can both "
"be applied in a way that is apparent from the final state of the updated "
"row, if an <varname>EXCLUDED</varname> column is referenced. There need not "
"be an <varname>EXCLUDED</varname> column reference for both sets of row-"
"level <literal>BEFORE</literal> triggers to execute, though. The possibility "
"of surprising outcomes should be considered when there are both "
"<literal>BEFORE</literal> <command>INSERT</command> and <literal>BEFORE</"
"literal> <command>UPDATE</command> row-level triggers that both affect a row "
"being inserted/updated (this can still be problematic if the modifications "
"are more or less equivalent if they're not also idempotent). Note that "
"statement-level <command>UPDATE</command> triggers are executed when "
"<literal>ON CONFLICT DO UPDATE</literal> is specified, regardless of whether "
"or not any rows were affected by the <command>UPDATE</command> (and "
"regardless of whether the alternative <command>UPDATE</command> path was "
"ever taken). An <command>INSERT</command> with an <literal>ON CONFLICT DO "
"UPDATE</literal> clause will execute statement-level <literal>BEFORE</"
"literal> <command>INSERT</command> triggers first, then statement-level "
"<literal>BEFORE</literal> <command>UPDATE</command> triggers, followed by "
"statement-level <literal>AFTER</literal> <command>UPDATE</command> triggers "
"and finally statement-level <literal>AFTER</literal> <command>INSERT</"
"command> triggers."
msgstr ""
"Если запрос <command>INSERT</command> содержит предложение <literal>ON "
"CONFLICT DO UPDATE</literal>, возможно совместное применение и триггеров "
"уровня строк <literal>BEFORE</literal> <command>INSERT</command>, и "
"триггеров уровня строк <literal>BEFORE</literal> <command>UPDATE</command>, "
"которое отразится в окончательном состоянии изменяемой строки, если в "
"запросе задействуются столбцы <varname>EXCLUDED</varname>. При этом "
"обращение к <varname>EXCLUDED</varname> не обязательно должно иметь место в "
"обоих наборах триггеров <literal>BEFORE</literal> на уровне строк. Следует "
"рассмотреть возможность получения неожиданного результата, когда имеются и "
"триггеры <literal>BEFORE</literal> <command>INSERT</command>, и "
"<literal>BEFORE</literal> <command>UPDATE</command> на уровне строки, и они "
"вместе воздействуют на добавляемую/изменяемую строку (это может быть "
"проблематично выявить, если изменения более или менее равнозначные, но при "
"этом не идемпотентные). Заметьте, что триггеры <command>UPDATE</command> "
"уровня оператора вызываются при <literal>ON CONFLICT DO UPDATE</literal> "
"независимо от того, будут ли изменены какие-либо строки в результате "
"<command>UPDATE</command> (и даже в случае, когда альтернативный путь "
"<command>UPDATE</command> вообще не выбирается). При выполнении запроса "
"<command>INSERT</command> с предложением <literal>ON CONFLICT DO UPDATE</"
"literal> сначала выполняются триггеры <literal>BEFORE</literal> "
"<command>INSERT</command>, затем триггеры <literal>BEFORE</literal> "
"<command>UPDATE</command>, потом триггеры <literal>AFTER</literal> "
"<command>UPDATE</command> и, наконец, <literal>AFTER</literal> "
"<command>INSERT</command> (речь идёт о триггерах на уровне операторов)."

#. +> REL9_6_3 REL9_6
#: trigger.xml:299(para)
msgid ""
"Each programming language that supports triggers has its own method for "
"making the trigger input data available to the trigger function. This input "
"data includes the type of trigger event (e.g., <command>INSERT</command> or "
"<command>UPDATE</command>) as well as any arguments that were listed in "
"<command>CREATE TRIGGER</command>. For a row-level trigger, the input data "
"also includes the <varname>NEW</varname> row for <command>INSERT</command> "
"and <command>UPDATE</command> triggers, and/or the <varname>OLD</varname> "
"row for <command>UPDATE</command> and <command>DELETE</command> triggers. "
"Statement-level triggers do not currently have any way to examine the "
"individual row(s) modified by the statement."
msgstr ""
"У каждого языка программирования, поддерживающего триггеры, есть свой "
"собственный метод доступа из триггерной функции к входным данным триггера. "
"Входные данные триггера включают в себя тип события (например, "
"<command>INSERT</command> или <command>UPDATE</command>), а также любые "
"аргументы, перечисленные в <command>CREATE TRIGGER</command>. Для триггеров "
"уровня строки входные данные также включают строку <varname>NEW</varname> "
"для триггеров <command>INSERT</command> и <command>UPDATE</command>, и/или "
"строку <varname>OLD</varname> для триггеров <command>UPDATE</command> и "
"<command>DELETE</command>. Триггеры уровня оператора в настоящее время не "
"имеют возможностей для проверки отдельных строк, модифицированных оператором."

#. +> REL9_6_3 REL9_6
#: trigger.xml:439(programlisting)
#, no-wrap
msgid ""
"typedef struct TriggerData\n"
"{\n"
"    NodeTag       type;\n"
"    TriggerEvent  tg_event;\n"
"    Relation      tg_relation;\n"
"    HeapTuple     tg_trigtuple;\n"
"    HeapTuple     tg_newtuple;\n"
"    Trigger      *tg_trigger;\n"
"    Buffer        tg_trigtuplebuf;\n"
"    Buffer        tg_newtuplebuf;\n"
"} TriggerData;"
msgstr ""
"typedef struct TriggerData\n"
"{\n"
"    NodeTag       type;\n"
"    TriggerEvent  tg_event;\n"
"    Relation      tg_relation;\n"
"    HeapTuple     tg_trigtuple;\n"
"    HeapTuple     tg_newtuple;\n"
"    Trigger      *tg_trigger;\n"
"    Buffer        tg_trigtuplebuf;\n"
"    Buffer        tg_newtuplebuf;\n"
"} TriggerData;"

#. +> REL9_6_3 REL9_6
#: trigger.xml:614(programlisting)
#, no-wrap
msgid ""
"typedef struct Trigger\n"
"{\n"
"    Oid         tgoid;\n"
"    char       *tgname;\n"
"    Oid         tgfoid;\n"
"    int16       tgtype;\n"
"    char        tgenabled;\n"
"    bool        tgisinternal;\n"
"    Oid         tgconstrrelid;\n"
"    Oid         tgconstrindid;\n"
"    Oid         tgconstraint;\n"
"    bool        tgdeferrable;\n"
"    bool        tginitdeferred;\n"
"    int16       tgnargs;\n"
"    int16       tgnattr;\n"
"    int16      *tgattr;\n"
"    char      **tgargs;\n"
"    char       *tgqual;\n"
"} Trigger;"
msgstr ""
"typedef struct Trigger\n"
"{\n"
"    Oid         tgoid;\n"
"    char       *tgname;\n"
"    Oid         tgfoid;\n"
"    int16       tgtype;\n"
"    char        tgenabled;\n"
"    bool        tgisinternal;\n"
"    Oid         tgconstrrelid;\n"
"    Oid         tgconstrindid;\n"
"    Oid         tgconstraint;\n"
"    bool        tgdeferrable;\n"
"    bool        tginitdeferred;\n"
"    int16       tgnargs;\n"
"    int16       tgnattr;\n"
"    int16      *tgattr;\n"
"    char      **tgargs;\n"
"    char       *tgqual;\n"
"} Trigger;"
