# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-08-09 15:59+0300\n"
"PO-Revision-Date: 2017-05-12 10:49+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: backup.xml:5(title)
msgid "Backup and Restore"
msgstr "Резервное копирование и восстановление"

#: backup.xml:7(indexterm)
msgid "<primary>backup</primary>"
msgstr "<primary>резервная копия</primary>"

#: backup.xml:9(para)
msgid ""
"As with everything that contains valuable data, <productname>PostgreSQL</"
"productname> databases should be backed up regularly. While the procedure is "
"essentially simple, it is important to have a clear understanding of the "
"underlying techniques and assumptions."
msgstr ""
"Как и всё, что содержит важные данные, базы данных <productname>PostgreSQL</"
"productname> следует регулярно сохранять в резервной копии. Хотя эта "
"процедура по существу проста, важно чётко понимать лежащие в её основе "
"приёмы и положения."

#: backup.xml:20(para)
msgid "<acronym>SQL</acronym> dump"
msgstr "Выгрузка в <acronym>SQL</acronym>"

#: backup.xml:21(para)
msgid "File system level backup"
msgstr "Копирование на уровне файлов"

#: backup.xml:22(para)
msgid "Continuous archiving"
msgstr "Непрерывное архивирование"

#: backup.xml:16(para)
msgid ""
"There are three fundamentally different approaches to backing up "
"<productname>PostgreSQL</productname> data: <placeholder-1/> Each has its "
"own strengths and weaknesses; each is discussed in turn in the following "
"sections."
msgstr ""
"Существует три фундаментально разных подхода к резервному копированию данных "
"в <productname>PostgreSQL</productname>: <placeholder-1/> Каждый из них "
"имеет свои сильные и слабые стороны; все они обсуждаются в следующих "
"разделах."

#: backup.xml:29(title)
msgid "<acronym>SQL</acronym> Dump"
msgstr "Выгрузка в <acronym>SQL</acronym>"

#: backup.xml:31(para)
msgid ""
"The idea behind this dump method is to generate a file with SQL commands "
"that, when fed back to the server, will recreate the database in the same "
"state as it was at the time of the dump. <productname>PostgreSQL</"
"productname> provides the utility program <xref linkend=\"app-pgdump\"/> for "
"this purpose. The basic usage of this command is: <synopsis>\n"
"pg_dump <replaceable class=\"parameter\">dbname</replaceable> &gt; "
"<replaceable class=\"parameter\">outfile</replaceable>\n"
"</synopsis> As you see, <application>pg_dump</application> writes its result "
"to the standard output. We will see below how this can be useful. While the "
"above command creates a text file, <application>pg_dump</application> can "
"create files in other formats that allow for parallelism and more fine-"
"grained control of object restoration."
msgstr ""
"Идея, стоящая за этим методом, заключается в генерации текстового файла с "
"командами SQL, которые при выполнении на сервере пересоздадут базу данных в "
"том же самом состоянии, в котором она была на момент выгрузки. "
"<productname>PostgreSQL</productname> предоставляет для этой цели "
"вспомогательную программу <xref linkend=\"app-pgdump\"/>. Простейшее "
"применение этой программы выглядит так: <synopsis>\n"
"pg_dump <replaceable class=\"parameter\">имя_базы</replaceable> &gt; "
"<replaceable class=\"parameter\">выходной_файл</replaceable>\n"
"</synopsis> Как видите, <application>pg_dump</application> записывает "
"результаты своей работы в устройство стандартного вывода. Далее будет "
"рассмотрено, чем это может быть полезно. В то время как вышеупомянутая "
"команда создаёт текстовый файл, <application>pg_dump</application> может "
"создать файлы и в других форматах, которые допускают параллельную обработку "
"и более гибкое управление восстановлением объектов."

#: backup.xml:48(para)
msgid ""
"<application>pg_dump</application> is a regular <productname>PostgreSQL</"
"productname> client application (albeit a particularly clever one). This "
"means that you can perform this backup procedure from any remote host that "
"has access to the database. But remember that <application>pg_dump</"
"application> does not operate with special permissions. In particular, it "
"must have read access to all tables that you want to back up, so in order to "
"back up the entire database you almost always have to run it as a database "
"superuser. (If you do not have sufficient privileges to back up the entire "
"database, you can still back up portions of the database to which you do "
"have access using options such as <option>-n <replaceable>schema</"
"replaceable></option> or <option>-t <replaceable>table</replaceable></"
"option>.)"
msgstr ""
"Программа <application>pg_dump</application> является для "
"<productname>PostgreSQL</productname> обычным клиентским приложением (хотя и "
"весьма умным). Это означает, что вы можете выполнять процедуру резервного "
"копирования с любого удалённого компьютера, если имеете доступ к нужной базе "
"данных. Но помните, что <application>pg_dump</application> не использует для "
"своей работы какие-то специальные привилегии. В частности, ей обычно "
"требуется доступ на чтение всех таблиц, которые вы хотите выгрузить, так что "
"для копирования всей базы данных практически всегда её нужно запускать с "
"правами суперпользователя СУБД. (Если у вас нет достаточных прав для "
"резервного копирования всей базы данных, вы, тем не менее, можете сделать "
"резервную копию той части базы, доступ к которой у вас есть, используя такие "
"параметры, как <option>-n <replaceable>схема</replaceable></option> или "
"<option>-t <replaceable>таблица</replaceable></option>.)"

#: backup.xml:63(para)
msgid ""
"To specify which database server <application>pg_dump</application> should "
"contact, use the command line options <option>-h <replaceable>host</"
"replaceable></option> and <option>-p <replaceable>port</replaceable></"
"option>. The default host is the local host or whatever your <envar>PGHOST</"
"envar> environment variable specifies. Similarly, the default port is "
"indicated by the <envar>PGPORT</envar> environment variable or, failing "
"that, by the compiled-in default. (Conveniently, the server will normally "
"have the same compiled-in default.)"
msgstr ""
"Указать, к какому серверу должна подключаться программа "
"<application>pg_dump</application>, можно с помощью аргументов командной "
"строки <option>-h <replaceable>сервер</replaceable></option> и <option>-p "
"<replaceable>порт</replaceable></option>. По умолчанию в качестве сервера "
"выбирается localhost или значение, указанное в переменной окружения "
"<envar>PGHOST</envar>. Подобным образом, по умолчанию используется порт, "
"заданный в переменной окружения <envar>PGPORT</envar>, а если она не задана, "
"то порт, указанный по умолчанию при компиляции. (Для удобства при компиляции "
"сервера обычно устанавливается то же значение по умолчанию.)"

#: backup.xml:75(para)
msgid ""
"Like any other <productname>PostgreSQL</productname> client application, "
"<application>pg_dump</application> will by default connect with the database "
"user name that is equal to the current operating system user name. To "
"override this, either specify the <option>-U</option> option or set the "
"environment variable <envar>PGUSER</envar>. Remember that "
"<application>pg_dump</application> connections are subject to the normal "
"client authentication mechanisms (which are described in <xref linkend="
"\"client-authentication\"/>)."
msgstr ""
"Как и любое другое клиентское приложение <productname>PostgreSQL</"
"productname>, <application>pg_dump</application> по умолчанию будет "
"подключаться к базе данных с именем пользователя, совпадающим с именем "
"текущего пользователя операционной системы. Чтобы переопределить имя, либо "
"добавьте параметр <option>-U</option>, либо установите переменную окружения "
"<envar>PGUSER</envar>. Помните, что <application>pg_dump</application> "
"подключается к серверу через обычные механизмы проверки подлинности клиента "
"(которые описываются в <xref remap=\"6\" linkend=\"client-authentication\"/"
">)."

#: backup.xml:86(para)
msgid ""
"An important advantage of <application>pg_dump</application> over the other "
"backup methods described later is that <application>pg_dump</application>'s "
"output can generally be re-loaded into newer versions of "
"<productname>PostgreSQL</productname>, whereas file-level backups and "
"continuous archiving are both extremely server-version-specific. "
"<application>pg_dump</application> is also the only method that will work "
"when transferring a database to a different machine architecture, such as "
"going from a 32-bit to a 64-bit server."
msgstr ""
"Важное преимущество <application>pg_dump</application> в сравнении с другими "
"методами резервного копирования, описанными далее, состоит в том, что вывод "
"<application>pg_dump</application> обычно можно загрузить в более новые "
"версии <productname>PostgreSQL</productname>, в то время как резервная копия "
"на уровне файловой системы и непрерывное архивирование жёстко зависят от "
"версии сервера. Также, только метод с применением <application>pg_dump</"
"application> будет работать при переносе базы данных на другую машинную "
"архитектуру, например, при переносе с 32-битной на 64-битную версию сервера."

#: backup.xml:96(para)
msgid ""
"Dumps created by <application>pg_dump</application> are internally "
"consistent, meaning, the dump represents a snapshot of the database at the "
"time <application>pg_dump</application> began running. <application>pg_dump</"
"application> does not block other operations on the database while it is "
"working. (Exceptions are those operations that need to operate with an "
"exclusive lock, such as most forms of <command>ALTER TABLE</command>.)"
msgstr ""
"Дампы, создаваемые <application>pg_dump</application>, являются внутренне "
"согласованными, то есть, дамп представляет собой снимок базы данных на "
"момент начала запуска <application>pg_dump</application>. "
"<application>pg_dump</application> не блокирует другие операции с базой "
"данных во время своей работы. (Исключение составляют операции, которым нужна "
"исключительная блокировка, как например, большинство форм команды "
"<command>ALTER TABLE</command>.)"

#: backup.xml:106(title)
msgid "Restoring the Dump"
msgstr "Восстановление дампа"

#: backup.xml:108(para)
msgid ""
"Text files created by <application>pg_dump</application> are intended to be "
"read in by the <application>psql</application> program. The general command "
"form to restore a dump is <synopsis>\n"
"psql <replaceable class=\"parameter\">dbname</replaceable> &lt; <replaceable "
"class=\"parameter\">infile</replaceable>\n"
"</synopsis> where <replaceable class=\"parameter\">infile</replaceable> is "
"the file output by the <application>pg_dump</application> command. The "
"database <replaceable class=\"parameter\">dbname</replaceable> will not be "
"created by this command, so you must create it yourself from "
"<literal>template0</literal> before executing <application>psql</"
"application> (e.g., with <literal>createdb -T template0 <replaceable class="
"\"parameter\">dbname</replaceable></literal>). <application>psql</"
"application> supports options similar to <application>pg_dump</application> "
"for specifying the database server to connect to and the user name to use. "
"See the <xref linkend=\"app-psql\"/> reference page for more information. "
"Non-text file dumps are restored using the <xref linkend=\"app-pgrestore\"/> "
"utility."
msgstr ""
"Текстовые файлы, созданные <application>pg_dump</application> "
"предназначаются для последующего чтения программой <application>psql</"
"application>. Общий вид команды для восстановления дампа: <synopsis>\n"
"psql <replaceable class=\"parameter\">имя_базы</replaceable> &lt; "
"<replaceable class=\"parameter\">входной_файл</replaceable>\n"
"</synopsis> где <replaceable class=\"parameter\">входной_файл</replaceable> "
"&mdash; это файл, содержащий вывод команды <application>pg_dump</"
"application>. База данных, заданная параметром <replaceable class=\"parameter"
"\">имя_базы</replaceable>, не будет создана данной командой, так что вы "
"должны создать её сами из базы <literal>template0</literal> перед запуском "
"<application>psql</application> (например, с помощью команды "
"<literal>createdb -T template0 <replaceable class=\"parameter\">имя_базы</"
"replaceable></literal>). Программа <application>psql</application> принимает "
"параметры, указывающие сервер, к которому осуществляется подключение, и имя "
"пользователя, подобно <application>pg_dump</application>. За дополнительными "
"сведениями обратитесь к справке по <xref linkend=\"app-pgrestore\"/>. Копии "
"не текстовые восстанавливаются утилитой <xref linkend=\"app-pgrestore\"/>."

#: backup.xml:129(para)
msgid ""
"Before restoring an SQL dump, all the users who own objects or were granted "
"permissions on objects in the dumped database must already exist. If they do "
"not, the restore will fail to recreate the objects with the original "
"ownership and/or permissions. (Sometimes this is what you want, but usually "
"it is not.)"
msgstr ""
"Перед восстановлением SQL-дампа все пользователи, которые владели объектами "
"или имели права на объекты в выгруженной базе данных, должны уже "
"существовать. Если их нет, при восстановлении будут ошибки пересоздания "
"объектов с изначальными владельцами и/или правами. (Иногда это желаемый "
"результат, но обычно нет)."

#: backup.xml:144(programlisting)
#, no-wrap
msgid "psql --set ON_ERROR_STOP=on dbname &lt; infile"
msgstr "psql --set ON_ERROR_STOP=on имя_базы &lt; входной_файл"

#: backup.xml:137(para)
msgid ""
"By default, the <application>psql</application> script will continue to "
"execute after an SQL error is encountered. You might wish to run "
"<application>psql</application> with the <literal>ON_ERROR_STOP</literal> "
"variable set to alter that behavior and have <application>psql</application> "
"exit with an exit status of 3 if an SQL error occurs: <placeholder-1/> "
"Either way, you will only have a partially restored database. Alternatively, "
"you can specify that the whole dump should be restored as a single "
"transaction, so the restore is either fully completed or fully rolled back. "
"This mode can be specified by passing the <option>-1</option> or <option>--"
"single-transaction</option> command-line options to <application>psql</"
"application>. When using this mode, be aware that even a minor error can "
"rollback a restore that has already run for many hours. However, that might "
"still be preferable to manually cleaning up a complex database after a "
"partially restored dump."
msgstr ""
"По умолчанию, если происходит ошибка SQL, программа <application>psql</"
"application> продолжает выполнение. Если же запустить <application>psql</"
"application> с установленной переменной <literal>ON_ERROR_STOP</literal>, "
"это поведение поменяется и <application>psql</application> завершится с "
"кодом 3 в случае возникновения ошибки SQL: <placeholder-1/> В любом случае, "
"вы получите только частично восстановленную базу данных. В качестве "
"альтернативы можно указать, что весь дамп должен быть восстановлен в одной "
"транзакции, так что восстановление либо полностью выполнится, либо полностью "
"отменится. Включить данный режим можно, передав <application>psql</"
"application> аргумент <option>-1</option> или <option>--single-transaction</"
"option>. Выбирая этот режим, учтите, что даже незначительная ошибка может "
"привести к откату восстановления, которое могло продолжаться несколько "
"часов. Однако, это всё же может быть предпочтительней, чем вручную вычищать "
"сложную базу данных после частично восстановленного дампа."

#: backup.xml:163(programlisting)
#, no-wrap
msgid "pg_dump -h <replaceable>host1</replaceable> <replaceable>dbname</replaceable> | psql -h <replaceable>host2</replaceable> <replaceable>dbname</replaceable>"
msgstr "pg_dump -h <replaceable>host1</replaceable> <replaceable>имя_базы</replaceable> | psql -h <replaceable>host2</replaceable> <replaceable>имя_базы</replaceable>"

#: backup.xml:159(para)
msgid ""
"The ability of <application>pg_dump</application> and <application>psql</"
"application> to write to or read from pipes makes it possible to dump a "
"database directly from one server to another, for example: <placeholder-1/>"
msgstr ""
"Благодаря способности <application>pg_dump</application> и "
"<application>psql</application> писать и читать каналы ввода/вывода, можно "
"скопировать базу данных непосредственно с одного сервера на другой, "
"например: <placeholder-1/>"

#: backup.xml:169(para)
msgid ""
"The dumps produced by <application>pg_dump</application> are relative to "
"<literal>template0</literal>. This means that any languages, procedures, "
"etc. added via <literal>template1</literal> will also be dumped by "
"<application>pg_dump</application>. As a result, when restoring, if you are "
"using a customized <literal>template1</literal>, you must create the empty "
"database from <literal>template0</literal>, as in the example above."
msgstr ""
"Дампы, которые выдаёт <application>pg_dump</application>, содержат "
"определения относительно <literal>template0</literal>. Это означает, что "
"любые языки, процедуры и т. п., добавленные в базу через <literal>template1</"
"literal>, <application>pg_dump</application> также выгрузит в дамп. Как "
"следствие, если при восстановлении вы используете модифицированный "
"<literal>template1</literal>, вы должны создать пустую базу данных из "
"<literal>template0</literal>, как показано в примере выше."

#: backup.xml:180(para)
msgid ""
"After restoring a backup, it is wise to run <xref linkend=\"sql-analyze\"/> "
"on each database so the query optimizer has useful statistics; see <xref "
"linkend=\"vacuum-for-statistics\"/> and <xref linkend=\"autovacuum\"/> for "
"more information. For more advice on how to load large amounts of data into "
"<productname>PostgreSQL</productname> efficiently, refer to <xref linkend="
"\"populate\"/>."
msgstr ""
"После восстановления резервной копии имеет смысл запустить <xref linkend="
"\"sql-analyze\"/> для каждой базы данных, чтобы оптимизатор запросов получил "
"полезную статистику; за подробностями обратитесь к <xref remap=\"3\" linkend="
"\"vacuum-for-statistics\"/> и <xref remap=\"3\" linkend=\"autovacuum\"/>. "
"Другие советы по эффективной загрузке больших объёмов данных в "
"<productname>PostgreSQL</productname> вы можете найти в <xref remap=\"6\" "
"linkend=\"populate\"/>."

#: backup.xml:193(title)
msgid "Using <application>pg_dumpall</application>"
msgstr "Использование <application>pg_dumpall</application>"

#: backup.xml:195(para)
msgid ""
"<application>pg_dump</application> dumps only a single database at a time, "
"and it does not dump information about roles or tablespaces (because those "
"are cluster-wide rather than per-database). To support convenient dumping of "
"the entire contents of a database cluster, the <xref linkend=\"app-pg-dumpall"
"\"/> program is provided. <application>pg_dumpall</application> backs up "
"each database in a given cluster, and also preserves cluster-wide data such "
"as role and tablespace definitions. The basic usage of this command is: "
"<synopsis>\n"
"pg_dumpall &gt; <replaceable>outfile</replaceable>\n"
"</synopsis> The resulting dump can be restored with <application>psql</"
"application>: <synopsis>\n"
"psql -f <replaceable class=\"parameter\">infile</replaceable> postgres\n"
"</synopsis> (Actually, you can specify any existing database name to start "
"from, but if you are loading into an empty cluster then <literal>postgres</"
"literal> should usually be used.) It is always necessary to have database "
"superuser access when restoring a <application>pg_dumpall</application> "
"dump, as that is required to restore the role and tablespace information. If "
"you use tablespaces, make sure that the tablespace paths in the dump are "
"appropriate for the new installation."
msgstr ""
"Программа <application>pg_dump</application> выгружает только одну базу "
"данных в один момент времени и не включает в дамп информацию о ролях и "
"табличных пространствах (так как это информация уровня кластера, а не самой "
"базы данных). Для удобства создания дампа всего содержимого кластера баз "
"данных предоставляется программа <xref linkend=\"app-pg-dumpall\"/>, которая "
"делает резервную копию всех баз данных кластера, а также сохраняет данные "
"уровня кластера, такие как роли и определения табличных пространств. Простое "
"использование этой команды: <synopsis>\n"
"pg_dumpall &gt; <replaceable>выходной_файл</replaceable>\n"
"</synopsis> Полученную копию можно восстановить с помощью <application>psql</"
"application>: <synopsis>\n"
"psql -f <replaceable class=\"parameter\">входной_файл</replaceable> "
"postgres\n"
"</synopsis> (В принципе, здесь в качестве начальной базы данных можно "
"указать имя любой существующей базы, но если вы загружаете копию в пустой "
"кластер, обычно нужно использовать <literal>postgres</literal>). "
"Восстанавливать дамп, который выдала <application>pg_dumpall</application>, "
"всегда необходимо с правами суперпользователя, так как они требуются для "
"восстановления информации о ролях и табличных пространствах. Если вы "
"используете табличные пространства, убедитесь, что пути к табличным "
"пространствам в дампе соответствуют новой среде."

#: backup.xml:220(para)
msgid ""
"<application>pg_dumpall</application> works by emitting commands to re-"
"create roles, tablespaces, and empty databases, then invoking "
"<application>pg_dump</application> for each database. This means that while "
"each database will be internally consistent, the snapshots of different "
"databases are not synchronized."
msgstr ""
"<application>pg_dumpall</application> выдаёт команды, которые заново создают "
"роли, табличные пространства и пустые базы данных, а затем вызывает для "
"каждой базы <application>pg_dump</application>. Таким образом, хотя каждая "
"база данных будет внутренне согласованной, состояние разных баз не будет "
"синхронным."

#: backup.xml:228(para)
msgid ""
"Cluster-wide data can be dumped alone using the <application>pg_dumpall</"
"application> <option>--globals-only</option> option. This is necessary to "
"fully backup the cluster if running the <application>pg_dump</application> "
"command on individual databases."
msgstr ""
"Только глобальные данные кластера можно выгрузить, передав "
"<application>pg_dumpall</application> ключ <option>--globals-only</option>. "
"Это необходимо, чтобы полностью скопировать кластер, когда "
"<application>pg_dump</application> выполняется для отдельных баз данных."

#: backup.xml:237(title)
msgid "Handling Large Databases"
msgstr "Управление большими базами данных"

#: backup.xml:239(para)
msgid ""
"Some operating systems have maximum file size limits that cause problems "
"when creating large <application>pg_dump</application> output files. "
"Fortunately, <application>pg_dump</application> can write to the standard "
"output, so you can use standard Unix tools to work around this potential "
"problem. There are several possible methods:"
msgstr ""
"Некоторые операционные системы накладывают ограничение на максимальный "
"размер файла, что приводит к проблемам при создании больших файлов с помощью "
"<application>pg_dump</application>. К счастью, <application>pg_dump</"
"application> может писать в стандартный вывод, так что вы можете "
"использовать стандартные инструменты Unix для того, чтобы избежать "
"потенциальных проблем. Вот несколько возможных методов:"

#: backup.xml:248(title)
msgid "Use compressed dumps."
msgstr "Используйте сжатые дампы."

#: backup.xml:253(programlisting)
#, no-wrap
msgid "pg_dump <replaceable class=\"parameter\">dbname</replaceable> | gzip &gt; <replaceable class=\"parameter\">filename</replaceable>.gz"
msgstr "pg_dump <replaceable class=\"parameter\">имя_базы</replaceable> | gzip &gt; <replaceable class=\"parameter\">имя_файла</replaceable>.gz"

#: backup.xml:259(programlisting)
#, no-wrap
msgid "gunzip -c <replaceable class=\"parameter\">filename</replaceable>.gz | psql <replaceable class=\"parameter\">dbname</replaceable>"
msgstr "gunzip -c <replaceable class=\"parameter\">имя_файла</replaceable>.gz | psql <replaceable class=\"parameter\">имя_базы</replaceable>"

#: backup.xml:265(programlisting)
#, no-wrap
msgid "cat <replaceable class=\"parameter\">filename</replaceable>.gz | gunzip | psql <replaceable class=\"parameter\">dbname</replaceable>"
msgstr "cat <replaceable class=\"parameter\">имя_файла</replaceable>.gz | gunzip | psql <replaceable class=\"parameter\">имя_базы</replaceable>"

#: backup.xml:249(para)
msgid ""
"You can use your favorite compression program, for example "
"<application>gzip</application>: <placeholder-1/> Reload with: "
"<placeholder-2/> or: <placeholder-3/>"
msgstr ""
"Вы можете использовать предпочитаемую программу сжатия, например "
"<application>gzip</application>: <placeholder-1/> Затем загрузить сжатый "
"дамп можно командой: <placeholder-2/> или: <placeholder-3/>"

#: backup.xml:272(title)
msgid "Use <command>split</command>."
msgstr "Используйте <command>split</command>."

#: backup.xml:279(programlisting)
#, no-wrap
msgid "pg_dump <replaceable class=\"parameter\">dbname</replaceable> | split -b 1m - <replaceable class=\"parameter\">filename</replaceable>"
msgstr "pg_dump <replaceable class=\"parameter\">имя_базы</replaceable> | split -b 1m - <replaceable class=\"parameter\">имя_файла</replaceable>"

#: backup.xml:285(programlisting)
#, no-wrap
msgid "cat <replaceable class=\"parameter\">filename</replaceable>* | psql <replaceable class=\"parameter\">dbname</replaceable>"
msgstr "cat <replaceable class=\"parameter\">имя_файла</replaceable>* | psql <replaceable class=\"parameter\">имя_базы</replaceable>"

#: backup.xml:273(para)
msgid ""
"The <command>split</command> command allows you to split the output into "
"smaller files that are acceptable in size to the underlying file system. For "
"example, to make chunks of 1 megabyte: <placeholder-1/> Reload with: "
"<placeholder-2/>"
msgstr ""
"Команда <command>split</command> может разбивать выводимые данные на "
"небольшие файлы, размер которых удовлетворяет ограничению нижележащей "
"файловой системы. Например, чтобы получить части по 1 мегабайту: "
"<placeholder-1/> Восстановить их можно так: <placeholder-2/>"

#: backup.xml:292(title)
msgid "Use <application>pg_dump</application>'s custom dump format."
msgstr ""
"Используйте специальный формат дампа <application>pg_dump</application>."

#: backup.xml:301(programlisting)
#, no-wrap
msgid "pg_dump -Fc <replaceable class=\"parameter\">dbname</replaceable> &gt; <replaceable class=\"parameter\">filename</replaceable>"
msgstr "pg_dump -Fc <replaceable class=\"parameter\">имя_базы</replaceable> &gt; <replaceable class=\"parameter\">имя_файла</replaceable>"

#: backup.xml:308(programlisting)
#, no-wrap
msgid "pg_restore -d <replaceable class=\"parameter\">dbname</replaceable> <replaceable class=\"parameter\">filename</replaceable>"
msgstr "pg_restore -d <replaceable class=\"parameter\">имя_базы</replaceable> <replaceable class=\"parameter\">имя_файла</replaceable>"

#: backup.xml:293(para)
msgid ""
"If <productname>PostgreSQL</productname> was built on a system with the "
"<application>zlib</application> compression library installed, the custom "
"dump format will compress data as it writes it to the output file. This will "
"produce dump file sizes similar to using <command>gzip</command>, but it has "
"the added advantage that tables can be restored selectively. The following "
"command dumps a database using the custom dump format: <placeholder-1/> A "
"custom-format dump is not a script for <application>psql</application>, but "
"instead must be restored with <application>pg_restore</application>, for "
"example: <placeholder-2/> See the <xref linkend=\"app-pgdump\"/> and <xref "
"linkend=\"app-pgrestore\"/> reference pages for details."
msgstr ""
"Если при сборке <productname>PostgreSQL</productname> была подключена "
"библиотека <application>zlib</application>, дамп в специальном формате будет "
"записываться в файл в сжатом виде. В таком формате размер файла дампа будет "
"близок к размеру, полученному с применением <command>gzip</command>, но он "
"лучше тем, что позволяет восстанавливать таблицы выборочно. Следующая "
"команда выгружает базу данных в специальном формате: <placeholder-1/> Дамп в "
"специальном формате не является скриптом для <application>psql</application> "
"и должен восстанавливаться с помощью команды <application>pg_restore</"
"application>, например: <placeholder-2/> За подробностями обратитесь к "
"справке по командам <xref linkend=\"app-pgdump\"/> и <xref linkend=\"app-"
"pgrestore\"/>."

#: backup.xml:317(para)
msgid ""
"For very large databases, you might need to combine <command>split</command> "
"with one of the other two approaches."
msgstr ""
"Для очень больших баз данных может понадобиться сочетать <command>split</"
"command> с одним из двух других методов."

#: backup.xml:323(title)
msgid "Use <application>pg_dump</application>'s parallel dump feature."
msgstr ""
"Используйте возможность параллельной выгрузки в <application>pg_dump</"
"application>."

#: backup.xml:331(programlisting)
#, no-wrap
msgid "pg_dump -j <replaceable class=\"parameter\">num</replaceable> -F d -f <replaceable class=\"parameter\">out.dir</replaceable> <replaceable class=\"parameter\">dbname</replaceable>"
msgstr "pg_dump -j <replaceable class=\"parameter\">число</replaceable> -F d -f <replaceable class=\"parameter\">выходной_каталог</replaceable> <replaceable class=\"parameter\">имя_базы</replaceable>"

#: backup.xml:324(para)
msgid ""
"To speed up the dump of a large database, you can use <application>pg_dump</"
"application>'s parallel mode. This will dump multiple tables at the same "
"time. You can control the degree of parallelism with the <command>-j</"
"command> parameter. Parallel dumps are only supported for the \"directory\" "
"archive format. <placeholder-1/> You can use <command>pg_restore -j</"
"command> to restore a dump in parallel. This will work for any archive of "
"either the \"custom\" or the \"directory\" archive mode, whether or not it "
"has been created with <command>pg_dump -j</command>."
msgstr ""
"Чтобы ускорить выгрузку большой БД, вы можете использовать режим "
"параллельной выгрузки в <application>pg_dump</application>. При этом "
"одновременно будут выгружаться несколько таблиц. Управлять числом "
"параллельных заданий позволяет параметр <command>-j</command>. Параллельная "
"выгрузка поддерживается только для формата архива в каталоге. <placeholder-1/"
"> Вы также можете восстановить копию в параллельном режиме с помощью "
"<command>pg_restore -j</command>. Это поддерживается для любого архива в "
"формате каталога или специальном формате, даже если архив создавался не "
"командой <command>pg_dump -j</command>."

#: backup.xml:344(title)
msgid "File System Level Backup"
msgstr "Резервное копирование на уровне файлов"

#: backup.xml:353(programlisting)
#, no-wrap
msgid "tar -cf backup.tar /usr/local/pgsql/data"
msgstr "tar -cf backup.tar /usr/local/pgsql/data"

#: backup.xml:346(para)
msgid ""
"An alternative backup strategy is to directly copy the files that "
"<productname>PostgreSQL</productname> uses to store the data in the "
"database; <xref linkend=\"creating-cluster\"/> explains where these files "
"are located. You can use whatever method you prefer for doing file system "
"backups; for example: <placeholder-1/>"
msgstr ""
"Альтернативной стратегией резервного копирования является непосредственное "
"копирование файлов, в которых <productname>PostgreSQL</productname> хранит "
"содержимое базы данных; в <xref remap=\"6\" linkend=\"creating-cluster\"/> "
"рассказывается, где находятся эти файлы. Вы можете использовать любой способ "
"копирования файлов по желанию, например: <placeholder-1/>"

#: backup.xml:365(para)
msgid ""
"The database server <emphasis>must</emphasis> be shut down in order to get a "
"usable backup. Half-way measures such as disallowing all connections will "
"<emphasis>not</emphasis> work (in part because <command>tar</command> and "
"similar tools do not take an atomic snapshot of the state of the file "
"system, but also because of internal buffering within the server). "
"Information about stopping the server can be found in <xref linkend=\"server-"
"shutdown\"/>. Needless to say, you also need to shut down the server before "
"restoring the data."
msgstr ""
"Чтобы полученная резервная копия была годной, сервер баз данных "
"<emphasis>должен</emphasis> быть остановлен. Такие полумеры, как запрещение "
"всех подключений к серверу, работать <emphasis>не</emphasis> будут (отчасти "
"потому что <command>tar</command> и подобные средства не получают мгновенный "
"снимок состояния файловой системы, но ещё и потому, что в сервере есть "
"внутренние буферы). Узнать о том, как остановить сервер, можно в <xref remap="
"\"6\" linkend=\"server-shutdown\"/>. Необходимо отметить, что сервер нужно "
"будет остановить и перед восстановлением данных."

#: backup.xml:379(para)
msgid ""
"If you have dug into the details of the file system layout of the database, "
"you might be tempted to try to back up or restore only certain individual "
"tables or databases from their respective files or directories. This will "
"<emphasis>not</emphasis> work because the information contained in these "
"files is not usable without the commit log files, <filename>pg_clog/*</"
"filename>, which contain the commit status of all transactions. A table file "
"is only usable with this information. Of course it is also impossible to "
"restore only a table and the associated <filename>pg_clog</filename> data "
"because that would render all other tables in the database cluster useless. "
"So file system backups only work for complete backup and restoration of an "
"entire database cluster."
msgstr ""
"Если вы ознакомились с внутренней организацией базы данных в файловой "
"системе, у вас может возникнуть соблазн скопировать или восстановить только "
"отдельные таблицы или базы данных в соответствующих файлах или каталогах. "
"Это <emphasis>не</emphasis> будет работать, потому что информацию, "
"содержащуюся в этих файлах, нельзя использовать без файлов журналов "
"транзакций, <filename>pg_clog/*</filename>, которые содержат состояние всех "
"транзакций. Без этих данных файлы таблиц непригодны к использованию. "
"Разумеется также невозможно восстановить только одну таблицу и "
"соответствующие данные <filename>pg_clog</filename>, потому что в результате "
"нерабочими станут все другие таблицы в кластере баз данных. Таким образом, "
"копирование на уровне файловой системы будет работать, только если "
"выполняется полное копирование и восстановление всего кластера баз данных."

#: backup.xml:358(para)
msgid ""
"There are two restrictions, however, which make this method impractical, or "
"at least inferior to the <application>pg_dump</application> method: "
"<placeholder-1/>"
msgstr ""
"Однако, существуют два ограничения, которые делают этот метод непрактичным "
"или как минимум менее предпочтительным по сравнению с <application>pg_dump</"
"application>: <placeholder-1/>"

#: backup.xml:398(para)
msgid ""
"An alternative file-system backup approach is to make a <quote>consistent "
"snapshot</quote> of the data directory, if the file system supports that "
"functionality (and you are willing to trust that it is implemented "
"correctly). The typical procedure is to make a <quote>frozen snapshot</"
"quote> of the volume containing the database, then copy the whole data "
"directory (not just parts, see above) from the snapshot to a backup device, "
"then release the frozen snapshot. This will work even while the database "
"server is running. However, a backup created in this way saves the database "
"files in a state as if the database server was not properly shut down; "
"therefore, when you start the database server on the backed-up data, it will "
"think the previous server instance crashed and will replay the WAL log. This "
"is not a problem; just be aware of it (and be sure to include the WAL files "
"in your backup). You can perform a <command>CHECKPOINT</command> before "
"taking the snapshot to reduce recovery time."
msgstr ""
"Ещё один подход к резервному копированию файловой системы заключается в "
"создании <quote>целостного снимка</quote> каталога с данными, если это "
"поддерживает файловая система (и вы склонны считать, что эта "
"функциональность реализована корректно). Типичная процедура включает "
"создание <quote>замороженного снимка</quote> тома, содержащего базу данных, "
"затем копирование всего каталога с данными (а не его избранных частей, см. "
"выше) из этого снимка на устройство резервного копирования, и наконец "
"освобождение замороженного снимка. При этом сервер базы данных может не "
"прекращать свою работу. Однако резервная копия, созданная таким способом, "
"содержит файлы базы данных в таком состоянии, как если бы сервер баз данных "
"не был остановлен штатным образом; таким образом, когда вы запустите сервер "
"баз данных с сохранёнными данными, он будет считать, что до этого процесс "
"сервера был прерван аварийно, и будет накатывать журнал WAL. Это не "
"проблема, просто имейте это в виду (и обязательно включите файлы WAL в "
"резервную копию). Чтобы сократить время восстановления, можно выполнить "
"команду <command>CHECKPOINT</command> перед созданием снимка."

#: backup.xml:417(para)
msgid ""
"If your database is spread across multiple file systems, there might not be "
"any way to obtain exactly-simultaneous frozen snapshots of all the volumes. "
"For example, if your data files and WAL log are on different disks, or if "
"tablespaces are on different file systems, it might not be possible to use "
"snapshot backup because the snapshots <emphasis>must</emphasis> be "
"simultaneous. Read your file system documentation very carefully before "
"trusting the consistent-snapshot technique in such situations."
msgstr ""
"Если ваша база данных размещена в нескольких файловых системах, получить в "
"точности одновременно замороженные снимки всех томов может быть невозможно. "
"Например, если файлы данных и журналы WAL находятся на разных дисках или "
"табличные пространства расположены в разных файловых системах, резервное "
"копирование со снимками может быть неприменимо, потому что снимки "
"<emphasis>должны</emphasis> быть одновременными. В таких ситуациях очень "
"внимательно изучите документацию по вашей файловой системе, прежде чем "
"довериться технологии согласованных снимков."

#: backup.xml:428(para)
msgid ""
"If simultaneous snapshots are not possible, one option is to shut down the "
"database server long enough to establish all the frozen snapshots. Another "
"option is to perform a continuous archiving base backup (<xref linkend="
"\"backup-base-backup\"/>) because such backups are immune to file system "
"changes during the backup. This requires enabling continuous archiving just "
"during the backup process; restore is done using continuous archive recovery "
"(<xref linkend=\"backup-pitr-recovery\"/>)."
msgstr ""
"Если одновременные снимки невозможны, остаётся вариант с остановкой сервера "
"баз данных на время, достаточное для получения всех замороженных снимков. "
"Другое возможное решение — получить базовую копию путём непрерывного "
"архивирования (см. <xref remap=\"4\" linkend=\"backup-base-backup\"/>), "
"такие резервные копии не могут пострадать от изменений файловой системы в "
"процессе резервного копирования. Для этого требуется включить непрерывное "
"архивирование только на время резервного копирования; для восстановления "
"применяется процедура восстановления из непрерывного архива (<xref linkend="
"\"backup-pitr-recovery\"/>)."

#: backup.xml:438(para)
msgid ""
"Another option is to use <application>rsync</application> to perform a file "
"system backup. This is done by first running <application>rsync</"
"application> while the database server is running, then shutting down the "
"database server long enough to do an <command>rsync --checksum</command>. "
"(<option>--checksum</option> is necessary because <command>rsync</command> "
"only has file modification-time granularity of one second.) The second "
"<application>rsync</application> will be quicker than the first, because it "
"has relatively little data to transfer, and the end result will be "
"consistent because the server was down. This method allows a file system "
"backup to be performed with minimal downtime."
msgstr ""
"Ещё один вариант — копировать содержимое файловой системы с помощью "
"<application>rsync</application>. Для этого <application>rsync</application> "
"запускается сначала во время работы сервера баз данных, а затем сервер "
"останавливается на время, достаточное для запуска <command>rsync --checksum</"
"command>. (Ключ <option>--checksum</option> необходим, потому что "
"<command>rsync</command> различает время только с точностью до секунд.) Во "
"второй раз <application>rsync</application> отработает быстрее, чем в "
"первый, потому что скопировать надо будет относительно немного данных; и в "
"итоге будет получен согласованный результат, так как сервер был остановлен. "
"Данный метод позволяет получить копию на уровне файловой системы с "
"минимальным временем простоя."

#: backup.xml:451(para)
msgid ""
"Note that a file system backup will typically be larger than an SQL dump. "
"(<application>pg_dump</application> does not need to dump the contents of "
"indexes for example, just the commands to recreate them.) However, taking a "
"file system backup might be faster."
msgstr ""
"Обратите внимание, что размер копии на уровне файлов обычно больше, чем "
"дампа SQL. (Программе <application>pg_dump</application> не нужно, например, "
"записывать содержимое индексов, достаточно команд для их пересоздания). "
"Однако копирование на уровне файлов может выполняться быстрее."

#: backup.xml:460(title)
msgid "Continuous Archiving and Point-in-Time Recovery (PITR)"
msgstr ""
"Непрерывное архивирование и восстановление на момент времени (Point-in-Time "
"Recovery, PITR)"

#: backup.xml:462(indexterm)
msgid "<primary>continuous archiving</primary>"
msgstr "<primary>непрерывное архивирование</primary>"

#: backup.xml:466(indexterm)
msgid "<primary>point-in-time recovery</primary>"
msgstr "<primary>восстановление на момент времени</primary>"

#: backup.xml:470(indexterm)
msgid "<primary>PITR</primary>"
msgstr "<primary>PITR</primary>"

#: backup.xml:491(para)
msgid ""
"We do not need a perfectly consistent file system backup as the starting "
"point. Any internal inconsistency in the backup will be corrected by log "
"replay (this is not significantly different from what happens during crash "
"recovery). So we do not need a file system snapshot capability, just "
"<application>tar</application> or a similar archiving tool."
msgstr ""
"В качестве начальной точки для восстановления необязательно иметь полностью "
"согласованную копию на уровне файлов. Внутренняя несогласованность копии "
"будет исправлена при воспроизведении журнала (практически то же самое "
"происходит при восстановлении после краха). Таким образом, согласованный "
"снимок файловой системы не требуется, вполне можно использовать "
"<application>tar</application> или похожие средства архивации."

#: backup.xml:500(para)
msgid ""
"Since we can combine an indefinitely long sequence of WAL files for replay, "
"continuous backup can be achieved simply by continuing to archive the WAL "
"files. This is particularly valuable for large databases, where it might not "
"be convenient to take a full backup frequently."
msgstr ""
"Поскольку при воспроизведении можно обрабатывать неограниченную "
"последовательность файлов WAL, непрерывную резервную копию можно получить, "
"просто продолжая архивировать файлы WAL. Это особенно ценно для больших баз "
"данных, полные резервные копии которых делать как минимум неудобно."

#: backup.xml:508(para)
msgid ""
"It is not necessary to replay the WAL entries all the way to the end. We "
"could stop the replay at any point and have a consistent snapshot of the "
"database as it was at that time. Thus, this technique supports "
"<firstterm>point-in-time recovery</firstterm>: it is possible to restore the "
"database to its state at any time since your base backup was taken."
msgstr ""
"Воспроизводить все записи WAL до самого конца нет необходимости. "
"Воспроизведение можно остановить в любой точке и получить целостный снимок "
"базы данных на этот момент времени. Таким образом, данная технология "
"поддерживает <firstterm>восстановление на момент времени</firstterm>: можно "
"восстановить состояние базы данных на любое время с момента создания "
"резервной копии."

#: backup.xml:518(para)
msgid ""
"If we continuously feed the series of WAL files to another machine that has "
"been loaded with the same base backup file, we have a <firstterm>warm "
"standby</firstterm> system: at any point we can bring up the second machine "
"and it will have a nearly-current copy of the database."
msgstr ""
"Если непрерывно передавать последовательность файлов WAL другому серверу, "
"получившему данные из базовой копии того же кластера, получается система "
"<firstterm>тёплого резерва</firstterm>: в любой момент мы можем запустить "
"второй сервер и он будет иметь практически текущую копию баз данных."

#: backup.xml:474(para)
msgid ""
"At all times, <productname>PostgreSQL</productname> maintains a "
"<firstterm>write ahead log</firstterm> (WAL) in the <filename>pg_xlog/</"
"filename> subdirectory of the cluster's data directory. The log records "
"every change made to the database's data files. This log exists primarily "
"for crash-safety purposes: if the system crashes, the database can be "
"restored to consistency by <quote>replaying</quote> the log entries made "
"since the last checkpoint. However, the existence of the log makes it "
"possible to use a third strategy for backing up databases: we can combine a "
"file-system-level backup with backup of the WAL files. If recovery is "
"needed, we restore the file system backup and then replay from the backed-up "
"WAL files to bring the system to a current state. This approach is more "
"complex to administer than either of the previous approaches, but it has "
"some significant benefits: <placeholder-1/>"
msgstr ""
"Всё время в процессе работы <productname>PostgreSQL</productname> ведёт "
"<firstterm>журнал упреждающей записи</firstterm> (WAL), который расположен в "
"подкаталоге <filename>pg_xlog/</filename> каталога с данными кластера баз "
"данных. В этот журнал записываются все изменения, вносимые в файлы данных. "
"Прежде всего, журнал существует для безопасного восстановления после краха "
"сервера: если происходит крах, целостность СУБД может быть восстановлена в "
"результате <quote>воспроизведения</quote> записей, зафиксированных после "
"последней контрольной точки. Однако наличие журнала делает возможным "
"использование третьей стратегии копирования баз данных: можно сочетать "
"резервное копирование на уровне файловой системы с копированием файлов WAL. "
"Если потребуется восстановить данные, мы можем восстановить копию файлов, а "
"затем воспроизвести журнал из скопированных файлов WAL, и таким образом "
"привести систему в нужное состояние. Такой подход более сложен для "
"администрирования, чем любой из описанных выше, но он имеет значительные "
"преимущества: <placeholder-1/>"

#: backup.xml:530(para)
msgid ""
"<application>pg_dump</application> and <application>pg_dumpall</application> "
"do not produce file-system-level backups and cannot be used as part of a "
"continuous-archiving solution. Such dumps are <emphasis>logical</emphasis> "
"and do not contain enough information to be used by WAL replay."
msgstr ""
"Программы <application>pg_dump</application> и <application>pg_dumpall</"
"application> не создают копии на уровне файловой системы и не могут "
"применяться как часть решения по непрерывной архивации. Создаваемые ими "
"копии являются логическими и не содержат информации, необходимой для "
"воспроизведения WAL."

#: backup.xml:539(para)
msgid ""
"As with the plain file-system-backup technique, this method can only support "
"restoration of an entire database cluster, not a subset. Also, it requires a "
"lot of archival storage: the base backup might be bulky, and a busy system "
"will generate many megabytes of WAL traffic that have to be archived. Still, "
"it is the preferred backup technique in many situations where high "
"reliability is needed."
msgstr ""
"Как и обычное резервное копирование файловой системы, этот метод позволяет "
"восстанавливать только весь кластер баз данных целиком, но не его части. "
"Кроме того, для архивов требуется большое хранилище: базовая резервная копия "
"может быть объёмной, а нагруженные системы будут генерировать многие "
"мегабайты трафика WAL, который необходимо архивировать. Тем не менее, этот "
"метод резервного копирования предпочитается во многих ситуациях, где "
"необходима высокая надёжность."

#: backup.xml:548(para)
msgid ""
"To recover successfully using continuous archiving (also called "
"<quote>online backup</quote> by many database vendors), you need a "
"continuous sequence of archived WAL files that extends back at least as far "
"as the start time of your backup. So to get started, you should set up and "
"test your procedure for archiving WAL files <emphasis>before</emphasis> you "
"take your first base backup. Accordingly, we first discuss the mechanics of "
"archiving WAL files."
msgstr ""
"Для успешного восстановления с применением непрерывного архивирования (также "
"называемого <quote>оперативным резервным копированием</quote> многими "
"разработчиками СУБД), вам необходима непрерывная последовательность "
"заархивированных файлов WAL, начинающаяся не позже, чем с момента начала "
"копирования. Так что для начала вы должны настроить и протестировать "
"процедуру архивирования файлов WAL <emphasis>до того</emphasis>, как "
"получите первую базовую копию. Соответственно, сначала мы обсудим механику "
"архивирования файлов WAL."

#: backup.xml:559(title)
msgid "Setting Up WAL Archiving"
msgstr "Настройка архивирования WAL"

#: backup.xml:561(para)
msgid ""
"In an abstract sense, a running <productname>PostgreSQL</productname> system "
"produces an indefinitely long sequence of WAL records. The system physically "
"divides this sequence into WAL <firstterm>segment files</firstterm>, which "
"are normally 16MB apiece (although the segment size can be altered when "
"building <productname>PostgreSQL</productname>). The segment files are given "
"numeric names that reflect their position in the abstract WAL sequence. When "
"not using WAL archiving, the system normally creates just a few segment "
"files and then <quote>recycles</quote> them by renaming no-longer-needed "
"segment files to higher segment numbers. It's assumed that segment files "
"whose contents precede the checkpoint-before-last are no longer of interest "
"and can be recycled."
msgstr ""
"В абстрактном смысле, запущенная СУБД <productname>PostgreSQL</productname> "
"производит неограниченно длинную последовательность записей WAL. СУБД "
"физически делит эту последовательность на <firstterm>файлы-сегменты</"
"firstterm> WAL, которые обычно имеют размер в 16 МиБ (хотя размер сегмента "
"может быть изменён при сборке <productname>PostgreSQL</productname>). Файлы-"
"сегменты получают цифровые имена, которые отражают их позицию в абстрактной "
"последовательности WAL. Когда архивирование WAL не применяется, система "
"обычно создаёт только несколько файлов-сегментов и затем "
"<quote>перерабатывает</quote> их, меняя номер в имени более не нужного файла-"
"сегмента на больший. Предполагается, что файлы-сегменты, чьё содержимое "
"предшествует последней контрольной точке, уже не представляют интереса и "
"могут быть переработаны."

#: backup.xml:576(para)
msgid ""
"When archiving WAL data, we need to capture the contents of each segment "
"file once it is filled, and save that data somewhere before the segment file "
"is recycled for reuse. Depending on the application and the available "
"hardware, there could be many different ways of <quote>saving the data "
"somewhere</quote>: we could copy the segment files to an NFS-mounted "
"directory on another machine, write them onto a tape drive (ensuring that "
"you have a way of identifying the original name of each file), or batch them "
"together and burn them onto CDs, or something else entirely. To provide the "
"database administrator with flexibility, <productname>PostgreSQL</"
"productname> tries not to make any assumptions about how the archiving will "
"be done. Instead, <productname>PostgreSQL</productname> lets the "
"administrator specify a shell command to be executed to copy a completed "
"segment file to wherever it needs to go. The command could be as simple as a "
"<literal>cp</literal>, or it could invoke a complex shell script &mdash; "
"it's all up to you."
msgstr ""
"При архивировании данных WAL необходимо считывать содержимое каждого файла-"
"сегмента, как только он заполняется, и сохранять эти данные куда-то, прежде "
"чем файл-сегмент будет переработан и использован повторно. В зависимости от "
"применения и доступного аппаратного обеспечения, возможны разные способы "
"<quote>сохранить данные куда-то</quote>: можно скопировать файлы-сегменты в "
"смонтированный по NFS каталог на другую машину, записать их на ленту "
"(убедившись, что у вас есть способ идентифицировать исходное имя каждого "
"файла) или собрать их в пакет и записать на CD, либо какие-то совсем другие "
"варианты. Чтобы у администратора баз данных была гибкость в этом плане, "
"<productname>PostgreSQL</productname> пытается не делать каких-либо "
"предположений о том, как будет выполняться архивация. Вместо этого, "
"<productname>PostgreSQL</productname> позволяет администратору указать "
"команду оболочки, которая будет запускаться для копирования завершённого "
"файла-сегмента в нужное место. Эта команда может быть простой как "
"<literal>cp</literal>, а может вызывать сложный скрипт оболочки &mdash; это "
"решать вам."

#: backup.xml:610(programlisting)
#, no-wrap
msgid ""
"archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix\n"
"archive_command = 'copy \"%p\" \"C:\\\\server\\\\archivedir\\\\%f\"'  # Windows"
msgstr ""
"archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix\n"
"archive_command = 'copy \"%p\" \"C:\\\\server\\\\archivedir\\\\%f\"'  # Windows"

#: backup.xml:619(programlisting)
#, no-wrap
msgid "test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065"
msgstr "test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065"

#: backup.xml:594(para)
msgid ""
"To enable WAL archiving, set the <xref linkend=\"guc-wal-level\"/> "
"configuration parameter to <literal>replica</literal> or higher, <xref "
"linkend=\"guc-archive-mode\"/> to <literal>on</literal>, and specify the "
"shell command to use in the <xref linkend=\"guc-archive-command\"/> "
"configuration parameter. In practice these settings will always be placed in "
"the <filename>postgresql.conf</filename> file. In <varname>archive_command</"
"varname>, <literal>%p</literal> is replaced by the path name of the file to "
"archive, while <literal>%f</literal> is replaced by only the file name. (The "
"path name is relative to the current working directory, i.e., the cluster's "
"data directory.) Use <literal>%%</literal> if you need to embed an actual "
"<literal>%</literal> character in the command. The simplest useful command "
"is something like: <placeholder-1/> which will copy archivable WAL segments "
"to the directory <filename>/mnt/server/archivedir</filename>. (This is an "
"example, not a recommendation, and might not work on all platforms.) After "
"the <literal>%p</literal> and <literal>%f</literal> parameters have been "
"replaced, the actual command executed might look like this: <placeholder-2/> "
"A similar command will be generated for each new file to be archived."
msgstr ""
"Чтобы включить архивирование WAL, установите в параметре конфигурации <xref "
"linkend=\"guc-wal-level\"/> уровень <literal>replica</literal> (или выше), в "
"<xref linkend=\"guc-archive-mode\"/> — значение <literal>on</literal>, и "
"задайте желаемую команду оболочки в параметре <xref linkend=\"guc-archive-"
"command\"/>. На практике эти параметры всегда задаются в файле "
"<filename>postgresql.conf</filename>. В <varname>archive_command</varname> "
"символы <literal>%p</literal> заменяются полным путём к файлу, подлежащему "
"архивации, а <literal>%f</literal> заменяются только именем файла. (Путь "
"задаётся относительно текущего рабочего каталога, т. е. каталога данных "
"кластера). Если в команду нужно включить сам символ <literal>%</literal>, "
"запишите <literal>%%</literal>. Простейшая команда, которая может быть "
"полезна: <placeholder-1/> Она будет копировать архивируемые сегменты WAL в "
"каталог /mnt/server/archivedir. (Команда дана как пример, а не как "
"рекомендация, и может не работать на всех платформах.) После замены "
"параметров <literal>%p</literal> и <literal>%f</literal> фактически "
"запускаемая команда может выглядеть так: <placeholder-2/> Подобная команда "
"будет генерироваться для каждого следующего архивируемого файла."

#: backup.xml:625(para)
msgid ""
"The archive command will be executed under the ownership of the same user "
"that the <productname>PostgreSQL</productname> server is running as. Since "
"the series of WAL files being archived contains effectively everything in "
"your database, you will want to be sure that the archived data is protected "
"from prying eyes; for example, archive into a directory that does not have "
"group or world read access."
msgstr ""
"Команда архивирования будет запущена от имени того же пользователя, от имени "
"которого работает сервер <productname>PostgreSQL</productname>. Поскольку "
"архивируемые последовательности файлов WAL фактически содержат всё, что есть "
"в вашей базе данных, вам нужно будет защитить архивируемые данные от "
"посторонних глаз; например, сохраните архив в каталог, чтение которого "
"запрещено для группы и остальных пользователей."

#: backup.xml:634(para)
msgid ""
"It is important that the archive command return zero exit status if and only "
"if it succeeds. Upon getting a zero result, <productname>PostgreSQL</"
"productname> will assume that the file has been successfully archived, and "
"will remove or recycle it. However, a nonzero status tells "
"<productname>PostgreSQL</productname> that the file was not archived; it "
"will try again periodically until it succeeds."
msgstr ""
"Важно, чтобы команда архивирования возвращала нулевой код завершения, если и "
"только если она завершилась успешно. Получив нулевой результат, "
"<productname>PostgreSQL</productname> будет полагать, что файл успешно "
"заархивирован и удалит его или переработает. Однако, ненулевой код состояния "
"скажет <productname>PostgreSQL</productname>, что файл не заархивирован; "
"попытки заархивировать его будут периодически повторяться, пока это не "
"удастся."

#: backup.xml:643(para)
msgid ""
"The archive command should generally be designed to refuse to overwrite any "
"pre-existing archive file. This is an important safety feature to preserve "
"the integrity of your archive in case of administrator error (such as "
"sending the output of two different servers to the same archive directory)."
msgstr ""
"Команда архивирования обычно разрабатывается так, чтобы не допускать "
"перезаписи любых существующих архивных файлов. Это важная мера безопасности, "
"позволяющая сохранить целостность архива в случае ошибки администратора "
"(например, если архивируемые данные двух разных серверов будут сохраняться в "
"одном каталоге)."

#: backup.xml:651(para)
msgid ""
"It is advisable to test your proposed archive command to ensure that it "
"indeed does not overwrite an existing file, <emphasis>and that it returns "
"nonzero status in this case</emphasis>. The example command above for Unix "
"ensures this by including a separate <command>test</command> step. On some "
"Unix platforms, <command>cp</command> has switches such as <option>-i</"
"option> that can be used to do the same thing less verbosely, but you should "
"not rely on these without verifying that the right exit status is returned. "
"(In particular, GNU <command>cp</command> will return status zero when "
"<option>-i</option> is used and the target file already exists, which is "
"<emphasis>not</emphasis> the desired behavior.)"
msgstr ""
"Рекомендуется протестировать команду архивирования, чтобы убедиться, что она "
"действительно не перезаписывает существующие файлы, и что она "
"<emphasis>возвращает ненулевое состояние в этом случае</emphasis>. В "
"показанной выше команде для Unix для этого добавлен отдельный шаг "
"<command>test</command>. На некоторых платформах Unix у <command>cp</"
"command> есть ключ <option>-i</option>, который позволяет сделать то же, но "
"менее явно; но не проверив, какой код состояния при этом возвращается, "
"полагаться на этот ключ не следует. (В частности, GNU <command>cp</command> "
"возвратит нулевой код состояния, если используется ключ <option>-i</option> "
"и целевой файл существует, а это <emphasis>не то</emphasis>, что нужно.)"

#: backup.xml:664(para)
msgid ""
"While designing your archiving setup, consider what will happen if the "
"archive command fails repeatedly because some aspect requires operator "
"intervention or the archive runs out of space. For example, this could occur "
"if you write to tape without an autochanger; when the tape fills, nothing "
"further can be archived until the tape is swapped. You should ensure that "
"any error condition or request to a human operator is reported appropriately "
"so that the situation can be resolved reasonably quickly. The "
"<filename>pg_xlog/</filename> directory will continue to fill with WAL "
"segment files until the situation is resolved. (If the file system "
"containing <filename>pg_xlog/</filename> fills up, <productname>PostgreSQL</"
"productname> will do a PANIC shutdown. No committed transactions will be "
"lost, but the database will remain offline until you free some space.)"
msgstr ""
"Разрабатывая схему архивирования, подумайте, что произойдёт, если команда "
"архивирования начнёт постоянно выдавать ошибку, потому что требуется "
"вмешательство оператора или для архивирования не хватает места. Например, "
"это может произойти, если вы записываете архивы на ленточное устройство без "
"механизма автозамены; когда лента заполняется полностью, больше ничего "
"архивироваться не будет, пока вы не замените кассету. Вы должны убедиться, "
"что любые возникающие ошибки или обращения к человеку (оператору), "
"обрабатываются так, чтобы проблема решалась достаточно быстро. Пока она не "
"разрешится, каталог <filename>pg_xlog/</filename> продолжит наполняться "
"файлами-сегментами WAL. (Если файловая система, в которой находится каталог "
"<filename>pg_xlog/</filename> заполнится до конца, <productname>PostgreSQL</"
"productname> завершит свою работу аварийно. Зафиксированные транзакции не "
"потеряются, но база данных не будет работать, пока вы не освободите место.)"

#: backup.xml:680(para)
msgid ""
"The speed of the archiving command is unimportant as long as it can keep up "
"with the average rate at which your server generates WAL data. Normal "
"operation continues even if the archiving process falls a little behind. If "
"archiving falls significantly behind, this will increase the amount of data "
"that would be lost in the event of a disaster. It will also mean that the "
"<filename>pg_xlog/</filename> directory will contain large numbers of not-"
"yet-archived segment files, which could eventually exceed available disk "
"space. You are advised to monitor the archiving process to ensure that it is "
"working as you intend."
msgstr ""
"Не важно, с какой скоростью работает команда архивирования, если только она "
"не ниже средней скорости, с которой сервер генерирует записи WAL. Обычно "
"работа продолжается, даже если процесс архивирования немного отстаёт. Если "
"же архивирование отстаёт значительно, это приводит к увеличению объёма "
"данных, которые могут быть потеряны в случае аварии. При этом каталог "
"<filename>pg_xlog/</filename> будет содержать большое количество ещё не "
"заархивированных файлов-сегментов, которые в конце концов могут занять всё "
"доступное дисковое пространство. Поэтому рекомендуется контролировать "
"процесс архивации и следить за тем, чтобы он выполнялся как задумано."

#: backup.xml:692(para)
msgid ""
"In writing your archive command, you should assume that the file names to be "
"archived can be up to 64 characters long and can contain any combination of "
"ASCII letters, digits, and dots. It is not necessary to preserve the "
"original relative path (<literal>%p</literal>) but it is necessary to "
"preserve the file name (<literal>%f</literal>)."
msgstr ""
"При написании команды архивирования вы должны иметь в виду, что имена файлов "
"для архивирования могут иметь длину до 64 символов и содержать любые "
"комбинации из цифр, точек и букв ASCII. Сохранять исходный относительный "
"путь (<literal>%p</literal>) необязательно, но необходимо сохранять имя "
"файла (<literal>%f</literal>)."

#: backup.xml:700(para)
msgid ""
"Note that although WAL archiving will allow you to restore any modifications "
"made to the data in your <productname>PostgreSQL</productname> database, it "
"will not restore changes made to configuration files (that is, "
"<filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> and "
"<filename>pg_ident.conf</filename>), since those are edited manually rather "
"than through SQL operations. You might wish to keep the configuration files "
"in a location that will be backed up by your regular file system backup "
"procedures. See <xref linkend=\"runtime-config-file-locations\"/> for how to "
"relocate the configuration files."
msgstr ""
"Обратите внимание, что хотя архивирование WAL позволяет сохранить любые "
"изменения данных, произведённые в базе данных <productname>PostgreSQL</"
"productname>, оно не затрагивает изменения, внесённые в конфигурационные "
"файлы (такие как <filename>postgresql.conf</filename>, <filename>pg_hba."
"conf</filename> и <filename>pg_ident.conf</filename>), поскольку эти "
"изменения выполняются вручную, а не через SQL. Поэтому имеет смысл "
"разместить конфигурационные файлы там, где они будут заархивированы обычными "
"процедурами копирования файлов. Как перемещать конфигурационные файлы, "
"рассказывается в <xref remap=\"6\" linkend=\"runtime-config-file-locations\"/"
">."

#: backup.xml:713(para)
msgid ""
"The archive command is only invoked on completed WAL segments. Hence, if "
"your server generates only little WAL traffic (or has slack periods where it "
"does so), there could be a long delay between the completion of a "
"transaction and its safe recording in archive storage. To put a limit on how "
"old unarchived data can be, you can set <xref linkend=\"guc-archive-timeout"
"\"/> to force the server to switch to a new WAL segment file at least that "
"often. Note that archived files that are archived early due to a forced "
"switch are still the same length as completely full files. It is therefore "
"unwise to set a very short <varname>archive_timeout</varname> &mdash; it "
"will bloat your archive storage. <varname>archive_timeout</varname> settings "
"of a minute or so are usually reasonable."
msgstr ""
"Команда архивирования вызывается, только когда сегмент WAL заполнен до "
"конца. Таким образом, если сервер постоянно генерирует небольшой трафик WAL "
"(или есть продолжительные периоды, когда это происходит), между завершением "
"транзакций и их безопасным сохранением в архиве может образоваться большая "
"задержка. Чтобы ограничить время жизни неархивированных данных, можно "
"установить <xref linkend=\"guc-archive-timeout\"/>, чтобы сервер "
"переключался на новый файл сегмента WAL как минимум с заданной частотой. "
"Заметьте, что неполные файлы, архивируемые досрочно из-за принудительного "
"переключения по тайм-ауту, будут иметь тот же размер, что и заполненные "
"файлы. Таким образом, устанавливать очень маленький "
"<varname>archive_timeout</varname> &mdash; неразумно; это приведёт к "
"неэффективному заполнению архива. Обычно подходящее значение "
"<varname>archive_timeout</varname> — минута или около того."

#: backup.xml:728(para)
msgid ""
"Also, you can force a segment switch manually with <function>pg_switch_xlog</"
"function> if you want to ensure that a just-finished transaction is archived "
"as soon as possible. Other utility functions related to WAL management are "
"listed in <xref linkend=\"functions-admin-backup-table\"/>."
msgstr ""
"Также вы можете принудительно переключить сегмент WAL вручную с помощью "
"<function>pg_switch_xlog</function>, если хотите, чтобы только что "
"завершённая транзакция заархивировалась как можно скорее. Другие полезные "
"функции, относящиеся к управлению WAL, перечисляются в <xref remap=\"6\" "
"linkend=\"functions-admin-backup-table\"/>."

#: backup.xml:736(para)
msgid ""
"When <varname>wal_level</varname> is <literal>minimal</literal> some SQL "
"commands are optimized to avoid WAL logging, as described in <xref linkend="
"\"populate-pitr\"/>. If archiving or streaming replication were turned on "
"during execution of one of these statements, WAL would not contain enough "
"information for archive recovery. (Crash recovery is unaffected.) For this "
"reason, <varname>wal_level</varname> can only be changed at server start. "
"However, <varname>archive_command</varname> can be changed with a "
"configuration file reload. If you wish to temporarily stop archiving, one "
"way to do it is to set <varname>archive_command</varname> to the empty "
"string (<literal>''</literal>). This will cause WAL files to accumulate in "
"<filename>pg_xlog/</filename> until a working <varname>archive_command</"
"varname> is re-established."
msgstr ""
"Когда <varname>wal_level</varname> имеет значение <literal>minimal</"
"literal>, некоторые команды SQL выполняются в обход журнала WAL, как "
"описывается в <xref remap=\"6\" linkend=\"populate-pitr\"/>. Если "
"архивирование или потоковая репликация были включены во время выполнения "
"таких операторов, WAL не будет содержать информацию, необходимую для "
"восстановления. (На восстановление после краха это не распространяется). "
"Поэтому <varname>wal_level</varname> можно изменить только при запуске "
"сервера. Однако, чтобы изменить команду <varname>archive_command</varname>, "
"достаточно перезагрузить файл конфигурации. Если вы хотите на время "
"остановить архивирование, это можно сделать, например, задав в качестве "
"значения <varname>archive_command</varname> пустую строку (''). В результате "
"файлы WAL будут накапливаться в каталоге <filename>pg_xlog/</filename>, пока "
"не будет восстановлена действующая команда <varname>archive_command</"
"varname>."

#: backup.xml:753(title)
msgid "Making a Base Backup"
msgstr "Создание базовой резервной копии"

#: backup.xml:755(para)
msgid ""
"The easiest way to perform a base backup is to use the <xref linkend=\"app-"
"pgbasebackup\"/> tool. It can create a base backup either as regular files "
"or as a tar archive. If more flexibility than <xref linkend=\"app-"
"pgbasebackup\"/> can provide is required, you can also make a base backup "
"using the low level API (see <xref linkend=\"backup-lowlevel-base-backup\"/"
">)."
msgstr ""
"Проще всего получить базовую резервную копию, используя программу <xref "
"linkend=\"app-pgbasebackup\"/>. Эта программа сохраняет базовую копию в виде "
"обычных файлов или в архиве tar. Если гибкости <xref linkend=\"app-"
"pgbasebackup\"/> не хватает, вы также можете получить базовую резервную "
"копию, используя низкоуровневый API (см. <xref remap=\"4\" linkend=\"backup-"
"lowlevel-base-backup\"/>)."

#: backup.xml:764(para)
msgid ""
"It is not necessary to be concerned about the amount of time it takes to "
"make a base backup. However, if you normally run the server with "
"<varname>full_page_writes</varname> disabled, you might notice a drop in "
"performance while the backup runs since <varname>full_page_writes</varname> "
"is effectively forced on during backup mode."
msgstr ""
"Продолжительность создания резервной копии обычно не имеет большого "
"значения. Однако, если вы эксплуатируете сервер с отключённым режимом "
"<varname>full_page_writes</varname>, вы можете заметить падение "
"производительности в процессе резервного копирования, так как режим "
"<varname>full_page_writes</varname> включается принудительно на время "
"резервного копирования."

#: backup.xml:772(para)
msgid ""
"To make use of the backup, you will need to keep all the WAL segment files "
"generated during and after the file system backup. To aid you in doing this, "
"the base backup process creates a <firstterm>backup history file</firstterm> "
"that is immediately stored into the WAL archive area. This file is named "
"after the first WAL segment file that you need for the file system backup. "
"For example, if the starting WAL file is <literal>0000000100001234000055CD</"
"literal> the backup history file will be named something like "
"<literal>0000000100001234000055CD.007C9330.backup</literal>. (The second "
"part of the file name stands for an exact position within the WAL file, and "
"can ordinarily be ignored.) Once you have safely archived the file system "
"backup and the WAL segment files used during the backup (as specified in the "
"backup history file), all archived WAL segments with names numerically less "
"are no longer needed to recover the file system backup and can be deleted. "
"However, you should consider keeping several backup sets to be absolutely "
"certain that you can recover your data."
msgstr ""
"Чтобы резервной копией можно было пользоваться, нужно сохранить все файлы "
"сегментов WAL, сгенерированные во время и после копирования файлов. Для "
"облегчения этой задачи, процесс создания базовой резервной копии записывает "
"<firstterm>файл истории резервного копирования</firstterm>, который "
"немедленно сохраняется в области архивации WAL. Данный файл получает имя по "
"имени файла первого сегмента WAL, который потребуется для восстановления "
"скопированных файлов. Например, если начальный файл WAL назывался "
"<literal>0000000100001234000055CD</literal>, файл истории резервного "
"копирования получит имя <literal>0000000100001234000055CD.007C9330.backup</"
"literal>. (Вторая часть имени файла обозначает точную позицию внутри файла "
"WAL и обычно может быть проигнорирована.) Как только вы заархивировали копии "
"файлов данных и файлов сегментов WAL, полученных в процессе копирования (по "
"сведениям в файле истории резервного копирования), все заархивированные "
"сегменты WAL с именами, меньшими по номеру, становятся ненужными для "
"восстановления файловой копии и могут быть удалены. Но всё же рассмотрите "
"возможность хранения нескольких наборов резервных копий, чтобы быть "
"абсолютно уверенными, что вы сможете восстановить ваши данные."

#: backup.xml:793(para)
msgid ""
"The backup history file is just a small text file. It contains the label "
"string you gave to <xref linkend=\"app-pgbasebackup\"/>, as well as the "
"starting and ending times and WAL segments of the backup. If you used the "
"label to identify the associated dump file, then the archived history file "
"is enough to tell you which dump file to restore."
msgstr ""
"Файл истории резервного копирования &mdash; это просто небольшой текстовый "
"файл. В него записывается метка, которая была передана <xref linkend=\"app-"
"pgbasebackup\"/>, а также время и текущие сегменты WAL в момент начала и "
"завершения резервной копии. Если вы связали с данной меткой соответствующий "
"файл дампа, то заархивированного файла истории достаточно, чтобы найти файл "
"дампа, нужный для восстановления."

#: backup.xml:802(para)
msgid ""
"Since you have to keep around all the archived WAL files back to your last "
"base backup, the interval between base backups should usually be chosen "
"based on how much storage you want to expend on archived WAL files. You "
"should also consider how long you are prepared to spend recovering, if "
"recovery should be necessary &mdash; the system will have to replay all "
"those WAL segments, and that could take awhile if it has been a long time "
"since the last base backup."
msgstr ""
"Поскольку необходимо хранить все заархивированные файлы WAL с момента "
"последней базовой резервной копии, интервал базового резервного копирования "
"обычно выбирается в зависимости от того, сколько места может быть выделено "
"для архива файлов WAL. Также стоит отталкиваться от того, сколько вы готовы "
"ожидать восстановления, если оно понадобится — системе придётся "
"воспроизвести все эти сегменты WAL, а этот процесс может быть долгим, если с "
"момента последней базовой копии прошло много времени."

#: backup.xml:814(title)
msgid "Making a Base Backup Using the Low Level API"
msgstr "Создание базовой резервной копии через низкоуровневый API"

#: backup.xml:815(para)
msgid ""
"The procedure for making a base backup using the low level APIs contains a "
"few more steps than the <xref linkend=\"app-pgbasebackup\"/> method, but is "
"relatively simple. It is very important that these steps are executed in "
"sequence, and that the success of a step is verified before proceeding to "
"the next step."
msgstr ""
"Процедура создания базовой резервной копии с использованием низкоуровневого "
"API содержит чуть больше шагов, чем метод <xref linkend=\"app-pgbasebackup\"/"
">, но всё же относительно проста. Очень важно, чтобы эти шаги выполнялись по "
"порядку, и следующий шаг выполнялся, только если предыдущий успешен."

#: backup.xml:823(para)
msgid ""
"Low level base backups can be made in a non-exclusive or an exclusive way. "
"The non-exclusive method is recommended and the exclusive one is deprecated "
"and will eventually be removed."
msgstr ""
"Резервное копирование на низком уровне можно произвести в монопольном или "
"немонопольном режиме. Рекомендуется применять немонопольный метод, а "
"монопольный считается устаревшим и в конце концов будет ликвидирован."

#: backup.xml:829(title)
msgid "Making a non-exclusive low level backup"
msgstr "Немонопольное резервное копирование на низком уровне"

#: backup.xml:830(para)
msgid ""
"A non-exclusive low level backup is one that allows other concurrent backups "
"to be running (both those started using the same backup API and those "
"started using <xref linkend=\"app-pgbasebackup\"/>)."
msgstr ""
"Немонопольное резервное копирование позволяет параллельно запускать другие "
"процессы копирования (используя тот же API или <xref linkend=\"app-"
"pgbasebackup\"/>)."

#: backup.xml:839(para) backup.xml:945(para)
msgid "Ensure that WAL archiving is enabled and working."
msgstr "Убедитесь, что архивирование WAL включено и работает."

#: backup.xml:848(programlisting)
#, no-wrap
msgid "SELECT pg_start_backup('label', false, false);"
msgstr "SELECT pg_start_backup('label', false, false);"

#: backup.xml:844(para)
msgid ""
"Connect to the server (it does not matter which database) as a user with "
"rights to run pg_start_backup (superuser, or a user who has been granted "
"EXECUTE on the function) and issue the command: <placeholder-1/> where "
"<literal>label</literal> is any string you want to use to uniquely identify "
"this backup operation. The connection calling <function>pg_start_backup</"
"function> must be maintained until the end of the backup, or the backup will "
"be automatically aborted."
msgstr ""
"Подключитесь к серверу (к любой базе данных) как пользователь с правами на "
"выполнение pg_start_backup (суперпользователь или пользователь, которому "
"дано право EXECUTE для этой функции) и выполните команду: <placeholder-1/> "
"где <literal>label</literal> &mdash; любая метка, по которой можно "
"однозначно идентифицировать данную операцию резервного копирования. "
"Соединение, через которое вызывается <function>pg_start_backup</function>, "
"должно поддерживаться до окончания резервного копирования, иначе этот "
"процесс будет автоматически прерван."

#: backup.xml:857(para)
msgid ""
"By default, <function>pg_start_backup</function> can take a long time to "
"finish. This is because it performs a checkpoint, and the I/O required for "
"the checkpoint will be spread out over a significant period of time, by "
"default half your inter-checkpoint interval (see the configuration parameter "
"<xref linkend=\"guc-checkpoint-completion-target\"/>). This is usually what "
"you want, because it minimizes the impact on query processing. If you want "
"to start the backup as soon as possible, change the second parameter to "
"<literal>true</literal>, which will issue an immediate checkpoint using as "
"much I/O as available."
msgstr ""
"По умолчанию <function>pg_start_backup</function> может выполняться "
"длительное время. Это объясняется тем, что функция выполняет контрольную "
"точку, а операции ввода/вывода, требуемые для этого, распределяются в "
"интервале времени, по умолчанию равном половине интервала между контрольными "
"точками (см. параметр <xref linkend=\"guc-checkpoint-completion-target\"/>). "
"Обычно это вполне приемлемо, так как при этом минимизируется влияние на "
"выполнение других запросов. Если же вы хотите начать резервное копирование "
"максимально быстро, передайте во втором параметре <literal>true</literal>. В "
"этом случае контрольная точка будет выполнена немедленно без ограничения "
"объёма ввода/вывода."

#: backup.xml:870(para)
msgid ""
"The third parameter being <literal>false</literal> tells "
"<function>pg_start_backup</function> to initiate a non-exclusive base backup."
msgstr ""
"Третий параметр, имеющий значение <literal>false</literal>, указывает "
"<function>pg_start_backup</function> начать немонопольное базовое "
"копирование."

#: backup.xml:876(para) backup.xml:986(para)
msgid ""
"Perform the backup, using any convenient file-system-backup tool such as "
"<application>tar</application> or <application>cpio</application> (not "
"<application>pg_dump</application> or <application>pg_dumpall</"
"application>). It is neither necessary nor desirable to stop normal "
"operation of the database while you do this. See <xref linkend=\"backup-"
"lowlevel-base-backup-data\"/> for things to consider during this backup."
msgstr ""
"Скопируйте файлы, используя любое удобное средство резервного копирования, "
"например, <application>tar</application> или <application>cpio</application> "
"(не <application>pg_dump</application> или <application>pg_dumpall</"
"application>). В процессе копирования останавливать работу базы данных не "
"требуется, это ничего не даёт. В <xref remap=\"6\" linkend=\"backup-lowlevel-"
"base-backup-data\"/> описано, что следует учитывать в процессе копирования."

#: backup.xml:890(programlisting)
#, no-wrap
msgid "SELECT * FROM pg_stop_backup(false);"
msgstr "SELECT * FROM pg_stop_backup(false);"

#: backup.xml:888(para)
msgid ""
"In the same connection as before, issue the command: <placeholder-1/> This "
"terminates the backup mode and performs an automatic switch to the next WAL "
"segment. The reason for the switch is to arrange for the last WAL segment "
"file written during the backup interval to be ready to archive."
msgstr ""
"Через то же подключение, что и раньше, выполните команду: <placeholder-1/> "
"Сервер выйдет из режима резервного копирования и автоматически переключится "
"на следующий сегмент WAL. Это переключение выполняется для того, чтобы файл "
"последнего сегмента WAL, записанного во время копирования, был готов к "
"архивации."

#: backup.xml:898(para)
msgid ""
"The <function>pg_stop_backup</function> will return one row with three "
"values. The second of these fields should be written to a file named "
"<filename>backup_label</filename> in the root directory of the backup. The "
"third field should be written to a file named <filename>tablespace_map</"
"filename> unless the field is empty. These files are vital to the backup "
"working, and must be written without modification."
msgstr ""
"Функция <function>pg_stop_backup</function> возвратит одну строку с тремя "
"значениями. Второе из них нужно записать в файл <filename>backup_label</"
"filename> в корневой каталог резервной копии. Третье значение, если оно не "
"пустое, должно быть записано в файл <filename>tablespace_map</filename>. Эти "
"значения крайне важны для восстановления копии и должны записываться без "
"изменений."

#: backup.xml:908(para)
msgid ""
"Once the WAL segment files active during the backup are archived, you are "
"done. The file identified by <function>pg_stop_backup</function>'s first "
"return value is the last segment that is required to form a complete set of "
"backup files. If <varname>archive_mode</varname> is enabled, "
"<function>pg_stop_backup</function> does not return until the last segment "
"has been archived. Archiving of these files happens automatically since you "
"have already configured <varname>archive_command</varname>. In most cases "
"this happens quickly, but you are advised to monitor your archive system to "
"ensure there are no delays. If the archive process has fallen behind because "
"of failures of the archive command, it will keep retrying until the archive "
"succeeds and the backup is complete. If you wish to place a time limit on "
"the execution of <function>pg_stop_backup</function>, set an appropriate "
"<varname>statement_timeout</varname> value, but make note that if "
"<function>pg_stop_backup</function> terminates because of this your backup "
"may not be valid."
msgstr ""
"После этого останется заархивировать файлы сегментов WAL, активных во время "
"создания резервной копии, и процедура резервного копирования будет "
"завершена. Функция <function>pg_stop_backup</function> в первом значении "
"результата указывает, какой последний сегмент требуется для формирования "
"полного набора файлов резервной копии. Если включён режим архивации "
"(параметр <varname>archive_mode</varname>), функция "
"<function>pg_stop_backup</function> не завершится, пока не будет "
"заархивирован последний сегмент. В этом случае файлы будут заархивированы "
"автоматически, поскольку также должна быть настроена команда "
"<varname>archive_command</varname>. Чаще всего это происходит быстро, но мы "
"советуем наблюдать за системой архивации и проверять, не возникают ли "
"задержки. Если архивирование остановится из-за ошибок команды архивации, "
"попытки архивации будут продолжаться до успешного завершения, и только тогда "
"резервная копия будет завершена. Если вы хотите ограничить время выполнения "
"<function>pg_stop_backup</function>, установите соответствующее значение в "
"<varname>statement_timeout</varname>, но заметьте, что в случае прерывания "
"<function>pg_stop_backup</function> по времени резервная копия может "
"оказаться негодной."

#: backup.xml:933(title)
msgid "Making an exclusive low level backup"
msgstr "Монопольное резервное копирование на низком уровне"

#: backup.xml:934(para)
msgid ""
"The process for an exclusive backup is mostly the same as for a non-"
"exclusive one, but it differs in a few key steps. It does not allow more "
"than one concurrent backup to run, and there can be some issues on the "
"server if it crashes during the backup. Prior to PostgreSQL 9.6, this was "
"the only low-level method available, but it is now recommended that all "
"users upgrade their scripts to use non-exclusive backups if possible."
msgstr ""
"Монопольное резервное копирование во многом похоже на немонопольное, но "
"имеет несколько важных отличий. Этот вариант не позволяет запустить больше "
"одного процесса копирования одновременно, а в случае сбоя в процессе "
"копирования возможны некоторые осложнения на сервере. До PostgreSQL 9.6 это "
"был единственный возможный метод низкоуровневого копирования, но сейчас "
"пользователям рекомендуется по возможности подкорректировать свои скрипты и "
"перейти к использованию немонопольного варианта."

#: backup.xml:954(programlisting)
#, no-wrap
msgid "SELECT pg_start_backup('label');"
msgstr "SELECT pg_start_backup('label');"

#: backup.xml:950(para)
msgid ""
"Connect to the server (it does not matter which database) as a user with "
"rights to run pg_start_backup (superuser, or a user who has been granted "
"EXECUTE on the function) and issue the command: <placeholder-1/> where "
"<literal>label</literal> is any string you want to use to uniquely identify "
"this backup operation. <function>pg_start_backup</function> creates a "
"<firstterm>backup label</firstterm> file, called <filename>backup_label</"
"filename>, in the cluster directory with information about your backup, "
"including the start time and label string. The function also creates a "
"<firstterm>tablespace map</firstterm> file, called <filename>tablespace_map</"
"filename>, in the cluster directory with information about tablespace "
"symbolic links in <filename>pg_tblspc/</filename> if one or more such link "
"is present. Both files are critical to the integrity of the backup, should "
"you need to restore from it."
msgstr ""
"Подключитесь к серверу (к любой базе данных) как пользователь с правами на "
"выполнение pg_start_backup (суперпользователь или пользователь, которому "
"дано право EXECUTE для этой функции) и выполните команду: <placeholder-1/> "
"где <literal>label</literal> &mdash; любая метка, по которой можно "
"однозначно идентифицировать данную операцию резервного копирования. Функция "
"<function>pg_start_backup</function> создаёт в каталоге кластера файл "
"<firstterm>метки резервного копирования</firstterm>, называемый "
"<filename>backup_label</filename>, в который помещается информация о "
"резервной копии, включающая время начала и строку метки. Эта функция также "
"создаёт в каталоге кластера файл <firstterm>карты табличных пространств</"
"firstterm>, называемый <filename>tablespace_map</filename>, с информацией о "
"символических ссылках табличных пространств в <filename>pg_tblspc/</"
"filename>, если такие ссылки есть. Оба файла важны для целостности резервных "
"копии и понадобятся при восстановлении."

#: backup.xml:979(programlisting)
#, no-wrap
msgid "SELECT pg_start_backup('label', true);"
msgstr "SELECT pg_start_backup('label', true);"

#: backup.xml:969(para)
msgid ""
"By default, <function>pg_start_backup</function> can take a long time to "
"finish. This is because it performs a checkpoint, and the I/O required for "
"the checkpoint will be spread out over a significant period of time, by "
"default half your inter-checkpoint interval (see the configuration parameter "
"<xref linkend=\"guc-checkpoint-completion-target\"/>). This is usually what "
"you want, because it minimizes the impact on query processing. If you want "
"to start the backup as soon as possible, use: <placeholder-1/> This forces "
"the checkpoint to be done as quickly as possible."
msgstr ""
"По умолчанию <function>pg_start_backup</function> может выполняться "
"длительное время. Это объясняется тем, что функция выполняет контрольную "
"точку, а операции ввода/вывода, требуемые для этого, распределяются в "
"интервале времени, по умолчанию равном половине интервала между контрольными "
"точками (см. параметр <xref linkend=\"guc-checkpoint-completion-target\"/>). "
"Обычно это вполне приемлемо, так как при этом минимизируется влияние на "
"выполнение других запросов. Если же вы хотите начать резервное копирование "
"максимально быстро, выполните: <placeholder-1/> При этом контрольная точка "
"будет выполнена как можно скорее."

#: backup.xml:1002(programlisting)
#, no-wrap
msgid "SELECT pg_stop_backup();"
msgstr "SELECT pg_stop_backup();"

#: backup.xml:998(para)
msgid ""
"Again connect to the database as a user with rights to run pg_stop_backup "
"(superuser, or a user who has been granted EXECUTE on the function), and "
"issue the command: <placeholder-1/> This terminates the backup mode and "
"performs an automatic switch to the next WAL segment. The reason for the "
"switch is to arrange for the last WAL segment file written during the backup "
"interval to be ready to archive."
msgstr ""
"Снова подключитесь к базе данных как пользователь с правами на выполнение "
"pg_stop_backup (суперпользователь или пользователь, которому дано право "
"EXECUTE для этой функции) и выполните команду: <placeholder-1/> Сервер "
"выйдет из режима резервного копирования и автоматически переключится на "
"следующий сегмент WAL. Это переключение выполняется для того, чтобы файл "
"последнего сегмента WAL, записанного во время копирования, был готов к "
"архивации."

#: backup.xml:1012(para)
msgid ""
"Once the WAL segment files active during the backup are archived, you are "
"done. The file identified by <function>pg_stop_backup</function>'s result is "
"the last segment that is required to form a complete set of backup files. If "
"<varname>archive_mode</varname> is enabled, <function>pg_stop_backup</"
"function> does not return until the last segment has been archived. "
"Archiving of these files happens automatically since you have already "
"configured <varname>archive_command</varname>. In most cases this happens "
"quickly, but you are advised to monitor your archive system to ensure there "
"are no delays. If the archive process has fallen behind because of failures "
"of the archive command, it will keep retrying until the archive succeeds and "
"the backup is complete. If you wish to place a time limit on the execution "
"of <function>pg_stop_backup</function>, set an appropriate "
"<varname>statement_timeout</varname> value, but make note that if "
"<function>pg_stop_backup</function> terminates because of this your backup "
"may not be valid."
msgstr ""
"После этого останется заархивировать файлы сегментов WAL, активных во время "
"создания резервной копии, и процедура резервного копирования будет "
"завершена. Функция <function>pg_stop_backup</function> возвращает указание "
"на файл последнего сегмента, который требуется для формирования полного "
"набора файлов резервной копии. Если включён режим архивации (параметр "
"<varname>archive_mode</varname>), функция <function>pg_stop_backup</"
"function> не завершится, пока не будет заархивирован последний сегмент. В "
"этом случае файлы будут заархивированы автоматически, поскольку также должна "
"быть настроена команда <varname>archive_command</varname>. Чаще всего это "
"происходит быстро, но мы советуем наблюдать за системой архивации и "
"проверять, не возникают ли задержки. Если архивирование остановится из-за "
"ошибок команды архивации, попытки архивации будут продолжаться до успешного "
"завершения, и только тогда резервная копия будет завершена. Если вы хотите "
"ограничить время выполнения <function>pg_stop_backup</function>, установите "
"соответствующее значение в <varname>statement_timeout</varname>, но "
"заметьте, что в случае прерывания <function>pg_stop_backup</function> по "
"времени резервная копия может оказаться негодной."

#: backup.xml:1037(title)
msgid "Backing up the data directory"
msgstr "Копирование каталога данных"

#: backup.xml:1038(para)
msgid ""
"Some file system backup tools emit warnings or errors if the files they are "
"trying to copy change while the copy proceeds. When taking a base backup of "
"an active database, this situation is normal and not an error. However, you "
"need to ensure that you can distinguish complaints of this sort from real "
"errors. For example, some versions of <application>rsync</application> "
"return a separate exit code for <quote>vanished source files</quote>, and "
"you can write a driver script to accept this exit code as a non-error case. "
"Also, some versions of GNU <application>tar</application> return an error "
"code indistinguishable from a fatal error if a file was truncated while "
"<application>tar</application> was copying it. Fortunately, GNU "
"<application>tar</application> versions 1.16 and later exit with 1 if a file "
"was changed during the backup, and 2 for other errors. With GNU "
"<application>tar</application> version 1.23 and later, you can use the "
"warning options <literal>--warning=no-file-changed --warning=no-file-"
"removed</literal> to hide the related warning messages."
msgstr ""
"Некоторые средства резервного копирования файлов выдают предупреждения или "
"ошибки, если файлы, которые они пытаются скопировать, изменяются в процессе "
"копирования. При получении базовой резервной копии активной базы данных это "
"вполне нормально и не является ошибкой. Однако, вам нужно знать, как "
"отличить ошибки такого рода от реальных ошибок. Например, некоторые версии "
"<application>rsync</application> возвращают отдельный код выхода для "
"ситуации <quote>исчезнувшие исходные файлы</quote>, и вы можете написать "
"управляющий скрипт, который примет этот код как не ошибочный. Также "
"некоторые версии GNU <application>tar</application> возвращают код выхода, "
"неотличимый от кода фатальной ошибки, если файл был усечён, когда "
"<application>tar</application> копировал его. К счастью, GNU "
"<application>tar</application> версий 1.16 и более поздних завершается с "
"кодом 1, если файл был изменён во время копирования, и 2 в случае других "
"ошибок. С GNU <application>tar</application> версии 1.23 и более поздними, "
"вы можете использовать следующие ключи <literal>--warning=no-file-changed --"
"warning=no-file-removed</literal>, чтобы скрыть соответствующие "
"предупреждения."

#: backup.xml:1056(para)
msgid ""
"Be certain that your backup includes all of the files under the database "
"cluster directory (e.g., <filename>/usr/local/pgsql/data</filename>). If you "
"are using tablespaces that do not reside underneath this directory, be "
"careful to include them as well (and be sure that your backup archives "
"symbolic links as links, otherwise the restore will corrupt your "
"tablespaces)."
msgstr ""
"Убедитесь, что ваша резервная копия включает все файлы из каталога кластера "
"баз данных (например, <filename>/usr/local/pgsql/data</filename>). Если вы "
"используете табличные пространства, которые находятся не внутри этого "
"каталога, не забудьте включить и их в резервную копию (также важно, чтобы "
"при создании резервной копии символьные ссылки сохранялись как ссылки, иначе "
"табличные пространства будут повреждены при восстановлении)."

#: backup.xml:1065(para)
msgid ""
"You should, however, omit from the backup the files within the cluster's "
"<filename>pg_xlog/</filename> subdirectory. This slight adjustment is "
"worthwhile because it reduces the risk of mistakes when restoring. This is "
"easy to arrange if <filename>pg_xlog/</filename> is a symbolic link pointing "
"to someplace outside the cluster directory, which is a common setup anyway "
"for performance reasons. You might also want to exclude <filename>postmaster."
"pid</filename> and <filename>postmaster.opts</filename>, which record "
"information about the running <application>postmaster</application>, not "
"about the <application>postmaster</application> which will eventually use "
"this backup. (These files can confuse <application>pg_ctl</application>.)"
msgstr ""
"Однако следует исключить из резервной копии файлы в подкаталоге данных "
"кластера <filename>pg_xlog/</filename>. Эту небольшую корректировку стоит "
"внести для снижения риска ошибок при восстановлении. Это легко организовать, "
"если <filename>pg_xlog/</filename> — символическая ссылка на каталог за "
"пределами каталога данных (так часто делают из соображений "
"производительности). Также имеет смысл исключить файлы <filename>postmaster."
"pid</filename> и <filename>postmaster.opts</filename>, содержащие информацию "
"о работающем процессе <application>postmaster</application> (а не о том "
"процессе <application>postmaster</application>, который будет "
"восстанавливать эту копию). (Эти файлы могут ввести <application>pg_ctl</"
"application> в заблуждение.)"

#: backup.xml:1079(para)
msgid ""
"It is often a good idea to also omit from the backup the files within the "
"cluster's <filename>pg_replslot/</filename> directory, so that replication "
"slots that exist on the master do not become part of the backup. Otherwise, "
"the subsequent use of the backup to create a standby may result in "
"indefinite retention of WAL files on the standby, and possibly bloat on the "
"master if hot standby feedback is enabled, because the clients that are "
"using those replication slots will still be connecting to and updating the "
"slots on the master, not the standby. Even if the backup is only intended "
"for use in creating a new master, copying the replication slots isn't "
"expected to be particularly useful, since the contents of those slots will "
"likely be badly out of date by the time the new master comes on line."
msgstr ""
"Часто также стоит исключать из резервной копии каталог <filename>pg_replslot/"
"</filename> кластера, чтобы слоты репликации, существующие на главном "
"сервере, не попадали в копию. В противном случае, при последующем "
"восстановлении копии на резервном сервере может получиться так, что он будет "
"неограниченно долго сохранять файлы WAL, а главный не будет очищаться, если "
"он следит за горячим резервом, так как клиенты этих слотов репликации будут "
"продолжать подключаться и изменять состояние слотов на главном, а не "
"резервном сервере. Даже если резервная копия предназначена только для "
"создания нового главного сервера, копирование слотов репликации вряд ли "
"принесёт пользу, так как к моменту включения в работу этого нового сервера "
"содержимое этих слотов станет абсолютно неактуальным."

#: backup.xml:1094(para)
msgid ""
"The backup label file includes the label string you gave to "
"<function>pg_start_backup</function>, as well as the time at which "
"<function>pg_start_backup</function> was run, and the name of the starting "
"WAL file. In case of confusion it is therefore possible to look inside a "
"backup file and determine exactly which backup session the dump file came "
"from. The tablespace map file includes the symbolic link names as they exist "
"in the directory <filename>pg_tblspc/</filename> and the full path of each "
"symbolic link. These files are not merely for your information; their "
"presence and contents are critical to the proper operation of the system's "
"recovery process."
msgstr ""
"В файл метки резервной копии записывается строка метки, заданная при вызове "
"<function>pg_start_backup</function>, время запуска функции "
"<function>pg_start_backup</function> и имя начального файла WAL. Таким "
"образом, в случае сомнений можно заглянуть внутрь архива резервной копии и "
"точно определить, в каком сеансе резервного копирования он был создан. Файл "
"карты табличных пространств содержит имена символических ссылок, как они "
"существуют в каталоге <filename>pg_tblspc/</filename>, и полный путь каждой "
"символической ссылки. Эти файлы не только к вашему сведению; их "
"существование и содержание важны для правильного проведения процесса "
"восстановления системы."

#: backup.xml:1108(para)
msgid ""
"It is also possible to make a backup while the server is stopped. In this "
"case, you obviously cannot use <function>pg_start_backup</function> or "
"<function>pg_stop_backup</function>, and you will therefore be left to your "
"own devices to keep track of which backup is which and how far back the "
"associated WAL files go. It is generally better to follow the continuous "
"archiving procedure above."
msgstr ""
"Вы также можете создать резервную копию, когда сервер остановлен. В этом "
"случае, вы, очевидно, не сможете вызвать <function>pg_start_backup</"
"function> или <function>pg_stop_backup</function>, и следовательно, вам надо "
"будет самостоятельно как-то идентифицировать резервные копии и понимать, "
"какие файлы WAL должны быть заархивированы. Поэтому обычно всё-таки лучше "
"следовать вышеописанной процедуре непрерывного архивирования."

#: backup.xml:1120(title)
msgid "Recovering Using a Continuous Archive Backup"
msgstr "Восстановление непрерывной архивной копии"

#: backup.xml:1127(para)
msgid "Stop the server, if it's running."
msgstr "Остановите сервер баз данных, если он запущен."

#: backup.xml:1132(para)
msgid ""
"If you have the space to do so, copy the whole cluster data directory and "
"any tablespaces to a temporary location in case you need them later. Note "
"that this precaution will require that you have enough free space on your "
"system to hold two copies of your existing database. If you do not have "
"enough space, you should at least save the contents of the cluster's "
"<filename>pg_xlog</filename> subdirectory, as it might contain logs which "
"were not archived before the system went down."
msgstr ""
"Если у вас есть место для этого, скопируйте весь текущий каталог кластера "
"баз данных и все табличные пространства во временный каталог на случай, если "
"они вам понадобятся. Учтите, что эта мера предосторожности требует, чтобы "
"свободного места на диске было достаточно для размещения двух копий "
"существующих данных. Если места недостаточно, необходимо сохранить как "
"минимум содержимое подкаталога <filename>pg_xlog</filename> каталога "
"кластера, так как он может содержать журналы, не попавшие в архив перед "
"остановкой системы."

#: backup.xml:1144(para)
msgid ""
"Remove all existing files and subdirectories under the cluster data "
"directory and under the root directories of any tablespaces you are using."
msgstr ""
"Удалите все существующие файлы и подкаталоги из каталога кластера и из "
"корневых каталогов используемых табличных пространств."

#: backup.xml:1150(para)
msgid ""
"Restore the database files from your file system backup. Be sure that they "
"are restored with the right ownership (the database system user, not "
"<literal>root</literal>!) and with the right permissions. If you are using "
"tablespaces, you should verify that the symbolic links in "
"<filename>pg_tblspc/</filename> were correctly restored."
msgstr ""
"Восстановите файлы базы данных из архивной копии файлов. Важно, чтобы у "
"восстановленных файлов были правильные разрешения и правильный владелец "
"(пользователь, запускающий сервер, а не <literal>root</literal>!). Если вы "
"используете табличные пространства, убедитесь также, что символьные ссылки в "
"<filename>pg_tblspc/</filename> восстановились корректно."

#: backup.xml:1160(para)
msgid ""
"Remove any files present in <filename>pg_xlog/</filename>; these came from "
"the file system backup and are therefore probably obsolete rather than "
"current. If you didn't archive <filename>pg_xlog/</filename> at all, then "
"recreate it with proper permissions, being careful to ensure that you re-"
"establish it as a symbolic link if you had it set up that way before."
msgstr ""
"Удалите все файлы из <filename>pg_xlog/</filename>; они восстановились из "
"резервной копии файлов и поэтому, скорее всего, будут старее текущих. Если "
"вы вовсе не архивировали <filename>pg_xlog/</filename>, создайте этот "
"каталог с правильными правами доступа, но если это была символьная ссылка, "
"восстановите её."

#: backup.xml:1170(para)
msgid ""
"If you have unarchived WAL segment files that you saved in step 2, copy them "
"into <filename>pg_xlog/</filename>. (It is best to copy them, not move them, "
"so you still have the unmodified files if a problem occurs and you have to "
"start over.)"
msgstr ""
"Если на шаге 2 вы сохранили незаархивированные файлы с сегментами WAL, "
"скопируйте их в <filename>pg_xlog/</filename>. (Лучше всего именно "
"копировать, а не перемещать их, чтобы у вас остались неизменённые файлы на "
"случай, если возникнет проблема и всё придётся начинать сначала.)"

#: backup.xml:1178(para)
msgid ""
"Create a recovery command file <filename>recovery.conf</filename> in the "
"cluster data directory (see <xref linkend=\"recovery-config\"/>). You might "
"also want to temporarily modify <filename>pg_hba.conf</filename> to prevent "
"ordinary users from connecting until you are sure the recovery was "
"successful."
msgstr ""
"Создайте командный файл восстановления <filename>recovery.conf</filename> в "
"каталоге кластера баз данных (см. <xref remap=\"4\" linkend=\"recovery-config"
"\"/>). Вы можете также временно изменить <filename>pg_hba.conf</filename>, "
"чтобы обычные пользователи не могли подключаться, пока вы не будете уверены, "
"что восстановление завершилось успешно."

#: backup.xml:1186(para)
msgid ""
"Start the server. The server will go into recovery mode and proceed to read "
"through the archived WAL files it needs. Should the recovery be terminated "
"because of an external error, the server can simply be restarted and it will "
"continue recovery. Upon completion of the recovery process, the server will "
"rename <filename>recovery.conf</filename> to <filename>recovery.done</"
"filename> (to prevent accidentally re-entering recovery mode later) and then "
"commence normal database operations."
msgstr ""
"Запустите сервер. Сервер запустится в режиме восстановления и начнёт "
"считывать необходимые ему архивные файлы WAL. Если восстановление будет "
"прервано из-за внешней ошибки, сервер можно просто перезапустить и он "
"продолжит восстановление. По завершении процесса восстановления сервер "
"переименует файл <filename>recovery.conf</filename> в <filename>recovery."
"done</filename> (чтобы предотвратить повторный запуск режима "
"восстановления), а затем перейдёт к обычной работе с базой данных."

#: backup.xml:1198(para)
msgid ""
"Inspect the contents of the database to ensure you have recovered to the "
"desired state. If not, return to step 1. If all is well, allow your users to "
"connect by restoring <filename>pg_hba.conf</filename> to normal."
msgstr ""
"Просмотрите содержимое базы данных, чтобы убедиться, что вы вернули её к "
"желаемому состоянию. Если это не так, вернитесь к шагу 1. Если всё хорошо, "
"разрешите пользователям подключаться к серверу, восстановив обычный файл "
"<filename>pg_hba.conf</filename>."

#: backup.xml:1122(para)
msgid ""
"Okay, the worst has happened and you need to recover from your backup. Here "
"is the procedure: <placeholder-1/>"
msgstr ""
"Допустим, худшее случилось и вам необходимо восстановить базу данных из "
"резервной копии. Порядок действий таков: <placeholder-1/>"

#: backup.xml:1224(programlisting)
#, no-wrap
msgid "restore_command = 'cp /mnt/server/archivedir/%f %p'"
msgstr "restore_command = 'cp /mnt/server/archivedir/%f %p'"

#: backup.xml:1207(para)
msgid ""
"The key part of all this is to set up a recovery configuration file that "
"describes how you want to recover and how far the recovery should run. You "
"can use <filename>recovery.conf.sample</filename> (normally located in the "
"installation's <filename>share/</filename> directory) as a prototype. The "
"one thing that you absolutely must specify in <filename>recovery.conf</"
"filename> is the <varname>restore_command</varname>, which tells "
"<productname>PostgreSQL</productname> how to retrieve archived WAL file "
"segments. Like the <varname>archive_command</varname>, this is a shell "
"command string. It can contain <literal>%f</literal>, which is replaced by "
"the name of the desired log file, and <literal>%p</literal>, which is "
"replaced by the path name to copy the log file to. (The path name is "
"relative to the current working directory, i.e., the cluster's data "
"directory.) Write <literal>%%</literal> if you need to embed an actual "
"<literal>%</literal> character in the command. The simplest useful command "
"is something like: <placeholder-1/> which will copy previously archived WAL "
"segments from the directory <filename>/mnt/server/archivedir</filename>. Of "
"course, you can use something much more complicated, perhaps even a shell "
"script that requests the operator to mount an appropriate tape."
msgstr ""
"Ключевой момент этой процедуры заключается в создании файла конфигурации "
"восстановления, описывающего, как будет выполняться восстановление и до "
"какой точки. В качестве прототипа вы можете использовать файл "
"<filename>recovery.conf.sample</filename> (он обычно помещается в каталог "
"<filename>share/</filename> после установки). Единственное, что совершенно "
"необходимо указать в <filename>recovery.conf</filename> &mdash; это команду "
"<varname>restore_command</varname>, которая говорит <productname>PostgreSQL</"
"productname>, как получать из архива файл-сегменты WAL. Как и "
"<varname>archive_command</varname>, это командная строка для оболочки. Она "
"может содержать символы <literal>%f</literal>, которые заменятся именем "
"требующегося файла журнала, и <literal>%p</literal>, которые заменятся "
"целевым путём для копирования этого файла. (Путь задаётся относительно "
"текущего рабочего каталога, т. е. каталога кластера данных.) Если вам нужно "
"включить в команду сам символ <literal>%</literal>, напишите <literal>%%</"
"literal>. Простейшая команда, которая может быть полезна, такая: "
"<placeholder-1/> Эта команда копирует заархивированные ранее сегменты WAL из "
"каталога <filename>/mnt/server/archivedir</filename>. Разумеется, вы можете "
"использовать что-то более сложное, возможно, даже скрипт оболочки, который "
"укажет оператору установить соответствующую ленту."

#: backup.xml:1233(para)
msgid ""
"It is important that the command return nonzero exit status on failure. The "
"command <emphasis>will</emphasis> be called requesting files that are not "
"present in the archive; it must return nonzero when so asked. This is not an "
"error condition. An exception is that if the command was terminated by a "
"signal (other than <systemitem>SIGTERM</systemitem>, which is used as part "
"of a database server shutdown) or an error by the shell (such as command not "
"found), then recovery will abort and the server will not start up."
msgstr ""
"Важно, чтобы данная команда возвращала ненулевой код возврата в случае "
"ошибки. Эта команда <emphasis>будет</emphasis> вызываться и с запросом "
"файлов, отсутствующих в архиве; в этом случае она должна вернуть ненулевое "
"значение и это считается штатной ситуацией. В исключительной ситуации, когда "
"команда была прервана сигналом (кроме <systemitem>SIGTERM</systemitem>, "
"который применяется в процессе остановки сервера базы данных) или произошла "
"ошибка оболочки (например, команда не найдена), восстановление будет "
"прервано и сервер не запустится."

#: backup.xml:1244(para)
msgid ""
"Not all of the requested files will be WAL segment files; you should also "
"expect requests for files with a suffix of <literal>.backup</literal> or "
"<literal>.history</literal>. Also be aware that the base name of the "
"<literal>%p</literal> path will be different from <literal>%f</literal>; do "
"not expect them to be interchangeable."
msgstr ""
"Не все запрашиваемые файлы будут сегментами WAL; следует также ожидать "
"запросов файлов с суффиксом <literal>.backup</literal> или <literal>."
"history</literal>. Также учтите, что базовое имя пути <literal>%p</literal> "
"будет отличаться от <literal>%f</literal>; не думайте, что они "
"взаимозаменяемы."

#: backup.xml:1252(para)
msgid ""
"WAL segments that cannot be found in the archive will be sought in "
"<filename>pg_xlog/</filename>; this allows use of recent un-archived "
"segments. However, segments that are available from the archive will be used "
"in preference to files in <filename>pg_xlog/</filename>."
msgstr ""
"Сегменты WAL, которые не найдутся в архиве, система будет искать в "
"<filename>pg_xlog/</filename>; благодаря этому можно использовать последние "
"незаархивированные сегменты. Однако файлы в <filename>pg_xlog/</filename> "
"будут менее предпочтительными, если такие сегменты окажутся в архиве."

#: backup.xml:1259(para)
msgid ""
"Normally, recovery will proceed through all available WAL segments, thereby "
"restoring the database to the current point in time (or as close as possible "
"given the available WAL segments). Therefore, a normal recovery will end "
"with a <quote>file not found</quote> message, the exact text of the error "
"message depending upon your choice of <varname>restore_command</varname>. "
"You may also see an error message at the start of recovery for a file named "
"something like <filename>00000001.history</filename>. This is also normal "
"and does not indicate a problem in simple recovery situations; see <xref "
"linkend=\"backup-timelines\"/> for discussion."
msgstr ""
"Обычно при восстановлении обрабатываются все доступные сегменты WAL и, таким "
"образом, база данных восстанавливается до последнего момента времени (или "
"максимально близкого к нему, в зависимости от наличия сегментов WAL). Таким "
"образом, восстановление обычно завершается с сообщением <quote>файл не "
"найден</quote>; точный текст сообщения об ошибке зависит от того, что делает "
"<varname>restore_command</varname>. Вы также можете увидеть сообщение об "
"ошибке в начале восстановления для файла с именем типа <filename>00000001."
"history</filename>. Это также нормально и обычно не говорит о какой-либо "
"проблеме при восстановлении в простых ситуациях; подробнее об этом "
"рассказывается в <xref remap=\"6\" linkend=\"backup-timelines\"/>."

#: backup.xml:1272(para)
msgid ""
"If you want to recover to some previous point in time (say, right before the "
"junior DBA dropped your main transaction table), just specify the required "
"<link linkend=\"recovery-target-settings\">stopping point</link> in "
"<filename>recovery.conf</filename>. You can specify the stop point, known as "
"the <quote>recovery target</quote>, either by date/time, named restore point "
"or by completion of a specific transaction ID. As of this writing only the "
"date/time and named restore point options are very usable, since there are "
"no tools to help you identify with any accuracy which transaction ID to use."
msgstr ""
"Если вы хотите восстановить базу на какой-то момент времени (скажем, до "
"момента, когда неопытный администратор базы данных удалил основную таблицу "
"транзакций), просто укажите требуемую <link linkend=\"recovery-target-"
"settings\">точку остановки</link> в <filename>recovery.conf</filename>. Вы "
"можете задать точку останова, так называемую <quote>цель восстановления</"
"quote>, по дате/времени, именованной точке восстановления или определённому "
"идентификатору транзакции. На момент написания этой документации полезными "
"могут быть только указания даты/времени или имени точки восстановления, пока "
"нет никаких средств, позволяющих точно определить, какой идентификатор "
"транзакции нужно выбрать."

#: backup.xml:1284(para)
msgid ""
"The stop point must be after the ending time of the base backup, i.e., the "
"end time of <function>pg_stop_backup</function>. You cannot use a base "
"backup to recover to a time when that backup was in progress. (To recover to "
"such a time, you must go back to your previous base backup and roll forward "
"from there.)"
msgstr ""
"Точка останова должна указывать на момент после окончания базового "
"копирования, т. е. после времени завершения <function>pg_stop_backup</"
"function>. Использовать базовую резервную копию для восстановления на момент "
"времени, когда она ещё только создавалась, нельзя. (Чтобы восстановить "
"данные на этот момент времени, придётся вернуться к предыдущей базовой "
"резервной копии и накатывать изменения с этой позиции.)"

#: backup.xml:1293(para)
msgid ""
"If recovery finds corrupted WAL data, recovery will halt at that point and "
"the server will not start. In such a case the recovery process could be re-"
"run from the beginning, specifying a <quote>recovery target</quote> before "
"the point of corruption so that recovery can complete normally. If recovery "
"fails for an external reason, such as a system crash or if the WAL archive "
"has become inaccessible, then the recovery can simply be restarted and it "
"will restart almost from where it failed. Recovery restart works much like "
"checkpointing in normal operation: the server periodically forces all its "
"state to disk, and then updates the <filename>pg_control</filename> file to "
"indicate that the already-processed WAL data need not be scanned again."
msgstr ""
"Если при восстановлении обнаруживаются повреждённые данные WAL, "
"восстановление прерывается в этом месте и сервер не запускается. В этом "
"случае процесс восстановления можно перезапустить с начала, указав "
"<quote>цель восстановления</quote> до точки повреждения, чтобы "
"восстановление могло завершиться нормально. Если восстановление завершается "
"ошибкой из-за внешней причины, например, из-за краха системы или "
"недоступности архива WAL, его можно просто перезапустить, и оно продолжится "
"с того места, где было прервано. Перезапуск восстановления реализован по "
"тому же принципу, что и контрольные точки при обычной работе: сервер "
"периодически сохраняет всё текущее состояние на диске и отражает это в файле "
"<filename>pg_control</filename>, чтобы уже обработанные данные WAL не "
"приходилось сканировать снова."

#: backup.xml:1311(title)
msgid "Timelines"
msgstr "Линии времени"

#: backup.xml:1313(indexterm)
msgid "<primary>timelines</primary>"
msgstr "<primary>линии времени</primary>"

#: backup.xml:1317(para)
msgid ""
"The ability to restore the database to a previous point in time creates some "
"complexities that are akin to science-fiction stories about time travel and "
"parallel universes. For example, in the original history of the database, "
"suppose you dropped a critical table at 5:15PM on Tuesday evening, but "
"didn't realize your mistake until Wednesday noon. Unfazed, you get out your "
"backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and "
"running. In <emphasis>this</emphasis> history of the database universe, you "
"never dropped the table. But suppose you later realize this wasn't such a "
"great idea, and would like to return to sometime Wednesday morning in the "
"original history. You won't be able to if, while your database was up-and-"
"running, it overwrote some of the WAL segment files that led up to the time "
"you now wish you could get back to. Thus, to avoid this, you need to "
"distinguish the series of WAL records generated after you've done a point-in-"
"time recovery from those that were generated in the original database "
"history."
msgstr ""
"Возможность восстановить базу данных на некий предыдущий момент времени "
"создаёт некоторые сложности, сродни научно-фантастическим историям о "
"путешествиях во времени и параллельных мирах. Например, предположим, что в "
"начальной истории базы данных вы удалили важную таблицу в 17:15 во вторник, "
"но осознали эту ошибку только в среду в полдень. Вы можете спокойно взять "
"резервную копию, восстановить данные на 17:14 во вторник и запустить сервер. "
"В <emphasis>этой</emphasis> истории мира базы данных вы никогда не удаляли "
"вышеупомянутую таблицу. Но предположим, что позже вы заметили, что это была "
"не такая уж хорошая идея и захотели вернуться к утру среды в первоначальной "
"истории базы данных. Вы не сможете сделать это, если в процессе работы базы "
"данных она успеет перезаписать какие-либо файлы-сегменты WAL, приводящие к "
"моменту времени, к которому вы хотите вернуться теперь. Таким образом, для "
"получения желаемого результата необходимо как-то отличать последовательности "
"записей WAL, добавленные после восстановления на какой-то момент времени от "
"тех, что существовали в начальной истории базы данных."

#: backup.xml:1336(para)
msgid ""
"To deal with this problem, <productname>PostgreSQL</productname> has a "
"notion of <firstterm>timelines</firstterm>. Whenever an archive recovery "
"completes, a new timeline is created to identify the series of WAL records "
"generated after that recovery. The timeline ID number is part of WAL segment "
"file names so a new timeline does not overwrite the WAL data generated by "
"previous timelines. It is in fact possible to archive many different "
"timelines. While that might seem like a useless feature, it's often a "
"lifesaver. Consider the situation where you aren't quite sure what point-in-"
"time to recover to, and so have to do several point-in-time recoveries by "
"trial and error until you find the best place to branch off from the old "
"history. Without timelines this process would soon generate an unmanageable "
"mess. With timelines, you can recover to <emphasis>any</emphasis> prior "
"state, including states in timeline branches that you abandoned earlier."
msgstr ""
"Для решения этой проблемы в <productname>PostgreSQL</productname> есть такое "
"понятие, как <firstterm>линия времени</firstterm>. Всякий раз, когда "
"завершается восстановление из архива, создаётся новая линия времени, "
"позволяющая идентифицировать последовательность записей WAL, добавленных "
"после этого восстановления. Номер линии времени включается в имя файлов-"
"сегментов WAL, так что файлы новой линии времени не перезаписывают файлы "
"WAL, сгенерированные предыдущими линиями времени. Фактически это позволяет "
"архивировать много различных линий времени. Хотя это может показаться "
"бесполезной возможностью, на самом деле она часто бывает спасительной. "
"Представьте, что вы не определились, какую точку времени выбрать для "
"восстановления, и таким образом должны проводить восстановление методом проб "
"и ошибок, пока не найдёте лучший момент для ответвления от старой истории. "
"Без линий времени этот процесс быстро стал бы очень запутанным. А благодаря "
"линиям времени, вы можете вернуться к <emphasis>любому</emphasis> "
"предыдущему состоянию, включая состояния в ветках линий времени, покинутых "
"ранее."

#: backup.xml:1353(para)
msgid ""
"Every time a new timeline is created, <productname>PostgreSQL</productname> "
"creates a <quote>timeline history</quote> file that shows which timeline it "
"branched off from and when. These history files are necessary to allow the "
"system to pick the right WAL segment files when recovering from an archive "
"that contains multiple timelines. Therefore, they are archived into the WAL "
"archive area just like WAL segment files. The history files are just small "
"text files, so it's cheap and appropriate to keep them around indefinitely "
"(unlike the segment files which are large). You can, if you like, add "
"comments to a history file to record your own notes about how and why this "
"particular timeline was created. Such comments will be especially valuable "
"when you have a thicket of different timelines as a result of "
"experimentation."
msgstr ""
"Каждый раз, когда образуется новая линия времени, <productname>PostgreSQL</"
"productname> создаёт файл <quote>истории линии времени</quote>, "
"показывающий, от какой линии времени ответвилась данная и когда. Эти файлы "
"истории нужны, чтобы система могла выбрать правильные файлы-сегменты WAL при "
"восстановлении из архива, содержащего несколько линий времени. Таким "
"образом, они помещаются в область архивов WAL так же, как и файлы сегментов "
"WAL. Файлы истории представляют собой небольшие текстовые файлы, так что они "
"не занимают много места и их вполне можно сохранять неограниченно долго (в "
"отличие от файлов сегментов, имеющих большой размер). Если хотите, вы можете "
"добавлять в файл истории комментарии, свои собственные заметки о том, как и "
"почему была создана эта конкретная линия времени. Такие комментарии будут "
"особенно ценны, если в результате экспериментов у вас образуется "
"хитросплетение разных линий времени."

#: backup.xml:1368(para)
msgid ""
"The default behavior of recovery is to recover along the same timeline that "
"was current when the base backup was taken. If you wish to recover into some "
"child timeline (that is, you want to return to some state that was itself "
"generated after a recovery attempt), you need to specify the target timeline "
"ID in <filename>recovery.conf</filename>. You cannot recover into timelines "
"that branched off earlier than the base backup."
msgstr ""
"По умолчанию при восстановлении восстанавливается та же линия времени, "
"которая была текущей при создании базовой резервной копии. Если вы хотите "
"восстановить состояние на какой-либо дочерней линии времени, (то есть, "
"хотите вернуться к некоторому состоянию, которое тоже было получено в "
"результате попытки восстановления), вам необходимо указать идентификатор "
"целевой линии времени в <filename>recovery.conf</filename>. Восстановить "
"состояние в линии времени, ответвившейся раньше, чем была сделана базовая "
"резервная копия, нельзя."

#: backup.xml:1379(title)
msgid "Tips and Examples"
msgstr "Советы и примеры"

#: backup.xml:1381(para)
msgid "Some tips for configuring continuous archiving are given here."
msgstr ""
"Ниже мы дадим несколько советов по настройке непрерывного архивирования."

#: backup.xml:1386(title)
msgid "Standalone Hot Backups"
msgstr "Обособленные горячие резервные копии"

#: backup.xml:1388(para)
msgid ""
"It is possible to use <productname>PostgreSQL</productname>'s backup "
"facilities to produce standalone hot backups. These are backups that cannot "
"be used for point-in-time recovery, yet are typically much faster to backup "
"and restore than <application>pg_dump</application> dumps. (They are also "
"much larger than <application>pg_dump</application> dumps, so in some cases "
"the speed advantage might be negated.)"
msgstr ""
"Средства резервного копирования <productname>PostgreSQL</productname> можно "
"применять для создания обособленных горячих копий. Эти копии нельзя "
"использовать для восстановления на момент времени, но создаются и "
"восстанавливаются они обычно гораздо быстрее, чем дампы "
"<application>pg_dump</application>. (Они также намного больше, чем дампы "
"<application>pg_dump</application>, так что в некоторых случаях выигрыш в "
"скорости может быть потерян.)"

#: backup.xml:1397(para)
msgid ""
"As with base backups, the easiest way to produce a standalone hot backup is "
"to use the <xref linkend=\"app-pgbasebackup\"/> tool. If you include the "
"<literal>-X</literal> parameter when calling it, all the transaction log "
"required to use the backup will be included in the backup automatically, and "
"no special action is required to restore the backup."
msgstr ""
"Как и базовые резервные копии, обособленную горячую копию проще всего "
"получить, используя программу <xref linkend=\"app-pgbasebackup\"/>. Если вы "
"вызовете эту программу с параметром <literal>-X</literal>, в эту копию "
"автоматически будет включён весь журнал транзакций, необходимый для её "
"использования, так что никакие особые действия для восстановления не "
"потребуются."

#: backup.xml:1413(programlisting)
#, no-wrap
msgid "archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'"
msgstr "archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'"

#: backup.xml:1406(para)
msgid ""
"If more flexibility in copying the backup files is needed, a lower level "
"process can be used for standalone hot backups as well. To prepare for low "
"level standalone hot backups, set <varname>wal_level</varname> to "
"<literal>replica</literal> or higher, <varname>archive_mode</varname> to "
"<literal>on</literal>, and set up an <varname>archive_command</varname> that "
"performs archiving only when a <emphasis>switch file</emphasis> exists. For "
"example: <placeholder-1/> This command will perform archiving when "
"<filename>/var/lib/pgsql/backup_in_progress</filename> exists, and otherwise "
"silently return zero exit status (allowing <productname>PostgreSQL</"
"productname> to recycle the unwanted WAL file)."
msgstr ""
"Если нужна дополнительная гибкость в процессе копирования файлов, создавать "
"обособленные горячие копии можно также на более низком уровне. Чтобы "
"подготовиться к получению такой копии на низком уровне, установите в "
"<varname>wal_level</varname> уровень <literal>replica</literal> (или выше), "
"в <varname>archive_mode</varname> значение <literal>on</literal> и настройте "
"команду <varname>archive_command</varname>, которая будет выполнять "
"архивацию, только когда существует <emphasis>файл-переключатель</emphasis>. "
"Например: <placeholder-1/> Данная команда выполнит архивацию, если будет "
"существовать файл <filename>/var/lib/pgsql/backup_in_progress</filename>, а "
"в противном случае просто вернёт нулевой код возврата (и тогда "
"<productname>PostgreSQL</productname> сможет переработать ненужный файл WAL)."

#: backup.xml:1425(programlisting)
#, no-wrap
msgid ""
"touch /var/lib/pgsql/backup_in_progress\n"
"psql -c \"select pg_start_backup('hot_backup');\"\n"
"tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/\n"
"psql -c \"select pg_stop_backup();\"\n"
"rm /var/lib/pgsql/backup_in_progress\n"
"tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/"
msgstr ""
"touch /var/lib/pgsql/backup_in_progress\n"
"psql -c \"select pg_start_backup('hot_backup');\"\n"
"tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/\n"
"psql -c \"select pg_stop_backup();\"\n"
"rm /var/lib/pgsql/backup_in_progress\n"
"tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/"

#: backup.xml:1422(para)
msgid ""
"With this preparation, a backup can be taken using a script like the "
"following: <placeholder-1/> The switch file <filename>/var/lib/pgsql/"
"backup_in_progress</filename> is created first, enabling archiving of "
"completed WAL files to occur. After the backup the switch file is removed. "
"Archived WAL files are then added to the backup so that both base backup and "
"all required WAL files are part of the same <application>tar</application> "
"file. Please remember to add error handling to your backup scripts."
msgstr ""
"После такой подготовки резервную копию можно создать, например таким "
"скриптом: <placeholder-1/> Сначала создаётся файл-переключатель <filename>/"
"var/lib/pgsql/backup_in_progress</filename>, включающий архивирование "
"заполненных файлов WAL. По окончании резервного копирования файл-"
"переключатель удаляется. Затем заархивированные файлы WAL тоже добавляются в "
"резервную копию, так что в одном архиве <application>tar</application> "
"оказывается и базовая резервная копия, и все требуемые файлы WAL. "
"Пожалуйста, не забудьте добавить в ваши скрипты резервного копирования "
"обработку ошибок."

#: backup.xml:1444(title)
msgid "Compressed Archive Logs"
msgstr "Сжатие журналов в архиве"

#: backup.xml:1449(programlisting)
#, no-wrap
msgid "archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'"
msgstr "archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'"

#: backup.xml:1453(programlisting)
#, no-wrap
msgid "restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'"
msgstr "restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'"

#: backup.xml:1446(para)
msgid ""
"If archive storage size is a concern, you can use <application>gzip</"
"application> to compress the archive files: <placeholder-1/> You will then "
"need to use <application>gunzip</application> during recovery: "
"<placeholder-2/>"
msgstr ""
"Если размер архива имеет большое значение, можно воспользоваться "
"<application>gzip</application> и сжимать архивные файлы: <placeholder-1/> "
"При этом для восстановления придётся использовать <application>gunzip</"
"application>: <placeholder-2/>"

#: backup.xml:1460(title)
msgid "<varname>archive_command</varname> Scripts"
msgstr "Скрипты <varname>archive_command</varname>"

#: backup.xml:1466(programlisting)
#, no-wrap
msgid "archive_command = 'local_backup_script.sh \"%p\" \"%f\"'"
msgstr "archive_command = 'local_backup_script.sh \"%p\" \"%f\"'"

#: backup.xml:1462(para)
msgid ""
"Many people choose to use scripts to define their <varname>archive_command</"
"varname>, so that their <filename>postgresql.conf</filename> entry looks "
"very simple: <placeholder-1/> Using a separate script file is advisable any "
"time you want to use more than a single command in the archiving process. "
"This allows all complexity to be managed within the script, which can be "
"written in a popular scripting language such as <application>bash</"
"application> or <application>perl</application>."
msgstr ""
"Многие в качестве команды <varname>archive_command</varname> используют "
"скрипты, так что запись в <filename>postgresql.conf</filename> оказывается "
"очень простой: <placeholder-1/> Применять отдельный файла скрипта "
"целесообразно всегда, когда вы хотите использовать в процедуре архивирования "
"несколько команд. Это позволяет управлять сложностью этой процедуры в рамках "
"одного скрипта, который можно написать на любом популярном языке скриптов, "
"например на <application>bash</application> или <application>perl</"
"application>."

#: backup.xml:1480(para)
msgid "Copying data to secure off-site data storage"
msgstr "Копирование данных в безопасное внешнее хранилище"

#: backup.xml:1485(para)
msgid ""
"Batching WAL files so that they are transferred every three hours, rather "
"than one at a time"
msgstr ""
"Пакетная обработка файлов WAL, чтобы они передавались каждые три часа, а не "
"по одному"

#: backup.xml:1491(para)
msgid "Interfacing with other backup and recovery software"
msgstr ""
"Взаимодействие с другими приложениями резервного копирования и восстановления"

#: backup.xml:1496(para)
msgid "Interfacing with monitoring software to report errors"
msgstr "Взаимодействие со средствами мониторинга, регистрация ошибок"

#: backup.xml:1476(para)
msgid ""
"Examples of requirements that might be solved within a script include: "
"<placeholder-1/>"
msgstr ""
"В частности, с помощью скриптов можно решить такие задачи: <placeholder-1/>"

#: backup.xml:1504(para)
msgid ""
"When using an <varname>archive_command</varname> script, it's desirable to "
"enable <xref linkend=\"guc-logging-collector\"/>. Any messages written to "
"<systemitem>stderr</systemitem> from the script will then appear in the "
"database server log, allowing complex configurations to be diagnosed easily "
"if they fail."
msgstr ""
"Когда в <varname>archive_command</varname> используется скрипт, желательно "
"включить <xref linkend=\"guc-logging-collector\"/>. Тогда все сообщения, "
"которые скрипт выведет в <systemitem>stderr</systemitem>, будут записываться "
"в журнал сервера баз данных, что позволит легко диагностировать ошибки в "
"сложных конфигурациях."

#: backup.xml:1516(title)
msgid "Caveats"
msgstr "Ограничения"

#: backup.xml:1524(para)
msgid ""
"Operations on hash indexes are not presently WAL-logged, so replay will not "
"update these indexes. This will mean that any new inserts will be ignored by "
"the index, updated rows will apparently disappear and deleted rows will "
"still retain pointers. In other words, if you modify a table with a hash "
"index on it then you will get incorrect query results on a standby server. "
"When recovery completes it is recommended that you manually <xref linkend="
"\"sql-reindex\"/> each such index after completing a recovery operation."
msgstr ""
"Операции с хеш-индексами в настоящее время не проходят через WAL, так что "
"при воспроизведении WAL эти индексы не меняются. Это означает, что "
"добавление данных будет игнорироваться индексом, изменяемые строки будут "
"исчезать, а на удалённые строки сохранятся ссылки. Другими словами, если вы "
"изменяете таблицу, для которой есть хеш-индекс, на резервном сервере вы "
"будете получать некорректные результаты запросов. Поэтому по завершении "
"восстановления рекомендуется вручную выполнить <xref linkend=\"sql-reindex\"/"
"> для каждого такого индекса."

#: backup.xml:1537(para)
msgid ""
"If a <xref linkend=\"sql-createdatabase\"/> command is executed while a base "
"backup is being taken, and then the template database that the "
"<command>CREATE DATABASE</command> copied is modified while the base backup "
"is still in progress, it is possible that recovery will cause those "
"modifications to be propagated into the created database as well. This is of "
"course undesirable. To avoid this risk, it is best not to modify any "
"template databases while taking a base backup."
msgstr ""
"Если во время создания базовой резервной копии выполняется команда <xref "
"linkend=\"sql-createdatabase\"/>, а затем база-шаблон, задействованная в "
"<command>CREATE DATABASE</command>, изменяется, пока продолжается "
"копирование, возможно, что при восстановлении эти изменения распространятся "
"также и на созданную базу данных. Конечно, это нежелательно. Во избежание "
"подобных рисков, лучше всего не изменять никакие базы-шаблоны во время "
"получения базовой резервной копии."

#: backup.xml:1550(para)
msgid ""
"<xref linkend=\"sql-createtablespace\"/> commands are WAL-logged with the "
"literal absolute path, and will therefore be replayed as tablespace "
"creations with the same absolute path. This might be undesirable if the log "
"is being replayed on a different machine. It can be dangerous even if the "
"log is being replayed on the same machine, but into a new data directory: "
"the replay will still overwrite the contents of the original tablespace. To "
"avoid potential gotchas of this sort, the best practice is to take a new "
"base backup after creating or dropping tablespaces."
msgstr ""
"Команды <xref linkend=\"sql-createtablespace\"/> записываются в WAL с "
"абсолютным путём и, таким образом, при воспроизведении WAL будут выполнены с "
"тем же абсолютным путём. Это может быть нежелательно, если журнал "
"воспроизводится на другой машине. Но опасность есть, даже если журнал "
"воспроизводится на той же машине, но в другом каталоге данных: при "
"воспроизведении будет так же перезаписано содержимое исходных табличных "
"пространств. Чтобы избежать потенциальных проблем такого рода, лучше всего "
"делать новую базовую резервную копию после создания или удаления табличных "
"пространств."

#: backup.xml:1518(para)
msgid ""
"At this writing, there are several limitations of the continuous archiving "
"technique. These will probably be fixed in future releases: <placeholder-1/>"
msgstr ""
"На момент написания документации методика непрерывного архивирования имеет "
"несколько ограничений. Они могут быть ликвидированы в будущих версиях: "
"<placeholder-1/>"

#: backup.xml:1566(para)
msgid ""
"It should also be noted that the default <acronym>WAL</acronym> format is "
"fairly bulky since it includes many disk page snapshots. These page "
"snapshots are designed to support crash recovery, since we might need to fix "
"partially-written disk pages. Depending on your system hardware and "
"software, the risk of partial writes might be small enough to ignore, in "
"which case you can significantly reduce the total volume of archived logs by "
"turning off page snapshots using the <xref linkend=\"guc-full-page-writes\"/"
"> parameter. (Read the notes and warnings in <xref linkend=\"wal\"/> before "
"you do so.) Turning off page snapshots does not prevent use of the logs for "
"PITR operations. An area for future development is to compress archived WAL "
"data by removing unnecessary page copies even when "
"<varname>full_page_writes</varname> is on. In the meantime, administrators "
"might wish to reduce the number of page snapshots included in WAL by "
"increasing the checkpoint interval parameters as much as feasible."
msgstr ""
"Также следует заметить, что стандартный формат <acronym>WAL</acronym> не "
"очень компактный, так как включает много снимков дисковых страниц. Эти "
"снимки страниц предназначены для поддержки восстановления после сбоя, на "
"случай, если понадобится исправить страницы, записанные на диск частично. В "
"зависимости от аппаратного и программного обеспечения вашей системы, риск "
"частичной записи может быть достаточно мал, так что его можно игнорировать, "
"и в этом случае можно существенно уменьшить общий объём архивируемых "
"журналов, выключив снимки страниц с помощью параметра <xref linkend=\"guc-"
"full-page-writes\"/>. (Прежде чем делать это, прочтите замечания и "
"предупреждения в <xref remap=\"6\" linkend=\"wal\"/>.) Выключение снимков "
"страниц не препятствует использованию журналов для восстановления PITR. "
"Одним из направлений разработки в будущем является сжатие архивируемых "
"данных WAL, путём удаления ненужных копий страниц даже при включённом режиме "
"<varname>full_page_writes</varname>. Тем временем администраторы могут "
"сократить количество снимков страниц, включаемых в WAL, увеличив параметры "
"интервала контрольных точек в разумных пределах."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: backup.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
