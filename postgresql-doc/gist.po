# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: gist.xml:5(title)
msgid "GiST Indexes"
msgstr "Индексы GiST"

#: gist.xml:7(indexterm)
msgid "<primary>index</primary> <secondary>GiST</secondary>"
msgstr "<primary>индекс</primary> <secondary>GiST</secondary>"

#: gist.xml:13(title)
msgid "Introduction"
msgstr "Введение"

#: gist.xml:15(para)
msgid ""
"<acronym>GiST</acronym> stands for Generalized Search Tree. It is a "
"balanced, tree-structured access method, that acts as a base template in "
"which to implement arbitrary indexing schemes. B-trees, R-trees and many "
"other indexing schemes can be implemented in <acronym>GiST</acronym>."
msgstr ""
"<acronym>GiST</acronym> расшифровывается как <quote>Generalized Search Tree</"
"quote> (Обобщённое поисковое дерево). Это сбалансированный иерархический "
"метод доступа, который представляет собой базовый шаблон, на основе которого "
"могут реализовываться произвольные схемы индексации. На базе <acronym>GiST</"
"acronym> могут быть реализованы B-деревья, R-деревья и многие другие схемы "
"индексации."

#: gist.xml:22(para)
msgid ""
"One advantage of <acronym>GiST</acronym> is that it allows the development "
"of custom data types with the appropriate access methods, by an expert in "
"the domain of the data type, rather than a database expert."
msgstr ""
"Ключевым преимуществом <acronym>GiST</acronym> является то, что он позволяет "
"разрабатывать дополнительные типы данных с соответствующими методами доступа "
"экспертам в предметной области типа данных, а не специалистам по СУБД."

#: gist.xml:28(para)
msgid ""
"Some of the information here is derived from the University of California at "
"Berkeley's GiST Indexing Project <ulink url=\"http://gist.cs.berkeley.edu/"
"\">web site</ulink> and Marcel Kornacker's thesis, <ulink url=\"http://www."
"sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-"
"generation.pdf.gz\"> Access Methods for Next-Generation Database Systems</"
"ulink>. The <acronym>GiST</acronym> implementation in "
"<productname>PostgreSQL</productname> is primarily maintained by Teodor "
"Sigaev and Oleg Bartunov, and there is more information on their <ulink url="
"\"http://www.sai.msu.su/~megera/postgres/gist/\">web site</ulink>."
msgstr ""
"Представленная здесь информация частично позаимствована с <ulink url="
"\"http://gist.cs.berkeley.edu/\">сайта</ulink> Проекта индексации GiST "
"Калифорнийского университета в Беркли и из диссертации Марселя Корнакера "
"<ulink url=\"http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/"
"access-methods-for-next-generation.pdf.gz\">Методы доступа для СУБД "
"следующего поколения</ulink>. Сопровождением реализации <acronym>SP-GiST</"
"acronym> в <productname>PostgreSQL</productname> в основном занимаются Фёдор "
"Сигаев и Олег Бартунов; дополнительные сведения можно получить на их <ulink "
"url=\"http://www.sai.msu.su/~megera/postgres/gist/\">сайте</ulink>."

#: gist.xml:45(title)
msgid "Built-in Operator Classes"
msgstr "Встроенные классы операторов"

#: gist.xml:47(para)
msgid ""
"The core <productname>PostgreSQL</productname> distribution includes the "
"<acronym>GiST</acronym> operator classes shown in <xref linkend=\"gist-"
"builtin-opclasses-table\"/>. (Some of the optional modules described in "
"<xref linkend=\"contrib\"/> provide additional <acronym>GiST</acronym> "
"operator classes.)"
msgstr ""
"В базовый дистрибутив <productname>PostgreSQL</productname> включены классы "
"операторов <acronym>GiST</acronym>, перечисленные в <xref remap=\"6\" "
"linkend=\"gist-builtin-opclasses-table\"/>. (Некоторые дополнительные "
"модули, описанные в <xref remap=\"6\" linkend=\"contrib\"/>, добавляют "
"другие классы операторов <acronym>GiST</acronym>.)"

#: gist.xml:56(title)
msgid "Built-in <acronym>GiST</acronym> Operator Classes"
msgstr "Встроенные классы операторов <acronym>GiST</acronym>"

#: gist.xml:60(entry)
msgid "Name"
msgstr "Имя"

#: gist.xml:61(entry)
msgid "Indexed Data Type"
msgstr "Индексируемый тип данных"

#: gist.xml:62(entry)
msgid "Indexable Operators"
msgstr "Индексируемые операторы"

#: gist.xml:63(entry)
msgid "Ordering Operators"
msgstr "Операторы упорядочивания"

#: gist.xml:68(literal)
msgid "box_ops"
msgstr "box_ops"

#: gist.xml:69(type)
msgid "box"
msgstr "box"

#: gist.xml:71(literal) gist.xml:93(literal) gist.xml:116(literal)
#: gist.xml:152(literal) gist.xml:175(literal)
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#: gist.xml:72(literal) gist.xml:94(literal) gist.xml:153(literal)
#: gist.xml:176(literal)
msgid "&amp;&gt;"
msgstr "&amp;&gt;"

#: gist.xml:73(literal) gist.xml:95(literal) gist.xml:154(literal)
#: gist.xml:177(literal)
msgid "&amp;&lt;"
msgstr "&amp;&lt;"

#: gist.xml:74(literal) gist.xml:96(literal) gist.xml:155(literal)
msgid "&amp;&lt;|"
msgstr "&amp;&lt;|"

#: gist.xml:75(literal) gist.xml:97(literal) gist.xml:117(literal)
#: gist.xml:135(literal) gist.xml:156(literal) gist.xml:178(literal)
msgid "&gt;&gt;"
msgstr "&gt;&gt;"

#: gist.xml:76(literal) gist.xml:98(literal) gist.xml:122(literal)
#: gist.xml:137(literal) gist.xml:157(literal) gist.xml:179(literal)
msgid "&lt;&lt;"
msgstr "&lt;&lt;"

#: gist.xml:77(literal) gist.xml:99(literal) gist.xml:158(literal)
msgid "&lt;&lt;|"
msgstr "&lt;&lt;|"

#: gist.xml:78(literal) gist.xml:100(literal) gist.xml:138(literal)
#: gist.xml:139(literal) gist.xml:140(literal) gist.xml:159(literal)
#: gist.xml:180(literal) gist.xml:193(literal)
msgid "&lt;@"
msgstr "&lt;@"

#: gist.xml:79(literal) gist.xml:101(literal) gist.xml:160(literal)
#: gist.xml:183(literal) gist.xml:184(literal) gist.xml:194(literal)
msgid "@&gt;"
msgstr "@&gt;"

#: gist.xml:80(literal) gist.xml:102(literal) gist.xml:161(literal)
msgid "@"
msgstr "@"

#: gist.xml:81(literal) gist.xml:103(literal) gist.xml:162(literal)
msgid "|&amp;&gt;"
msgstr "|&amp;&gt;"

#: gist.xml:82(literal) gist.xml:104(literal) gist.xml:163(literal)
msgid "|&gt;&gt;"
msgstr "|&gt;&gt;"

#: gist.xml:83(literal) gist.xml:105(literal) gist.xml:164(literal)
msgid "~"
msgstr "~"

#: gist.xml:84(literal) gist.xml:106(literal) gist.xml:142(literal)
#: gist.xml:165(literal)
msgid "~="
msgstr "~="

#: gist.xml:90(literal)
msgid "circle_ops"
msgstr "circle_ops"

#: gist.xml:91(type)
msgid "circle"
msgstr "circle"

#: gist.xml:109(literal) gist.xml:145(literal) gist.xml:168(literal)
msgid "&lt;-&gt;"
msgstr "&lt;-&gt;"

#: gist.xml:113(literal)
msgid "inet_ops"
msgstr "inet_ops"

#: gist.xml:114(entry)
msgid "<type>inet</type>, <type>cidr</type>"
msgstr "<type>inet</type>, <type>cidr</type>"

#: gist.xml:118(literal)
msgid "&gt;&gt;="
msgstr "&gt;&gt;="

#: gist.xml:119(literal)
msgid "&gt;"
msgstr "&gt;"

#: gist.xml:120(literal)
msgid "&gt;="
msgstr "&gt;="

#: gist.xml:121(literal)
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#: gist.xml:123(literal)
msgid "&lt;&lt;="
msgstr "&lt;&lt;="

#: gist.xml:124(literal)
msgid "&lt;"
msgstr "&lt;"

#: gist.xml:125(literal)
msgid "&lt;="
msgstr "&lt;="

#: gist.xml:126(literal) gist.xml:182(literal)
msgid "="
msgstr "="

#: gist.xml:132(literal)
msgid "point_ops"
msgstr "point_ops"

#: gist.xml:133(type)
msgid "point"
msgstr "point"

#: gist.xml:136(literal)
msgid "&gt;^"
msgstr "&gt;^"

#: gist.xml:141(literal)
msgid "&lt;^"
msgstr "&lt;^"

#: gist.xml:149(literal)
msgid "poly_ops"
msgstr "poly_ops"

#: gist.xml:150(type)
msgid "polygon"
msgstr "polygon"

#: gist.xml:172(literal)
msgid "range_ops"
msgstr "range_ops"

#: gist.xml:173(entry)
msgid "any range type"
msgstr "любой тип диапазона"

#: gist.xml:181(literal)
msgid "-|-"
msgstr "-|-"

#: gist.xml:190(literal)
msgid "tsquery_ops"
msgstr "tsquery_ops"

#: gist.xml:191(type)
msgid "tsquery"
msgstr "tsquery"

#: gist.xml:200(literal)
msgid "tsvector_ops"
msgstr "tsvector_ops"

#: gist.xml:201(type)
msgid "tsvector"
msgstr "tsvector"

#: gist.xml:203(literal)
msgid "@@"
msgstr "@@"

#: gist.xml:217(programlisting)
#, no-wrap
msgid "CREATE INDEX ON my_table USING GIST (my_inet_column inet_ops);"
msgstr "CREATE INDEX ON my_table USING GIST (my_inet_column inet_ops);"

#: gist.xml:212(para)
msgid ""
"For historical reasons, the <literal>inet_ops</literal> operator class is "
"not the default class for types <type>inet</type> and <type>cidr</type>. To "
"use it, mention the class name in <command>CREATE INDEX</command>, for "
"example <placeholder-1/>"
msgstr ""
"По историческим причинам класс операторов <literal>inet_ops</literal> не "
"является классом по умолчанию для типов <type>inet</type> и <type>cidr</"
"type>. Чтобы использовать его, укажите имя класса в <command>CREATE INDEX</"
"command>, например: <placeholder-1/>"

#: gist.xml:225(title)
msgid "Extensibility"
msgstr "Расширяемость"

#: gist.xml:227(para)
msgid ""
"Traditionally, implementing a new index access method meant a lot of "
"difficult work. It was necessary to understand the inner workings of the "
"database, such as the lock manager and Write-Ahead Log. The <acronym>GiST</"
"acronym> interface has a high level of abstraction, requiring the access "
"method implementer only to implement the semantics of the data type being "
"accessed. The <acronym>GiST</acronym> layer itself takes care of "
"concurrency, logging and searching the tree structure."
msgstr ""
"Реализация нового метода доступа индекса традиционно была большой и сложной "
"задачей. Чтобы её решить, необходимо было понимать внутреннее устройство "
"базы данных, в частности работу менеджера блокировок и журнала упреждающей "
"записи. Но с интерфейсом <acronym>GiST</acronym>, реализующим высокий "
"уровень абстракции, разработчик метода доступа должен реализовать только "
"смысловое наполнение индексируемого типа данных. Уровень <acronym>GiST</"
"acronym> берёт на себя заботу о параллельном доступе, поддержке журнала и "
"поиске в структуре дерева."

#: gist.xml:237(para)
msgid ""
"This extensibility should not be confused with the extensibility of the "
"other standard search trees in terms of the data they can handle. For "
"example, <productname>PostgreSQL</productname> supports extensible B-trees "
"and hash indexes. That means that you can use <productname>PostgreSQL</"
"productname> to build a B-tree or hash over any data type you want. But B-"
"trees only support range predicates (<literal>&lt;</literal>, <literal>=</"
"literal>, <literal>&gt;</literal>), and hash indexes only support equality "
"queries."
msgstr ""
"Эту расширяемость не следует путать с расширяемостью других стандартных "
"деревьев поиска в смысле поддержки различных типов данных. Например, "
"<productname>PostgreSQL</productname> поддерживает расширяемость B-деревьев "
"и индексов по хешу. Это означает, что в <productname>PostgreSQL</"
"productname> вы можете построить B-дерево или хеш-таблицу по любому "
"желаемому типу данных. Но такие B-деревья будут поддерживать только "
"предикаты сравнений (<literal>&lt;</literal>, <literal>=</literal>, "
"<literal>&gt;</literal>), а индексы по хешу только запросы с равенством."

#: gist.xml:248(para)
msgid ""
"So if you index, say, an image collection with a <productname>PostgreSQL</"
"productname> B-tree, you can only issue queries such as <quote>is imagex "
"equal to imagey</quote>, <quote>is imagex less than imagey</quote> and "
"<quote>is imagex greater than imagey</quote>. Depending on how you define "
"<quote>equals</quote>, <quote>less than</quote> and <quote>greater than</"
"quote> in this context, this could be useful. However, by using a "
"<acronym>GiST</acronym> based index, you could create ways to ask domain-"
"specific questions, perhaps <quote>find all images of horses</quote> or "
"<quote>find all over-exposed images</quote>."
msgstr ""
"Поэтому, если вы проиндексируете в <productname>PostgreSQL</productname> в B-"
"дереве, например, коллекцию изображений, вы сможете выполнять только "
"проверки вида <quote>равны ли изображения X и Y</quote>, <quote>меньше ли "
"изображение X изображения Y</quote> и <quote>больше ли изображение X "
"изображения Y</quote>. Это может быть полезно, в зависимости от того, как вы "
"определите операции <quote>равно</quote>, <quote>меньше</quote> и "
"<quote>больше</quote>. Однако, используя индекс на базе <acronym>GiST</"
"acronym>, возможно удовлетворять и запросы из предметной области, например, "
"<quote>найти все изображения лошадей</quote> или <quote>найти все "
"пересвеченные изображения</quote>."

#: gist.xml:260(para)
msgid ""
"All it takes to get a <acronym>GiST</acronym> access method up and running "
"is to implement several user-defined methods, which define the behavior of "
"keys in the tree. Of course these methods have to be pretty fancy to support "
"fancy queries, but for all the standard queries (B-trees, R-trees, etc.) "
"they're relatively straightforward. In short, <acronym>GiST</acronym> "
"combines extensibility along with generality, code reuse, and a clean "
"interface."
msgstr ""
"Всё, что нужно, чтобы получить работающий метод доступа <acronym>GiST</"
"acronym> — это реализовать несколько методов, определяющих поведение ключей "
"в дереве. Конечно, эти методы должны быть довольно изощрёнными, чтобы "
"поддерживать изощрённые запросы, но для всех стандартных запросов (B-"
"деревьев, R-деревьев и т. д.) они относительно просты. Словом, "
"<acronym>GiST</acronym> сочетает расширяемость с универсальностью, повторным "
"использованием кода и аккуратным интерфейсом."

#: gist.xml:270(para)
msgid ""
"There are seven methods that an index operator class for <acronym>GiST</"
"acronym> must provide, and two that are optional. Correctness of the index "
"is ensured by proper implementation of the <function>same</function>, "
"<function>consistent</function> and <function>union</function> methods, "
"while efficiency (size and speed) of the index will depend on the "
"<function>penalty</function> and <function>picksplit</function> methods. The "
"remaining two basic methods are <function>compress</function> and "
"<function>decompress</function>, which allow an index to have internal tree "
"data of a different type than the data it indexes. The leaves are to be of "
"the indexed data type, while the other tree nodes can be of any C struct "
"(but you still have to follow <productname>PostgreSQL</productname> data "
"type rules here, see about <literal>varlena</literal> for variable sized "
"data). If the tree's internal data type exists at the SQL level, the "
"<literal>STORAGE</literal> option of the <command>CREATE OPERATOR CLASS</"
"command> command can be used. The optional eighth method is "
"<function>distance</function>, which is needed if the operator class wishes "
"to support ordered scans (nearest-neighbor searches). The optional ninth "
"method <function>fetch</function> is needed if the operator class wishes to "
"support index-only scans."
msgstr ""
"Класс операторов индекса <acronym>GiST</acronym> должен предоставить семь "
"методов и может дополнительно предоставлять ещё два. Корректность индекса "
"обеспечивается реализацией методов <function>same</function>, "
"<function>consistent</function> и <function>union</function>, а его "
"эффективность (по размеру и скорости) будет зависеть от методов "
"<function>penalty</function> и <function>picksplit</function>. Последние два "
"основных метода <function>compress</function> и <function>decompress</"
"function> позволяют реализовать внутреннее представление данных дерева, не "
"совпадающее с типом индексируемых данных. Данные листьев индекса должны быть "
"индексируемого типа, тогда как в остальных узлах дерева могут быть "
"произвольные структуры C (но при этом должны соблюдаться правила, "
"предъявляемые <productname>PostgreSQL</productname> к типам данным; "
"прочитайте о <literal>varlena</literal> для данных переменного размера). "
"Если внутренний тип данных дерева существует на уровне SQL, в команде "
"<command>CREATE OPERATOR CLASS</command> можно использовать указание "
"<literal>STORAGE</literal>. Необязательный восьмой метод <function>distance</"
"function> нужно реализовать, только если класс операторов желает "
"поддерживать упорядоченные сканирования (поиск ближайших соседей). "
"Необязательный девятый метод <function>fetch</function> требуется, если "
"класс операторов желает поддерживать сканирование только индекса."

#: gist.xml:294(function)
msgid "consistent"
msgstr "consistent"

#: gist.xml:296(para)
msgid ""
"Given an index entry <literal>p</literal> and a query value <literal>q</"
"literal>, this function determines whether the index entry is "
"<quote>consistent</quote> with the query; that is, could the predicate "
"<quote><replaceable>indexed_column</replaceable> "
"<replaceable>indexable_operator</replaceable> <literal>q</literal></quote> "
"be true for any row represented by the index entry? For a leaf index entry "
"this is equivalent to testing the indexable condition, while for an internal "
"tree node this determines whether it is necessary to scan the subtree of the "
"index represented by the tree node. When the result is <literal>true</"
"literal>, a <literal>recheck</literal> flag must also be returned. This "
"indicates whether the predicate is certainly true or only possibly true. If "
"<literal>recheck</literal> = <literal>false</literal> then the index has "
"tested the predicate condition exactly, whereas if <literal>recheck</"
"literal> = <literal>true</literal> the row is only a candidate match. In "
"that case the system will automatically evaluate the "
"<replaceable>indexable_operator</replaceable> against the actual row value "
"to see if it is really a match. This convention allows <acronym>GiST</"
"acronym> to support both lossless and lossy index structures."
msgstr ""
"Для переданной записи индекса <literal>p</literal> и значения запроса "
"<literal>q</literal> эта функция определяет, является ли запись индекса "
"<quote>соответствующей</quote> запросу; то есть, может ли предикат "
"<quote><replaceable>индексированный_столбец</replaceable> "
"<replaceable>индексируемый_оператор</replaceable> <literal>q</literal></"
"quote> удовлетворяться для какой-либо строки, представленной данной записью "
"индекса? Для записей на уровне листьев это равносильно проверке "
"индексируемого условия, тогда как для внутреннего узла дерева требуется "
"определить, нужно ли сканировать поддерево индекса, относящееся к данному "
"узлу. Когда результат <literal>true</literal>, также должен возвращаться "
"флаг <literal>recheck</literal>, показывающий, точно ли удовлетворяется "
"предикат или это лишь потенциально возможно. Если <literal>recheck</literal> "
"= <literal>false</literal>, это означает, что индекс проверил условие "
"предиката в точности, тогда как при <literal>recheck</literal> = "
"<literal>true</literal> проверяемая строка будет только кандидатом на "
"совпадение. В этом случае система автоматически перепроверит "
"<replaceable>индексируемый_оператор</replaceable> с действительным значением "
"строки, чтобы окончательно определить, соответствует ли оно запросу. "
"Благодаря этому <acronym>GiST</acronym> поддерживает индексы как точной, так "
"и неточной структуры."

#: gist.xml:321(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)\n"
"RETURNS bool\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)\n"
"RETURNS bool\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:330(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_consistent);\n"
"\n"
"Datum\n"
"my_consistent(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    data_type  *query = PG_GETARG_DATA_TYPE_P(1);\n"
"    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n"
"    /* Oid subtype = PG_GETARG_OID(3); */\n"
"    bool       *recheck = (bool *) PG_GETARG_POINTER(4);\n"
"    data_type  *key = DatumGetDataType(entry-&gt;key);\n"
"    bool        retval;\n"
"\n"
"    /*\n"
"     * determine return value as a function of strategy, key and query.\n"
"     *\n"
"     * Use GIST_LEAF(entry) to know where you're called in the index tree,\n"
"     * which comes handy when supporting the = operator for example (you could\n"
"     * check for non empty union() in non-leaf nodes and equality in leaf\n"
"     * nodes).\n"
"     */\n"
"\n"
"    *recheck = true;        /* or false if check is exact */\n"
"\n"
"    PG_RETURN_BOOL(retval);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_consistent);\n"
"\n"
"Datum\n"
"my_consistent(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    data_type  *query = PG_GETARG_DATA_TYPE_P(1);\n"
"    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n"
"    /* Oid subtype = PG_GETARG_OID(3); */\n"
"    bool       *recheck = (bool *) PG_GETARG_POINTER(4);\n"
"    data_type  *key = DatumGetDataType(entry-&gt;key);\n"
"    bool        retval;\n"
"\n"
"    /*\n"
"     * Определить возвращаемое значение как функцию стратегии, ключа и запроса.\n"
"     *\n"
"     * Вызовите GIST_LEAF(entry), чтобы узнать текущую позицию в дереве индекса,\n"
"     * что удобно, например для поддержки оператора = (вы можете проверить\n"
"     * равенство в листьях дерева и непустое пересечение в остальных\n"
"     * узлах).\n"
"     */\n"
"\n"
"    *recheck = true;        /* или false, если проверка точная */\n"
"\n"
"    PG_RETURN_BOOL(retval);\n"
"}"

#: gist.xml:318(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> And the matching code in the C module could then follow "
"this skeleton: <placeholder-2/> Here, <varname>key</varname> is an element "
"in the index and <varname>query</varname> the value being looked up in the "
"index. The <literal>StrategyNumber</literal> parameter indicates which "
"operator of your operator class is being applied &mdash; it matches one of "
"the operator numbers in the <command>CREATE OPERATOR CLASS</command> command."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться примерно так: "
"<placeholder-1/> А соответствующий код в модуле C может реализовываться по "
"такому шаблону: <placeholder-2/> Здесь <varname>key</varname> — это элемент "
"в индексе, а <varname>query</varname> — значение, искомое в индексе. "
"Параметр <literal>StrategyNumber</literal> показывает, какой оператор из "
"класса операторов применяется &mdash; он соответствует одному из номеров "
"операторов, заданных в команде <command>CREATE OPERATOR CLASS</command>."

#: gist.xml:366(para)
msgid ""
"Depending on which operators you have included in the class, the data type "
"of <varname>query</varname> could vary with the operator, since it will be "
"whatever type is on the righthand side of the operator, which might be "
"different from the indexed data type appearing on the lefthand side. (The "
"above code skeleton assumes that only one type is possible; if not, fetching "
"the <varname>query</varname> argument value would have to depend on the "
"operator.) It is recommended that the SQL declaration of the "
"<function>consistent</function> function use the opclass's indexed data type "
"for the <varname>query</varname> argument, even though the actual type might "
"be something else depending on the operator."
msgstr ""
"В зависимости от того, какие операторы включены в класс, тип данных "
"<varname>query</varname> может быть разным для разных операторов, так как "
"это будет тот тип, что фигурирует в правой части оператора, и он может "
"отличаться от индексируемого типа данных, фигурирующего слева. (В показанном "
"выше шаблоне предполагается, что допускается только один тип; в противном "
"случае получение значения <varname>query</varname> зависело бы от "
"оператора.) В SQL-объявлении функции <function>consistent</function> для "
"аргумента <varname>query</varname> рекомендуется установить индексированный "
"тип данного класса операторов, хотя фактический тип может быть каким-то "
"другим, в зависимости от оператора."

#: gist.xml:383(function)
msgid "union"
msgstr "union"

#: gist.xml:385(para)
msgid ""
"This method consolidates information in the tree. Given a set of entries, "
"this function generates a new index entry that represents all the given "
"entries."
msgstr ""
"Этот метод консолидирует информацию в дереве. Получив набор записей, он "
"должен сгенерировать в индексе новую запись, представляющие все эти записи."

#: gist.xml:394(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_union(internal, internal)\n"
"RETURNS storage_type\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_union(internal, internal)\n"
"RETURNS storage_type\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:403(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_union);\n"
"\n"
"Datum\n"
"my_union(PG_FUNCTION_ARGS)\n"
"{\n"
"    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n"
"    GISTENTRY  *ent = entryvec-&gt;vector;\n"
"    data_type  *out,\n"
"               *tmp,\n"
"               *old;\n"
"    int         numranges,\n"
"                i = 0;\n"
"\n"
"    numranges = entryvec-&gt;n;\n"
"    tmp = DatumGetDataType(ent[0].key);\n"
"    out = tmp;\n"
"\n"
"    if (numranges == 1)\n"
"    {\n"
"        out = data_type_deep_copy(tmp);\n"
"\n"
"        PG_RETURN_DATA_TYPE_P(out);\n"
"    }\n"
"\n"
"    for (i = 1; i &lt; numranges; i++)\n"
"    {\n"
"        old = out;\n"
"        tmp = DatumGetDataType(ent[i].key);\n"
"        out = my_union_implementation(out, tmp);\n"
"    }\n"
"\n"
"    PG_RETURN_DATA_TYPE_P(out);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_union);\n"
"\n"
"Datum\n"
"my_union(PG_FUNCTION_ARGS)\n"
"{\n"
"    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n"
"    GISTENTRY  *ent = entryvec-&gt;vector;\n"
"    data_type  *out,\n"
"               *tmp,\n"
"               *old;\n"
"    int         numranges,\n"
"                i = 0;\n"
"\n"
"    numranges = entryvec-&gt;n;\n"
"    tmp = DatumGetDataType(ent[0].key);\n"
"    out = tmp;\n"
"\n"
"    if (numranges == 1)\n"
"    {\n"
"        out = data_type_deep_copy(tmp);\n"
"\n"
"        PG_RETURN_DATA_TYPE_P(out);\n"
"    }\n"
"\n"
"    for (i = 1; i &lt; numranges; i++)\n"
"    {\n"
"        old = out;\n"
"        tmp = DatumGetDataType(ent[i].key);\n"
"        out = my_union_implementation(out, tmp);\n"
"    }\n"
"\n"
"    PG_RETURN_DATA_TYPE_P(out);\n"
"}"

#: gist.xml:391(para) gist.xml:476(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> And the matching code in the C module could then follow "
"this skeleton: <placeholder-2/>"
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> И соответствующий код в модуле C должен реализовываться по такому шаблону: "
"<placeholder-2/>"

#: gist.xml:440(para)
msgid ""
"As you can see, in this skeleton we're dealing with a data type where "
"<literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>. It's easy enough "
"to support data types where this is not the case, by implementing the proper "
"union algorithm in this <acronym>GiST</acronym> support method."
msgstr ""
"Как можно заметить, в этом шаблоне мы имеем дело с типом данных, для "
"которого <literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>. "
"Достаточно просто можно поддержать и такие типы данных, для которых это не "
"выполняется, реализовав соответствующий алгоритм объединения в этом опорном "
"методе <acronym>GiST</acronym>."

#: gist.xml:448(para)
msgid ""
"The result of the <function>union</function> function must be a value of the "
"index's storage type, whatever that is (it might or might not be different "
"from the indexed column's type). The <function>union</function> function "
"should return a pointer to newly <function>palloc()</function>ed memory. You "
"can't just return the input value as-is, even if there is no type change."
msgstr ""
"Результатом функции <function>union</function> должно быть значение типа "
"хранения индекса, каким бы он ни был (он может совпадать с типом "
"индексированного столбца, а может и отличаться от него). Функция, "
"реализующая <function>union</function>, должна возвращать указатель на "
"память, выделенную вызовом <function>palloc()</function>. Она не может "
"просто вернуть полученное значение как есть, даже если оно имеет тот же тип."

#: gist.xml:457(para)
msgid ""
"As shown above, the <function>union</function> function's first "
"<type>internal</type> argument is actually a <structname>GistEntryVector</"
"structname> pointer. The second argument is a pointer to an integer "
"variable, which can be ignored. (It used to be required that the "
"<function>union</function> function store the size of its result value into "
"that variable, but this is no longer necessary.)"
msgstr ""
"Как показано выше, первый аргумент <type>internal</type> функции "
"<function>union</function> на самом деле представляет указатель "
"<structname>GistEntryVector</structname>. Во втором аргументе (его можно "
"игнорировать) передаётся указатель на целочисленную переменную. (Раньше "
"требовалось, чтобы функция <function>union</function> сохраняла в этой "
"переменной размер результирующего значения, но теперь такого требования нет.)"

#: gist.xml:469(function)
msgid "compress"
msgstr "compress"

#: gist.xml:471(para)
msgid ""
"Converts the data item into a format suitable for physical storage in an "
"index page."
msgstr ""
"Преобразует элемент данных в формат, подходящий для физического хранения в "
"странице индекса."

#: gist.xml:479(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_compress(internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_compress(internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:488(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_compress);\n"
"\n"
"Datum\n"
"my_compress(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    GISTENTRY  *retval;\n"
"\n"
"    if (entry-&gt;leafkey)\n"
"    {\n"
"        /* replace entry-&gt;key with a compressed version */\n"
"        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));\n"
"\n"
"        /* fill *compressed_data from entry-&gt;key ... */\n"
"\n"
"        retval = palloc(sizeof(GISTENTRY));\n"
"        gistentryinit(*retval, PointerGetDatum(compressed_data),\n"
"                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);\n"
"    }\n"
"    else\n"
"    {\n"
"        /* typically we needn't do anything with non-leaf entries */\n"
"        retval = entry;\n"
"    }\n"
"\n"
"    PG_RETURN_POINTER(retval);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_compress);\n"
"\n"
"Datum\n"
"my_compress(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    GISTENTRY  *retval;\n"
"\n"
"    if (entry-&gt;leafkey)\n"
"    {\n"
"        /* заменить entry-&gt;key сжатой версией */\n"
"        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));\n"
"\n"
"        /* заполнить *compressed_data из entry-&gt;key ... */\n"
"\n"
"        retval = palloc(sizeof(GISTENTRY));\n"
"        gistentryinit(*retval, PointerGetDatum(compressed_data),\n"
"                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);\n"
"    }\n"
"    else\n"
"    {\n"
"        /* обычно с записями внутренних узлов ничего делать не нужно */\n"
"        retval = entry;\n"
"    }\n"
"\n"
"    PG_RETURN_POINTER(retval);\n"
"}"

#: gist.xml:519(para)
msgid ""
"You have to adapt <replaceable>compressed_data_type</replaceable> to the "
"specific type you're converting to in order to compress your leaf nodes, of "
"course."
msgstr ""
"Разумеется, <replaceable>compressed_data_type</replaceable> (тип сжатых "
"данных) нужно привести к нужному типу, при преобразовании в который будут "
"сжиматься узлы на уровне листьев."

#: gist.xml:528(function)
msgid "decompress"
msgstr "decompress"

#: gist.xml:530(para)
msgid ""
"The reverse of the <function>compress</function> method. Converts the index "
"representation of the data item into a format that can be manipulated by the "
"other GiST methods in the operator class."
msgstr ""
"Метод, обратный к <function>compress</function>. Преобразует представление "
"элемента данных в индексе в формат, с которым могут работать другие методы "
"GiST в классе операторов."

#: gist.xml:539(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_decompress(internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_decompress(internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:548(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_decompress);\n"
"\n"
"Datum\n"
"my_decompress(PG_FUNCTION_ARGS)\n"
"{\n"
"    PG_RETURN_POINTER(PG_GETARG_POINTER(0));\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_decompress);\n"
"\n"
"Datum\n"
"my_decompress(PG_FUNCTION_ARGS)\n"
"{\n"
"    PG_RETURN_POINTER(PG_GETARG_POINTER(0));\n"
"}"

#: gist.xml:536(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> And the matching code in the C module could then follow "
"this skeleton: <placeholder-2/> The above skeleton is suitable for the case "
"where no decompression is needed."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> И соответствующий код в модуле C должен реализовываться по такому шаблону: "
"<placeholder-2/> Этот шаблон подходит для случая, когда преобразовывать "
"данные не нужно."

#: gist.xml:565(function)
msgid "penalty"
msgstr "penalty"

#: gist.xml:567(para)
msgid ""
"Returns a value indicating the <quote>cost</quote> of inserting the new "
"entry into a particular branch of the tree. Items will be inserted down the "
"path of least <function>penalty</function> in the tree. Values returned by "
"<function>penalty</function> should be non-negative. If a negative value is "
"returned, it will be treated as zero."
msgstr ""
"Возвращает значение, выражающее <quote>стоимость</quote> добавления новой "
"записи в конкретную ветвь дерева. Элементы будут вставляться по тому "
"направлению в дереве, для которого значение <function>penalty</function> "
"минимально. Результаты <function>penalty</function> должны быть "
"неотрицательными; если возвращается отрицательное значение, оно "
"воспринимается как ноль."

#: gist.xml:578(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict"
msgstr ""
"CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;  -- в некоторых случая функции стоимости не должны быть строгими"

#: gist.xml:587(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_penalty);\n"
"\n"
"Datum\n"
"my_penalty(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);\n"
"    float      *penalty = (float *) PG_GETARG_POINTER(2);\n"
"    data_type  *orig = DatumGetDataType(origentry-&gt;key);\n"
"    data_type  *new = DatumGetDataType(newentry-&gt;key);\n"
"\n"
"    *penalty = my_penalty_implementation(orig, new);\n"
"    PG_RETURN_POINTER(penalty);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_penalty);\n"
"\n"
"Datum\n"
"my_penalty(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);\n"
"    float      *penalty = (float *) PG_GETARG_POINTER(2);\n"
"    data_type  *orig = DatumGetDataType(origentry-&gt;key);\n"
"    data_type  *new = DatumGetDataType(newentry-&gt;key);\n"
"\n"
"    *penalty = my_penalty_implementation(orig, new);\n"
"    PG_RETURN_POINTER(penalty);\n"
"}"

#: gist.xml:575(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> And the matching code in the C module could then follow "
"this skeleton: <placeholder-2/> For historical reasons, the "
"<function>penalty</function> function doesn't just return a <type>float</"
"type> result; instead it has to store the value at the location indicated by "
"the third argument. The return value per se is ignored, though it's "
"conventional to pass back the address of that argument."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> И соответствующий код в модуле C может реализовываться по такому шаблону: "
"<placeholder-2/> По историческим причинам функция <function>penalty</"
"function> не просто возвращает результат типа <type>float</type>; вместо "
"этого она должна сохранить его значение по адресу, указанному третьим "
"аргументом. Собственно возвращаемое значение игнорируется, хотя в нём "
"принято возвращать этот же адрес."

#: gist.xml:611(para)
msgid ""
"The <function>penalty</function> function is crucial to good performance of "
"the index. It'll get used at insertion time to determine which branch to "
"follow when choosing where to add the new entry in the tree. At query time, "
"the more balanced the index, the quicker the lookup."
msgstr ""
"Функция <function>penalty</function> важна для хорошей производительности "
"индекса. Она будет вызываться во время добавления записи, чтобы выбрать "
"ветвь для дальнейшего движения, когда в дерево нужно добавить новый элемент. "
"Это имеет значение во время запроса, так как чем более сбалансирован индекс, "
"тем быстрее будет поиск в нём."

#: gist.xml:621(function)
msgid "picksplit"
msgstr "picksplit"

#: gist.xml:623(para)
msgid ""
"When an index page split is necessary, this function decides which entries "
"on the page are to stay on the old page, and which are to move to the new "
"page."
msgstr ""
"Когда необходимо разделить страницу индекса, эта функция решает, какие "
"записи должны остаться в старой странице, а какие нужно перенести в новую."

#: gist.xml:632(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:641(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_picksplit);\n"
"\n"
"Datum\n"
"my_picksplit(PG_FUNCTION_ARGS)\n"
"{\n"
"    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n"
"    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);\n"
"    OffsetNumber maxoff = entryvec-&gt;n - 1;\n"
"    GISTENTRY  *ent = entryvec-&gt;vector;\n"
"    int         i,\n"
"                nbytes;\n"
"    OffsetNumber *left,\n"
"               *right;\n"
"    data_type  *tmp_union;\n"
"    data_type  *unionL;\n"
"    data_type  *unionR;\n"
"    GISTENTRY **raw_entryvec;\n"
"\n"
"    maxoff = entryvec-&gt;n - 1;\n"
"    nbytes = (maxoff + 1) * sizeof(OffsetNumber);\n"
"\n"
"    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);\n"
"    left = v-&gt;spl_left;\n"
"    v-&gt;spl_nleft = 0;\n"
"\n"
"    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);\n"
"    right = v-&gt;spl_right;\n"
"    v-&gt;spl_nright = 0;\n"
"\n"
"    unionL = NULL;\n"
"    unionR = NULL;\n"
"\n"
"    /* Initialize the raw entry vector. */\n"
"    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));\n"
"    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))\n"
"        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);\n"
"\n"
"    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))\n"
"    {\n"
"        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;\n"
"\n"
"        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);\n"
"        Assert(tmp_union != NULL);\n"
"\n"
"        /*\n"
"         * Choose where to put the index entries and update unionL and unionR\n"
"         * accordingly. Append the entries to either v_spl_left or\n"
"         * v_spl_right, and care about the counters.\n"
"         */\n"
"\n"
"        if (my_choice_is_left(unionL, curl, unionR, curr))\n"
"        {\n"
"            if (unionL == NULL)\n"
"                unionL = tmp_union;\n"
"            else\n"
"                unionL = my_union_implementation(unionL, tmp_union);\n"
"\n"
"            *left = real_index;\n"
"            ++left;\n"
"            ++(v-&gt;spl_nleft);\n"
"        }\n"
"        else\n"
"        {\n"
"            /*\n"
"             * Same on the right\n"
"             */\n"
"        }\n"
"    }\n"
"\n"
"    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);\n"
"    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);\n"
"    PG_RETURN_POINTER(v);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_picksplit);\n"
"\n"
"Datum\n"
"my_picksplit(PG_FUNCTION_ARGS)\n"
"{\n"
"    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n"
"    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);\n"
"    OffsetNumber maxoff = entryvec-&gt;n - 1;\n"
"    GISTENTRY  *ent = entryvec-&gt;vector;\n"
"    int         i,\n"
"                nbytes;\n"
"    OffsetNumber *left,\n"
"               *right;\n"
"    data_type  *tmp_union;\n"
"    data_type  *unionL;\n"
"    data_type  *unionR;\n"
"    GISTENTRY **raw_entryvec;\n"
"\n"
"    maxoff = entryvec-&gt;n - 1;\n"
"    nbytes = (maxoff + 1) * sizeof(OffsetNumber);\n"
"\n"
"    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);\n"
"    left = v-&gt;spl_left;\n"
"    v-&gt;spl_nleft = 0;\n"
"\n"
"    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);\n"
"    right = v-&gt;spl_right;\n"
"    v-&gt;spl_nright = 0;\n"
"\n"
"    unionL = NULL;\n"
"    unionR = NULL;\n"
"\n"
"    /* Инициализировать чистый вектор записи. */\n"
"    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));\n"
"    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))\n"
"        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);\n"
"\n"
"    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))\n"
"    {\n"
"        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;\n"
"\n"
"        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);\n"
"        Assert(tmp_union != NULL);\n"
"\n"
"        /*\n"
"         * Выбрать, куда помещать записи индекса и изменить unionL и unionR\n"
"         * соответственно. Добавить записи в v_spl_left или\n"
"         * v_spl_right и увеличить счётчики.\n"
"         */\n"
"\n"
"        if (my_choice_is_left(unionL, curl, unionR, curr))\n"
"        {\n"
"            if (unionL == NULL)\n"
"                unionL = tmp_union;\n"
"            else\n"
"                unionL = my_union_implementation(unionL, tmp_union);\n"
"\n"
"            *left = real_index;\n"
"            ++left;\n"
"            ++(v-&gt;spl_nleft);\n"
"        }\n"
"        else\n"
"        {\n"
"            /*\n"
"             * То же самое с правой стороной\n"
"             */\n"
"        }\n"
"    }\n"
"\n"
"    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);\n"
"    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);\n"
"    PG_RETURN_POINTER(v);\n"
"}"

#: gist.xml:629(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> And the matching code in the C module could then follow "
"this skeleton: <placeholder-2/> Notice that the <function>picksplit</"
"function> function's result is delivered by modifying the passed-in "
"<structname>v</structname> structure. The return value per se is ignored, "
"though it's conventional to pass back the address of <structname>v</"
"structname>."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> И соответствующий код в модуле C может реализовываться по такому шаблону: "
"<placeholder-2/> Заметьте, что результат функции <function>picksplit</"
"function> доставляется через полученную на вход структуру <structname>v</"
"structname>. Собственно возвращаемое значение игнорируется, хотя в нём "
"принято возвращать адрес <structname>v</structname>."

#: gist.xml:723(para)
msgid ""
"Like <function>penalty</function>, the <function>picksplit</function> "
"function is crucial to good performance of the index. Designing suitable "
"<function>penalty</function> and <function>picksplit</function> "
"implementations is where the challenge of implementing well-performing "
"<acronym>GiST</acronym> indexes lies."
msgstr ""
"Как и <function>penalty</function>, функция <function>picksplit</function> "
"важна для хорошей производительности индекса. Сложность создания "
"быстродействующих индексов <acronym>GiST</acronym> заключается как раз в "
"разработке подходящих реализаций <function>penalty</function> и "
"<function>picksplit</function>."

#: gist.xml:734(function)
msgid "same"
msgstr "same"

#: gist.xml:736(para)
msgid ""
"Returns true if two index entries are identical, false otherwise. (An "
"<quote>index entry</quote> is a value of the index's storage type, not "
"necessarily the original indexed column's type.)"
msgstr ""
"Возвращает true, если два элемента индекса равны, и false в противном "
"случае. (<quote>Элемент индекса</quote> — это значение типа хранения "
"индекса, а не обязательно исходного типа индексируемого столбца.)"

#: gist.xml:745(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:754(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_same);\n"
"\n"
"Datum\n"
"my_same(PG_FUNCTION_ARGS)\n"
"{\n"
"    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);\n"
"    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);\n"
"    bool       *result = (bool *) PG_GETARG_POINTER(2);\n"
"\n"
"    *result = my_eq(v1, v2);\n"
"    PG_RETURN_POINTER(result);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_same);\n"
"\n"
"Datum\n"
"my_same(PG_FUNCTION_ARGS)\n"
"{\n"
"    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);\n"
"    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);\n"
"    bool       *result = (bool *) PG_GETARG_POINTER(2);\n"
"\n"
"    *result = my_eq(v1, v2);\n"
"    PG_RETURN_POINTER(result);\n"
"}"

#: gist.xml:742(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> And the matching code in the C module could then follow "
"this skeleton: <placeholder-2/> For historical reasons, the <function>same</"
"function> function doesn't just return a Boolean result; instead it has to "
"store the flag at the location indicated by the third argument. The return "
"value per se is ignored, though it's conventional to pass back the address "
"of that argument."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> И соответствующий код в модуле C может реализовываться по такому шаблону: "
"<placeholder-2/> По историческим причинам функция <function>same</function> "
"не просто возвращает результат булевского типа; вместо этого она должна "
"сохранить флаг по адресу, указанному третьим аргументом. Собственно "
"возвращаемое значение игнорируется, хотя в нём принято возвращать этот же "
"адрес."

#: gist.xml:779(function)
msgid "distance"
msgstr "distance"

#: gist.xml:781(para)
msgid ""
"Given an index entry <literal>p</literal> and a query value <literal>q</"
"literal>, this function determines the index entry's <quote>distance</quote> "
"from the query value. This function must be supplied if the operator class "
"contains any ordering operators. A query using the ordering operator will be "
"implemented by returning index entries with the smallest <quote>distance</"
"quote> values first, so the results must be consistent with the operator's "
"semantics. For a leaf index entry the result just represents the distance to "
"the index entry; for an internal tree node, the result must be the smallest "
"distance that any child entry could have."
msgstr ""
"Для переданной записи индекса <literal>p</literal> и значения запроса "
"<literal>q</literal> эта функция определяет <quote>дистанцию</quote> от "
"записи индекса до значения в запросе. Эта функция должна быть представлена, "
"если класс операторов содержит какие-либо операторы упорядочивания. Запрос с "
"оператором упорядочивания будет выполняться так, чтобы записи индекса с "
"наименьшей <quote>дистанцией</quote> возвращались первыми, так что "
"результаты должны согласовываться со смысловым значением оператора. Для "
"записи на уровне листьев результат представляет только дистанцию до этой "
"записи, а для внутреннего узла дерева это будет минимальная дистанция, "
"которая может быть получена среди всех его потомков."

#: gist.xml:797(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)\n"
"RETURNS float8\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)\n"
"RETURNS float8\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:806(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_distance);\n"
"\n"
"Datum\n"
"my_distance(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    data_type  *query = PG_GETARG_DATA_TYPE_P(1);\n"
"    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n"
"    /* Oid subtype = PG_GETARG_OID(3); */\n"
"    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */\n"
"    data_type  *key = DatumGetDataType(entry-&gt;key);\n"
"    double      retval;\n"
"\n"
"    /*\n"
"     * determine return value as a function of strategy, key and query.\n"
"     */\n"
"\n"
"    PG_RETURN_FLOAT8(retval);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_distance);\n"
"\n"
"Datum\n"
"my_distance(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    data_type  *query = PG_GETARG_DATA_TYPE_P(1);\n"
"    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n"
"    /* Oid subtype = PG_GETARG_OID(3); */\n"
"    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */\n"
"    data_type  *key = DatumGetDataType(entry-&gt;key);\n"
"    double      retval;\n"
"\n"
"    /*\n"
"     * определить возвращаемое значение как функцию стратегии, ключа и запроса.\n"
"     */\n"
"\n"
"    PG_RETURN_FLOAT8(retval);\n"
"}"

#: gist.xml:794(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> And the matching code in the C module could then follow "
"this skeleton: <placeholder-2/> The arguments to the <function>distance</"
"function> function are identical to the arguments of the "
"<function>consistent</function> function."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> И соответствующий код в модуле C должен реализовываться по такому шаблону: "
"<placeholder-2/> Функции <function>distance</function> передаются те же "
"аргументы, что и функции <function>consistent</function>."

#: gist.xml:832(para)
msgid ""
"Some approximation is allowed when determining the distance, so long as the "
"result is never greater than the entry's actual distance. Thus, for example, "
"distance to a bounding box is usually sufficient in geometric applications. "
"For an internal tree node, the distance returned must not be greater than "
"the distance to any of the child nodes. If the returned distance is not "
"exact, the function must set <literal>*recheck</literal> to true. (This is "
"not necessary for internal tree nodes; for them, the calculation is always "
"assumed to be inexact.) In this case the executor will calculate the "
"accurate distance after fetching the tuple from the heap, and reorder the "
"tuples if necessary."
msgstr ""
"При определении дистанции допускается некоторая неточность, если результат "
"никогда не будет превышать действительную дистанцию до элемента. Так, "
"например, в геометрических приложениях бывает достаточно определить "
"дистанцию до описанного прямоугольника. Для внутреннего узла дерева "
"результат не должен превышать дистанцию до любого из его дочерних узлов. "
"Если возвращаемая дистанция неточная, функция должна установить флаг "
"<literal>*recheck</literal>. (Это необязательно для внутренних узлов дерева; "
"для них результат всегда считается неточным.) В этом случае исполнитель "
"вычислит точную дистанцию, выбрав кортеж из кучи, и переупорядочит кортежи "
"при необходимости."

#: gist.xml:845(para)
msgid ""
"If the distance function returns <literal>*recheck = true</literal> for any "
"leaf node, the original ordering operator's return type must be "
"<type>float8</type> or <type>float4</type>, and the distance function's "
"result values must be comparable to those of the original ordering operator, "
"since the executor will sort using both distance function results and "
"recalculated ordering-operator results. Otherwise, the distance function's "
"result values can be any finite <type>float8</type> values, so long as the "
"relative order of the result values matches the order returned by the "
"ordering operator. (Infinity and minus infinity are used internally to "
"handle cases such as nulls, so it is not recommended that "
"<function>distance</function> functions return these values.)"
msgstr ""
"Если функция distance возвращает <literal>*recheck = true</literal> для "
"любого узла на уровне листьев, типом результата исходного оператора "
"упорядочивания должен быть <type>float8</type> или <type>float4</type>, и "
"значения результата функции distance должны быть сравнимы с результатами "
"исходного оператора упорядочивания, так как исполнитель будет выполнять "
"сортировку, используя и результаты функции distance, и уточнённые результаты "
"оператора упорядочивания. В противном случае значениями результата distance "
"могут быть любые конечные значения <type>float8</type>, при условии, что "
"относительный порядок значений результата соответствует порядку, который "
"даёт оператор упорядочивания. (Значения бесконечность и минус бесконечность "
"применяются внутри для особых случаев, например, представления NULL, поэтому "
"возвращать такие значения из функций <function>distance</function> не "
"рекомендуется.)"

#: gist.xml:863(function)
msgid "fetch"
msgstr "fetch"

#: gist.xml:865(para)
msgid ""
"Converts the compressed index representation of a data item into the "
"original data type, for index-only scans. The returned data must be an "
"exact, non-lossy copy of the originally indexed value."
msgstr ""
"Преобразует сжатое представление элемента данных в индексе в исходный тип "
"данных, для сканирования только индекса. Возвращаемые данные должны быть "
"точной, не примерной копией изначально проиндексированного значения."

#: gist.xml:874(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION my_fetch(internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION my_fetch(internal)\n"
"RETURNS internal\n"
"AS 'MODULE_PATHNAME'\n"
"LANGUAGE C STRICT;"

#: gist.xml:871(para)
msgid ""
"The <acronym>SQL</acronym> declaration of the function must look like this: "
"<placeholder-1/> The argument is a pointer to a <structname>GISTENTRY</"
"structname> struct. On entry, its <structfield>key</structfield> field "
"contains a non-NULL leaf datum in compressed form. The return value is "
"another <structname>GISTENTRY</structname> struct, whose <structfield>key</"
"structfield> field contains the same datum in its original, uncompressed "
"form. If the opclass's compress function does nothing for leaf entries, the "
"<function>fetch</function> method can return the argument as-is."
msgstr ""
"В <acronym>SQL</acronym> эта функция должна объявляться так: <placeholder-1/"
"> В качестве аргумента ей передаётся указатель на структуру "
"<structname>GISTENTRY</structname>. При вызове её поле <structfield>key</"
"structfield> содержит данные листа в сжатой форме (не NULL). Возвращаемое "
"значение — ещё одна структура <structname>GISTENTRY</structname>, в которой "
"поле <structfield>key</structfield> содержит те же данные в исходной, "
"развёрнутой форме. Если функция compress класса операторов не делает с "
"данными листьев ничего, метод <function>fetch</function> может возвратить "
"аргумент без изменений."

#: gist.xml:893(programlisting)
#, no-wrap
msgid ""
"PG_FUNCTION_INFO_V1(my_fetch);\n"
"\n"
"Datum\n"
"my_fetch(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    input_data_type *in = DatumGetP(entry-&gt;key);\n"
"    fetched_data_type *fetched_data;\n"
"    GISTENTRY  *retval;\n"
"\n"
"    retval = palloc(sizeof(GISTENTRY));\n"
"    fetched_data = palloc(sizeof(fetched_data_type));\n"
"\n"
"    /*\n"
"     * Convert 'fetched_data' into the a Datum of the original datatype.\n"
"     */\n"
"\n"
"    /* fill *retval from fetch_data. */\n"
"    gistentryinit(*retval, PointerGetDatum(converted_datum),\n"
"                  entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);\n"
"\n"
"    PG_RETURN_POINTER(retval);\n"
"}"
msgstr ""
"PG_FUNCTION_INFO_V1(my_fetch);\n"
"\n"
"Datum\n"
"my_fetch(PG_FUNCTION_ARGS)\n"
"{\n"
"    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n"
"    input_data_type *in = DatumGetP(entry-&gt;key);\n"
"    fetched_data_type *fetched_data;\n"
"    GISTENTRY  *retval;\n"
"\n"
"    retval = palloc(sizeof(GISTENTRY));\n"
"    fetched_data = palloc(sizeof(fetched_data_type));\n"
"\n"
"    /*\n"
"     * Преобразовать структуру 'fetched_data' в Datum исходного типа данных.\n"
"     */\n"
"\n"
"    /* заполнить *retval из fetch_data. */\n"
"    gistentryinit(*retval, PointerGetDatum(converted_datum),\n"
"                  entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);\n"
"\n"
"    PG_RETURN_POINTER(retval);\n"
"}"

#: gist.xml:890(para)
msgid ""
"The matching code in the C module could then follow this skeleton: "
"<placeholder-1/>"
msgstr ""
"Соответствующий код в модуле C должен реализовываться по такому шаблону: "
"<placeholder-1/>"

#: gist.xml:920(para)
msgid ""
"If the compress method is lossy for leaf entries, the operator class cannot "
"support index-only scans, and must not define a <function>fetch</function> "
"function."
msgstr ""
"Если метод сжатия является неточным для записей уровня листьев, такой класс "
"операторов не может поддерживать сканирование только индекса и не должен "
"определять функцию <function>fetch</function>."

#: gist.xml:930(para)
msgid ""
"All the GiST support methods are normally called in short-lived memory "
"contexts; that is, <varname>CurrentMemoryContext</varname> will get reset "
"after each tuple is processed. It is therefore not very important to worry "
"about pfree'ing everything you palloc. However, in some cases it's useful "
"for a support method to cache data across repeated calls. To do that, "
"allocate the longer-lived data in <literal>fcinfo-&gt;flinfo-&gt;fn_mcxt</"
"literal>, and keep a pointer to it in <literal>fcinfo-&gt;flinfo-&gt;"
"fn_extra</literal>. Such data will survive for the life of the index "
"operation (e.g., a single GiST index scan, index build, or index tuple "
"insertion). Be careful to pfree the previous value when replacing a "
"<literal>fn_extra</literal> value, or the leak will accumulate for the "
"duration of the operation."
msgstr ""
"Все опорные методы GiST обычно вызываются в кратковременных контекстах "
"памяти; то есть, <varname>CurrentMemoryContext</varname> сбрасывается после "
"обработки каждого кортежа. Таким образом можно не заботиться об освобождении "
"любых блоков памяти, выделенных функцией palloc. Однако в некоторых случаях "
"для опорного метода полезно кешировать какие-либо данные между вызовами. Для "
"этого нужно разместить долгоживущие данные в контексте <literal>fcinfo-&gt;"
"flinfo-&gt;fn_mcxt</literal> и сохранить указатель на них в <literal>fcinfo-"
"&gt;flinfo-&gt;fn_extra</literal>. Такие данные смогут просуществовать всё "
"время операции с индексом (например, одно сканирование индекса GiST, "
"построение индекса или добавление кортежа в индекс). Не забудьте вызвать "
"pfree для предыдущего значения, заменяя значение в <literal>fn_extra</"
"literal>, чтобы не допустить накопления утечек памяти в ходе операции."

#: gist.xml:947(title)
msgid "Implementation"
msgstr "Реализация"

#: gist.xml:950(title)
msgid "GiST buffering build"
msgstr "Построение GiST с буферизацией"

#: gist.xml:951(para)
msgid ""
"Building large GiST indexes by simply inserting all the tuples tends to be "
"slow, because if the index tuples are scattered across the index and the "
"index is large enough to not fit in cache, the insertions need to perform a "
"lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more "
"efficient method to build GiST indexes based on buffering, which can "
"dramatically reduce the number of random I/Os needed for non-ordered data "
"sets. For well-ordered data sets the benefit is smaller or non-existent, "
"because only a small number of pages receive new tuples at a time, and those "
"pages fit in cache even if the index as whole does not."
msgstr ""
"Если попытаться построить большой индекс GiST, просто добавляя все кортежи "
"по очереди, скорее всего это будет медленно, потому что если кортежи "
"индексов будут разбросаны по всему индексу, а индекс будет большим и не "
"поместится в кеше, при добавлении записей потребуется произвести множество "
"операций произвольного доступа. Начиная с версии 9.2, PostgreSQL "
"поддерживает более эффективный метод построения индексов с применением "
"буферизации, что позволяет кардинально сократить число операций "
"произвольного доступа, требующихся при обработке неупорядоченных наборов "
"данных. Для хорошо упорядоченных наборов выигрыш может быть минимальным или "
"вообще отсутствовать, так как всего несколько страниц будут принимать новые "
"кортежи в один момент времени, и эти страницы будут умещаться в кеше, даже "
"если весь индекс очень большой."

#: gist.xml:963(para)
msgid ""
"However, buffering index build needs to call the <function>penalty</"
"function> function more often, which consumes some extra CPU resources. "
"Also, the buffers used in the buffering build need temporary disk space, up "
"to the size of the resulting index. Buffering can also influence the quality "
"of the resulting index, in both positive and negative directions. That "
"influence depends on various factors, like the distribution of the input "
"data and the operator class implementation."
msgstr ""
"Однако, при построении индекса с буферизацией приходится гораздо чаще "
"вызывать функцию <function>penalty</function>, на что уходят дополнительные "
"ресурсы процессора. Кроме того, используемым для этой операции буферам "
"требуется временное место на диске, вплоть до размера результирующего "
"индекса. Буферизация также может повлиять на качество результирующего "
"индекса, как в положительную, так и в отрицательную сторону. Это влияние "
"зависит от различных факторов, например, от распределения поступающих данных "
"и от реализации класса операторов."

#: gist.xml:973(para)
msgid ""
"By default, a GiST index build switches to the buffering method when the "
"index size reaches <xref linkend=\"guc-effective-cache-size\"/>. It can be "
"manually turned on or off by the <literal>buffering</literal> parameter to "
"the CREATE INDEX command. The default behavior is good for most cases, but "
"turning buffering off might speed up the build somewhat if the input data is "
"ordered."
msgstr ""
"По умолчанию при построении индекса GiST включается буферизация, когда "
"размер индекса достигает значения <xref linkend=\"guc-effective-cache-size\"/"
">. Этот режим можно вручную включить или отключить с помощью параметра "
"<literal>buffering</literal> команды CREATE INDEX. Поведение по умолчанию "
"достаточно эффективно в большинстве случаев, но если входные данные "
"упорядочены, выключив буферизацию, можно получить некоторое ускорение."

#: gist.xml:986(title)
msgid "Examples"
msgstr "Примеры"

#: gist.xml:1000(filename)
msgid "btree_gist"
msgstr "btree_gist"

#: gist.xml:1002(para)
msgid "B-tree equivalent functionality for several data types"
msgstr "Функциональность B-дерева для различных типов данных"

#: gist.xml:1007(filename)
msgid "cube"
msgstr "cube"

#: gist.xml:1009(para)
msgid "Indexing for multidimensional cubes"
msgstr "Индексирование для многомерных кубов"

#: gist.xml:1014(filename)
msgid "hstore"
msgstr "hstore"

#: gist.xml:1016(para)
msgid "Module for storing (key, value) pairs"
msgstr "Модуль для хранения пар (ключ, значение)"

#: gist.xml:1021(filename)
msgid "intarray"
msgstr "intarray"

#: gist.xml:1023(para)
msgid "RD-Tree for one-dimensional array of int4 values"
msgstr "RD-дерево для одномерных массивов значений int4"

#: gist.xml:1028(filename)
msgid "ltree"
msgstr "ltree"

#: gist.xml:1030(para)
msgid "Indexing for tree-like structures"
msgstr "Индексирование древовидных структур"

#: gist.xml:1035(filename)
msgid "pg_trgm"
msgstr "pg_trgm"

#: gist.xml:1037(para)
msgid "Text similarity using trigram matching"
msgstr "Схожесть текста на основе статистики триграмм"

#: gist.xml:1042(filename)
msgid "seg"
msgstr "seg"

#: gist.xml:1044(para)
msgid "Indexing for <quote>float ranges</quote>"
msgstr "Индексирование <quote>диапазонов чисел с плавающей точкой</quote>"

#: gist.xml:988(para)
msgid ""
"The <productname>PostgreSQL</productname> source distribution includes "
"several examples of index methods implemented using <acronym>GiST</acronym>. "
"The core system currently provides text search support (indexing for "
"<type>tsvector</type> and <type>tsquery</type>) as well as R-Tree equivalent "
"functionality for some of the built-in geometric data types (see "
"<filename>src/backend/access/gist/gistproc.c</filename>). The following "
"<filename>contrib</filename> modules also contain <acronym>GiST</acronym> "
"operator classes: <placeholder-1/>"
msgstr ""
"В дистрибутив исходного кода <productname>PostgreSQL</productname> включены "
"несколько примеров методов индексов, реализованных на базе <acronym>GiST</"
"acronym>. В настоящее время ядро системы обеспечивает поддержку текстового "
"поиска (индексацию типов <type>tsvector</type> и <type>tsquery</type>), а "
"также функциональность R-дерева для некоторых встроенных геометрических "
"типов данных (см. <filename>src/backend/access/gist/gistproc.c</filename>). "
"Классы операторов <acronym>GiST</acronym> содержатся также и в следующих "
"дополнительных модулях (<filename>contrib</filename>): <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: gist.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
