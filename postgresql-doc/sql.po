# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: sql.xml:5(title)
msgid "SQL"
msgstr "SQL"

#: sql.xml:8(para)
msgid ""
"This chapter introduces the mathematical concepts behind relational "
"databases. It is not required reading, so if you bog down or want to get "
"straight to some simple examples feel free to jump ahead to the next chapter "
"and come back when you have more time and patience. This stuff is supposed "
"to be fun!"
msgstr ""
"В этой главе вводятся математические концепции, стоящие за реляционными "
"базами данных. Этот материал не является обязательным к прочтению, так что "
"если он окажется сложным или вы хотите сразу перейти к простым примерам, вы "
"можете свободно пропустить эту главу и вернуться сюда, когда у вас будет "
"больше времени и терпения. Тут должно быть интересно!"

#: sql.xml:16(para)
msgid ""
"This material originally appeared as a part of Stefan Simkovics' Master's "
"Thesis (<xref linkend=\"sim98\" endterm=\"sim98\"/>)."
msgstr ""
"Этот материал изначально был представлен в дипломной работе Стефана "
"Симковича (<xref linkend=\"sim98\" endterm=\"sim98\"/>)."

#: sql.xml:23(para)
msgid ""
"<acronym>SQL</acronym> has become the most popular relational query "
"language. The name <quote><acronym>SQL</acronym></quote> is an abbreviation "
"for <firstterm>Structured Query Language</firstterm>. In 1974 Donald "
"Chamberlin and others defined the language SEQUEL (<firstterm>Structured "
"English Query Language</firstterm>) at IBM Research. This language was first "
"implemented in an IBM prototype called SEQUEL-XRM in 1974-75. In 1976-77 a "
"revised version of SEQUEL called SEQUEL/2 was defined and the name was "
"changed to <acronym>SQL</acronym> subsequently."
msgstr ""
"<acronym>SQL</acronym> стал самым популярным языком реляционных запросов. "
"Название <quote><acronym>SQL</acronym></quote> является аббревиатурой от "
"<firstterm>Structured Query Language</firstterm> (Язык структурированных "
"запросов). В 1974 в группе IBM Research Дональд Чамберлин с коллегами "
"разработали язык SEQUEL (<firstterm>Structured English Query Language</"
"firstterm>, Язык структурированных англоязычных запросов). Сначала этот язык "
"был воплощён внутри IBM, в прототипе, названном SEQUEL-XRM, в 1974-75 г. В "
"1976-77 была определена пересмотренная версия SEQUEL, названная SEQUEL/2, а "
"затем имя было изменено на <acronym>SQL</acronym>."

#: sql.xml:38(para)
msgid ""
"A new prototype called System R was developed by IBM in 1977. System R "
"implemented a large subset of SEQUEL/2 (now <acronym>SQL</acronym>) and a "
"number of changes were made to <acronym>SQL</acronym> during the project. "
"System R was installed in a number of user sites, both internal IBM sites "
"and also some selected customer sites. Thanks to the success and acceptance "
"of System R at those user sites IBM started to develop commercial products "
"that implemented the <acronym>SQL</acronym> language based on the System R "
"technology."
msgstr ""
"Новый прототип, названный System R, был разработан в IBM в 1977 г. В проекте "
"System R было реализовано большое подмножество SEQUEL/2 (ставшего "
"<acronym>SQL</acronym>), а в процессе его разработки ряд изменений был "
"внесён и в <acronym>SQL</acronym>. Технология System R была внедрена на "
"нескольких площадках, как внутри IBM, так и у некоторых клиентов. Благодаря "
"признанию System R и успеху у этих пользователей, IBM начала разрабатывать "
"коммерческие продукты, реализующие язык <acronym>SQL</acronym> на базе "
"System R."

#: sql.xml:51(para)
msgid ""
"Over the next years IBM and also a number of other vendors announced "
"<acronym>SQL</acronym> products such as <productname>SQL/DS</productname> "
"(IBM), <productname>DB2</productname> (IBM), <productname>ORACLE</"
"productname> (Oracle Corp.), <productname>DG/SQL</productname> (Data General "
"Corp.), and <productname>SYBASE</productname> (Sybase Inc.)."
msgstr ""
"За следующие несколько лет IBM и ряд других компаний анонсировали несколько "
"продуктов <acronym>SQL</acronym>, включая <productname>SQL/DS</productname> "
"(IBM), <productname>DB2</productname> (IBM), <productname>ORACLE</"
"productname> (Oracle Corp.), <productname>DG/SQL</productname> (Data General "
"Corp.) и <productname>SYBASE</productname> (Sybase Inc.)."

#: sql.xml:61(para)
msgid ""
"<acronym>SQL</acronym> is also an official standard now. In 1982 the "
"American National Standards Institute (<acronym>ANSI</acronym>) chartered "
"its Database Committee X3H2 to develop a proposal for a standard relational "
"language. This proposal was ratified in 1986 and consisted essentially of "
"the IBM dialect of <acronym>SQL</acronym>. In 1987 this <acronym>ANSI</"
"acronym> standard was also accepted as an international standard by the "
"International Organization for Standardization (<acronym>ISO</acronym>). "
"This original standard version of <acronym>SQL</acronym> is often referred "
"to, informally, as <quote><abbrev>SQL/86</abbrev></quote>. In 1989 the "
"original standard was extended and this new standard is often, again "
"informally, referred to as <quote><abbrev>SQL/89</abbrev></quote>. Also in "
"1989, a related standard called <firstterm>Database Language Embedded "
"<acronym>SQL</acronym></firstterm> (<acronym>ESQL</acronym>) was developed."
msgstr ""
"Сейчас <acronym>SQL</acronym> является официальным стандартом. В 1982 г. "
"Американский национальный институт стандартов (<acronym>ANSI</acronym>, "
"American National Standards Institute) поручил своему комитету баз данных "
"X3H2 разработать предложение для стандартного реляционного языка. Это "
"предложение было принято в 1986 и по сути содержало диалект <acronym>SQL</"
"acronym>, сложившийся в IBM. В 1987 г. этот стандарт <acronym>ANSI</acronym> "
"также был принят в качестве международного стандарта Международной "
"организацией по стандартизации (<acronym>ISO</acronym>, International "
"Organization for Standardization). Первоначальная версия стандарта "
"<acronym>SQL</acronym> часто неформально называется <quote><abbrev>SQL/86</"
"abbrev></quote>. В 1989 г. первая версия стандарта была расширена и этот "
"новый стандарт получил, так же неформальное, название <quote><abbrev>SQL/89</"
"abbrev></quote>. В том же 1989 г. был разработан связанный стандарт "
"<firstterm>Язык баз данных Встраиваемый <acronym>SQL</acronym></firstterm> "
"(<acronym>ESQL</acronym>, Embedded <acronym>SQL</acronym>)."

#: sql.xml:82(para)
msgid ""
"The <acronym>ISO</acronym> and <acronym>ANSI</acronym> committees have been "
"working for many years on the definition of a greatly expanded version of "
"the original standard, referred to informally as <firstterm><acronym>SQL2</"
"acronym></firstterm> or <firstterm><acronym>SQL/92</acronym></firstterm>. "
"This version became a ratified standard - <quote>International Standard ISO/"
"IEC 9075:1992, Database Language <acronym>SQL</acronym></quote> - in late "
"1992. <acronym>SQL/92</acronym> is the version normally meant when people "
"refer to <quote>the <acronym>SQL</acronym> standard</quote>. A detailed "
"description of <acronym>SQL/92</acronym> is given in <xref linkend="
"\"date97\" endterm=\"date97\"/>. At the time of writing this document a new "
"standard informally referred to as <firstterm><acronym>SQL3</acronym></"
"firstterm> is under development. It is planned to make <acronym>SQL</"
"acronym> a Turing-complete language, i.e., all computable queries (e.g., "
"recursive queries) will be possible. This has now been completed as SQL:2003."
msgstr ""
"Комитеты <acronym>ISO</acronym> и <acronym>ANSI</acronym> несколько лет "
"работали над определением значительно расширенной версии начального "
"стандарта, получившей неформальное название <firstterm><acronym>SQL2</"
"acronym></firstterm> или <firstterm><acronym>SQL/92</acronym></firstterm>. "
"Эта версия стала принятым стандартом <quote>International Standard ISO/IEC "
"9075:1992, Database Language <acronym>SQL</acronym></quote> в конце 1992 г. "
"И сейчас, когда говорят <quote>о стандарте <acronym>SQL</acronym></quote>, "
"обычно имеют в виду версию <acronym>SQL/92</acronym>. Подробное описание "
"<acronym>SQL/92</acronym> приведено в книге <xref linkend=\"date97\" endterm="
"\"date97\"/>. На момент написания этого материала разрабатывался новый "
"стандарт, неформально называемый <firstterm><acronym>SQL3</acronym></"
"firstterm>. Планировалось, что в нём <acronym>SQL</acronym> станет языком, "
"полным по Тьюрингу, то есть будут возможны все вычисляемые запросы "
"(например, рекурсивные). Позже это было воплощено в стандарте SQL:2003."

#: sql.xml:104(title)
msgid "The Relational Data Model"
msgstr "Реляционная модель данных"

#: sql.xml:106(para)
msgid ""
"As mentioned before, <acronym>SQL</acronym> is a relational language. That "
"means it is based on the <firstterm>relational data model</firstterm> first "
"published by E.F. Codd in 1970. We will give a formal description of the "
"relational model later (in <xref linkend=\"formal-notion\" endterm=\"formal-"
"notion\"/>) but first we want to have a look at it from a more intuitive "
"point of view."
msgstr ""
"Как упоминалось ранее, <acronym>SQL</acronym> является реляционным языком. "
"Это означает, что он основан на <firstterm>реляционной модели данных</"
"firstterm>, которую впервые предложил Эдгар Франк Кодд в 1970 г. Мы дадим "
"формальное описание реляционной модели позже (в <xref remap=\"6\" linkend="
"\"formal-notion\" endterm=\"formal-notion\"/>), но сначала хотим посмотреть "
"на неё с более интуитивной точки зрения."

#: sql.xml:131(para)
msgid ""
"SUPPLIER is a table storing the number (SNO), the name (SNAME) and the city "
"(CITY) of a supplier."
msgstr ""
"Таблица &laquo;Поставщик&raquo; (SUPPLIER) содержит номер (SNO), имя (SNAME) "
"и город (CITY) поставщика."

#: sql.xml:138(para)
msgid ""
"PART is a table storing the number (PNO) the name (PNAME) and the price "
"(PRICE) of a part."
msgstr ""
"Таблица &laquo;Деталь&raquo; (PART) содержит номер (PNO), имя (PNAME) и цену "
"(PRICE) детали."

#: sql.xml:145(para)
msgid ""
"SELLS stores information about which part (PNO) is sold by which supplier "
"(SNO). It serves in a sense to connect the other two tables together."
msgstr ""
"Таблица &laquo;Продажи&raquo; (SELLS) содержит информацию о том, какая "
"деталь (PNO) была продана каким поставщиком (SNO). Она играет роль "
"связывающей две другие таблицы."

#: sql.xml:154(title)
msgid "The Suppliers and Parts Database"
msgstr "База данных поставщиков и деталей"

#: sql.xml:118(para)
msgid ""
"A <firstterm>relational database</firstterm> is a database that is perceived "
"by its users as a <firstterm>collection of tables</firstterm> (and nothing "
"else but tables). A table consists of rows and columns where each row "
"represents a record and each column represents an attribute of the records "
"contained in the table. <xref linkend=\"supplier-fig\" endterm=\"supplier-fig"
"\"/> shows an example of a database consisting of three tables: "
"<placeholder-1/> <example><placeholder-2/> <screen>\n"
"SUPPLIER:                   SELLS:\n"
" SNO |  SNAME  |  CITY       SNO | PNO\n"
"----+---------+--------     -----+-----\n"
" 1  |  Smith  | London        1  |  1\n"
" 2  |  Jones  | Paris         1  |  2\n"
" 3  |  Adams  | Vienna        2  |  4\n"
" 4  |  Blake  | Rome          3  |  1\n"
"                              3  |  3\n"
"                              4  |  2\n"
"PART:                         4  |  3\n"
" PNO |  PNAME  |  PRICE       4  |  4\n"
"----+---------+---------\n"
" 1  |  Screw  |   10\n"
" 2  |  Nut    |    8\n"
" 3  |  Bolt   |   15\n"
" 4  |  Cam    |   25\n"
"</screen></example>"
msgstr ""
"<firstterm>Реляционная база данных</firstterm> — это база данных, "
"воспринимаемая пользователями как <firstterm>набор таблиц</firstterm> (и "
"ничего кроме таблиц). Таблицы состоят из строк и столбцов, в которой каждая "
"строка представляет запись, а каждый столбец — один атрибут записей, "
"содержащихся в таблице. <xref linkend=\"supplier-fig\" endterm=\"supplier-fig"
"\"/> показывает пример базы данных, состоящей из трёх таблиц: <placeholder-1/"
"> <example><placeholder-2/>\n"
"<screen>\n"
"SUPPLIER:                   SELLS:\n"
" SNO |  SNAME  |  CITY       SNO | PNO\n"
"----+---------+--------     -----+-----\n"
" 1  |  Smith  | London        1  |  1\n"
" 2  |  Jones  | Paris         1  |  2\n"
" 3  |  Adams  | Vienna        2  |  4\n"
" 4  |  Blake  | Rome          3  |  1\n"
"                              3  |  3\n"
"                              4  |  2\n"
"PART:                         4  |  3\n"
" PNO |  PNAME  |  PRICE       4  |  4\n"
"----+---------+---------\n"
" 1  |  Screw  |   10\n"
" 2  |  Nut    |    8\n"
" 3  |  Bolt   |   15\n"
" 4  |  Cam    |   25\n"
"</screen></example>"

#: sql.xml:176(para)
msgid ""
"The tables PART and SUPPLIER can be regarded as <firstterm>entities</"
"firstterm> and SELLS can be regarded as a <firstterm>relationship</"
"firstterm> between a particular part and a particular supplier."
msgstr ""
"Таблицы PART и SUPPLIER можно считать <firstterm>сущностями</firstterm> в "
"БД, а SELLS — устанавливающей <firstterm>связь</firstterm> между "
"определённой деталью и определённым поставщиком."

#: sql.xml:184(para)
msgid ""
"As we will see later, <acronym>SQL</acronym> operates on tables like the "
"ones just defined but before that we will study the theory of the relational "
"model."
msgstr ""
"Как мы увидим позже, <acronym>SQL</acronym> работает с таблицами, подобными "
"тем, что были только что определены, но прежде мы изучим теорию реляционной "
"модели."

#: sql.xml:193(title)
msgid "Relational Data Model Formalities"
msgstr "Формальное определение реляционной модели данных"

#: sql.xml:195(para)
msgid ""
"The mathematical concept underlying the relational model is the set-"
"theoretic <firstterm>relation</firstterm> which is a subset of the Cartesian "
"product of a list of domains. This set-theoretic relation gives the model "
"its name (do not confuse it with the relationship from the <firstterm>Entity-"
"Relationship model</firstterm>). Formally a domain is simply a set of "
"values. For example the set of integers is a domain. Also the set of "
"character strings of length 20 and the real numbers are examples of domains."
msgstr ""
"Математическая концепция, стоящая за реляционной моделью, основана на "
"<firstterm>отношениях</firstterm>, являющихся декартовым произведением "
"списка доменов. Отношение (англ. relation) из теории множеств и дало модели "
"название (англ. relational) (не стоит путать его с отношением в "
"<firstterm>модели сущность-связь</firstterm>). Доменом в данном контексте "
"формально является просто множество значений. Например, домен образует "
"множество целых чисел. Другие примеры доменов — множество строк из 20 "
"символов или вещественные числа."

# well-spelled: арных
#: sql.xml:208(para)
msgid ""
"The <firstterm>Cartesian product</firstterm> of domains "
"<parameter>D<subscript>1</subscript></parameter>, <parameter>D<subscript>2</"
"subscript></parameter>, ... <parameter>D<subscript>k</subscript></"
"parameter>, written <parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> &times; ... &times; "
"<parameter>D<subscript>k</subscript></parameter> is the set of all k-tuples "
"<parameter>v<subscript>1</subscript></parameter>, <parameter>v<subscript>2</"
"subscript></parameter>, ... <parameter>v<subscript>k</subscript></"
"parameter>, such that <parameter>v<subscript>1</subscript></parameter> "
"&isin; <parameter>D<subscript>1</subscript></parameter>, "
"<parameter>v<subscript>2</subscript></parameter> &isin; "
"<parameter>D<subscript>2</subscript></parameter>, ... "
"<parameter>v<subscript>k</subscript></parameter> &isin; "
"<parameter>D<subscript>k</subscript></parameter>."
msgstr ""
"<firstterm>Декартовым произведением</firstterm> доменов "
"<parameter>D<subscript>1</subscript></parameter>, <parameter>D<subscript>2</"
"subscript></parameter>, ... <parameter>D<subscript>k</subscript></parameter> "
"(записывается как <parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> &times; ... &times; "
"<parameter>D<subscript>k</subscript></parameter>) является множество из всех "
"k-арных кортежей <parameter>v<subscript>1</subscript></parameter>, "
"<parameter>v<subscript>2</subscript></parameter>, ... "
"<parameter>v<subscript>k</subscript></parameter>, таких, что "
"<parameter>v<subscript>1</subscript></parameter> &isin; "
"<parameter>D<subscript>1</subscript></parameter>, <parameter>v<subscript>2</"
"subscript></parameter> &isin; <parameter>D<subscript>2</subscript></"
"parameter>, ... <parameter>v<subscript>k</subscript></parameter> &isin; "
"<parameter>D<subscript>k</subscript></parameter>."

#: sql.xml:243(para)
msgid ""
"For example, when we have <parameter>k</parameter>=2, "
"<parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal> "
"and <parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</"
"literal> then <parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> is <literal>{(0,a),(0,b),(0,"
"c),(1,a),(1,b),(1,c)}</literal>."
msgstr ""
"Например, если <parameter>k</parameter>=2, <parameter>D<subscript>1</"
"subscript></parameter>=<literal>{0,1}</literal> и <parameter>D<subscript>2</"
"subscript></parameter>=<literal>{a,b,c}</literal>, то "
"<parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> равняется <literal>{(0,a),"
"(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>."

#: sql.xml:258(para)
msgid ""
"A Relation is any subset of the Cartesian product of one or more domains: "
"<parameter>R</parameter> &sube; <parameter>D<subscript>1</subscript></"
"parameter> &times; <parameter>D<subscript>2</subscript></parameter> "
"&times; ... &times; <parameter>D<subscript>k</subscript></parameter>."
msgstr ""
"Отношением является любое подмножество декартова произведения одного или "
"нескольких доменов: <parameter>R</parameter> &sube; "
"<parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> &times; ... &times; "
"<parameter>D<subscript>k</subscript></parameter>."

#: sql.xml:273(para)
msgid ""
"For example <literal>{(0,a),(0,b),(1,a)}</literal> is a relation; it is in "
"fact a subset of <parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> mentioned above."
msgstr ""
"Например, <literal>{(0,a),(0,b),(1,a)}</literal> — это отношение, и на самом "
"деле оно является подмножеством вышеописанного произведения "
"<parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter>."

#: sql.xml:281(para)
msgid ""
"The members of a relation are called tuples. Each relation of some Cartesian "
"product <parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> &times; ... &times; "
"<parameter>D<subscript>k</subscript></parameter> is said to have arity "
"<literal>k</literal> and is therefore a set of <literal>k</literal>-tuples."
msgstr ""
"Члены отношения называются кортежами. Про отношение некоторого декартового "
"произведения <parameter>D<subscript>1</subscript></parameter> &times; "
"<parameter>D<subscript>2</subscript></parameter> &times; ... &times; "
"<parameter>D<subscript>k</subscript></parameter> говорят, что оно имеет "
"арность <literal>k</literal> и таким образом является множеством <literal>k</"
"literal>-арных кортежей."

#: sql.xml:292(para)
msgid ""
"A relation can be viewed as a table (as we already did, remember <xref "
"linkend=\"supplier-fig\" endterm=\"supplier-fig\"/> where every tuple is "
"represented by a row and every column corresponds to one component of a "
"tuple. Giving names (called attributes) to the columns leads to the "
"definition of a <firstterm>relation scheme</firstterm>."
msgstr ""
"Отношение можно рассматривать как таблицу (как мы уже делали, вспомните "
"<xref linkend=\"supplier-fig\" endterm=\"supplier-fig\"/>, где каждый кортеж "
"представляет строку, а каждый столбец соответствует одному компоненту "
"кортежа. Введя имёна (называемые атрибутами) столбцов, мы приходим к "
"определению <firstterm>схемы отношения</firstterm>."

#: sql.xml:330(para)
msgid ""
"A <firstterm>relation scheme</firstterm> is just a kind of template whereas "
"a <firstterm>relation</firstterm> is an instance of a <firstterm>relation "
"scheme</firstterm>. The relation consists of tuples (and can therefore be "
"viewed as a table); not so the relation scheme."
msgstr ""
"<firstterm>Реляционная схема</firstterm> — это своего рода класс, "
"экземпляром которого является <firstterm>отношение</firstterm>. Отношение "
"состоит из кортежей (и поэтому может рассматриваться как таблица), в отличие "
"от реляционной схемы."

#: sql.xml:301(para)
msgid ""
"A <firstterm>relation scheme</firstterm> <literal>R</literal> is a finite "
"set of attributes <parameter>A<subscript>1</subscript></parameter>, "
"<parameter>A<subscript>2</subscript></parameter>, ... "
"<parameter>A<subscript>k</subscript></parameter>. There is a domain "
"<parameter>D<subscript>i</subscript></parameter>, for each attribute "
"<parameter>A<subscript>i</subscript></parameter>, 1 &lt;= <literal>i</"
"literal> &lt;= <literal>k</literal>, where the values of the attributes are "
"taken from. We often write a relation scheme as "
"<literal>R(<parameter>A<subscript>1</subscript></parameter>, "
"<parameter>A<subscript>2</subscript></parameter>, ... "
"<parameter>A<subscript>k</subscript></parameter>)</literal>. <placeholder-1/>"
msgstr ""
"<firstterm>Реляционная схема</firstterm> <literal>R</literal> определяет "
"<parameter>A<subscript>1</subscript></parameter>, <parameter>A<subscript>2</"
"subscript></parameter>, ... <parameter>A<subscript>k</subscript></"
"parameter>. Для каждого атрибута <parameter>A<subscript>i</subscript></"
"parameter>, 1 &lt;= <literal>i</literal> &lt;= <literal>k</literal> "
"существует домен <parameter>D<subscript>i</subscript></parameter>, из "
"которого берутся значения атрибутов. Мы часто записываем реляционную схему "
"как <literal>R(<parameter>A<subscript>1</subscript></parameter>, "
"<parameter>A<subscript>2</subscript></parameter>, ... "
"<parameter>A<subscript>k</subscript></parameter>)</literal>. <placeholder-1/>"

#: sql.xml:342(title)
msgid "Domains vs. Data Types"
msgstr "Домены и типы данных"

#: sql.xml:344(para)
msgid ""
"We often talked about <firstterm>domains</firstterm> in the last section. "
"Recall that a domain is, formally, just a set of values (e.g., the set of "
"integers or the real numbers). In terms of database systems we often talk of "
"<firstterm>data types</firstterm> instead of domains. When we define a table "
"we have to make a decision about which attributes to include. Additionally "
"we have to decide which kind of data is going to be stored as attribute "
"values. For example the values of <classname>SNAME</classname> from the "
"table <classname>SUPPLIER</classname> will be character strings, whereas "
"<classname>SNO</classname> will store integers. We define this by assigning "
"a data type to each attribute. The type of <classname>SNAME</classname> will "
"be <type>VARCHAR(20)</type> (this is the <acronym>SQL</acronym> type for "
"character strings of length &lt;= 20), the type of <classname>SNO</"
"classname> will be <type>INTEGER</type>. With the assignment of a data type "
"we also have selected a domain for an attribute. The domain of "
"<classname>SNAME</classname> is the set of all character strings of length "
"&lt;= 20, the domain of <classname>SNO</classname> is the set of all integer "
"numbers."
msgstr ""
"В последнем разделе мы часто говорили о <firstterm>доменах</firstterm>. "
"Вспомните, что домен формально является просто множеством значений "
"(например, множество целых или вещественных чисел). В терминах баз данных мы "
"часто говорим о <firstterm>типах данных</firstterm>, а не о доменах. Когда "
"мы определяем таблицу, мы должны решить, какие атрибуты в неё включить. "
"Кроме того, необходимо решить, какого рода данные будут храниться в качестве "
"значений атрибутов. Например, значениями <classname>SNAME</classname> в "
"таблице <classname>SUPPLIER</classname> будут символьные строки, тогда как в "
"<classname>SNO</classname> будут храниться целые числа. Мы определяем это, "
"назначая типы данных каждому атрибуту. Типом <classname>SNAME</classname> "
"будет <type>VARCHAR(20)</type> (это тип <acronym>SQL</acronym> для "
"символьных строк длины &lt;= 20), а типом <classname>SNO</classname> будет "
"<type>INTEGER</type>. Назначая тип данных, мы тем самым также выбираем домен "
"для атрибута. Доменом <classname>SNAME</classname> будет множество всех "
"символьных строк длины &lt;= 20, а доменом <classname>SNO</classname> — "
"множество всех целых чисел."

#: sql.xml:374(title)
msgid "Operations in the Relational Data Model"
msgstr "Операции в реляционной модели данных"

#: sql.xml:389(para)
msgid ""
"The <firstterm>Relational Algebra</firstterm> which is an algebraic "
"notation, where queries are expressed by applying specialized operators to "
"the relations."
msgstr ""
"<firstterm>Реляционная алгебра</firstterm>, представляющая алгебраическую "
"нотацию, в которой запросы выражаются как применение специализированных "
"операторов к отношениям."

#: sql.xml:398(para)
msgid ""
"The <firstterm>Relational Calculus</firstterm> which is a logical notation, "
"where queries are expressed by formulating some logical restrictions that "
"the tuples in the answer must satisfy."
msgstr ""
"<firstterm>Реляционное исчисление</firstterm>, представляющее логическую "
"нотацию, в которой запросы выражаются как формулировка логических "
"ограничений, которым должны удовлетворять интересующие кортежи."

#: sql.xml:376(para)
msgid ""
"In the previous section (<xref linkend=\"formal-notion\" endterm=\"formal-"
"notion\"/>) we defined the mathematical notion of the relational model. Now "
"we know how the data can be stored using a relational data model but we do "
"not know what to do with all these tables to retrieve something from the "
"database yet. For example somebody could ask for the names of all suppliers "
"that sell the part 'Screw'. Therefore two rather different kinds of "
"notations for expressing operations on relations have been defined: "
"<placeholder-1/>"
msgstr ""
"В предыдущем разделе (<xref linkend=\"formal-notion\" endterm=\"formal-notion"
"\"/>) мы определили математическую запись реляционной модели. Теперь мы "
"знаем, как данные могут храниться в реляционной модели данных, но пока ещё "
"не знаем, что делать со всеми этими таблицами, чтобы извлечь что-либо из "
"базы данных. Например, кого-то могут интересовать имена всех поставщиков, "
"продающих шурупы (деталь 'Screw'). Для этого были определены два весьма "
"различных вида нотаций, позволяющих выражать операции с отношениями: "
"<placeholder-1/>"

#: sql.xml:409(title)
msgid "Relational Algebra"
msgstr "Реляционная алгебра"

#: sql.xml:417(para)
msgid ""
"SELECT (&sigma;): extracts <firstterm>tuples</firstterm> from a relation "
"that satisfy a given restriction. Let <parameter>R</parameter> be a table "
"that contains an attribute <parameter>A</parameter>. &sigma;<subscript>A=a</"
"subscript>(R) = {t &isin; R &mid; t(A) = a} where <literal>t</literal> "
"denotes a tuple of <parameter>R</parameter> and <literal>t(A)</literal> "
"denotes the value of attribute <parameter>A</parameter> of tuple <literal>t</"
"literal>."
msgstr ""
"SELECT (&sigma;): извлекает <firstterm>кортежи</firstterm> из отношения, "
"удовлетворяющие заданному ограничению. Пусть <parameter>R</parameter> — "
"таблица, содержащая атрибут <parameter>A</parameter>. &sigma;<subscript>A=a</"
"subscript>(R) = {t &isin; R &mid; t(A) = a}, где <literal>t</literal> "
"обозначает кортеж отношения <parameter>R</parameter>, а <literal>t(A)</"
"literal> обозначает значение атрибута <parameter>A</parameter> кортежа "
"<literal>t</literal>."

#: sql.xml:432(para)
msgid ""
"PROJECT (&pi;): extracts specified <firstterm>attributes</firstterm> "
"(columns) from a relation. Let <classname>R</classname> be a relation that "
"contains an attribute <classname>X</classname>. &pi;<subscript>X</"
"subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</"
"classname>}, where <literal>t</literal>(<classname>X</classname>) denotes "
"the value of attribute <classname>X</classname> of tuple <literal>t</"
"literal>."
msgstr ""
"PROJECT (&pi;): извлекает указанные <firstterm>атрибуты</firstterm> "
"(столбцы) из отношения. Пусть <classname>R</classname> — отношение, "
"содержащее атрибут <classname>X</classname>, тогда &pi;<subscript>X</"
"subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</"
"classname>}, где <literal>t</literal>(<classname>X</classname>) обозначает "
"значение атрибута <classname>X</classname> кортежа <literal>t</literal>."

#: sql.xml:444(para)
msgid ""
"PRODUCT (&times;): builds the Cartesian product of two relations. Let "
"<classname>R</classname> be a table with arity <literal>k</"
"literal><subscript>1</subscript> and let <classname>S</classname> be a table "
"with arity <literal>k</literal><subscript>2</subscript>. <classname>R</"
"classname> &times; <classname>S</classname> is the set of all <literal>k</"
"literal><subscript>1</subscript> + <literal>k</literal><subscript>2</"
"subscript>-tuples whose first <literal>k</literal><subscript>1</subscript> "
"components form a tuple in <classname>R</classname> and whose last "
"<literal>k</literal><subscript>2</subscript> components form a tuple in "
"<classname>S</classname>."
msgstr ""
"PRODUCT (&times;): формирует декартово произведение двух отношений. Пусть "
"<classname>R</classname> — таблица с арностью <literal>k</"
"literal><subscript>1</subscript> и <classname>S</classname> — таблица с "
"арностью <literal>k</literal><subscript>2</subscript>. Тогда <classname>R</"
"classname> &times; <classname>S</classname> — множество всех <literal>k</"
"literal><subscript>1</subscript> + <literal>k</literal><subscript>2</"
"subscript>-арных кортежей, в которых первые <literal>k</"
"literal><subscript>1</subscript> компонентов формируют кортеж в "
"<classname>R</classname>, а последние <literal>k</literal><subscript>2</"
"subscript> компонентов формируют кортеж в <classname>S</classname>."

#: sql.xml:462(para)
msgid ""
"UNION (&cup;): builds the set-theoretic union of two tables. Given the "
"tables <classname>R</classname> and <classname>S</classname> (both must have "
"the same arity), the union <classname>R</classname> &cup; <classname>S</"
"classname> is the set of tuples that are in <classname>R</classname> or "
"<classname>S</classname> or both."
msgstr ""
"UNION (&cup;): формирует объединение (в терминах теории множеств) двух "
"таблиц. Для данных таблиц <classname>R</classname> и <classname>S</"
"classname> (обе должны иметь одну арность) объединением <classname>R</"
"classname> &cup; <classname>S</classname> будет множество кортежей, "
"принадлежащих <classname>R</classname> или <classname>S</classname> или "
"обеим таблицам."

#: sql.xml:473(para)
msgid ""
"INTERSECT (&cap;): builds the set-theoretic intersection of two tables. "
"Given the tables <classname>R</classname> and <classname>S</classname>, "
"<classname>R</classname> &cap; <classname>S</classname> is the set of tuples "
"that are in <classname>R</classname> and in <classname>S</classname>. We "
"again require that <classname>R</classname> and <classname>S</classname> "
"have the same arity."
msgstr ""
"INTERSECT (&cap;): формирует пересечение (в терминах теории множеств) двух "
"таблиц. Для данных таблиц <classname>R</classname> и <classname>S</"
"classname>, пересечением <classname>R</classname> &cap; <classname>S</"
"classname> будет множество кортежей, принадлежащих и <classname>R</"
"classname>, и <classname>S</classname>. При этом опять же требуется, чтобы "
"<classname>R</classname> и <classname>S</classname> были одной арности."

#: sql.xml:488(para)
msgid ""
"DIFFERENCE (&minus; or &setmn;): builds the set difference of two tables. "
"Let <classname>R</classname> and <classname>S</classname> again be two "
"tables with the same arity. <classname>R</classname> - <classname>S</"
"classname> is the set of tuples in <classname>R</classname> but not in "
"<classname>S</classname>."
msgstr ""
"DIFFERENCE (&minus; или &setmn;): формирует разность (в терминах теории "
"множеств) двух таблиц. Пусть <classname>R</classname> и <classname>S</"
"classname> так же две таблицы одинаковой арности, тогда <classname>R</"
"classname> — <classname>S</classname> — множество кортежей, принадлежащих "
"<classname>R</classname>, но не <classname>S</classname>."

#: sql.xml:499(para)
msgid ""
"JOIN (&prod;): connects two tables by their common attributes. Let "
"<classname>R</classname> be a table with the attributes <classname>A</"
"classname>,<classname>B</classname> and <classname>C</classname> and let "
"<classname>S</classname> be a table with the attributes <classname>C</"
"classname>,<classname>D</classname> and <classname>E</classname>. There is "
"one attribute common to both relations, the attribute <classname>C</"
"classname>. R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</"
"subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S)). What are we "
"doing here? We first calculate the Cartesian product <classname>R</"
"classname> &times; <classname>S</classname>. Then we select those tuples "
"whose values for the common attribute <classname>C</classname> are equal "
"(&sigma;<subscript>R.C = S.C</subscript>). Now we have a table that contains "
"the attribute <classname>C</classname> two times and we correct this by "
"projecting out the duplicate column."
msgstr ""
"JOIN (&prod;): соединяет две таблицы по их общим атрибутам. Пусть "
"<classname>R</classname> — таблица с атрибутами <classname>A</classname>, "
"<classname>B</classname> и <classname>C</classname>, а <classname>S</"
"classname> — таблица с атрибутами <classname>C</classname>, <classname>D</"
"classname> и <classname>E</classname>. Общим для обоих отношений является "
"только один атрибут, атрибут <classname>C</classname>. Тогда R &prod; S = "
"&pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</"
"subscript>(R &times; S)). Что здесь происходит? Сначала мы вычисляем "
"декартово произведение <classname>R</classname> &times; <classname>S</"
"classname>, а затем выбираем кортежи, в которых значения общего атрибута "
"<classname>C</classname> равны (&sigma;<subscript>R.C = S.C</subscript>). В "
"результате получается таблица, содержащая атрибут <classname>C</classname> "
"два раза, и мы исправляем это, извлекая столбцы без повторения."

#: sql.xml:527(title)
msgid "An Inner Join"
msgstr "Внутреннее соединение"

#: sql.xml:529(para)
msgid ""
"Let's have a look at the tables that are produced by evaluating the steps "
"necessary for a join. Let the following two tables be given: <screen>\n"
"R:                 S:\n"
" A | B | C          C | D | E\n"
"---+---+---        ---+---+---\n"
" 1 | 2 | 3          3 | a | b\n"
" 4 | 5 | 6          6 | c | d\n"
" 7 | 8 | 9\n"
"</screen>"
msgstr ""
"Давайте взглянем на получаемые таблицы, проанализировав этапы соединения. "
"Пусть даны две следующие таблицы: <screen>\n"
"R:                 S:\n"
" A | B | C          C | D | E\n"
"---+---+---        ---+---+---\n"
" 1 | 2 | 3          3 | a | b\n"
" 4 | 5 | 6          6 | c | d\n"
" 7 | 8 | 9\n"
"</screen>"

#: sql.xml:545(para)
msgid ""
"First we calculate the Cartesian product <classname>R</classname> &times; "
"<classname>S</classname> and get: <screen>\n"
"R x S:\n"
" A | B | R.C | S.C | D | E\n"
"---+---+-----+-----+---+---\n"
" 1 | 2 |  3  |  3  | a | b\n"
" 1 | 2 |  3  |  6  | c | d\n"
" 4 | 5 |  6  |  3  | a | b\n"
" 4 | 5 |  6  |  6  | c | d\n"
" 7 | 8 |  9  |  3  | a | b\n"
" 7 | 8 |  9  |  6  | c | d\n"
"</screen>"
msgstr ""
"Сначала вычислим декартово произведение <classname>R</classname> &times; "
"<classname>S</classname> и получим: <screen>\n"
"R x S:\n"
" A | B | R.C | S.C | D | E\n"
"---+---+-----+-----+---+---\n"
" 1 | 2 |  3  |  3  | a | b\n"
" 1 | 2 |  3  |  6  | c | d\n"
" 4 | 5 |  6  |  3  | a | b\n"
" 4 | 5 |  6  |  6  | c | d\n"
" 7 | 8 |  9  |  3  | a | b\n"
" 7 | 8 |  9  |  6  | c | d\n"
"</screen>"

#: sql.xml:563(para)
msgid ""
"After the selection &sigma;<subscript>R.C=S.C</subscript>(R &times; S) we "
"get: <screen>\n"
" A | B | R.C | S.C | D | E\n"
"---+---+-----+-----+---+---\n"
" 1 | 2 |  3  |  3  | a | b\n"
" 4 | 5 |  6  |  6  | c | d\n"
"</screen>"
msgstr ""
"После выборки &sigma;<subscript>R.C=S.C</subscript>(R &times; S) мы "
"получаем: <screen>\n"
" A | B | R.C | S.C | D | E\n"
"---+---+-----+-----+---+---\n"
" 1 | 2 |  3  |  3  | a | b\n"
" 4 | 5 |  6  |  6  | c | d\n"
"</screen>"

#: sql.xml:576(para)
msgid ""
"To remove the duplicate column <classname>S</classname>.<classname>C</"
"classname> we project it out by the following operation: &pi;<subscript>R.A,"
"R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; "
"S)) and get: <screen>\n"
" A | B | C | D | E\n"
"---+---+---+---+---\n"
" 1 | 2 | 3 | a | b\n"
" 4 | 5 | 6 | c | d\n"
"</screen>"
msgstr ""
"Чтобы удалить дублирующийся столбец <classname>S</classname>.<classname>C</"
"classname>, мы проделываем следующую операцию: &pi;<subscript>R.A,R.B,R.C,S."
"D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S)) и "
"получаем: <screen>\n"
" A | B | C | D | E\n"
"---+---+---+---+---\n"
" 1 | 2 | 3 | a | b\n"
" 4 | 5 | 6 | c | d\n"
"</screen>"

#: sql.xml:600(programlisting)
#, no-wrap
msgid "R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S &exist; t<subscript>r</subscript> &isin; R"
msgstr "R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S &exist; t<subscript>r</subscript> &isin; R"

#: sql.xml:593(para)
msgid ""
"DIVIDE (&divide;): Let <classname>R</classname> be a table with the "
"attributes A, B, C, and D and let <classname>S</classname> be a table with "
"the attributes C and D. Then we define the division as: <placeholder-1/> "
"such that t<subscript>r</subscript>(A,B)=t&and;t<subscript>r</subscript>(C,"
"D)=t<subscript>s</subscript>} where t<subscript>r</subscript>(x,y) denotes a "
"tuple of table <classname>R</classname> that consists only of the components "
"<literal>x</literal> and <literal>y</literal>. Note that the tuple "
"<literal>t</literal> only consists of the components <classname>A</"
"classname> and <classname>B</classname> of relation <classname>R</classname>."
msgstr ""
"DIVIDE (&divide;): Пусть <classname>R</classname> — таблица с атрибутами A, "
"B, C и D и пусть <classname>S</classname> — таблица с атрибутами C и D. "
"Тогда мы определим деление как: <placeholder-1/> и <subscript>r</"
"subscript>(A,B)=t&and;t<subscript>r</subscript>(C,D)=t<subscript>s</"
"subscript>} где t<subscript>r</subscript>(x,y) обозначает кортеж таблицы "
"<classname>R</classname>, состоящий только из компонентов <literal>x</"
"literal> и <literal>y</literal>. Заметьте, что кортеж <literal>t</literal> "
"состоит только из компонентов <classname>A</classname> и <classname>B</"
"classname> отношения <classname>R</classname>."

#: sql.xml:616(para)
msgid ""
"Given the following tables <screen>\n"
"R:                    S:\n"
" A | B | C | D         C | D\n"
"---+---+---+---       ---+---\n"
" a | b | c | d         c | d\n"
" a | b | e | f         e | f\n"
" b | c | e | f\n"
" e | d | c | d\n"
" e | d | e | f\n"
" a | b | d | e\n"
"</screen> R &divide; S is derived as <screen>\n"
" A | B\n"
"---+---\n"
" a | b\n"
" e | d\n"
"</screen>"
msgstr ""
"Со следующими таблицами <screen>\n"
"R:                    S:\n"
" A | B | C | D         C | D\n"
"---+---+---+---       ---+---\n"
" a | b | c | d         c | d\n"
" a | b | e | f         e | f\n"
" b | c | e | f\n"
" e | d | c | d\n"
" e | d | e | f\n"
" a | b | d | e\n"
"</screen> R &divide; S даёт <screen>\n"
" A | B\n"
"---+---\n"
" a | b\n"
" e | d\n"
"</screen>"

#: sql.xml:411(para)
msgid ""
"The <firstterm>Relational Algebra</firstterm> was introduced by E. F. Codd "
"in 1972. It consists of a set of operations on relations: <placeholder-1/>"
msgstr ""
"<firstterm>Реляционную алгебру</firstterm> впервые ввёл Эдгар Франк Кодд в "
"1972 г. Она включает набор операций с отношениями: <placeholder-1/>"

#: sql.xml:645(para)
msgid ""
"For a more detailed description and definition of the relational algebra "
"refer to [<xref linkend=\"ull88\" endterm=\"ull88\"/>] or [<xref linkend="
"\"date04\" endterm=\"date04\"/>]."
msgstr ""
"За более подробным описанием и определением реляционной алгебры обратитесь к "
"[<xref linkend=\"ull88\" endterm=\"ull88\"/>] или [<xref linkend=\"date04\" "
"endterm=\"date04\"/>]."

#: sql.xml:652(title)
msgid "A Query Using Relational Algebra"
msgstr "Запросы с применением реляционной алгебры"

#: sql.xml:663(programlisting)
#, no-wrap
msgid "&pi;<subscript>SUPPLIER.SNAME</subscript>(&sigma;<subscript>PART.PNAME='Screw'</subscript>(SUPPLIER &prod; SELLS &prod; PART))"
msgstr "&pi;<subscript>SUPPLIER.SNAME</subscript>(&sigma;<subscript>PART.PNAME='Screw'</subscript>(SUPPLIER &prod; SELLS &prod; PART))"

#: sql.xml:653(para)
msgid ""
"Recall that we formulated all those relational operators to be able to "
"retrieve data from the database. Let's return to our example from the "
"previous section (<xref linkend=\"operations\" endterm=\"operations\"/>) "
"where someone wanted to know the names of all suppliers that sell the part "
"<literal>Screw</literal>. This question can be answered using relational "
"algebra by the following operation: <placeholder-1/>"
msgstr ""
"Вспомните, что мы формулировали все эти реляционные операторы, чтобы иметь "
"возможность извлекать данные из базы данных. Давайте вернёмся к нашему "
"примеру из предыдущего раздела (<xref linkend=\"operations\" endterm="
"\"operations\"/>), когда кто-то захотел узнать имена всех поставщиков "
"шурупов (детали <literal>Screw</literal>). На этот вопрос можно ответить, "
"применяя реляционную алгебру, выполнив следующую операцию: <placeholder-1/>"

#: sql.xml:668(para)
msgid ""
"We call such an operation a query. If we evaluate the above query against "
"the our example tables (<xref linkend=\"supplier-fig\" endterm=\"supplier-fig"
"\"/>) we will obtain the following result: <screen>\n"
" SNAME\n"
"-------\n"
" Smith\n"
" Adams\n"
"</screen>"
msgstr ""
"Мы называем такую операцию запросом. Если мы вычислим предыдущий запрос с "
"таблицами из нашего примера (см. <xref remap=\"4\" linkend=\"supplier-fig\" "
"endterm=\"supplier-fig\"/>), мы получим следующий результат: <screen>\n"
" SNAME\n"
"-------\n"
" Smith\n"
" Adams\n"
"</screen>"

#: sql.xml:685(title)
msgid "Relational Calculus"
msgstr "Реляционное исчисление"

#: sql.xml:694(para)
msgid ""
"The <firstterm>Domain Relational Calculus</firstterm> (<acronym>DRC</"
"acronym>), where variables stand for components (attributes) of the tuples."
msgstr ""
"<firstterm>Реляционное исчисление доменов</firstterm> (Domain Relational "
"Calculus, <acronym>DRC</acronym>), где под переменными понимаются компоненты "
"(атрибуты) кортежей."

#: sql.xml:702(para)
msgid ""
"The <firstterm>Tuple Relational Calculus</firstterm> (<acronym>TRC</"
"acronym>), where variables stand for tuples."
msgstr ""
"<firstterm>Реляционное исчисление кортежей</firstterm> (Tuple Relational "
"Calculus, <acronym>TRC</acronym>), где под переменными понимаются кортежи."

#: sql.xml:687(para)
msgid ""
"The relational calculus is based on the <firstterm>first order logic</"
"firstterm>. There are two variants of the relational calculus: "
"<placeholder-1/>"
msgstr ""
"Реляционное исчисление основано на <firstterm>логике первого порядка</"
"firstterm>. Существует два варианта реляционного исчисления: <placeholder-1/>"

#: sql.xml:710(para)
msgid ""
"We want to discuss the tuple relational calculus only because it is the one "
"underlying the most relational languages. For a detailed discussion on "
"<acronym>DRC</acronym> (and also <acronym>TRC</acronym>) see <xref linkend="
"\"date04\" endterm=\"date04\"/> or <xref linkend=\"ull88\" endterm=\"ull88\"/"
">."
msgstr ""
"Мы хотим обсудить реляционное исчисление кортежей только потому, что на нём "
"основаны многие реляционные языки. Более подробное описание <acronym>DRC</"
"acronym> (а также <acronym>TRC</acronym>) можно найти в <xref remap=\"6\" "
"linkend=\"date04\" endterm=\"date04\"/> или <xref remap=\"6\" linkend="
"\"ull88\" endterm=\"ull88\"/>."

#: sql.xml:722(title)
msgid "Tuple Relational Calculus"
msgstr "Реляционное исчисление кортежей"

#: sql.xml:728(programlisting)
#, no-wrap
msgid "x(A) &mid; F(x)"
msgstr "x(A) &mid; F(x)"

#: sql.xml:724(para)
msgid ""
"The queries used in <acronym>TRC</acronym> are of the following form: "
"<placeholder-1/> where <literal>x</literal> is a tuple variable "
"<classname>A</classname> is a set of attributes and <literal>F</literal> is "
"a formula. The resulting relation consists of all tuples <literal>t(A)</"
"literal> that satisfy <literal>F(t)</literal>."
msgstr ""
"Запросы в <acronym>TRC</acronym> имеют следующий вид: <placeholder-1/> где "
"<literal>x</literal> — переменная кортежа, <classname>A</classname> — "
"множество атрибутов, а <literal>F</literal> — формула. Результирующее "
"отношение состоит из всех кортежей <literal>t(A)</literal>, удовлетворяющих "
"условию <literal>F(t)</literal>."

#: sql.xml:743(programlisting)
#, no-wrap
msgid ""
"{x(SNAME) &mid; x &isin; SUPPLIER &and;\n"
"    &exist; y &isin; SELLS &exist; z &isin; PART (y(SNO)=x(SNO) &and;\n"
"    z(PNO)=y(PNO) &and;\n"
"    z(PNAME)='Screw')}"
msgstr ""
"{x(SNAME) &mid; x &isin; SUPPLIER &and;\n"
"    &exist; y &isin; SELLS &exist; z &isin; PART (y(SNO)=x(SNO) &and;\n"
"    z(PNO)=y(PNO) &and;\n"
"    z(PNAME)='Screw')}"

#: sql.xml:738(para)
msgid ""
"If we want to answer the question from example <xref linkend=\"suppl-rel-alg"
"\" endterm=\"suppl-rel-alg\"/> using <acronym>TRC</acronym> we formulate the "
"following query: <placeholder-1/>"
msgstr ""
"Если мы хотим ответить на вопрос из примера <xref linkend=\"suppl-rel-alg\" "
"endterm=\"suppl-rel-alg\"/>, применяя <acronym>TRC</acronym>, мы можем "
"сформулировать следующий запрос: <placeholder-1/>"

#: sql.xml:751(para)
msgid ""
"Evaluating the query against the tables from <xref linkend=\"supplier-fig\" "
"endterm=\"supplier-fig\"/> again leads to the same result as in <xref "
"linkend=\"suppl-rel-alg\" endterm=\"suppl-rel-alg\"/>."
msgstr ""
"Вычисление этого запроса с таблицами из <xref linkend=\"supplier-fig\" "
"endterm=\"supplier-fig\"/> даёт тот же результат, что и в разделе <xref "
"linkend=\"suppl-rel-alg\" endterm=\"suppl-rel-alg\"/>."

#: sql.xml:761(title)
msgid "Relational Algebra vs. Relational Calculus"
msgstr "Реляционная алгебра и реляционное исчисление"

#: sql.xml:763(para)
msgid ""
"The relational algebra and the relational calculus have the same "
"<firstterm>expressive power</firstterm>; i.e., all queries that can be "
"formulated using relational algebra can also be formulated using the "
"relational calculus and vice versa. This was first proved by E. F. Codd in "
"1972. This proof is based on an algorithm (<quote>Codd's reduction "
"algorithm</quote>) by which an arbitrary expression of the relational "
"calculus can be reduced to a semantically equivalent expression of "
"relational algebra. For a more detailed discussion on that refer to <xref "
"linkend=\"date04\" endterm=\"date04\"/> and <xref linkend=\"ull88\" endterm="
"\"ull88\"/>."
msgstr ""
"Реляционная алгебра и реляционное исчисление имеют одинаковую "
"<firstterm>выразительную мощность</firstterm>; то есть, все запросы, которые "
"можно выразить в реляционной алгебре, можно также выразить в реляционном "
"исчислении, и наоборот. Впервые это доказал Эдгар Франк Кодд в 1972 г. Это "
"доказательство основывалось на алгоритме (<quote>алгоритме редукции Кодда</"
"quote>), по которому произвольное выражение реляционного исчисления можно "
"свести к семантически равнозначному выражению реляционной алгебры. Более "
"подробно это обсуждается в книге <xref linkend=\"date04\" endterm=\"date04\"/"
"> и <xref linkend=\"ull88\" endterm=\"ull88\"/>."

#: sql.xml:778(para)
msgid ""
"It is sometimes said that languages based on the relational calculus are "
"<quote>higher level</quote> or <quote>more declarative</quote> than "
"languages based on relational algebra because the algebra (partially) "
"specifies the order of operations while the calculus leaves it to a compiler "
"or interpreter to determine the most efficient order of evaluation."
msgstr ""
"Иногда говорят, что языки, основанные на реляционном исчислении, более "
"<quote>высокоуровневые</quote> или <quote>более декларативные</quote>, чем "
"языки, основанные на реляционной алгебре, так как в алгебре (частично) "
"задаётся порядок операций, тогда как в исчислении выбор наиболее "
"эффективного порядка вычислений — задача компилятора или интерпретатора."

#: sql.xml:790(title)
msgid "The <acronym>SQL</acronym> Language"
msgstr "Язык <acronym>SQL</acronym>"

#: sql.xml:806(para)
msgid "Commands for insertion, deletion or modification of data."
msgstr "Команды для добавления, удаления или изменения данных"

#: sql.xml:817(programlisting)
#, no-wrap
msgid "A &lt; B + 3."
msgstr "A &lt; B + 3."

#: sql.xml:812(para)
msgid ""
"Arithmetic capability: In <acronym>SQL</acronym> it is possible to involve "
"arithmetic operations as well as comparisons, e.g.: <placeholder-1/> Note "
"that + or other arithmetic operators appear neither in relational algebra "
"nor in relational calculus."
msgstr ""
"Арифметические действия: В <acronym>SQL</acronym> возможно задействовать "
"арифметические операции, а также сравнения: <placeholder-1/> Заметьте, что "
"ни в реляционной алгебре, ни в реляционном исчислении нет операции + и "
"других арифметических операций."

#: sql.xml:828(para)
msgid ""
"Assignment and Print Commands: It is possible to print a relation "
"constructed by a query and to assign a computed relation to a relation name."
msgstr ""
"Команды вывода и присвоения: Отношение, сконструированное запросом, можно "
"вывести, и можно связать вычисленное отношение с именем."

#: sql.xml:836(para)
msgid ""
"Aggregate Functions: Operations such as <firstterm>average</firstterm>, "
"<firstterm>sum</firstterm>, <firstterm>max</firstterm>, etc. can be applied "
"to columns of a relation to obtain a single quantity."
msgstr ""
"Агрегатные функции: Такие операции, как <firstterm>среднее</firstterm>, "
"<firstterm>сумма</firstterm>, <firstterm>максимум</firstterm> и т. п. можно "
"применять к столбцам отношения для получения единственного значения."

#: sql.xml:792(para)
msgid ""
"As is the case with most modern relational languages, <acronym>SQL</acronym> "
"is based on the tuple relational calculus. As a result every query that can "
"be formulated using the tuple relational calculus (or equivalently, "
"relational algebra) can also be formulated using <acronym>SQL</acronym>. "
"There are, however, capabilities beyond the scope of relational algebra or "
"calculus. Here is a list of some additional features provided by "
"<acronym>SQL</acronym> that are not part of relational algebra or calculus: "
"<placeholder-1/>"
msgstr ""
"Как и большинство современных реляционных языков, <acronym>SQL</acronym> "
"основывается на реляционном исчислении кортежей. Вследствие этого, каждый "
"запрос, который можно сформулировать с применением реляционного исчисления "
"кортежей (или, что равнозначно, реляционной алгебры), можно так же "
"сформулировать, используя <acronym>SQL</acronym>. Однако у него есть "
"дополнительные возможности, выходящие за рамки реляционной алгебры или "
"реляционного исчисления. К числу дополнительных возможностей <acronym>SQL</"
"acronym>, отсутствующих в реляционной алгебре и реляционном исчислении, "
"относятся: <placeholder-1/>"

#: sql.xml:848(title)
msgid "Select"
msgstr "Select"

#: sql.xml:850(para)
msgid ""
"The most often used command in <acronym>SQL</acronym> is the "
"<command>SELECT</command> statement, used to retrieve data. The syntax is: "
"<synopsis>\n"
"SELECT [ ALL | DISTINCT [ ON ( <replaceable class=\"parameter\">expression</"
"replaceable> [, ...] ) ] ]\n"
"    * | <replaceable class=\"parameter\">expression</replaceable> [ [ AS ] "
"<replaceable class=\"parameter\">output_name</replaceable> ] [, ...]\n"
"    [ INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable class=\"parameter"
"\">new_table</replaceable> ]\n"
"    [ FROM <replaceable class=\"parameter\">from_item</replaceable> "
"[, ...] ]\n"
"    [ WHERE <replaceable class=\"parameter\">condition</replaceable> ]\n"
"    [ GROUP BY <replaceable class=\"parameter\">expression</replaceable> "
"[, ...] ]\n"
"    [ HAVING <replaceable class=\"parameter\">condition</replaceable> "
"[, ...] ]\n"
"    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class=\"parameter"
"\">select</replaceable> ]\n"
"    [ ORDER BY <replaceable class=\"parameter\">expression</replaceable> "
"[ ASC | DESC | USING <replaceable class=\"parameter\">operator</"
"replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]\n"
"    [ LIMIT { <replaceable class=\"parameter\">count</replaceable> | "
"ALL } ]\n"
"    [ OFFSET <replaceable class=\"parameter\">start</replaceable> ]\n"
"    [ FOR { UPDATE | SHARE } [ OF <replaceable class=\"parameter"
"\">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n"
"</synopsis>"
msgstr ""
"Наиболее часто используемая команда в <acronym>SQL</acronym> — оператор "
"<command>SELECT</command>, осуществляющий выборку данных. Он имеет следующий "
"синтаксис: <synopsis>\n"
"SELECT [ ALL | DISTINCT [ ON ( <replaceable class=\"parameter\">выражение</"
"replaceable> [, ...] ) ] ]\n"
"    * | <replaceable class=\"parameter\">выражение</replaceable> [ [ AS ] "
"<replaceable class=\"parameter\">выходное_имя</replaceable> ] [, ...]\n"
"    [ INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable class=\"parameter"
"\">новая_таблица</replaceable> ]\n"
"    [ FROM <replaceable class=\"parameter\">элемент_FROM</replaceable> "
"[, ...] ]\n"
"    [ WHERE <replaceable class=\"parameter\">условие</replaceable> ]\n"
"    [ GROUP BY <replaceable class=\"parameter\">выражение</replaceable> "
"[, ...] ]\n"
"    [ HAVING <replaceable class=\"parameter\">условие</replaceable> "
"[, ...] ]\n"
"    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class=\"parameter"
"\">выборка</replaceable> ]\n"
"    [ ORDER BY <replaceable class=\"parameter\">выражение</replaceable> "
"[ ASC | DESC | USING <replaceable class=\"parameter\">оператор</"
"replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]\n"
"    [ LIMIT { <replaceable class=\"parameter\">количество</replaceable> | "
"ALL } ]\n"
"    [ OFFSET <replaceable class=\"parameter\">начало</replaceable> ]\n"
"    [ FOR { UPDATE | SHARE } [ OF <replaceable class=\"parameter"
"\">имя_таблицы</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n"
"</synopsis>"

#: sql.xml:871(para)
msgid ""
"Now we will illustrate the complex syntax of the <command>SELECT</command> "
"statement with various examples. The tables used for the examples are "
"defined in <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\"/>."
msgstr ""
"Далее мы проиллюстрируем сложный синтаксис оператора <command>SELECT</"
"command> различными примерами. Таблицы для этих примеров определены в <xref "
"remap=\"6\" linkend=\"supplier-fig\" endterm=\"supplier-fig\"/>."

#: sql.xml:879(title)
msgid "Simple Selects"
msgstr "Простые выборки"

#: sql.xml:885(title)
msgid "Simple Query with Qualification"
msgstr "Простой запрос с условием"

#: sql.xml:890(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM PART\n"
"    WHERE PRICE &gt; 10;"
msgstr ""
"SELECT * FROM PART\n"
"    WHERE PRICE &gt; 10;"

#: sql.xml:886(para)
msgid ""
"To retrieve all tuples from table PART where the attribute PRICE is greater "
"than 10 we formulate the following query: <placeholder-1/> and get the "
"table: <screen>\n"
" PNO |  PNAME  |  PRICE\n"
"-----+---------+--------\n"
"  3  |  Bolt   |   15\n"
"  4  |  Cam    |   25\n"
"</screen>"
msgstr ""
"Чтобы выбрать все кортежи из таблицы PART (детали), у которых атрибут PRICE "
"(цена) больше 10, мы формулируем следующий запрос: <placeholder-1/> и "
"получаем таблицу: <screen>\n"
" PNO |  PNAME  |  PRICE\n"
"-----+---------+--------\n"
"  3  |  Bolt   |   15\n"
"  4  |  Cam    |   25\n"
"</screen>"

#: sql.xml:911(programlisting)
#, no-wrap
msgid ""
"SELECT PNAME, PRICE\n"
"    FROM PART\n"
"    WHERE PRICE &gt; 10;"
msgstr ""
"SELECT PNAME, PRICE\n"
"    FROM PART\n"
"    WHERE PRICE &gt; 10;"

#: sql.xml:905(para)
msgid ""
"Using <quote>*</quote> in the <command>SELECT</command> statement will "
"deliver all attributes from the table. If we want to retrieve only the "
"attributes PNAME and PRICE from table PART we use the statement: "
"<placeholder-1/> In this case the result is: <screen>\n"
"                      PNAME  |  PRICE\n"
"                     --------+--------\n"
"                      Bolt   |   15\n"
"                      Cam    |   25\n"
"</screen> Note that the <acronym>SQL</acronym> <command>SELECT</command> "
"corresponds to the <quote>projection</quote> in relational algebra not to "
"the <quote>selection</quote> (see <xref linkend=\"rel-alg\" endterm=\"rel-alg"
"\"/> for more details)."
msgstr ""
"Используя <quote>*</quote> в операторе <command>SELECT</command>, мы получим "
"все атрибуты из этой таблицы. Если мы хотим выбрать из таблицы PART только "
"атрибуты PNAME and PRICE, воспользуемся таким оператором: <placeholder-1/> В "
"этом случае мы получим такой результат: <screen>\n"
"                      PNAME  |  PRICE\n"
"                     --------+--------\n"
"                      Bolt   |   15\n"
"                      Cam    |   25\n"
"</screen> Заметьте, что <command>SELECT</command> в <acronym>SQL</acronym> "
"соответствует в реляционной алгебре <quote>проекции</quote>, а не "
"<quote>выборке</quote> (за подробностями обратитесь к <xref remap=\"3\" "
"linkend=\"rel-alg\" endterm=\"rel-alg\"/>)."

#: sql.xml:936(programlisting)
#, no-wrap
msgid ""
"SELECT PNAME, PRICE\n"
"    FROM PART\n"
"    WHERE PNAME = 'Bolt' AND\n"
"         (PRICE = 0 OR PRICE &lt;= 15);"
msgstr ""
"SELECT PNAME, PRICE\n"
"    FROM PART\n"
"    WHERE PNAME = 'Bolt' AND\n"
"         (PRICE = 0 OR PRICE &lt;= 15);"

#: sql.xml:932(para)
msgid ""
"The qualifications in the WHERE clause can also be logically connected using "
"the keywords OR, AND, and NOT: <placeholder-1/> will lead to the result: "
"<screen>\n"
" PNAME  |  PRICE\n"
"--------+--------\n"
" Bolt   |   15\n"
"</screen>"
msgstr ""
"Условия в предложении WHERE также могут логически связываться ключевыми "
"словами OR (ИЛИ), AND (И) и NOT (НЕ): <placeholder-1/> даст результат: "
"<screen>\n"
" PNAME  |  PRICE\n"
"--------+--------\n"
" Bolt   |   15\n"
"</screen>"

#: sql.xml:957(programlisting)
#, no-wrap
msgid ""
"SELECT PNAME, PRICE * 2 AS DOUBLE\n"
"    FROM PART\n"
"    WHERE PRICE * 2 &lt; 50;"
msgstr ""
"SELECT PNAME, PRICE * 2 AS DOUBLE\n"
"    FROM PART\n"
"    WHERE PRICE * 2 &lt; 50;"

#: sql.xml:952(para)
msgid ""
"Arithmetic operations can be used in the target list and in the WHERE "
"clause. For example if we want to know how much it would cost if we take two "
"pieces of a part we could use the following query: <placeholder-1/> and we "
"get: <screen>\n"
" PNAME  |  DOUBLE\n"
"--------+---------\n"
" Screw  |    20\n"
" Nut    |    16\n"
" Bolt   |    30\n"
"</screen> Note that the word DOUBLE after the keyword AS is the new title of "
"the second column. This technique can be used for every element of the "
"target list to assign a new title to the resulting column. This new title is "
"often referred to as alias. The alias cannot be used throughout the rest of "
"the query."
msgstr ""
"В целевом списке и в предложении WHERE могут использоваться арифметические "
"операции. Например, если мы хотим узнать, сколько будет стоить пара каждых "
"деталей, воспользуемся следующим запросом: <placeholder-1/> и получим: "
"<screen>\n"
" PNAME  |  DOUBLE\n"
"--------+---------\n"
" Screw  |    20\n"
" Nut    |    16\n"
" Bolt   |    30\n"
"</screen> Заметьте, что слово DOUBLE после ключевого слова AS обозначает "
"новое имя второго столбца. Этот приём можно использовать для каждого "
"элемента целевого списка, чтобы присвоить результирующему столбцу новое имя. "
"Это новое имя часто называется псевдонимом. Использовать этот псевдоним в "
"другой части запроса нельзя."

#: sql.xml:881(para)
msgid ""
"Here are some simple examples using a <command>SELECT</command> statement: "
"<placeholder-1/>"
msgstr ""
"Несколько простых примеров использования оператора <command>SELECT</"
"command>: <placeholder-1/>"

#: sql.xml:985(title)
msgid "Joins"
msgstr "Соединения"

#: sql.xml:987(para)
msgid ""
"The following example shows how <firstterm>joins</firstterm> are realized in "
"<acronym>SQL</acronym>."
msgstr ""
"Следующий пример показывает, как в <acronym>SQL</acronym> реализованы "
"<firstterm>соединения</firstterm>."

#: sql.xml:996(programlisting)
#, no-wrap
msgid ""
"SELECT S.SNAME, P.PNAME\n"
"    FROM SUPPLIER S, PART P, SELLS SE\n"
"    WHERE S.SNO = SE.SNO AND\n"
"          P.PNO = SE.PNO;"
msgstr ""
"SELECT S.SNAME, P.PNAME\n"
"    FROM SUPPLIER S, PART P, SELLS SE\n"
"    WHERE S.SNO = SE.SNO AND\n"
"          P.PNO = SE.PNO;"

#: sql.xml:992(para)
msgid ""
"To join the three tables SUPPLIER, PART and SELLS over their common "
"attributes we formulate the following statement: <placeholder-1/> and get "
"the following table as a result: <screen>\n"
" SNAME | PNAME\n"
"-------+-------\n"
" Smith | Screw\n"
" Smith | Nut\n"
" Jones | Cam\n"
" Adams | Screw\n"
" Adams | Bolt\n"
" Blake | Nut\n"
" Blake | Bolt\n"
" Blake | Cam\n"
"</screen>"
msgstr ""
"Чтобы соединить три таблицы SUPPLIER, PART и SELLS по их общим атрибутам, мы "
"формулируем следующий оператор: <placeholder-1/> и получаем в результате "
"следующую таблицу: <screen>\n"
" SNAME | PNAME\n"
"-------+-------\n"
" Smith | Screw\n"
" Smith | Nut\n"
" Jones | Cam\n"
" Adams | Screw\n"
" Adams | Bolt\n"
" Blake | Nut\n"
" Blake | Bolt\n"
" Blake | Cam\n"
"</screen>"

#: sql.xml:1019(para)
msgid ""
"In the FROM clause we introduced an alias name for every relation because "
"there are common named attributes (SNO and PNO) among the relations. Now we "
"can distinguish between the common named attributes by simply prefixing the "
"attribute name with the alias name followed by a dot. The join is calculated "
"in the same way as shown in <xref linkend=\"join-example\" endterm=\"join-"
"example\"/>. First the Cartesian product SUPPLIER &times; PART &times; SELLS "
"is derived. Now only those tuples satisfying the conditions given in the "
"WHERE clause are selected (i.e., the common named attributes have to be "
"equal). Finally we project out all columns but S.SNAME and P.PNAME."
msgstr ""
"В предложении FROM мы ввели псевдоним для каждого отношения, так как у "
"отношений есть одноимённые атрибуты (SNO и PNO). Теперь мы можем различать "
"общие атрибуты, просто добавляя перед именем атрибута имя псевдонима с "
"точкой. Соединение вычисляется так же, как показано в <xref remap=\"6\" "
"linkend=\"join-example\" endterm=\"join-example\"/>. На первом этапе "
"формируется декартово произведение SUPPLIER &times; PART &times; SELLS. "
"Затем выбираются только те кортежи, которые удовлетворяют условиям, заданным "
"в предложении WHERE (то есть те, у которых указанные общие атрибуты равны). "
"Наконец, мы отбираем все столбцы, кроме S.SNAME и P.PNAME."

#: sql.xml:1038(programlisting)
#, no-wrap
msgid ""
"SELECT sname, pname from supplier\n"
"    JOIN sells USING (sno)\n"
"    JOIN part USING (pno);"
msgstr ""
"SELECT sname, pname from supplier\n"
"    JOIN sells USING (sno)\n"
"    JOIN part USING (pno);"

#: sql.xml:1036(para)
msgid ""
"Another way to perform joins is to use the SQL JOIN syntax as follows: "
"<placeholder-1/> giving again: <screen>\n"
" sname | pname\n"
"-------+-------\n"
" Smith | Screw\n"
" Adams | Screw\n"
" Smith | Nut\n"
" Blake | Nut\n"
" Adams | Bolt\n"
" Blake | Bolt\n"
" Jones | Cam\n"
" Blake | Cam\n"
"(8 rows)\n"
"</screen>"
msgstr ""
"Ещё один способ выполнить соединение — использовать синтаксис SQL JOIN так: "
"<placeholder-1/> Это даёт нам: <screen>\n"
" sname | pname\n"
"-------+-------\n"
" Smith | Screw\n"
" Adams | Screw\n"
" Smith | Nut\n"
" Blake | Nut\n"
" Adams | Bolt\n"
" Blake | Bolt\n"
" Jones | Cam\n"
" Blake | Cam\n"
"(8 rows)\n"
"</screen>"

#: sql.xml:1059(para)
msgid ""
"A joined table, created using JOIN syntax, is a table reference list item "
"that occurs in a FROM clause and before any WHERE, GROUP BY, or HAVING "
"clause. Other table references, including table names or other JOIN clauses, "
"can be included in the FROM clause if separated by commas. JOINed tables are "
"logically like any other table listed in the FROM clause."
msgstr ""
"Соединённая таблица, созданная с использованием синтаксиса JOIN, становится "
"элементом списка ссылок на таблицы, имеющим место внутри предложения FROM и "
"перед предложениями WHERE, GROUP BY или HAVING. В предложение FROM можно "
"включить другие ссылки на таблицы, в том числе по именам, или другие "
"предложения JOIN. Соединённые таблицы логически не отличаются от любых "
"других таблиц, перечисленных в предложении FROM."

#: sql.xml:1068(para)
msgid ""
"SQL JOINs come in two main types, CROSS JOINs (unqualified joins) and "
"<firstterm>qualified JOINs</firstterm>. Qualified joins can be further "
"subdivided based on the way in which the <firstterm>join condition</"
"firstterm> is specified (ON, USING, or NATURAL) and the way in which it is "
"applied (INNER or OUTER join)."
msgstr ""
"Среди соединений SQL можно выделить два основных типа, перекрёстные "
"соединения (соединения без условий, CROSS JOIN) и <firstterm>соединения с "
"условиями</firstterm>. Соединения с условиями можно затем разделить в "
"зависимости от способа указания <firstterm>условия соединения</firstterm> "
"(ON, USING или NATURAL) и способа его применения (внутреннее (INNER) или "
"внешнее (OUTER) соединение)."

#: sql.xml:1077(title)
msgid "Join Types"
msgstr "Типы соединений"

#: sql.xml:1079(term)
msgctxt "term"
msgid "CROSS JOIN"
msgstr "CROSS JOIN"

#: sql.xml:1082(replaceable) sql.xml:1103(replaceable)
msgid "T1"
msgstr "T1"

#: sql.xml:1083(command)
msgctxt "command"
msgid "CROSS JOIN"
msgstr "CROSS JOIN"

#: sql.xml:1084(replaceable) sql.xml:1117(replaceable)
msgid "T2"
msgstr "T2"

#: sql.xml:1087(para)
msgid ""
"A cross join takes two tables T1 and T2 having N and M rows respectively, "
"and returns a joined table containing all N*M possible joined rows. For each "
"row R1 of T1, each row R2 of T2 is joined with R1 to yield a joined table "
"row JR consisting of all fields in R1 and R2. A CROSS JOIN is equivalent to "
"an INNER JOIN ON TRUE."
msgstr ""
"Перекрёстное соединение получает две таблицы T1 и T2, имеющих соответственно "
"N и M строк, и выдаёт соединённую таблицу, содержащую все возможные "
"соединённые строки (N*M). Для каждой строки R1 из T1, каждая строка R2 из T2 "
"соединяется с R1 и в результате выдаётся соединённая строка таблицы JR, "
"состоящая из всех полей в R1 и R2. Соединение CROSS JOIN равнозначно "
"соединению INNER JOIN ON TRUE."

#: sql.xml:1099(term)
msgid "Qualified JOINs"
msgstr "Соединения с условиями"

#: sql.xml:1104(arg)
msgid "NATURAL"
msgstr "NATURAL"

#: sql.xml:1106(arg) sql.xml:1145(arg)
msgid "INNER"
msgstr "INNER"

#: sql.xml:1109(arg) sql.xml:1166(arg)
msgid "LEFT"
msgstr "LEFT"

#: sql.xml:1110(arg) sql.xml:1188(arg)
msgid "RIGHT"
msgstr "RIGHT"

#: sql.xml:1111(arg) sql.xml:1210(arg)
msgid "FULL"
msgstr "FULL"

#: sql.xml:1113(arg) sql.xml:1167(arg) sql.xml:1189(arg) sql.xml:1211(arg)
msgid "OUTER"
msgstr "OUTER"

#: sql.xml:1116(command) sql.xml:1146(command) sql.xml:1168(command)
#: sql.xml:1190(command) sql.xml:1212(command)
msgid "JOIN"
msgstr "JOIN"

#: sql.xml:1119(replaceable)
msgid "search condition"
msgstr "условие поиска"

#: sql.xml:1119(arg)
msgid "ON <placeholder-1/>"
msgstr "ON <placeholder-1/>"

#: sql.xml:1120(replaceable)
msgid "join column list"
msgstr "список столбцов соединения"

#: sql.xml:1120(arg)
msgid "USING ( <placeholder-1/> )"
msgstr "USING ( <placeholder-1/> )"

#: sql.xml:1124(para)
msgid ""
"A qualified JOIN must specify its join condition by providing one (and only "
"one) of NATURAL, ON, or USING. The ON clause takes a <replaceable>search "
"condition</replaceable>, which is the same as in a WHERE clause. The USING "
"clause takes a comma-separated list of column names, which the joined tables "
"must have in common, and joins the tables on equality of those columns. "
"NATURAL is shorthand for a USING clause that lists all the common column "
"names of the two tables. A side-effect of both USING and NATURAL is that "
"only one copy of each joined column is emitted into the result table "
"(compare the relational-algebra definition of JOIN, shown earlier)."
msgstr ""
"В соединении с условием должно задаваться условие соединения в одном (и "
"только одном) предложении NATURAL, ON или USING. Предложение ON принимает "
"<replaceable>условие поиска</replaceable>, которое действует так же, как и в "
"предложении WHERE. Предложение USING принимает список имён столбцов через "
"запятую, которые должны быть общими у соединяемых таблиц, и соединяет "
"таблицы по равенству этих столбцов. Предложение NATURAL является краткой "
"формой USING с перечислением всех общих имён столбцов двух таблиц. Побочный "
"эффект использования и USING, и NATURAL состоит в том, что в результирующую "
"таблицу выдаётся только одна копия каждого соединяемого столбца (сравните "
"это с описанным выше определением JOIN в реляционной алгебре)."

#: sql.xml:1150(para)
msgid ""
"For each row R1 of T1, the joined table has a row for each row in T2 that "
"satisfies the join condition with R1."
msgstr ""
"Для каждой строки R1 из T1 в результирующей таблице содержится строка для "
"каждой строки в T2, удовлетворяющей условию соединения с R1."

#: sql.xml:1155(para)
msgid ""
"The words INNER and OUTER are optional for all JOINs. INNER is the default. "
"LEFT, RIGHT, and FULL imply an OUTER JOIN."
msgstr ""
"Слова INNER и OUTER необязательны для всех форм JOIN. По умолчанию "
"подразумевается INNER (внутреннее соединение), а при указании LEFT, RIGHT и "
"FULL — OUTER (внешнее соединение)."

#: sql.xml:1172(para)
msgid ""
"First, an INNER JOIN is performed. Then, for each row in T1 that does not "
"satisfy the join condition with any row in T2, an additional joined row is "
"returned with null fields in the columns from T2."
msgstr ""
"Сначала выполняется внутреннее соединение (INNER JOIN). Затем для каждой "
"строки в T1, не удовлетворяющей условию соединения ни с какой строкой в T2, "
"возвращается дополнительная строка со значениями NULL в столбцах из T2."

#: sql.xml:1179(para)
msgid "The joined table unconditionally has a row for each row in T1."
msgstr ""
"В соединённой таблице всегда оказывается строка для каждой строки в T1."

#: sql.xml:1194(para)
msgid ""
"First, an INNER JOIN is performed. Then, for each row in T2 that does not "
"satisfy the join condition with any row in T1, an additional joined row is "
"returned with null fields in the columns from T1."
msgstr ""
"Сначала выполняется внутреннее соединение (INNER JOIN). Затем для каждой "
"строки в T2, не удовлетворяющей условию соединения ни с какой строкой в T1, "
"возвращается дополнительная строка со значениями NULL в столбцах из T1."

#: sql.xml:1201(para)
msgid "The joined table unconditionally has a row for each row in T2."
msgstr ""
"В соединённой таблице всегда оказывается строка для каждой строки в T2."

#: sql.xml:1216(para)
msgid ""
"First, an INNER JOIN is performed. Then, for each row in T1 that does not "
"satisfy the join condition with any row in T2, an additional joined row is "
"returned with null fields in the columns from T2. Also, for each row in T2 "
"that does not satisfy the join condition with any row in T1, an additional "
"joined row is returned with null fields in the columns from T1."
msgstr ""
"Сначала выполняется внутреннее соединение (INNER JOIN). Затем для каждой "
"строки в T1, не удовлетворяющей условию соединения ни с какой строкой в T2, "
"возвращается дополнительная строка со значениями NULL в столбцах из T2. А "
"также для каждой строки в T2, не удовлетворяющей условию соединения ни с "
"какой строкой в T1, возвращается дополнительная строка со значениями NULL в "
"столбцах из T1."

#: sql.xml:1226(para)
msgid ""
"The joined table unconditionally has a row for every row of T1 and a row for "
"every row of T2."
msgstr ""
"В соединённой таблице всегда оказывается строка для каждой строки в T1 и для "
"каждой строки в T2."

#: sql.xml:1240(para)
msgid ""
"JOINs of all types can be chained together or nested where either or both of "
"<replaceable class=\"parameter\">T1</replaceable> and <replaceable class="
"\"parameter\">T2</replaceable> can be JOINed tables. Parenthesis can be used "
"around JOIN clauses to control the order of JOINs which are otherwise "
"processed left to right."
msgstr ""
"Соединения всех типов можно связывать вместе или вкладывать одно в другое, "
"так что и <replaceable class=\"parameter\">T1</replaceable>, и <replaceable "
"class=\"parameter\">T2</replaceable> могут быть соединёнными таблицами. "
"Предложения JOIN могут быть заключены в скобки для установления нужного "
"порядка соединений (без них действует порядок справа налево)."

#: sql.xml:1251(title)
msgid "Aggregate Functions"
msgstr "Агрегатные функции"

#: sql.xml:1265(title) sql.xml:1334(title)
msgid "Aggregates"
msgstr "Агрегатные функции"

#: sql.xml:1271(programlisting)
#, no-wrap
msgid ""
"SELECT AVG(PRICE) AS AVG_PRICE\n"
"    FROM PART;"
msgstr ""
"SELECT AVG(PRICE) AS AVG_PRICE\n"
"    FROM PART;"

#: sql.xml:1267(para)
msgid ""
"If we want to know the average cost of all parts in table PART we use the "
"following query: <placeholder-1/>"
msgstr ""
"Если мы хотим узнать среднюю стоимость всех деталей в таблице PART, "
"воспользуемся следующим запросом: <placeholder-1/>"

#: sql.xml:1277(para)
msgid ""
"The result is: <screen>\n"
" AVG_PRICE\n"
"-----------\n"
"   14.5\n"
"</screen>"
msgstr ""
"Результат: <screen>\n"
" AVG_PRICE\n"
"-----------\n"
"   14.5\n"
"</screen>"

#: sql.xml:1291(programlisting)
#, no-wrap
msgid ""
"SELECT COUNT(PNO)\n"
"    FROM PART;"
msgstr ""
"SELECT COUNT(PNO)\n"
"    FROM PART;"

#: sql.xml:1287(para)
msgid ""
"If we want to know how many parts are defined in table PART we use the "
"statement: <placeholder-1/> and get: <screen>\n"
" COUNT\n"
"-------\n"
"   4\n"
"</screen>"
msgstr ""
"Если мы хотим узнать, сколько деталей учтено в таблице PART, воспользуемся "
"этим оператором: <placeholder-1/> и получим: <screen>\n"
" COUNT\n"
"-------\n"
"   4\n"
"</screen>"

#: sql.xml:1253(para)
msgid ""
"<acronym>SQL</acronym> provides aggregate functions such as AVG, COUNT, SUM, "
"MIN, and MAX. The argument(s) of an aggregate function are evaluated at each "
"row that satisfies the WHERE clause, and the aggregate function is "
"calculated over this set of input values. Normally, an aggregate delivers a "
"single result for a whole <command>SELECT</command> statement. But if "
"grouping is specified in the query, then a separate calculation is done over "
"the rows of each group, and an aggregate result is delivered per group (see "
"next section). <placeholder-1/>"
msgstr ""
"В <acronym>SQL</acronym> имеются агрегатные функции, такие как AVG, COUNT, "
"SUM, MIN и MAX. Агрегатная функция вычисляется по набору входных значений, "
"получаемых для каждой строки, удовлетворяющей предложению WHERE. Обычно "
"агрегатная функция выдаёт единственный результат для всего оператора "
"<command>SELECT</command>. Но если в запросе устанавливается группировка, по "
"строкам в каждой группе выполняется отдельное вычисление и агрегатные "
"результаты выдаются для каждой группы (см. следующий раздел). <placeholder-1/"
">"

#: sql.xml:1310(title)
msgid "Aggregation by Groups"
msgstr "Агрегирование по группам"

#: sql.xml:1312(para)
msgid ""
"<acronym>SQL</acronym> allows one to partition the tuples of a table into "
"groups. Then the aggregate functions described above can be applied to the "
"groups &mdash; i.e., the value of the aggregate function is no longer "
"calculated over all the values of the specified column but over all values "
"of a group. Thus the aggregate function is evaluated separately for every "
"group."
msgstr ""
"<acronym>SQL</acronym> позволяет разбивать кортежи таблицы на группы. Затем "
"к группам можно применить описанные выше агрегатные функции &mdash; т. е. "
"значение агрегатной функции будет вычисляться не по всем значениям "
"определённого столбца, а по всем значениям группы. Таким образом, агрегатная "
"функция вычисляется отдельно для каждой группы."

#: sql.xml:1339(programlisting)
#, no-wrap
msgid ""
"SELECT S.SNO, S.SNAME, COUNT(SE.PNO)\n"
"    FROM SUPPLIER S, SELLS SE\n"
"    WHERE S.SNO = SE.SNO\n"
"    GROUP BY S.SNO, S.SNAME;"
msgstr ""
"SELECT S.SNO, S.SNAME, COUNT(SE.PNO)\n"
"    FROM SUPPLIER S, SELLS SE\n"
"    WHERE S.SNO = SE.SNO\n"
"    GROUP BY S.SNO, S.SNAME;"

#: sql.xml:1335(para)
msgid ""
"If we want to know how many parts are sold by every supplier we formulate "
"the query: <placeholder-1/> and get: <screen>\n"
" SNO | SNAME | COUNT\n"
"-----+-------+-------\n"
"  1  | Smith |   2\n"
"  2  | Jones |   1\n"
"  3  | Adams |   2\n"
"  4  | Blake |   3\n"
"</screen>"
msgstr ""
"Если мы хотим узнать, сколько деталей было продано каждым поставщиком, мы "
"формулируем запрос: <placeholder-1/> и получаем: <screen>\n"
" SNO | SNAME | COUNT\n"
"-----+-------+-------\n"
"  1  | Smith |   2\n"
"  2  | Jones |   1\n"
"  3  | Adams |   2\n"
"  4  | Blake |   3\n"
"</screen>"

#: sql.xml:1358(para)
msgid ""
"Now let's have a look of what is happening here. First the join of the "
"tables SUPPLIER and SELLS is derived: <screen>\n"
" S.SNO | S.SNAME | SE.PNO\n"
"-------+---------+--------\n"
"   1   |  Smith  |   1\n"
"   1   |  Smith  |   2\n"
"   2   |  Jones  |   4\n"
"   3   |  Adams  |   1\n"
"   3   |  Adams  |   3\n"
"   4   |  Blake  |   2\n"
"   4   |  Blake  |   3\n"
"   4   |  Blake  |   4\n"
"</screen>"
msgstr ""
"Теперь давайте посмотрим, что здесь происходит. Сначала образуется "
"соединение таблиц SUPPLIER и SELLS: <screen>\n"
" S.SNO | S.SNAME | SE.PNO\n"
"-------+---------+--------\n"
"   1   |  Smith  |   1\n"
"   1   |  Smith  |   2\n"
"   2   |  Jones  |   4\n"
"   3   |  Adams  |   1\n"
"   3   |  Adams  |   3\n"
"   4   |  Blake  |   2\n"
"   4   |  Blake  |   3\n"
"   4   |  Blake  |   4\n"
"</screen>"

#: sql.xml:1377(para)
msgid ""
"Next we partition the tuples into groups by putting all tuples together that "
"agree on both attributes S.SNO and S.SNAME: <screen>\n"
" S.SNO | S.SNAME | SE.PNO\n"
"-------+---------+--------\n"
"   1   |  Smith  |   1\n"
"                 |   2\n"
"--------------------------\n"
"   2   |  Jones  |   4\n"
"--------------------------\n"
"   3   |  Adams  |   1\n"
"                 |   3\n"
"--------------------------\n"
"   4   |  Blake  |   2\n"
"                 |   3\n"
"                 |   4\n"
"</screen>"
msgstr ""
"Затем мы разбиваем кортежи на группы, собирая вместе все кортежи, имеющие "
"общие атрибуты S.SNO и S.SNAME: <screen>\n"
" S.SNO | S.SNAME | SE.PNO\n"
"-------+---------+--------\n"
"   1   |  Smith  |   1\n"
"                 |   2\n"
"--------------------------\n"
"   2   |  Jones  |   4\n"
"--------------------------\n"
"   3   |  Adams  |   1\n"
"                 |   3\n"
"--------------------------\n"
"   4   |  Blake  |   2\n"
"                 |   3\n"
"                 |   4\n"
"</screen>"

#: sql.xml:1398(para)
msgid ""
"In our example we got four groups and now we can apply the aggregate "
"function COUNT to every group leading to the final result of the query given "
"above."
msgstr ""
"В данном примере мы получаем четыре группы и теперь можем применить "
"агрегатную функцию COUNT к каждой группе, чтобы в результате получить "
"окончательный результат данного выше запроса."

#: sql.xml:1322(para)
msgid ""
"The partitioning of the tuples into groups is done by using the keywords "
"<command>GROUP BY</command> followed by a list of attributes that define the "
"groups. If we have <command>GROUP BY A<subscript>1</subscript>, &tdot;, "
"A<subscript>k</subscript></command> we partition the relation into groups, "
"such that two tuples are in the same group if and only if they agree on all "
"the attributes A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript>. "
"<placeholder-1/>"
msgstr ""
"Разбиение кортежей на группы осуществляется ключевым словом <command>GROUP "
"BY</command>, за которым следует список атрибутов, определяющих группы. "
"Написав <command>GROUP BY A<subscript>1</subscript>, &tdot;, A<subscript>k</"
"subscript></command>, мы разделяем отношение на группы так, что два кортежа "
"оказываются в одной группе, если и только если они имеют одинаковые значения "
"всех атрибутов A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript>. "
"<placeholder-1/>"

#: sql.xml:1406(para)
msgid ""
"Note that for a query using GROUP BY and aggregate functions to make sense, "
"the target list can only refer directly to the attributes being grouped by. "
"Other attributes can only be used inside the arguments of aggregate "
"functions. Otherwise there would not be a unique value to associate with the "
"other attributes."
msgstr ""
"Заметьте, чтобы применение GROUP BY и агрегатных функций в запросе имело "
"смысл, в целевом списке должны указываться только непосредственно "
"группируемые атрибуты. Другие атрибуты можно использовать только в "
"аргументах агрегатных функций. В противном случае не будут получены "
"уникальные значения, которые нужно связывать с другими атрибутами."

#: sql.xml:1414(para)
msgid ""
"Also observe that it makes no sense to ask for an aggregate of an aggregate, "
"e.g., AVG(MAX(sno)), because a <command>SELECT</command> only does one pass "
"of grouping and aggregation. You can get a result of this kind by using a "
"temporary table or a sub-SELECT in the FROM clause to do the first level of "
"aggregation."
msgstr ""
"Также заметьте, что не имеет смысла применять агрегатную функцию к "
"агрегатной функции, например, AVG(MAX(sno)), так как <command>SELECT</"
"command> делает только один проход для группирования и агрегирования. "
"Получить подобный результат можно, осуществив первый уровень агрегирования с "
"использованием временной таблицы или вложенного SELECT в предложении FROM."

#: sql.xml:1425(title) sql.xml:1440(title)
msgid "Having"
msgstr "Having"

#: sql.xml:1446(programlisting)
#, no-wrap
msgid ""
"SELECT S.SNO, S.SNAME, COUNT(SE.PNO)\n"
"    FROM SUPPLIER S, SELLS SE\n"
"    WHERE S.SNO = SE.SNO\n"
"    GROUP BY S.SNO, S.SNAME\n"
"    HAVING COUNT(SE.PNO) &gt; 1;"
msgstr ""
"SELECT S.SNO, S.SNAME, COUNT(SE.PNO)\n"
"    FROM SUPPLIER S, SELLS SE\n"
"    WHERE S.SNO = SE.SNO\n"
"    GROUP BY S.SNO, S.SNAME\n"
"    HAVING COUNT(SE.PNO) &gt; 1;"

#: sql.xml:1442(para)
msgid ""
"If we want only those suppliers selling more than one part we use the query: "
"<placeholder-1/> and get: <screen>\n"
" SNO | SNAME | COUNT\n"
"-----+-------+-------\n"
"  1  | Smith |   2\n"
"  3  | Adams |   2\n"
"  4  | Blake |   3\n"
"</screen>"
msgstr ""
"Если мы хотим получить только поставщиков, продающих больше одного вида "
"деталей, воспользуемся запросом: <placeholder-1/> и получим: <screen>\n"
" SNO | SNAME | COUNT\n"
"-----+-------+-------\n"
"  1  | Smith |   2\n"
"  3  | Adams |   2\n"
"  4  | Blake |   3\n"
"</screen>"

#: sql.xml:1427(para)
msgid ""
"The HAVING clause works much like the WHERE clause and is used to consider "
"only those groups satisfying the qualification given in the HAVING clause. "
"Essentially, WHERE filters out unwanted input rows before grouping and "
"aggregation are done, whereas HAVING filters out unwanted group rows post-"
"GROUP. Therefore, WHERE cannot refer to the results of aggregate functions. "
"On the other hand, there's no point in writing a HAVING condition that "
"doesn't involve an aggregate function! If your condition doesn't involve "
"aggregates, you might as well write it in WHERE, and thereby avoid the "
"computation of aggregates for groups that you're just going to throw away "
"anyway. <placeholder-1/>"
msgstr ""
"Предложение HAVING действует во многом как предложение WHERE и применяется "
"для рассмотрения только тех групп, которые удовлетворяют заданным в этом "
"предложении условиям. По сути, предложение WHERE отфильтровывает ненужные "
"входные строки до группирования и агрегирования, тогда как HAVING "
"отфильтровывает ненужные группы после группирования. Таким образом, WHERE не "
"может обращаться к результатам агрегатной функции. С другой стороны, нет "
"смысла в условии HAVING, которое не включает агрегатную функцию. Если в "
"вашем условии не задействованы агрегатные функции, вы можете также написать "
"его и в WHERE и тем самым избежать вычисления агрегатных функций для групп, "
"которые вы всё равно собираетесь исключать. <placeholder-1/>"

#: sql.xml:1469(title)
msgid "Subqueries"
msgstr "Подзапросы"

#: sql.xml:1479(title)
msgid "Subselect"
msgstr "Вложенная выборка"

#: sql.xml:1485(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM PART\n"
"    WHERE PRICE &gt; (SELECT PRICE FROM PART\n"
"                   WHERE PNAME='Screw');"
msgstr ""
"SELECT *\n"
"    FROM PART\n"
"    WHERE PRICE &gt; (SELECT PRICE FROM PART\n"
"                   WHERE PNAME='Screw');"

#: sql.xml:1481(para)
msgid ""
"If we want to know all parts having a greater price than the part named "
"'Screw' we use the query: <placeholder-1/>"
msgstr ""
"Если мы хотим узнать, какие детали стоят дороже, чем деталь 'Screw', "
"воспользуемся запросом: <placeholder-1/>"

#: sql.xml:1493(para)
msgid ""
"The result is: <screen>\n"
" PNO |  PNAME  |  PRICE\n"
"-----+---------+--------\n"
"  3  |  Bolt   |   15\n"
"  4  |  Cam    |   25\n"
"</screen>"
msgstr ""
"Результат: <screen>\n"
" PNO |  PNAME  |  PRICE\n"
"-----+---------+--------\n"
"  3  |  Bolt   |   15\n"
"  4  |  Cam    |   25\n"
"</screen>"

#: sql.xml:1504(para)
msgid ""
"When we look at the above query we can see the keyword <command>SELECT</"
"command> two times. The first one at the beginning of the query - we will "
"refer to it as outer <command>SELECT</command> - and the one in the WHERE "
"clause which begins a nested query - we will refer to it as inner "
"<command>SELECT</command>. For every tuple of the outer <command>SELECT</"
"command> the inner <command>SELECT</command> has to be evaluated. After "
"every evaluation we know the price of the tuple named 'Screw' and we can "
"check if the price of the actual tuple is greater. (Actually, in this "
"example the inner query need only be evaluated once, since it does not "
"depend on the state of the outer query.)"
msgstr ""
"Взглянув на приведённый выше запрос, вы можете увидеть ключевое слово "
"<command>SELECT</command>, написанное два раза. Первое, в начале запроса, мы "
"будем называть внешним <command>SELECT</command>, а второе, внутри "
"предложения WHERE, начинающее вложенный запрос, — внутренним "
"<command>SELECT</command>. Внутренний <command>SELECT</command> должен "
"вычисляться для каждого кортежа внешнего <command>SELECT</command>. После "
"каждого вычисления внутреннего запроса мы знаем цену шурупа (детали 'Screw') "
"и можем проверить, больше ли цена детали в текущем кортеже. (На самом деле в "
"этом примере внутренний запрос нужно было вычислить только один раз, так как "
"он не зависит от состояния внешнего запроса.)"

#: sql.xml:1523(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM SUPPLIER S\n"
"    WHERE NOT EXISTS\n"
"        (SELECT * FROM SELLS SE\n"
"         WHERE SE.SNO = S.SNO);"
msgstr ""
"SELECT *\n"
"    FROM SUPPLIER S\n"
"    WHERE NOT EXISTS\n"
"        (SELECT * FROM SELLS SE\n"
"         WHERE SE.SNO = S.SNO);"

#: sql.xml:1519(para)
msgid ""
"If we want to know all suppliers that do not sell any part (e.g., to be able "
"to remove these suppliers from the database) we use: <placeholder-1/>"
msgstr ""
"Если мы хотим узнать, какие поставщики не продают никакие детали (например, "
"чтобы этих поставщиков можно было удалить из базы данных), выполним: "
"<placeholder-1/>"

#: sql.xml:1532(para)
msgid ""
"In our example the result will be empty because every supplier sells at "
"least one part. Note that we use S.SNO from the outer <command>SELECT</"
"command> within the WHERE clause of the inner <command>SELECT</command>. "
"Here the subquery must be evaluated afresh for each tuple from the outer "
"query, i.e., the value for S.SNO is always taken from the current tuple of "
"the outer <command>SELECT</command>."
msgstr ""
"В нашем примере результат будет пустым, так как каждый поставщик продаёт "
"минимум один вид деталей. Заметьте, что мы использовали S.SNO из внешнего "
"<command>SELECT</command> в предложении WHERE внутреннего <command>SELECT</"
"command>. В данном случае подзапрос должен вычисляться заново для каждого "
"кортежа из внешнего запроса, то есть значение S.SNO всегда берётся из "
"текущего кортежа внешнего <command>SELECT</command>."

#: sql.xml:1471(para)
msgid ""
"In the WHERE and HAVING clauses the use of subqueries (subselects) is "
"allowed in every place where a value is expected. In this case the value "
"must be derived by evaluating the subquery first. The usage of subqueries "
"extends the expressive power of <acronym>SQL</acronym>. <placeholder-1/>"
msgstr ""
"Подзапросы (вложенные SELECT) можно использовать в предложениях WHERE и "
"HAVING везде, где ожидается значение. В этом случае сначала должно быть "
"получено значение в результате вычисления подзапроса. Использование "
"подзапросов увеличивает выразительную мощность <acronym>SQL</acronym>. "
"<placeholder-1/>"

#: sql.xml:1546(title)
msgid "Subqueries in FROM"
msgstr "Подзапросы во FROM"

#: sql.xml:1557(title)
msgid "Subselect in FROM"
msgstr "Вложенная выборка во FROM"

#: sql.xml:1563(programlisting)
#, no-wrap
msgid ""
"SELECT MAX(subtable.avgprice)\n"
"    FROM (SELECT AVG(P.PRICE) AS avgprice\n"
"          FROM SUPPLIER S, PART P, SELLS SE\n"
"          WHERE S.SNO = SE.SNO AND\n"
"                P.PNO = SE.PNO\n"
"          GROUP BY S.SNO) subtable;"
msgstr ""
"SELECT MAX(subtable.avgprice)\n"
"    FROM (SELECT AVG(P.PRICE) AS avgprice\n"
"          FROM SUPPLIER S, PART P, SELLS SE\n"
"          WHERE S.SNO = SE.SNO AND\n"
"                P.PNO = SE.PNO\n"
"          GROUP BY S.SNO) subtable;"

#: sql.xml:1559(para)
msgid ""
"If we want to know the highest average part price among all our suppliers, "
"we cannot write MAX(AVG(PRICE)), but we can write: <placeholder-1/> The "
"subquery returns one row per supplier (because of its GROUP BY) and then we "
"aggregate over those rows in the outer query."
msgstr ""
"Если мы хотим узнать наибольшую среднюю цену деталей по всем поставщикам, мы "
"не можем написать MAX(AVG(PRICE)), но можем написать: <placeholder-1/> Этот "
"подзапрос возвращает одну строку для каждого поставщика (из-за GROUP BY), а "
"затем мы агрегируем эти строки во внешнем запросе."

#: sql.xml:1548(para)
msgid ""
"A somewhat different way of using subqueries is to put them in the FROM "
"clause. This is a useful feature because a subquery of this kind can output "
"multiple columns and rows, whereas a subquery used in an expression must "
"deliver just a single result. It also lets us get more than one round of "
"grouping/aggregation without resorting to a temporary table. <placeholder-1/>"
msgstr ""
"Подзапросы можно использовать и несколько по-другому, поместив их в "
"предложение FROM. Это полезная возможность, так как подзапрос такого рода "
"может выдавать несколько столбцов и строк, тогда как подзапрос в выражении "
"должен сводиться всего к одному результату. Это также позволяет нам "
"произвести несколько проходов группировки/агрегирования, не прибегая к "
"использованию временных таблиц. <placeholder-1/>"

#: sql.xml:1580(title) sql.xml:1587(title)
msgid "Union, Intersect, Except"
msgstr "Объединение, пересечение, разность"

#: sql.xml:1592(programlisting)
#, no-wrap
msgid ""
"SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNAME = 'Jones'\n"
"UNION\n"
"    SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNAME = 'Adams';"
msgstr ""
"SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNAME = 'Jones'\n"
"UNION\n"
"    SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNAME = 'Adams';"

#: sql.xml:1589(para)
msgid ""
"The following query is an example for UNION: <placeholder-1/> gives the "
"result: <screen>\n"
" SNO | SNAME |  CITY\n"
"-----+-------+--------\n"
"  2  | Jones | Paris\n"
"  3  | Adams | Vienna\n"
"</screen>"
msgstr ""
"Следующий запрос демонстрирует объединение (UNION): <placeholder-1/> и "
"выдаёт результат: <screen>\n"
" SNO | SNAME |  CITY\n"
"-----+-------+--------\n"
"  2  | Jones | Paris\n"
"  3  | Adams | Vienna\n"
"</screen>"

#: sql.xml:1615(programlisting)
#, no-wrap
msgid ""
"SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &gt; 1\n"
"INTERSECT\n"
"    SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &lt; 3;"
msgstr ""
"SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &gt; 1\n"
"INTERSECT\n"
"    SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &lt; 3;"

#: sql.xml:1612(para)
msgid ""
"Here is an example for INTERSECT: <placeholder-1/> gives the result: "
"<screen>\n"
" SNO | SNAME |  CITY\n"
"-----+-------+--------\n"
"  2  | Jones | Paris\n"
"</screen> The only tuple returned by both parts of the query is the one "
"having SNO=2."
msgstr ""
"Пример для INTERSECT: <placeholder-1/> даёт следующий результат: <screen>\n"
" SNO | SNAME |  CITY\n"
"-----+-------+--------\n"
"  2  | Jones | Paris\n"
"</screen> Единственным кортежем, возвращаемым двумя частями запроса, "
"является кортеж с SNO=2."

#: sql.xml:1639(programlisting)
#, no-wrap
msgid ""
"SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &gt; 1\n"
"EXCEPT\n"
"    SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &gt; 3;"
msgstr ""
"SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &gt; 1\n"
"EXCEPT\n"
"    SELECT S.SNO, S.SNAME, S.CITY\n"
"    FROM SUPPLIER S\n"
"    WHERE S.SNO &gt; 3;"

#: sql.xml:1636(para)
msgid ""
"Finally an example for EXCEPT: <placeholder-1/> gives the result: <screen>\n"
" SNO | SNAME |  CITY\n"
"-----+-------+--------\n"
"  2  | Jones | Paris\n"
"  3  | Adams | Vienna\n"
"</screen>"
msgstr ""
"И наконец, пример для EXCEPT: <placeholder-1/> даёт такой результат: "
"<screen>\n"
" SNO | SNAME |  CITY\n"
"-----+-------+--------\n"
"  2  | Jones | Paris\n"
"  3  | Adams | Vienna\n"
"</screen>"

#: sql.xml:1582(para)
msgid ""
"These operations calculate the union, intersection and set theoretic "
"difference of the tuples derived by two subqueries. <placeholder-1/>"
msgstr ""
"Эти операции вычисляют объединение, пересечение и разность (как она "
"понимается в теории множеств) для кортежей, полученных из двух подзапросов. "
"<placeholder-1/>"

#: sql.xml:1664(title)
msgid "Data Definition"
msgstr "Определение данных"

#: sql.xml:1666(para)
msgid ""
"There is a set of commands used for data definition included in the "
"<acronym>SQL</acronym> language."
msgstr ""
"Язык <acronym>SQL</acronym> включает набор команд для определения данных."

#: sql.xml:1672(title)
msgid "Create Table"
msgstr "Create Table"

#: sql.xml:1687(title)
msgid "Table Creation"
msgstr "Создание таблицы"

#: sql.xml:1694(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE SUPPLIER\n"
"    (SNO   INTEGER,\n"
"     SNAME VARCHAR(20),\n"
"     CITY  VARCHAR(20));"
msgstr ""
"CREATE TABLE SUPPLIER\n"
"    (SNO   INTEGER,\n"
"     SNAME VARCHAR(20),\n"
"     CITY  VARCHAR(20));"

#: sql.xml:1701(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE PART\n"
"    (PNO   INTEGER,\n"
"     PNAME VARCHAR(20),\n"
"     PRICE DECIMAL(4 , 2));"
msgstr ""
"CREATE TABLE PART\n"
"    (PNO   INTEGER,\n"
"     PNAME VARCHAR(20),\n"
"     PRICE DECIMAL(4 , 2));"

#: sql.xml:1708(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE SELLS\n"
"    (SNO INTEGER,\n"
"     PNO INTEGER);"
msgstr ""
"CREATE TABLE SELLS\n"
"    (SNO INTEGER,\n"
"     PNO INTEGER);"

#: sql.xml:1689(para)
msgid ""
"To create the tables defined in <xref linkend=\"supplier-fig\" endterm="
"\"supplier-fig\"/> the following <acronym>SQL</acronym> statements are used: "
"<placeholder-1/> <placeholder-2/> <placeholder-3/>"
msgstr ""
"Следующие операторы <acronym>SQL</acronym> создают таблицы, описанные в "
"<xref linkend=\"supplier-fig\" endterm=\"supplier-fig\"/>: <placeholder-1/> "
"<placeholder-2/> <placeholder-3/>"

#: sql.xml:1674(para)
msgid ""
"The most fundamental command for data definition is the one that creates a "
"new relation (a new table). The syntax of the <command>CREATE TABLE</"
"command> command is: <synopsis>\n"
"CREATE TABLE <replaceable class=\"parameter\">table_name</replaceable>\n"
"    (<replaceable class=\"parameter\">name_of_attr_1</replaceable> "
"<replaceable class=\"parameter\">type_of_attr_1</replaceable>\n"
"     [, <replaceable class=\"parameter\">name_of_attr_2</replaceable> "
"<replaceable class=\"parameter\">type_of_attr_2</replaceable>\n"
"     [, ...]]);\n"
"</synopsis> <placeholder-1/>"
msgstr ""
"Самой фундаментальной командой определения данных является команда, "
"создающая новое отношение (новую таблицу). Команда <command>CREATE TABLE</"
"command> имеет следующий синтаксис: <synopsis>\n"
"CREATE TABLE <replaceable class=\"parameter\">имя_таблицы</replaceable>\n"
"    (<replaceable class=\"parameter\">имя_атрибута_1</replaceable> "
"<replaceable class=\"parameter\">тип_атрибута_1</replaceable>\n"
"     [, <replaceable class=\"parameter\">имя_атрибута_2</replaceable> "
"<replaceable class=\"parameter\">тип_атрибута_2</replaceable>\n"
"     [, ...]]);\n"
"</synopsis> <placeholder-1/>"

#: sql.xml:1719(title)
msgid "Data Types in <acronym>SQL</acronym>"
msgstr "Типы данных в <acronym>SQL</acronym>"

#: sql.xml:1727(para)
msgid "INTEGER: signed fullword binary integer (31 bits precision)."
msgstr ""
"INTEGER: знаковое двоичное целое, занимающее полное слово (точность 31 бит)."

#: sql.xml:1733(para)
msgid "SMALLINT: signed halfword binary integer (15 bits precision)."
msgstr ""
"SMALLINT: знаковое двоичное целое, занимающее полслова (точность 15 бит)."

#: sql.xml:1739(para)
msgid ""
"DECIMAL (<replaceable class=\"parameter\">p</replaceable>[,<replaceable "
"class=\"parameter\">q</replaceable>]): signed packed decimal number of up to "
"<replaceable class=\"parameter\">p</replaceable> digits, with <replaceable "
"class=\"parameter\">q</replaceable> digits to the right of the decimal "
"point. If <replaceable class=\"parameter\">q</replaceable> is omitted it is "
"assumed to be 0."
msgstr ""
"DECIMAL (<replaceable class=\"parameter\">p</replaceable>[,<replaceable "
"class=\"parameter\">q</replaceable>]): знаковое упакованное десятичное "
"число, содержащее до <replaceable class=\"parameter\">p</replaceable> цифр и "
"<replaceable class=\"parameter\">q</replaceable> цифр справа от десятичной "
"точки. Если <replaceable class=\"parameter\">q</replaceable> опущено, оно "
"считается равным 0."

#: sql.xml:1752(para)
msgid "FLOAT: signed doubleword floating point number."
msgstr "FLOAT: знаковое число с плавающей точкой, занимающее двойное слово."

#: sql.xml:1758(para)
msgid ""
"VARCHAR(<replaceable class=\"parameter\">n</replaceable>): varying length "
"character string of maximum length <replaceable class=\"parameter\">n</"
"replaceable>."
msgstr ""
"VARCHAR(<replaceable class=\"parameter\">n</replaceable>): символьная строка "
"переменной длины не больше <replaceable class=\"parameter\">n</replaceable>."

#: sql.xml:1766(para)
msgid ""
"CHAR(<replaceable class=\"parameter\">n</replaceable>): fixed length "
"character string of length <replaceable class=\"parameter\">n</replaceable>."
msgstr ""
"CHAR(<replaceable class=\"parameter\">n</replaceable>): символьная строка "
"фиксированной длины <replaceable class=\"parameter\">n</replaceable>."

#: sql.xml:1721(para)
msgid ""
"The following is a list of some data types that are supported by "
"<acronym>SQL</acronym>: <placeholder-1/>"
msgstr ""
"Ниже перечислены некоторые типы данных, поддерживаемые <acronym>SQL</"
"acronym>: <placeholder-1/>"

#: sql.xml:1778(title) sql.xml:1803(title)
msgid "Create Index"
msgstr "Create Index"

#: sql.xml:1780(para)
msgid ""
"Indexes are used to speed up access to a relation. If a relation "
"<classname>R</classname> has an index on attribute <classname>A</classname> "
"then we can retrieve all tuples <replaceable>t</replaceable> having "
"<replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</"
"replaceable> in time roughly proportional to the number of such tuples "
"<replaceable>t</replaceable> rather than in time proportional to the size of "
"<classname>R</classname>."
msgstr ""
"Индексы используются для ускорения доступа к отношению. Если в отношении "
"<classname>R</classname> есть индекс по атрибуту <classname>A</classname>, "
"мы можем получить все кортежи <replaceable>t</replaceable>, для которых "
"<replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</"
"replaceable>, за время, пропорциональное количеству таких кортежей "
"<replaceable>t</replaceable>, а не размеру всего отношения <classname>R</"
"classname>."

#: sql.xml:1795(programlisting)
#, no-wrap
msgid ""
"CREATE INDEX <replaceable class=\"parameter\">index_name</replaceable>\n"
"    ON <replaceable class=\"parameter\">table_name</replaceable> ( <replaceable class=\"parameter\">name_of_attribute</replaceable> );"
msgstr ""
"CREATE INDEX <replaceable class=\"parameter\">имя_индекса</replaceable>\n"
"    ON <replaceable class=\"parameter\">имя_таблицы</replaceable> ( <replaceable class=\"parameter\">имя_атрибута</replaceable> );"

#: sql.xml:1791(para)
msgid ""
"To create an index in <acronym>SQL</acronym> the <command>CREATE INDEX</"
"command> command is used. The syntax is: <placeholder-1/>"
msgstr ""
"Для создания индекса в <acronym>SQL</acronym> применяется команда "
"<command>CREATE INDEX</command>. Она имеет следующий синтаксис: "
"<placeholder-1/>"

#: sql.xml:1809(programlisting)
#, no-wrap
msgid "CREATE INDEX I ON SUPPLIER (SNAME);"
msgstr "CREATE INDEX I ON SUPPLIER (SNAME);"

#: sql.xml:1805(para)
msgid ""
"To create an index named I on attribute SNAME of relation SUPPLIER we use "
"the following statement: <placeholder-1/>"
msgstr ""
"Следующий оператор создаёт индекс с именем I по атрибуту SNAME в отношении "
"SUPPLIER: <placeholder-1/>"

#: sql.xml:1814(para)
msgid ""
"The created index is maintained automatically, i.e., whenever a new tuple is "
"inserted into the relation SUPPLIER the index I is adapted. Note that the "
"only changes a user can perceive when an index is present are increased "
"speed for <command>SELECT</command> and decreases in speed of updates."
msgstr ""
"Созданный индекс поддерживается автоматически, то есть добавление нового "
"кортежа в отношение SUPPLIER отражается в индексе I. Заметьте, что "
"единственное изменение, которое замечает пользователь при добавлении "
"индекса, это увеличение скорости <command>SELECT</command> и снижение "
"скорости изменений данных."

#: sql.xml:1826(title)
msgid "Create View"
msgstr "Create View"

#: sql.xml:1828(para)
msgid ""
"A view can be regarded as a <firstterm>virtual table</firstterm>, i.e., a "
"table that does not <emphasis>physically</emphasis> exist in the database "
"but looks to the user as if it does. By contrast, when we talk of a "
"<firstterm>base table</firstterm> there is really a physically stored "
"counterpart of each row of the table somewhere in the physical storage."
msgstr ""
"Представление можно считать <firstterm>виртуальной таблицей</firstterm>, то "
"есть таблицей, не существующей <emphasis>физически</emphasis> в базе данных, "
"но существующей для пользователя. И напротив, когда речь идёт о "
"<firstterm>базовой таблице</firstterm>, каждой её строке соответствует "
"физически сохранённая в хранилище сущность."

#: sql.xml:1839(para)
msgid ""
"Views do not have their own, physically separate, distinguishable stored "
"data. Instead, the system stores the definition of the view (i.e., the rules "
"about how to access physically stored base tables in order to materialize "
"the view) somewhere in the system catalogs (see <xref linkend=\"tutorial-"
"catalogs-title\" endterm=\"tutorial-catalogs-title\"/>). For a discussion on "
"different techniques to implement views refer to <citetitle>SIM98</"
"citetitle>."
msgstr ""
"Представления лишены собственных, физически отдельных и независимых хранимых "
"данных. Вместо этого, система хранит определение представления (то есть, "
"правила, говорящие, как нужно обращаться к физически хранимым базовым "
"таблицам, чтобы материализовать представление) в своих каталогах (см. <xref "
"remap=\"4\" linkend=\"tutorial-catalogs-title\" endterm=\"tutorial-catalogs-"
"title\"/>). Различные технологии реализации представлений обсуждаются в "
"<citetitle>SIM98</citetitle>."

#: sql.xml:1859(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW <replaceable class=\"parameter\">view_name</replaceable>\n"
"    AS <replaceable class=\"parameter\">select_stmt</replaceable>"
msgstr ""
"CREATE VIEW <replaceable class=\"parameter\">имя_представления</replaceable>\n"
"    AS <replaceable class=\"parameter\">оператор_select</replaceable>"

#: sql.xml:1854(para)
msgid ""
"In <acronym>SQL</acronym> the <command>CREATE VIEW</command> command is used "
"to define a view. The syntax is: <placeholder-1/> where <replaceable class="
"\"parameter\">select_stmt</replaceable> is a valid select statement as "
"defined in <xref linkend=\"select-title\" endterm=\"select-title\"/>. Note "
"that <replaceable class=\"parameter\">select_stmt</replaceable> is not "
"executed when the view is created. It is just stored in the "
"<firstterm>system catalogs</firstterm> and is executed whenever a query "
"against the view is made."
msgstr ""
"В <acronym>SQL</acronym> представление создаёт команда <command>CREATE VIEW</"
"command>. Она имеет следующий синтаксис: <placeholder-1/> Здесь <replaceable "
"class=\"parameter\">оператор_SELECT</replaceable> — допустимый оператор "
"SELECT, как определено в <xref remap=\"6\" linkend=\"select-title\" endterm="
"\"select-title\"/>. Заметьте, что <replaceable class=\"parameter"
"\">оператор_SELECT</replaceable> не выполняется при создании представления. "
"Он только сохраняется в <firstterm>системных каталогах</firstterm> и "
"выполняется, когда обрабатывается запрос к представлению."

#: sql.xml:1878(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW London_Suppliers\n"
"    AS SELECT S.SNAME, P.PNAME\n"
"        FROM SUPPLIER S, PART P, SELLS SE\n"
"        WHERE S.SNO = SE.SNO AND\n"
"              P.PNO = SE.PNO AND\n"
"              S.CITY = 'London';"
msgstr ""
"CREATE VIEW London_Suppliers\n"
"    AS SELECT S.SNAME, P.PNAME\n"
"        FROM SUPPLIER S, PART P, SELLS SE\n"
"        WHERE S.SNO = SE.SNO AND\n"
"              P.PNO = SE.PNO AND\n"
"              S.CITY = 'London';"

#: sql.xml:1873(para)
msgid ""
"Let the following view definition be given (we use the tables from <xref "
"linkend=\"supplier-fig\" endterm=\"supplier-fig\"/> again): <placeholder-1/>"
msgstr ""
"Пусть дано следующее определение представления (в нём мы снова используем "
"таблицы из примера <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\"/"
">): <placeholder-1/>"

#: sql.xml:1893(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM London_Suppliers\n"
"    WHERE PNAME = 'Screw';"
msgstr ""
"SELECT * FROM London_Suppliers\n"
"    WHERE PNAME = 'Screw';"

#: sql.xml:1888(para)
msgid ""
"Now we can use this <firstterm>virtual relation</firstterm> "
"<classname>London_Suppliers</classname> as if it were another base table: "
"<placeholder-1/> which will return the following table: <screen>\n"
" SNAME | PNAME\n"
"-------+-------\n"
" Smith | Screw                 \n"
"</screen>"
msgstr ""
"Теперь мы можем использовать это <firstterm>виртуальное отношение</"
"firstterm> <classname>London_Suppliers</classname>, как если бы это была "
"другая базовая таблица: <placeholder-1/> и в результате мы получим следующую "
"таблицу: <screen>\n"
" SNAME | PNAME\n"
"-------+-------\n"
" Smith | Screw                 \n"
"</screen>"

#: sql.xml:1907(para)
msgid ""
"To calculate this result the database system has to do a <emphasis>hidden</"
"emphasis> access to the base tables SUPPLIER, SELLS and PART first. It does "
"so by executing the query given in the view definition against those base "
"tables. After that the additional qualifications (given in the query against "
"the view) can be applied to obtain the resulting table."
msgstr ""
"Чтобы вычислить этот результат, система управления базой данных должна "
"сначала осуществить <emphasis>скрытое</emphasis> обращение к базовым "
"таблицам SUPPLIER, SELLS и PART. Для этого она выполняет запрос к базовым "
"таблицам, заданный в определении представления. После этого для получения "
"результирующей таблицы могут быть применены дополнительные условия (заданные "
"в запросе с представлением)."

#: sql.xml:1920(title)
msgid "Drop Table, Drop Index, Drop View"
msgstr "Drop Table, Drop Index, Drop View"

#: sql.xml:1926(programlisting)
#, no-wrap
msgid "DROP TABLE <replaceable class=\"parameter\">table_name</replaceable>;"
msgstr "DROP TABLE <replaceable class=\"parameter\">имя_таблицы</replaceable>;"

#: sql.xml:1922(para)
msgid ""
"To destroy a table (including all tuples stored in that table) the "
"<command>DROP TABLE</command> command is used: <placeholder-1/>"
msgstr ""
"Чтобы уничтожить таблицы (включая все содержащиеся в ней кортежи), "
"применяется команда <command>DROP TABLE</command>: <placeholder-1/>"

#: sql.xml:1934(programlisting)
#, no-wrap
msgid "DROP TABLE SUPPLIER;"
msgstr "DROP TABLE SUPPLIER;"

#: sql.xml:1931(para)
msgid ""
"To destroy the SUPPLIER table use the following statement: <placeholder-1/>"
msgstr ""
"Чтобы уничтожить таблицу SUPPLIER, выполните следующий оператор: "
"<placeholder-1/>"

#: sql.xml:1942(programlisting)
#, no-wrap
msgid "DROP INDEX <replaceable class=\"parameter\">index_name</replaceable>;"
msgstr "DROP INDEX <replaceable class=\"parameter\">имя_индекса</replaceable>;"

#: sql.xml:1939(para)
msgid ""
"The <command>DROP INDEX</command> command is used to destroy an index: "
"<placeholder-1/>"
msgstr ""
"Для уничтожения индекса применяется команда <command>DROP INDEX</command>: "
"<placeholder-1/>"

#: sql.xml:1951(programlisting)
#, no-wrap
msgid "DROP VIEW <replaceable class=\"parameter\">view_name</replaceable>;"
msgstr "DROP VIEW <replaceable class=\"parameter\">имя_представления</replaceable>;"

#: sql.xml:1947(para)
msgid ""
"Finally to destroy a given view use the command <command>DROP VIEW</"
"command>: <placeholder-1/>"
msgstr ""
"Наконец, чтобы уничтожить указанное представление, выполните команду "
"<command>DROP VIEW</command>: <placeholder-1/>"

#: sql.xml:1959(title)
msgid "Data Manipulation"
msgstr "Обработка данных"

#: sql.xml:1962(title)
msgid "Insert Into"
msgstr "Insert Into"

#: sql.xml:1970(programlisting)
#, no-wrap
msgid ""
"INSERT INTO <replaceable class=\"parameter\">table_name</replaceable> (<replaceable class=\"parameter\">name_of_attr_1</replaceable>\n"
"    [, <replaceable class=\"parameter\">name_of_attr_2</replaceable> [, ...]])\n"
"    VALUES (<replaceable class=\"parameter\">val_attr_1</replaceable> [, <replaceable class=\"parameter\">val_attr_2</replaceable> [, ...]]);"
msgstr ""
"INSERT INTO <replaceable class=\"parameter\">имя_таблицы</replaceable> (<replaceable class=\"parameter\">имя_атр_1</replaceable>\n"
"    [, <replaceable class=\"parameter\">имя_атр_2</replaceable> [, ...]])\n"
"    VALUES (<replaceable class=\"parameter\">знач_атр_1</replaceable> [, <replaceable class=\"parameter\">знач_атр_2</replaceable> [, ...]]);"

#: sql.xml:1964(para)
msgid ""
"Once a table is created (see <xref linkend=\"create-title\" endterm=\"create-"
"title\"/>), it can be filled with tuples using the command <command>INSERT "
"INTO</command>. The syntax is: <placeholder-1/>"
msgstr ""
"Когда таблица создана (см. <xref remap=\"4\" linkend=\"create-title\" "
"endterm=\"create-title\"/>), её можно наполнить кортежами, применив команду "
"<command>INSERT INTO</command>. Синтаксис этой команды: <placeholder-1/>"

#: sql.xml:1982(programlisting)
#, no-wrap
msgid ""
"INSERT INTO SUPPLIER (SNO, SNAME, CITY)\n"
"    VALUES (1, 'Smith', 'London');"
msgstr ""
"INSERT INTO SUPPLIER (SNO, SNAME, CITY)\n"
"    VALUES (1, 'Smith', 'London');"

#: sql.xml:1977(para)
msgid ""
"To insert the first tuple into the relation SUPPLIER (from <xref linkend="
"\"supplier-fig\" endterm=\"supplier-fig\"/>) we use the following statement: "
"<placeholder-1/>"
msgstr ""
"Для добавления первого кортежа в отношение SUPPLIER (из <xref linkend="
"\"supplier-fig\" endterm=\"supplier-fig\"/>) воспользуемся следующим "
"оператором: <placeholder-1/>"

#: sql.xml:1991(programlisting)
#, no-wrap
msgid ""
"INSERT INTO SELLS (SNO, PNO)\n"
"    VALUES (1, 1);"
msgstr ""
"INSERT INTO SELLS (SNO, PNO)\n"
"    VALUES (1, 1);"

#: sql.xml:1988(para)
msgid ""
"To insert the first tuple into the relation SELLS we use: <placeholder-1/>"
msgstr ""
"Для добавления первого кортежа в отношение SELLS мы выполним: <placeholder-1/"
">"

#: sql.xml:1999(title)
msgid "Update"
msgstr "Update"

#: sql.xml:2005(programlisting)
#, no-wrap
msgid ""
"UPDATE <replaceable class=\"parameter\">table_name</replaceable>\n"
"    SET <replaceable class=\"parameter\">name_of_attr_1</replaceable> = <replaceable class=\"parameter\">value_1</replaceable>\n"
"        [, ... [, <replaceable class=\"parameter\">name_of_attr_k</replaceable> = <replaceable class=\"parameter\">value_k</replaceable>]]\n"
"    WHERE <replaceable class=\"parameter\">condition</replaceable>;"
msgstr ""
"UPDATE <replaceable class=\"parameter\">имя_таблицы</replaceable>\n"
"    SET <replaceable class=\"parameter\">имя_атрибута_1</replaceable> = <replaceable class=\"parameter\">значение_1</replaceable>\n"
"        [, ... [, <replaceable class=\"parameter\">имя_атрибута_k</replaceable> = <replaceable class=\"parameter\">значение_k</replaceable>]]\n"
"    WHERE <replaceable class=\"parameter\">условие</replaceable>;"

#: sql.xml:2001(para)
msgid ""
"To change one or more attribute values of tuples in a relation the "
"<command>UPDATE</command> command is used. The syntax is: <placeholder-1/>"
msgstr ""
"Чтобы изменить значения одного или нескольких атрибутов кортежей в "
"отношении, применяется команда <command>UPDATE</command>. Она имеет "
"следующий синтаксис: <placeholder-1/>"

#: sql.xml:2017(programlisting)
#, no-wrap
msgid ""
"UPDATE PART\n"
"    SET PRICE = 15\n"
"    WHERE PNAME = 'Screw';"
msgstr ""
"UPDATE PART\n"
"    SET PRICE = 15\n"
"    WHERE PNAME = 'Screw';"

#: sql.xml:2013(para)
msgid ""
"To change the value of attribute PRICE of the part 'Screw' in the relation "
"PART we use: <placeholder-1/>"
msgstr ""
"Чтобы изменить значение атрибута PRICE детали 'Screw' в отношении PART, "
"выполним: <placeholder-1/>"

#: sql.xml:2024(para)
msgid ""
"The new value of attribute PRICE of the tuple whose name is 'Screw' is now "
"15."
msgstr "Новым значением атрибута PRICE кортежа с именем 'Screw' стало 15."

#: sql.xml:2031(title)
msgid "Delete"
msgstr "Delete"

#: sql.xml:2037(programlisting)
#, no-wrap
msgid ""
"DELETE FROM <replaceable class=\"parameter\">table_name</replaceable>\n"
"    WHERE <replaceable class=\"parameter\">condition</replaceable>;"
msgstr ""
"DELETE FROM <replaceable class=\"parameter\">имя_таблицы</replaceable>\n"
"    WHERE <replaceable class=\"parameter\">условие</replaceable>;"

#: sql.xml:2033(para)
msgid ""
"To delete a tuple from a particular table use the command DELETE FROM. The "
"syntax is: <placeholder-1/>"
msgstr ""
"Для удаления кортежей из определённой таблицы применяется команда DELETE "
"FROM. Она имеет такой синтаксис: <placeholder-1/>"

#: sql.xml:2047(programlisting)
#, no-wrap
msgid ""
"DELETE FROM SUPPLIER\n"
"    WHERE SNAME = 'Smith';"
msgstr ""
"DELETE FROM SUPPLIER\n"
"    WHERE SNAME = 'Smith';"

#: sql.xml:2043(para)
msgid ""
"To delete the supplier called 'Smith' of the table SUPPLIER the following "
"statement is used: <placeholder-1/>"
msgstr ""
"Следующий оператор удаляет поставщика с именем 'Smith' из таблицы SUPPLIER: "
"<placeholder-1/>"

#: sql.xml:2056(title)
msgid "System Catalogs"
msgstr "Системные каталоги"

#: sql.xml:2058(para)
msgid ""
"In every <acronym>SQL</acronym> database system <firstterm>system catalogs</"
"firstterm> are used to keep track of which tables, views indexes etc. are "
"defined in the database. These system catalogs can be queried as if they "
"were normal relations. For example there is one catalog used for the "
"definition of views. This catalog stores the query from the view definition. "
"Whenever a query against a view is made, the system first gets the "
"<firstterm>view definition query</firstterm> out of the catalog and "
"materializes the view before proceeding with the user query (see <xref "
"linkend=\"sim98\" endterm=\"sim98\"/> for a more detailed description). For "
"more information about system catalogs refer to <xref linkend=\"date04\" "
"endterm=\"date04\"/>."
msgstr ""
"Во всех СУБД <acronym>SQL</acronym> существуют <firstterm>системные "
"каталоги</firstterm>, в которых описывается, какие таблицы, представления, "
"индексы и т. п. определены в базе данных. К этим системным каталогам можно "
"обращаться, как если бы они были обычными отношениями. Например, существует "
"каталог, в котором определяются представления. В этом каталоге хранится "
"запрос, заданный в определении представления. Когда выполняется запрос к "
"представлению, система сначала извлекает <firstterm>запрос, определяющий "
"представление</firstterm>, из каталога и материализует представление, прежде "
"чем обрабатывать запрос пользователя (более подробно это описано в <xref "
"remap=\"6\" linkend=\"sim98\" endterm=\"sim98\"/>). За дополнительными "
"сведениями о системных каталогах обратитесь к <xref remap=\"3\" linkend="
"\"date04\" endterm=\"date04\"/>."

#: sql.xml:2082(title)
msgid "Embedded <acronym>SQL</acronym>"
msgstr "Встраиваемый <acronym>SQL</acronym>"

#: sql.xml:2092(para)
msgid ""
"There are queries that cannot be formulated using pure <acronym>SQL</"
"acronym> (i.e., recursive queries). To be able to perform such queries we "
"need a host language with a greater expressive power than <acronym>SQL</"
"acronym>."
msgstr ""
"Существуют и такие запросы, которые нельзя сформулировать на чистом "
"<acronym>SQL</acronym> (например, рекурсивные запросы). Чтобы иметь "
"возможность выполнять эти запросы, нам нужен язык с большей выразительной "
"мощностью, чем <acronym>SQL</acronym>."

#: sql.xml:2101(para)
msgid ""
"We simply want to access a database from some application that is written in "
"the host language (e.g., a ticket reservation system with a graphical user "
"interface is written in C and the information about which tickets are still "
"left is stored in a database that can be accessed using embedded "
"<acronym>SQL</acronym>)."
msgstr ""
"Мы просто хотим обратиться к базе данных из некоторого приложения, "
"написанного на ведущем языке (например, система резервирования билетов с "
"графическим интерфейсом разрабатывается на C, а информация о наличии билетов "
"хранится в базе данных, и может быть получена с применением встраиваемого "
"<acronym>SQL</acronym>)."

#: sql.xml:2084(para)
msgid ""
"In this section we will sketch how <acronym>SQL</acronym> can be embedded "
"into a host language (e.g., <literal>C</literal>). There are two main "
"reasons why we want to use <acronym>SQL</acronym> from a host language: "
"<placeholder-1/>"
msgstr ""
"В этом разделе мы кратко расскажем, как язык <acronym>SQL</acronym> может "
"встраиваться в ведущий язык (например, <literal>C</literal>). Для "
"использования <acronym>SQL</acronym> в среде ведущего языка есть две "
"основные причины: <placeholder-1/>"

#: sql.xml:2112(para)
msgid ""
"A program using embedded <acronym>SQL</acronym> in a host language consists "
"of statements of the host language and of <firstterm>embedded <acronym>SQL</"
"acronym></firstterm> (<acronym>ESQL</acronym>) statements. Every "
"<acronym>ESQL</acronym> statement begins with the keywords <command>EXEC "
"SQL</command>. The <acronym>ESQL</acronym> statements are transformed to "
"statements of the host language by a <firstterm>precompiler</firstterm> "
"(which usually inserts calls to library routines that perform the various "
"<acronym>SQL</acronym> commands)."
msgstr ""
"Программа, использующая встраиваемый <acronym>SQL</acronym> в ведущем языке, "
"состоит из операторов ведущего языка и операторов <firstterm>встраиваемого "
"<acronym>SQL</acronym></firstterm> (Embedded SQL, <acronym>ESQL</acronym>). "
"Каждый оператор <acronym>ESQL</acronym> начинается с ключевых слов "
"<command>EXEC SQL</command>. Операторы <acronym>ESQL</acronym> преобразуются "
"в операторы ведущего языка <firstterm>предкомпилятором</firstterm> (который "
"обычно вставляет вместо них вызовы библиотечных подпрограмм, выполняющих "
"различные команды <acronym>SQL</acronym>)."

#: sql.xml:2127(para)
msgid ""
"When we look at the examples throughout <xref linkend=\"select-title\" "
"endterm=\"select-title\"/> we realize that the result of the queries is very "
"often a set of tuples. Most host languages are not designed to operate on "
"sets so we need a mechanism to access every single tuple of the set of "
"tuples returned by a SELECT statement. This mechanism can be provided by "
"declaring a <firstterm>cursor</firstterm>. After that we can use the "
"<command>FETCH</command> command to retrieve a tuple and set the cursor to "
"the next tuple."
msgstr ""
"Взглянув на примеры, приведённые в разделе <xref linkend=\"select-title\" "
"endterm=\"select-title\"/>, можно понять, что результатом запросов часто "
"оказывается множество кортежей. Многие языки не предназначены для работы с "
"множествами, так что нам нужен механизм для обращения к каждому отдельному "
"кортежу из множества, выданного оператором SELECT. Этот механизм может "
"обеспечиваться <firstterm>курсором</firstterm>. Объявив курсор, мы можем "
"применять команду <command>FETCH</command> для чтения текущего кортежа и "
"перемещения к следующему."

#: sql.xml:2139(para)
msgid ""
"For a detailed discussion on embedded <acronym>SQL</acronym> refer to <xref "
"linkend=\"date97\" endterm=\"date97\"/>, <xref linkend=\"date04\" endterm="
"\"date04\"/>, or <xref linkend=\"ull88\" endterm=\"ull88\"/>."
msgstr ""
"Узнать о встраиваемом <acronym>SQL</acronym> больше можно в <xref linkend="
"\"date97\" endterm=\"date97\"/>, <xref linkend=\"date04\" endterm=\"date04\"/"
"> и <xref linkend=\"ull88\" endterm=\"ull88\"/>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: sql.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
