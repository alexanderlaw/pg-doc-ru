# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2016, 2017.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-18 10:07+0300\n"
"PO-Revision-Date: 2017-09-18 15:59+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:5(title)
msgid "Parallel Query"
msgstr "Параллельный запрос"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:7(indexterm)
msgid "<primary>parallel query</primary>"
msgstr "<primary>параллельный запрос</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:11(para)
msgid ""
"<productname>PostgreSQL</productname> can devise query plans which can "
"leverage multiple CPUs in order to answer queries faster. This feature is "
"known as parallel query. Many queries cannot benefit from parallel query, "
"either due to limitations of the current implementation or because there is "
"no imaginable query plan which is any faster than the serial query plan. "
"However, for queries that can benefit, the speedup from parallel query is "
"often very significant. Many queries can run more than twice as fast when "
"using parallel query, and some queries can run four times faster or even "
"more. Queries that touch a large amount of data but return only a few rows "
"to the user will typically benefit most. This chapter explains some details "
"of how parallel query works and in which situations it can be used so that "
"users who wish to make use of it can understand what to expect."
msgstr ""
"<productname>PostgreSQL</productname> может вырабатывать такие планы "
"запросов, которые будут задействовать несколько CPU, чтобы получить ответ на "
"запросы быстрее. Эта возможность называется распараллеливанием запросов. Для "
"многих запросов параллельное выполнение не даёт никакого выигрыша, либо из-"
"за ограничений текущей реализации, либо из-за принципиальной невозможности "
"построить параллельный план, который был бы быстрее последовательного. "
"Однако для запросов, в которых это может быть полезно, распараллеливание "
"часто даёт очень значительное ускорение. Многие такие запросы могут "
"выполняться в параллельном режиме как минимум двое быстрее, а некоторые — "
"быстрее в четыре и даже более раз. Обычно наибольший выигрыш можно получить "
"с запросами, обрабатывающими большой объём данных, но возвращающими "
"пользователю всего несколько строк. В этой главе достаточно подробно "
"рассказывается, как работают параллельные запросы и в каких ситуациях их "
"можно использовать, чтобы пользователи, желающие применять их, понимали, "
"чего ожидать."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:27(title)
msgid "How Parallel Query Works"
msgstr "Как работают параллельно выполняемые запросы"

#. +> REL_10
#: parallel.xml:29(para)
msgid ""
"When the optimizer determines that parallel query is the fastest execution "
"strategy for a particular query, it will create a query plan which includes "
"a <firstterm>Gather</firstterm> or <firstterm>Gather Merge</firstterm> node. "
"Here is a simple example: <screen>\n"
"EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';\n"
"                                     QUERY "
"PLAN                                      \n"
"-------------------------------------------------------------------------------------\n"
" Gather  (cost=1000.00..217018.43 rows=1 width=97)\n"
"   Workers Planned: 2\n"
"   -&gt;  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 "
"rows=1 width=97)\n"
"         Filter: (filler ~~ '%x%'::text)\n"
"(4 rows)\n"
"</screen>"
msgstr ""
"Когда оптимизатор определяет, что параллельное выполнение будет наилучшей "
"стратегией для конкретного запроса, он создаёт план запроса, включающий "
"<firstterm>узел Gather</firstterm> (Сбор) или <firstterm>Gather Merge</"
"firstterm> (Сбор со слиянием). Взгляните на простой пример: <screen>\n"
"EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';\n"
"                                     QUERY "
"PLAN                                      \n"
"-------------------------------------------------------------------------------------\n"
" Gather  (cost=1000.00..217018.43 rows=1 width=97)\n"
"   Workers Planned: 2\n"
"   -&gt;  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 "
"rows=1 width=97)\n"
"         Filter: (filler ~~ '%x%'::text)\n"
"(4 rows)\n"
"</screen>"

#. +> REL9_6_3 REL9_6
#: parallel.xml:29(para)
msgid ""
"When the optimizer determines that parallel query is the fastest execution "
"strategy for a particular query, it will create a query plan which includes "
"a <firstterm>Gather node</firstterm>. Here is a simple example: <screen>\n"
"EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';\n"
"                                     QUERY "
"PLAN                                      \n"
"-------------------------------------------------------------------------------------\n"
" Gather  (cost=1000.00..217018.43 rows=1 width=97)\n"
"   Workers Planned: 2\n"
"   -&gt;  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 "
"rows=1 width=97)\n"
"         Filter: (filler ~~ '%x%'::text)\n"
"(4 rows)\n"
"</screen>"
msgstr ""
"Когда оптимизатор определяет, что параллельное выполнение будет наилучшей "
"стратегией для конкретного запроса, он создаёт план запроса, включающий "
"<firstterm>узел Gather</firstterm> (Сбор). Взгляните на простой пример: "
"<screen>\n"
"EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';\n"
"                                     QUERY "
"PLAN                                      \n"
"-------------------------------------------------------------------------------------\n"
" Gather  (cost=1000.00..217018.43 rows=1 width=97)\n"
"   Workers Planned: 2\n"
"   -&gt;  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 "
"rows=1 width=97)\n"
"         Filter: (filler ~~ '%x%'::text)\n"
"(4 rows)\n"
"</screen>"

#. +> REL_10
#: parallel.xml:47(para)
msgid ""
"In all cases, the <literal>Gather</literal> or <literal>Gather Merge</"
"literal> node will have exactly one child plan, which is the portion of the "
"plan that will be executed in parallel. If the <literal>Gather</literal> or "
"<literal>Gather Merge</literal> node is at the very top of the plan tree, "
"then the entire query will execute in parallel. If it is somewhere else in "
"the plan tree, then only the portion of the plan below it will run in "
"parallel. In the example above, the query accesses only one table, so there "
"is only one plan node other than the <literal>Gather</literal> node itself; "
"since that plan node is a child of the <literal>Gather</literal> node, it "
"will run in parallel."
msgstr ""
"Во всех случаях узел <literal>Gather</literal> или <literal>Gather Merge</"
"literal> будет иметь ровно один дочерний план, представляющий часть общего "
"плана, выполняемую в параллельном режиме. Если узел <literal>Gather</"
"literal> или <literal>Gather Merge</literal> располагается на самом верху "
"дерева плана, в параллельном режиме будет выполняться весь запрос. Если он "
"находится где-то в другом месте плана, параллельно будет выполняться только "
"часть плана ниже него. В приведённом выше примере запрос обращается только к "
"одной таблице, так что помимо узла <literal>Gather</literal> есть только ещё "
"один узел плана; и так как этот узел является потомком узла <literal>Gather</"
"literal>, он будет выполняться в параллельном режиме."

#. +> REL_10
#: parallel.xml:60(para)
msgid ""
"<link linkend=\"using-explain\">Using EXPLAIN</link>, you can see the number "
"of workers chosen by the planner. When the <literal>Gather</literal> node is "
"reached during query execution, the process which is implementing the user's "
"session will request a number of <link linkend=\"bgworker\">background "
"worker processes</link> equal to the number of workers chosen by the "
"planner. The number of background workers that the planner will consider "
"using is limited to at most <xref linkend=\"guc-max-parallel-workers-per-"
"gather\"/>. The total number of background workers that can exist at any one "
"time is limited by both <xref linkend=\"guc-max-worker-processes\"/> and "
"<xref linkend=\"guc-max-parallel-workers\"/>. Therefore, it is possible for "
"a parallel query to run with fewer workers than planned, or even with no "
"workers at all. The optimal plan may depend on the number of workers that "
"are available, so this can result in poor query performance. If this "
"occurrence is frequent, consider increasing <varname>max_worker_processes</"
"varname> and <varname>max_parallel_workers</varname> so that more workers "
"can be run simultaneously or alternatively reducing "
"<varname>max_parallel_workers_per_gather</varname> so that the planner "
"requests fewer workers."
msgstr ""
"<link linkend=\"using-explain\">Используя EXPLAIN</link>, вы можете узнать "
"количество исполнителей, выбранное планировщиком для данного запроса. Когда "
"при выполнении запроса достигается узел <literal>Gather</literal>, процесс, "
"обслуживающий сеанс пользователя, запрашивает <link linkend=\"bgworker"
"\">фоновые рабочие процессы</link> в этом количестве. Количество "
"исполнителей, которое может попытаться задействовать планировщик, "
"ограничивается значением <xref linkend=\"guc-max-parallel-workers-per-gather"
"\"/>. Общее число фоновых рабочих процессов, которые могут существовать "
"одновременно, ограничивается параметрами <xref linkend=\"guc-max-worker-"
"processes\"/> и <xref linkend=\"guc-max-parallel-workers\"/>. Таким образом, "
"вполне возможно, что параллельный запрос будет выполняться меньшим числом "
"рабочих процессов, чем планировалось, либо вообще без дополнительных рабочих "
"процессов. Оптимальность плана может зависеть от числа доступных рабочих "
"процессов, так что их нехватка может повлечь значительное снижение "
"производительности. Если это наблюдается часто, имеет смысл увеличить "
"<varname>max_worker_processes</varname> и <varname>max_parallel_workers</"
"varname>, чтобы одновременно могло работать больше процессов, либо наоборот "
"уменьшить <varname>max_parallel_workers_per_gather</varname>, чтобы "
"планировщик запрашивал их в меньшем количестве."

#. +> REL_10
#: parallel.xml:82(para)
msgid ""
"Every background worker process which is successfully started for a given "
"parallel query will execute the parallel portion of the plan. The leader "
"will also execute that portion of the plan, but it has an additional "
"responsibility: it must also read all of the tuples generated by the "
"workers. When the parallel portion of the plan generates only a small number "
"of tuples, the leader will often behave very much like an additional worker, "
"speeding up query execution. Conversely, when the parallel portion of the "
"plan generates a large number of tuples, the leader may be almost entirely "
"occupied with reading the tuples generated by the workers and performing any "
"further processing steps which are required by plan nodes above the level of "
"the <literal>Gather</literal> node or <literal>Gather Merge</literal> node. "
"In such cases, the leader will do very little of the work of executing the "
"parallel portion of the plan."
msgstr ""
"Каждый фоновый рабочий процесс, успешно запущенный для данного параллельного "
"запроса, будет выполнять параллельную часть плана. Ведущий процесс также "
"будет выполнять эту часть плана, но он несёт дополнительную ответственность: "
"он должен также прочитать все кортежи, выданные рабочими процессами. Когда "
"параллельная часть плана выдаёт лишь небольшое количество кортежей, ведущий "
"часто ведёт себя просто как один из рабочих процессов, ускоряя выполнение "
"запроса. И напротив, когда параллельная часть плана выдаёт множество "
"кортежей, ведущий может быть почти всё время занят чтением кортежей, "
"выдаваемых другими рабочими процессами, и выполнять другие шаги обработки, "
"связанные с узлами плана выше узла <literal>Gather</literal> или "
"<literal>Gather Merge</literal>. В таких случаях ведущий процесс может "
"вносить лишь минимальный вклад в выполнение параллельной части плана."

#. +> REL_10
#: parallel.xml:98(para)
msgid ""
"When the node at the top of the parallel portion of the plan is "
"<literal>Gather Merge</literal> rather than <literal>Gather</literal>, it "
"indicates that each process executing the parallel portion of the plan is "
"producing tuples in sorted order, and that the leader is performing an order-"
"preserving merge. In contrast, <literal>Gather</literal> reads tuples from "
"the workers in whatever order is convenient, destroying any sort order that "
"may have existed."
msgstr ""
"Когда над параллельной частью плана оказывается узел <literal>Gather Merge</"
"literal>, а не <literal>Gather</literal>, это означает, что все процессы, "
"выполняющие части параллельного плана, выдают кортежи в отсортированном "
"порядке, и что ведущий процесс выполняет слияние с сохранением порядка. Узел "
"же <literal>Gather</literal>, напротив, получает кортежи от подчинённых "
"процессов в произвольном удобном ему порядке, нарушая порядок сортировки, "
"который мог существовать."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:110(title)
msgid "When Can Parallel Query Be Used?"
msgstr "Когда может применяться распараллеливание запросов?"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:112(para)
msgid ""
"There are several settings which can cause the query planner not to generate "
"a parallel query plan under any circumstances. In order for any parallel "
"query plans whatsoever to be generated, the following settings must be "
"configured as indicated."
msgstr ""
"Планировщик запросов может отказаться от построения параллельных планов "
"запросов в любом случае под влиянием нескольких параметров. Чтобы он строил "
"параллельные планы запросов при каких-бы то ни было условиях, описанные "
"далее параметры необходимо настроить указанным образом."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:121(para)
msgid ""
"<xref linkend=\"guc-max-parallel-workers-per-gather\"/> must be set to a "
"value which is greater than zero. This is a special case of the more general "
"principle that no more workers should be used than the number configured via "
"<varname>max_parallel_workers_per_gather</varname>."
msgstr ""
"<xref linkend=\"guc-max-parallel-workers-per-gather\"/> должен иметь "
"значение, большее нуля. Это особый вариант более общего ограничения на "
"суммарное число используемых рабочих процессов, задаваемого параметром "
"<varname>max_parallel_workers_per_gather</varname>."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:130(para)
msgid ""
"<xref linkend=\"guc-dynamic-shared-memory-type\"/> must be set to a value "
"other than <literal>none</literal>. Parallel query requires dynamic shared "
"memory in order to pass data between cooperating processes."
msgstr ""
"<xref linkend=\"guc-dynamic-shared-memory-type\"/> должен иметь значение, "
"отличное от <literal>none</literal>. Для параллельного выполнения запросов "
"нужна динамическая общая память, через которую будут передаваться данные "
"между взаимодействующими процессами."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:138(para)
msgid ""
"In addition, the system must not be running in single-user mode. Since the "
"entire database system is running in single process in this situation, no "
"background workers will be available."
msgstr ""
"В дополнение к этому, система должна работать не в однопользовательском "
"режиме. Так как в этом режиме вся СУБД работает в одном процессе, фоновые "
"рабочие процессы в нём недоступны."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:144(para)
msgid ""
"Even when it is in general possible for parallel query plans to be "
"generated, the planner will not generate them for a given query if any of "
"the following are true:"
msgstr ""
"Даже если принципиально возможно построить параллельные планы выполнения, "
"планировщик не будет строить такой план для определённого запроса, если "
"имеет место одно из следующих обстоятельств:"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:152(para)
msgid ""
"The query writes any data or locks any database rows. If a query contains a "
"data-modifying operation either at the top level or within a CTE, no "
"parallel plans for that query will be generated. This is a limitation of the "
"current implementation which could be lifted in a future release."
msgstr ""
"Запрос выполняет запись данных или блокирует строки в базе данных. Если "
"запрос содержит операцию, изменяющую данные либо на верхнем уровне, либо "
"внутри CTE, для такого запроса не будут строиться параллельные планы. Это "
"ограничение текущей реализации, которое может быть смягчено в будущих "
"версиях."

#. +> REL_10
#: parallel.xml:162(para)
msgid ""
"The query might be suspended during execution. In any situation in which the "
"system thinks that partial or incremental execution might occur, no parallel "
"plan is generated. For example, a cursor created using <link linkend=\"sql-"
"declare\">DECLARE CURSOR</link> will never use a parallel plan. Similarly, a "
"PL/pgSQL loop of the form <literal>FOR x IN query LOOP .. END LOOP</literal> "
"will never use a parallel plan, because the parallel query system is unable "
"to verify that the code in the loop is safe to execute while parallel query "
"is active."
msgstr ""
"Запрос может быть приостановлен в процессе выполнения. В ситуациях, когда "
"система решает, что может иметь место частичное или дополнительное "
"выполнение, план параллельного выполнения не строится. Например, курсор, "
"созданный предложением <link linkend=\"sql-declare\">DECLARE CURSOR</link>, "
"никогда не будет использовать параллельный план. Подобным образом, цикл PL/"
"pgSQL вида <literal>FOR x IN query LOOP .. END LOOP</literal> никогда не "
"будет использовать параллельный план, так как система параллельных запросов "
"не сможет определить, может ли безопасно выполняться код внутри цикла во "
"время параллельного выполнения запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:176(para)
msgid ""
"The query uses any function marked <literal>PARALLEL UNSAFE</literal>. Most "
"system-defined functions are <literal>PARALLEL SAFE</literal>, but user-"
"defined functions are marked <literal>PARALLEL UNSAFE</literal> by default. "
"See the discussion of <xref linkend=\"parallel-safety\"/>."
msgstr ""
"В запросе используются функции, помеченные как <literal>PARALLEL UNSAFE</"
"literal>. Большинство системных функций безопасны для параллельного "
"выполнения (<literal>PARALLEL SAFE</literal>), но пользовательские функции "
"по умолчанию помечаются как небезопасные (<literal>PARALLEL UNSAFE</"
"literal>). Эта характеристика функции рассматривается в <xref remap=\"6\" "
"linkend=\"parallel-safety\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:186(para)
msgid ""
"The query is running inside of another query that is already parallel. For "
"example, if a function called by a parallel query issues an SQL query "
"itself, that query will never use a parallel plan. This is a limitation of "
"the current implementation, but it may not be desirable to remove this "
"limitation, since it could result in a single query using a very large "
"number of processes."
msgstr ""
"Запрос работает внутри другого запроса, уже параллельного. Например, если "
"функция, вызываемая в параллельном запросе, сама выполняет SQL-запрос, "
"последний запрос никогда не будет выполняться параллельно. Это ограничение "
"текущей реализации, но убирать его вряд ли следует, так как это может "
"привести к использованию одним запросом чрезмерного количества процессов."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:197(para)
msgid ""
"The transaction isolation level is serializable. This is a limitation of the "
"current implementation."
msgstr ""
"Для транзакции установлен сериализуемый уровень изоляции. Это ограничение "
"текущей реализации."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:204(para)
msgid ""
"Even when parallel query plan is generated for a particular query, there are "
"several circumstances under which it will be impossible to execute that plan "
"in parallel at execution time. If this occurs, the leader will execute the "
"portion of the plan below the <literal>Gather</literal> node entirely by "
"itself, almost as if the <literal>Gather</literal> node were not present. "
"This will happen if any of the following conditions are met:"
msgstr ""
"Даже когда для определённого запроса построен параллельный план, возможны "
"различные обстоятельства, при которых этот план нельзя будет выполнить в "
"параллельном режиме. В этих случаях ведущий процесс выполнит часть плана "
"ниже узла <literal>Gather</literal> полностью самостоятельно, как если бы "
"узла <literal>Gather</literal> вовсе не было. Это произойдёт только при "
"выполнении одного из следующих условий:"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:215(para)
msgid ""
"No background workers can be obtained because of the limitation that the "
"total number of background workers cannot exceed <xref linkend=\"guc-max-"
"worker-processes\"/>."
msgstr ""
"Невозможно получить ни одного фонового рабочего процесса из-за ограничения "
"общего числа этих процессов значением <xref linkend=\"guc-max-worker-"
"processes\"/>."

#. +> REL_10
#: parallel.xml:223(para)
msgid ""
"No background workers can be obtained because of the limitation that the "
"total number of background workers launched for purposes of parallel query "
"cannot exceed <xref linkend=\"guc-max-parallel-workers\"/>."
msgstr ""
"Невозможно получить ни одного фонового рабочего процесса из-за ограничения "
"общего числа таких процессов для параллельного выполнения значением <xref "
"linkend=\"guc-max-parallel-workers\"/>."

#. +> REL_10
#: parallel.xml:231(para)
msgid ""
"The client sends an Execute message with a non-zero fetch count. See the "
"discussion of the <link linkend=\"protocol-flow-ext-query\">extended query "
"protocol</link>. Since <link linkend=\"libpq\">libpq</link> currently "
"provides no way to send such a message, this can only occur when using a "
"client that does not rely on libpq. If this is a frequent occurrence, it may "
"be a good idea to set <xref linkend=\"guc-max-parallel-workers-per-gather\"/"
"> to zero in sessions where it is likely, so as to avoid generating query "
"plans that may be suboptimal when run serially."
msgstr ""
"Клиент передаёт сообщение Execute с ненулевым количеством выбираемых "
"кортежей. За подробностями обратитесь к описанию <link linkend=\"protocol-"
"flow-ext-query\">протокола расширенных запросов</link>. Так как <link "
"linkend=\"libpq\">libpq</link> в настоящее время не позволяет передавать "
"такие сообщения, это возможно только с клиентом, задействующим не libpq. "
"Если это происходит часто, имеет смысл установить в <xref linkend=\"guc-max-"
"parallel-workers-per-gather\"/> 0 в сеансах, для которых это актуально, "
"чтобы система не пыталась строить планы, которые могут быть неэффективны при "
"последовательном выполнении."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:246(para)
msgid ""
"A prepared statement is executed using a <literal>CREATE TABLE .. AS "
"EXECUTE ..</literal> statement. This construct converts what otherwise would "
"have been a read-only operation into a read-write operation, making it "
"ineligible for parallel query."
msgstr ""
"Подготовленный оператор выполняется в конструкции <literal>CREATE TABLE .. "
"AS EXECUTE ..</literal>. Эта конструкция меняет характер операции с «только "
"чтение» на «чтение+запись», что исключает параллельное выполнение этой "
"операции."

#. +> REL9_6_3 REL9_6
#: parallel.xml:246(para)
msgid ""
"Because each worker executes the parallel portion of the plan to completion, "
"it is not possible to simply take an ordinary query plan and run it using "
"multiple workers. Each worker would produce a full copy of the output result "
"set, so the query would not run any faster than normal but would produce "
"incorrect results. Instead, the parallel portion of the plan must be what is "
"known internally to the query optimizer as a <firstterm>partial plan</"
"firstterm>; that is, it must be constructed so that each process which "
"executes the plan will generate only a subset of the output rows in such a "
"way that each required output row is guaranteed to be generated by exactly "
"one of the cooperating processes."
msgstr ""
"Так как каждый рабочий процесс выполняет параллельную часть плана до конца, "
"нельзя просто взять обычный план запроса и запустить его в нескольких "
"исполнителях. В этом случае все исполнители выдавали бы полные копии "
"выходного набора результатов, так что запрос выполнится не быстрее, чем "
"обычно, а его результаты могут быть некорректными. Вместо этого параллельной "
"частью плана должно быть то, что для оптимизатора представляется как "
"<firstterm>частичный план</firstterm>; то есть такой план, при выполнении "
"которого в отдельном процессе будет получено только подмножество выходных "
"строк, а каждая требующаяся строка результата будет гарантированно выдана "
"ровно одним из сотрудничающих процессов."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:255(para)
msgid ""
"The transaction isolation level is serializable. This situation does not "
"normally arise, because parallel query plans are not generated when the "
"transaction isolation level is serializable. However, it can happen if the "
"transaction isolation level is changed to serializable after the plan is "
"generated and before it is executed."
msgstr ""
"Для транзакции установлен сериализуемый уровень изоляции. Обычно эта "
"ситуация не возникает, так как при таком уровне изоляции не строятся "
"параллельные планы выполнения. Однако она возможна, если уровень изоляции "
"транзакции меняется на сериализуемый после построения плана и до его "
"выполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:267(title)
msgid "Parallel Plans"
msgstr "Параллельные планы"

#. +> REL_10
#: parallel.xml:269(para)
msgid ""
"Because each worker executes the parallel portion of the plan to completion, "
"it is not possible to simply take an ordinary query plan and run it using "
"multiple workers. Each worker would produce a full copy of the output result "
"set, so the query would not run any faster than normal but would produce "
"incorrect results. Instead, the parallel portion of the plan must be what is "
"known internally to the query optimizer as a <firstterm>partial plan</"
"firstterm>; that is, it must be constructed so that each process which "
"executes the plan will generate only a subset of the output rows in such a "
"way that each required output row is guaranteed to be generated by exactly "
"one of the cooperating processes. Generally, this means that the scan on the "
"driving table of the query must be a parallel-aware scan."
msgstr ""
"Так как каждый рабочий процесс выполняет параллельную часть плана до конца, "
"нельзя просто взять обычный план запроса и запустить его в нескольких "
"исполнителях. В этом случае все исполнители выдавали бы полные копии "
"выходного набора результатов, так что запрос выполнится не быстрее, чем "
"обычно, а его результаты могут быть некорректными. Вместо этого параллельной "
"частью плана должно быть то, что для оптимизатора представляется как "
"<firstterm>частичный план</firstterm>; то есть такой план, при выполнении "
"которого в отдельном процессе будет получено только подмножество выходных "
"строк, а каждая требующаяся строка результата будет гарантированно выдана "
"ровно одним из сотрудничающих процессов. Вообще говоря, это означает, что "
"сканирование нижележащей таблицы запроса должно проводиться с учётом "
"распараллеливания."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:285(title)
msgid "Parallel Scans"
msgstr "Параллельные сканирования"

#. +> REL_10
#: parallel.xml:292(para)
msgid ""
"In a <emphasis>parallel sequential scan</emphasis>, the table's blocks will "
"be divided among the cooperating processes. Blocks are handed out one at a "
"time, so that access to the table remains sequential."
msgstr ""
"При <emphasis>параллельном последовательном сканировании</emphasis> блоки "
"таблицы будут разделены между взаимодействующими процессами. Блоки выдаются "
"по очереди, так что доступ к таблице остаётся последовательным."

#. +> REL_10
#: parallel.xml:299(para)
msgid ""
"In a <emphasis>parallel bitmap heap scan</emphasis>, one process is chosen "
"as the leader. That process performs a scan of one or more indexes and "
"builds a bitmap indicating which table blocks need to be visited. These "
"blocks are then divided among the cooperating processes as in a parallel "
"sequential scan. In other words, the heap scan is performed in parallel, but "
"the underlying index scan is not."
msgstr ""
"При <emphasis>параллельном сканировании кучи по битовой карте</emphasis> "
"один процесс выбирается на роль ведущего. Этот процесс производит "
"сканирование одного или нескольких индексов и строит битовую карту, "
"показывающую, какие блоки таблицы нужно посетить. Затем эти блоки "
"разделяются между взаимодействующими процессами как при параллельном "
"последовательном сканировании. Другими словами, сканирование кучи "
"выполняется в параллельном режиме, а сканирование нижележащего индекса — нет."

#. +> REL_10
#: parallel.xml:309(para)
msgid ""
"In a <emphasis>parallel index scan</emphasis> or <emphasis>parallel index-"
"only scan</emphasis>, the cooperating processes take turns reading data from "
"the index. Currently, parallel index scans are supported only for btree "
"indexes. Each process will claim a single index block and will scan and "
"return all tuples referenced by that block; other process can at the same "
"time be returning tuples from a different index block. The results of a "
"parallel btree scan are returned in sorted order within each worker process."
msgstr ""
"При <emphasis>параллельном сканировании по индексу</emphasis> или "
"<emphasis>параллельном сканировании только индекса</emphasis>, "
"взаимодействующие процессы читают данные из индекса по очереди. В настоящее "
"время параллельное сканирование индекса поддерживается только для индексов-B-"
"деревьев. Каждый процесс будет выбирать один блок индекса с тем, чтобы "
"просканировать и вернуть все кортежи, на которые он ссылается; другой "
"процесс может в то же время возвращать кортежи для другого блока индекса. "
"Результаты параллельного сканирования B-дерева каждый рабочий процесс "
"возвращает в отсортированном порядке."

#. +> REL_10
#: parallel.xml:287(para)
msgid ""
"The following types of parallel-aware table scans are currently supported. "
"<placeholder-1/> Other scan types, such as scans of non-btree indexes, may "
"support parallel scans in the future."
msgstr ""
"В настоящее время поддерживаются следующие виды сканирований таблицы, "
"рассчитанные на параллельное выполнение. <placeholder-1/> В будущем может "
"появиться поддержка параллельного выполнения и для других вариантов "
"сканирования, например, сканирования индексов, отличных от B-дерева."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:328(title)
msgid "Parallel Joins"
msgstr "Параллельные соединения"

#. +> REL_10
#: parallel.xml:330(para)
msgid ""
"Just as in a non-parallel plan, the driving table may be joined to one or "
"more other tables using a nested loop, hash join, or merge join. The inner "
"side of the join may be any kind of non-parallel plan that is otherwise "
"supported by the planner provided that it is safe to run within a parallel "
"worker. For example, if a nested loop join is chosen, the inner plan may be "
"an index scan which looks up a value taken from the outer side of the join."
msgstr ""
"Как и в непараллельном плане, целевая таблица может соединяться с одной или "
"несколькими другими таблицами с использованием вложенных циклов, соединений "
"по хешу или соединений слиянием. Внутренней стороной соединения может быть "
"любой вид непараллельного плана, который в остальном поддерживается "
"планировщиком, при условии, что он безопасен для выполнения в параллельном "
"исполнителе. Например, если выбрано соединение с вложенным циклом, во "
"внутреннем плане может быть сканирование индекса, при котором находится "
"значение, взятое из внешней стороны соединения."

#. +> REL_10
#: parallel.xml:340(para)
msgid ""
"Each worker will execute the inner side of the join in full. This is "
"typically not a problem for nested loops, but may be inefficient for cases "
"involving hash or merge joins. For example, for a hash join, this "
"restriction means that an identical hash table is built in each worker "
"process, which works fine for joins against small tables but may not be "
"efficient when the inner table is large. For a merge join, it might mean "
"that each worker performs a separate sort of the inner relation, which could "
"be slow. Of course, in cases where a parallel plan of this type would be "
"inefficient, the query planner will normally choose some other plan "
"(possibly one which does not use parallelism) instead."
msgstr ""
"Каждый рабочий процесс будет выполнять внутреннюю сторону соединения в "
"полном объёме. Обычно это не проблема для вложенных циклов, но это может "
"быть неэффективно с соединением по хешу или соединением слиянием. Например, "
"для соединения по хешу это ограничение означает, что в каждом рабочем "
"процессе будет строиться одна и та же хеш-таблица, что приемлемо для "
"маленьких таблиц, но может быть неэффективно, когда внутренняя таблица "
"велика. Для соединения слиянием это может означать, что каждый рабочий "
"процесс независимо выполняет сортировку внутреннего отношения, потенциально "
"медленную операцию. Конечно, в тех случаях, когда параллельный план такого "
"вида может быть неэффективным, планировщик запросов обычно выбирает другой "
"план (возможно, уже без распараллеливания)."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:355(title)
msgid "Parallel Aggregation"
msgstr "Параллельное агрегирование"

#. +> REL_10
#: parallel.xml:356(para)
msgid ""
"<productname>PostgreSQL</productname> supports parallel aggregation by "
"aggregating in two stages. First, each process participating in the parallel "
"portion of the query performs an aggregation step, producing a partial "
"result for each group of which that process is aware. This is reflected in "
"the plan as a <literal>Partial Aggregate</literal> node. Second, the partial "
"results are transferred to the leader via <literal>Gather</literal> or "
"<literal>Gather Merge</literal>. Finally, the leader re-aggregates the "
"results across all workers in order to produce the final result. This is "
"reflected in the plan as a <literal>Finalize Aggregate</literal> node."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает параллельное "
"агрегирование, выполняя агрегирование в два этапа. Сначала каждый процесс, "
"задействованный в параллельной части запроса, выполняет шаг агрегирования, "
"выдавая частичный результат для каждой известной ему группы. В плане это "
"отражает узел <literal>Partial Aggregate</literal>. Затем эти промежуточные "
"результаты передаются ведущему через узел <literal>Gather</literal> или "
"<literal>Gather Merge</literal>. И наконец, ведущий заново агрегирует "
"результаты всех рабочих процессов, чтобы получить окончательный результат. "
"Это отражает в плане узел <literal>Finalize Aggregate</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:368(para)
msgid ""
"Because the <literal>Finalize Aggregate</literal> node runs on the leader "
"process, queries which produce a relatively large number of groups in "
"comparison to the number of input rows will appear less favorable to the "
"query planner. For example, in the worst-case scenario the number of groups "
"seen by the <literal>Finalize Aggregate</literal> node could be as many as "
"the number of input rows which were seen by all worker processes in the "
"<literal>Partial Aggregate</literal> stage. For such cases, there is clearly "
"going to be no performance benefit to using parallel aggregation. The query "
"planner takes this into account during the planning process and is unlikely "
"to choose parallel aggregate in this scenario."
msgstr ""
"Так как узел <literal>Finalize Aggregate</literal> выполняется в ведущем "
"процессе, запросы, выдающие достаточно большое количество групп по отношению "
"к числу входных строк, будут расцениваться планировщиком как менее "
"предпочтительные. Например, в худшем случае количество групп, выявленных "
"узлом <literal>Finalize Aggregate</literal>, может равняться числу входных "
"строк, обработанных всеми рабочими процессами на этапе <literal>Partial "
"Aggregate</literal>. Очевидно, что в такой ситуации использование "
"параллельного агрегирования не даст никакого выигрыша производительности. "
"Планировщик запросов учитывает это в процессе планирования, так что выбор "
"параллельного агрегирования в подобных случаях очень маловероятен."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:381(para)
msgid ""
"Parallel aggregation is not supported in all situations. Each aggregate must "
"be <link linkend=\"parallel-safety\">safe</link> for parallelism and must "
"have a combine function. If the aggregate has a transition state of type "
"<literal>internal</literal>, it must have serialization and deserialization "
"functions. See <xref linkend=\"sql-createaggregate\"/> for more details. "
"Parallel aggregation is not supported if any aggregate function call "
"contains <literal>DISTINCT</literal> or <literal>ORDER BY</literal> clause "
"and is also not supported for ordered set aggregates or when the query "
"involves <literal>GROUPING SETS</literal>. It can only be used when all "
"joins involved in the query are also part of the parallel portion of the "
"plan."
msgstr ""
"Параллельное агрегирование поддерживается не во всех случаях. Чтобы оно "
"поддерживалось, агрегатная функция должна быть <link linkend=\"parallel-"
"safety\">безопасной</link> для распараллеливания и должна иметь "
"комбинирующую функцию. Если переходное состояние агрегатной функции имеет "
"тип <literal>internal</literal>, она должна также иметь функции сериализации "
"и десериализации. За подробностями обратитесь к <xref remap=\"3\" linkend="
"\"sql-createaggregate\"/>. Параллельное агрегирование не поддерживается, "
"если вызов агрегатной функции содержит предложение <literal>DISTINCT</"
"literal> или <literal>ORDER BY</literal>. Также оно не поддерживается для "
"сортирующих агрегатов или когда запрос включает предложение "
"<literal>GROUPING SETS</literal>. Оно может использоваться только когда все "
"соединения, задействованные в запросе, также входят в параллельную часть "
"плана."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:397(title)
msgid "Parallel Plan Tips"
msgstr "Советы по параллельным планам"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:399(para)
msgid ""
"If a query that is expected to do so does not produce a parallel plan, you "
"can try reducing <xref linkend=\"guc-parallel-setup-cost\"/> or <xref "
"linkend=\"guc-parallel-tuple-cost\"/>. Of course, this plan may turn out to "
"be slower than the serial plan which the planner preferred, but this will "
"not always be the case. If you don't get a parallel plan even with very "
"small values of these settings (e.g. after setting them both to zero), there "
"may be some reason why the query planner is unable to generate a parallel "
"plan for your query. See <xref linkend=\"when-can-parallel-query-be-used\"/> "
"and <xref linkend=\"parallel-safety\"/> for information on why this may be "
"the case."
msgstr ""
"Если для запроса ожидается параллельный план, но такой план не строится, "
"можно попытаться уменьшить <xref linkend=\"guc-parallel-setup-cost\"/> или "
"<xref linkend=\"guc-parallel-tuple-cost\"/>. Разумеется, этот план может "
"оказаться медленнее последовательного плана, предпочитаемого планировщиком, "
"но не всегда. Если вы не получаете параллельный план даже с очень маленькими "
"значениями этих параметров (например, сбросив оба их в ноль), может быть "
"какая-то веская причина тому, что планировщик запросов не может построить "
"параллельный план для вашего запроса. За информацией о возможных причинах "
"обратитесь к <xref remap=\"3\" linkend=\"when-can-parallel-query-be-used\"/> "
"и <xref remap=\"3\" linkend=\"parallel-safety\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:413(para)
msgid ""
"When executing a parallel plan, you can use <literal>EXPLAIN (ANALYZE, "
"VERBOSE)</literal> to display per-worker statistics for each plan node. This "
"may be useful in determining whether the work is being evenly distributed "
"between all plan nodes and more generally in understanding the performance "
"characteristics of the plan."
msgstr ""
"Когда выполняется параллельный план, вы можете применить <literal>EXPLAIN "
"(ANALYZE, VERBOSE)</literal>, чтобы просмотреть статистику по каждому узлу "
"плана в разрезе рабочих процессов. Это может помочь определить, равномерно "
"ли распределяется работа между всеми узлами плана, и на более общем уровне "
"понимать характеристики производительности плана."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:425(title)
msgid "Parallel Safety"
msgstr "Безопасность распараллеливания"

#. +> REL_10
#: parallel.xml:427(para)
msgid ""
"The planner classifies operations involved in a query as either "
"<firstterm>parallel safe</firstterm>, <firstterm>parallel restricted</"
"firstterm>, or <firstterm>parallel unsafe</firstterm>. A parallel safe "
"operation is one which does not conflict with the use of parallel query. A "
"parallel restricted operation is one which cannot be performed in a parallel "
"worker, but which can be performed in the leader while parallel query is in "
"use. Therefore, parallel restricted operations can never occur below a "
"<literal>Gather</literal> or <literal>Gather Merge</literal> node, but can "
"occur elsewhere in a plan which contains such a node. A parallel unsafe "
"operation is one which cannot be performed while parallel query is in use, "
"not even in the leader. When a query contains anything which is parallel "
"unsafe, parallel query is completely disabled for that query."
msgstr ""
"Планировщик классифицирует операции, вовлечённые в выполнение запроса, как "
"либо <firstterm>безопасные для распараллеливания</firstterm>, либо "
"<firstterm>ограниченно распараллеливаемые</firstterm>, либо "
"<firstterm>небезопасные для распараллеливания</firstterm>. Безопасной для "
"распараллеливания операцией считается такая, которая не мешает параллельному "
"выполнению запроса. Ограниченно распараллеливаемой операцией считается "
"такая, которая не может выполняться в параллельном рабочем процессе, но "
"может выполняться в ведущем процессе, когда запрос выполняется параллельно. "
"Таким образом, ограниченно параллельные операции никогда не могут оказаться "
"ниже узла <literal>Gather</literal> или <literal>Gather Merge</literal>, но "
"могут встречаться в других местах плана, содержащего такой узел. "
"Небезопасные для распараллеливания операции не могут выполняться в "
"параллельных запросах, даже в ведущем процессе. Когда запрос содержит что-"
"либо небезопасное для распараллеливания, параллельное выполнение для такого "
"запроса полностью исключается."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:442(para)
msgid "The following operations are always parallel restricted."
msgstr "Параллельное выполнение всегда запрещается для следующих операций."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:448(para)
msgid "Scans of common table expressions (CTEs)."
msgstr "Сканирование общих табличных выражений (CTE)."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:454(para)
msgid "Scans of temporary tables."
msgstr "Сканирование временных таблиц."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:460(para)
msgid ""
"Scans of foreign tables, unless the foreign data wrapper has an "
"<literal>IsForeignScanParallelSafe</literal> API which indicates otherwise."
msgstr ""
"Сканирование сторонних таблиц, если только обёртка сторонних данных не "
"предоставляет функцию <literal>IsForeignScanParallelSafe</literal>, которая "
"допускает распараллеливание."

#. +> REL_10
#: parallel.xml:467(para)
msgid ""
"Access to an <literal>InitPlan</literal> or correlated <literal>SubPlan</"
"literal>."
msgstr ""
"Доступ к <literal>InitPlan</literal> или связанному <literal>SubPlan</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:474(title)
msgid "Parallel Labeling for Functions and Aggregates"
msgstr "Пометки параллельности для функций и агрегатов"

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:476(para)
msgid ""
"The planner cannot automatically determine whether a user-defined function "
"or aggregate is parallel safe, parallel restricted, or parallel unsafe, "
"because this would require predicting every operation which the function "
"could possibly perform. In general, this is equivalent to the Halting "
"Problem and therefore impossible. Even for simple functions where it "
"conceivably be done, we do not try, since this would be expensive and error-"
"prone. Instead, all user-defined functions are assumed to be parallel unsafe "
"unless otherwise marked. When using <xref linkend=\"sql-createfunction\"/> "
"or <xref linkend=\"sql-alterfunction\"/>, markings can be set by specifying "
"<literal>PARALLEL SAFE</literal>, <literal>PARALLEL RESTRICTED</literal>, or "
"<literal>PARALLEL UNSAFE</literal> as appropriate. When using <xref linkend="
"\"sql-createaggregate\"/>, the <literal>PARALLEL</literal> option can be "
"specified with <literal>SAFE</literal>, <literal>RESTRICTED</literal>, or "
"<literal>UNSAFE</literal> as the corresponding value."
msgstr ""
"Планировщик не может автоматически определить, является ли пользовательская "
"обычная или агрегатная функция безопасной для распараллеливания, так как это "
"потребовало бы предсказания действия каждой операции, которую могла бы "
"выполнять функция. В общем случае это равнозначно решению проблемы "
"остановки, а значит, невозможно. Даже для простых функций, где это в "
"принципе возможно, мы не пытаемся это делать, так как это будет слишком "
"дорогой и потенциально неточной процедурой. Вместо этого, все определяемые "
"пользователем функции полагаются небезопасными для распараллеливания, если "
"явно не отмечено обратное. Когда используется <xref linkend=\"sql-"
"createfunction\"/> или <xref linkend=\"sql-alterfunction\"/>, функции можно "
"назначить отметку <literal>PARALLEL SAFE</literal>, <literal>PARALLEL "
"RESTRICTED</literal> или <literal>PARALLEL UNSAFE</literal>, отражающую её "
"характер. В команде <xref linkend=\"sql-createaggregate\"/> для параметра "
"<literal>PARALLEL</literal> можно задать <literal>SAFE</literal>, "
"<literal>RESTRICTED</literal> или <literal>UNSAFE</literal> в виде "
"соответствующего значения."

#. +> REL_10
#: parallel.xml:494(para)
msgid ""
"Functions and aggregates must be marked <literal>PARALLEL UNSAFE</literal> "
"if they write to the database, access sequences, change the transaction "
"state even temporarily (e.g. a PL/pgSQL function which establishes an "
"<literal>EXCEPTION</literal> block to catch errors), or make persistent "
"changes to settings. Similarly, functions must be marked <literal>PARALLEL "
"RESTRICTED</literal> if they access temporary tables, client connection "
"state, cursors, prepared statements, or miscellaneous backend-local state "
"which the system cannot synchronize across workers. For example, "
"<literal>setseed</literal> and <literal>random</literal> are parallel "
"restricted for this last reason."
msgstr ""
"Обычные и агрегатные функции должны помечаться небезопасными для "
"распараллеливания (<literal>PARALLEL UNSAFE</literal>), если они пишут в "
"базу данных, обращаются к последовательностям, изменяют состояние "
"транзакции, даже временно (как, например, функция PL/pgSQL, устанавливающая "
"блок <literal>EXCEPTION</literal> для перехвата ошибок), либо производят "
"постоянные изменения параметров. Подобным образом, функции должны помечаться "
"как ограниченно распараллеливаемые (<literal>PARALLEL RESTRICTED</literal>), "
"если они обращаются к временным таблицам, состоянию клиентского подключения, "
"курсорам, подготовленным операторам или разнообразному локальному состоянию "
"обслуживающего процесса, которое система не может синхронизировать между "
"рабочими процессами. Например, по этой причине ограниченно параллельными "
"являются функции <literal>setseed</literal> и <literal>random</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:507(para)
msgid ""
"In general, if a function is labeled as being safe when it is restricted or "
"unsafe, or if it is labeled as being restricted when it is in fact unsafe, "
"it may throw errors or produce wrong answers when used in a parallel query. "
"C-language functions could in theory exhibit totally undefined behavior if "
"mislabeled, since there is no way for the system to protect itself against "
"arbitrary C code, but in most likely cases the result will be no worse than "
"for any other function. If in doubt, it is probably best to label functions "
"as <literal>UNSAFE</literal>."
msgstr ""
"В целом, если функция помечена как безопасная, когда на самом деле она "
"небезопасна или ограниченно безопасна, или если она помечена как ограниченно "
"безопасная, когда на самом деле она небезопасная, такая функция может "
"выдавать ошибки или возвращать неправильные ответы при использовании в "
"параллельном запросе. Функции на языке C могут теоретически проявлять "
"полностью неопределённое появление при некорректной пометке, так как система "
"никаким образом не может защитить себя от произвольного кода C, но чаще "
"всего результат будет не хуже, чем с любой другой функцией. В случае "
"сомнений, вероятно, лучше всего будет помечать функции как небезопасные "
"(<literal>UNSAFE</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:518(para)
msgid ""
"If a function executed within a parallel worker acquires locks which are not "
"held by the leader, for example by querying a table not referenced in the "
"query, those locks will be released at worker exit, not end of transaction. "
"If you write a function which does this, and this behavior difference is "
"important to you, mark such functions as <literal>PARALLEL RESTRICTED</"
"literal> to ensure that they execute only in the leader."
msgstr ""
"Если функция, выполняемая в параллельном рабочем процессе, затребует "
"блокировки, которыми не владеет ведущий, например, обращаясь к таблице, не "
"упомянутой в запросе, эти блокировки будут освобождены по завершении "
"процесса, а не в конце транзакции. Если вы разрабатываете функцию с таким "
"поведением, и эта особенность выполнения оказывается критичной, пометьте "
"такую функцию как <literal>PARALLEL RESTRICTED</literal>, чтобы она "
"выполнялась только в ведущем процессе."

#. +> REL_10
#: parallel.xml:528(para)
msgid ""
"Note that the query planner does not consider deferring the evaluation of "
"parallel-restricted functions or aggregates involved in the query in order "
"to obtain a superior plan. So, for example, if a <literal>WHERE</literal> "
"clause applied to a particular table is parallel restricted, the query "
"planner will not consider performing a scan of that table in the parallel "
"portion of a plan. In some cases, it would be possible (and perhaps even "
"efficient) to include the scan of that table in the parallel portion of the "
"query and defer the evaluation of the <literal>WHERE</literal> clause so "
"that it happens above the <literal>Gather</literal> node. However, the "
"planner does not do this."
msgstr ""
"Заметьте, что планировщик запросов не рассматривает возможность отложенного "
"выполнения ограниченно распараллеливаемых обычных или агрегатных функций, "
"задействованных в запросе, для получения лучшего плана. Поэтому, например, "
"если предложение <literal>WHERE</literal>, применяемое к конкретной таблице, "
"является ограниченно параллельным, планировщик запросов исключит возможность "
"сканирования этой таблицы в параллельной части плана. В некоторых случаях "
"возможно (и, вероятно, более эффективно) включить сканирование этой таблицы "
"в параллельную часть запроса и отложить вычисление предложения "
"<literal>WHERE</literal>, чтобы оно происходило над узлом <literal>Gather</"
"literal>, но планировщик этого не делает."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: parallel.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: parallel.xml:46(para)
msgid ""
"In all cases, the <literal>Gather</literal> node will have exactly one child "
"plan, which is the portion of the plan that will be executed in parallel. If "
"the <literal>Gather</literal> node is at the very top of the plan tree, then "
"the entire query will execute in parallel. If it is somewhere else in the "
"plan tree, then only that portion of the query will run in parallel. In the "
"example above, the query accesses only one table, so there is only one plan "
"node other than the <literal>Gather</literal> node itself; since that plan "
"node is a child of the <literal>Gather</literal> node, it will run in "
"parallel."
msgstr ""
"Во всех случаях узел <literal>Gather</literal> будет иметь ровно один "
"дочерний план, представляющий часть общего плана, выполняемую в параллельном "
"режиме. Если узел <literal>Gather</literal> располагается на самом верху "
"дерева плана, в параллельном режиме будет выполняться весь запрос. Если он "
"находится где-то в другом месте плана, параллельно будет выполняться только "
"соответствующая часть плана. В приведённом выше примере запрос обращается "
"только к одной таблице, так что помимо узла <literal>Gather</literal> есть "
"только ещё один узел плана; и так как этот узел является потомком узла "
"<literal>Gather</literal>, он будет выполняться в параллельном режиме."

#. +> REL9_6_3 REL9_6
#: parallel.xml:58(para)
msgid ""
"<link linkend=\"using-explain\">Using EXPLAIN</link>, you can see the number "
"of workers chosen by the planner. When the <literal>Gather</literal> node is "
"reached during query execution, the process which is implementing the user's "
"session will request a number of <link linkend=\"bgworker\">background "
"worker processes</link> equal to the number of workers chosen by the "
"planner. The total number of background workers that can exist at any one "
"time is limited by <xref linkend=\"guc-max-worker-processes\"/>, so it is "
"possible for a parallel query to run with fewer workers than planned, or "
"even with no workers at all. The optimal plan may depend on the number of "
"workers that are available, so this can result in poor query performance. If "
"this occurrence is frequent, considering increasing "
"<varname>max_worker_processes</varname> so that more workers can be run "
"simultaneously or alternatively reducing <xref linkend=\"guc-max-parallel-"
"workers-per-gather\"/> so that the planner requests fewer workers."
msgstr ""
"<link linkend=\"using-explain\">Используя EXPLAIN</link>, вы можете узнать "
"количество исполнителей, выбранное планировщиком для данного запроса. Когда "
"при выполнении запроса достигается узел <literal>Gather</literal>, процесс, "
"обслуживающий сеанс пользователя, запрашивает <link linkend=\"bgworker"
"\">фоновые рабочие процессы</link> в этом количестве. Общее число фоновых "
"рабочих процессов, которые могут существовать одновременно, ограничивается "
"параметром <xref linkend=\"guc-max-worker-processes\"/>, так что вполне "
"возможно, что параллельный запрос будет выполняться меньшим числом рабочих "
"процессов, чем планировалось, либо вообще без дополнительных рабочих "
"процессов. Оптимальность плана может зависеть от числа доступных рабочих "
"процессов, так что их нехватка может повлечь значительное снижение "
"производительности. Если это наблюдается часто, имеет смысл увеличить "
"<varname>max_worker_processes</varname>, чтобы одновременно могло работать "
"больше процессов, либо уменьшить <xref linkend=\"guc-max-parallel-workers-"
"per-gather\"/>, чтобы планировщик ожидал их наличия в меньшем количестве."

#. +> REL9_6_3 REL9_6
#: parallel.xml:77(para)
msgid ""
"Every background worker process which is successfully started for a given "
"parallel query will execute the portion of the plan which is a descendent of "
"the <literal>Gather</literal> node. The leader will also execute that "
"portion of the plan, but it has an additional responsibility: it must also "
"read all of the tuples generated by the workers. When the parallel portion "
"of the plan generates only a small number of tuples, the leader will often "
"behave very much like an additional worker, speeding up query execution. "
"Conversely, when the parallel portion of the plan generates a large number "
"of tuples, the leader may be almost entirely occupied with reading the "
"tuples generated by the workers and performing any further processing steps "
"which are required by plan nodes above the level of the <literal>Gather</"
"literal> node. In such cases, the leader will do very little of the work of "
"executing the parallel portion of the plan."
msgstr ""
"Каждый фоновый рабочий процесс, успешно запущенный для данного параллельного "
"запроса, будет выполнять часть плана, подчинённую узлу <literal>Gather</"
"literal>. Ведущий процесс также будет выполнять эту часть плана, но он несёт "
"дополнительную ответственность: он должен также прочитать все кортежи, "
"выданные рабочими процессами. Когда параллельная часть плана выдаёт лишь "
"небольшое количество кортежей, ведущий часто ведёт себя просто как один из "
"рабочих процессов, ускоряя выполнение запроса. И напротив, когда "
"параллельная часть плана выдаёт множество кортежей, ведущий может быть почти "
"всё время занят чтением кортежей, выдаваемых другими рабочими процессами, и "
"выполнять другие шаги обработки, связанные с узлами плана выше узла "
"<literal>Gather</literal>. В таких случаях ведущий процесс может вносить "
"лишь минимальный вклад в выполнение параллельной части плана."

#. +> REL9_6_3 REL9_6
#: parallel.xml:147(para)
msgid ""
"The query might be suspended during execution. In any situation in which the "
"system thinks that partial or incremental execution might occur, no parallel "
"plan is generated. For example, a cursor created using <link linkend=\"sql-"
"declare\">DECLARE CURSOR</link> will never use a parallel plan. Similarly, a "
"PL/pgsql loop of the form <literal>FOR x IN query LOOP .. END LOOP</literal> "
"will never use a parallel plan, because the parallel query system is unable "
"to verify that the code in the loop is safe to execute while parallel query "
"is active."
msgstr ""
"Запрос может быть приостановлен в процессе выполнения. В ситуациях, когда "
"система решает, что может иметь место частичное или дополнительное "
"выполнение, план параллельного выполнения не строится. Например, курсор, "
"созданный предложением <link linkend=\"sql-declare\">DECLARE CURSOR</link>, "
"никогда не будет использовать параллельный план. Подобным образом, цикл PL/"
"pgSQL вида <literal>FOR x IN query LOOP .. END LOOP</literal> никогда не "
"будет использовать параллельный план, так как система параллельных запросов "
"не сможет определить, может ли безопасно выполняться код внутри цикла во "
"время параллельного выполнения запроса."

#. +> REL9_6_3 REL9_6
#: parallel.xml:208(para)
msgid ""
"The client sends an Execute message with a non-zero fetch count. See the "
"discussion of the <link linkend=\"protocol-flow-ext-query\">extended query "
"protocol</link>. Since <link linkend=\"libpq\">libpq</link> currently "
"provides no way to send such a message, this can only occur when using a "
"client that does not rely on libpq. If this is a frequent occurrence, it may "
"be a good idea to set <xref linkend=\"guc-max-parallel-workers-per-gather\"/"
"> in sessions where it is likely, so as to avoid generating query plans that "
"may be suboptimal when run serially."
msgstr ""
"Клиент передаёт сообщение Execute с ненулевым количеством выбираемых "
"кортежей. За подробностями обратитесь к описанию <link linkend=\"protocol-"
"flow-ext-query\">протокола расширенных запросов</link>. Так как <link "
"linkend=\"libpq\">libpq</link> в настоящее время не позволяет передавать "
"такие сообщения, это возможно только с клиентом, задействующим не libpq. "
"Если это происходит часто, имеет смысл установить <xref linkend=\"guc-max-"
"parallel-workers-per-gather\"/> в сеансах, для которых это актуально, чтобы "
"система не пыталась строить планы, которые могут быть неэффективны при "
"последовательном выполнении."

#. +> REL9_6_3 REL9_6
#: parallel.xml:262(para)
msgid ""
"Currently, the only type of scan which has been modified to work with "
"parallel query is a sequential scan. Therefore, the driving table in a "
"parallel plan will always be scanned using a <literal>Parallel Seq Scan</"
"literal>. The relation's blocks will be divided among the cooperating "
"processes. Blocks are handed out one at a time, so that access to the "
"relation remains sequential. Each process will visit every tuple on the page "
"assigned to it before requesting a new page."
msgstr ""
"В настоящее время единственным вариантом сканирования, адаптированным для "
"работы в параллельном режиме, является последовательное сканирование. Таким "
"образом, целевая таблица в параллельном плане всегда будет сканироваться "
"узлом <literal>Parallel Seq Scan</literal>. Блоки отношения разделяются "
"между сотрудничающими процессами и выдаются им по одному, так что доступ к "
"отношению остаётся последовательным. Каждый отдельный процесс сначала "
"посещает все кортежи на назначенной ему странице, и только затем переходит к "
"новой."

#. +> REL9_6_3 REL9_6
#: parallel.xml:277(para)
msgid ""
"The driving table may be joined to one or more other tables using nested "
"loops or hash joins. The inner side of the join may be any kind of non-"
"parallel plan that is otherwise supported by the planner provided that it is "
"safe to run within a parallel worker. For example, it may be an index scan "
"which looks up a value taken from the outer side of the join. Each worker "
"will execute the inner side of the join in full, which for hash join means "
"that an identical hash table is built in each worker process."
msgstr ""
"Целевая таблица может соединяться с одной или несколькими другими таблицами "
"с использованием вложенных циклов или соединений по хешу. Внутренней "
"стороной соединения может быть любой вид не параллельного плана, который в "
"остальном поддерживается планировщиком, при условии, что он безопасен для "
"выполнения в параллельном исполнителе. Например, это может быть сканирование "
"индекса, при котором находится значение, взятое из внешней стороны "
"соединения. Каждый рабочий процесс будет выполнять внутреннюю сторону "
"соединения в полном объёме, что для соединения по хешу означает, что в "
"каждом рабочем процессе будет строиться одна и та же хеш-таблица."

#. +> REL9_6_3 REL9_6
#: parallel.xml:291(para)
msgid ""
"<productname>PostgreSQL</productname> supports parallel aggregation by "
"aggregating in two stages. First, each process participating in the parallel "
"portion of the query performs an aggregation step, producing a partial "
"result for each group of which that process is aware. This is reflected in "
"the plan as a <literal>Partial Aggregate</literal> node. Second, the partial "
"results are transferred to the leader via the <literal>Gather</literal> "
"node. Finally, the leader re-aggregates the results across all workers in "
"order to produce the final result. This is reflected in the plan as a "
"<literal>Finalize Aggregate</literal> node."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает параллельное "
"агрегирование, выполняя агрегирование в два этапа. Сначала каждый процесс, "
"задействованный в параллельной части запроса, выполняет шаг агрегирования, "
"выдавая частичный результат для каждой известной ему группы. В плане это "
"отражает узел <literal>Partial Aggregate</literal>. Затем эти промежуточные "
"результаты передаются ведущему через узел <literal>Gather</literal>. И "
"наконец, ведущий заново агрегирует результаты всех рабочих процессов, чтобы "
"получить окончательный результат. Это отражает в плане узел "
"<literal>Finalize Aggregate</literal>."

#. +> REL9_6_3 REL9_6
#: parallel.xml:362(para)
msgid ""
"The planner classifies operations involved in a query as either "
"<firstterm>parallel safe</firstterm>, <firstterm>parallel restricted</"
"firstterm>, or <firstterm>parallel unsafe</firstterm>. A parallel safe "
"operation is one which does not conflict with the use of parallel query. A "
"parallel restricted operation is one which cannot be performed in a parallel "
"worker, but which can be performed in the leader while parallel query is in "
"use. Therefore, parallel restricted operations can never occur below a "
"<literal>Gather</literal> node, but can occur elsewhere in a plan which "
"contains a <literal>Gather</literal> node. A parallel unsafe operation is "
"one which cannot be performed while parallel query is in use, not even in "
"the leader. When a query contains anything which is parallel unsafe, "
"parallel query is completely disabled for that query."
msgstr ""
"Планировщик классифицирует операции, вовлечённые в выполнение запроса, как "
"либо <firstterm>безопасные для распараллеливания</firstterm>, либо "
"<firstterm>ограниченно распараллеливаемые</firstterm>, либо "
"<firstterm>небезопасные для распараллеливания</firstterm>. Безопасной для "
"распараллеливания операцией считается такая, которая не мешает параллельному "
"выполнению запроса. Ограниченно распараллеливаемой операцией считается "
"такая, которая не может выполняться в параллельном рабочем процессе, но "
"может выполняться в ведущем процессе, когда запрос выполняется параллельно. "
"Таким образом, ограниченно параллельные операции никогда не могут оказаться "
"ниже узла <literal>Gather</literal>, но могут встречаться в других местах "
"плана с узлом <literal>Gather</literal>. Небезопасные для распараллеливания "
"операции не могут выполняться в параллельных запросах, даже в ведущем "
"процессе. Когда запрос содержит что-либо небезопасное для распараллеливания, "
"параллельное выполнение для такого запроса полностью исключается."

#. +> REL9_6_3 REL9_6
#: parallel.xml:402(para)
msgid "Access to an <literal>InitPlan</literal> or <literal>SubPlan</literal>."
msgstr "Доступ к <literal>InitPlan</literal> или <literal>SubPlan</literal>."

#. +> REL9_6_3 REL9_6
#: parallel.xml:429(para)
msgid ""
"Functions and aggregates must be marked <literal>PARALLEL UNSAFE</literal> "
"if they write to the database, access sequences, change the transaction "
"state even temporarily (e.g. a PL/pgsql function which establishes an "
"<literal>EXCEPTION</literal> block to catch errors), or make persistent "
"changes to settings. Similarly, functions must be marked <literal>PARALLEL "
"RESTRICTED</literal> if they access temporary tables, client connection "
"state, cursors, prepared statements, or miscellaneous backend-local state "
"which the system cannot synchronize across workers. For example, "
"<literal>setseed</literal> and <literal>random</literal> are parallel "
"restricted for this last reason."
msgstr ""
"Обычные и агрегатные функции должны помечаться небезопасными для "
"распараллеливания (<literal>PARALLEL UNSAFE</literal>), если они пишут в "
"базу данных, обращаются к последовательностям, изменяют состояние "
"транзакции, даже временно (как, например, функция PL/pgSQL, устанавливающая "
"блок <literal>EXCEPTION</literal> для перехвата ошибок), либо производят "
"постоянные изменения параметров. Подобным образом, функции должны помечаться "
"как ограниченно распараллеливаемые (<literal>PARALLEL RESTRICTED</literal>), "
"если они обращаются к временным таблицам, состоянию клиентского подключения, "
"курсорам, подготовленным операторам или разнообразному локальному состоянию "
"обслуживающего процесса, которое система не может синхронизировать между "
"рабочими процессами. Например, по этой причине ограниченно параллельными "
"являются функции <literal>setseed</literal> и <literal>random</literal>."

#. +> REL9_6_3 REL9_6
#: parallel.xml:463(para)
msgid ""
"Note that the query planner does not consider deferring the evaluation of "
"parallel-restricted functions or aggregates involved in the query in order "
"to obtain a superior plan. So, for example, if a <literal>WHERE</literal> "
"clause applied to a particular table is parallel restricted, the query "
"planner will not consider placing the scan of that table below a "
"<literal>Gather</literal> node. In some cases, it would be possible (and "
"perhaps even efficient) to include the scan of that table in the parallel "
"portion of the query and defer the evaluation of the <literal>WHERE</"
"literal> clause so that it happens above the <literal>Gather</literal> node. "
"However, the planner does not do this."
msgstr ""
"Заметьте, что планировщик запросов не рассматривает возможность отложенного "
"выполнения ограниченно распараллеливаемых обычных или агрегатных функций, "
"задействованных в запросе, для получения лучшего плана. Поэтому, например, "
"если предложение <literal>WHERE</literal>, применяемое к конкретной таблице, "
"является ограниченно параллельным, планировщик запросов не будет помещать "
"сканирование этой таблицы под узел <literal>Gather</literal>. В некоторых "
"случаях возможно (и, вероятно, более эффективно) включить сканирование этой "
"таблицы в параллельную часть запроса и отложить вычисление предложения "
"<literal>WHERE</literal>, чтобы оно происходило над узлом <literal>Gather</"
"literal>, но планировщик этого не делает."

#~ msgid ""
#~ "It is not possible to perform the aggregation portion of a query entirely "
#~ "in parallel. For example, if a query involves selecting "
#~ "<literal>COUNT(*)</literal>, each worker could compute a total, but those "
#~ "totals would need to combined in order to produce a final answer. If the "
#~ "query involved a <literal>GROUP BY</literal> clause, a separate total "
#~ "would need to be computed for each group. Even though aggregation can't "
#~ "be done entirely in parallel, queries involving aggregation are often "
#~ "excellent candidates for parallel query, because they typically read many "
#~ "rows but return only a few rows to the client. Queries that return many "
#~ "rows to the client are often limited by the speed at which the client can "
#~ "read the data, in which case parallel query cannot help very much."
#~ msgstr ""
#~ "Часть запроса, собственно производящую агрегирование, невозможно "
#~ "выполнять полностью в параллельном режиме. Например, если запрос включает "
#~ "выборку <literal>COUNT(*)</literal>, каждый рабочий процесс сможет "
#~ "подсчитать своё количество строк, но эти количества нужно будет сложить, "
#~ "чтобы получить окончательный ответ. Если запрос включает предложение "
#~ "<literal>GROUP BY</literal>, отдельное общее количество надо будет "
#~ "вычислять для каждой группы. И даже несмотря на то, что агрегирование "
#~ "нельзя осуществлять полностью параллельно, запросы с агрегированием часто "
#~ "становятся отличными кандидатами на распараллеливание, так как они обычно "
#~ "читают множество строк, но возвращают клиенту только небольшое их число. "
#~ "Запросы, возвращающие клиенту множество строк, часто ограничены "
#~ "скоростью, с которой клиент может принимать данные, так что в таких "
#~ "случаях параллельное выполнение запроса может быть не очень полезным."
