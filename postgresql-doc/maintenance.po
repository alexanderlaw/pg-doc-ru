# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: maintenance.xml:5(title)
msgid "Routine Database Maintenance Tasks"
msgstr "Регламентные задачи обслуживания базы данных"

#: maintenance.xml:7(indexterm)
msgid "<primary>maintenance</primary>"
msgstr "<primary>обслуживание</primary>"

#: maintenance.xml:11(indexterm)
msgid "<primary>routine maintenance</primary>"
msgstr "<primary>регламентное обслуживание</primary>"

#: maintenance.xml:15(para)
msgid ""
"<productname>PostgreSQL</productname>, like any database software, requires "
"that certain tasks be performed regularly to achieve optimum performance. "
"The tasks discussed here are <emphasis>required</emphasis>, but they are "
"repetitive in nature and can easily be automated using standard tools such "
"as <application>cron</application> scripts or Windows' <application>Task "
"Scheduler</application>. It is the database administrator's responsibility "
"to set up appropriate scripts, and to check that they execute successfully."
msgstr ""
"Как и в любой СУБД, в <productname>PostgreSQL</productname> для достижения "
"оптимальной производительности нужно регулярно выполнять определённые "
"процедуры. Задачи, которые рассматриваются в этой главе, являются "
"<emphasis>обязательными</emphasis>, но они по природе своей повторяющиеся и "
"легко поддаются автоматизации с использованием стандартных средств, таких "
"как задания <application>cron</application> или <application>Планировщика "
"задач</application> в Windows. Создание соответствующих заданий и контроль "
"над их успешным выполнением входят в обязанности администратора базы данных."

#: maintenance.xml:26(para)
msgid ""
"One obvious maintenance task is the creation of backup copies of the data on "
"a regular schedule. Without a recent backup, you have no chance of recovery "
"after a catastrophe (disk failure, fire, mistakenly dropping a critical "
"table, etc.). The backup and recovery mechanisms available in "
"<productname>PostgreSQL</productname> are discussed at length in <xref "
"linkend=\"backup\"/>."
msgstr ""
"Одной из очевидных задач обслуживания СУБД является регулярное создание "
"резервных копий данных. При отсутствии свежей резервной копии у вас не будет "
"шанса восстановить систему после катастрофы (сбой диска, пожар, удаление "
"важной таблицы по ошибке и т. д.). Механизмы резервного копирования и "
"восстановления в <productname>PostgreSQL</productname> детально "
"рассматриваются в <xref remap=\"6\" linkend=\"backup\"/>."

#: maintenance.xml:35(para)
msgid ""
"The other main category of maintenance task is periodic <quote>vacuuming</"
"quote> of the database. This activity is discussed in <xref linkend="
"\"routine-vacuuming\"/>. Closely related to this is updating the statistics "
"that will be used by the query planner, as discussed in <xref linkend="
"\"vacuum-for-statistics\"/>."
msgstr ""
"Другое важное направление обслуживания СУБД — периодическая <quote>очистка</"
"quote> базы данных. Эта операция рассматривается в <xref remap=\"6\" linkend="
"\"routine-vacuuming\"/>. С ней тесно связано обновление статистики, которая "
"будет использоваться планировщиком запросов; оно рассматривается в <xref "
"remap=\"6\" linkend=\"vacuum-for-statistics\"/>."

#: maintenance.xml:43(para)
msgid ""
"Another task that might need periodic attention is log file management. This "
"is discussed in <xref linkend=\"logfile-maintenance\"/>."
msgstr ""
"Ещё одной задачей, требующей периодического выполнения, является управление "
"файлами журнала. Она рассматривается в <xref remap=\"6\" linkend=\"logfile-"
"maintenance\"/>."

#: maintenance.xml:48(para)
msgid ""
"<ulink url=\"http://bucardo.org/wiki/Check_postgres"
"\"><application>check_postgres</application></ulink> is available for "
"monitoring database health and reporting unusual conditions. "
"<application>check_postgres</application> integrates with Nagios and MRTG, "
"but can be run standalone too."
msgstr ""
"Для контроля состояния базы данных и для отслеживания нестандартных ситуаций "
"можно использовать <ulink url=\"http://bucardo.org/wiki/Check_postgres"
"\"><application>check_postgres</application></ulink>. Скрипт "
"<application>check_postgres</application> можно интегрировать с Nagios и "
"MRTG, однако он может работать и самостоятельно."

#: maintenance.xml:56(para)
msgid ""
"<productname>PostgreSQL</productname> is low-maintenance compared to some "
"other database management systems. Nonetheless, appropriate attention to "
"these tasks will go far towards ensuring a pleasant and productive "
"experience with the system."
msgstr ""
"По сравнению с некоторыми другими СУБД <productname>PostgreSQL</productname> "
"неприхотлив в обслуживании. Тем не менее, должное внимание к "
"вышеперечисленным задачам будет значительно способствовать комфортной и "
"производительной работе с СУБД."

#: maintenance.xml:64(title)
msgid "Routine Vacuuming"
msgstr "Регламентная очистка"

#: maintenance.xml:66(indexterm)
msgid "<primary>vacuum</primary>"
msgstr "<primary>очистка</primary>"

#: maintenance.xml:70(para)
msgid ""
"<productname>PostgreSQL</productname> databases require periodic maintenance "
"known as <firstterm>vacuuming</firstterm>. For many installations, it is "
"sufficient to let vacuuming be performed by the <firstterm>autovacuum "
"daemon</firstterm>, which is described in <xref linkend=\"autovacuum\"/>. "
"You might need to adjust the autovacuuming parameters described there to "
"obtain best results for your situation. Some database administrators will "
"want to supplement or replace the daemon's activities with manually-managed "
"<command>VACUUM</command> commands, which typically are executed according "
"to a schedule by <application>cron</application> or <application>Task "
"Scheduler</application> scripts. To set up manually-managed vacuuming "
"properly, it is essential to understand the issues discussed in the next few "
"subsections. Administrators who rely on autovacuuming may still wish to skim "
"this material to help them understand and adjust autovacuuming."
msgstr ""
"Базы данных <productname>PostgreSQL</productname> требуют периодического "
"проведения процедуры обслуживания, которая называется <firstterm>очисткой</"
"firstterm>. Во многих случаях очистку достаточно выполнять с помощью "
"<firstterm>демона автоочистки</firstterm>, который описан в <xref remap="
"\"6\" linkend=\"autovacuum\"/>. Возможно, в вашей ситуации для получения "
"оптимальных результатов потребуется настроить описанные там же параметры "
"автоочистки. Некоторые администраторы СУБД могут дополнить или заменить "
"действие этого демона командами <command>VACUUM</command> (обычно они "
"выполняются по расписанию в заданиях <application>cron</application> или "
"<application>Планировщика задач</application>). Чтобы правильно организовать "
"очистку вручную, необходимо понимать темы, которые будут рассмотрены в "
"следующих подразделах. Администраторы, которые полагаются на автоочистку, "
"возможно, всё же захотят просмотреть этот материал, чтобы лучше понимать и "
"настраивать эту процедуру."

#: maintenance.xml:87(title)
msgid "Vacuuming Basics"
msgstr "Основные принципы очистки"

#: maintenance.xml:96(simpara)
msgid "To recover or reuse disk space occupied by updated or deleted rows."
msgstr ""
"Для высвобождения или повторного использования дискового пространства, "
"занятого изменёнными или удалёнными строками."

#: maintenance.xml:101(simpara)
msgid ""
"To update data statistics used by the <productname>PostgreSQL</productname> "
"query planner."
msgstr ""
"Для обновления статистики по данным, используемой планировщиком запросов "
"<productname>PostgreSQL</productname>."

#: maintenance.xml:106(simpara)
msgid ""
"To update the visibility map, which speeds up <link linkend=\"indexes-index-"
"only-scans\">index-only scans</link>."
msgstr ""
"Для обновления карты видимости, которая ускоряет <link linkend=\"indexes-"
"index-only-scans\">сканирование только индекса</link>."

#: maintenance.xml:112(simpara)
msgid ""
"To protect against loss of very old data due to <firstterm>transaction ID "
"wraparound</firstterm> or <firstterm>multixact ID wraparound</firstterm>."
msgstr ""
"Для предотвращения потери очень старых данных из-за зацикливания "
"идентификаторов <firstterm>транзакций</firstterm> или "
"<firstterm>мультитранзакций</firstterm>."

#: maintenance.xml:89(para)
msgid ""
"<productname>PostgreSQL</productname>'s <xref linkend=\"sql-vacuum\"/> "
"command has to process each table on a regular basis for several reasons: "
"<placeholder-1/> Each of these reasons dictates performing <command>VACUUM</"
"command> operations of varying frequency and scope, as explained in the "
"following subsections."
msgstr ""
"Команды <xref linkend=\"sql-vacuum\"/> в <productname>PostgreSQL</"
"productname> должны обрабатывать каждую таблицу по следующим причинам: "
"<placeholder-1/> Разные причины диктуют выполнение действий <command>VACUUM</"
"command> с разной частотой и в разном объёме, как рассматривается в "
"следующих подразделах."

#: maintenance.xml:122(para)
msgid ""
"There are two variants of <command>VACUUM</command>: standard "
"<command>VACUUM</command> and <command>VACUUM FULL</command>. "
"<command>VACUUM FULL</command> can reclaim more disk space but runs much "
"more slowly. Also, the standard form of <command>VACUUM</command> can run in "
"parallel with production database operations. (Commands such as "
"<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</"
"command>, and <command>DELETE</command> will continue to function normally, "
"though you will not be able to modify the definition of a table with "
"commands such as <command>ALTER TABLE</command> while it is being vacuumed.) "
"<command>VACUUM FULL</command> requires exclusive lock on the table it is "
"working on, and therefore cannot be done in parallel with other use of the "
"table. Generally, therefore, administrators should strive to use standard "
"<command>VACUUM</command> and avoid <command>VACUUM FULL</command>."
msgstr ""
"Существует два варианта <command>VACUUM</command>: обычный <command>VACUUM</"
"command> и <command>VACUUM FULL</command>. Команда <command>VACUUM FULL</"
"command> может высвободить больше дискового пространства, однако работает "
"медленнее. Кроме того, обычная команда <command>VACUUM</command> может "
"выполняться параллельно с использованием производственной базы данных. (При "
"этом такие команды как <command>SELECT</command>, <command>INSERT</command>, "
"<command>UPDATE</command> и <command>DELETE</command> будут выполняться "
"нормально, хотя нельзя будет изменить определение таблицы командами типа "
"<command>ALTER TABLE</command>.) Команда <command>VACUUM FULL</command> "
"требует исключительной блокировки обрабатываемой таблицы и поэтому не может "
"выполняться параллельно с другими операциями с этой таблицей. По этой "
"причине администраторы, как правило, должны стараться использовать обычную "
"команду <command>VACUUM</command> и избегать <command>VACUUM FULL</command>."

#: maintenance.xml:139(para)
msgid ""
"<command>VACUUM</command> creates a substantial amount of I/O traffic, which "
"can cause poor performance for other active sessions. There are "
"configuration parameters that can be adjusted to reduce the performance "
"impact of background vacuuming &mdash; see <xref linkend=\"runtime-config-"
"resource-vacuum-cost\"/>."
msgstr ""
"Команда <command>VACUUM</command> порождает существенный объём трафика ввода/"
"вывода, который может стать причиной низкой производительности в других "
"активных сеансах. Это влияние фоновой очистки можно регулировать, настраивая "
"параметры конфигурации (см. <xref remap=\"4\" linkend=\"runtime-config-"
"resource-vacuum-cost\"/>)."

#: maintenance.xml:149(title)
msgid "Recovering Disk Space"
msgstr "Высвобождение дискового пространства"

#: maintenance.xml:151(indexterm)
msgid "<primary>disk space</primary>"
msgstr "<primary>дисковое пространство</primary>"

#: maintenance.xml:155(para)
msgid ""
"In <productname>PostgreSQL</productname>, an <command>UPDATE</command> or "
"<command>DELETE</command> of a row does not immediately remove the old "
"version of the row. This approach is necessary to gain the benefits of "
"multiversion concurrency control (<acronym>MVCC</acronym>, see <xref linkend="
"\"mvcc\"/>): the row version must not be deleted while it is still "
"potentially visible to other transactions. But eventually, an outdated or "
"deleted row version is no longer of interest to any transaction. The space "
"it occupies must then be reclaimed for reuse by new rows, to avoid unbounded "
"growth of disk space requirements. This is done by running <command>VACUUM</"
"command>."
msgstr ""
"В <productname>PostgreSQL</productname> команды <command>UPDATE</command> "
"или <command>DELETE</command> не вызывают немедленного удаления старой "
"версии изменяемых строк. Этот подход необходим для реализации эффективного "
"многоверсионного управления конкурентным доступом (<acronym>MVCC</acronym>, "
"см. <xref remap=\"4\" linkend=\"mvcc\"/>): версия строки не должна удаляться "
"до тех пор, пока она остаётся потенциально видимой для других транзакций. "
"Однако в конце концов устаревшая или удалённая версия строки оказывается не "
"нужна ни одной из транзакций. После этого занимаемое ей место должно быть "
"освобождено и может быть отдано новым строкам, во избежание неограниченного "
"роста потребности в дисковом пространстве. Это происходит при выполнении "
"команды <command>VACUUM</command>."

#: maintenance.xml:168(para)
msgid ""
"The standard form of <command>VACUUM</command> removes dead row versions in "
"tables and indexes and marks the space available for future reuse. However, "
"it will not return the space to the operating system, except in the special "
"case where one or more pages at the end of a table become entirely free and "
"an exclusive table lock can be easily obtained. In contrast, <command>VACUUM "
"FULL</command> actively compacts tables by writing a complete new version of "
"the table file with no dead space. This minimizes the size of the table, but "
"can take a long time. It also requires extra disk space for the new copy of "
"the table, until the operation completes."
msgstr ""
"Обычная форма <command>VACUUM</command> удаляет неиспользуемые версии строк "
"в таблицах и индексах и помечает пространство свободным для дальнейшего "
"использования. Однако это дисковое пространство не возвращается операционной "
"системе, кроме особого случая, когда полностью освобождаются одна или "
"несколько страниц в конце таблицы и можно легко получить исключительную "
"блокировку таблицы. Команда <command>VACUUM FULL</command>, напротив, "
"кардинально сжимает таблицы, записывая абсолютно новую версию файла таблицы "
"без неиспользуемого пространства. Это минимизирует размер таблицы, однако "
"может занять много времени. Кроме того, для этого требуется больше места на "
"диске для записи новой копии таблицы до завершения операции."

#: maintenance.xml:181(para)
msgid ""
"The usual goal of routine vacuuming is to do standard <command>VACUUM</"
"command>s often enough to avoid needing <command>VACUUM FULL</command>. The "
"autovacuum daemon attempts to work this way, and in fact will never issue "
"<command>VACUUM FULL</command>. In this approach, the idea is not to keep "
"tables at their minimum size, but to maintain steady-state usage of disk "
"space: each table occupies space equivalent to its minimum size plus however "
"much space gets used up between vacuumings. Although <command>VACUUM FULL</"
"command> can be used to shrink a table back to its minimum size and return "
"the disk space to the operating system, there is not much point in this if "
"the table will just grow again in the future. Thus, moderately-frequent "
"standard <command>VACUUM</command> runs are a better approach than "
"infrequent <command>VACUUM FULL</command> runs for maintaining heavily-"
"updated tables."
msgstr ""
"Обычно цель регулярной очистки — выполнять простую очистку (<command>VACUUM</"
"command>) достаточно часто, чтобы не возникала необходимость в "
"<command>VACUUM FULL</command>. Демон автоочистки пытается работать в этом "
"режиме, и на самом деле он сам никогда не выполняет <command>VACUUM FULL</"
"command>. Основная идея такого подхода не в том, чтобы минимизировать размер "
"таблиц, а в том, чтобы поддерживать использование дискового пространства на "
"стабильном уровне: каждая таблица занимает объём, равный её минимальному "
"размеру, плюс объём, который был занят между процедурами очистки. Хотя с "
"помощью <command>VACUUM FULL</command> можно сжать таблицу до минимума и "
"возвратить дисковое пространство операционной системе, большого смысла в "
"этом нет, если в будущем таблица так же вырастет снова. Следовательно, для "
"активно изменяемых таблиц лучше с умеренной частотой выполнять "
"<command>VACUUM</command>, чем очень редко выполнять <command>VACUUM FULL</"
"command>."

#: maintenance.xml:197(para)
msgid ""
"Some administrators prefer to schedule vacuuming themselves, for example "
"doing all the work at night when load is low. The difficulty with doing "
"vacuuming according to a fixed schedule is that if a table has an unexpected "
"spike in update activity, it may get bloated to the point that "
"<command>VACUUM FULL</command> is really necessary to reclaim space. Using "
"the autovacuum daemon alleviates this problem, since the daemon schedules "
"vacuuming dynamically in response to update activity. It is unwise to "
"disable the daemon completely unless you have an extremely predictable "
"workload. One possible compromise is to set the daemon's parameters so that "
"it will only react to unusually heavy update activity, thus keeping things "
"from getting out of hand, while scheduled <command>VACUUM</command>s are "
"expected to do the bulk of the work when the load is typical."
msgstr ""
"Некоторые администраторы предпочитают планировать очистку БД самостоятельно, "
"например, проводя все работы ночью в период низкой загрузки. Однако очистка "
"только по фиксированному расписанию плоха тем, что при резком скачке "
"интенсивности изменений таблица может разрастить настолько, что для "
"высвобождения пространства действительно понадобится выполнить "
"<command>VACUUM FULL</command>. Использование демона автоочистки снимает эту "
"проблему, поскольку он планирует очистку динамически, отслеживая "
"интенсивность изменений. Полностью отключать этот демон может иметь смысл, "
"только если вы имеете дело с предельно предсказуемой загрузкой. Возможен и "
"компромиссный вариант — настроить параметры демона автоочистки так, чтобы он "
"реагировал только на необычайно высокую интенсивность изменений и мог "
"удержать ситуацию под контролем, в то время как команды <command>VACUUM</"
"command>, запускаемые по расписанию, будут выполнять основную работу в "
"периоды нормальной загрузки."

#: maintenance.xml:213(para)
msgid ""
"For those not using autovacuum, a typical approach is to schedule a database-"
"wide <command>VACUUM</command> once a day during a low-usage period, "
"supplemented by more frequent vacuuming of heavily-updated tables as "
"necessary. (Some installations with extremely high update rates vacuum their "
"busiest tables as often as once every few minutes.) If you have multiple "
"databases in a cluster, don't forget to <command>VACUUM</command> each one; "
"the program <xref linkend=\"app-vacuumdb\"/> might be helpful."
msgstr ""
"Если же автоочистка не применяется, обычно планируется выполнение "
"<command>VACUUM</command> для всей базы данных раз в сутки в период низкой "
"активности, и в случае необходимости оно дополняется более частой очисткой "
"интенсивно изменяемых таблиц. (В некоторых ситуациях, когда изменения "
"производятся крайне интенсивно, самые востребованные таблицы могут очищаться "
"раз в несколько минут.) Если в вашем кластере несколько баз данных, не "
"забывайте выполнять <command>VACUUM</command> для каждой из них; при этом "
"может быть полезна программа <xref linkend=\"app-vacuumdb\"/>."

#: maintenance.xml:225(para)
msgid ""
"Plain <command>VACUUM</command> may not be satisfactory when a table "
"contains large numbers of dead row versions as a result of massive update or "
"delete activity. If you have such a table and you need to reclaim the excess "
"disk space it occupies, you will need to use <command>VACUUM FULL</command>, "
"or alternatively <xref linkend=\"sql-cluster\"/> or one of the table-"
"rewriting variants of <xref linkend=\"sql-altertable\"/>. These commands "
"rewrite an entire new copy of the table and build new indexes for it. All "
"these options require exclusive lock. Note that they also temporarily use "
"extra disk space approximately equal to the size of the table, since the old "
"copies of the table and indexes can't be released until the new ones are "
"complete."
msgstr ""
"Результат обычного <command>VACUUM</command> может быть "
"неудовлетворительным, когда вследствие массового изменения или удаления "
"строк в таблице оказывается много мёртвых версий строк. Если у вас есть "
"такая таблица и вам нужно освободить лишнее пространство, которое она "
"занимает, используйте команду <command>VACUUM FULL</command> или, в качестве "
"альтернативы, <xref linkend=\"sql-cluster\"/> или один из вариантов <xref "
"linkend=\"sql-altertable\"/>, выполняющий перезапись таблицы. Эти команды "
"записывают абсолютно новую копию таблицы и строят для неё индексы. Все эти "
"варианты требуют исключительной блокировки. Заметьте, что они также на время "
"требуют дополнительного пространства на диске в объёме, приблизительно "
"равном размеру таблицы, поскольку старые копии таблицы и индексов нельзя "
"удалить до завершения создания новых копий."

#: maintenance.xml:243(para)
msgid ""
"If you have a table whose entire contents are deleted on a periodic basis, "
"consider doing it with <xref linkend=\"sql-truncate\"/> rather than using "
"<command>DELETE</command> followed by <command>VACUUM</command>. "
"<command>TRUNCATE</command> removes the entire content of the table "
"immediately, without requiring a subsequent <command>VACUUM</command> or "
"<command>VACUUM FULL</command> to reclaim the now-unused disk space. The "
"disadvantage is that strict MVCC semantics are violated."
msgstr ""
"Если у вас есть таблица, всё содержимое которой периодически удаляется, "
"рассмотрите возможность использования <xref linkend=\"sql-truncate\"/> "
"вместо <command>DELETE</command> с последующей командой <command>VACUUM</"
"command>. <command>TRUNCATE</command> немедленно удаляет всё содержимое "
"таблицы, не требуя последующей очистки (<command>VACUUM</command> или "
"<command>VACUUM FULL</command>) для высвобождения неиспользуемого дискового "
"пространства. Недостатком такого подхода является нарушение строгой "
"семантики MVCC."

#: maintenance.xml:258(title)
msgid "Updating Planner Statistics"
msgstr "Обновление статистики планировщика"

#: maintenance.xml:260(indexterm)
msgid "<primary>statistics</primary> <secondary>of the planner</secondary>"
msgstr "<primary>статистика</primary> <secondary>планировщика</secondary>"

#: maintenance.xml:265(indexterm)
msgid "<primary>ANALYZE</primary>"
msgstr "<primary>ANALYZE</primary>"

#: maintenance.xml:269(para)
msgid ""
"The <productname>PostgreSQL</productname> query planner relies on "
"statistical information about the contents of tables in order to generate "
"good plans for queries. These statistics are gathered by the <xref linkend="
"\"sql-analyze\"/> command, which can be invoked by itself or as an optional "
"step in <command>VACUUM</command>. It is important to have reasonably "
"accurate statistics, otherwise poor choices of plans might degrade database "
"performance."
msgstr ""
"Планировщик запросов в <productname>PostgreSQL</productname>, выбирая "
"эффективные планы запросов, полагается на статистическую информацию о "
"содержимом таблиц. Эта статистика собирается командой <xref linkend=\"sql-"
"analyze\"/>, которая может вызываться сама по себе или как дополнительное "
"действие команды <command>VACUUM</command>. Статистика должна быть "
"достаточно точной, так как в противном случае неудачно выбранные планы "
"запросов могут снизить производительность базы данных."

#: maintenance.xml:280(para)
msgid ""
"The autovacuum daemon, if enabled, will automatically issue "
"<command>ANALYZE</command> commands whenever the content of a table has "
"changed sufficiently. However, administrators might prefer to rely on "
"manually-scheduled <command>ANALYZE</command> operations, particularly if it "
"is known that update activity on a table will not affect the statistics of "
"<quote>interesting</quote> columns. The daemon schedules <command>ANALYZE</"
"command> strictly as a function of the number of rows inserted or updated; "
"it has no knowledge of whether that will lead to meaningful statistical "
"changes."
msgstr ""
"Демон автоочистки, если он включён, будет автоматически выполнять "
"<command>ANALYZE</command> после существенных изменений содержимого таблицы. "
"Однако администраторы могут предпочесть выполнение <command>ANALYZE</"
"command> вручную, в частности, если известно, что производимые в таблице "
"изменения не повлияют на статистику по <quote>интересным</quote> столбцам. "
"Демон же планирует выполнение <command>ANALYZE</command> в зависимости "
"только от количества вставленных или изменённых строк; он не знает, приведут "
"ли они к значимым изменениям статистики."

#: maintenance.xml:292(para)
msgid ""
"As with vacuuming for space recovery, frequent updates of statistics are "
"more useful for heavily-updated tables than for seldom-updated ones. But "
"even for a heavily-updated table, there might be no need for statistics "
"updates if the statistical distribution of the data is not changing much. A "
"simple rule of thumb is to think about how much the minimum and maximum "
"values of the columns in the table change. For example, a <type>timestamp</"
"type> column that contains the time of row update will have a constantly-"
"increasing maximum value as rows are added and updated; such a column will "
"probably need more frequent statistics updates than, say, a column "
"containing URLs for pages accessed on a website. The URL column might "
"receive changes just as often, but the statistical distribution of its "
"values probably changes relatively slowly."
msgstr ""
"Как и процедура очистки для высвобождения пространства, частое обновление "
"статистики полезнее для интенсивно изменяемых таблиц, нежели для тех таблиц, "
"которые изменяются редко. Однако даже в случае часто изменяемой таблицы "
"обновление статистики может не требоваться, если статистическое "
"распределение данных меняется слабо. Как правило, достаточно оценить, "
"насколько меняются максимальное и минимальное значения в столбцах таблицы. "
"Например, максимальное значение в столбце <type>timestamp</type>, хранящем "
"время изменения строки, будет постоянно увеличиваться по мере добавления и "
"изменения строк; для такого столбца может потребоваться более частое "
"обновление статистики, чем, к примеру, для столбца, содержащего адреса "
"страниц (URL), которые запрашивались с сайта. Столбец с URL-адресами может "
"меняться столь же часто, однако статистическое распределение его значений, "
"вероятно, будет изменяться относительно медленно."

#: maintenance.xml:308(para)
msgid ""
"It is possible to run <command>ANALYZE</command> on specific tables and even "
"just specific columns of a table, so the flexibility exists to update some "
"statistics more frequently than others if your application requires it. In "
"practice, however, it is usually best to just analyze the entire database, "
"because it is a fast operation. <command>ANALYZE</command> uses a "
"statistically random sampling of the rows of a table rather than reading "
"every single row."
msgstr ""
"Команду <command>ANALYZE</command> можно выполнять для отдельных таблиц и "
"даже просто для отдельных столбцов таблицы, поэтому, если того требует "
"приложение, одни статистические данные можно обновлять чаще, чем другие. "
"Однако на практике обычно лучше просто анализировать всю базу данных, "
"поскольку это быстрая операция, так как <command>ANALYZE</command> читает не "
"каждую отдельную строку, а статистически случайную выборку строк таблицы."

#: maintenance.xml:319(para)
msgid ""
"Although per-column tweaking of <command>ANALYZE</command> frequency might "
"not be very productive, you might find it worthwhile to do per-column "
"adjustment of the level of detail of the statistics collected by "
"<command>ANALYZE</command>. Columns that are heavily used in <literal>WHERE</"
"literal> clauses and have highly irregular data distributions might require "
"a finer-grain data histogram than other columns. See <command>ALTER TABLE "
"SET STATISTICS</command>, or change the database-wide default using the "
"<xref linkend=\"guc-default-statistics-target\"/> configuration parameter."
msgstr ""
"Хотя индивидуальная настройка частоты <command>ANALYZE</command> для "
"отдельных столбцов может быть не очень полезной, смысл может иметь настройка "
"детализации статистики, собираемой командой <command>ANALYZE</command>. Для "
"столбцов, которые часто используются в предложениях <literal>WHERE</"
"literal>, и имеют очень неравномерное распределение данных, может "
"потребоваться более детальная, по сравнению с другими столбцами, гистограмма "
"данных. В таких случаях можно воспользоваться командой <command>ALTER TABLE "
"SET STATISTICS</command> или изменить значение по умолчанию параметра уровня "
"БД <xref linkend=\"guc-default-statistics-target\"/>."

#: maintenance.xml:330(para)
msgid ""
"Also, by default there is limited information available about the "
"selectivity of functions. However, if you create an expression index that "
"uses a function call, useful statistics will be gathered about the function, "
"which can greatly improve query plans that use the expression index."
msgstr ""
"Кроме того, по умолчанию информация об избирательности функций ограничена. "
"Однако если вы создаёте индекс по выражению с вызовом функции, об этой "
"функции будет собрана полезная статистическая информация, которая может "
"значительно улучшить планы запросов, в которых используется данный индекс."

#: maintenance.xml:340(para)
msgid ""
"The autovacuum daemon does not issue <command>ANALYZE</command> commands for "
"foreign tables, since it has no means of determining how often that might be "
"useful. If your queries require statistics on foreign tables for proper "
"planning, it's a good idea to run manually-managed <command>ANALYZE</"
"command> commands on those tables on a suitable schedule."
msgstr ""
"Демон автоочистки не выполняет команды <command>ANALYZE</command> для "
"сторонних таблиц, поскольку он не знает, как часто это следует делать. Если "
"для получения качественных планов вашим запросам необходима статистика по "
"сторонним таблицам, будет хорошей идеей дополнительно запускать "
"<command>ANALYZE</command> для них по подходящему расписанию."

#: maintenance.xml:351(title)
msgid "Updating The Visibility Map"
msgstr "Обновление карты видимости"

#: maintenance.xml:353(para)
msgid ""
"Vacuum maintains a <link linkend=\"storage-vm\">visibility map</link> for "
"each table to keep track of which pages contain only tuples that are known "
"to be visible to all active transactions (and all future transactions, until "
"the page is again modified). This has two purposes. First, vacuum itself can "
"skip such pages on the next run, since there is nothing to clean up."
msgstr ""
"Процедура очистки поддерживает <link linkend=\"storage-vm\">карты видимости</"
"link> для каждой таблицы, позволяющие определить, в каких страницах есть "
"только записи, заведомо видимые для всех активных транзакций (и всех будущих "
"транзакций, пока страница не будет изменена). Это имеет два применения. Во-"
"первых, сам процесс очистки может пропускать такие страницы при следующем "
"запуске, поскольку на этих страницах вычищать нечего."

#: maintenance.xml:362(para)
msgid ""
"Second, it allows <productname>PostgreSQL</productname> to answer some "
"queries using only the index, without reference to the underlying table. "
"Since <productname>PostgreSQL</productname> indexes don't contain tuple "
"visibility information, a normal index scan fetches the heap tuple for each "
"matching index entry, to check whether it should be seen by the current "
"transaction. An <link linkend=\"indexes-index-only-scans\"><firstterm>index-"
"only scan</firstterm></link>, on the other hand, checks the visibility map "
"first. If it's known that all tuples on the page are visible, the heap fetch "
"can be skipped. This is most useful on large data sets where the visibility "
"map can prevent disk accesses. The visibility map is vastly smaller than the "
"heap, so it can easily be cached even when the heap is very large."
msgstr ""
"Во-вторых, с такими картами <productname>PostgreSQL</productname> может "
"выдавать результаты некоторых запросов, используя только индекс, не "
"обращаясь к данным таблицы. Так как индексы <productname>PostgreSQL</"
"productname> не содержат информацию о видимости записей, при обычном "
"сканировании по индексу необходимо извлечь соответствующую запись из таблицы "
"и проверить её видимость для текущей транзакции. Поэтому при <link linkend="
"\"indexes-index-only-scans\"><firstterm>сканировании только индекса</"
"firstterm></link>, наоборот, сначала проверяется карта видимости. Если "
"известно, что все записи на странице видимы, то выборку из таблицы можно "
"пропустить. Это наиболее полезно с большими наборах данных, когда благодаря "
"карте видимости можно оптимизировать чтение с диска. Карта видимости "
"значительно меньше таблицы, поэтому она легко помещается в кеш, даже когда "
"объём самих страниц очень велик."

#: maintenance.xml:380(title)
msgid "Preventing Transaction ID Wraparound Failures"
msgstr "Предотвращение ошибок из-за зацикливания счётчика транзакций"

#: maintenance.xml:382(indexterm)
msgid "<primary>transaction ID</primary> <secondary>wraparound</secondary>"
msgstr ""
"<primary>идентификатор транзакции</primary> <secondary>зацикливание</"
"secondary>"

#: maintenance.xml:387(indexterm)
msgid "<primary>wraparound</primary> <secondary>of transaction IDs</secondary>"
msgstr ""
"<primary>зацикливание</primary> <secondary>идентификаторов транзакций</"
"secondary>"

#: maintenance.xml:392(para)
msgid ""
"<productname>PostgreSQL</productname>'s <link linkend=\"mvcc-intro\">MVCC</"
"link> transaction semantics depend on being able to compare transaction ID "
"(<acronym>XID</acronym>) numbers: a row version with an insertion XID "
"greater than the current transaction's XID is <quote>in the future</quote> "
"and should not be visible to the current transaction. But since transaction "
"IDs have limited size (32 bits) a cluster that runs for a long time (more "
"than 4 billion transactions) would suffer <firstterm>transaction ID "
"wraparound</firstterm>: the XID counter wraps around to zero, and all of a "
"sudden transactions that were in the past appear to be in the future &mdash; "
"which means their output become invisible. In short, catastrophic data loss. "
"(Actually the data is still there, but that's cold comfort if you cannot get "
"at it.) To avoid this, it is necessary to vacuum every table in every "
"database at least once every two billion transactions."
msgstr ""
"В <productname>PostgreSQL</productname> семантика транзакций <link linkend="
"\"mvcc-intro\">MVCC</link> зависит от возможности сравнения номеров "
"идентификаторов транзакций (<acronym>XID</acronym>): версия строки, у "
"которой XID добавившей её транзакции больше, чем XID текущей транзакции, "
"относится <quote>к будущему</quote> и не должна быть видна в текущей "
"транзакции. Однако поскольку идентификаторы транзакций имеют ограниченный "
"размер (32 бита), кластер, работающий долгое время (более 4 миллиардов "
"транзакций) столкнётся с <firstterm>зацикливанием идентификаторов "
"транзакций</firstterm>: счётчик XID прокрутится до нуля, и внезапно "
"транзакции, которые относились к прошлому, окажутся в будущем &mdash; это "
"означает, что их результаты станут невидимыми. Одним словом, это "
"катастрофическая потеря данных. (На самом деле данные никуда не пропадают, "
"однако если вы не можете их получить, то это слабое утешение.) Для того "
"чтобы этого избежать, необходимо выполнять очистку для каждой таблицы в "
"каждой базе данных как минимум единожды на два миллиардов транзакций."

#: maintenance.xml:409(para)
msgid ""
"The reason that periodic vacuuming solves the problem is that "
"<command>VACUUM</command> will mark rows as <emphasis>frozen</emphasis>, "
"indicating that they were inserted by a transaction that committed "
"sufficiently far in the past that the effects of the inserting transaction "
"are certain to be visible to all current and future transactions. Normal "
"XIDs are compared using modulo-2<superscript>32</superscript> arithmetic. "
"This means that for every normal XID, there are two billion XIDs that are "
"<quote>older</quote> and two billion that are <quote>newer</quote>; another "
"way to say it is that the normal XID space is circular with no endpoint. "
"Therefore, once a row version has been created with a particular normal XID, "
"the row version will appear to be <quote>in the past</quote> for the next "
"two billion transactions, no matter which normal XID we are talking about. "
"If the row version still exists after more than two billion transactions, it "
"will suddenly appear to be in the future. To prevent this, "
"<productname>PostgreSQL</productname> reserves a special XID, "
"<literal>FrozenTransactionId</literal>, which does not follow the normal XID "
"comparison rules and is always considered older than every normal XID. "
"Frozen row versions are treated as if the inserting XID were "
"<literal>FrozenTransactionId</literal>, so that they will appear to be "
"<quote>in the past</quote> to all normal transactions regardless of "
"wraparound issues, and so such row versions will be valid until deleted, no "
"matter how long that is."
msgstr ""
"Периодическое выполнение очистки решает эту проблему, потому что процедура "
"<command>VACUUM</command> помечает строки как <emphasis>замороженные</"
"emphasis>, указывая, что они были вставлены транзакцией, зафиксированной "
"достаточно давно, так что эффект добавляющей транзакции с точки зрения MVCC "
"определённо будет виден во всех текущих и будущих транзакциях. Обычные "
"значения XID сравниваются по модулю 2<superscript>32</superscript>. Это "
"означает, что для каждого обычного XID существуют два миллиарда значений "
"XID, которые <quote>старше</quote> него, и два миллиарда значений, которые "
"<quote>младше</quote> него; другими словами, пространство значений XID "
"циклично и не имеет конечной точки. Следовательно, как только создаётся "
"версия строки с обычным XID, для следующих двух миллиардов транзакций эта "
"версия строки оказывается <quote>в прошлом</quote>, неважно о каком значении "
"обычного XID идет речь. Если после двух миллиардов транзакций эта версия "
"строки всё ещё существует, она внезапно окажется в будущем. Для того чтобы "
"это предотвратить, в какой-то момент значение XID для старых версий строк "
"должно быть заменено на <literal>FrozenTransactionId</literal> (заморожено) "
"до того, как будет достигнута граница в два миллиарда транзакций. После "
"получения этого особенного XID для всех обычных транзакций эти версии строк "
"будут относиться <quote>к прошлому</quote>, независимо от зацикливания, и, "
"таким образом, эти версии строк будут действительны до момента их удаления, "
"когда бы это ни произошло."

#: maintenance.xml:437(para)
msgid ""
"In <productname>PostgreSQL</productname> versions before 9.4, freezing was "
"implemented by actually replacing a row's insertion XID with "
"<literal>FrozenTransactionId</literal>, which was visible in the row's "
"<structname>xmin</structname> system column. Newer versions just set a flag "
"bit, preserving the row's original <structname>xmin</structname> for "
"possible forensic use. However, rows with <structname>xmin</structname> "
"equal to <literal>FrozenTransactionId</literal> (2) may still be found in "
"databases <application>pg_upgrade</application>'d from pre-9.4 versions."
msgstr ""
"В версиях <productname>PostgreSQL</productname> до 9.4 замораживание было "
"реализовано как замена XID добавления строки специальным идентификатором "
"<literal>FrozenTransactionId</literal>, который можно было увидеть в "
"системной колонке <structname>xmin</structname> данной строки. В новых "
"версиях просто устанавливается битовый флаг, а исходный <structname>xmin</"
"structname> строки сохраняется для возможного расследования в будущем. "
"Однако строки с <structname>xmin</structname>, равным "
"<literal>FrozenTransactionId</literal> (2), можно по-прежнему встретить в "
"базах данных, обновлённых (с применением <application>pg_upgrade</"
"application>) с версий до 9.4."

#: maintenance.xml:447(para)
msgid ""
"Also, system catalogs may contain rows with <structname>xmin</structname> "
"equal to <literal>BootstrapTransactionId</literal> (1), indicating that they "
"were inserted during the first phase of <application>initdb</application>. "
"Like <literal>FrozenTransactionId</literal>, this special XID is treated as "
"older than every normal XID."
msgstr ""
"Также системные каталоги могут содержать строки со значением "
"<structname>xmin</structname>, равным <literal>BootstrapTransactionId</"
"literal> (1), показывающим, что они были вставлены на первом этапе "
"<application>initdb</application>. Как и <literal>FrozenTransactionId</"
"literal>, этот специальный XID считается более старым, чем любой обычный XID."

#: maintenance.xml:456(para)
msgid ""
"<xref linkend=\"guc-vacuum-freeze-min-age\"/> controls how old an XID value "
"has to be before rows bearing that XID will be frozen. Increasing this "
"setting may avoid unnecessary work if the rows that would otherwise be "
"frozen will soon be modified again, but decreasing this setting increases "
"the number of transactions that can elapse before the table must be vacuumed "
"again."
msgstr ""
"Параметр <xref linkend=\"guc-vacuum-freeze-min-age\"/> определяет, насколько "
"старым должен стать XID, чтобы строки с таким XID были заморожены. "
"Увеличение его значения помогает избежать ненужной работы, если строки, "
"которые могли бы быть заморожены в ближайшее время, будут изменены ещё раз, "
"а уменьшение приводит к увеличению количества транзакций, которые могут "
"выполниться, прежде чем потребуется очередная очистка таблицы."

#: maintenance.xml:466(para)
msgid ""
"<command>VACUUM</command> uses the <link linkend=\"storage-vm\">visibility "
"map</link> to determine which pages of a table must be scanned. Normally, it "
"will skip pages that don't have any dead row versions even if those pages "
"might still have row versions with old XID values. Therefore, normal "
"<command>VACUUM</command>s won't always freeze every old row version in the "
"table. Periodically, <command>VACUUM</command> will perform an "
"<firstterm>aggressive vacuum</firstterm>, skipping only those pages which "
"contain neither dead rows nor any unfrozen XID or MXID values. <xref linkend="
"\"guc-vacuum-freeze-table-age\"/> controls when <command>VACUUM</command> "
"does that: all-visible but not all-frozen pages are scanned if the number of "
"transactions that have passed since the last such scan is greater than "
"<varname>vacuum_freeze_table_age</varname> minus "
"<varname>vacuum_freeze_min_age</varname>. Setting "
"<varname>vacuum_freeze_table_age</varname> to 0 forces <command>VACUUM</"
"command> to use this more aggressive strategy for all scans."
msgstr ""
"<command>VACUUM</command> определяет, какие страницы таблицы нужно "
"сканировать, анализируя <link linkend=\"storage-vm\">карту видимости</link>. "
"Обычно при этой операции пропускаются страницы, в которых нет мёртвых версий "
"строк, даже если в них могут быть версии строк со старыми XID. Таким "
"образом, обычная команда <command>VACUUM</command> не будет всегда "
"замораживать все версии строк, имеющиеся в таблице. Периодически "
"<command>VACUUM</command> будет также производить <firstterm>агрессивную "
"очистку</firstterm>, пропуская только те страницы, которые не содержат ни "
"мёртвых строк, ни незамороженных значений XID или MXID. Когда "
"<command>VACUUM</command> будет делать это, зависит от параметра <xref "
"linkend=\"guc-vacuum-freeze-table-age\"/>: полностью видимые, но не "
"полностью замороженные страницы будут сканироваться, если число транзакций, "
"прошедших со времени последнего такого сканирования, оказывается больше чем "
"<varname>vacuum_freeze_table_age</varname> минус "
"<varname>vacuum_freeze_min_age</varname>. Если "
"<varname>vacuum_freeze_table_age</varname> равно 0, <command>VACUUM</"
"command> будет применять эту более агрессивную стратегию при каждом "
"сканировании."

#: maintenance.xml:484(para)
msgid ""
"The maximum time that a table can go unvacuumed is two billion transactions "
"minus the <varname>vacuum_freeze_min_age</varname> value at the time of the "
"last aggressive vacuum. If it were to go unvacuumed for longer than that, "
"data loss could result. To ensure that this does not happen, autovacuum is "
"invoked on any table that might contain unfrozen rows with XIDs older than "
"the age specified by the configuration parameter <xref linkend=\"guc-"
"autovacuum-freeze-max-age\"/>. (This will happen even if autovacuum is "
"disabled.)"
msgstr ""
"Максимальное время, в течение которого таблица может обходиться без очистки, "
"составляет два миллиарда транзакций минус значение "
"<varname>vacuum_freeze_min_age</varname> с момента последней агрессивной "
"очистки. Если бы таблица не подвергалась очистке дольше, была бы возможна "
"потеря данных. Чтобы гарантировать, что это не произойдёт, для любой "
"таблицы, которая может содержать значения XID старше, чем возраст, указанный "
"в конфигурационном параметре <xref linkend=\"guc-autovacuum-freeze-max-age\"/"
">, вызывается автоочистка. (Это случится, даже если автоочистка отключена.)"

#: maintenance.xml:496(para)
msgid ""
"This implies that if a table is not otherwise vacuumed, autovacuum will be "
"invoked on it approximately once every <varname>autovacuum_freeze_max_age</"
"varname> minus <varname>vacuum_freeze_min_age</varname> transactions. For "
"tables that are regularly vacuumed for space reclamation purposes, this is "
"of little importance. However, for static tables (including tables that "
"receive inserts, but no updates or deletes), there is no need to vacuum for "
"space reclamation, so it can be useful to try to maximize the interval "
"between forced autovacuums on very large static tables. Obviously one can do "
"this either by increasing <varname>autovacuum_freeze_max_age</varname> or "
"decreasing <varname>vacuum_freeze_min_age</varname>."
msgstr ""
"Это означает, что если очистка таблицы не вызывается другим способом, то "
"автоочистка для неё будет вызываться приблизительно через каждые "
"<varname>autovacuum_freeze_max_age</varname> минус "
"<varname>vacuum_freeze_min_age</varname> транзакций. Для таблиц, очищаемых "
"регулярно для высвобождения пространства, это неактуально. В то же время "
"статичные таблицы (включая таблицы, в которых данные вставляются, но не "
"изменяются и не удаляются) не нуждаются в очистке для высвобождения "
"пространства, поэтому для очень больших статичных таблиц имеет смысл "
"увеличить интервал между вынужденными запусками автоочистки. Очевидно, это "
"можно сделать, либо увеличив <varname>autovacuum_freeze_max_age</varname>, "
"либо уменьшив <varname>vacuum_freeze_min_age</varname>."

#: maintenance.xml:511(para)
msgid ""
"The effective maximum for <varname>vacuum_freeze_table_age</varname> is 0.95 "
"* <varname>autovacuum_freeze_max_age</varname>; a setting higher than that "
"will be capped to the maximum. A value higher than "
"<varname>autovacuum_freeze_max_age</varname> wouldn't make sense because an "
"anti-wraparound autovacuum would be triggered at that point anyway, and the "
"0.95 multiplier leaves some breathing room to run a manual <command>VACUUM</"
"command> before that happens. As a rule of thumb, "
"<command>vacuum_freeze_table_age</command> should be set to a value somewhat "
"below <varname>autovacuum_freeze_max_age</varname>, leaving enough gap so "
"that a regularly scheduled <command>VACUUM</command> or an autovacuum "
"triggered by normal delete and update activity is run in that window. "
"Setting it too close could lead to anti-wraparound autovacuums, even though "
"the table was recently vacuumed to reclaim space, whereas lower values lead "
"to more frequent aggressive vacuuming."
msgstr ""
"Фактический максимум для <varname>vacuum_freeze_table_age</varname> "
"составляет 0.95 * <varname>autovacuum_freeze_max_age</varname>; большее "
"значение будет ограничено этим пределом. Значение, превышающее "
"<varname>autovacuum_freeze_max_age</varname>, не имело бы смысла, поскольку "
"по достижении этого значения в любом случае вызывалась бы автоочистка для "
"предотвращения зацикливания, а коэффициент 0.95 оставляет немного времени "
"для того, чтобы запустить команду <command>VACUUM</command> вручную до того, "
"как это произойдёт. Как правило, установленное значение "
"<command>vacuum_freeze_table_age</command> должно быть несколько меньше "
"<varname>autovacuum_freeze_max_age</varname>, чтобы оставленный промежуток "
"был достаточен для выполнения в этом окне <command>VACUUM</command> по "
"расписанию или автоочистки, управляемой обычной активностью операций "
"удаления и изменения. Если это значение будет слишком близким к максимуму, "
"автоочистка для предотвращения зацикливания будет выполняться, даже если "
"таблица только что была очищена для высвобождения пространства, в то же "
"время при небольшом значении будет чаще производиться агрессивная очистка."

#: maintenance.xml:528(para)
msgid ""
"The sole disadvantage of increasing <varname>autovacuum_freeze_max_age</"
"varname> (and <varname>vacuum_freeze_table_age</varname> along with it) is "
"that the <filename>pg_clog</filename> subdirectory of the database cluster "
"will take more space, because it must store the commit status of all "
"transactions back to the <varname>autovacuum_freeze_max_age</varname> "
"horizon. The commit status uses two bits per transaction, so if "
"<varname>autovacuum_freeze_max_age</varname> is set to its maximum allowed "
"value of two billion, <filename>pg_clog</filename> can be expected to grow "
"to about half a gigabyte. If this is trivial compared to your total database "
"size, setting <varname>autovacuum_freeze_max_age</varname> to its maximum "
"allowed value is recommended. Otherwise, set it depending on what you are "
"willing to allow for <filename>pg_clog</filename> storage. (The default, 200 "
"million transactions, translates to about 50MB of <filename>pg_clog</"
"filename> storage.)"
msgstr ""
"Единственный минус увеличения <varname>autovacuum_freeze_max_age</varname> "
"(и <varname>vacuum_freeze_table_age</varname> с ним) заключается в том, что "
"подкаталог <filename>pg_clog</filename> в кластере базы данных будет "
"занимать больше места, поскольку в нём нужно будет хранить статус фиксации "
"всех транзакций вплоть до горизонта <varname>autovacuum_freeze_max_age</"
"varname>. Для статуса фиксации используется по два бита на транзакцию, "
"поэтому если в <varname>autovacuum_freeze_max_age</varname> установлено "
"максимально допустимое значение в два миллиарда, то размер "
"<filename>pg_clog</filename> может составить примерно половину гигабайта. "
"Если по сравнению с объёмом вашей базы данных этот объём незначителен, тогда "
"рекомендуется установить для <varname>autovacuum_freeze_max_age</varname> "
"максимально допустимое значение. В противном случае, установите значение "
"этого параметра в зависимости от объёма, который вы готовы выделить для "
"<filename>pg_clog</filename>. (Значению по умолчанию, 200 миллионам "
"транзакций, соответствует приблизительно 50 Мб в <filename>pg_clog</"
"filename>.)"

#: maintenance.xml:545(para)
msgid ""
"One disadvantage of decreasing <varname>vacuum_freeze_min_age</varname> is "
"that it might cause <command>VACUUM</command> to do useless work: freezing a "
"row version is a waste of time if the row is modified soon thereafter "
"(causing it to acquire a new XID). So the setting should be large enough "
"that rows are not frozen until they are unlikely to change any more."
msgstr ""
"Уменьшение значения <varname>vacuum_freeze_min_age</varname>, с другой "
"стороны, чревато тем, что команда <command>VACUUM</command> может выполнять "
"бесполезную работу: замораживание версии строки — пустая трата времени, если "
"эта строка будет вскоре изменена (и в результате получит новый XID). Поэтому "
"значение этого параметра должно быть достаточно большим для того, чтобы "
"строки не замораживались, пока их последующее изменение не станет "
"маловероятным."

#: maintenance.xml:571(programlisting)
#, no-wrap
msgid ""
"SELECT c.oid::regclass as table_name,\n"
"       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age\n"
"FROM pg_class c\n"
"LEFT JOIN pg_class t ON c.reltoastrelid = t.oid\n"
"WHERE c.relkind IN ('r', 'm');\n"
"\n"
"SELECT datname, age(datfrozenxid) FROM pg_database;"
msgstr ""
"SELECT c.oid::regclass as table_name,\n"
"       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age\n"
"FROM pg_class c\n"
"LEFT JOIN pg_class t ON c.reltoastrelid = t.oid\n"
"WHERE c.relkind IN ('r', 'm');\n"
"\n"
"SELECT datname, age(datfrozenxid) FROM pg_database;"

#: maintenance.xml:554(para)
msgid ""
"To track the age of the oldest unfrozen XIDs in a database, <command>VACUUM</"
"command> stores XID statistics in the system tables <structname>pg_class</"
"structname> and <structname>pg_database</structname>. In particular, the "
"<structfield>relfrozenxid</structfield> column of a table's "
"<structname>pg_class</structname> row contains the freeze cutoff XID that "
"was used by the last aggressive <command>VACUUM</command> for that table. "
"All rows inserted by transactions with XIDs older than this cutoff XID are "
"guaranteed to have been frozen. Similarly, the <structfield>datfrozenxid</"
"structfield> column of a database's <structname>pg_database</structname> row "
"is a lower bound on the unfrozen XIDs appearing in that database &mdash; it "
"is just the minimum of the per-table <structfield>relfrozenxid</structfield> "
"values within the database. A convenient way to examine this information is "
"to execute queries such as: <placeholder-1/> The <literal>age</literal> "
"column measures the number of transactions from the cutoff XID to the "
"current transaction's XID."
msgstr ""
"Для отслеживания возраста самых старых значений XID в базе данных команда "
"<command>VACUUM</command> сохраняет статистику по XID в системных таблицах "
"<structname>pg_class</structname> и <structname>pg_database</structname>. В "
"частности, столбец <structfield>relfrozenxid</structfield> в записи для "
"определённой таблицы в <structname>pg_class</structname> содержит граничное "
"значение XID, с которым в последний раз выполнялась агрессивная очистка "
"(<command>VACUUM</command>) этой таблицы. Все строки, добавленные "
"транзакциями с более ранними XID, гарантированно будут заморожены. "
"Аналогично столбец <structfield>datfrozenxid</structfield> в записи для базы "
"данных в <structname>pg_database</structname> представляет нижнюю границу "
"обычных значений XID, встречающихся в этой базе &mdash; он просто хранит "
"минимальное из всех значений <structfield>relfrozenxid</structfield> для "
"таблиц этой базы. Эту информацию удобно получать с помощью таких запросов: "
"<placeholder-1/> Столбец <literal>age</literal> показывает количество "
"транзакций от граничного значения XID до XID текущей транзакции."

#: maintenance.xml:585(para)
msgid ""
"<command>VACUUM</command> normally only scans pages that have been modified "
"since the last vacuum, but <structfield>relfrozenxid</structfield> can only "
"be advanced when every page of the table that might contain unfrozen XIDs is "
"scanned. This happens when <structfield>relfrozenxid</structfield> is more "
"than <varname>vacuum_freeze_table_age</varname> transactions old, when "
"<command>VACUUM</command>'s <literal>FREEZE</literal> option is used, or "
"when all pages that are not already all-frozen happen to require vacuuming "
"to remove dead row versions. When <command>VACUUM</command> scans every page "
"in the table that is not already all-frozen, it should set "
"<literal>age(relfrozenxid)</literal> to a value just a little more than the "
"<varname>vacuum_freeze_min_age</varname> setting that was used (more by the "
"number of transcations started since the <command>VACUUM</command> started). "
"If no <structfield>relfrozenxid</structfield>-advancing <command>VACUUM</"
"command> is issued on the table until <varname>autovacuum_freeze_max_age</"
"varname> is reached, an autovacuum will soon be forced for the table."
msgstr ""
"Обычно <command>VACUUM</command> сканирует только те страницы, которые "
"изменялись после последней очистки, однако <structfield>relfrozenxid</"
"structfield> может увеличиться только при сканировании всех страниц таблицы, "
"включая те, что могут содержать незамороженные XID. Это происходит когда "
"возраст <structfield>relfrozenxid</structfield> достигает "
"<varname>vacuum_freeze_table_age</varname> транзакций, когда "
"<command>VACUUM</command> вызывается с указанием <literal>FREEZE</literal>, "
"или когда оказывается, что очистку для удаления мёртвых версий строк нужно "
"провести во всех ещё не замороженных страницах. Когда <command>VACUUM</"
"command> сканирует в таблице каждую ещё не полностью замороженную страницу, "
"значение <literal>age(relfrozenxid)</literal> в результате должно стать "
"немного больше, чем установленное значение <varname>vacuum_freeze_min_age</"
"varname> (больше на число транзакций, начатых с момента запуска "
"<command>VACUUM</command>). Если по достижении "
"<varname>autovacuum_freeze_max_age</varname> для таблицы ни разу не будет "
"выполнена операция <structfield>relfrozenxid</structfield>, в скором времени "
"для неё будет принудительно запущена автоочистка."

#: maintenance.xml:611(programlisting)
#, no-wrap
msgid ""
"WARNING:  database \"mydb\" must be vacuumed within 177009986 transactions\n"
"HINT:  To avoid a database shutdown, execute a database-wide VACUUM in \"mydb\"."
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ:  база данных \"mydb\" должна быть очищена (предельное число транзакций: 177009986)\n"
"ПОДСКАЗКА:  Во избежание отключения базы данных выполните очистку (VACUUM) всей базы \"mydb\"."

#: maintenance.xml:625(programlisting)
#, no-wrap
msgid ""
"ERROR:  database is not accepting commands to avoid wraparound data loss in database \"mydb\"\n"
"HINT:  Stop the postmaster and vacuum that database in single-user mode."
msgstr ""
"ОШИБКА:  база данных не принимает команды во избежание потери данных из-за зацикливания в БД \"mydb\"\n"
"ПОДСКАЗКА:  Остановите управляющий процесс (postmaster) и выполните очистку (VACUUM) базы данных в однопользовательском режиме."

#: maintenance.xml:605(para)
msgid ""
"If for some reason autovacuum fails to clear old XIDs from a table, the "
"system will begin to emit warning messages like this when the database's "
"oldest XIDs reach ten million transactions from the wraparound point: "
"<placeholder-1/> (A manual <command>VACUUM</command> should fix the problem, "
"as suggested by the hint; but note that the <command>VACUUM</command> must "
"be performed by a superuser, else it will fail to process system catalogs "
"and thus not be able to advance the database's <structfield>datfrozenxid</"
"structfield>.) If these warnings are ignored, the system will shut down and "
"refuse to start any new transactions once there are fewer than 1 million "
"transactions left until wraparound: <placeholder-2/> The 1-million-"
"transaction safety margin exists to let the administrator recover without "
"data loss, by manually executing the required <command>VACUUM</command> "
"commands. However, since the system will not execute commands once it has "
"gone into the safety shutdown mode, the only way to do this is to stop the "
"server and start the server in single-user mode to execute <command>VACUUM</"
"command>. The shutdown mode is not enforced in single-user mode. See the "
"<xref linkend=\"app-postgres\"/> reference page for details about using "
"single-user mode."
msgstr ""
"Если по какой-либо причине автоочистка не может вычистить старые значения "
"XID из таблицы, система начинает выдавать предупреждающие сообщения, "
"подобные приведённому ниже, когда самое старое значение XID в базе данных "
"оказывается в десяти миллионах транзакций от точки зацикливания: "
"<placeholder-1/> (Проблему можно решить, как предлагает подсказка, запустив "
"<command>VACUUM</command> вручную; однако учтите, что выполнять "
"<command>VACUUM</command> должен суперпользователь, в противном случае эта "
"процедура не сможет обработать системные каталоги и, следовательно, не "
"сможет увеличить значение <structfield>datfrozenxid</structfield> для базы "
"данных.) Если эти предупреждения игнорировать, система отключится и не будет "
"начинать никаких транзакций, как только до точки зацикливания останется "
"менее 1 миллиона транзакций: <placeholder-2/> Резерв в 1 миллион транзакций "
"позволяет администратору провести восстановление без потери данных, выполнив "
"необходимые команды <command>VACUUM</command> вручную. Однако, поскольку "
"после безопасной остановки система не будет исполнять команды, "
"администратору останется только перезапустить сервер в однопользовательском "
"режиме, чтобы запустить <command>VACUUM</command>. За подробной информацией "
"об использовании однопользовательского режима обратитесь к странице справки "
"по <xref linkend=\"app-postgres\"/>."

#: maintenance.xml:641(title)
msgid "Multixacts and Wraparound"
msgstr "Мультитранзакции и зацикливание"

#: maintenance.xml:643(indexterm)
msgid "<primary>MultiXactId</primary>"
msgstr "<primary>MultiXactId</primary>"

#: maintenance.xml:647(indexterm)
msgid "<primary>wraparound</primary> <secondary>of multixact IDs</secondary>"
msgstr ""
"<primary>зацикливание</primary> <secondary>идентификаторов мультитранзакций</"
"secondary>"

#: maintenance.xml:652(para)
msgid ""
"<firstterm>Multixact IDs</firstterm> are used to support row locking by "
"multiple transactions. Since there is only limited space in a tuple header "
"to store lock information, that information is encoded as a <quote>multiple "
"transaction ID</quote>, or multixact ID for short, whenever there is more "
"than one transaction concurrently locking a row. Information about which "
"transaction IDs are included in any particular multixact ID is stored "
"separately in the <filename>pg_multixact</filename> subdirectory, and only "
"the multixact ID appears in the <structfield>xmax</structfield> field in the "
"tuple header. Like transaction IDs, multixact IDs are implemented as a 32-"
"bit counter and corresponding storage, all of which requires careful aging "
"management, storage cleanup, and wraparound handling. There is a separate "
"storage area which holds the list of members in each multixact, which also "
"uses a 32-bit counter and which must also be managed."
msgstr ""
"<firstterm>Идентификаторы мультитранзакций</firstterm> используются для "
"поддержки блокировки строк несколькими транзакциями одновременно. Поскольку "
"в заголовке строки есть только ограниченное пространство для хранения "
"информации о блокировках, в нём указывается <quote>идентификатор "
"множественной транзакции</quote>, или идентификатор мультитранзакции для "
"краткости, когда строку блокируют одновременно несколько транзакций. "
"Информация о том, какие именно идентификаторы транзакций относятся к "
"определённой мультитранзакции, хранится отдельно в подкаталоге "
"<filename>pg_multixact</filename>, а в поле <structfield>xmax</structfield> "
"в заголовке строки сохраняется только идентификатор мультитранзакции. Как и "
"идентификаторы транзакций, идентификаторы мультитранзакций исполнены в виде "
"32-разрядного счётчика и хранятся аналогично, что требует аккуратного "
"управления их возрастом, очисткой хранилища и предотвращением зацикливаний. "
"Существует отдельная область, в которой содержится список членов каждой "
"мультитранзакции, где счётчики также 32-битные и требуют должного контроля."

#: maintenance.xml:670(para)
msgid ""
"Whenever <command>VACUUM</command> scans any part of a table, it will "
"replace any multixact ID it encounters which is older than <xref linkend="
"\"guc-vacuum-multixact-freeze-min-age\"/> by a different value, which can be "
"the zero value, a single transaction ID, or a newer multixact ID. For each "
"table, <structname>pg_class</structname>.<structfield>relminmxid</"
"structfield> stores the oldest possible multixact ID still appearing in any "
"tuple of that table. If this value is older than <xref linkend=\"guc-vacuum-"
"multixact-freeze-table-age\"/>, an aggressive vacuum is forced. As discussed "
"in the previous section, an aggressive vacuum means that only those pages "
"which are known to be all-frozen will be skipped. <function>mxid_age()</"
"function> can be used on <structname>pg_class</structname>."
"<structfield>relminmxid</structfield> to find its age."
msgstr ""
"Когда <command>VACUUM</command> сканирует какую-либо часть таблицы, каждый "
"идентификатор мультитранзакции старее чем <xref linkend=\"guc-vacuum-"
"multixact-freeze-min-age\"/> заменяется другим значением, которое может быть "
"нулевым, идентификатором одиночной транзакции или новым идентификатором "
"мультитранзакции. Для каждой таблицы в <structname>pg_class</structname>."
"<structfield>relminmxid</structfield> хранится самый старый возможный "
"идентификатор мультитранзакции, всё ещё задействованный в какой-либо строке "
"этой таблицы. Если это значение оказывается старее <xref linkend=\"guc-"
"vacuum-multixact-freeze-table-age\"/>, выполняется агрессивная очистка. Как "
"рассказывалось в предыдущем разделе, при агрессивной очистке будут "
"пропускаться только те страницы, которые считаются полностью замороженными. "
"Узнать возраст <structname>pg_class</structname>.<structfield>relminmxid</"
"structfield> можно с помощью функции <function>mxid_age()</function>."

#: maintenance.xml:686(para)
msgid ""
"Aggressive <command>VACUUM</command> scans, regardless of what causes them, "
"enable advancing the value for that table. Eventually, as all tables in all "
"databases are scanned and their oldest multixact values are advanced, on-"
"disk storage for older multixacts can be removed."
msgstr ""
"Благодаря агрессивным операциям <command>VACUUM</command>, вне зависимости "
"от их причины, это значение для таблицы будет увеличиваться. В конце концов, "
"по мере сканирования всех таблиц во всех базах данных и увеличения их "
"старейших значений мультитранзакций, информация о старых мультитранзакциях "
"может быть удалена с диска."

#: maintenance.xml:694(para)
msgid ""
"As a safety device, an aggressive vacuum scan will occur for any table whose "
"multixact-age is greater than <xref linkend=\"guc-autovacuum-multixact-"
"freeze-max-age\"/>. Aggressive vacuum scans will also occur progressively "
"for all tables, starting with those that have the oldest multixact-age, if "
"the amount of used member storage space exceeds the amount 50% of the "
"addressable storage space. Both of these kinds of aggressive scans will "
"occur even if autovacuum is nominally disabled."
msgstr ""
"В качестве меры защиты, агрессивное сканирование с целью очистки будет "
"происходить для любой таблицы, возраст мультитранзакций которой больше, чем "
"<xref linkend=\"guc-autovacuum-multixact-freeze-max-age\"/>. Агрессивное "
"сканирование также будет выполняться постепенно со всеми таблицами, начиная "
"с имеющих старейшие мультитранзакции, если объём занятой области членов "
"мультитранзакций превышает 50% от объёма адресуемого пространства. Эти два "
"варианта агрессивного сканирования осуществляются, даже если процесс "
"автоочистки отключён."

#: maintenance.xml:708(title)
msgid "The Autovacuum Daemon"
msgstr "Демон автоочистки"

#: maintenance.xml:710(indexterm)
msgid ""
"<primary>autovacuum</primary> <secondary>general information</secondary>"
msgstr "<primary>автоочистка</primary> <secondary>общая информация</secondary>"

#: maintenance.xml:714(para)
msgid ""
"<productname>PostgreSQL</productname> has an optional but highly recommended "
"feature called <firstterm>autovacuum</firstterm>, whose purpose is to "
"automate the execution of <command>VACUUM</command> and <command>ANALYZE </"
"command> commands. When enabled, autovacuum checks for tables that have had "
"a large number of inserted, updated or deleted tuples. These checks use the "
"statistics collection facility; therefore, autovacuum cannot be used unless "
"<xref linkend=\"guc-track-counts\"/> is set to <literal>true</literal>. In "
"the default configuration, autovacuuming is enabled and the related "
"configuration parameters are appropriately set."
msgstr ""
"В <productname>PostgreSQL</productname> имеется не обязательная, но "
"настоятельно рекомендуемая к использованию функция, называемая "
"<firstterm>автоочисткой</firstterm>, предназначение которой — "
"автоматизировать выполнение команд <command>VACUUM</command> и "
"<command>ANALYZE </command>. Когда автоочистка включена, она проверяет, в "
"каких таблицах было вставлено, изменено или удалено много строк. При этих "
"проверках используются средства сбора статистики; поэтому автоочистка будет "
"работать, только если параметр <xref linkend=\"guc-track-counts\"/> имеет "
"значение <literal>true</literal>. В конфигурации по умолчанию автоочистка "
"включена и соответствующие параметры имеют подходящие значения."

#: maintenance.xml:728(para)
msgid ""
"The <quote>autovacuum daemon</quote> actually consists of multiple "
"processes. There is a persistent daemon process, called the "
"<firstterm>autovacuum launcher</firstterm>, which is in charge of starting "
"<firstterm>autovacuum worker</firstterm> processes for all databases. The "
"launcher will distribute the work across time, attempting to start one "
"worker within each database every <xref linkend=\"guc-autovacuum-naptime\"/> "
"seconds. (Therefore, if the installation has <replaceable>N</replaceable> "
"databases, a new worker will be launched every <varname>autovacuum_naptime</"
"varname>/<replaceable>N</replaceable> seconds.) A maximum of <xref linkend="
"\"guc-autovacuum-max-workers\"/> worker processes are allowed to run at the "
"same time. If there are more than <varname>autovacuum_max_workers</varname> "
"databases to be processed, the next database will be processed as soon as "
"the first worker finishes. Each worker process will check each table within "
"its database and execute <command>VACUUM</command> and/or <command>ANALYZE</"
"command> as needed. <xref linkend=\"guc-log-autovacuum-min-duration\"/> can "
"be set to monitor autovacuum workers' activity."
msgstr ""
"<quote>Демон автоочистки</quote> на самом деле состоит из нескольких "
"процессов. Существует постоянный фоновый процесс, называемый "
"<firstterm>процессом запуска автоочистки</firstterm>, который отвечает за "
"запуск <firstterm>рабочих процессов автоочистки</firstterm> для всех баз "
"данных. Этот контролирующий процесс распределяет работу по времени, стараясь "
"запускать рабочий процесс для каждой базы данных каждые <xref linkend=\"guc-"
"autovacuum-naptime\"/> секунд. (Следовательно, если всего имеется "
"<replaceable>N</replaceable> баз данных, новый рабочий процесс будет "
"запускаться каждые <varname>autovacuum_naptime</varname>/<replaceable>N</"
"replaceable> секунд.) Одновременно могут выполняться до <xref linkend=\"guc-"
"autovacuum-max-workers\"/> рабочих процессов. Если число баз данных, "
"требующих обработки, превышает <varname>autovacuum_max_workers</varname>, "
"обработка следующей базы начинается сразу по завершении первого рабочего "
"процесса. Каждый рабочий процесс проверяет все таблицы в своей базе данных и "
"в случае необходимости выполняет <command>VACUUM</command> и/или "
"<command>ANALYZE</command>. Для отслеживания действий рабочих процессов "
"можно установить параметр <xref linkend=\"guc-log-autovacuum-min-duration\"/"
">."

#: maintenance.xml:748(para)
msgid ""
"If several large tables all become eligible for vacuuming in a short amount "
"of time, all autovacuum workers might become occupied with vacuuming those "
"tables for a long period. This would result in other tables and databases "
"not being vacuumed until a worker becomes available. There is no limit on "
"how many workers might be in a single database, but workers do try to avoid "
"repeating work that has already been done by other workers. Note that the "
"number of running workers does not count towards <xref linkend=\"guc-max-"
"connections\"/> or <xref linkend=\"guc-superuser-reserved-connections\"/> "
"limits."
msgstr ""
"Если в течение короткого промежутка времени потребность в очистке возникает "
"для нескольких больших таблиц, все рабочие процессы автоочистки могут "
"продолжительное время заниматься очисткой только этих таблиц. В результате "
"другие таблицы и базы данных будут ожидать очистки, пока не появится "
"свободный рабочий процесс. Число рабочих процессов для одной базы не "
"ограничивается, при этом каждый процесс старается не повторять работу, "
"только что выполненную другими. Заметьте, что в ограничениях <xref linkend="
"\"guc-max-connections\"/> или <xref linkend=\"guc-superuser-reserved-"
"connections\"/> число выполняющихся рабочих процессов не учитывается."

#: maintenance.xml:768(programlisting)
#, no-wrap
msgid "vacuum threshold = vacuum base threshold + vacuum scale factor * number of tuples"
msgstr "порог очистки = базовый порог очистки + коэффициент доли для очистки * количество кортежей"

#: maintenance.xml:760(para)
msgid ""
"Tables whose <structfield>relfrozenxid</structfield> value is more than "
"<xref linkend=\"guc-autovacuum-freeze-max-age\"/> transactions old are "
"always vacuumed (this also applies to those tables whose freeze max age has "
"been modified via storage parameters; see below). Otherwise, if the number "
"of tuples obsoleted since the last <command>VACUUM</command> exceeds the "
"<quote>vacuum threshold</quote>, the table is vacuumed. The vacuum threshold "
"is defined as: <placeholder-1/> where the vacuum base threshold is <xref "
"linkend=\"guc-autovacuum-vacuum-threshold\"/>, the vacuum scale factor is "
"<xref linkend=\"guc-autovacuum-vacuum-scale-factor\"/>, and the number of "
"tuples is <structname>pg_class</structname>.<structfield>reltuples</"
"structfield>. The number of obsolete tuples is obtained from the statistics "
"collector; it is a semi-accurate count updated by each <command>UPDATE</"
"command> and <command>DELETE</command> operation. (It is only semi-accurate "
"because some information might be lost under heavy load.) If the "
"<structfield>relfrozenxid</structfield> value of the table is more than "
"<varname>vacuum_freeze_table_age</varname> transactions old, an aggressive "
"vacuum is performed to freeze old tuples and advance "
"<structfield>relfrozenxid</structfield>; otherwise, only pages that have "
"been modified since the last vacuum are scanned."
msgstr ""
"Для таблиц с <structfield>relfrozenxid</structfield>, устаревшим более чем "
"на <xref linkend=\"guc-autovacuum-freeze-max-age\"/> транзакций, очистка "
"выполняется всегда (это также применимо к таблицам, для которых максимальный "
"порог заморозки был изменён через параметры хранения; см. ниже). В противном "
"случае, очистка таблицы производится, если количество кортежей, устаревших с "
"момента последнего выполнения <command>VACUUM</command>, превышает "
"<quote>пороговое значение очистки</quote>. Пороговое значение очистки "
"определяется как: <placeholder-1/> где базовый порог очистки — значение "
"<xref linkend=\"guc-autovacuum-vacuum-threshold\"/>, коэффициент доли — "
"<xref linkend=\"guc-autovacuum-vacuum-scale-factor\"/>, а количество "
"кортежей — <structname>pg_class</structname>.<structfield>reltuples</"
"structfield>. Количество устаревших кортежей получается от сборщика "
"статистики; оно представляет собой приблизительное число, обновляемое после "
"каждой операции <command>UPDATE</command> и <command>DELETE</command>. "
"(Точность не гарантируется, потому что при большой нагрузке часть информации "
"может быть утеряна.) Если значение <structfield>relfrozenxid</structfield> "
"для таблицы старее <varname>vacuum_freeze_table_age</varname> транзакций, "
"производится агрессивная очистка с целью заморозить старые версии строк и "
"увеличить значение <structfield>relfrozenxid</structfield>; в противном "
"случае сканируются только страницы, изменённые после последней очистки."

#: maintenance.xml:790(programlisting)
#, no-wrap
msgid "analyze threshold = analyze base threshold + analyze scale factor * number of tuples"
msgstr "порог анализа = базовый порог анализа + коэффициент доли для анализа * количество кортежей"

#: maintenance.xml:788(para)
msgid ""
"For analyze, a similar condition is used: the threshold, defined as: "
"<placeholder-1/> is compared to the total number of tuples inserted, "
"updated, or deleted since the last <command>ANALYZE</command>."
msgstr ""
"Для выполнения сбора статистики используется аналогичное условие: пороговое "
"значение, определяемое как: <placeholder-1/> сравнивается с общим "
"количеством кортежей добавленных, изменённых или удалённых после последнего "
"выполнения <command>ANALYZE</command>."

#: maintenance.xml:797(para)
msgid ""
"Temporary tables cannot be accessed by autovacuum. Therefore, appropriate "
"vacuum and analyze operations should be performed via session SQL commands."
msgstr ""
"Автоочистка не обрабатывает временные таблицы. Поэтому очистку и сбор "
"статистики в них нужно производить с помощью SQL-команд в обычном сеансе."

#: maintenance.xml:803(para)
msgid ""
"The default thresholds and scale factors are taken from <filename>postgresql."
"conf</filename>, but it is possible to override them (and many other "
"autovacuum control parameters) on a per-table basis; see <xref linkend=\"sql-"
"createtable-storage-parameters\" endterm=\"sql-createtable-storage-"
"parameters-title\"/> for more information. If a setting has been changed via "
"a table's storage parameters, that value is used when processing that table; "
"otherwise the global settings are used. See <xref linkend=\"runtime-config-"
"autovacuum\"/> for more details on the global settings."
msgstr ""
"Используемые по умолчанию пороговые значения и коэффициенты берутся из "
"<filename>postgresql.conf</filename>, однако их (и многие другие параметры, "
"управляющие автоочисткой) можно переопределить для каждой таблицы; за "
"подробностями обратитесь к <xref remap=\"3\" linkend=\"sql-createtable-"
"storage-parameters\" endterm=\"sql-createtable-storage-parameters-title\"/>. "
"Если какие-либо значения определены через параметры хранения таблицы, при "
"обработке этой таблицы действуют они, а в противном случае — глобальные "
"параметры. За более подробной информацией о глобальных параметрах обратитесь "
"к <xref remap=\"3\" linkend=\"runtime-config-autovacuum\"/>."

#: maintenance.xml:815(para)
msgid ""
"When multiple workers are running, the autovacuum cost delay parameters (see "
"<xref linkend=\"runtime-config-resource-vacuum-cost\"/>) are "
"<quote>balanced</quote> among all the running workers, so that the total I/O "
"impact on the system is the same regardless of the number of workers "
"actually running. However, any workers processing tables whose per-table "
"<literal>autovacuum_vacuum_cost_delay</literal> or "
"<literal>autovacuum_vacuum_cost_limit</literal> storage parameters have been "
"set are not considered in the balancing algorithm."
msgstr ""
"Когда выполняются несколько рабочих процессов, параметры задержки "
"автоочистки по стоимости (см. <xref remap=\"4\" linkend=\"runtime-config-"
"resource-vacuum-cost\"/>) <quote>распределяются</quote> между всеми этими "
"процессами, так что общее воздействие на систему остаётся неизменным, "
"независимо от их числа. Однако этот алгоритм распределения нагрузки не "
"учитывает процессы, обрабатывающие таблицы с индивидуальными значениями "
"параметров хранения <literal>autovacuum_vacuum_cost_delay</literal> и "
"<literal>autovacuum_vacuum_cost_limit</literal>."

#: maintenance.xml:830(title)
msgid "Routine Reindexing"
msgstr "Регулярная переиндексация"

#: maintenance.xml:832(indexterm)
msgid "<primary>reindex</primary>"
msgstr "<primary>переиндексация</primary>"

#: maintenance.xml:836(para)
msgid ""
"In some situations it is worthwhile to rebuild indexes periodically with the "
"<xref linkend=\"sql-reindex\"/> command or a series of individual rebuilding "
"steps."
msgstr ""
"В некоторых ситуациях стоит периодически перестраивать индексы, выполняя "
"команду <xref linkend=\"sql-reindex\"/> или последовательность отдельных "
"шагов по восстановлению индексов."

#: maintenance.xml:843(para)
msgid ""
"B-tree index pages that have become completely empty are reclaimed for re-"
"use. However, there is still a possibility of inefficient use of space: if "
"all but a few index keys on a page have been deleted, the page remains "
"allocated. Therefore, a usage pattern in which most, but not all, keys in "
"each range are eventually deleted will see poor use of space. For such usage "
"patterns, periodic reindexing is recommended."
msgstr ""
"Страницы индексов на основе B-деревьев, которые стали абсолютно пустыми, "
"могут быть использованы повторно. Однако возможность неэффективного "
"использования пространства всё же остаётся: если со страницы были удалены "
"почти все, но не все ключи индекса, страница всё равно остаётся занятой. "
"Следовательно, шаблон использования, при котором со временем удаляются "
"многие, но не все ключи в каждом диапазоне, приведёт к неэффективному "
"расходованию пространства. В таких случаях рекомендуется периодически "
"проводить переиндексацию."

#: maintenance.xml:853(para)
msgid ""
"The potential for bloat in non-B-tree indexes has not been well researched. "
"It is a good idea to periodically monitor the index's physical size when "
"using any non-B-tree index type."
msgstr ""
"Возможность потери пространства в индексах на основе не B-деревьев глубоко "
"не исследовалась. Поэтому имеет смысл периодически отслеживать физический "
"размер индекса, когда применяется индекс такого типа."

#: maintenance.xml:859(para)
msgid ""
"Also, for B-tree indexes, a freshly-constructed index is slightly faster to "
"access than one that has been updated many times because logically adjacent "
"pages are usually also physically adjacent in a newly built index. (This "
"consideration does not apply to non-B-tree indexes.) It might be worthwhile "
"to reindex periodically just to improve access speed."
msgstr ""
"Кроме того, с B-деревьями доступ по недавно построенному индексу "
"осуществляется немного быстрее, нежели доступ по индексу, который "
"неоднократно изменялся, поскольку в недавно построенном индексе страницы, "
"близкие логически, обычно расположены так же близко и физически. (Это "
"соображение неприменимо к индексам, которые основаны не на B-деревьях.) "
"Поэтому периодически проводить переиндексацию стоит хотя бы для того, чтобы "
"увеличить скорость доступа."

#: maintenance.xml:867(para)
msgid ""
"<xref linkend=\"sql-reindex\"/> can be used safely and easily in all cases. "
"But since the command requires an exclusive table lock, it is often "
"preferable to execute an index rebuild with a sequence of creation and "
"replacement steps. Index types that support <xref linkend=\"sql-createindex"
"\"/> with the <literal>CONCURRENTLY</literal> option can instead be "
"recreated that way. If that is successful and the resulting index is valid, "
"the original index can then be replaced by the newly built one using a "
"combination of <xref linkend=\"sql-alterindex\"/> and <xref linkend=\"sql-"
"dropindex\"/>. When an index is used to enforce uniqueness or other "
"constraints, <xref linkend=\"sql-altertable\"/> might be necessary to swap "
"the existing constraint with one enforced by the new index. Review this "
"alternate multistep rebuild approach carefully before using it as there are "
"limitations on which indexes can be reindexed this way, and errors must be "
"handled."
msgstr ""
"Команду <xref linkend=\"sql-reindex\"/> можно безопасно и просто применять "
"во всех случаях. Но так как она требует исключительной блокировки таблицы, "
"часто предпочтительнее перестраивать индекс в несколько этапов, включающих "
"создание и замену индекса. Типы индексов, которые поддерживает <xref linkend="
"\"sql-createindex\"/> с указанием <literal>CONCURRENTLY</literal>, можно "
"построить именно так. Если это удаётся и получен рабочий индекс, изначальный "
"индекс можно заменить им, выполнив <xref linkend=\"sql-alterindex\"/> и "
"<xref linkend=\"sql-dropindex\"/>. Когда индекс используется для обеспечения "
"уникальности или других ограничений, может потребоваться команда <xref "
"linkend=\"sql-altertable\"/>, чтобы поменять существующее ограничение на то, "
"что обеспечивает новый индекс. Обстоятельно продумайте эту многоходовую "
"процедуру, прежде чем выполнять её, так как не все индексы можно перестроить "
"таким образом, и предусмотрите обработку ошибок."

#: maintenance.xml:887(title)
msgid "Log File Maintenance"
msgstr "Обслуживание журнала"

#: maintenance.xml:889(indexterm)
msgid ""
"<primary>server log</primary> <secondary>log file maintenance</secondary>"
msgstr ""
"<primary>журнал сервера</primary> <secondary>обслуживание файла журнала</"
"secondary>"

#: maintenance.xml:894(para)
msgid ""
"It is a good idea to save the database server's log output somewhere, rather "
"than just discarding it via <filename>/dev/null</filename>. The log output "
"is invaluable when diagnosing problems. However, the log output tends to be "
"voluminous (especially at higher debug levels) so you won't want to save it "
"indefinitely. You need to <emphasis>rotate</emphasis> the log files so that "
"new log files are started and old ones removed after a reasonable period of "
"time."
msgstr ""
"Журнал сервера базы данных желательно сохранять где-либо, а не просто "
"сбрасывать его в <filename>/dev/null</filename>. Этот журнал бесценен при "
"диагностике проблем. Однако он может быть очень объёмным (особенно при "
"высоких уровнях отладки), так что хранить его неограниченно долго вы вряд ли "
"захотите. Поэтому необходимо организовать <emphasis>ротацию</emphasis> "
"журнальных файлов так, чтобы новые файлы создавались, а старые удалялись "
"через разумный промежуток времени."

#: maintenance.xml:905(para)
msgid ""
"If you simply direct the <systemitem>stderr</systemitem> of "
"<command>postgres</command> into a file, you will have log output, but the "
"only way to truncate the log file is to stop and restart the server. This "
"might be acceptable if you are using <productname>PostgreSQL</productname> "
"in a development environment, but few production servers would find this "
"behavior acceptable."
msgstr ""
"Если просто направить <systemitem>stderr</systemitem> команды "
"<command>postgres</command> в файл, вы получите в нём журнал сообщений, но "
"очистить этот файл можно будет, только если остановить и перезапустить "
"сервер. Это может быть допустимо при использовании <productname>PostgreSQL</"
"productname> в среде разработки, но вряд ли такой вариант будет приемлемым в "
"производственной среде."

#: maintenance.xml:915(para)
msgid ""
"A better approach is to send the server's <systemitem>stderr</systemitem> "
"output to some type of log rotation program. There is a built-in log "
"rotation facility, which you can use by setting the configuration parameter "
"<varname>logging_collector</varname> to <literal>true</literal> in "
"<filename>postgresql.conf</filename>. The control parameters for this "
"program are described in <xref linkend=\"runtime-config-logging-where\"/>. "
"You can also use this approach to capture the log data in machine readable "
"<acronym>CSV</acronym> (comma-separated values) format."
msgstr ""
"Лучшим подходом будет перенаправление вывода сервера <systemitem>stderr</"
"systemitem> в какую-либо программу ротации журнальных файлов. Существует и "
"встроенное средство ротации журнальных файлов, которое можно использовать, "
"установив для параметра <varname>logging_collector</varname> значение "
"<literal>true</literal> в <filename>postgresql.conf</filename>. Параметры, "
"управляющие этой программой, описаны в <xref remap=\"6\" linkend=\"runtime-"
"config-logging-where\"/>. Этот подход также можно использовать для получения "
"содержимого журнала в формате <acronym>CSV</acronym> (значения, разделённые "
"запятыми)."

#: maintenance.xml:940(programlisting)
#, no-wrap
msgid "pg_ctl start | rotatelogs /var/log/pgsql_log 86400"
msgstr "pg_ctl start | rotatelogs /var/log/pgsql_log 86400"

#: maintenance.xml:927(para)
msgid ""
"Alternatively, you might prefer to use an external log rotation program if "
"you have one that you are already using with other server software. For "
"example, the <application>rotatelogs</application> tool included in the "
"<productname>Apache</productname> distribution can be used with "
"<productname>PostgreSQL</productname>. To do this, just pipe the server's "
"<systemitem>stderr</systemitem> output to the desired program. If you start "
"the server with <command>pg_ctl</command>, then <systemitem>stderr</"
"systemitem> is already redirected to <systemitem>stdout</systemitem>, so you "
"just need a pipe command, for example: <placeholder-1/>"
msgstr ""
"Вы также можете использовать внешнюю программу для ротации журнальных "
"файлов, если уже применяете такое приложение для других серверных "
"приложений. Например, утилиту <application>rotatelogs</application>, "
"включённую в дистрибутив <productname>Apache</productname>, можно "
"использовать и с <productname>PostgreSQL</productname>. Для этого просто "
"направьте вывод <systemitem>stderr</systemitem> сервера в желаемую "
"программу. Если вы запускаете сервер, используя <command>pg_ctl</command>, "
"то <systemitem>stderr</systemitem> уже будет перенаправлен в "
"<systemitem>stdout</systemitem>, так что будет достаточно просто применить "
"конвейер, например: <placeholder-1/>"

#: maintenance.xml:945(para)
msgid ""
"Another production-grade approach to managing log output is to send it to "
"<application>syslog</application> and let <application>syslog</application> "
"deal with file rotation. To do this, set the configuration parameter "
"<varname>log_destination</varname> to <literal>syslog</literal> (to log to "
"<application>syslog</application> only) in <filename>postgresql.conf</"
"filename>. Then you can send a <literal>SIGHUP</literal> signal to the "
"<application>syslog</application> daemon whenever you want to force it to "
"start writing a new log file. If you want to automate log rotation, the "
"<application>logrotate</application> program can be configured to work with "
"log files from <application>syslog</application>."
msgstr ""
"Ещё одно решение промышленного уровня заключается в передаче журнала в "
"<application>syslog</application>, чтобы ротацией файлов занималась уже "
"служба <application>syslog</application>. Для этого присвойте параметру "
"конфигурации <varname>log_destination</varname> значение <literal>syslog</"
"literal> (для вывода журнала только в <application>syslog</application>) в "
"<filename>postgresql.conf</filename>. Затем вы сможете посылать сигнал "
"<literal>SIGHUP</literal> службе <application>syslog</application>, когда "
"захотите принудительно начать запись нового журнального файла. Если вы "
"хотите автоматизировать ротацию журнальных файлов, программу "
"<application>logrotate</application> можно настроить и для работы с "
"журнальными файлами, которые формирует <application>syslog</application>."

#: maintenance.xml:959(para)
msgid ""
"On many systems, however, <application>syslog</application> is not very "
"reliable, particularly with large log messages; it might truncate or drop "
"messages just when you need them the most. Also, on <productname>Linux</"
"productname>, <application>syslog</application> will flush each message to "
"disk, yielding poor performance. (You can use a <quote><literal>-</literal></"
"quote> at the start of the file name in the <application>syslog</"
"application> configuration file to disable syncing.)"
msgstr ""
"Однако во многих системах, а особенно c большими сообщениями, "
"<application>syslog</application> работает не очень надёжно; он может "
"обрезать или терять сообщения как раз тогда, когда они вам нужны. Кроме "
"того, в <productname>Linux</productname>, <application>syslog</application>> "
"сбрасывает каждое сообщение на диск, от чего страдает производительность. "
"(Для отключения этой синхронной записи можно добавить <quote><literal>-</"
"literal></quote> перед именем файла в файле конфигурации "
"<application>syslog</application>.)"

#: maintenance.xml:968(para)
msgid ""
"Note that all the solutions described above take care of starting new log "
"files at configurable intervals, but they do not handle deletion of old, no-"
"longer-useful log files. You will probably want to set up a batch job to "
"periodically delete old log files. Another possibility is to configure the "
"rotation program so that old log files are overwritten cyclically."
msgstr ""
"Обратите внимание, что все описанные выше решения обеспечивают создание "
"новых журнальных файлов через задаваемые промежутки времени, но не удаление "
"старых, ставших бесполезными файлов журналов. Возможно, вы захотите создать "
"задание для периодического удаления старых файлов. Кроме того, вы можете "
"настроить программу ротации файлов так, чтобы старые файлы журналов "
"циклически перезаписывались."

#: maintenance.xml:977(para)
msgid ""
"<ulink url=\"http://dalibo.github.io/pgbadger/\"><productname>pgBadger</"
"productname></ulink> is an external project that does sophisticated log file "
"analysis. <ulink url=\"http://bucardo.org/wiki/Check_postgres"
"\"><productname>check_postgres</productname></ulink> provides Nagios alerts "
"when important messages appear in the log files, as well as detection of "
"many other extraordinary conditions."
msgstr ""
"Также вам может быть полезен <ulink url=\"http://dalibo.github.io/pgbadger/"
"\"><productname>pgBadger</productname></ulink> — инструмент для сложного "
"анализа файлов журнала. Кроме того, <ulink url=\"http://bucardo.org/wiki/"
"Check_postgres\"><productname>check_postgres</productname></ulink> может "
"посылать уведомления в Nagios, когда в журнале появляются важные сообщения, "
"а также при обнаружении других нестандартных ситуаций."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: maintenance.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
