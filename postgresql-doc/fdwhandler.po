# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: fdwhandler.xml:5(title)
msgid "Writing A Foreign Data Wrapper"
msgstr "Написание обёртки сторонних данных"

#: fdwhandler.xml:7(indexterm)
msgid ""
"<primary>foreign data wrapper</primary> <secondary>handler for</secondary>"
msgstr ""
"<primary>обёртка сторонних данных</primary> <secondary>обработчик</secondary>"

#: fdwhandler.xml:12(para)
msgid ""
"All operations on a foreign table are handled through its foreign data "
"wrapper, which consists of a set of functions that the core server calls. "
"The foreign data wrapper is responsible for fetching data from the remote "
"data source and returning it to the <productname>PostgreSQL</productname> "
"executor. If updating foreign tables is to be supported, the wrapper must "
"handle that, too. This chapter outlines how to write a new foreign data "
"wrapper."
msgstr ""
"Все операции со сторонней таблицей производятся через созданную для неё "
"обёртку сторонних данных, представляющую собой набор подпрограмм, которые "
"вызывает ядро сервера. Обёртка сторонних данных отвечает за получение данных "
"из удалённого источника данных и передачу их исполнителю запросов "
"<productname>PostgreSQL</productname>. Чтобы поддерживалось изменение данных "
"в сторонних таблицах, эту операцию также должна выполнять обёртка. В данной "
"главе освещается написание обёртки сторонних данных."

#: fdwhandler.xml:22(para)
msgid ""
"The foreign data wrappers included in the standard distribution are good "
"references when trying to write your own. Look into the <filename>contrib</"
"filename> subdirectory of the source tree. The <xref linkend=\"sql-"
"createforeigndatawrapper\"/> reference page also has some useful details."
msgstr ""
"Реализация обёрток сторонних данных, включённых в стандартный дистрибутив, "
"может послужить хорошим примером при написании собственных обёрток. Её вы "
"можете найти в подкаталоге <filename>contrib</filename> дерева исходного "
"кода. Некоторые полезные детали также можно узнать на странице справки <xref "
"linkend=\"sql-createforeigndatawrapper\"/>."

#: fdwhandler.xml:31(para)
msgid ""
"The SQL standard specifies an interface for writing foreign data wrappers. "
"However, PostgreSQL does not implement that API, because the effort to "
"accommodate it into PostgreSQL would be large, and the standard API hasn't "
"gained wide adoption anyway."
msgstr ""
"В стандарте SQL описан интерфейс для написания обёрток сторонних данных, но "
"PostgreSQL не реализует его, так как это потребовало бы больших усилий, а "
"данный стандартизированный API всё равно не получил широкого распространения."

#: fdwhandler.xml:40(title)
msgid "Foreign Data Wrapper Functions"
msgstr "Функции обёрток сторонних данных"

#: fdwhandler.xml:42(para)
msgid ""
"The FDW author needs to implement a handler function, and optionally a "
"validator function. Both functions must be written in a compiled language "
"such as C, using the version-1 interface. For details on C language calling "
"conventions and dynamic loading, see <xref linkend=\"xfunc-c\"/>."
msgstr ""
"Автор FDW (Foreign Data Wrapper, Обёртки сторонних данных) должен "
"реализовать функцию-обработчик и может дополнительно добавить функцию "
"проверки. Обе функции должны быть написаны на компилируемом языке, таком как "
"C, и использовать интерфейс версии 1. Подробнее соглашение о вызовах и "
"динамическая загрузка кода на C описывается в <xref remap=\"6\" linkend="
"\"xfunc-c\"/>."

#: fdwhandler.xml:50(para)
msgid ""
"The handler function simply returns a struct of function pointers to "
"callback functions that will be called by the planner, executor, and various "
"maintenance commands. Most of the effort in writing an FDW is in "
"implementing these callback functions. The handler function must be "
"registered with <productname>PostgreSQL</productname> as taking no arguments "
"and returning the special pseudo-type <type>fdw_handler</type>. The callback "
"functions are plain C functions and are not visible or callable at the SQL "
"level. The callback functions are described in <xref linkend=\"fdw-callbacks"
"\"/>."
msgstr ""
"Функция-обработчик просто возвращает структуру с указателями на реализующие "
"подпрограммы, которые будут вызываться планировщиком, исполнителем и "
"различными служебными командами. Основная часть разработки FDW заключается в "
"написании этих реализующих подпрограмм. Функция-обработчик должна быть "
"зарегистрирована в <productname>PostgreSQL</productname> как функция без "
"аргументов, возвращающая специальный псевдотип <type>fdw_handler</type>. "
"Реализующие подпрограммы представляют собой обычные функции на C, которые не "
"видны и не могут вызываться на уровне SQL. Они описаны в <xref remap=\"6\" "
"linkend=\"fdw-callbacks\"/>."

#: fdwhandler.xml:64(para)
msgid ""
"The validator function is responsible for validating options given in "
"<command>CREATE</command> and <command>ALTER</command> commands for its "
"foreign data wrapper, as well as foreign servers, user mappings, and foreign "
"tables using the wrapper. The validator function must be registered as "
"taking two arguments, a text array containing the options to be validated, "
"and an OID representing the type of object the options are associated with "
"(in the form of the OID of the system catalog the object would be stored in, "
"either <literal>ForeignDataWrapperRelationId</literal>, "
"<literal>ForeignServerRelationId</literal>, <literal>UserMappingRelationId</"
"literal>, or <literal>ForeignTableRelationId</literal>). If no validator "
"function is supplied, options are not checked at object creation time or "
"object alteration time."
msgstr ""
"Функция проверки отвечает за проверку параметров, передаваемых с командами "
"<command>CREATE</command> и <command>ALTER</command> для этой обёртки "
"сторонних данных, а также параметров сторонних серверов, сопоставлений "
"пользователей и сторонних таблиц, доступных через эту обёртку. Эта функция "
"должна быть зарегистрирована как принимающая два аргумента: текстовый "
"массив, содержащий параметры для проверки, и OID, представляющий тип "
"объекта, с которым связаны эти параметры (в виде OID системного каталога, в "
"котором будет сохраняться объект: <literal>ForeignDataWrapperRelationId</"
"literal>, <literal>ForeignServerRelationId</literal>, "
"<literal>UserMappingRelationId</literal> или "
"<literal>ForeignTableRelationId</literal>). Если функция проверки "
"отсутствует, параметры не проверяются ни при создании, ни при изменении "
"объекта."

#: fdwhandler.xml:85(title)
msgid "Foreign Data Wrapper Callback Routines"
msgstr "Подпрограммы обёртки сторонних данных"

#: fdwhandler.xml:87(para)
msgid ""
"The FDW handler function returns a palloc'd <structname>FdwRoutine</"
"structname> struct containing pointers to the callback functions described "
"below. The scan-related functions are required, the rest are optional."
msgstr ""
"Функция-обработчик FDW возвращает структуру <structname>FdwRoutine</"
"structname> (выделенную с помощью palloc), содержащую указатели на "
"подпрограммы, которые реализуют описанные ниже функции. Из всех функций "
"обязательными являются только те, что касаются сканирования, а остальные "
"могут отсутствовать."

#: fdwhandler.xml:93(para)
msgid ""
"The <structname>FdwRoutine</structname> struct type is declared in "
"<filename>src/include/foreign/fdwapi.h</filename>, which see for additional "
"details."
msgstr ""
"Тип структуры <structname>FdwRoutine</structname> объявлен в <filename>src/"
"include/foreign/fdwapi.h</filename>, там же можно узнать дополнительные "
"подробности."

#: fdwhandler.xml:100(title)
msgid "FDW Routines For Scanning Foreign Tables"
msgstr "Подпрограммы FDW для сканирования сторонних таблиц"

#: fdwhandler.xml:103(programlisting)
#, no-wrap
msgid ""
"void\n"
"GetForeignRelSize (PlannerInfo *root,\n"
"                   RelOptInfo *baserel,\n"
"                   Oid foreigntableid);"
msgstr ""
"void\n"
"GetForeignRelSize (PlannerInfo *root,\n"
"                   RelOptInfo *baserel,\n"
"                   Oid foreigntableid);"

#: fdwhandler.xml:102(para)
msgid ""
"<placeholder-1/> Obtain relation size estimates for a foreign table. This is "
"called at the beginning of planning for a query that scans a foreign table. "
"<literal>root</literal> is the planner's global information about the query; "
"<literal>baserel</literal> is the planner's information about this table; "
"and <literal>foreigntableid</literal> is the <structname>pg_class</"
"structname> OID of the foreign table. (<literal>foreigntableid</literal> "
"could be obtained from the planner data structures, but it's passed "
"explicitly to save effort.)"
msgstr ""
"<placeholder-1/> Выдаёт оценку размера отношения для сторонней таблицы. Она "
"вызывается в начале планирования запроса, в котором сканируется сторонняя "
"таблица. В параметре <literal>root</literal> передаётся общая информация "
"планировщика о запросе, в <literal>baserel</literal> — информация о данной "
"таблице, а в <literal>foreigntableid</literal> — OID записи в "
"<structname>pg_class</structname> для данной таблицы. (Значение "
"<literal>foreigntableid</literal> можно получить и из структуры данных "
"планировщика, но простоты ради оно передаётся явно.)"

#: fdwhandler.xml:119(para)
msgid ""
"This function should update <literal>baserel-&gt;rows</literal> to be the "
"expected number of rows returned by the table scan, after accounting for the "
"filtering done by the restriction quals. The initial value of "
"<literal>baserel-&gt;rows</literal> is just a constant default estimate, "
"which should be replaced if at all possible. The function may also choose to "
"update <literal>baserel-&gt;width</literal> if it can compute a better "
"estimate of the average result row width."
msgstr ""
"Эта функция должна записать в <literal>baserel-&gt;rows</literal> ожидаемое "
"число строк, которое будет получено при сканировании таблицы, с учётом "
"фильтра, заданного ограничением выборки. Изначально в <literal>baserel-&gt;"
"rows</literal> содержится просто постоянная оценка по умолчанию, которую "
"следует заменить, если это вообще возможно. Функция также может поменять "
"значение <literal>baserel-&gt;width</literal>, если она может дать лучшую "
"оценку средней ширины строки результата."

#: fdwhandler.xml:129(para) fdwhandler.xml:160(para) fdwhandler.xml:196(para)
#: fdwhandler.xml:344(para) fdwhandler.xml:391(para) fdwhandler.xml:480(para)
#: fdwhandler.xml:762(para)
msgid "See <xref linkend=\"fdw-planning\"/> for additional information."
msgstr ""
"За дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"fdw-"
"planning\"/>."

#: fdwhandler.xml:134(programlisting)
#, no-wrap
msgid ""
"void\n"
"GetForeignPaths (PlannerInfo *root,\n"
"                 RelOptInfo *baserel,\n"
"                 Oid foreigntableid);"
msgstr ""
"void\n"
"GetForeignPaths (PlannerInfo *root,\n"
"                 RelOptInfo *baserel,\n"
"                 Oid foreigntableid);"

#: fdwhandler.xml:133(para)
msgid ""
"<placeholder-1/> Create possible access paths for a scan on a foreign table. "
"This is called during query planning. The parameters are the same as for "
"<function>GetForeignRelSize</function>, which has already been called."
msgstr ""
"<placeholder-1/> Формирует возможные пути доступа для сканирования сторонней "
"таблицы. Эта функция вызывается при планировании запроса. Ей передаются те "
"же параметры, что и функции <function>GetForeignRelSize</function>, которая "
"к этому времени уже будет вызвана."

#: fdwhandler.xml:147(para)
msgid ""
"This function must generate at least one access path "
"(<structname>ForeignPath</structname> node) for a scan on the foreign table "
"and must call <function>add_path</function> to add each such path to "
"<literal>baserel-&gt;pathlist</literal>. It's recommended to use "
"<function>create_foreignscan_path</function> to build the "
"<structname>ForeignPath</structname> nodes. The function can generate "
"multiple access paths, e.g., a path which has valid <literal>pathkeys</"
"literal> to represent a pre-sorted result. Each access path must contain "
"cost estimates, and can contain any FDW-private information that is needed "
"to identify the specific scan method intended."
msgstr ""
"Эта функция должна выдать минимум один путь доступа (узел "
"<structname>ForeignPath</structname>) для сканирования сторонней таблицы и "
"должна вызвать <function>add_path</function>, чтобы добавить каждый такой "
"путь в <literal>baserel-&gt;pathlist</literal>. Для формирования узлов "
"<structname>ForeignPath</structname> рекомендуется вызывать "
"<function>create_foreignscan_path</function>. Данная функция может выдавать "
"несколько путей доступа, то есть путей, для которых по заданным "
"<literal>pathkeys</literal> можно получить уже отсортированный результат. "
"Каждый путь доступа должен содержать оценки стоимости и может содержать "
"любую частную информацию FDW, необходимую для выбора целевого метода "
"сканирования."

#: fdwhandler.xml:165(programlisting)
#, no-wrap
msgid ""
"ForeignScan *\n"
"GetForeignPlan (PlannerInfo *root,\n"
"                RelOptInfo *baserel,\n"
"                Oid foreigntableid,\n"
"                ForeignPath *best_path,\n"
"                List *tlist,\n"
"                List *scan_clauses,\n"
"                Plan *outer_plan);"
msgstr ""
"ForeignScan *\n"
"GetForeignPlan (PlannerInfo *root,\n"
"                RelOptInfo *baserel,\n"
"                Oid foreigntableid,\n"
"                ForeignPath *best_path,\n"
"                List *tlist,\n"
"                List *scan_clauses,\n"
"                Plan *outer_plan);"

#: fdwhandler.xml:164(para)
msgid ""
"<placeholder-1/> Create a <structname>ForeignScan</structname> plan node "
"from the selected foreign access path. This is called at the end of query "
"planning. The parameters are as for <function>GetForeignRelSize</function>, "
"plus the selected <structname>ForeignPath</structname> (previously produced "
"by <function>GetForeignPaths</function>, <function>GetForeignJoinPaths</"
"function>, or <function>GetForeignUpperPaths</function>), the target list to "
"be emitted by the plan node, the restriction clauses to be enforced by the "
"plan node, and the outer subplan of the <structname>ForeignScan</"
"structname>, which is used for rechecks performed by "
"<function>RecheckForeignScan</function>. (If the path is for a join rather "
"than a base relation, <literal>foreigntableid</literal> is "
"<literal>InvalidOid</literal>.)"
msgstr ""
"<placeholder-1/> Создаёт узел плана <structname>ForeignScan</structname> из "
"выбранного пути доступа к сторонней таблице. Эта функция вызывается в конце "
"планирования запроса. Ей передаются те же параметры, что и "
"<function>GetForeignRelSize</function>, плюс выбранный путь "
"<structname>ForeignPath</structname> (до этого сформированный функциями "
"<function>GetForeignPaths</function>, <function>GetForeignJoinPaths</"
"function> или <function>GetForeignUpperPaths</function>), целевой список, "
"который должен быть выдан этим узлом плана, условия ограничения, которые "
"должны применяться для данного узла, и внешний вложенный подплан "
"<structname>ForeignScan</structname>, применяемый для перепроверок, "
"выполняемых функцией <function>RecheckForeignScan</function>. (Если путь "
"задаётся для соединения, а не для базового отношения, в "
"<literal>foreigntableid</literal> передаётся <literal>InvalidOid</literal>.)"

#: fdwhandler.xml:190(para)
msgid ""
"This function must create and return a <structname>ForeignScan</structname> "
"plan node; it's recommended to use <function>make_foreignscan</function> to "
"build the <structname>ForeignScan</structname> node."
msgstr ""
"Эта функция должна создать и выдать узел плана <structname>ForeignScan</"
"structname>; для формирования этого узла рекомендуется использовать "
"<function>make_foreignscan</function>."

#: fdwhandler.xml:201(programlisting)
#, no-wrap
msgid ""
"void\n"
"BeginForeignScan (ForeignScanState *node,\n"
"                  int eflags);"
msgstr ""
"void\n"
"BeginForeignScan (ForeignScanState *node,\n"
"                  int eflags);"

#: fdwhandler.xml:200(para)
msgid ""
"<placeholder-1/> Begin executing a foreign scan. This is called during "
"executor startup. It should perform any initialization needed before the "
"scan can start, but not start executing the actual scan (that should be done "
"upon the first call to <function>IterateForeignScan</function>). The "
"<structname>ForeignScanState</structname> node has already been created, but "
"its <structfield>fdw_state</structfield> field is still NULL. Information "
"about the table to scan is accessible through the "
"<structname>ForeignScanState</structname> node (in particular, from the "
"underlying <structname>ForeignScan</structname> plan node, which contains "
"any FDW-private information provided by <function>GetForeignPlan</"
"function>). <literal>eflags</literal> contains flag bits describing the "
"executor's operating mode for this plan node."
msgstr ""
"<placeholder-1/> Начинает сканирование сторонней таблицы. Эта функция "
"вызывается при запуске исполнителя. Она должна выполнить все "
"подготовительные действия, необходимые для осуществления сканирования, но не "
"должна собственно производить сканирование (оно должно начаться с первым "
"вызовом <function>IterateForeignScan</function>). Узел "
"<structname>ForeignScanState</structname> уже был создан, но его поле "
"<structfield>fdw_state</structfield> по-прежнему NULL. Информацию о "
"сканируемой таблице можно получить через узел <structname>ForeignScanState</"
"structname> (в частности, из нижележащего узла <structname>ForeignScan</"
"structname>, содержащего частную информацию FDW, заданную функцией "
"<function>GetForeignPlan</function>). Параметр <literal>eflags</literal> "
"содержит битовые флаги, описывающие режим работы исполнителя для этого узла "
"плана."

#: fdwhandler.xml:221(para)
msgid ""
"Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is "
"true, this function should not perform any externally-visible actions; it "
"should only do the minimum required to make the node state valid for "
"<function>ExplainForeignScan</function> and <function>EndForeignScan</"
"function>."
msgstr ""
"Заметьте, что когда <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> "
"не равно нулю, эта функция не должна выполнять какие-либо внешне "
"проявляющиеся действия; она должна сделать только то, что необходимо для "
"получения состояния узла, подходящего для <function>ExplainForeignScan</"
"function> и <function>EndForeignScan</function>."

#: fdwhandler.xml:229(programlisting)
#, no-wrap
msgid ""
"TupleTableSlot *\n"
"IterateForeignScan (ForeignScanState *node);"
msgstr ""
"TupleTableSlot *\n"
"IterateForeignScan (ForeignScanState *node);"

#: fdwhandler.xml:228(para)
msgid ""
"<placeholder-1/> Fetch one row from the foreign source, returning it in a "
"tuple table slot (the node's <structfield>ScanTupleSlot</structfield> should "
"be used for this purpose). Return NULL if no more rows are available. The "
"tuple table slot infrastructure allows either a physical or virtual tuple to "
"be returned; in most cases the latter choice is preferable from a "
"performance standpoint. Note that this is called in a short-lived memory "
"context that will be reset between invocations. Create a memory context in "
"<function>BeginForeignScan</function> if you need longer-lived storage, or "
"use the <structfield>es_query_cxt</structfield> of the node's "
"<structname>EState</structname>."
msgstr ""
"<placeholder-1/> Выбирает одну строку из стороннего источника и возвращает "
"её в слоте таблицы кортежей (для этой цели следует использовать "
"<structfield>ScanTupleSlot</structfield>, переданный с узлом). Когда строки "
"заканчиваются, возвращает NULL. Инфраструктура слотов таблицы кортежей "
"позволяет возвращать как физические, так и виртуальные кортежи; в "
"большинстве случаев второй вариант предпочтительнее с точки зрения "
"производительности. Заметьте, что эта функция вызывается в контексте "
"кратковременной памяти, который будет сбрасываться между вызовами. Если вам "
"нужна более долгоживущая память, создайте соответствующий контекст в "
"<function>BeginForeignScan</function> либо используйте "
"<structfield>es_query_cxt</structfield> из структуры <structname>EState</"
"structname>, переданной с узлом."

#: fdwhandler.xml:245(para)
msgid ""
"The rows returned must match the <structfield>fdw_scan_tlist</structfield> "
"target list if one was supplied, otherwise they must match the row type of "
"the foreign table being scanned. If you choose to optimize away fetching "
"columns that are not needed, you should insert nulls in those column "
"positions, or else generate a <structfield>fdw_scan_tlist</structfield> list "
"with those columns omitted."
msgstr ""
"Возвращаемые строки должны соответствовать целевому списку "
"<structfield>fdw_scan_tlist</structfield>, если он передаётся, а в противном "
"случае — типу строки сканируемой сторонней таблицы. Если вы решите для "
"оптимизации не возвращать ненужные столбцы, в их позиции нужно вставить "
"NULL, либо сформировать список <structfield>fdw_scan_tlist</structfield> без "
"этих столбцов."

#: fdwhandler.xml:254(para)
msgid ""
"Note that <productname>PostgreSQL</productname>'s executor doesn't care "
"whether the rows returned violate any constraints that were defined on the "
"foreign table &mdash; but the planner does care, and may optimize queries "
"incorrectly if there are rows visible in the foreign table that do not "
"satisfy a declared constraint. If a constraint is violated when the user has "
"declared that the constraint should hold true, it may be appropriate to "
"raise an error (just as you would need to do in the case of a data type "
"mismatch)."
msgstr ""
"Заметьте, что для исполнителя <productname>PostgreSQL</productname> не "
"важно, удовлетворяют ли возвращаемые строки каким-либо ограничениям, "
"определённым для сторонней таблицы &mdash; но это важно для планировщика, "
"так что запросы могут оптимизироваться некорректно, если в сторонней таблице "
"будут видны строки, не удовлетворяющие объявленному ограничению. Если "
"ограничение нарушается, тогда как пользователь объявил, что оно должно "
"выполняться, может быть уместно сообщить об ошибке (точно так же, как и при "
"несовпадении типов данных)."

#: fdwhandler.xml:266(programlisting)
#, no-wrap
msgid ""
"void\n"
"ReScanForeignScan (ForeignScanState *node);"
msgstr ""
"void\n"
"ReScanForeignScan (ForeignScanState *node);"

#: fdwhandler.xml:265(para)
msgid ""
"<placeholder-1/> Restart the scan from the beginning. Note that any "
"parameters the scan depends on may have changed value, so the new scan does "
"not necessarily return exactly the same rows."
msgstr ""
"<placeholder-1/> Перезапускает сканирование с начала. Заметьте, что значения "
"параметров, от которых зависит сканирование, могли измениться, так что новое "
"сканирование не обязательно вернёт те же строки."

#: fdwhandler.xml:277(programlisting)
#, no-wrap
msgid ""
"void\n"
"EndForeignScan (ForeignScanState *node);"
msgstr ""
"void\n"
"EndForeignScan (ForeignScanState *node);"

#: fdwhandler.xml:276(para)
msgid ""
"<placeholder-1/> End the scan and release resources. It is normally not "
"important to release palloc'd memory, but for example open files and "
"connections to remote servers should be cleaned up."
msgstr ""
"<placeholder-1/> Завершает сканирование и освобождает ресурсы. Обычно при "
"этом не нужно освобождать память, выделенную через palloc, но например, "
"открытые файлы и подключения к удалённым серверам следует закрыть."

#: fdwhandler.xml:290(title)
msgid "FDW Routines For Scanning Foreign Joins"
msgstr "Подпрограммы FDW для сканирования сторонних соединений"

#: fdwhandler.xml:292(para)
msgid ""
"If an FDW supports performing foreign joins remotely (rather than by "
"fetching both tables' data and doing the join locally), it should provide "
"this callback function:"
msgstr ""
"Если FDW поддерживает соединения на удалённой стороне (вместо того, чтобы "
"считывать данные обеих таблиц и выполнять соединения локально), она должна "
"предоставить эту реализующую подпрограмму:"

#: fdwhandler.xml:299(programlisting)
#, no-wrap
msgid ""
"void\n"
"GetForeignJoinPaths (PlannerInfo *root,\n"
"                     RelOptInfo *joinrel,\n"
"                     RelOptInfo *outerrel,\n"
"                     RelOptInfo *innerrel,\n"
"                     JoinType jointype,\n"
"                     JoinPathExtraData *extra);"
msgstr ""
"void\n"
"GetForeignJoinPaths (PlannerInfo *root,\n"
"                     RelOptInfo *joinrel,\n"
"                     RelOptInfo *outerrel,\n"
"                     RelOptInfo *innerrel,\n"
"                     JoinType jointype,\n"
"                     JoinPathExtraData *extra);"

#: fdwhandler.xml:298(para)
msgid ""
"<placeholder-1/> Create possible access paths for a join of two (or more) "
"foreign tables that all belong to the same foreign server. This optional "
"function is called during query planning. As with <function>GetForeignPaths</"
"function>, this function should generate <structname>ForeignPath</"
"structname> path(s) for the supplied <literal>joinrel</literal>, and call "
"<function>add_path</function> to add these paths to the set of paths "
"considered for the join. But unlike <function>GetForeignPaths</function>, it "
"is not necessary that this function succeed in creating at least one path, "
"since paths involving local joining are always possible."
msgstr ""
"<placeholder-1/> Формирует возможные пути доступа для соединения двух (и "
"более) сторонних таблиц, принадлежащих одному стороннему серверу. Эта "
"необязательная функция вызывается во время планирования запроса. Как и "
"<function>GetForeignPaths</function>, эта функция должна построить путь(и) "
"<structname>ForeignPath</structname> для переданного <literal>joinrel</"
"literal> и вызвать <function>add_path</function>, чтобы добавить эти пути в "
"набор путей, подходящих для соединения. Но, в отличие от "
"<function>GetForeignPaths</function>, эта функция не обязательно должна "
"возвращать минимум один путь, так как всегда возможен альтернативный путь с "
"локальным соединением таблиц."

#: fdwhandler.xml:320(para)
msgid ""
"Note that this function will be invoked repeatedly for the same join "
"relation, with different combinations of inner and outer relations; it is "
"the responsibility of the FDW to minimize duplicated work."
msgstr ""
"Заметьте, что эта функция будет вызываться неоднократно для одного и того же "
"соединения с разными комбинациями внутреннего и внешнего отношений; "
"минимизировать двойную работу должна сама FDW."

#: fdwhandler.xml:326(para)
msgid ""
"If a <structname>ForeignPath</structname> path is chosen for the join, it "
"will represent the entire join process; paths generated for the component "
"tables and subsidiary joins will not be used. Subsequent processing of the "
"join path proceeds much as it does for a path scanning a single foreign "
"table. One difference is that the <structfield>scanrelid</structfield> of "
"the resulting <structname>ForeignScan</structname> plan node should be set "
"to zero, since there is no single relation that it represents; instead, the "
"<structfield>fs_relids</structfield> field of the <structname>ForeignScan</"
"structname> node represents the set of relations that were joined. (The "
"latter field is set up automatically by the core planner code, and need not "
"be filled by the FDW.) Another difference is that, because the column list "
"for a remote join cannot be found from the system catalogs, the FDW must "
"fill <structfield>fdw_scan_tlist</structfield> with an appropriate list of "
"<structfield>TargetEntry</structfield> nodes, representing the set of "
"columns it will supply at run time in the tuples it returns."
msgstr ""
"Если для соединения выбирается путь <structname>ForeignPath</structname>, он "
"будет представлять весь процесс соединения; пути, сформированные для "
"задействованных таблиц и подчинённых соединений, в нём применяться не будут. "
"Далее этот путь соединения обрабатывается во многом так же, как и путь "
"сканирования одной сторонней таблицы. Одно различие состоит в том, что "
"<structfield>scanrelid</structfield> результирующего плана узла "
"<structname>ForeignScan</structname> должно быть равно нулю, так как он не "
"представляет какое-либо одно отношение; вместо этого набор соединяемых "
"отношений представляется в поле <structfield>fs_relids</structfield> узла "
"<structname>ForeignScan</structname>. (Это поле заполняется автоматически "
"кодом ядра планировщика, так что FDW делать это не нужно.) Ещё одно отличие "
"в том, что список столбцов для удалённого соединения нельзя получить из "
"системных каталогов и поэтому FDW должна выдать в "
"<structfield>fdw_scan_tlist</structfield> требуемый список узлов "
"<structfield>TargetEntry</structfield>, представляющий набор столбцов, "
"которые будут выдаваться во время выполнения в возвращаемых кортежах."

#: fdwhandler.xml:350(title)
msgid "FDW Routines For Planning Post-Scan/Join Processing"
msgstr ""
"Подпрограммы FDW для планирования обработки после сканирования/соединения"

#: fdwhandler.xml:352(para)
msgid ""
"If an FDW supports performing remote post-scan/join processing, such as "
"remote aggregation, it should provide this callback function:"
msgstr ""
"Если FDW поддерживает удалённое выполнение операций после сканирования/"
"соединения, например, удалённое агрегирование, она должна предоставить эту "
"реализующую подпрограмму:"

#: fdwhandler.xml:358(programlisting)
#, no-wrap
msgid ""
"void\n"
"GetForeignUpperPaths (PlannerInfo *root,\n"
"                      UpperRelationKind stage,\n"
"                      RelOptInfo *input_rel,\n"
"                      RelOptInfo *output_rel);"
msgstr ""
"void\n"
"GetForeignUpperPaths (PlannerInfo *root,\n"
"                      UpperRelationKind stage,\n"
"                      RelOptInfo *input_rel,\n"
"                      RelOptInfo *output_rel);"

#: fdwhandler.xml:357(para)
msgid ""
"<placeholder-1/> Create possible access paths for <firstterm>upper relation</"
"firstterm> processing, which is the planner's term for all post-scan/join "
"query processing, such as aggregation, window functions, sorting, and table "
"updates. This optional function is called during query planning. Currently, "
"it is called only if all base relation(s) involved in the query belong to "
"the same FDW. This function should generate <structname>ForeignPath</"
"structname> path(s) for any post-scan/join processing that the FDW knows how "
"to perform remotely, and call <function>add_path</function> to add these "
"paths to the indicated upper relation. As with "
"<function>GetForeignJoinPaths</function>, it is not necessary that this "
"function succeed in creating any paths, since paths involving local "
"processing are always possible."
msgstr ""
"<placeholder-1/> Формирует возможные пути доступа для обработки "
"<firstterm>верхнего отношения</firstterm>. Этот термин планировщика "
"подразумевает любую обработку запросов после сканирования/соединения, в "
"частности, агрегирование, вычисление оконных функций, сортировку и изменение "
"таблиц. Эта необязательная функция вызывается во время планирования запроса. "
"В настоящее время она вызывается, только если все базовые отношения, "
"задействованные в запросе, относятся к одной FDW. Эта функция должна "
"построить путь(и) <structname>ForeignPath</structname> для любых действий "
"после сканирования/соединения, которые FDW умеет выполнять удалённо, и "
"вызвать <function>add_path</function>, чтобы добавить эти пути к указанному "
"верхнему отношению. Как и <function>GetForeignJoinPaths</function>, эта "
"функция не обязательно должна возвращать какие-либо пути, так как всегда "
"возможны пути с локальной обработкой."

#: fdwhandler.xml:378(para)
msgid ""
"The <literal>stage</literal> parameter identifies which post-scan/join step "
"is currently being considered. <literal>output_rel</literal> is the upper "
"relation that should receive paths representing computation of this step, "
"and <literal>input_rel</literal> is the relation representing the input to "
"this step. (Note that <structname>ForeignPath</structname> paths added to "
"<literal>output_rel</literal> would typically not have any direct dependency "
"on paths of the <literal>input_rel</literal>, since their processing is "
"expected to be done externally. However, examining paths previously "
"generated for the previous processing step can be useful to avoid redundant "
"planning work.)"
msgstr ""
"Параметр <literal>stage</literal> определяет, какой шаг после сканирования/"
"соединения рассматривается в данный момент. Параметр <literal>output_rel</"
"literal> указывает на верхнее отношение, которое должно получить пути, "
"представляющие вычисление этого шага, а <literal>input_rel</literal> — на "
"отношение, представляющее входные данные для этого шага. (Заметьте, что пути "
"<structname>ForeignPath</structname>, добавляемые в <literal>output_rel</"
"literal>, обычно не будут напрямую зависеть от путей <literal>input_rel</"
"literal>, так как ожидается, что они будут обрабатываться снаружи. Однако "
"изучить пути, построенные для предыдущего шага обработки, может быть полезно "
"для исключения лишних операций при планировании.)"

#: fdwhandler.xml:397(title)
msgid "FDW Routines For Updating Foreign Tables"
msgstr "Подпрограммы FDW для изменения данных в сторонних таблицах"

#: fdwhandler.xml:399(para)
msgid ""
"If an FDW supports writable foreign tables, it should provide some or all of "
"the following callback functions depending on the needs and capabilities of "
"the FDW:"
msgstr ""
"Если FDW поддерживает запись в сторонние таблицы, она должна предоставить "
"некоторые или все подпрограммы, реализующие следующие функции, в зависимости "
"от потребностей и возможностей FDW:"

#: fdwhandler.xml:406(programlisting)
#, no-wrap
msgid ""
"void\n"
"AddForeignUpdateTargets (Query *parsetree,\n"
"                         RangeTblEntry *target_rte,\n"
"                         Relation target_relation);"
msgstr ""
"void\n"
"AddForeignUpdateTargets (Query *parsetree,\n"
"                         RangeTblEntry *target_rte,\n"
"                         Relation target_relation);"

#: fdwhandler.xml:405(para)
msgid ""
"<placeholder-1/> <command>UPDATE</command> and <command>DELETE</command> "
"operations are performed against rows previously fetched by the table-"
"scanning functions. The FDW may need extra information, such as a row ID or "
"the values of primary-key columns, to ensure that it can identify the exact "
"row to update or delete. To support that, this function can add extra "
"hidden, or <quote>junk</quote>, target columns to the list of columns that "
"are to be retrieved from the foreign table during an <command>UPDATE</"
"command> or <command>DELETE</command>."
msgstr ""
"<placeholder-1/> Операции <command>UPDATE</command> и <command>DELETE</"
"command> выполняются со строками, ранее выбранными функциями сканирования "
"таблицы. FDW может потребоваться дополнительная информация, например, ID "
"строки или значения столбцов первичного ключа, чтобы точно знать, какую "
"именно строку нужно изменить или удалить. Для этого данная функция может "
"добавить дополнительные скрытые или <quote>отбросовые</quote> целевые "
"столбцы в список столбцов, которые должны быть получены из сторонней таблицы "
"во время <command>UPDATE</command> или <command>DELETE</command>."

#: fdwhandler.xml:423(para)
msgid ""
"To do that, add <structname>TargetEntry</structname> items to "
"<literal>parsetree-&gt;targetList</literal>, containing expressions for the "
"extra values to be fetched. Each such entry must be marked "
"<structfield>resjunk</structfield> = <literal>true</literal>, and must have "
"a distinct <structfield>resname</structfield> that will identify it at "
"execution time. Avoid using names matching <literal>ctid<replaceable>N</"
"replaceable></literal>, <literal>wholerow</literal>, or "
"<literal>wholerow<replaceable>N</replaceable></literal>, as the core system "
"can generate junk columns of these names."
msgstr ""
"Для этого добавьте в <literal>parsetree-&gt;targetList</literal> элементы "
"<structname>TargetEntry</structname>, содержащие выражения для "
"дополнительных выбираемых значений. У каждой такой записи должен быть "
"признак <structfield>resjunk</structfield> = <literal>true</literal> и "
"должно быть отдельное собственное имя <structfield>resname</structfield>, по "
"которому она будет идентифицироваться во время выполнения. Избегайте "
"использования имён вида <literal>ctid<replaceable>N</replaceable></literal>, "
"<literal>wholerow</literal> или <literal>wholerow<replaceable>N</"
"replaceable></literal>, так как столбцы с такими именами может генерировать "
"ядро системы."

#: fdwhandler.xml:435(para)
msgid ""
"This function is called in the rewriter, not the planner, so the information "
"available is a bit different from that available to the planning routines. "
"<literal>parsetree</literal> is the parse tree for the <command>UPDATE</"
"command> or <command>DELETE</command> command, while <literal>target_rte</"
"literal> and <literal>target_relation</literal> describe the target foreign "
"table."
msgstr ""
"Эта функция вызывается механизмом перезаписи запросов, а не планировщиком, "
"так что ей доступна информация, несколько отличающаяся от той, что получают "
"подпрограммы на этапе планирования. В <literal>parsetree</literal> "
"передаётся дерево разбора команды <command>UPDATE</command> или "
"<command>DELETE</command>, а параметры <literal>target_rte</literal> и "
"<literal>target_relation</literal> описывают целевую стороннюю таблицу."

#: fdwhandler.xml:444(para)
msgid ""
"If the <function>AddForeignUpdateTargets</function> pointer is set to "
"<literal>NULL</literal>, no extra target expressions are added. (This will "
"make it impossible to implement <command>DELETE</command> operations, though "
"<command>UPDATE</command> may still be feasible if the FDW relies on an "
"unchanging primary key to identify rows.)"
msgstr ""
"Если указатель <function>AddForeignUpdateTargets</function> равен "
"<literal>NULL</literal>, дополнительные целевые выражения не добавляются. "
"(Это делает невозможным реализацию операций <command>DELETE</command>, хотя "
"операция <command>UPDATE</command> может быть всё же возможна, если FDW "
"идентифицирует строки, полагаясь на то, что первичный ключ не меняется.)"

#: fdwhandler.xml:453(programlisting)
#, no-wrap
msgid ""
"List *\n"
"PlanForeignModify (PlannerInfo *root,\n"
"                   ModifyTable *plan,\n"
"                   Index resultRelation,\n"
"                   int subplan_index);"
msgstr ""
"List *\n"
"PlanForeignModify (PlannerInfo *root,\n"
"                   ModifyTable *plan,\n"
"                   Index resultRelation,\n"
"                   int subplan_index);"

#: fdwhandler.xml:452(para)
msgid ""
"<placeholder-1/> Perform any additional planning actions needed for an "
"insert, update, or delete on a foreign table. This function generates the "
"FDW-private information that will be attached to the "
"<structname>ModifyTable</structname> plan node that performs the update "
"action. This private information must have the form of a <literal>List</"
"literal>, and will be delivered to <function>BeginForeignModify</function> "
"during the execution stage."
msgstr ""
"<placeholder-1/> Выполняет любые дополнительные действия планирования, "
"необходимые для добавления, изменения или удаления в сторонней таблице. Эта "
"функция формирует частную информацию FDW, которая будет добавлена в узел "
"плана <structname>ModifyTable</structname>, осуществляющий изменение. Эта "
"информация должна возвращаться в списке (<literal>List</literal>); она будет "
"доставлена в функцию <function>BeginForeignModify</function> на стадии "
"выполнения."

#: fdwhandler.xml:469(para)
msgid ""
"<literal>root</literal> is the planner's global information about the query. "
"<literal>plan</literal> is the <structname>ModifyTable</structname> plan "
"node, which is complete except for the <structfield>fdwPrivLists</"
"structfield> field. <literal>resultRelation</literal> identifies the target "
"foreign table by its range table index. <literal>subplan_index</literal> "
"identifies which target of the <structname>ModifyTable</structname> plan "
"node this is, counting from zero; use this if you want to index into "
"<literal>plan-&gt;plans</literal> or other substructure of the "
"<literal>plan</literal> node."
msgstr ""
"В <literal>root</literal> передаётся общая информация планировщика о "
"запросе, а в <literal>plan</literal> — узел плана <structname>ModifyTable</"
"structname>, заполненный, не считая поля <structfield>fdwPrivLists</"
"structfield>. Параметр <literal>resultRelation</literal> указывает на "
"целевую стороннюю таблицу по номеру в списке отношений, а "
"<literal>subplan_index</literal> определяет целевое отношение в данном узле "
"<structname>ModifyTable</structname>, начиная с нуля; воспользуйтесь этим "
"индексом, обращаясь к <literal>plan-&gt;plans</literal> или другой вложенной "
"структуре узла <literal>plan</literal>."

#: fdwhandler.xml:484(para)
msgid ""
"If the <function>PlanForeignModify</function> pointer is set to "
"<literal>NULL</literal>, no additional plan-time actions are taken, and the "
"<literal>fdw_private</literal> list delivered to "
"<function>BeginForeignModify</function> will be NIL."
msgstr ""
"Если указатель <function>PlanForeignModify</function> равен <literal>NULL</"
"literal>, дополнительные действия во время планирования не предпринимаются, "
"и в качестве <literal>fdw_private</literal> в <function>BeginForeignModify</"
"function> поступит NULL."

#: fdwhandler.xml:492(programlisting)
#, no-wrap
msgid ""
"void\n"
"BeginForeignModify (ModifyTableState *mtstate,\n"
"                    ResultRelInfo *rinfo,\n"
"                    List *fdw_private,\n"
"                    int subplan_index,\n"
"                    int eflags);"
msgstr ""
"void\n"
"BeginForeignModify (ModifyTableState *mtstate,\n"
"                    ResultRelInfo *rinfo,\n"
"                    List *fdw_private,\n"
"                    int subplan_index,\n"
"                    int eflags);"

#: fdwhandler.xml:491(para)
msgid ""
"<placeholder-1/> Begin executing a foreign table modification operation. "
"This routine is called during executor startup. It should perform any "
"initialization needed prior to the actual table modifications. Subsequently, "
"<function>ExecForeignInsert</function>, <function>ExecForeignUpdate</"
"function> or <function>ExecForeignDelete</function> will be called for each "
"tuple to be inserted, updated, or deleted."
msgstr ""
"<placeholder-1/> Начинает выполнение операции изменения данных в сторонней "
"таблице. Эта подпрограмма выполняется при запуске исполнителя. Она должна "
"выполнять любые подготовительные действия, необходимые для того, чтобы "
"собственно произвести изменения в таблице. Впоследствии для каждого кортежа, "
"который будет вставляться, изменяться или удаляться, будет вызываться "
"<function>ExecForeignInsert</function>, <function>ExecForeignUpdate</"
"function> или <function>ExecForeignDelete</function>."

#: fdwhandler.xml:509(para)
msgid ""
"<literal>mtstate</literal> is the overall state of the "
"<structname>ModifyTable</structname> plan node being executed; global data "
"about the plan and execution state is available via this structure. "
"<literal>rinfo</literal> is the <structname>ResultRelInfo</structname> "
"struct describing the target foreign table. (The <structfield>ri_FdwState</"
"structfield> field of <structname>ResultRelInfo</structname> is available "
"for the FDW to store any private state it needs for this operation.) "
"<literal>fdw_private</literal> contains the private data generated by "
"<function>PlanForeignModify</function>, if any. <literal>subplan_index</"
"literal> identifies which target of the <structname>ModifyTable</structname> "
"plan node this is. <literal>eflags</literal> contains flag bits describing "
"the executor's operating mode for this plan node."
msgstr ""
"В параметре <literal>mtstate</literal> передаётся общее состояние "
"выполняемого плана узла <structname>ModifyTable</structname>; через эту "
"структуру доступны глобальные сведения о плане и состояние выполнения. В "
"<literal>rinfo</literal> передаётся структура <structname>ResultRelInfo</"
"structname>, описывающая целевую стороннюю таблицу. (Если FDW нужно "
"сохранить частное состояние, необходимое для этой операции, она может "
"воспользоваться полем <structfield>ri_FdwState</structfield> структуры "
"<structname>ResultRelInfo</structname>.) В <literal>fdw_private</literal> "
"передаются частные данные, если они были сформированы процедурой "
"<function>PlanForeignModify</function>. Параметр <literal>subplan_index</"
"literal> определяет целевое отношение в данном узле <structname>ModifyTable</"
"structname>, а в <literal>eflags</literal> передаются битовые флаги, "
"описывающие режим работы исполнителя для этого узла плана."

#: fdwhandler.xml:525(para)
msgid ""
"Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is "
"true, this function should not perform any externally-visible actions; it "
"should only do the minimum required to make the node state valid for "
"<function>ExplainForeignModify</function> and <function>EndForeignModify</"
"function>."
msgstr ""
"Заметьте, что когда <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> "
"не равно нулю, эта функция не должна выполнять какие-либо внешне "
"проявляющиеся действия; она должна сделать только то, что необходимо для "
"получения состояния узла, подходящего для <function>ExplainForeignModify</"
"function> и <function>EndForeignModify</function>."

#: fdwhandler.xml:532(para)
msgid ""
"If the <function>BeginForeignModify</function> pointer is set to "
"<literal>NULL</literal>, no action is taken during executor startup."
msgstr ""
"Если указатель на <function>BeginForeignModify</function> равен "
"<literal>NULL</literal>, никакое действие при запуске исполнителя не "
"выполняется."

#: fdwhandler.xml:538(programlisting)
#, no-wrap
msgid ""
"TupleTableSlot *\n"
"ExecForeignInsert (EState *estate,\n"
"                   ResultRelInfo *rinfo,\n"
"                   TupleTableSlot *slot,\n"
"                   TupleTableSlot *planSlot);"
msgstr ""
"TupleTableSlot *\n"
"ExecForeignInsert (EState *estate,\n"
"                   ResultRelInfo *rinfo,\n"
"                   TupleTableSlot *slot,\n"
"                   TupleTableSlot *planSlot);"

#: fdwhandler.xml:537(para)
msgid ""
"<placeholder-1/> Insert one tuple into the foreign table. <literal>estate</"
"literal> is global execution state for the query. <literal>rinfo</literal> "
"is the <structname>ResultRelInfo</structname> struct describing the target "
"foreign table. <literal>slot</literal> contains the tuple to be inserted; it "
"will match the row-type definition of the foreign table. <literal>planSlot</"
"literal> contains the tuple that was generated by the "
"<structname>ModifyTable</structname> plan node's subplan; it differs from "
"<literal>slot</literal> in possibly containing additional <quote>junk</"
"quote> columns. (The <literal>planSlot</literal> is typically of little "
"interest for <command>INSERT</command> cases, but is provided for "
"completeness.)"
msgstr ""
"<placeholder-1/> Вставляет один кортеж в стороннюю таблицу. В "
"<literal>estate</literal> передаётся глобальное состояние выполнения "
"запроса, а в <literal>rinfo</literal> — структура <structname>ResultRelInfo</"
"structname>, описывающая целевую стороннюю таблицу. Параметр <literal>slot</"
"literal> содержит кортеж, который должен быть вставлен; он будет "
"соответствовать определению типа строки сторонней таблицы. Параметр "
"<literal>planSlot</literal> содержит кортеж, сформированный вложенным планом "
"узла <structname>ModifyTable</structname>; он отличается от <literal>slot</"
"literal> тем, что может содержать дополнительные <quote>отбросовые</quote> "
"столбцы. (Значение <literal>planSlot</literal> обычно не очень интересно для "
"операций <command>INSERT</command>, но оно представлено для полноты.)"

#: fdwhandler.xml:559(para)
msgid ""
"The return value is either a slot containing the data that was actually "
"inserted (this might differ from the data supplied, for example as a result "
"of trigger actions), or NULL if no row was actually inserted (again, "
"typically as a result of triggers). The passed-in <literal>slot</literal> "
"can be re-used for this purpose."
msgstr ""
"Возвращаемым значением будет либо слот, содержащий данные, которые были "
"фактически вставлены (они могут отличаться от переданных данных, например, в "
"результате действий триггеров), либо NULL, если никакая строка фактически не "
"была вставлена (опять же, обычно в результате действий триггеров). Чтобы "
"вернуть результат, также можно использовать передаваемый на вход "
"<literal>slot</literal>."

#: fdwhandler.xml:567(para)
msgid ""
"The data in the returned slot is used only if the <command>INSERT</command> "
"query has a <literal>RETURNING</literal> clause or the foreign table has an "
"<literal>AFTER ROW</literal> trigger. Triggers require all columns, but the "
"FDW could choose to optimize away returning some or all columns depending on "
"the contents of the <literal>RETURNING</literal> clause. Regardless, some "
"slot must be returned to indicate success, or the query's reported row count "
"will be wrong."
msgstr ""
"Данные в возвращаемом слоте используются, только если запрос "
"<command>INSERT</command> содержит предложение <literal>RETURNING</literal> "
"или для сторонней таблицы определён триггер <literal>AFTER ROW</literal>. "
"Триггерам нужны все столбцы, но для предложения <literal>RETURNING</literal> "
"FDW может ради оптимизации не возвращать некоторые или все столбцы, в "
"зависимости от его содержания. Так или иначе, какой-либо слот необходимо "
"вернуть, чтобы отметить, что операция успешна, иначе возвращённое число "
"строк будет неверным."

#: fdwhandler.xml:577(para)
msgid ""
"If the <function>ExecForeignInsert</function> pointer is set to "
"<literal>NULL</literal>, attempts to insert into the foreign table will fail "
"with an error message."
msgstr ""
"Если указатель на <function>ExecForeignInsert</function> равен "
"<literal>NULL</literal>, вставить данные в стороннюю таблицу не удастся, в "
"ответ будет выдаваться сообщение об ошибке."

#: fdwhandler.xml:584(programlisting)
#, no-wrap
msgid ""
"TupleTableSlot *\n"
"ExecForeignUpdate (EState *estate,\n"
"                   ResultRelInfo *rinfo,\n"
"                   TupleTableSlot *slot,\n"
"                   TupleTableSlot *planSlot);"
msgstr ""
"TupleTableSlot *\n"
"ExecForeignUpdate (EState *estate,\n"
"                   ResultRelInfo *rinfo,\n"
"                   TupleTableSlot *slot,\n"
"                   TupleTableSlot *planSlot);"

#: fdwhandler.xml:583(para)
msgid ""
"<placeholder-1/> Update one tuple in the foreign table. <literal>estate</"
"literal> is global execution state for the query. <literal>rinfo</literal> "
"is the <structname>ResultRelInfo</structname> struct describing the target "
"foreign table. <literal>slot</literal> contains the new data for the tuple; "
"it will match the row-type definition of the foreign table. "
"<literal>planSlot</literal> contains the tuple that was generated by the "
"<structname>ModifyTable</structname> plan node's subplan; it differs from "
"<literal>slot</literal> in possibly containing additional <quote>junk</"
"quote> columns. In particular, any junk columns that were requested by "
"<function>AddForeignUpdateTargets</function> will be available from this "
"slot."
msgstr ""
"<placeholder-1/> Изменяет один кортеж в сторонней таблице. В "
"<literal>estate</literal> передаётся глобальное состояние выполнения "
"запроса, а в <literal>rinfo</literal> — структура <structname>ResultRelInfo</"
"structname>, описывающая целевую стороннюю таблицу. Параметр <literal>slot</"
"literal> содержит новые данные для кортежа; он будет соответствовать "
"определению типа строки сторонней таблицы. Параметр <literal>planSlot</"
"literal> содержит кортеж, сформированный вложенным планом узла "
"<structname>ModifyTable</structname>; он отличается от <literal>slot</"
"literal> тем, что может содержать дополнительные <quote>отбросовые</quote> "
"столбцы. В частности, в этом слоте можно получить любые отбросовые столбцы, "
"запрошенные в <function>AddForeignUpdateTargets</function>."

#: fdwhandler.xml:605(para)
msgid ""
"The return value is either a slot containing the row as it was actually "
"updated (this might differ from the data supplied, for example as a result "
"of trigger actions), or NULL if no row was actually updated (again, "
"typically as a result of triggers). The passed-in <literal>slot</literal> "
"can be re-used for this purpose."
msgstr ""
"Возвращаемым значением будет либо слот, содержащий строку в состоянии после "
"изменения (её содержимое может отличаться от переданного, например, в "
"результате действий триггеров), либо NULL, если никакая строка фактически не "
"была изменена (опять же, обычно в результате действий триггеров). Чтобы "
"вернуть результат, также можно использовать передаваемый на вход "
"<literal>slot</literal>."

#: fdwhandler.xml:613(para)
msgid ""
"The data in the returned slot is used only if the <command>UPDATE</command> "
"query has a <literal>RETURNING</literal> clause or the foreign table has an "
"<literal>AFTER ROW</literal> trigger. Triggers require all columns, but the "
"FDW could choose to optimize away returning some or all columns depending on "
"the contents of the <literal>RETURNING</literal> clause. Regardless, some "
"slot must be returned to indicate success, or the query's reported row count "
"will be wrong."
msgstr ""
"Данные в возвращаемом слоте используются, только если запрос "
"<command>UPDATE</command> содержит предложение <literal>RETURNING</literal> "
"или для сторонней таблицы определён триггер <literal>AFTER ROW</literal>. "
"Триггерам нужны все столбцы, но для предложения <literal>RETURNING</literal> "
"FDW может ради оптимизации не возвращать некоторые или все столбцы, в "
"зависимости от его содержания. Так или иначе, какой-либо слот необходимо "
"вернуть, чтобы отметить, что операция успешна, иначе возвращённое число "
"строк будет неверным."

#: fdwhandler.xml:623(para)
msgid ""
"If the <function>ExecForeignUpdate</function> pointer is set to "
"<literal>NULL</literal>, attempts to update the foreign table will fail with "
"an error message."
msgstr ""
"Если указатель на <function>ExecForeignUpdate</function> равен "
"<literal>NULL</literal>, изменить данные в сторонней таблице не удастся, а в "
"ответ будет выдаваться сообщение об ошибке."

#: fdwhandler.xml:630(programlisting)
#, no-wrap
msgid ""
"TupleTableSlot *\n"
"ExecForeignDelete (EState *estate,\n"
"                   ResultRelInfo *rinfo,\n"
"                   TupleTableSlot *slot,\n"
"                   TupleTableSlot *planSlot);"
msgstr ""
"TupleTableSlot *\n"
"ExecForeignDelete (EState *estate,\n"
"                   ResultRelInfo *rinfo,\n"
"                   TupleTableSlot *slot,\n"
"                   TupleTableSlot *planSlot);"

#: fdwhandler.xml:629(para)
msgid ""
"<placeholder-1/> Delete one tuple from the foreign table. <literal>estate</"
"literal> is global execution state for the query. <literal>rinfo</literal> "
"is the <structname>ResultRelInfo</structname> struct describing the target "
"foreign table. <literal>slot</literal> contains nothing useful upon call, "
"but can be used to hold the returned tuple. <literal>planSlot</literal> "
"contains the tuple that was generated by the <structname>ModifyTable</"
"structname> plan node's subplan; in particular, it will carry any junk "
"columns that were requested by <function>AddForeignUpdateTargets</function>. "
"The junk column(s) must be used to identify the tuple to be deleted."
msgstr ""
"<placeholder-1/> Удаляет один кортеж из сторонней таблицы. В "
"<literal>estate</literal> передаётся глобальное состояние выполнения "
"запроса, а в <literal>rinfo</literal> — структура <structname>ResultRelInfo</"
"structname>, описывающая целевую стороннюю таблицу. Параметр <literal>slot</"
"literal> при вызове не содержит ничего полезного, но в эту структуру можно "
"поместить возвращаемый кортеж. Параметр <literal>planSlot</literal> содержит "
"кортеж, сформированный вложенным планом узла <structname>ModifyTable</"
"structname>; в частности, в нём могут содержаться отбросовые столбцы, "
"запрошенные в <function>AddForeignUpdateTargets</function>. Отбросовые "
"столбцы необходимы, чтобы определить, какой именно кортеж удалять."

#: fdwhandler.xml:651(para)
msgid ""
"The return value is either a slot containing the row that was deleted, or "
"NULL if no row was deleted (typically as a result of triggers). The passed-"
"in <literal>slot</literal> can be used to hold the tuple to be returned."
msgstr ""
"Возвращаемым значением будет либо слот, содержащий строку, которая была "
"удалена, либо NULL, если не удалена никакая строка (обычно в результате "
"действия триггеров). Для размещения возвращаемого кортежа можно использовать "
"передаваемый на вход <literal>slot</literal>."

#: fdwhandler.xml:657(para)
msgid ""
"The data in the returned slot is used only if the <command>DELETE</command> "
"query has a <literal>RETURNING</literal> clause or the foreign table has an "
"<literal>AFTER ROW</literal> trigger. Triggers require all columns, but the "
"FDW could choose to optimize away returning some or all columns depending on "
"the contents of the <literal>RETURNING</literal> clause. Regardless, some "
"slot must be returned to indicate success, or the query's reported row count "
"will be wrong."
msgstr ""
"Данные в возвращаемом слоте используются, только если запрос "
"<command>DELETE</command> содержит предложение <literal>RETURNING</literal> "
"или для сторонней таблицы определён триггер <literal>AFTER ROW</literal>. "
"Триггерам нужны все столбцы, но для предложения <literal>RETURNING</literal> "
"FDW может ради оптимизации не возвращать некоторые или все столбцы, в "
"зависимости от его содержания. Так или иначе, какой-либо слот необходимо "
"вернуть, чтобы отметить, что операция успешна, иначе возвращённое число "
"строк будет неверным."

#: fdwhandler.xml:667(para)
msgid ""
"If the <function>ExecForeignDelete</function> pointer is set to "
"<literal>NULL</literal>, attempts to delete from the foreign table will fail "
"with an error message."
msgstr ""
"Если указатель на <function>ExecForeignDelete</function> равен "
"<literal>NULL</literal>, удалить данные из сторонней таблицы не удастся, а в "
"ответ будет выдаваться сообщение об ошибке."

#: fdwhandler.xml:674(programlisting)
#, no-wrap
msgid ""
"void\n"
"EndForeignModify (EState *estate,\n"
"                  ResultRelInfo *rinfo);"
msgstr ""
"void\n"
"EndForeignModify (EState *estate,\n"
"                  ResultRelInfo *rinfo);"

#: fdwhandler.xml:673(para)
msgid ""
"<placeholder-1/> End the table update and release resources. It is normally "
"not important to release palloc'd memory, but for example open files and "
"connections to remote servers should be cleaned up."
msgstr ""
"<placeholder-1/> Завершает изменение данных в таблице и освобождает ресурсы. "
"Обычно при этом не нужно освобождать память, выделенную через palloc, но "
"например, открытые файлы и подключения к удалённым серверам следует закрыть."

#: fdwhandler.xml:685(para)
msgid ""
"If the <function>EndForeignModify</function> pointer is set to "
"<literal>NULL</literal>, no action is taken during executor shutdown."
msgstr ""
"Если указатель на <function>EndForeignModify</function> равен <literal>NULL</"
"literal>, никакое действие при завершении исполнителя не выполняется."

#: fdwhandler.xml:691(programlisting)
#, no-wrap
msgid ""
"int\n"
"IsForeignRelUpdatable (Relation rel);"
msgstr ""
"int\n"
"IsForeignRelUpdatable (Relation rel);"

#: fdwhandler.xml:690(para)
msgid ""
"<placeholder-1/> Report which update operations the specified foreign table "
"supports. The return value should be a bit mask of rule event numbers "
"indicating which operations are supported by the foreign table, using the "
"<literal>CmdType</literal> enumeration; that is, <literal>(1 &lt;&lt; "
"CMD_UPDATE) = 4</literal> for <command>UPDATE</command>, <literal>(1 &lt;"
"&lt; CMD_INSERT) = 8</literal> for <command>INSERT</command>, and "
"<literal>(1 &lt;&lt; CMD_DELETE) = 16</literal> for <command>DELETE</"
"command>."
msgstr ""
"<placeholder-1/> Сообщает, какие операции изменения данных поддерживает "
"указанная сторонняя таблица. Возвращаемое значение должно быть битовой "
"маской кодов событий, обозначающих операции, поддерживаемые таблицей, и "
"заданных в перечислении <literal>CmdType</literal>; то есть, <literal>(1 &lt;"
"&lt; CMD_UPDATE) = 4</literal> для <command>UPDATE</command>, <literal>(1 "
"&lt;&lt; CMD_INSERT) = 8</literal> для <command>INSERT</command> и "
"<literal>(1 &lt;&lt; CMD_DELETE) = 16</literal> для <command>DELETE</"
"command>."

#: fdwhandler.xml:705(para)
msgid ""
"If the <function>IsForeignRelUpdatable</function> pointer is set to "
"<literal>NULL</literal>, foreign tables are assumed to be insertable, "
"updatable, or deletable if the FDW provides <function>ExecForeignInsert</"
"function>, <function>ExecForeignUpdate</function>, or "
"<function>ExecForeignDelete</function> respectively. This function is only "
"needed if the FDW supports some tables that are updatable and some that are "
"not. (Even then, it's permissible to throw an error in the execution routine "
"instead of checking in this function. However, this function is used to "
"determine updatability for display in the <literal>information_schema</"
"literal> views.)"
msgstr ""
"Если указатель на <function>IsForeignRelUpdatable</function> равен "
"<literal>NULL</literal>, предполагается, что сторонние таблицы позволяют "
"добавлять, изменять и удалять строки, если FDW предоставляет процедуры для "
"функций <function>ExecForeignInsert</function>, <function>ExecForeignUpdate</"
"function> или <function>ExecForeignDelete</function>, соответственно. Данная "
"функция необходима, только если FDW поддерживает операции изменения для "
"одних таблиц и не поддерживает для других. (Хотя для этого можно выдать "
"ошибку в подпрограмме, выполняющей операцию, а не задействовать эту функцию. "
"Однако данная функция позволяет корректно отражать поддержку изменений в "
"представлениях <literal>information_schema</literal>.)"

#: fdwhandler.xml:717(para)
msgid ""
"Some inserts, updates, and deletes to foreign tables can be optimized by "
"implementing an alternative set of interfaces. The ordinary interfaces for "
"inserts, updates, and deletes fetch rows from the remote server and then "
"modify those rows one at a time. In some cases, this row-by-row approach is "
"necessary, but it can be inefficient. If it is possible for the foreign "
"server to determine which rows should be modified without actually "
"retrieving them, and if there are no local triggers which would affect the "
"operation, then it is possible to arrange things so that the entire "
"operation is performed on the remote server. The interfaces described below "
"make this possible."
msgstr ""
"Некоторые операции добавления, изменений и удаления данных в сторонних "
"таблицах можно соптимизировать, применив альтернативный набор интерфейсов. "
"Обычные интерфейсы для операций добавления, изменения и удаления выбирают "
"строки с удалённого сервера, а затем модифицируют их по одной. В некоторых "
"случаях такой подход &laquo;строка-за-строкой&raquo; необходим, но он может "
"быть не самым эффективным. Если есть возможность определить на стороннем "
"сервере, какие строки должны модифицироваться, собственно не считывая их, и "
"если никакие локальные триггеры этой операцией не затрагиваются, то возможно "
"организовать операцию так, чтобы она выполнялась целиком на удалённом "
"сервере. Это становится возможным благодаря описанным ниже интерфейсам."

#: fdwhandler.xml:731(programlisting)
#, no-wrap
msgid ""
"bool\n"
"PlanDirectModify (PlannerInfo *root,\n"
"                  ModifyTable *plan,\n"
"                  Index resultRelation,\n"
"                  int subplan_index);"
msgstr ""
"bool\n"
"PlanDirectModify (PlannerInfo *root,\n"
"                  ModifyTable *plan,\n"
"                  Index resultRelation,\n"
"                  int subplan_index);"

#: fdwhandler.xml:730(para)
msgid ""
"<placeholder-1/> Decide whether it is safe to execute a direct modification "
"on the remote server. If so, return <literal>true</literal> after performing "
"planning actions needed for that. Otherwise, return <literal>false</"
"literal>. This optional function is called during query planning. If this "
"function succeeds, <function>BeginDirectModify</function>, "
"<function>IterateDirectModify</function> and <function>EndDirectModify</"
"function> will be called at the execution stage, instead. Otherwise, the "
"table modification will be executed using the table-updating functions "
"described above. The parameters are the same as for "
"<function>PlanForeignModify</function>."
msgstr ""
"<placeholder-1/> Определяет, возможно ли безопасно выполнить прямую "
"модификацию на удалённом сервере. Если да, возвращает <literal>true</"
"literal>, произведя требуемые для этого операции планирования. В противном "
"случае возвращает <literal>false</literal>. Эта необязательная функция "
"вызывается во время планирования запроса. Если результат этой функции "
"положительный, на стадии выполнения будут вызываться "
"<function>BeginDirectModify</function>, <function>IterateDirectModify</"
"function> и <function>EndDirectModify</function>. Иначе модификация таблиц "
"будет осуществляться посредством функций изменения, описанных выше. Данная "
"функция принимает те же параметры, что и <function>PlanForeignModify</"
"function>."

#: fdwhandler.xml:751(para)
msgid ""
"To execute the direct modification on the remote server, this function must "
"rewrite the target subplan with a <structname>ForeignScan</structname> plan "
"node that executes the direct modification on the remote server. The "
"<structfield>operation</structfield> field of the <structname>ForeignScan</"
"structname> must be set to the <literal>CmdType</literal> enumeration "
"appropriately; that is, <literal>CMD_UPDATE</literal> for <command>UPDATE</"
"command>, <literal>CMD_INSERT</literal> for <command>INSERT</command>, and "
"<literal>CMD_DELETE</literal> for <command>DELETE</command>."
msgstr ""
"Для осуществления прямой модификации на удалённом сервере эта функция должна "
"подставить в целевой подплан узел <structname>ForeignScan</structname>, "
"выполняющий прямую модификацию на удалённом сервере. В поле "
"<structfield>operation</structfield> структуры <structname>ForeignScan</"
"structname> должно быть установлено соответствующее значение перечисления "
"<literal>CmdType</literal>: то есть, <literal>CMD_UPDATE</literal> для "
"<command>UPDATE</command>, <literal>CMD_INSERT</literal> для "
"<command>INSERT</command> и <literal>CMD_DELETE</literal> для "
"<command>DELETE</command>."

#: fdwhandler.xml:766(para)
msgid ""
"If the <function>PlanDirectModify</function> pointer is set to "
"<literal>NULL</literal>, no attempts to execute a direct modification on the "
"remote server are taken."
msgstr ""
"Если указатель на <function>PlanDirectModify</function> равен <literal>NULL</"
"literal>, сервер не будет пытаться произвести прямую модификацию."

#: fdwhandler.xml:773(programlisting)
#, no-wrap
msgid ""
"void\n"
"BeginDirectModify (ForeignScanState *node,\n"
"                   int eflags);"
msgstr ""
"void\n"
"BeginDirectModify (ForeignScanState *node,\n"
"                   int eflags);"

#: fdwhandler.xml:772(para)
msgid ""
"<placeholder-1/> Prepare to execute a direct modification on the remote "
"server. This is called during executor startup. It should perform any "
"initialization needed prior to the direct modification (that should be done "
"upon the first call to <function>IterateDirectModify</function>). The "
"<structname>ForeignScanState</structname> node has already been created, but "
"its <structfield>fdw_state</structfield> field is still NULL. Information "
"about the table to modify is accessible through the "
"<structname>ForeignScanState</structname> node (in particular, from the "
"underlying <structname>ForeignScan</structname> plan node, which contains "
"any FDW-private information provided by <function>PlanDirectModify</"
"function>). <literal>eflags</literal> contains flag bits describing the "
"executor's operating mode for this plan node."
msgstr ""
"<placeholder-1/> Подготавливает прямую модификацию на удалённом сервере. Эта "
"функция вызывается при запуске исполнителя. Она должна выполнить все "
"подготовительные действия, необходимые для осуществления прямой модификации "
"(модификация должна начаться с первым вызовом <function>IterateDirectModify</"
"function>). Узел <structname>ForeignScanState</structname> уже был создан, "
"но его поле <structfield>fdw_state</structfield> по-прежнему NULL. "
"Информацию о модифицируемой таблице можно получить через узел "
"<structname>ForeignScanState</structname> (в частности, из нижележащего узла "
"<structname>ForeignScan</structname>, содержащего частную информацию FDW, "
"заданную функцией <function>PlanDirectModify</function>). Параметр "
"<literal>eflags</literal> содержит битовые флаги, описывающие режим работы "
"исполнителя для этого узла плана."

#: fdwhandler.xml:793(para)
msgid ""
"Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is "
"true, this function should not perform any externally-visible actions; it "
"should only do the minimum required to make the node state valid for "
"<function>ExplainDirectModify</function> and <function>EndDirectModify</"
"function>."
msgstr ""
"Заметьте, что когда <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> "
"не равно нулю, эта функция не должна выполнять какие-либо внешне "
"проявляющиеся действия; она должна сделать только то, что необходимо для "
"получения состояния узла, подходящего для <function>ExplainDirectModify</"
"function> и <function>EndDirectModify</function>."

#: fdwhandler.xml:800(para)
msgid ""
"If the <function>BeginDirectModify</function> pointer is set to "
"<literal>NULL</literal>, no attempts to execute a direct modification on the "
"remote server are taken."
msgstr ""
"Если указатель на <function>BeginDirectModify</function> равен "
"<literal>NULL</literal>, сервер не будет пытаться произвести прямую "
"модификацию."

#: fdwhandler.xml:807(programlisting)
#, no-wrap
msgid ""
"TupleTableSlot *\n"
"IterateDirectModify (ForeignScanState *node);"
msgstr ""
"TupleTableSlot *\n"
"IterateDirectModify (ForeignScanState *node);"

#: fdwhandler.xml:806(para)
msgid ""
"<placeholder-1/> When the <command>INSERT</command>, <command>UPDATE</"
"command> or <command>DELETE</command> query doesn't have a "
"<literal>RETURNING</literal> clause, just return NULL after a direct "
"modification on the remote server. When the query has the clause, fetch one "
"result containing the data needed for the <literal>RETURNING</literal> "
"calculation, returning it in a tuple table slot (the node's "
"<structfield>ScanTupleSlot</structfield> should be used for this purpose). "
"The data that was actually inserted, updated or deleted must be stored in "
"the <literal>es_result_relation_info-&gt;ri_projectReturning-&gt;"
"pi_exprContext-&gt;ecxt_scantuple</literal> of the node's "
"<structname>EState</structname>. Return NULL if no more rows are available. "
"Note that this is called in a short-lived memory context that will be reset "
"between invocations. Create a memory context in <function>BeginDirectModify</"
"function> if you need longer-lived storage, or use the "
"<structfield>es_query_cxt</structfield> of the node's <structname>EState</"
"structname>."
msgstr ""
"<placeholder-1/> Когда в запросе <command>INSERT</command>, <command>UPDATE</"
"command> или <command>DELETE</command> отсутствует предложение "
"<literal>RETURNING</literal>, просто возвращает NULL после прямой "
"модификации на удалённом сервере. Когда в запросе есть это предложение, "
"выбирает одну строку результата с данными, требующимися для вычисления "
"<literal>RETURNING</literal>, и возвращает её в слоте таблицы кортежей (для "
"этой цели следует использовать <structfield>ScanTupleSlot</structfield>, "
"переданный с узлом). Данные, которые были фактически добавлены, изменены или "
"удалены, нужно сохранить в <literal>es_result_relation_info-&gt;"
"ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</literal> в "
"структуре <structname>EState</structname>, переданной с узлом. Возвращает "
"NULL, если строк больше нет. Заметьте, что эта функция вызывается в "
"контексте кратковременной памяти, который будет сбрасываться между вызовами. "
"Если вам нужна более долгоживущая память, создайте соответствующий контекст "
"в <function>BeginDirectModify</function> либо используйте "
"<structfield>es_query_cxt</structfield> из переданной с узлом структуры "
"<structname>EState</structname>."

#: fdwhandler.xml:829(para)
msgid ""
"The rows returned must match the <structfield>fdw_scan_tlist</structfield> "
"target list if one was supplied, otherwise they must match the row type of "
"the foreign table being updated. If you choose to optimize away fetching "
"columns that are not needed for the <literal>RETURNING</literal> "
"calculation, you should insert nulls in those column positions, or else "
"generate a <structfield>fdw_scan_tlist</structfield> list with those columns "
"omitted."
msgstr ""
"Возвращаемые строки должны соответствовать целевому списку "
"<structfield>fdw_scan_tlist</structfield>, если он передаётся, а в противном "
"случае — типу строки изменяемой сторонней таблицы. Если вы решите для "
"оптимизации не возвращать ненужные столбцы, не требующиеся для получения "
"<literal>RETURNING</literal>, в их позиции нужно вставить NULL, либо "
"сформировать список <structfield>fdw_scan_tlist</structfield> без этих "
"столбцов."

#: fdwhandler.xml:838(para)
msgid ""
"Whether the query has the clause or not, the query's reported row count must "
"be incremented by the FDW itself. When the query doesn't have the clause, "
"the FDW must also increment the row count for the "
"<structname>ForeignScanState</structname> node in the <command>EXPLAIN "
"ANALYZE</command> case."
msgstr ""
"Независимо от того, есть ли в запросе это предложение или нет, число строк, "
"возвращаемых запросом, должно увеличиваться самой FDW. Когда этого "
"предложения в запросе нет, FDW должна также увеличивать число строк для узла "
"<structname>ForeignScanState</structname> в случае <command>EXPLAIN ANALYZE</"
"command>."

#: fdwhandler.xml:846(para)
msgid ""
"If the <function>IterateDirectModify</function> pointer is set to "
"<literal>NULL</literal>, no attempts to execute a direct modification on the "
"remote server are taken."
msgstr ""
"Если указатель на <function>IterateDirectModify</function> равен "
"<literal>NULL</literal>, сервер не будет пытаться произвести прямую "
"модификацию."

#: fdwhandler.xml:853(programlisting)
#, no-wrap
msgid ""
"void\n"
"EndDirectModify (ForeignScanState *node);"
msgstr ""
"void\n"
"EndDirectModify (ForeignScanState *node);"

#: fdwhandler.xml:852(para)
msgid ""
"<placeholder-1/> Clean up following a direct modification on the remote "
"server. It is normally not important to release palloc'd memory, but for "
"example open files and connections to the remote server should be cleaned up."
msgstr ""
"<placeholder-1/> Очищает ресурсы после непосредственной модификации на "
"удалённом сервере. Обычно при этом не нужно освобождать память, выделенную "
"через palloc, но например, открытые файлы и подключения к удалённому серверу "
"следует закрыть."

#: fdwhandler.xml:863(para)
msgid ""
"If the <function>EndDirectModify</function> pointer is set to <literal>NULL</"
"literal>, no attempts to execute a direct modification on the remote server "
"are taken."
msgstr ""
"Если указатель на <function>EndDirectModify</function> равен <literal>NULL</"
"literal>, сервер не будет пытаться произвести прямую модификацию."

#: fdwhandler.xml:872(title)
msgid "FDW Routines For Row Locking"
msgstr "Подпрограммы FDW для блокировки строк"

#: fdwhandler.xml:874(para)
msgid ""
"If an FDW wishes to support <firstterm>late row locking</firstterm> (as "
"described in <xref linkend=\"fdw-row-locking\"/>), it must provide the "
"following callback functions:"
msgstr ""
"Если FDW желает поддержать функцию <firstterm>поздней блокировки строк</"
"firstterm> (описанную в <xref remap=\"6\" linkend=\"fdw-row-locking\"/>), "
"она должна предоставить следующие реализующие подпрограммы:"

#: fdwhandler.xml:881(programlisting)
#, no-wrap
msgid ""
"RowMarkType\n"
"GetForeignRowMarkType (RangeTblEntry *rte,\n"
"                       LockClauseStrength strength);"
msgstr ""
"RowMarkType\n"
"GetForeignRowMarkType (RangeTblEntry *rte,\n"
"                       LockClauseStrength strength);"

#: fdwhandler.xml:880(para)
msgid ""
"<placeholder-1/> Report which row-marking option to use for a foreign table. "
"<literal>rte</literal> is the <structname>RangeTblEntry</structname> node "
"for the table and <literal>strength</literal> describes the lock strength "
"requested by the relevant <literal>FOR UPDATE/SHARE</literal> clause, if "
"any. The result must be a member of the <literal>RowMarkType</literal> enum "
"type."
msgstr ""
"<placeholder-1/> Сообщает, какой вариант пометки строк будет использоваться "
"для сторонней таблицы. Здесь <literal>rte</literal> представляет узел "
"<structname>RangeTblEntry</structname> для таблицы, а <literal>strength</"
"literal> описывает силу блокировки, запрошенную соответствующим предложением "
"<literal>FOR UPDATE/SHARE</literal>, если оно имеется. Результатом должно "
"быть значение перечисления <literal>RowMarkType</literal>."

#: fdwhandler.xml:894(para)
msgid ""
"This function is called during query planning for each foreign table that "
"appears in an <command>UPDATE</command>, <command>DELETE</command>, or "
"<command>SELECT FOR UPDATE/SHARE</command> query and is not the target of "
"<command>UPDATE</command> or <command>DELETE</command>."
msgstr ""
"Эта функция вызывается в процессе планирования запроса для каждой сторонней "
"таблицы, которая участвует в запросе <command>UPDATE</command>, "
"<command>DELETE</command> или <command>SELECT FOR UPDATE/SHARE</command>, и "
"не является целевой в запросе <command>UPDATE</command> или <command>DELETE</"
"command>."

#: fdwhandler.xml:901(para)
msgid ""
"If the <function>GetForeignRowMarkType</function> pointer is set to "
"<literal>NULL</literal>, the <literal>ROW_MARK_COPY</literal> option is "
"always used. (This implies that <function>RefetchForeignRow</function> will "
"never be called, so it need not be provided either.)"
msgstr ""
"Если указатель <function>GetForeignRowMarkType</function> равен "
"<literal>NULL</literal>, всегда выбирается вариант <literal>ROW_MARK_COPY</"
"literal>. (Вследствие этого, функция <function>RefetchForeignRow</function> "
"никогда не будет вызываться, так что и её задавать не нужно.)"

#: fdwhandler.xml:908(para) fdwhandler.xml:967(para)
msgid "See <xref linkend=\"fdw-row-locking\"/> for more information."
msgstr ""
"За подробностями обратитесь к <xref remap=\"3\" linkend=\"fdw-row-locking\"/"
">."

#: fdwhandler.xml:913(programlisting)
#, no-wrap
msgid ""
"HeapTuple\n"
"RefetchForeignRow (EState *estate,\n"
"                   ExecRowMark *erm,\n"
"                   Datum rowid,\n"
"                   bool *updated);"
msgstr ""
"HeapTuple\n"
"RefetchForeignRow (EState *estate,\n"
"                   ExecRowMark *erm,\n"
"                   Datum rowid,\n"
"                   bool *updated);"

#: fdwhandler.xml:912(para)
msgid ""
"<placeholder-1/> Re-fetch one tuple from the foreign table, after locking it "
"if required. <literal>estate</literal> is global execution state for the "
"query. <literal>erm</literal> is the <structname>ExecRowMark</structname> "
"struct describing the target foreign table and the row lock type (if any) to "
"acquire. <literal>rowid</literal> identifies the tuple to be fetched. "
"<literal>updated</literal> is an output parameter."
msgstr ""
"<placeholder-1/> Повторно считывает один кортеж из сторонней таблицы после "
"блокировки, если она требуется. В <literal>estate</literal> передаётся "
"глобальное состояние выполнения запроса. В <literal>erm</literal> передаётся "
"структура <structname>ExecRowMark</structname>, описывающая целевую "
"стороннюю таблицу и тип запрашиваемой блокировки (если требуется "
"блокировка). Параметр <literal>rowid</literal> идентифицирует считываемый "
"кортеж. Параметр <literal>updated</literal> используется как выходной."

#: fdwhandler.xml:929(para)
msgid ""
"This function should return a palloc'ed copy of the fetched tuple, or "
"<literal>NULL</literal> if the row lock couldn't be obtained. The row lock "
"type to acquire is defined by <literal>erm-&gt;markType</literal>, which is "
"the value previously returned by <function>GetForeignRowMarkType</function>. "
"(<literal>ROW_MARK_REFERENCE</literal> means to just re-fetch the tuple "
"without acquiring any lock, and <literal>ROW_MARK_COPY</literal> will never "
"be seen by this routine.)"
msgstr ""
"Эта функция должна вернуть копию выбранного кортежа (размещённую в памяти "
"palloc) или <literal>NULL</literal>, если получить блокировку строки не "
"удаётся. Тип запрашиваемой блокировки строки определяется значением "
"<literal>erm-&gt;markType</literal>, которое было до этого возвращено "
"функцией <function>GetForeignRowMarkType</function>. (Вариант "
"<literal>ROW_MARK_REFERENCE</literal> означает, что нужно просто повторно "
"выбрать кортеж, не запрашивая никакую блокировку, а <literal>ROW_MARK_COPY</"
"literal> никогда не поступает в эту подпрограмму.)"

#: fdwhandler.xml:939(para)
msgid ""
"In addition, <literal>*updated</literal> should be set to <literal>true</"
"literal> if what was fetched was an updated version of the tuple rather than "
"the same version previously obtained. (If the FDW cannot be sure about this, "
"always returning <literal>true</literal> is recommended.)"
msgstr ""
"Кроме того, переменной <literal>*updated</literal> следует присвоить "
"<literal>true</literal>, если была считана изменённая версия кортежа, а не "
"версия, полученная ранее. (Если FDW не знает этого наверняка, рекомендуется "
"всегда возвращать <literal>true</literal>.)"

#: fdwhandler.xml:946(para)
msgid ""
"Note that by default, failure to acquire a row lock should result in raising "
"an error; a <literal>NULL</literal> return is only appropriate if the "
"<literal>SKIP LOCKED</literal> option is specified by <literal>erm-&gt;"
"waitPolicy</literal>."
msgstr ""
"Заметьте, что по умолчанию в случае неудачи при попытке получить блокировку "
"строки должна выдаваться ошибка; значение <literal>NULL</literal> может "
"возвращаться, только если в <literal>erm-&gt;waitPolicy</literal> выбран "
"вариант <literal>SKIP LOCKED</literal>."

#: fdwhandler.xml:953(para)
msgid ""
"The <literal>rowid</literal> is the <structfield>ctid</structfield> value "
"previously read for the row to be re-fetched. Although the <literal>rowid</"
"literal> value is passed as a <type>Datum</type>, it can currently only be a "
"<type>tid</type>. The function API is chosen in hopes that it may be "
"possible to allow other data types for row IDs in future."
msgstr ""
"В <literal>rowid</literal> передаётся значение <structfield>ctid</"
"structfield>, полученное ранее для строки, которую нужно считать повторно. "
"Хотя значение <literal>rowid</literal> передаётся в виде <type>Datum</type>, "
"в настоящее время это может быть только <type>tid</type>. Такой интерфейс "
"функции выбран с расчётом на то, чтобы в будущем в качестве идентификаторов "
"строк могли приниматься и другие типы данных."

#: fdwhandler.xml:961(para)
msgid ""
"If the <function>RefetchForeignRow</function> pointer is set to "
"<literal>NULL</literal>, attempts to re-fetch rows will fail with an error "
"message."
msgstr ""
"Если указатель на <function>RefetchForeignRow</function> равен "
"<literal>NULL</literal>, повторно выбрать данные не удастся, в ответ будет "
"выдаваться сообщение об ошибке."

#: fdwhandler.xml:972(programlisting)
#, no-wrap
msgid ""
"bool\n"
"RecheckForeignScan (ForeignScanState *node, TupleTableSlot *slot);"
msgstr ""
"bool\n"
"RecheckForeignScan (ForeignScanState *node, TupleTableSlot *slot);"

#: fdwhandler.xml:971(para)
msgid ""
"<placeholder-1/> Recheck that a previously-returned tuple still matches the "
"relevant scan and join qualifiers, and possibly provide a modified version "
"of the tuple. For foreign data wrappers which do not perform join pushdown, "
"it will typically be more convenient to set this to <literal>NULL</literal> "
"and instead set <structfield>fdw_recheck_quals</structfield> appropriately. "
"When outer joins are pushed down, however, it isn't sufficient to reapply "
"the checks relevant to all the base tables to the result tuple, even if all "
"needed attributes are present, because failure to match some qualifier might "
"result in some attributes going to NULL, rather than in no tuple being "
"returned. <literal>RecheckForeignScan</literal> can recheck qualifiers and "
"return true if they are still satisfied and false otherwise, but it can also "
"store a replacement tuple into the supplied slot."
msgstr ""
"<placeholder-1/> Перепроверяет, соответствует ли по-прежнему ранее "
"возвращённый кортеж применимым условиям сканирования и соединения, и "
"возможно выдаёт изменённую версию кортежа. Для обёрток сторонних данных, "
"которые не выносят соединение наружу, обычно удобнее присвоить этому "
"указателю <literal>NULL</literal> и задать <structfield>fdw_recheck_quals</"
"structfield>. Однако, когда внешние соединения выносятся наружу, "
"недостаточно повторно применить к результирующему кортежу проверки, "
"относящиеся ко всем базовым таблицам, даже если присутствуют все атрибуты, "
"так как невыполнение некоторого условия может приводить и к обнулению "
"некоторых атрибутов, а не только исключению этого кортежа. "
"<literal>RecheckForeignScan</literal> может перепроверить условия и "
"возвратить true, если они по-прежнему выполняются, или false в противном "
"случае, но также она может записать в переданный слот кортеж на замену "
"предыдущему."

#: fdwhandler.xml:991(para)
msgid ""
"To implement join pushdown, a foreign data wrapper will typically construct "
"an alternative local join plan which is used only for rechecks; this will "
"become the outer subplan of the <literal>ForeignScan</literal>. When a "
"recheck is required, this subplan can be executed and the resulting tuple "
"can be stored in the slot. This plan need not be efficient since no base "
"table will return more than one row; for example, it may implement all joins "
"as nested loops. The function <literal>GetExistingLocalJoinPath</literal> "
"may be used to search existing paths for a suitable local join path, which "
"can be used as the alternative local join plan. "
"<literal>GetExistingLocalJoinPath</literal> searches for an unparameterized "
"path in the path list of the specified join relation. (If it does not find "
"such a path, it returns NULL, in which case a foreign data wrapper may build "
"the local path by itself or may choose not to create access paths for that "
"join.)"
msgstr ""
"Чтобы вынести соединение наружу, обёртка сторонних данных обычно "
"конструирует альтернативный план локального соединения, применяемый только "
"для перепроверок; он становится внешним подпланом узла <literal>ForeignScan</"
"literal>. Когда требуется перепроверка, может быть выполнен этот подплан и "
"результирующий кортеж сохранён в слоте. Этот план может не быть эффективным, "
"так как ни одна базовая таблица не выдаст больше одной строки; например, он "
"может реализовывать все соединения в виде вложенных циклов. Для поиска "
"подходящего локального пути соединения в существующих путях можно "
"воспользоваться функцией <literal>GetExistingLocalJoinPath</literal>. "
"Функция <literal>GetExistingLocalJoinPath</literal> ищет непараметризованный "
"путь в списке путей заданного отношения соединения. (Если такой путь не "
"находится, она возвращает NULL, и в этом случае обёртка сторонних данных "
"может построить локальный путь сама или решить не создавать пути доступа для "
"этого соединения.)"

#: fdwhandler.xml:1010(title)
msgid "FDW Routines for <command>EXPLAIN</command>"
msgstr "Подпрограммы FDW для <command>EXPLAIN</command>"

#: fdwhandler.xml:1013(programlisting)
#, no-wrap
msgid ""
"void\n"
"ExplainForeignScan (ForeignScanState *node,\n"
"                    ExplainState *es);"
msgstr ""
"void\n"
"ExplainForeignScan (ForeignScanState *node,\n"
"                    ExplainState *es);"

#: fdwhandler.xml:1012(para)
msgid ""
"<placeholder-1/> Print additional <command>EXPLAIN</command> output for a "
"foreign table scan. This function can call <function>ExplainPropertyText</"
"function> and related functions to add fields to the <command>EXPLAIN</"
"command> output. The flag fields in <literal>es</literal> can be used to "
"determine what to print, and the state of the <structname>ForeignScanState</"
"structname> node can be inspected to provide run-time statistics in the "
"<command>EXPLAIN ANALYZE</command> case."
msgstr ""
"<placeholder-1/> Дополняет вывод <command>EXPLAIN</command> для сканирования "
"сторонней таблицы. Эта функция может вызывать <function>ExplainPropertyText</"
"function> и связанные функции и добавлять поля в вывод <command>EXPLAIN</"
"command>. Поля флагов в <literal>es</literal> позволяют определить, что "
"именно выводить, а для выдачи статистики времени выполнения в случае с "
"<command>EXPLAIN ANALYZE</command> можно проанализировать состояние узла "
"<structname>ForeignScanState</structname>."

#: fdwhandler.xml:1028(para)
msgid ""
"If the <function>ExplainForeignScan</function> pointer is set to "
"<literal>NULL</literal>, no additional information is printed during "
"<command>EXPLAIN</command>."
msgstr ""
"Если указатель <function>ExplainForeignScan</function> равен <literal>NULL</"
"literal>, никакая дополнительная информация при <command>EXPLAIN</command> "
"не выводится."

#: fdwhandler.xml:1035(programlisting)
#, no-wrap
msgid ""
"void\n"
"ExplainForeignModify (ModifyTableState *mtstate,\n"
"                      ResultRelInfo *rinfo,\n"
"                      List *fdw_private,\n"
"                      int subplan_index,\n"
"                      struct ExplainState *es);"
msgstr ""
"void\n"
"ExplainForeignModify (ModifyTableState *mtstate,\n"
"                      ResultRelInfo *rinfo,\n"
"                      List *fdw_private,\n"
"                      int subplan_index,\n"
"                      struct ExplainState *es);"

#: fdwhandler.xml:1034(para)
msgid ""
"<placeholder-1/> Print additional <command>EXPLAIN</command> output for a "
"foreign table update. This function can call <function>ExplainPropertyText</"
"function> and related functions to add fields to the <command>EXPLAIN</"
"command> output. The flag fields in <literal>es</literal> can be used to "
"determine what to print, and the state of the <structname>ModifyTableState</"
"structname> node can be inspected to provide run-time statistics in the "
"<command>EXPLAIN ANALYZE</command> case. The first four arguments are the "
"same as for <function>BeginForeignModify</function>."
msgstr ""
"<placeholder-1/> Дополняет вывод <command>EXPLAIN</command> для изменений в "
"сторонней таблице. Эта функция может вызывать <function>ExplainPropertyText</"
"function> и связанные функции и добавлять поля в вывод <command>EXPLAIN</"
"command>. Поля флагов в <literal>es</literal> позволяют определить, что "
"именно выводить, а для выдачи статистики времени выполнения в случае с "
"<command>EXPLAIN ANALYZE</command> можно проанализировать состояние узла "
"<structname>ModifyTableState</structname>. Первые четыре аргумента у этой "
"функции те же, что и у <function>BeginForeignModify</function>."

#: fdwhandler.xml:1054(para)
msgid ""
"If the <function>ExplainForeignModify</function> pointer is set to "
"<literal>NULL</literal>, no additional information is printed during "
"<command>EXPLAIN</command>."
msgstr ""
"Если указатель <function>ExplainForeignModify</function> равен "
"<literal>NULL</literal>, никакая дополнительная информация при "
"<command>EXPLAIN</command> не выводится."

#: fdwhandler.xml:1061(programlisting)
#, no-wrap
msgid ""
"void\n"
"ExplainDirectModify (ForeignScanState *node,\n"
"                     ExplainState *es);"
msgstr ""
"void\n"
"ExplainDirectModify (ForeignScanState *node,\n"
"                     ExplainState *es);"

#: fdwhandler.xml:1060(para)
msgid ""
"<placeholder-1/> Print additional <command>EXPLAIN</command> output for a "
"direct modification on the remote server. This function can call "
"<function>ExplainPropertyText</function> and related functions to add fields "
"to the <command>EXPLAIN</command> output. The flag fields in <literal>es</"
"literal> can be used to determine what to print, and the state of the "
"<structname>ForeignScanState</structname> node can be inspected to provide "
"run-time statistics in the <command>EXPLAIN ANALYZE</command> case."
msgstr ""
"<placeholder-1/> Дополняет вывод <command>EXPLAIN</command> для прямой "
"модификации данных на удалённом сервере. Эта функция может вызывать "
"<function>ExplainPropertyText</function> и связанные функции и добавлять "
"поля в вывод <command>EXPLAIN</command>. Поля флагов в <literal>es</literal> "
"позволяют определить, что именно выводить, а для выдачи статистики времени "
"выполнения в случае <command>EXPLAIN ANALYZE</command> можно "
"проанализировать состояние узла <structname>ForeignScanState</structname>."

#: fdwhandler.xml:1077(para)
msgid ""
"If the <function>ExplainDirectModify</function> pointer is set to "
"<literal>NULL</literal>, no additional information is printed during "
"<command>EXPLAIN</command>."
msgstr ""
"Если указатель <function>ExplainDirectModify</function> равен <literal>NULL</"
"literal>, никакая дополнительная информация при <command>EXPLAIN</command> "
"не выводится."

#: fdwhandler.xml:1086(title)
msgid "FDW Routines for <command>ANALYZE</command>"
msgstr "Подпрограммы FDW для <command>ANALYZE</command>"

#: fdwhandler.xml:1089(programlisting)
#, no-wrap
msgid ""
"bool\n"
"AnalyzeForeignTable (Relation relation,\n"
"                     AcquireSampleRowsFunc *func,\n"
"                     BlockNumber *totalpages);"
msgstr ""
"bool\n"
"AnalyzeForeignTable (Relation relation,\n"
"                     AcquireSampleRowsFunc *func,\n"
"                     BlockNumber *totalpages);"

#: fdwhandler.xml:1088(para)
msgid ""
"<placeholder-1/> This function is called when <xref linkend=\"sql-analyze\"/"
"> is executed on a foreign table. If the FDW can collect statistics for this "
"foreign table, it should return <literal>true</literal>, and provide a "
"pointer to a function that will collect sample rows from the table in "
"<parameter>func</parameter>, plus the estimated size of the table in pages "
"in <parameter>totalpages</parameter>. Otherwise, return <literal>false</"
"literal>."
msgstr ""
"<placeholder-1/> Эта функция вызывается, когда для сторонней таблицы "
"выполняется <xref linkend=\"sql-analyze\"/>. Если FDW может собрать "
"статистику для этой сторонней таблицы, эта функция должна вернуть "
"<literal>true</literal> и передать в <parameter>func</parameter> указатель "
"на функцию, которая будет выдавать строки выборки из таблицы, а в "
"<parameter>totalpages</parameter> ожидаемый размер таблицы в страницах. В "
"противном случае эта функция должна вернуть <literal>false</literal>."

#: fdwhandler.xml:1104(para)
msgid ""
"If the FDW does not support collecting statistics for any tables, the "
"<function>AnalyzeForeignTable</function> pointer can be set to "
"<literal>NULL</literal>."
msgstr ""
"Если FDW не поддерживает сбор статистики ни для каких таблиц, в "
"<function>AnalyzeForeignTable</function> можно установить значение "
"<literal>NULL</literal>."

#: fdwhandler.xml:1111(programlisting)
#, no-wrap
msgid ""
"int\n"
"AcquireSampleRowsFunc (Relation relation, int elevel,\n"
"                       HeapTuple *rows, int targrows,\n"
"                       double *totalrows,\n"
"                       double *totaldeadrows);"
msgstr ""
"int\n"
"AcquireSampleRowsFunc (Relation relation, int elevel,\n"
"                       HeapTuple *rows, int targrows,\n"
"                       double *totalrows,\n"
"                       double *totaldeadrows);"

#: fdwhandler.xml:1109(para)
msgid ""
"If provided, the sample collection function must have the signature "
"<placeholder-1/> A random sample of up to <parameter>targrows</parameter> "
"rows should be collected from the table and stored into the caller-provided "
"<parameter>rows</parameter> array. The actual number of rows collected must "
"be returned. In addition, store estimates of the total numbers of live and "
"dead rows in the table into the output parameters <parameter>totalrows</"
"parameter> and <parameter>totaldeadrows</parameter>. (Set "
"<parameter>totaldeadrows</parameter> to zero if the FDW does not have any "
"concept of dead rows.)"
msgstr ""
"Функция выдачи выборки, если она предоставляется, должна иметь следующую "
"сигнатуру: <placeholder-1/> Она должна выбирать из таблицы максимум "
"<parameter>targrows</parameter> строк и помещать их в переданный вызывающим "
"кодом массив <parameter>rows</parameter>. Возвращать она должна фактическое "
"число выбранных строк. Кроме того, эта функция должна сохранить общее "
"количество актуальных и &laquo;мёртвых&raquo;строк в таблице в выходных "
"параметрах <parameter>totalrows</parameter> и <parameter>totaldeadrows</"
"parameter>, соответственно. (Если для данной FDW нет понятия &laquo;"
"мёртвых&raquo; строк, в <parameter>totaldeadrows</parameter> нужно записать "
"0.)"

#: fdwhandler.xml:1131(title)
msgid "FDW Routines For <command>IMPORT FOREIGN SCHEMA</command>"
msgstr "Подпрограммы FDW для <command>IMPORT FOREIGN SCHEMA</command>"

#: fdwhandler.xml:1134(programlisting)
#, no-wrap
msgid ""
"List *\n"
"ImportForeignSchema (ImportForeignSchemaStmt *stmt, Oid serverOid);"
msgstr ""
"List *\n"
"ImportForeignSchema (ImportForeignSchemaStmt *stmt, Oid serverOid);"

#: fdwhandler.xml:1133(para)
msgid ""
"<placeholder-1/> Obtain a list of foreign table creation commands. This "
"function is called when executing <xref linkend=\"sql-importforeignschema\"/"
">, and is passed the parse tree for that statement, as well as the OID of "
"the foreign server to use. It should return a list of C strings, each of "
"which must contain a <xref linkend=\"sql-createforeigntable\"/> command. "
"These strings will be parsed and executed by the core server."
msgstr ""
"<placeholder-1/> Получает список команд, создающих сторонние таблицы. Эта "
"функция вызывается при выполнении команды <xref linkend=\"sql-"
"importforeignschema\"/>; ей передаётся дерево разбора этого оператора и OID "
"целевого стороннего сервера. Она должна вернуть набор строк C, в каждой из "
"которых должна содержаться команда <xref linkend=\"sql-createforeigntable\"/"
">. Эти строки будут разобраны и выполнены ядром сервера."

#: fdwhandler.xml:1147(para)
msgid ""
"Within the <structname>ImportForeignSchemaStmt</structname> struct, "
"<structfield>remote_schema</structfield> is the name of the remote schema "
"from which tables are to be imported. <structfield>list_type</structfield> "
"identifies how to filter table names: <literal>FDW_IMPORT_SCHEMA_ALL</"
"literal> means that all tables in the remote schema should be imported (in "
"this case <structfield>table_list</structfield> is empty), "
"<literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal> means to include only tables "
"listed in <structfield>table_list</structfield>, and "
"<literal>FDW_IMPORT_SCHEMA_EXCEPT</literal> means to exclude the tables "
"listed in <structfield>table_list</structfield>. <structfield>options</"
"structfield> is a list of options used for the import process. The meanings "
"of the options are up to the FDW. For example, an FDW could use an option to "
"define whether the <literal>NOT NULL</literal> attributes of columns should "
"be imported. These options need not have anything to do with those supported "
"by the FDW as database object options."
msgstr ""
"В структуре <structname>ImportForeignSchemaStmt</structname> поле "
"<structfield>remote_schema</structfield> задаёт имя удалённой схемы, из "
"которой импортируются таблицы. Поле <structfield>list_type</structfield> "
"устанавливает, как фильтровать имена таблиц: вариант "
"<literal>FDW_IMPORT_SCHEMA_ALL</literal> означает, что нужно импортировать "
"все таблицы в удалённой схеме (в этом случае поле <structfield>table_list</"
"structfield> пустое), <literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal> "
"означает, что нужно импортировать только таблицы, перечисленные в "
"<structfield>table_list</structfield>, и <literal>FDW_IMPORT_SCHEMA_EXCEPT</"
"literal> означает, что нужно исключить таблицы, перечисленные в списке "
"<structfield>table_list</structfield>. В поле <structfield>options</"
"structfield> передаётся список параметров для процесса импорта. Значение "
"этих параметров определяется самой FDW. Например, у FDW может быть параметр, "
"определяющий, нужно ли сохранять у импортируемых столбцов атрибут "
"<literal>NOT NULL</literal>. Эти параметры могут не иметь ничего общего с "
"параметрами, которые принимает FDW в качестве параметров объектов базы."

#: fdwhandler.xml:1166(para)
msgid ""
"The FDW may ignore the <structfield>local_schema</structfield> field of the "
"<structname>ImportForeignSchemaStmt</structname>, because the core server "
"will automatically insert that name into the parsed <command>CREATE FOREIGN "
"TABLE</command> commands."
msgstr ""
"FDW может игнорировать поле <structfield>local_schema</structfield> в "
"<structname>ImportForeignSchemaStmt</structname>, так как ядро сервера само "
"вставит это имя в разобранные команды <command>CREATE FOREIGN TABLE</"
"command>."

#: fdwhandler.xml:1173(para)
msgid ""
"The FDW does not have to concern itself with implementing the filtering "
"specified by <structfield>list_type</structfield> and "
"<structfield>table_list</structfield>, either, as the core server will "
"automatically skip any returned commands for tables excluded according to "
"those options. However, it's often useful to avoid the work of creating "
"commands for excluded tables in the first place. The function "
"<function>IsImportableForeignTable()</function> may be useful to test "
"whether a given foreign-table name will pass the filter."
msgstr ""
"Также, FDW может не выполнять сама фильтрацию по полям "
"<structfield>list_type</structfield> и <structfield>table_list</"
"structfield>, так как ядро сервера автоматически пропустит все возвращённые "
"команды для таблиц, исключённых по заданным критериям. Однако часто лучше "
"сразу избежать лишней работы, не формируя команды для исключаемых таблиц. "
"Для проверки, удовлетворяет ли фильтру заданное имя сторонней таблицы, может "
"быть полезна функция <function>IsImportableForeignTable()</function>."

#: fdwhandler.xml:1183(para)
msgid ""
"If the FDW does not support importing table definitions, the "
"<function>ImportForeignSchema</function> pointer can be set to "
"<literal>NULL</literal>."
msgstr ""
"Если FDW не поддерживает импорт определений таблиц, указателю "
"<function>ImportForeignSchema</function> можно присвоить <literal>NULL</"
"literal>."

#: fdwhandler.xml:1191(title)
msgid "FDW Routines for Parallel Execution"
msgstr "Подпрограммы FDW для параллельного выполнения"

#: fdwhandler.xml:1192(para)
msgid ""
"A <structname>ForeignScan</structname> node can, optionally, support "
"parallel execution. A parallel <structname>ForeignScan</structname> will be "
"executed in multiple processes and should return each row only once across "
"all cooperating processes. To do this, processes can coordinate through "
"fixed size chunks of dynamic shared memory. This shared memory is not "
"guaranteed to be mapped at the same address in every process, so pointers "
"may not be used. The following callbacks are all optional in general, but "
"required if parallel execution is to be supported."
msgstr ""
"Узел <structname>ForeignScan</structname> может, хотя это не требуется, "
"поддерживать параллельное выполнение. Параллельный <structname>ForeignScan</"
"structname> будет выполняться в нескольких процессах и должен возвращать "
"одну строку только единожды. Для этого взаимодействующие процессы могут "
"координировать свои действия через фиксированного размера блоки в "
"динамической разделяемой памяти. Эта разделяемая память не будет "
"гарантированно отображаться по одному адресу в разных процессах, так что "
"указатели на неё использовать нельзя. Следующие обработчики в принципе не "
"являются обязательными, но они требуются, если реализуется поддержка "
"параллельного выполнения."

#: fdwhandler.xml:1204(programlisting)
#, no-wrap
msgid ""
"bool\n"
"IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,\n"
"                          RangeTblEntry *rte);"
msgstr ""
"bool\n"
"IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,\n"
"                          RangeTblEntry *rte);"

#: fdwhandler.xml:1203(para)
msgid ""
"<placeholder-1/> Test whether a scan can be performed within a parallel "
"worker. This function will only be called when the planner believes that a "
"parallel plan might be possible, and should return true if it is safe for "
"that scan to run within a parallel worker. This will generally not be the "
"case if the remote data source has transaction semantics, unless the "
"worker's connection to the data can somehow be made to share the same "
"transaction context as the leader."
msgstr ""
"<placeholder-1/> Проверяет, будет ли сканирование выполняться параллельным "
"исполнителем. Эта функция будет вызываться, только когда планировщик "
"считает, что параллельный план принципиально возможен, и должна возвращать "
"true, если такое сканирование может безопасно выполняться параллельным "
"исполнителем. Обычно это не так, если удалённый источник данных является "
"транзакционным. Но возможно исключение, когда в подключении рабочего "
"процесса к этому источнику каким-то образом используется тот же "
"транзакционный контекст, что и в ведущем процессе."

#: fdwhandler.xml:1218(para)
msgid ""
"If this callback is not defined, it is assumed that the scan must take place "
"within the parallel leader. Note that returning true does not mean that the "
"scan itself can be done in parallel, only that the scan can be performed "
"within a parallel worker. Therefore, it can be useful to define this method "
"even when parallel execution is not supported."
msgstr ""
"Если этот обработчик не определён, считается, что сканирование должно "
"происходить в ведущем процессе. Заметьте, что возвращённое значение true не "
"означает, что само сканирование может выполняться в параллельном режиме, а "
"только то, что сканирование будет производится в параллельном исполнителе. "
"Таким образом, может быть полезно определить этот обработчик, даже если "
"параллельное выполнение не поддерживается."

#: fdwhandler.xml:1227(programlisting)
#, no-wrap
msgid ""
"Size\n"
"EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);"
msgstr ""
"Size\n"
"EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);"

#: fdwhandler.xml:1226(para)
msgid ""
"<placeholder-1/> Estimate the amount of dynamic shared memory that will be "
"required for parallel operation. This may be higher than the amount that "
"will actually be used, but it must not be lower. The return value is in "
"bytes."
msgstr ""
"<placeholder-1/> Оценивает объём динамической разделяемой памяти, которая "
"потребуется для параллельной операции. Это значение может превышать объём, "
"который будет занят фактически, но не должно быть меньше. Возвращаемое "
"значение задаётся в байтах."

#: fdwhandler.xml:1237(programlisting)
#, no-wrap
msgid ""
"void\n"
"InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,\n"
"                         void *coordinate);"
msgstr ""
"void\n"
"InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,\n"
"                         void *coordinate);"

#: fdwhandler.xml:1236(para)
msgid ""
"<placeholder-1/> Initialize the dynamic shared memory that will be required "
"for parallel operation; <literal>coordinate</literal> points to an amount of "
"allocated space equal to the return value of "
"<function>EstimateDSMForeignScan</function>."
msgstr ""
"<placeholder-1/> Инициализирует динамическую разделяемую память, которая "
"потребуется для параллельной операции; <literal>coordinate</literal> "
"указывает на блок объёма, равного возвращаемому значению "
"<function>EstimateDSMForeignScan</function>."

#: fdwhandler.xml:1248(programlisting)
#, no-wrap
msgid ""
"void\n"
"InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,\n"
"                            void *coordinate);"
msgstr ""
"void\n"
"InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,\n"
"                            void *coordinate);"

#: fdwhandler.xml:1247(para)
msgid ""
"<placeholder-1/> Initialize a parallel worker's custom state based on the "
"shared state set up in the leader by <literal>InitializeDSMForeignScan</"
"literal>. This callback is optional, and needs only be supplied if this "
"custom path supports parallel execution."
msgstr ""
"<placeholder-1/> Инициализирует собственное состояние параллельного "
"исполнителя на основе общего состояния, заданного ведущим при вызове "
"<literal>InitializeDSMForeignScan</literal>. Этот обработчик является "
"необязательным и должен устанавливаться, только если провайдер "
"нестандартного сканирования поддерживает параллельное выполнение."

#: fdwhandler.xml:1263(title)
msgid "Foreign Data Wrapper Helper Functions"
msgstr "Вспомогательные функции для обёрток сторонних данных"

#: fdwhandler.xml:1265(para)
msgid ""
"Several helper functions are exported from the core server so that authors "
"of foreign data wrappers can get easy access to attributes of FDW-related "
"objects, such as FDW options. To use any of these functions, you need to "
"include the header file <filename>foreign/foreign.h</filename> in your "
"source file. That header also defines the struct types that are returned by "
"these functions."
msgstr ""
"Ядро сервера экспортирует набор полезных вспомогательных функций, которые "
"позволяют разработчикам обёрток сторонних данных легко обращаться к "
"атрибутам объектов, связанных с FDW, например, к параметрам FDW. Чтобы "
"использовать эти функции, необходимо включить в исходный файл заголовочный "
"файл <filename>foreign/foreign.h</filename>. В этом заголовочном файле также "
"определяются типы структур, возвращаемых этими функциями."

#: fdwhandler.xml:1276(programlisting)
#, no-wrap
msgid ""
"ForeignDataWrapper *\n"
"GetForeignDataWrapper(Oid fdwid);"
msgstr ""
"ForeignDataWrapper *\n"
"GetForeignDataWrapper(Oid fdwid);"

#: fdwhandler.xml:1275(para)
msgid ""
"<placeholder-1/> This function returns a <structname>ForeignDataWrapper</"
"structname> object for the foreign-data wrapper with the given OID. A "
"<structname>ForeignDataWrapper</structname> object contains properties of "
"the FDW (see <filename>foreign/foreign.h</filename> for details)."
msgstr ""
"<placeholder-1/> Эта функция возвращает объект "
"<structname>ForeignDataWrapper</structname> для обёртки сторонних данных с "
"указанным OID. Объект <structname>ForeignDataWrapper</structname> содержит "
"свойства FDW (они описаны в <filename>foreign/foreign.h</filename>)."

#: fdwhandler.xml:1288(programlisting)
#, no-wrap
msgid ""
"ForeignServer *\n"
"GetForeignServer(Oid serverid);"
msgstr ""
"ForeignServer *\n"
"GetForeignServer(Oid serverid);"

#: fdwhandler.xml:1287(para)
msgid ""
"<placeholder-1/> This function returns a <structname>ForeignServer</"
"structname> object for the foreign server with the given OID. A "
"<structname>ForeignServer</structname> object contains properties of the "
"server (see <filename>foreign/foreign.h</filename> for details)."
msgstr ""
"<placeholder-1/> Эта функция возвращает объект <structname>ForeignServer</"
"structname> для стороннего сервера с указанным OID. Объект "
"<structname>ForeignServer</structname> содержит свойства сервера (они "
"описаны в <filename>foreign/foreign.h</filename>)."

#: fdwhandler.xml:1300(programlisting)
#, no-wrap
msgid ""
"UserMapping *\n"
"GetUserMapping(Oid userid, Oid serverid);"
msgstr ""
"UserMapping *\n"
"GetUserMapping(Oid userid, Oid serverid);"

#: fdwhandler.xml:1299(para)
msgid ""
"<placeholder-1/> This function returns a <structname>UserMapping</"
"structname> object for the user mapping of the given role on the given "
"server. (If there is no mapping for the specific user, it will return the "
"mapping for <literal>PUBLIC</literal>, or throw error if there is none.) A "
"<structname>UserMapping</structname> object contains properties of the user "
"mapping (see <filename>foreign/foreign.h</filename> for details)."
msgstr ""
"<placeholder-1/> Эта функция возвращает объект <structname>UserMapping</"
"structname> для сопоставления пользователя, которое определено для указанной "
"роли на указанном сервере. (Если сопоставление для указанной роли "
"отсутствует, она возвращает сопоставление для <literal>PUBLIC</literal> или "
"выдаёт ошибку, если его нет.) Объект <structname>UserMapping</structname> "
"содержит свойства сопоставления пользователя (они описаны в "
"<filename>foreign/foreign.h</filename>)."

#: fdwhandler.xml:1314(programlisting)
#, no-wrap
msgid ""
"ForeignTable *\n"
"GetForeignTable(Oid relid);"
msgstr ""
"ForeignTable *\n"
"GetForeignTable(Oid relid);"

#: fdwhandler.xml:1313(para)
msgid ""
"<placeholder-1/> This function returns a <structname>ForeignTable</"
"structname> object for the foreign table with the given OID. A "
"<structname>ForeignTable</structname> object contains properties of the "
"foreign table (see <filename>foreign/foreign.h</filename> for details)."
msgstr ""
"<placeholder-1/> Эта функция возвращает объект <structname>ForeignTable</"
"structname> для сторонней таблицы с указанным OID. Объект "
"<structname>ForeignTable</structname> содержит свойства сторонней таблицы "
"(они описаны в <filename>foreign/foreign.h</filename>)."

#: fdwhandler.xml:1326(programlisting)
#, no-wrap
msgid ""
"List *\n"
"GetForeignColumnOptions(Oid relid, AttrNumber attnum);"
msgstr ""
"List *\n"
"GetForeignColumnOptions(Oid relid, AttrNumber attnum);"

#: fdwhandler.xml:1325(para)
msgid ""
"<placeholder-1/> This function returns the per-column FDW options for the "
"column with the given foreign table OID and attribute number, in the form of "
"a list of <structname>DefElem</structname>. NIL is returned if the column "
"has no options."
msgstr ""
"<placeholder-1/> Эта функция возвращает параметры FDW уровня столбцов для "
"столбца из таблицы с указанным OID сторонней таблицы и указанным номером, в "
"виде списка <structname>DefElem</structname>. Если для столбца не определены "
"параметры, возвращается NULL."

#: fdwhandler.xml:1337(para)
msgid ""
"Some object types have name-based lookup functions in addition to the OID-"
"based ones:"
msgstr ""
"В дополнение к функциям, выбирающим объекты по OID, для некоторых объектов "
"добавлены функции поиска по именам:"

#: fdwhandler.xml:1343(programlisting)
#, no-wrap
msgid ""
"ForeignDataWrapper *\n"
"GetForeignDataWrapperByName(const char *name, bool missing_ok);"
msgstr ""
"ForeignDataWrapper *\n"
"GetForeignDataWrapperByName(const char *name, bool missing_ok);"

#: fdwhandler.xml:1342(para)
msgid ""
"<placeholder-1/> This function returns a <structname>ForeignDataWrapper</"
"structname> object for the foreign-data wrapper with the given name. If the "
"wrapper is not found, return NULL if missing_ok is true, otherwise raise an "
"error."
msgstr ""
"<placeholder-1/> Эта функция возвращает объект "
"<structname>ForeignDataWrapper</structname> для обёртки сторонних данных с "
"указанным именем. В случае отсутствия такой обёртки возвращается NULL, если "
"missing_ok равно true, а иначе выдаётся ошибка."

#: fdwhandler.xml:1355(programlisting)
#, no-wrap
msgid ""
"ForeignServer *\n"
"GetForeignServerByName(const char *name, bool missing_ok);"
msgstr ""
"ForeignServer *\n"
"GetForeignServerByName(const char *name, bool missing_ok);"

#: fdwhandler.xml:1354(para)
msgid ""
"<placeholder-1/> This function returns a <structname>ForeignServer</"
"structname> object for the foreign server with the given name. If the server "
"is not found, return NULL if missing_ok is true, otherwise raise an error."
msgstr ""
"<placeholder-1/> Эта функция возвращает объект <structname>ForeignServer</"
"structname> для стороннего сервера с указанным именем. В случае отсутствия "
"такого сервера возвращается NULL, если missing_ok равно true, а иначе "
"выдаётся ошибка."

#: fdwhandler.xml:1368(title)
msgid "Foreign Data Wrapper Query Planning"
msgstr "Планирование запросов с обёртками сторонних данных"

#: fdwhandler.xml:1370(para)
msgid ""
"The FDW callback functions <function>GetForeignRelSize</function>, "
"<function>GetForeignPaths</function>, <function>GetForeignPlan</function>, "
"<function>PlanForeignModify</function>, <function>GetForeignJoinPaths</"
"function>, <function>GetForeignUpperPaths</function>, and "
"<function>PlanDirectModify</function> must fit into the workings of the "
"<productname>PostgreSQL</productname> planner. Here are some notes about "
"what they must do."
msgstr ""
"Процедуры в FDW, реализующие функции <function>GetForeignRelSize</function>, "
"<function>GetForeignPaths</function>, <function>GetForeignPlan</function>, "
"<function>PlanForeignModify</function>, <function>GetForeignJoinPaths</"
"function>, <function>GetForeignUpperPaths</function> и "
"<function>PlanDirectModify</function>, должны вписываться в работу "
"планировщика <productname>PostgreSQL</productname>. Здесь даётся несколько "
"замечаний о том, как это должно происходить."

#: fdwhandler.xml:1379(para)
msgid ""
"The information in <literal>root</literal> and <literal>baserel</literal> "
"can be used to reduce the amount of information that has to be fetched from "
"the foreign table (and therefore reduce the cost). <literal>baserel-&gt;"
"baserestrictinfo</literal> is particularly interesting, as it contains "
"restriction quals (<literal>WHERE</literal> clauses) that should be used to "
"filter the rows to be fetched. (The FDW itself is not required to enforce "
"these quals, as the core executor can check them instead.) <literal>baserel-"
"&gt;reltarget-&gt;exprs</literal> can be used to determine which columns "
"need to be fetched; but note that it only lists columns that have to be "
"emitted by the <structname>ForeignScan</structname> plan node, not columns "
"that are used in qual evaluation but not output by the query."
msgstr ""
"Для уменьшения объёма выбираемых из сторонней таблицы данных (и как "
"следствие, сокращения стоимости) может использоваться информация, "
"поступающая в <literal>root</literal> и <literal>baserel</literal>. Особый "
"интерес представляет поле <literal>baserel-&gt;baserestrictinfo</literal>, "
"так как оно содержит ограничивающие условия (предложение <literal>WHERE</"
"literal>), по которым можно отфильтровать выбираемые строки. (Сама FDW не "
"обязательно должна применять эти ограничения, так как их может проверить и "
"ядро исполнителя.) Список <literal>baserel-&gt;reltarget-&gt;exprs</literal> "
"позволяет определить, какие именно столбцы требуется выбрать; но учтите, что "
"в нём перечисляются только те столбцы, которые выдаются узлом плана "
"<structname>ForeignScan</structname>, но не столбцы, которые задействованы в "
"ограничивающих условиях и при этом не выводятся запросом."

#: fdwhandler.xml:1393(para)
msgid ""
"Various private fields are available for the FDW planning functions to keep "
"information in. Generally, whatever you store in FDW private fields should "
"be palloc'd, so that it will be reclaimed at the end of planning."
msgstr ""
"Когда функциям планирования FDW требуется сохранять свою информацию, они "
"могут использовать различные частные поля. Вообще, все структуры, которые "
"FDW помещает в закрытые поля, должны выделяться функцией palloc, чтобы они "
"автоматически освобождались при завершении планирования."

#: fdwhandler.xml:1399(para)
msgid ""
"<literal>baserel-&gt;fdw_private</literal> is a <type>void</type> pointer "
"that is available for FDW planning functions to store information relevant "
"to the particular foreign table. The core planner does not touch it except "
"to initialize it to NULL when the <literal>RelOptInfo</literal> node is "
"created. It is useful for passing information forward from "
"<function>GetForeignRelSize</function> to <function>GetForeignPaths</"
"function> and/or <function>GetForeignPaths</function> to "
"<function>GetForeignPlan</function>, thereby avoiding recalculation."
msgstr ""
"Для хранения информации, относящейся к определённой сторонней таблице, "
"функции планирования FDW могут использовать поле <literal>baserel-&gt;"
"fdw_private</literal>, которое может содержать указатель на <type>void</"
"type>. Ядро планировщика никак не касается его, кроме того, что записывает в "
"него NULL при создании узла <literal>RelOptInfo</literal>. Оно полезно для "
"передачи информации из <function>GetForeignRelSize</function> в "
"<function>GetForeignPaths</function> и/или из <function>GetForeignPaths</"
"function> в <function>GetForeignPlan</function> и позволяет избежать "
"повторных вычислений."

#: fdwhandler.xml:1410(para)
msgid ""
"<function>GetForeignPaths</function> can identify the meaning of different "
"access paths by storing private information in the <structfield>fdw_private</"
"structfield> field of <structname>ForeignPath</structname> nodes. "
"<structfield>fdw_private</structfield> is declared as a <type>List</type> "
"pointer, but could actually contain anything since the core planner does not "
"touch it. However, best practice is to use a representation that's dumpable "
"by <function>nodeToString</function>, for use with debugging support "
"available in the backend."
msgstr ""
"<function>GetForeignPaths</function> может обозначить свойства различных "
"путей доступа, сохранив частную информацию в поле <structfield>fdw_private</"
"structfield> узлов <structname>ForeignPath</structname>. Это поле "
"<structfield>fdw_private</structfield> объявлено как указатель на список "
"(<type>List</type>), но в принципе может содержать всё, что угодно, так как "
"ядро планировщика его не касается. Однако лучше поместить в него данные, "
"которые сможет представить функция <function>nodeToString</function>, для "
"применения средств отладки, имеющихся на сервере."

#: fdwhandler.xml:1421(para)
msgid ""
"<function>GetForeignPlan</function> can examine the "
"<structfield>fdw_private</structfield> field of the selected "
"<structname>ForeignPath</structname> node, and can generate "
"<structfield>fdw_exprs</structfield> and <structfield>fdw_private</"
"structfield> lists to be placed in the <structname>ForeignScan</structname> "
"plan node, where they will be available at execution time. Both of these "
"lists must be represented in a form that <function>copyObject</function> "
"knows how to copy. The <structfield>fdw_private</structfield> list has no "
"other restrictions and is not interpreted by the core backend in any way. "
"The <structfield>fdw_exprs</structfield> list, if not NIL, is expected to "
"contain expression trees that are intended to be executed at run time. These "
"trees will undergo post-processing by the planner to make them fully "
"executable."
msgstr ""
"<function>GetForeignPlan</function> может изучить поле "
"<structfield>fdw_private</structfield> выбранного узла "
"<structname>ForeignPath</structname> и сформировать списки "
"<structfield>fdw_exprs</structfield> и <structfield>fdw_private</"
"structfield>, которые будут помещены в узел <structname>ForeignScan</"
"structname>, где они будут находиться во время выполнения запроса. Оба эти "
"списка должны быть представлены в форме, которую способна копировать функция "
"<function>copyObject</function>. Список <structfield>fdw_private</"
"structfield> не имеет других ограничений и никаким образом не "
"интерпретируется ядром сервера. Список <structfield>fdw_exprs</structfield>, "
"если этот указатель не NULL, предположительно содержит деревья выражений, "
"которые должны быть вычислены при выполнении запроса. Затем планировщик "
"обрабатывает эти деревья, чтобы они были полностью готовы к выполнению."

#: fdwhandler.xml:1436(para)
msgid ""
"In <function>GetForeignPlan</function>, generally the passed-in target list "
"can be copied into the plan node as-is. The passed <literal>scan_clauses</"
"literal> list contains the same clauses as <literal>baserel-&gt;"
"baserestrictinfo</literal>, but may be re-ordered for better execution "
"efficiency. In simple cases the FDW can just strip <structname>RestrictInfo</"
"structname> nodes from the <literal>scan_clauses</literal> list (using "
"<function>extract_actual_clauses</function>) and put all the clauses into "
"the plan node's qual list, which means that all the clauses will be checked "
"by the executor at run time. More complex FDWs may be able to check some of "
"the clauses internally, in which case those clauses can be removed from the "
"plan node's qual list so that the executor doesn't waste time rechecking "
"them."
msgstr ""
"<function>GetForeignPlan</function> обычно может скопировать полученный "
"целевой список в узел плана как есть. Передаваемый список "
"<literal>scan_clauses</literal> содержит те же предложения, что и "
"<literal>baserel-&gt;baserestrictinfo</literal>, но, возможно, в другом "
"порядке для более эффективного выполнения. В простых случаях FDW может "
"просто убрать узлы <structname>RestrictInfo</structname> из списка "
"<literal>scan_clauses</literal> (используя функцию "
"<function>extract_actual_clauses</function>) и поместить все предложения в "
"список ограничений узла плана, что будет означать, что эти предложения будут "
"проверяться исполнителем во время выполнения. Более сложные FDW могут "
"самостоятельно проверять некоторые предложения, и в этом случае такие "
"предложения можно удалить из списка ограничений узла, чтобы исполнитель не "
"тратил время на их перепроверку."

#: fdwhandler.xml:1450(para)
msgid ""
"As an example, the FDW might identify some restriction clauses of the form "
"<replaceable>foreign_variable</replaceable> <literal>=</literal> "
"<replaceable>sub_expression</replaceable>, which it determines can be "
"executed on the remote server given the locally-evaluated value of the "
"<replaceable>sub_expression</replaceable>. The actual identification of such "
"a clause should happen during <function>GetForeignPaths</function>, since it "
"would affect the cost estimate for the path. The path's "
"<structfield>fdw_private</structfield> field would probably include a "
"pointer to the identified clause's <structname>RestrictInfo</structname> "
"node. Then <function>GetForeignPlan</function> would remove that clause from "
"<literal>scan_clauses</literal>, but add the <replaceable>sub_expression</"
"replaceable> to <structfield>fdw_exprs</structfield> to ensure that it gets "
"massaged into executable form. It would probably also put control "
"information into the plan node's <structfield>fdw_private</structfield> "
"field to tell the execution functions what to do at run time. The query "
"transmitted to the remote server would involve something like <literal>WHERE "
"<replaceable>foreign_variable</replaceable> = $1</literal>, with the "
"parameter value obtained at run time from evaluation of the "
"<structfield>fdw_exprs</structfield> expression tree."
msgstr ""
"Например, FDW может распознавать некоторые предложения ограничений вида "
"<replaceable>сторонняя_переменная</replaceable> <literal>=</literal> "
"<replaceable>подвыражение</replaceable>, которые, по её представлению, могут "
"выполняться на удалённом сервере с локально вычисленным значением "
"<replaceable>подвыражения</replaceable>. Собственно выявление такого "
"предложения должно происходить в функции <function>GetForeignPaths</"
"function>, так как это влияет на оценку стоимости пути. Эта функция может "
"включить в поле <structfield>fdw_private</structfield> конкретного пути "
"указатель на узел <structname>RestrictInfo</structname> этого предложения. "
"Затем <function>GetForeignPlan</function> удалит это предложение из "
"<literal>scan_clauses</literal>, но добавит <replaceable>подвыражение</"
"replaceable> в <structfield>fdw_exprs</structfield>, чтобы оно было "
"приведено к исполняемой форме. Она также может поместить управляющую "
"информацию в поле <structfield>fdw_private</structfield> плана узла, которая "
"скажет исполняющим функциям, что делать во время выполнения. Запрос, "
"передаваемый удалённому серверу, будет содержать что-то вроде <literal>WHERE "
"<replaceable>сторонняя_переменная</replaceable> = $1</literal>, а значение "
"параметра будет получено во время выполнения в результате вычисления дерева "
"выражения <structfield>fdw_exprs</structfield>."

#: fdwhandler.xml:1471(para)
msgid ""
"Any clauses removed from the plan node's qual list must instead be added to "
"<literal>fdw_recheck_quals</literal> or rechecked by "
"<literal>RecheckForeignScan</literal> in order to ensure correct behavior at "
"the <literal>READ COMMITTED</literal> isolation level. When a concurrent "
"update occurs for some other table involved in the query, the executor may "
"need to verify that all of the original quals are still satisfied for the "
"tuple, possibly against a different set of parameter values. Using "
"<literal>fdw_recheck_quals</literal> is typically easier than implementing "
"checks inside <literal>RecheckForeignScan</literal>, but this method will be "
"insufficient when outer joins have been pushed down, since the join tuples "
"in that case might have some fields go to NULL without rejecting the tuple "
"entirely."
msgstr ""
"Все предложения, удаляемые из списка условий узла плана, должны быть "
"добавлены в <literal>fdw_recheck_quals</literal> или перепроверены функцией "
"<literal>RecheckForeignScan</literal> для обеспечения корректного поведения "
"на уровне изоляции <literal>READ COMMITTED</literal>. Когда имеет место "
"параллельное изменение в некоторой другой таблице, задействованной в "
"запросе, исполнителю может потребоваться убедиться в том, что все исходные "
"условия по-прежнему выполняются для кортежа, возможно, с другим набором "
"значений параметров. Использовать <literal>fdw_recheck_quals</literal> "
"обычно проще, чем реализовывать проверки внутри <literal>RecheckForeignScan</"
"literal>, но этот метод недостаточен, когда внешние соединения выносятся "
"наружу, так как вследствие перепроверки в соединённых кортежах могут "
"обнуляться некоторые поля, но сами кортежи не будут исключаться."

#: fdwhandler.xml:1486(para)
msgid ""
"Another <structname>ForeignScan</structname> field that can be filled by "
"FDWs is <structfield>fdw_scan_tlist</structfield>, which describes the "
"tuples returned by the FDW for this plan node. For simple foreign table "
"scans this can be set to <literal>NIL</literal>, implying that the returned "
"tuples have the row type declared for the foreign table. A non-<symbol>NIL</"
"symbol> value must be a target list (list of <structname>TargetEntry</"
"structname>s) containing Vars and/or expressions representing the returned "
"columns. This might be used, for example, to show that the FDW has omitted "
"some columns that it noticed won't be needed for the query. Also, if the FDW "
"can compute expressions used by the query more cheaply than can be done "
"locally, it could add those expressions to <structfield>fdw_scan_tlist</"
"structfield>. Note that join plans (created from paths made by "
"<function>GetForeignJoinPaths</function>) must always supply "
"<structfield>fdw_scan_tlist</structfield> to describe the set of columns "
"they will return."
msgstr ""
"Ещё одно поле <structname>ForeignScan</structname>, которое могут заполнять "
"FDW, это <structfield>fdw_scan_tlist</structfield>, описывающее кортежи, "
"возвращаемые обёрткой для этого узла плана. Для простых сторонних таблиц в "
"него можно записать <literal>NIL</literal>, из чего будет следовать, что "
"возвращённые кортежи имеют тип, объявленный для сторонней таблицы. Отличное "
"от <symbol>NIL</symbol> значение должно указывать на список целевых "
"элементов (список структур <structname>TargetEntry</structname>), содержащий "
"переменные и/или выражения, представляющие возвращаемые столбцы. Это можно "
"использовать, например, чтобы показать, что FDW опустила некоторые столбцы, "
"которые по её наблюдению не нужны для запроса. Также, если FDW может "
"вычислить выражения, используемые в запросе, более эффективно, чем это можно "
"сделать локально, она должна добавить эти выражения в список "
"<structfield>fdw_scan_tlist</structfield>. Заметьте, что планы соединения "
"(полученные из путей, созданных функцией <function>GetForeignJoinPaths</"
"function>) должны всегда заполнять <structfield>fdw_scan_tlist</"
"structfield>, описывая набор столбцов, которые они будут возвращать."

#: fdwhandler.xml:1503(para)
msgid ""
"The FDW should always construct at least one path that depends only on the "
"table's restriction clauses. In join queries, it might also choose to "
"construct path(s) that depend on join clauses, for example "
"<replaceable>foreign_variable</replaceable> <literal>=</literal> "
"<replaceable>local_variable</replaceable>. Such clauses will not be found in "
"<literal>baserel-&gt;baserestrictinfo</literal> but must be sought in the "
"relation's join lists. A path using such a clause is called a "
"<quote>parameterized path</quote>. It must identify the other relations used "
"in the selected join clause(s) with a suitable value of <literal>param_info</"
"literal>; use <function>get_baserel_parampathinfo</function> to compute that "
"value. In <function>GetForeignPlan</function>, the "
"<replaceable>local_variable</replaceable> portion of the join clause would "
"be added to <structfield>fdw_exprs</structfield>, and then at run time the "
"case works the same as for an ordinary restriction clause."
msgstr ""
"FDW должна всегда строить минимум один путь, зависящий только от предложений "
"ограничения таблицы. В запросах с соединением она может также построить "
"пути, зависящие от ограничения соединения, например "
"<replaceable>сторонняя_переменная</replaceable> <literal>=</literal> "
"<replaceable>локальная_переменная</replaceable>. Такие предложения будут "
"отсутствовать в <literal>baserel-&gt;baserestrictinfo</literal>; их нужно "
"искать в списках соединений отношений. Путь, построенный с таким "
"предложением, называется <quote>параметризованным</quote>. Другие отношения, "
"задействованные в выбранном предложении соединения, должны связываться c "
"этим путём соответствующим значением <literal>param_info</literal>; для "
"получения этого значения используется <function>get_baserel_parampathinfo</"
"function>. В <function>GetForeignPlan</function> часть "
"<replaceable>локальная_переменная</replaceable> предложения соединения будет "
"добавлена в <structfield>fdw_exprs</structfield>, и затем, во время "
"выполнения, это будет работать так же, как и обычное предложение ограничения."

#: fdwhandler.xml:1520(para)
msgid ""
"If an FDW supports remote joins, <function>GetForeignJoinPaths</function> "
"should produce <structname>ForeignPath</structname>s for potential remote "
"joins in much the same way as <function>GetForeignPaths</function> works for "
"base tables. Information about the intended join can be passed forward to "
"<function>GetForeignPlan</function> in the same ways described above. "
"However, <structfield>baserestrictinfo</structfield> is not relevant for "
"join relations; instead, the relevant join clauses for a particular join are "
"passed to <function>GetForeignJoinPaths</function> as a separate parameter "
"(<literal>extra-&gt;restrictlist</literal>)."
msgstr ""
"Если FDW поддерживает удалённые соединения, <function>GetForeignJoinPaths</"
"function> должна выдавать пути <structname>ForeignPath</structname> для "
"потенциально удалённых соединений почти так же, как это делает "
"<function>GetForeignPaths</function> для базовых таблиц. Информация о "
"выбранном соединении может быть передана функции <function>GetForeignPlan</"
"function> так же, как было описано выше. Однако поле "
"<structfield>baserestrictinfo</structfield> неприменимо к отношениям "
"соединения; вместо этого соответствующие предложения соединения для "
"конкретного соединения передаются в <function>GetForeignJoinPaths</function> "
"в отдельном параметре (<literal>extra-&gt;restrictlist</literal>)."

#: fdwhandler.xml:1532(para)
msgid ""
"An FDW might additionally support direct execution of some plan actions that "
"are above the level of scans and joins, such as grouping or aggregation. To "
"offer such options, the FDW should generate paths and insert them into the "
"appropriate <firstterm>upper relation</firstterm>. For example, a path "
"representing remote aggregation should be inserted into the "
"<literal>UPPERREL_GROUP_AGG</literal> relation, using <function>add_path</"
"function>. This path will be compared on a cost basis with local aggregation "
"performed by reading a simple scan path for the foreign relation (note that "
"such a path must also be supplied, else there will be an error at plan "
"time). If the remote-aggregation path wins, which it usually would, it will "
"be converted into a plan in the usual way, by calling "
"<function>GetForeignPlan</function>. The recommended place to generate such "
"paths is in the <function>GetForeignUpperPaths</function> callback function, "
"which is called for each upper relation (i.e., each post-scan/join "
"processing step), if all the base relations of the query come from the same "
"FDW."
msgstr ""
"FDW может дополнительно поддерживать прямое выполнение некоторых действий "
"плана, находящихся выше уровня сканирований и соединений, например, "
"группировки или агрегирования. Для реализации этой возможности FDW должна "
"сформировать пути и вставить их в соответствующее <firstterm>верхнее "
"отношение</firstterm>. Например, путь, представляющий удалённое "
"агрегирование, должен вставляться в отношение <literal>UPPERREL_GROUP_AGG</"
"literal> с помощью <function>add_path</function>. Этот путь будет "
"сравниваться по стоимости с локальным агрегированием, выполненным по "
"результатам пути простого сканирования стороннего отношения (заметьте, что "
"такой путь также должен быть сформирован, иначе во время планирования "
"произойдёт ошибка). Если путь с удалённым агрегированием выигрывает, что, "
"как правило, и происходит, он будет преобразован в план обычным образом, "
"вызовом <function>GetForeignPlan</function>. Такие пути рекомендуется "
"формировать в обработчике <function>GetForeignUpperPaths</function>, который "
"вызывается для каждого верхнего отношения (то есть на каждом шаге обработки "
"после сканирования/соединения), если все базовые отношения запроса выдаются "
"одной обёрткой."

#: fdwhandler.xml:1551(para)
msgid ""
"<function>PlanForeignModify</function> and the other callbacks described in "
"<xref linkend=\"fdw-callbacks-update\"/> are designed around the assumption "
"that the foreign relation will be scanned in the usual way and then "
"individual row updates will be driven by a local <literal>ModifyTable</"
"literal> plan node. This approach is necessary for the general case where an "
"update requires reading local tables as well as foreign tables. However, if "
"the operation could be executed entirely by the foreign server, the FDW "
"could generate a path representing that and insert it into the "
"<literal>UPPERREL_FINAL</literal> upper relation, where it would compete "
"against the <literal>ModifyTable</literal> approach. This approach could "
"also be used to implement remote <literal>SELECT FOR UPDATE</literal>, "
"rather than using the row locking callbacks described in <xref linkend=\"fdw-"
"callbacks-row-locking\"/>. Keep in mind that a path inserted into "
"<literal>UPPERREL_FINAL</literal> is responsible for implementing "
"<emphasis>all</emphasis> behavior of the query."
msgstr ""
"<function>PlanForeignModify</function> и другие обработчики, описанные в "
"<xref remap=\"6\" linkend=\"fdw-callbacks-update\"/>, рассчитаны на то, что "
"стороннее отношение будет сканироваться обычным способом, а затем отдельные "
"изменения строк будут обрабатываться локальным узлом плана "
"<literal>ModifyTable</literal>. Этот подход необходим в общем случае, когда "
"для такого изменения требуется прочитать не только сторонние, но и локальные "
"таблицы. Однако, если операция может быть целиком выполнена сторонним "
"сервером, FDW может построить путь, представляющий эту возможность, и "
"вставить его в верхнее отношение <literal>UPPERREL_FINAL</literal>, где он "
"будет конкурировать с подходом <literal>ModifyTable</literal>. Этот подход "
"также должен применяться для реализации удалённого <literal>SELECT FOR "
"UPDATE</literal>, вместо обработчиков блокировки строк, описанных <xref "
"remap=\"6\" linkend=\"fdw-callbacks-row-locking\"/>. Учтите, что путь, "
"вставляемый в <literal>UPPERREL_FINAL</literal>, отвечает за реализацию "
"<emphasis>всех</emphasis> аспектов поведения запроса."

#: fdwhandler.xml:1569(para)
msgid ""
"When planning an <command>UPDATE</command> or <command>DELETE</command>, "
"<function>PlanForeignModify</function> and <function>PlanDirectModify</"
"function> can look up the <structname>RelOptInfo</structname> struct for the "
"foreign table and make use of the <literal>baserel-&gt;fdw_private</literal> "
"data previously created by the scan-planning functions. However, in "
"<command>INSERT</command> the target table is not scanned so there is no "
"<structname>RelOptInfo</structname> for it. The <structname>List</"
"structname> returned by <function>PlanForeignModify</function> has the same "
"restrictions as the <structfield>fdw_private</structfield> list of a "
"<structname>ForeignScan</structname> plan node, that is it must contain only "
"structures that <function>copyObject</function> knows how to copy."
msgstr ""
"При планировании запросов <command>UPDATE</command> или <command>DELETE</"
"command> функции <function>PlanForeignModify</function> и "
"<function>PlanDirectModify</function> могут обратиться к структуре "
"<structname>RelOptInfo</structname> сторонней таблицы и воспользоваться "
"информацией <literal>baserel-&gt;fdw_private</literal>, записанной ранее "
"функциями планирования сканирования. Однако при запросе <command>INSERT</"
"command> целевая таблица не сканируется, так что для неё "
"<structname>RelOptInfo</structname> не заполняется. На список "
"(<structname>List</structname>), возвращаемый функцией "
"<function>PlanForeignModify</function>, накладываются те же ограничения, что "
"и на список <structfield>fdw_private</structfield> в узле плана "
"<structname>ForeignScan</structname>, то есть он должен содержать только "
"такие структуры, которые способна копировать функция <function>copyObject</"
"function>."

#: fdwhandler.xml:1583(para)
msgid ""
"<command>INSERT</command> with an <literal>ON CONFLICT</literal> clause does "
"not support specifying the conflict target, as unique constraints or "
"exclusion constraints on remote tables are not locally known. This in turn "
"implies that <literal>ON CONFLICT DO UPDATE</literal> is not supported, "
"since the specification is mandatory there."
msgstr ""
"Команда <command>INSERT</command> с предложением <literal>ON CONFLICT</"
"literal> не поддерживает указание объекта конфликта, так как уникальные "
"ограничения или ограничения-исключения в удалённых таблицах неизвестны "
"локально. Из этого, в свою очередь, вытекает, что предложение <literal>ON "
"CONFLICT DO UPDATE</literal> не поддерживается, так как в нём это указание "
"является обязательным."

#: fdwhandler.xml:1594(title)
msgid "Row Locking in Foreign Data Wrappers"
msgstr "Блокировка строк в обёртках сторонних данных"

#: fdwhandler.xml:1596(para)
msgid ""
"If an FDW's underlying storage mechanism has a concept of locking individual "
"rows to prevent concurrent updates of those rows, it is usually worthwhile "
"for the FDW to perform row-level locking with as close an approximation as "
"practical to the semantics used in ordinary <productname>PostgreSQL</"
"productname> tables. There are multiple considerations involved in this."
msgstr ""
"Если нижележащий механизм хранения FDW поддерживает концепцию блокировки "
"отдельных строк, предотвращающую одновременное изменение этих строк, обычно "
"имеет смысл реализовать в FDW установление блокировок на уровне строк в "
"приближении, настолько близком к обычным таблицам <productname>PostgreSQL</"
"productname>, насколько это возможно и практично. При этом нужно учитывать "
"ряд замечаний."

#: fdwhandler.xml:1605(para)
msgid ""
"One key decision to be made is whether to perform <firstterm>early locking</"
"firstterm> or <firstterm>late locking</firstterm>. In early locking, a row "
"is locked when it is first retrieved from the underlying store, while in "
"late locking, the row is locked only when it is known that it needs to be "
"locked. (The difference arises because some rows may be discarded by locally-"
"checked restriction or join conditions.) Early locking is much simpler and "
"avoids extra round trips to a remote store, but it can cause locking of rows "
"that need not have been locked, resulting in reduced concurrency or even "
"unexpected deadlocks. Also, late locking is only possible if the row to be "
"locked can be uniquely re-identified later. Preferably the row identifier "
"should identify a specific version of the row, as <productname>PostgreSQL</"
"productname> TIDs do."
msgstr ""
"Первое важное решение, которое нужно принять — будет ли реализована "
"<firstterm>ранняя блокировка</firstterm> или <firstterm>поздняя блокировка</"
"firstterm>. С ранней блокировкой строка блокируется, когда впервые "
"считывается из нижележащего хранилища, тогда как с поздней блокировкой "
"строка блокируется, только когда известно, что её нужно заблокировать. "
"(Различие возникает из-за того, что некоторые строки могут быть отброшены "
"локально проверяемыми условиями ограничений или соединений.) Ранняя "
"блокировка гораздо проще и не требует дополнительных обращений к удалённому "
"хранилищу, но может вызывать блокировку строк, которые можно было бы не "
"блокировать, что может повлечь учащение конфликтов и даже неожиданные "
"взаимоблокировки. Кроме того, поздняя блокировка возможна, только если "
"блокируемая строка может быть однозначно идентифицирована позже. Поэтому в "
"идентификаторе строки следует идентифицировать определённую версию строки, "
"как это делает TID в <productname>PostgreSQL</productname>."

#: fdwhandler.xml:1620(para)
msgid ""
"By default, <productname>PostgreSQL</productname> ignores locking "
"considerations when interfacing to FDWs, but an FDW can perform early "
"locking without any explicit support from the core code. The API functions "
"described in <xref linkend=\"fdw-callbacks-row-locking\"/>, which were added "
"in <productname>PostgreSQL</productname> 9.5, allow an FDW to use late "
"locking if it wishes."
msgstr ""
"По умолчанию <productname>PostgreSQL</productname> игнорирует возможности "
"блокировки, обращаясь к FDW, но FDW может установить ранние блокировки и без "
"явной поддержки со стороны ядра. Функции, описанные в <xref remap=\"6\" "
"linkend=\"fdw-callbacks-row-locking\"/>, которые были добавлены в API в "
"<productname>PostgreSQL</productname> 9.5, позволяют FDW применять поздние "
"блокировки, если она этого пожелает."

#: fdwhandler.xml:1629(para)
msgid ""
"An additional consideration is that in <literal>READ COMMITTED</literal> "
"isolation mode, <productname>PostgreSQL</productname> may need to re-check "
"restriction and join conditions against an updated version of some target "
"tuple. Rechecking join conditions requires re-obtaining copies of the non-"
"target rows that were previously joined to the target tuple. When working "
"with standard <productname>PostgreSQL</productname> tables, this is done by "
"including the TIDs of the non-target tables in the column list projected "
"through the join, and then re-fetching non-target rows when required. This "
"approach keeps the join data set compact, but it requires inexpensive re-"
"fetch capability, as well as a TID that can uniquely identify the row "
"version to be re-fetched. By default, therefore, the approach used with "
"foreign tables is to include a copy of the entire row fetched from a foreign "
"table in the column list projected through the join. This puts no special "
"demands on the FDW but can result in reduced performance of merge and hash "
"joins. An FDW that is capable of meeting the re-fetch requirements can "
"choose to do it the first way."
msgstr ""
"Также следует учесть, что в режиме изоляции <literal>READ COMMITTED</"
"literal> серверу <productname>PostgreSQL</productname> может потребоваться "
"перепроверить условия ограничений и соединения с изменённой версией "
"некоторого целевого кортежа. Для перепроверки условий соединения требуется "
"повторно получить копии исходных строк, которые ранее были соединены в "
"целевой кортеж. В случае со стандартными таблицами <productname>PostgreSQL</"
"productname> для этого в список столбцов, проходящих через соединение, "
"включаются TID из исходных таблиц, а затем исходные строки извлекаются "
"заново при необходимости. При таком подходе набор данных соединения остаётся "
"компактным, но требуется недорогая операция повторного чтения строк, а также "
"возможность однозначно идентифицировать повторно считываемую версию строки "
"по TID. Поэтому по умолчанию при работе со сторонними таблицами в список "
"столбцов, проходящих через соединение, включается копия всей строки, "
"извлекаемой из сторонней таблицы. Это не накладывает специальных требований "
"на FDW, но может привести к снижению производительности при соединении "
"слиянием или по хешу. FDW, которая может удовлетворить требованиям "
"повторного чтения, может реализовать первый вариант."

#: fdwhandler.xml:1649(para)
msgid ""
"For an <command>UPDATE</command> or <command>DELETE</command> on a foreign "
"table, it is recommended that the <literal>ForeignScan</literal> operation "
"on the target table perform early locking on the rows that it fetches, "
"perhaps via the equivalent of <command>SELECT FOR UPDATE</command>. An FDW "
"can detect whether a table is an <command>UPDATE</command>/<command>DELETE</"
"command> target at plan time by comparing its relid to <literal>root-&gt;"
"parse-&gt;resultRelation</literal>, or at execution time by using "
"<function>ExecRelationIsTargetRelation()</function>. An alternative "
"possibility is to perform late locking within the "
"<function>ExecForeignUpdate</function> or <function>ExecForeignDelete</"
"function> callback, but no special support is provided for this."
msgstr ""
"Для команд <command>UPDATE</command> или <command>DELETE</command> со "
"сторонней таблицей рекомендуется, чтобы операция <literal>ForeignScan</"
"literal> в целевой таблице выполняла раннюю блокировку строк, которые она "
"выбирает, возможно, используя аналог <command>SELECT FOR UPDATE</command>. "
"FDW может определить, является ли таблица целевой таблицей команд "
"<command>UPDATE</command>/<command>DELETE</command>, во время планирования, "
"сравнив её relid с <literal>root-&gt;parse-&gt;resultRelation</literal>, или "
"во время планирования, вызвав <function>ExecRelationIsTargetRelation()</"
"function>. Также возможно выполнять позднюю блокировку в обработчике "
"<function>ExecForeignUpdate</function> или <function>ExecForeignDelete</"
"function>, но специальной поддержки для этого нет."

#: fdwhandler.xml:1662(para)
msgid ""
"For foreign tables that are specified to be locked by a <command>SELECT FOR "
"UPDATE/SHARE</command> command, the <literal>ForeignScan</literal> operation "
"can again perform early locking by fetching tuples with the equivalent of "
"<command>SELECT FOR UPDATE/SHARE</command>. To perform late locking instead, "
"provide the callback functions defined in <xref linkend=\"fdw-callbacks-row-"
"locking\"/>. In <function>GetForeignRowMarkType</function>, select rowmark "
"option <literal>ROW_MARK_EXCLUSIVE</literal>, "
"<literal>ROW_MARK_NOKEYEXCLUSIVE</literal>, <literal>ROW_MARK_SHARE</"
"literal>, or <literal>ROW_MARK_KEYSHARE</literal> depending on the requested "
"lock strength. (The core code will act the same regardless of which of these "
"four options you choose.) Elsewhere, you can detect whether a foreign table "
"was specified to be locked by this type of command by using "
"<function>get_plan_rowmark</function> at plan time, or "
"<function>ExecFindRowMark</function> at execution time; you must check not "
"only whether a non-null rowmark struct is returned, but that its "
"<structfield>strength</structfield> field is not <literal>LCS_NONE</literal>."
msgstr ""
"Для сторонних таблиц, блокировка которых запрашивается командой "
"<command>SELECT FOR UPDATE/SHARE</command>, операция <literal>ForeignScan</"
"literal> так же может произвести раннюю блокировку, выбрав кортежи, "
"используя аналог <command>SELECT FOR UPDATE/SHARE</command>. Чтобы вместо "
"этого произвести позднюю блокировку, предоставьте подпрограммы-обработчики, "
"описанные в <xref remap=\"6\" linkend=\"fdw-callbacks-row-locking\"/>. В "
"<function>GetForeignRowMarkType</function> выберите вариант отметки строк "
"<literal>ROW_MARK_EXCLUSIVE</literal>, <literal>ROW_MARK_NOKEYEXCLUSIVE</"
"literal>, <literal>ROW_MARK_SHARE</literal> или <literal>ROW_MARK_KEYSHARE</"
"literal>, в зависимости от запрошенной силы блокировки. (Код ядра будет "
"работать одинаково при любом из этих четырёх вариантов.) Затем вы сможете "
"определить, должна ли сторонняя таблица блокироваться командой этого типа, "
"вызвав функцию <function>get_plan_rowmark</function> во время планирования "
"либо <function>ExecFindRowMark</function> во время выполнения; нужно "
"проверить не только, что возвращённая структура rowmark отлична от NULL, но "
"и что её поле <structfield>strength</structfield> не равно "
"<literal>LCS_NONE</literal>."

#: fdwhandler.xml:1681(para)
msgid ""
"Lastly, for foreign tables that are used in an <command>UPDATE</command>, "
"<command>DELETE</command> or <command>SELECT FOR UPDATE/SHARE</command> "
"command but are not specified to be row-locked, you can override the default "
"choice to copy entire rows by having <function>GetForeignRowMarkType</"
"function> select option <literal>ROW_MARK_REFERENCE</literal> when it sees "
"lock strength <literal>LCS_NONE</literal>. This will cause "
"<function>RefetchForeignRow</function> to be called with that value for "
"<structfield>markType</structfield>; it should then re-fetch the row without "
"acquiring any new lock. (If you have a <function>GetForeignRowMarkType</"
"function> function but don't wish to re-fetch unlocked rows, select option "
"<literal>ROW_MARK_COPY</literal> for <literal>LCS_NONE</literal>.)"
msgstr ""
"Наконец, для сторонних таблиц, задействованных в командах <command>UPDATE</"
"command>, <command>DELETE</command> или <command>SELECT FOR UPDATE/SHARE</"
"command>, но не требующих блокировки строк, можно переопределить поведение "
"по умолчанию, заключающееся в копировании строк целиком, выбрав в "
"<function>GetForeignRowMarkType</function> вариант "
"<literal>ROW_MARK_REFERENCE</literal>, получив значение силы блокировки "
"<literal>LCS_NONE</literal>. В результате <function>RefetchForeignRow</"
"function> будет вызываться с таким значением <structfield>markType</"
"structfield>; она должна будет заново считывать строку, не запрашивая новую "
"блокировку. (Если вы реализуете функцию <function>GetForeignRowMarkType</"
"function>, но не хотите повторно считывать незаблокированные строки, "
"выберите для <literal>LCS_NONE</literal> вариант <literal>ROW_MARK_COPY</"
"literal>.)"

#: fdwhandler.xml:1695(para)
msgid ""
"See <filename>src/include/nodes/lockoptions.h</filename>, the comments for "
"<type>RowMarkType</type> and <type>PlanRowMark</type> in <filename>src/"
"include/nodes/plannodes.h</filename>, and the comments for "
"<type>ExecRowMark</type> in <filename>src/include/nodes/execnodes.h</"
"filename> for additional information."
msgstr ""
"Дополнительные сведения можно получить в <filename>src/include/nodes/"
"lockoptions.h</filename>, в комментариях к <type>RowMarkType</type> и "
"<type>PlanRowMark</type> в <filename>src/include/nodes/plannodes.h</"
"filename>, и в комментариях к <type>ExecRowMark</type> в <filename>src/"
"include/nodes/execnodes.h</filename>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: fdwhandler.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "UserMapping *\n"
#~ "GetUserMappingById(Oid umid);"
#~ msgstr ""
#~ "UserMapping *\n"
#~ "GetUserMappingById(Oid umid);"

#~ msgid ""
#~ "<placeholder-1/> This function returns the <structname>UserMapping</"
#~ "structname> object for the given user mapping OID. The OID of a user "
#~ "mapping for a foreign scan is available in the <structname>RelOptInfo</"
#~ "structname>. If there is no mapping for the OID, this function will throw "
#~ "an error. A <structname>UserMapping</structname> object contains "
#~ "properties of the user mapping (see <filename>foreign/foreign.h</"
#~ "filename> for details)."
#~ msgstr ""
#~ "<placeholder-1/> Эта функция возвращает объект <structname>UserMapping</"
#~ "structname> для заданного OID сопоставления пользователя. OID "
#~ "сопоставления пользователя для сторонней таблицы можно получить в "
#~ "<structname>RelOptInfo</structname>. Если сопоставления с таким OID нет, "
#~ "эта функция выдаст ошибку. Объект <structname>UserMapping</structname> "
#~ "содержит свойства сопоставления пользователя (они описаны в "
#~ "<filename>foreign/foreign.h</filename>)."

#~ msgid ""
#~ "void\n"
#~ "GetForeignUpperPaths (PlannerInfo *root,\n"
#~ "                      RelOptInfo *scan_join_rel);"
#~ msgstr ""
#~ "void\n"
#~ "GetForeignUpperPaths (PlannerInfo *root,\n"
#~ "                      RelOptInfo *scan_join_rel);"
