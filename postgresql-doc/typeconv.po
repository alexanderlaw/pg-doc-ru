# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: typeconv.xml:5(title)
msgid "Type Conversion"
msgstr "Преобразование типов"

#: typeconv.xml:7(indexterm)
msgid "<primary>data type</primary> <secondary>conversion</secondary>"
msgstr "<primary>тип данных</primary> <secondary>преобразование</secondary>"

#: typeconv.xml:12(para)
msgid ""
"<acronym>SQL</acronym> statements can, intentionally or not, require the "
"mixing of different data types in the same expression. "
"<productname>PostgreSQL</productname> has extensive facilities for "
"evaluating mixed-type expressions."
msgstr ""
"<acronym>SQL</acronym>-операторы, намеренно или нет, требуют совмещать "
"данные разных типов в одном выражении. Для вычисления подобных выражений со "
"смешанными типами <productname>PostgreSQL</productname> предоставляет "
"широкий набор возможностей."

#: typeconv.xml:19(para)
msgid ""
"In many cases a user does not need to understand the details of the type "
"conversion mechanism. However, implicit conversions done by "
"<productname>PostgreSQL</productname> can affect the results of a query. "
"When necessary, these results can be tailored by using <emphasis>explicit</"
"emphasis> type conversion."
msgstr ""
"Очень часто пользователю не нужно понимать все тонкости механизма "
"преобразования. Однако следует учитывать, что неявные преобразования, "
"производимые <productname>PostgreSQL</productname>, могут влиять на "
"результат запроса. Поэтому при необходимости нужные результаты можно "
"получить, применив <emphasis>явное</emphasis> преобразование типов."

#: typeconv.xml:27(para)
msgid ""
"This chapter introduces the <productname>PostgreSQL</productname> type "
"conversion mechanisms and conventions. Refer to the relevant sections in "
"<xref linkend=\"datatype\"/> and <xref linkend=\"functions\"/> for more "
"information on specific data types and allowed functions and operators."
msgstr ""
"В этой главе описываются общие механизмы преобразования типов и соглашения, "
"принятые в <productname>PostgreSQL</productname>. За дополнительной "
"информацией о конкретных типах данных и разрешённых для них функциях и "
"операторах обратитесь к соответствующим разделам в <xref remap=\"6\" linkend="
"\"datatype\"/> и <xref remap=\"6\" linkend=\"functions\"/>."

#: typeconv.xml:36(title)
msgid "Overview"
msgstr "Обзор"

#: typeconv.xml:38(para)
msgid ""
"<acronym>SQL</acronym> is a strongly typed language. That is, every data "
"item has an associated data type which determines its behavior and allowed "
"usage. <productname>PostgreSQL</productname> has an extensible type system "
"that is more general and flexible than other <acronym>SQL</acronym> "
"implementations. Hence, most type conversion behavior in "
"<productname>PostgreSQL</productname> is governed by general rules rather "
"than by <foreignphrase>ad hoc</foreignphrase> heuristics. This allows the "
"use of mixed-type expressions even with user-defined types."
msgstr ""
"<acronym>SQL</acronym> &mdash; язык со строгой типизацией. То есть каждый "
"элемент данных в нём имеет некоторый тип, определяющий его поведение и "
"допустимое использование. <productname>PostgreSQL</productname> наделён "
"расширяемой системой типов, более универсальной и гибкой по сравнению с "
"другими реализациями <acronym>SQL</acronym>. При этом преобразования типов в "
"<productname>PostgreSQL</productname> в основном подчиняются определённым "
"общим правилам, для их понимания не нужен <foreignphrase>эвристический</"
"foreignphrase> анализ. Благодаря этому в выражениях со смешанными типами "
"можно использовать даже типы, определённые пользователями."

#: typeconv.xml:49(para)
msgid ""
"The <productname>PostgreSQL</productname> scanner/parser divides lexical "
"elements into five fundamental categories: integers, non-integer numbers, "
"strings, identifiers, and key words. Constants of most non-numeric types are "
"first classified as strings. The <acronym>SQL</acronym> language definition "
"allows specifying type names with strings, and this mechanism can be used in "
"<productname>PostgreSQL</productname> to start the parser down the correct "
"path. For example, the query: <screen>\n"
"SELECT text 'Origin' AS \"label\", point '(0,0)' AS \"value\";\n"
"\n"
" label  | value\n"
"--------+-------\n"
" Origin | (0,0)\n"
"(1 row)\n"
"</screen> has two literal constants, of type <type>text</type> and "
"<type>point</type>. If a type is not specified for a string literal, then "
"the placeholder type <type>unknown</type> is assigned initially, to be "
"resolved in later stages as described below."
msgstr ""
"Анализатор выражений <productname>PostgreSQL</productname> разделяет их "
"лексические элементы на пять основных категорий: целые числа, другие "
"числовые значения, текстовые строки, идентификаторы и ключевые слова. "
"Константы большинства не числовых типов сначала классифицируются как строки. "
"В определении языка <acronym>SQL</acronym> допускается указывать имена типов "
"в строках и это можно использовать в <productname>PostgreSQL</productname>, "
"чтобы направить анализатор по верному пути. Например, запрос: <screen>\n"
"SELECT text 'Origin' AS \"label\", point '(0,0)' AS \"value\";\n"
"\n"
" label  | value\n"
"--------+-------\n"
" Origin | (0,0)\n"
"(1 row)\n"
"</screen> содержит две строковых константы, типа <type>text</type> и типа "
"<type>point</type>. Если для такой константы не указан тип, для неё "
"первоначально предполагается тип <type>unknown</type>, который затем может "
"быть уточнён, как описано ниже."

#: typeconv.xml:80(term)
msgid "Function calls"
msgstr "Вызовы функций"

#: typeconv.xml:84(para)
msgid ""
"Much of the <productname>PostgreSQL</productname> type system is built "
"around a rich set of functions. Functions can have one or more arguments. "
"Since <productname>PostgreSQL</productname> permits function overloading, "
"the function name alone does not uniquely identify the function to be "
"called; the parser must select the right function based on the data types of "
"the supplied arguments."
msgstr ""
"Система типов <productname>PostgreSQL</productname> во многом построена как "
"дополнение к богатым возможностям функций. Функции могут иметь один или "
"несколько аргументов, и при этом <productname>PostgreSQL</productname> "
"разрешает перегружать имена функций, так что имя функции само по себе не "
"идентифицирует вызываемую функцию; анализатор выбирает правильную функцию в "
"зависимости от типов переданных аргументов."

#: typeconv.xml:95(term)
msgctxt "term"
msgid "Operators"
msgstr "Операторы"

#: typeconv.xml:99(para)
msgid ""
"<productname>PostgreSQL</productname> allows expressions with prefix and "
"postfix unary (one-argument) operators, as well as binary (two-argument) "
"operators. Like functions, operators can be overloaded, so the same problem "
"of selecting the right operator exists."
msgstr ""
"<productname>PostgreSQL</productname> позволяет использовать в выражениях "
"префиксные и постфиксные операторы с одним аргументом, а также операторы с "
"двумя аргументами. Как и функции, операторы можно перегружать, так что и с "
"ними существует проблема выбора правильного оператора."

#: typeconv.xml:109(term)
msgctxt "term"
msgid "Value Storage"
msgstr "Сохранение значений"

#: typeconv.xml:113(para)
msgid ""
"<acronym>SQL</acronym> <command>INSERT</command> and <command>UPDATE</"
"command> statements place the results of expressions into a table. The "
"expressions in the statement must be matched up with, and perhaps converted "
"to, the types of the target columns."
msgstr ""
"<acronym>SQL</acronym>-операторы <command>INSERT</command> и "
"<command>UPDATE</command> помещают результаты выражений в таблицы. При этом "
"получаемые значения должны соответствовать типам целевых столбцов или, "
"возможно, приводиться к ним."

#: typeconv.xml:121(term)
msgid ""
"<literal>UNION</literal>, <literal>CASE</literal>, and related constructs"
msgstr ""
"<literal>UNION</literal>, <literal>CASE</literal> и связанные конструкции"

#: typeconv.xml:125(para)
msgid ""
"Since all query results from a unionized <command>SELECT</command> statement "
"must appear in a single set of columns, the types of the results of each "
"<command>SELECT</command> clause must be matched up and converted to a "
"uniform set. Similarly, the result expressions of a <literal>CASE</literal> "
"construct must be converted to a common type so that the <literal>CASE</"
"literal> expression as a whole has a known output type. The same holds for "
"<literal>ARRAY</literal> constructs, and for the <function>GREATEST</"
"function> and <function>LEAST</function> functions."
msgstr ""
"Так как все результаты запроса объединяющего оператора <command>SELECT</"
"command> должны оказаться в одном наборе столбцов, результаты каждого "
"подзапроса <command>SELECT</command> должны приводиться к одному набору "
"типов. Подобным образом, результирующие выражения конструкции <literal>CASE</"
"literal> должны приводиться к общему типу, так как выражение <literal>CASE</"
"literal> в целом должно иметь определённый выходной тип. То же справедливо в "
"отношении конструкций <literal>ARRAY</literal> и функций <function>GREATEST</"
"function> и <function>LEAST</function>."

#: typeconv.xml:73(para)
msgid ""
"There are four fundamental <acronym>SQL</acronym> constructs requiring "
"distinct type conversion rules in the <productname>PostgreSQL</productname> "
"parser: <placeholder-1/>"
msgstr ""
"В <acronym>SQL</acronym> есть четыре фундаментальных фактора, определяющих "
"правила преобразования типов для анализатора выражений "
"<productname>PostgreSQL</productname>: <placeholder-1/>"

#: typeconv.xml:139(para)
msgid ""
"The system catalogs store information about which conversions, or "
"<firstterm>casts</firstterm>, exist between which data types, and how to "
"perform those conversions. Additional casts can be added by the user with "
"the <xref linkend=\"sql-createcast\"/> command. (This is usually done in "
"conjunction with defining new data types. The set of casts between built-in "
"types has been carefully crafted and is best not altered.)"
msgstr ""
"Информация о существующих преобразованиях или <firstterm>приведениях</"
"firstterm> типов, для каких типов они определены и как их выполнять, "
"хранится в системных каталогах. Пользователь также может добавить "
"дополнительные преобразования с помощью команды <xref linkend=\"sql-"
"createcast\"/>. (Обычно это делается, когда определяются новые типы данных. "
"Набор приведений для встроенных типов достаточно хорошо проработан, так что "
"его лучше не менять.)"

#: typeconv.xml:150(indexterm)
msgid "<primary>data type</primary> <secondary>category</secondary>"
msgstr "<primary>тип данных</primary> <secondary>категория</secondary>"

#: typeconv.xml:155(para)
msgid ""
"An additional heuristic provided by the parser allows improved determination "
"of the proper casting behavior among groups of types that have implicit "
"casts. Data types are divided into several basic <firstterm>type categories</"
"firstterm>, including <type>boolean</type>, <type>numeric</type>, "
"<type>string</type>, <type>bitstring</type>, <type>datetime</type>, "
"<type>timespan</type>, <type>geometric</type>, <type>network</type>, and "
"user-defined. (For a list see <xref linkend=\"catalog-typcategory-table\"/>; "
"but note it is also possible to create custom type categories.) Within each "
"category there can be one or more <firstterm>preferred types</firstterm>, "
"which are preferred when there is a choice of possible types. With careful "
"selection of preferred types and available implicit casts, it is possible to "
"ensure that ambiguous expressions (those with multiple candidate parsing "
"solutions) can be resolved in a useful way."
msgstr ""
"Дополнительная логика анализа помогает выбрать оптимальное приведение в "
"группах типов, допускающих неявные преобразования. Для этого типы данных "
"разделяются на несколько базовых <firstterm>категорий</firstterm>, которые "
"включают: <type>boolean</type>, <type>numeric</type>, <type>string</type>, "
"<type>bitstring</type>, <type>datetime</type>, <type>timespan</type>, "
"<type>geometric</type>, <type>network</type> и пользовательские типы. "
"(Полный список категорий приведён в <xref remap=\"6\" linkend=\"catalog-"
"typcategory-table\"/>; хотя его тоже можно расширить, определив свои "
"категории.) В каждой категории могут быть выбраны один или несколько "
"<firstterm>предпочитаемых типов</firstterm>, которые будут считаться "
"наиболее подходящими при рассмотрении нескольких вариантов. Аккуратно "
"выбирая предпочитаемые типы и допустимые неявные преобразования, можно "
"добиться того, что выражения с неоднозначностями (в которых возможны разные "
"решения задачи преобразования) будут разрешаться наилучшим образом."

#: typeconv.xml:176(para)
msgid ""
"Implicit conversions should never have surprising or unpredictable outcomes."
msgstr ""
"Результат неявных преобразованиях всегда должен быть предсказуемым и "
"понятным."

#: typeconv.xml:182(para)
msgid ""
"There should be no extra overhead in the parser or executor if a query does "
"not need implicit type conversion. That is, if a query is well-formed and "
"the types already match, then the query should execute without spending "
"extra time in the parser and without introducing unnecessary implicit "
"conversion calls in the query."
msgstr ""
"Если в неявном преобразовании нет нужды, анализатор и исполнитель запроса не "
"должны тратить лишнее время на это. То есть, если запрос хорошо "
"сформулирован и типы значений совпадают, он должен выполняться без "
"дополнительной обработки в анализаторе и без лишних вызовов неявных "
"преобразований."

#: typeconv.xml:192(para)
msgid ""
"Additionally, if a query usually requires an implicit conversion for a "
"function, and if then the user defines a new function with the correct "
"argument types, the parser should use this new function and no longer do "
"implicit conversion to use the old function."
msgstr ""
"Кроме того, если запрос изначально требовал неявного преобразования для "
"функции, а пользователь определил новую функцию с точно совпадающими типами "
"аргументов, анализатор должен переключиться на новую функцию и больше не "
"выполнять преобразование для вызова старой."

#: typeconv.xml:171(para)
msgid ""
"All type conversion rules are designed with several principles in mind: "
"<placeholder-1/>"
msgstr ""
"Все правила преобразования типов разработаны с учётом следующих принципов: "
"<placeholder-1/>"

#: typeconv.xml:204(title)
msgctxt "title"
msgid "Operators"
msgstr "Операторы"

#: typeconv.xml:206(indexterm)
msgid ""
"<primary>operator</primary> <secondary>type resolution in an invocation</"
"secondary>"
msgstr ""
"<primary>оператор</primary> <secondary>разрешение типов при вызове</"
"secondary>"

#: typeconv.xml:211(para)
msgid ""
"The specific operator that is referenced by an operator expression is "
"determined using the following procedure. Note that this procedure is "
"indirectly affected by the precedence of the operators involved, since that "
"will determine which sub-expressions are taken to be the inputs of which "
"operators. See <xref linkend=\"sql-precedence\"/> for more information."
msgstr ""
"При выборе конкретного оператора, задействованного в выражении, "
"<productname>PostgreSQL</productname> следует описанному ниже алгоритму. "
"Заметьте, что на этот выбор могут неявно влиять приоритеты остальных "
"операторов в данном выражении, так как они определяют, какие подвыражения "
"будут аргументами операторов. Подробнее об этом рассказывается в <xref remap="
"\"6\" linkend=\"sql-precedence\"/>."

#: typeconv.xml:221(title)
msgid "Operator Type Resolution"
msgstr "Выбор оператора по типу"

#: typeconv.xml:224(para)
msgid ""
"Select the operators to be considered from the <classname>pg_operator</"
"classname> system catalog. If a non-schema-qualified operator name was used "
"(the usual case), the operators considered are those with the matching name "
"and argument count that are visible in the current search path (see <xref "
"linkend=\"ddl-schemas-path\"/>). If a qualified operator name was given, "
"only operators in the specified schema are considered."
msgstr ""
"Выбрать операторы для рассмотрения из системного каталога "
"<classname>pg_operator</classname>. Если имя оператора не дополнено именем "
"схемы (обычно это так), будут рассматриваться все операторы с подходящим "
"именем и числом аргументов, видимые в текущем пути поиска (см. <xref remap="
"\"4\" linkend=\"ddl-schemas-path\"/>). Если имя оператора определено "
"полностью, в рассмотрение принимаются только операторы из указанной схемы."

#: typeconv.xml:236(para)
msgid ""
"If the search path finds multiple operators with identical argument types, "
"only the one appearing earliest in the path is considered. Operators with "
"different argument types are considered on an equal footing regardless of "
"search path position."
msgstr ""
"Если в пути поиска оказывается несколько операторов с одинаковыми типами "
"аргументов, учитываются только те из них, которые находятся в пути раньше. "
"Операторы с разными типами аргументов рассматриваются на равных правах вне "
"зависимости от их положения в пути поиска."

#: typeconv.xml:247(para)
msgid ""
"Check for an operator accepting exactly the input argument types. If one "
"exists (there can be only one exact match in the set of operators "
"considered), use it."
msgstr ""
"Проверить, нет ли среди них оператора с точно совпадающими типами "
"аргументов. Если такой оператор есть (он может быть только одним в "
"отобранном ранее наборе), использовать его."

#: typeconv.xml:255(para)
msgid ""
"If one argument of a binary operator invocation is of the <type>unknown</"
"type> type, then assume it is the same type as the other argument for this "
"check. Invocations involving two <type>unknown</type> inputs, or a unary "
"operator with an <type>unknown</type> input, will never find a match at this "
"step."
msgstr ""
"Если один аргумент при вызове бинарного оператора имеет тип <type>unknown</"
"type>, для данной проверки предполагается, что он имеет тот же тип, что и "
"второй его аргумент. При вызове бинарного оператора с двумя аргументами "
"<type>unknown</type> или унарного с одним <type>unknown</type>, оператор не "
"будет выбран на этом шаге."

#: typeconv.xml:263(para)
msgid ""
"If one argument of a binary operator invocation is of the <type>unknown</"
"type> type and the other is of a domain type, next check to see if there is "
"an operator accepting exactly the domain's base type on both sides; if so, "
"use it."
msgstr ""
"Если один аргумент при вызове бинарного оператора имеет тип <type>unknown</"
"type>, а другой &mdash; домен, проверить, есть ли оператор, принимающий "
"базовый тип домена с обеих сторон; если таковой находится, использовать его."

#: typeconv.xml:273(para) typeconv.xml:644(para)
msgid "Look for the best match."
msgstr "Найти самый подходящий."

#: typeconv.xml:278(para)
msgid ""
"Discard candidate operators for which the input types do not match and "
"cannot be converted (using an implicit conversion) to match. <type>unknown</"
"type> literals are assumed to be convertible to anything for this purpose. "
"If only one candidate remains, use it; else continue to the next step."
msgstr ""
"Отбросить кандидаты, для которых входные типы не совпадают и не могут быть "
"преобразованы (неявным образом) так, чтобы они совпали. В данном случае "
"считается, что константы типа <type>unknown</type> можно преобразовать во "
"что угодно. Если остаётся только один кандидат, использовать его, в "
"противном случае перейти к следующему шагу."

#: typeconv.xml:287(para)
msgid ""
"If any input argument is of a domain type, treat it as being of the domain's "
"base type for all subsequent steps. This ensures that domains act like their "
"base types for purposes of ambiguous-operator resolution."
msgstr ""
"Если один из аргументов имеет тип домен, далее считать его типом базовый тип "
"домена. Благодаря этому при поиске неоднозначно заданного оператора домены "
"будут подобны свои базовым типам."

#: typeconv.xml:294(para) typeconv.xml:665(para)
msgid ""
"Run through all candidates and keep those with the most exact matches on "
"input types. Keep all candidates if none have exact matches. If only one "
"candidate remains, use it; else continue to the next step."
msgstr ""
"Просмотреть все кандидаты и оставить только те, для которых точно совпадают "
"как можно больше типов аргументов. Оставить все кандидаты, если точных "
"совпадений нет. Если остаётся только один кандидат, использовать его, в "
"противном случае перейти к следующему шагу."

#: typeconv.xml:301(para) typeconv.xml:672(para)
msgid ""
"Run through all candidates and keep those that accept preferred types (of "
"the input data type's type category) at the most positions where type "
"conversion will be required. Keep all candidates if none accept preferred "
"types. If only one candidate remains, use it; else continue to the next step."
msgstr ""
"Просмотреть все кандидаты и оставить только те, которые принимают "
"предпочитаемые типы (из категории типов входных значений) в наибольшем числе "
"позиций, где требуется преобразование типов. Оставить все кандидаты, если ни "
"один не принимает предпочитаемые типы. Если остаётся только один кандидат, "
"использовать его, в противном случае перейти к следующему шагу."

#: typeconv.xml:310(para) typeconv.xml:681(para)
msgid ""
"If any input arguments are <type>unknown</type>, check the type categories "
"accepted at those argument positions by the remaining candidates. At each "
"position, select the <type>string</type> category if any candidate accepts "
"that category. (This bias towards string is appropriate since an unknown-"
"type literal looks like a string.) Otherwise, if all the remaining "
"candidates accept the same type category, select that category; otherwise "
"fail because the correct choice cannot be deduced without more clues. Now "
"discard candidates that do not accept the selected type category. "
"Furthermore, if any candidate accepts a preferred type in that category, "
"discard candidates that accept non-preferred types for that argument. Keep "
"all candidates if none survive these tests. If only one candidate remains, "
"use it; else continue to the next step."
msgstr ""
"Если какие-либо значения имеют тип <type>unknown</type>, проверить категории "
"типов, принимаемых в данных позициях аргументов оставшимися кандидатами. Для "
"каждой позиции выбрать категорию <type>string</type>, если какой-либо "
"кандидат принимает эту категорию. (Эта склонность к строкам объясняется тем, "
"что константа типа unknown выглядит как строка.) Если эта категория не "
"подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать её; "
"в противном случае констатировать неудачу &mdash; сделать правильный выбор "
"без дополнительных подсказок нельзя. Затем отбросить кандидаты, которые не "
"принимают типы выбранной категории. Далее, если какой-либо кандидат "
"принимает предпочитаемый тип из этой категории, отбросить кандидаты, "
"принимающие другие, не предпочитаемые типы для данного аргумента. Оставить "
"все кандидаты, если эти проверки не прошёл ни один. Если остаётся только "
"один кандидат, использовать его, в противном случае перейти к следующему "
"шагу."

#: typeconv.xml:328(para) typeconv.xml:699(para)
msgid ""
"If there are both <type>unknown</type> and known-type arguments, and all the "
"known-type arguments have the same type, assume that the <type>unknown</"
"type> arguments are also of that type, and check which candidates can accept "
"that type at the <type>unknown</type>-argument positions. If exactly one "
"candidate passes this test, use it. Otherwise, fail."
msgstr ""
"Если в списке аргументов есть аргументы и типа <type>unknown</type>, и "
"известного типа, и этот известный тип один для всех аргументов, "
"предположить, что аргументы типа <type>unknown</type> также имеют этот тип, "
"и проверить, какие кандидаты могут принимать этот тип в позиции аргумента "
"<type>unknown</type>. Если остаётся только один кандидат, использовать его, "
"в противном случае констатировать неудачу."

#: typeconv.xml:341(para) typeconv.xml:1022(para)
msgid "Some examples follow."
msgstr "Ниже это проиллюстрировано на примерах."

#: typeconv.xml:346(title)
msgid "Factorial Operator Type Resolution"
msgstr "Разрешение оператора факториала"

#: typeconv.xml:348(para)
msgid ""
"There is only one factorial operator (postfix <literal>!</literal>) defined "
"in the standard catalog, and it takes an argument of type <type>bigint</"
"type>. The scanner assigns an initial type of <type>integer</type> to the "
"argument in this query expression: <screen>\n"
"SELECT 40 ! AS \"40 factorial\";\n"
"\n"
"                   40 factorial\n"
"--------------------------------------------------\n"
" 815915283247897734345611269596115894272000000000\n"
"(1 row)\n"
"</screen> So the parser does a type conversion on the operand and the query "
"is equivalent to: <screen>\n"
"SELECT CAST(40 AS bigint) ! AS \"40 factorial\";\n"
"</screen>"
msgstr ""
"В стандартном каталоге определён только один оператор факториала "
"(постфиксный <literal>!</literal>) и он принимает аргумент типа "
"<type>bigint</type>. При просмотре следующего выражения его аргументу "
"изначально назначается тип <type>integer</type>: <screen>\n"
"SELECT 40 ! AS \"40 factorial\";\n"
"\n"
"                   40 factorial\n"
"--------------------------------------------------\n"
" 815915283247897734345611269596115894272000000000\n"
"(1 row)\n"
"</screen> Анализатор выполняет преобразование типа для этого операнда и "
"запрос становится равносильным: <screen>\n"
"SELECT CAST(40 AS bigint) ! AS \"40 factorial\";\n"
"</screen>"

#: typeconv.xml:373(title)
msgid "String Concatenation Operator Type Resolution"
msgstr "Разрешение оператора конкатенации строк"

#: typeconv.xml:375(para)
msgid ""
"A string-like syntax is used for working with string types and for working "
"with complex extension types. Strings with unspecified type are matched with "
"likely operator candidates."
msgstr ""
"Синтаксис текстовых строк используется как для записи строковых типов, так и "
"для сложных типов расширений. Если тип не указан явно, такие строки "
"сопоставляются по тому же алгоритму с наиболее подходящими операторами."

#: typeconv.xml:381(para)
msgid ""
"An example with one unspecified argument: <screen>\n"
"SELECT text 'abc' || 'def' AS \"text and unknown\";\n"
"\n"
" text and unknown\n"
"------------------\n"
" abcdef\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Пример с одним неопределённым аргументом: <screen>\n"
"SELECT text 'abc' || 'def' AS \"text and unknown\";\n"
"\n"
" text and unknown\n"
"------------------\n"
" abcdef\n"
"(1 row)\n"
"</screen>"

#: typeconv.xml:393(para)
msgid ""
"In this case the parser looks to see if there is an operator taking "
"<type>text</type> for both arguments. Since there is, it assumes that the "
"second argument should be interpreted as type <type>text</type>."
msgstr ""
"В этом случае анализатор смотрит, есть ли оператор, у которого оба аргумента "
"имеют тип <type>text</type>. Такой оператор находится, поэтому "
"предполагается, что второй аргумент следует воспринимать как аргумент типа "
"<type>text</type>."

#: typeconv.xml:399(para)
msgid ""
"Here is a concatenation of two values of unspecified types: <screen>\n"
"SELECT 'abc' || 'def' AS \"unspecified\";\n"
"\n"
" unspecified\n"
"-------------\n"
" abcdef\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Конкатенация двух значений неопределённых типов: <screen>\n"
"SELECT 'abc' || 'def' AS \"unspecified\";\n"
"\n"
" unspecified\n"
"-------------\n"
" abcdef\n"
"(1 row)\n"
"</screen>"

#: typeconv.xml:411(para)
msgid ""
"In this case there is no initial hint for which type to use, since no types "
"are specified in the query. So, the parser looks for all candidate operators "
"and finds that there are candidates accepting both string-category and bit-"
"string-category inputs. Since string category is preferred when available, "
"that category is selected, and then the preferred type for strings, "
"<type>text</type>, is used as the specific type to resolve the unknown-type "
"literals as."
msgstr ""
"В данном случае нет подсказки для выбора типа, так как в данном запросе "
"никакие типы не указаны. Поэтому анализатор просматривает все возможные "
"операторы и находит в них кандидаты, принимающие аргументы категорий string "
"и bit-string. Так как категория string является предпочтительной, выбирается "
"она, а затем для разрешения типа не типизированной константы выбирается "
"предпочтительный тип этой категории, <type>text</type>."

#: typeconv.xml:423(title)
msgid "Absolute-Value and Negation Operator Type Resolution"
msgstr "Разрешение оператора абсолютного значения и отрицания"

#: typeconv.xml:425(para)
msgid ""
"The <productname>PostgreSQL</productname> operator catalog has several "
"entries for the prefix operator <literal>@</literal>, all of which implement "
"absolute-value operations for various numeric data types. One of these "
"entries is for type <type>float8</type>, which is the preferred type in the "
"numeric category. Therefore, <productname>PostgreSQL</productname> will use "
"that entry when faced with an <type>unknown</type> input: <screen>\n"
"SELECT @ '-4.5' AS \"abs\";\n"
" abs\n"
"-----\n"
" 4.5\n"
"(1 row)\n"
"</screen> Here the system has implicitly resolved the unknown-type literal "
"as type <type>float8</type> before applying the chosen operator. We can "
"verify that <type>float8</type> and not some other type was used: <screen>\n"
"SELECT @ '-4.5e500' AS \"abs\";\n"
"\n"
"ERROR:  \"-4.5e500\" is out of range for type double precision\n"
"</screen>"
msgstr ""
"В каталоге операторов <productname>PostgreSQL</productname> для префиксного "
"оператора <literal>@</literal> есть несколько записей, описывающих операции "
"получения абсолютного значения для различных числовых типов данных. Одна из "
"записей соответствует типу <type>float8</type>, предпочтительного в "
"категории числовых типов. Таким образом, столкнувшись со значением типа "
"<type>unknown</type>, <productname>PostgreSQL</productname> выберет эту "
"запись: <screen>\n"
"SELECT @ '-4.5' AS \"abs\";\n"
" abs\n"
"-----\n"
" 4.5\n"
"(1 row)\n"
"</screen> Здесь система неявно привела константу неизвестного типа к типу "
"<type>float8</type>, прежде чем применять выбранный оператор. Можно "
"убедиться в том, что выбран именно тип <type>float8</type>, а не какой-то "
"другой: <screen>\n"
"SELECT @ '-4.5e500' AS \"abs\";\n"
"\n"
"ОШИБКА:  \"-4.5e500\" вне диапазона для типа double precision\n"
"</screen>"

#: typeconv.xml:449(para)
msgid ""
"On the other hand, the prefix operator <literal>~</literal> (bitwise "
"negation) is defined only for integer data types, not for <type>float8</"
"type>. So, if we try a similar case with <literal>~</literal>, we get: "
"<screen>\n"
"SELECT ~ '20' AS \"negation\";\n"
"\n"
"ERROR:  operator is not unique: ~ \"unknown\"\n"
"HINT:  Could not choose a best candidate operator. You might need to add\n"
"explicit type casts.\n"
"</screen> This happens because the system cannot decide which of the several "
"possible <literal>~</literal> operators should be preferred. We can help it "
"out with an explicit cast: <screen>\n"
"SELECT ~ CAST('20' AS int8) AS \"negation\";\n"
"\n"
" negation\n"
"----------\n"
"      -21\n"
"(1 row)\n"
"</screen>"
msgstr ""
"С другой стороны, префиксный оператор <literal>~</literal> (побитовое "
"отрицание) определён только для целочисленных типов данных, но не для "
"<type>float8</type>. Поэтому, если попытаться выполнить похожий запрос с "
"<literal>~</literal>, мы получаем: <screen>\n"
"SELECT ~ '20' AS \"negation\";\n"
"\n"
"ОШИБКА: оператор не уникален: ~ \"unknown\"\n"
"ПОДСКАЗКА: Не удалось выбрать лучшую кандидатуру оператора. Возможно, вам "
"следует\n"
"добавить явные преобразования типов.\n"
"</screen> Это происходит оттого, что система не может решить, какой оператор "
"предпочесть из нескольких возможных вариантов <literal>~</literal>. Мы можем "
"облегчить её задачу, добавив явное преобразование: <screen>\n"
"SELECT ~ CAST('20' AS int8) AS \"negation\";\n"
"\n"
" negation\n"
"----------\n"
"      -21\n"
"(1 row)\n"
"</screen>"

#: typeconv.xml:475(title)
msgid "Array Inclusion Operator Type Resolution"
msgstr "Разрешение оператора включения в массив"

#: typeconv.xml:477(para)
msgid ""
"Here is another example of resolving an operator with one known and one "
"unknown input: <screen>\n"
"SELECT array[1,2] &lt;@ '{1,2,3}' as \"is subset\";\n"
"\n"
" is subset\n"
"-----------\n"
" t\n"
"(1 row)\n"
"</screen> The <productname>PostgreSQL</productname> operator catalog has "
"several entries for the infix operator <literal>&lt;@</literal>, but the "
"only two that could possibly accept an integer array on the left-hand side "
"are array inclusion (<type>anyarray</type> <literal>&lt;@</literal> "
"<type>anyarray</type>) and range inclusion (<type>anyelement</type> "
"<literal>&lt;@</literal> <type>anyrange</type>). Since none of these "
"polymorphic pseudo-types (see <xref linkend=\"datatype-pseudo\"/>) are "
"considered preferred, the parser cannot resolve the ambiguity on that basis. "
"However, <xref linkend=\"op-resol-last-unknown\"/> tells it to assume that "
"the unknown-type literal is of the same type as the other input, that is, "
"integer array. Now only one of the two operators can match, so array "
"inclusion is selected. (Had range inclusion been selected, we would have "
"gotten an error, because the string does not have the right format to be a "
"range literal.)"
msgstr ""
"Ещё один пример разрешения оператора с одним аргументом известного типа и "
"другим неизвестного: <screen>\n"
"SELECT array[1,2] &lt;@ '{1,2,3}' as \"is subset\";\n"
"\n"
" is subset\n"
"-----------\n"
" t\n"
"(1 row)\n"
"</screen> В каталоге операторов <productname>PostgreSQL</productname> есть "
"несколько записей для инфиксного оператора <literal>&lt;@</literal>, но "
"только два из них могут принять целочисленный массива слева: оператор "
"включения массива (<type>anyarray</type><literal>&lt;@</"
"literal><type>anyarray</type>) и оператор включения диапазона "
"(<type>anyelement</type><literal>&lt;@</literal><type>anyrange</type>). Так "
"как ни один из этих полиморфных псевдотипов (см. <xref remap=\"4\" linkend="
"\"datatype-pseudo\"/>) не считается предпочтительным, анализатор не может "
"избавиться от неоднозначности на данном этапе. Однако, в <xref remap=\"6\" "
"linkend=\"op-resol-last-unknown\"/> говорится, что константа неизвестного "
"типа должна рассматриваться как значение типа другого аргумента, в данном "
"случае это целочисленный массив. После этого подходящим считается только "
"один из двух операторов, так что выбирается оператор с целочисленными "
"массивами. (Если бы был выбран оператор включения диапазона, мы получили бы "
"ошибку, так как значение в строке не соответствует формату значений "
"диапазона.)"

#: typeconv.xml:506(title)
msgid "Custom Operator on a Domain Type"
msgstr "Нестандартный оператор с доменом"

#: typeconv.xml:508(para)
msgid ""
"Users sometimes try to declare operators applying just to a domain type. "
"This is possible but is not nearly as useful as it might seem, because the "
"operator resolution rules are designed to select operators applying to the "
"domain's base type. As an example consider <screen>\n"
"CREATE DOMAIN mytext AS text CHECK(...);\n"
"CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;\n"
"CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, "
"rightarg=text);\n"
"CREATE TABLE mytable (val mytext);\n"
"\n"
"SELECT * FROM mytable WHERE val = 'foo';\n"
"</screen> This query will not use the custom operator. The parser will first "
"see if there is a <type>mytext</type> <literal>=</literal> <type>mytext</"
"type> operator (<xref linkend=\"op-resol-exact-unknown\"/>), which there is "
"not; then it will consider the domain's base type <type>text</type>, and see "
"if there is a <type>text</type> <literal>=</literal> <type>text</type> "
"operator (<xref linkend=\"op-resol-exact-domain\"/>), which there is; so it "
"resolves the <type>unknown</type>-type literal as <type>text</type> and uses "
"the <type>text</type> <literal>=</literal> <type>text</type> operator. The "
"only way to get the custom operator to be used is to explicitly cast the "
"literal: <screen>\n"
"SELECT * FROM mytable WHERE val = text 'foo';\n"
"</screen> so that the <type>mytext</type> <literal>=</literal> <type>text</"
"type> operator is found immediately according to the exact-match rule. If "
"the best-match rules are reached, they actively discriminate against "
"operators on domain types. If they did not, such an operator would create "
"too many ambiguous-operator failures, because the casting rules always "
"consider a domain as castable to or from its base type, and so the domain "
"operator would be considered usable in all the same cases as a similarly-"
"named operator on the base type."
msgstr ""
"Иногда пользователи пытаются ввести операторы, применимые только к "
"определённому домену. Это возможно, но вовсе не так полезно, как может "
"показаться, ведь правила разрешения операторов применяются к базовому типу "
"домена. Взгляните на этот пример: <screen>\n"
"CREATE DOMAIN mytext AS text CHECK(...);\n"
"CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;\n"
"CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, "
"rightarg=text);\n"
"CREATE TABLE mytable (val mytext);\n"
"\n"
"SELECT * FROM mytable WHERE val = 'foo';\n"
"</screen> В этом запросе не будет использоваться нововведённый оператор. При "
"разборе запроса сначала будет проверено, есть ли оператор <type>mytext</"
"type> <literal>=</literal> <type>mytext</type> (см. <xref remap=\"4\" "
"linkend=\"op-resol-exact-unknown\"/>), но это не так; затем будет рассмотрен "
"базовый тип домена (<type>text</type>) и проверено наличие оператора "
"<type>text</type> <literal>=</literal> <type>text</type> (см. <xref remap="
"\"4\" linkend=\"op-resol-exact-domain\"/>), и таковой действительно есть; в "
"итоге строковое значение типа <type>unknown</type> будет воспринято как "
"<type>text</type> и будет применён оператор <type>text</type> <literal>=</"
"literal> <type>text</type>. Единственный вариант задействовать нововведённый "
"оператор &mdash; добавить явное приведение: <screen>\n"
"SELECT * FROM mytable WHERE val = text 'foo';\n"
"</screen> так, чтобы оператор <type>mytext</type> <literal>=</literal> "
"<type>text</type> был найден сразу, согласно правилу точного совпадения. "
"Если дело доходит до правил наибольшего соответствия, они активно "
"дискредитируют операторы доменных типов. Если бы они этого не делали, с "
"таким оператором возникало бы слишком много ошибок разрешения операторов, "
"потому что правила приведения всегда считают домен приводимым к базовому "
"типу и наоборот, так что доменный оператор применялся бы во всех случаях, "
"где применяется одноимённый оператор с базовым типом."

#: typeconv.xml:547(title)
msgid "Functions"
msgstr "Функции"

#: typeconv.xml:549(indexterm)
msgid ""
"<primary>function</primary> <secondary>type resolution in an invocation</"
"secondary>"
msgstr ""
"<primary>функции</primary> <secondary>разрешение типов при вызове</secondary>"

#: typeconv.xml:554(para)
msgid ""
"The specific function that is referenced by a function call is determined "
"using the following procedure."
msgstr ""
"При выборе конкретной функции, задействованной в выражении, "
"<productname>PostgreSQL</productname> следует описанному ниже алгоритму."

#: typeconv.xml:560(title)
msgid "Function Type Resolution"
msgstr "Разрешение функции по типу"

#: typeconv.xml:563(para)
msgid ""
"Select the functions to be considered from the <classname>pg_proc</"
"classname> system catalog. If a non-schema-qualified function name was used, "
"the functions considered are those with the matching name and argument count "
"that are visible in the current search path (see <xref linkend=\"ddl-schemas-"
"path\"/>). If a qualified function name was given, only functions in the "
"specified schema are considered."
msgstr ""
"Выбрать функции для рассмотрения из системного каталога <classname>pg_proc</"
"classname>. Если имя функции не дополнено именем схемы, будут "
"рассматриваться все функции с подходящим именем и числом аргументов, видимые "
"в текущем пути поиска (см. <xref remap=\"4\" linkend=\"ddl-schemas-path\"/"
">). Если имя функции определено полностью, в рассмотрение принимаются только "
"функции из указанной схемы."

#: typeconv.xml:575(para)
msgid ""
"If the search path finds multiple functions of identical argument types, "
"only the one appearing earliest in the path is considered. Functions of "
"different argument types are considered on an equal footing regardless of "
"search path position."
msgstr ""
"Если в пути поиска оказывается несколько функций с одинаковыми типами "
"аргументов, учитываются только те из них, которые находятся в пути раньше. "
"Функции с разными типами аргументов рассматриваются на равных правах вне "
"зависимости от их положения в пути поиска."

#: typeconv.xml:583(para)
msgid ""
"If a function is declared with a <literal>VARIADIC</literal> array "
"parameter, and the call does not use the <literal>VARIADIC</literal> "
"keyword, then the function is treated as if the array parameter were "
"replaced by one or more occurrences of its element type, as needed to match "
"the call. After such expansion the function might have effective argument "
"types identical to some non-variadic function. In that case the function "
"appearing earlier in the search path is used, or if the two functions are in "
"the same schema, the non-variadic one is preferred."
msgstr ""
"Если в числе параметров функции есть массив <literal>VARIADIC</literal> и "
"при вызове не указывается ключевое слово <literal>VARIADIC</literal>, "
"функция обрабатывается, как если бы этот параметр был заменён одним или "
"несколькими параметрами типа элементов массива, по числу аргументов при "
"вызове. После такого расширения по фактическим типам аргументов она может "
"совпасть с некоторой функцией с постоянным числом аргументов. В этом случае "
"используется функция, которая находится в пути раньше, а если они "
"оказываются в одной схеме, предпочитается вариант с постоянными аргументами."

#: typeconv.xml:595(para)
msgid ""
"Functions that have default values for parameters are considered to match "
"any call that omits zero or more of the defaultable parameter positions. If "
"more than one such function matches a call, the one appearing earliest in "
"the search path is used. If there are two or more such functions in the same "
"schema with identical parameter types in the non-defaulted positions (which "
"is possible if they have different sets of defaultable parameters), the "
"system will not be able to determine which to prefer, and so an "
"<quote>ambiguous function call</quote> error will result if no better match "
"to the call can be found."
msgstr ""
"Функции, для которых определены значения параметров по умолчанию, считаются "
"совпадающими с вызовом, в котором опущено ноль или более параметров в "
"соответствующих позициях. Если для вызова подходят несколько функций, "
"используется та, что обнаруживается в пути поиска раньше. Если в одной схеме "
"оказываются несколько функций с одинаковыми типами в позициях обязательных "
"параметров (что возможно, если в них определены разные наборы пропускаемых "
"параметров), система не сможет выбрать оптимальную, и выдаст ошибку "
"<quote>неоднозначный вызов функции</quote>, если лучшее соответствие для "
"вызова не будет найдено."

#: typeconv.xml:611(para)
msgid ""
"Check for a function accepting exactly the input argument types. If one "
"exists (there can be only one exact match in the set of functions "
"considered), use it. (Cases involving <type>unknown</type> will never find a "
"match at this step.)"
msgstr ""
"Проверить, нет ли среди них функций с точно совпадающими типами аргументов. "
"Если такая функция есть (она может быть только одной в отобранном ранее "
"наборе), использовать её. (В случаях с типами <type>unknown</type> функция "
"не будет выбрана на этом шаге.)"

#: typeconv.xml:632(para)
msgid ""
"The reason for this step is to support function-style cast specifications in "
"cases where there is not an actual cast function. If there is a cast "
"function, it is conventionally named after its output type, and so there is "
"no need to have a special case. See <xref linkend=\"sql-createcast\"/> for "
"additional commentary."
msgstr ""
"Этот шаг нужен для поддержки приведений типов в стиле вызова функции, когда "
"на самом деле соответствующей функции приведения нет. Если такая функция "
"приведения есть, она обычно называется именем выходного типа и необходимости "
"в особом подходе нет. За дополнительными комментариями обратитесь к <xref "
"remap=\"3\" linkend=\"sql-createcast\"/>."

#: typeconv.xml:621(para)
msgid ""
"If no exact match is found, see if the function call appears to be a special "
"type conversion request. This happens if the function call has just one "
"argument and the function name is the same as the (internal) name of some "
"data type. Furthermore, the function argument must be either an unknown-type "
"literal, or a type that is binary-coercible to the named data type, or a "
"type that could be converted to the named data type by applying that type's "
"I/O functions (that is, the conversion is either to or from one of the "
"standard string types). When these conditions are met, the function call is "
"treated as a form of <literal>CAST</literal> specification. <placeholder-1/>"
msgstr ""
"Если точное совпадение не найдено, проверить, не похож ли вызов функции на "
"особую форму преобразования типов. Это имеет место, когда при вызове функции "
"передаётся всего один аргумент и имя функции совпадает с именем (внутренним) "
"некоторого типа данных. Более того, аргументом функции должна быть либо "
"строка неопределённого типа, либо значение типа, двоично-совместимого с "
"указанным или приводимого к нему с помощью функций ввода/вывода типа (то "
"есть, преобразований в стандартный строковый тип и обратно). Если эти "
"условия выполняются, вызов функции воспринимается как особая форма "
"конструкции <literal>CAST</literal>. <placeholder-1/>"

#: typeconv.xml:649(para)
msgid ""
"Discard candidate functions for which the input types do not match and "
"cannot be converted (using an implicit conversion) to match. <type>unknown</"
"type> literals are assumed to be convertible to anything for this purpose. "
"If only one candidate remains, use it; else continue to the next step."
msgstr ""
"Отбросить кандидаты, для которых входные типы не совпадают и не могут быть "
"преобразованы (неявным образом) так, чтобы они совпали. В данном случае "
"считается, что константы типа <type>unknown</type> можно преобразовать во "
"что угодно. Если остаётся только один кандидат, использовать его, в "
"противном случае перейти к следующему шагу."

#: typeconv.xml:658(para)
msgid ""
"If any input argument is of a domain type, treat it as being of the domain's "
"base type for all subsequent steps. This ensures that domains act like their "
"base types for purposes of ambiguous-function resolution."
msgstr ""
"Если один из аргументов имеет тип домен, далее считать его типом базовый тип "
"домена. Благодаря этому при поиске неоднозначно заданной функции домены "
"будут подобны свои базовым типам."

#: typeconv.xml:712(para)
msgid ""
"Note that the <quote>best match</quote> rules are identical for operator and "
"function type resolution. Some examples follow."
msgstr ""
"Заметьте, что для функций действуют те же правила <quote>оптимального "
"соответствия</quote>, что и для операторов. Они проиллюстрированы следующими "
"примерами."

#: typeconv.xml:719(title)
msgid "Rounding Function Argument Type Resolution"
msgstr "Разрешение функции округления по типам аргументов"

#: typeconv.xml:721(para)
msgid ""
"There is only one <function>round</function> function that takes two "
"arguments; it takes a first argument of type <type>numeric</type> and a "
"second argument of type <type>integer</type>. So the following query "
"automatically converts the first argument of type <type>integer</type> to "
"<type>numeric</type>: <screen>\n"
"SELECT round(4, 4);\n"
"\n"
" round\n"
"--------\n"
" 4.0000\n"
"(1 row)\n"
"</screen> That query is actually transformed by the parser to: <screen>\n"
"SELECT round(CAST (4 AS numeric), 4);\n"
"</screen>"
msgstr ""
"В <productname>PostgreSQL</productname> есть только одна функция "
"<function>round</function>, принимающая два аргумента: первый типа "
"<type>numeric</type>, а второй &mdash; <type>integer</type>. Поэтому в "
"следующем запросе первый аргумент <type>integer</type> автоматически "
"приводится к типу <type>numeric</type>: <screen>\n"
"SELECT round(4, 4);\n"
"\n"
" round\n"
"--------\n"
" 4.0000\n"
"(1 row)\n"
"</screen> Таким образом, анализатор преобразует этот запрос в: <screen>\n"
"SELECT round(CAST (4 AS numeric), 4);\n"
"</screen>"

#: typeconv.xml:744(para)
msgid ""
"Since numeric constants with decimal points are initially assigned the type "
"<type>numeric</type>, the following query will require no type conversion "
"and therefore might be slightly more efficient: <screen>\n"
"SELECT round(4.0, 4);\n"
"</screen>"
msgstr ""
"Та как числовые константы с десятичными точками изначально относятся к типу "
"<type>numeric</type>, для следующего запроса преобразование типов не "
"потребуется, так что он немного эффективнее: <screen>\n"
"SELECT round(4.0, 4);\n"
"</screen>"

#: typeconv.xml:755(title)
msgid "Substring Function Type Resolution"
msgstr "Разрешение функции извлечения подстроки"

#: typeconv.xml:757(para)
msgid ""
"There are several <function>substr</function> functions, one of which takes "
"types <type>text</type> and <type>integer</type>. If called with a string "
"constant of unspecified type, the system chooses the candidate function that "
"accepts an argument of the preferred category <literal>string</literal> "
"(namely of type <type>text</type>). <screen>\n"
"SELECT substr('1234', 3);\n"
"\n"
" substr\n"
"--------\n"
"     34\n"
"(1 row)\n"
"</screen>"
msgstr ""
"В <productname>PostgreSQL</productname> есть несколько вариантов функции "
"<function>substr</function>, и один из них принимает аргументы типов "
"<type>text</type> и <type>integer</type>. Если эта функция вызывается со "
"строковой константой неопределённого типа, система выбирает функцию, "
"принимающую аргумент предпочитаемой категории <literal>string</literal> (а "
"конкретнее, типа <type>text</type>). <screen>\n"
"SELECT substr('1234', 3);\n"
"\n"
" substr\n"
"--------\n"
"     34\n"
"(1 row)\n"
"</screen>"

#: typeconv.xml:774(para)
msgid ""
"If the string is declared to be of type <type>varchar</type>, as might be "
"the case if it comes from a table, then the parser will try to convert it to "
"become <type>text</type>: <screen>\n"
"SELECT substr(varchar '1234', 3);\n"
"\n"
" substr\n"
"--------\n"
"     34\n"
"(1 row)\n"
"</screen> This is transformed by the parser to effectively become: <screen>\n"
"SELECT substr(CAST (varchar '1234' AS text), 3);\n"
"</screen>"
msgstr ""
"Если текстовая строка имеет тип <type>varchar</type>, например когда данные "
"поступают из таблицы, анализатор попытается привести её к типу <type>text</"
"type>: <screen>\n"
"SELECT substr (varchar '1234', 3);\n"
"\n"
" substr\n"
"--------\n"
"     34\n"
"(1 row)\n"
"</screen> Этот запрос анализатор фактически преобразует в: <screen>\n"
"SELECT substr(CAST (varchar '1234' AS text), 3);\n"
"</screen>"

#: typeconv.xml:793(para)
msgid ""
"The parser learns from the <structname>pg_cast</structname> catalog that "
"<type>text</type> and <type>varchar</type> are binary-compatible, meaning "
"that one can be passed to a function that accepts the other without doing "
"any physical conversion. Therefore, no type conversion call is really "
"inserted in this case."
msgstr ""
"Анализатор узнаёт из каталога <structname>pg_cast</structname>, что типы "
"<type>text</type> и <type>varchar</type> двоично-совместимы, что означает, "
"что один тип можно передать функции, принимающей другой, не выполняя "
"физического преобразования. Таким образом, в данном случае операция "
"преобразования на самом не добавляется."

#: typeconv.xml:803(para)
msgid ""
"And, if the function is called with an argument of type <type>integer</"
"type>, the parser will try to convert that to <type>text</type>: <screen>\n"
"SELECT substr(1234, 3);\n"
"ERROR:  function substr(integer, integer) does not exist\n"
"HINT:  No function matches the given name and argument types. You might "
"need\n"
"to add explicit type casts.\n"
"</screen> This does not work because <type>integer</type> does not have an "
"implicit cast to <type>text</type>. An explicit cast will work, however: "
"<screen>\n"
"SELECT substr(CAST (1234 AS text), 3);\n"
"\n"
" substr\n"
"--------\n"
"     34\n"
"(1 row)\n"
"</screen>"
msgstr ""
"И если функция вызывается с аргументом типа <type>integer</type>, анализатор "
"попытается преобразовать его в тип <type>text</type>: <screen>\n"
"SELECT substr(1234, 3);\n"
"ОШИБКА: функция substr(integer, integer) не существует\n"
"ПОДСКАЗКА: Функция с данными именем и типами аргументов не найдена. "
"Возможно, вам\n"
"следует добавить явные преобразования типов.\n"
"</screen> Этот вариант не работает, так как <type>integer</type> нельзя "
"неявно преобразовать в <type>text</type>. Однако с явным преобразованием "
"запрос выполняется: <screen>\n"
"SELECT substr(CAST (1234 AS text), 3);\n"
"\n"
" substr\n"
"--------\n"
"     34\n"
"(1 row)\n"
"</screen>"

#: typeconv.xml:829(title)
msgctxt "title"
msgid "Value Storage"
msgstr "Хранимое значение"

#: typeconv.xml:831(para)
msgid ""
"Values to be inserted into a table are converted to the destination column's "
"data type according to the following steps."
msgstr ""
"Значения, вставляемые в таблицу, преобразуется в тип данных целевого столбца "
"по следующему алгоритму."

#: typeconv.xml:838(title)
msgid "Value Storage Type Conversion"
msgstr "Преобразование по типу хранения"

#: typeconv.xml:841(para)
msgid "Check for an exact match with the target."
msgstr "Проверить точное совпадение с целевым типом."

#: typeconv.xml:847(para)
msgid ""
"Otherwise, try to convert the expression to the target type. This is "
"possible if an <firstterm>assignment cast</firstterm> between the two types "
"is registered in the <structname>pg_cast</structname> catalog (see <xref "
"linkend=\"sql-createcast\"/>). Alternatively, if the expression is an "
"unknown-type literal, the contents of the literal string will be fed to the "
"input conversion routine for the target type."
msgstr ""
"Если типы не совпадают, попытаться привести тип к целевому. Это возможно, "
"если в каталоге <structname>pg_cast</structname> (см. <xref remap=\"4\" "
"linkend=\"sql-createcast\"/>) зарегистрировано <firstterm>приведение "
"присваивания</firstterm> между двумя типами. Если же результат выражения "
"&mdash; строка неизвестного типа, содержимое этой строки будет подано на "
"вход процедуре ввода целевого типа."

#: typeconv.xml:858(para)
msgid ""
"Check to see if there is a sizing cast for the target type. A sizing cast is "
"a cast from that type to itself. If one is found in the <structname>pg_cast</"
"structname> catalog, apply it to the expression before storing into the "
"destination column. The implementation function for such a cast always takes "
"an extra parameter of type <type>integer</type>, which receives the "
"destination column's <structfield>atttypmod</structfield> value (typically "
"its declared length, although the interpretation of <structfield>atttypmod</"
"structfield> varies for different data types), and it may take a third "
"<type>boolean</type> parameter that says whether the cast is explicit or "
"implicit. The cast function is responsible for applying any length-dependent "
"semantics such as size checking or truncation."
msgstr ""
"Проверить, не требуется ли приведение размера для целевого типа. Приведение "
"размера &mdash; это преобразование типа к такому же. Если это приведение "
"описано в каталоге <structname>pg_cast</structname>, применить к его к "
"результату выражения, прежде чем сохранить в целевом столбце. Функция, "
"реализующая такое приведение, всегда принимает дополнительный параметр типа "
"<type>integer</type>, в котором передаётся значение <structfield>atttypmod</"
"structfield> для целевого столбца (обычно это её объявленный размер, хотя "
"интерпретироваться значение <structfield>atttypmod</structfield> для разных "
"типов данных может по-разному), и третий параметр типа <type>boolean</type>, "
"передающий признак явное/неявное преобразование. Функция приведения отвечает "
"за все операции с длиной, включая её проверку и усечение данных."

#: typeconv.xml:877(title)
msgid "<type>character</type> Storage Type Conversion"
msgstr "Преобразование для типа хранения <type>character</type>"

#: typeconv.xml:879(para)
msgid ""
"For a target column declared as <type>character(20)</type> the following "
"statement shows that the stored value is sized correctly: <screen>\n"
"CREATE TABLE vv (v character(20));\n"
"INSERT INTO vv SELECT 'abc' || 'def';\n"
"SELECT v, octet_length(v) FROM vv;\n"
"\n"
"          v           | octet_length\n"
"----------------------+--------------\n"
" abcdef               |           20\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Следующие запросы показывают, что сохраняемое значение подгоняется под "
"размер целевого столбца, объявленного как <type>character(20)</type>: "
"<screen>\n"
"CREATE TABLE vv (v character(20));\n"
"INSERT INTO vv SELECT 'abc' || 'def';\n"
"SELECT v, octet_length(v) FROM vv;\n"
"\n"
"          v           | octet_length\n"
"----------------------+--------------\n"
" abcdef               |           20\n"
"(1 row)\n"
"</screen>"

#: typeconv.xml:895(para)
msgid ""
"What has really happened here is that the two unknown literals are resolved "
"to <type>text</type> by default, allowing the <literal>||</literal> operator "
"to be resolved as <type>text</type> concatenation. Then the <type>text</"
"type> result of the operator is converted to <type>bpchar</type> "
"(<quote>blank-padded char</quote>, the internal name of the <type>character</"
"type> data type) to match the target column type. (Since the conversion from "
"<type>text</type> to <type>bpchar</type> is binary-coercible, this "
"conversion does not insert any real function call.) Finally, the sizing "
"function <literal>bpchar(bpchar, integer, boolean)</literal> is found in the "
"system catalog and applied to the operator's result and the stored column "
"length. This type-specific function performs the required length check and "
"addition of padding spaces."
msgstr ""
"Суть происходящего здесь в том, что две константы неизвестного типа по "
"умолчанию воспринимаются как значения <type>text</type>, что позволяет "
"применить к ним оператор <literal>||</literal> как оператор конкатенации "
"значений <type>text</type>. Затем результат оператора, имеющий тип "
"<type>text</type>, приводится к типу <type>bpchar</type> (<quote>blank-"
"padded char</quote> (символы, дополненные пробелами), внутреннее имя типа "
"<type>character</type>) в соответствии с типом целевого столбца. (Так как "
"типы <type>text</type> и <type>bpchar</type> двоично-совместимы, при этом "
"преобразовании реальный вызов функции не добавляется.) Наконец, в системном "
"каталоге находится функция изменения размера <literal>bpchar(bpchar, "
"integer, boolean)</literal> и применяется для результата оператора и длины "
"столбца. Эта связанная с типом функция проверяет длину данных и добавляет "
"недостающие пробелы."

#: typeconv.xml:913(title)
msgid ""
"<literal>UNION</literal>, <literal>CASE</literal>, and Related Constructs"
msgstr ""
"<literal>UNION</literal>, <literal>CASE</literal> и связанные конструкции"

#: typeconv.xml:915(indexterm)
msgid ""
"<primary>UNION</primary> <secondary>determination of result type</secondary>"
msgstr ""
"<primary>UNION</primary> <secondary>определение типа результата</secondary>"

#: typeconv.xml:920(indexterm)
msgid ""
"<primary>CASE</primary> <secondary>determination of result type</secondary>"
msgstr ""
"<primary>CASE</primary> <secondary>определение типа результата</secondary>"

#: typeconv.xml:925(indexterm)
msgid ""
"<primary>ARRAY</primary> <secondary>determination of result type</secondary>"
msgstr ""
"<primary>ARRAY</primary> <secondary>определение типа результата</secondary>"

#: typeconv.xml:930(indexterm)
msgid ""
"<primary>VALUES</primary> <secondary>determination of result type</secondary>"
msgstr ""
"<primary>VALUES</primary> <secondary>определение типа результата</secondary>"

#: typeconv.xml:935(indexterm)
msgid ""
"<primary>GREATEST</primary> <secondary>determination of result type</"
"secondary>"
msgstr ""
"<primary>GREATEST</primary> <secondary>определение типа результата</"
"secondary>"

#: typeconv.xml:940(indexterm)
msgid ""
"<primary>LEAST</primary> <secondary>determination of result type</secondary>"
msgstr ""
"<primary>LEAST</primary> <secondary>определение типа результата</secondary>"

#: typeconv.xml:945(para)
msgid ""
"SQL <literal>UNION</literal> constructs must match up possibly dissimilar "
"types to become a single result set. The resolution algorithm is applied "
"separately to each output column of a union query. The <literal>INTERSECT</"
"literal> and <literal>EXCEPT</literal> constructs resolve dissimilar types "
"in the same way as <literal>UNION</literal>. The <literal>CASE</literal>, "
"<literal>ARRAY</literal>, <literal>VALUES</literal>, <function>GREATEST</"
"function> and <function>LEAST</function> constructs use the identical "
"algorithm to match up their component expressions and select a result data "
"type."
msgstr ""
"SQL-конструкция <literal>UNION</literal> взаимодействует с системой типов, "
"так как ей приходится объединять значения возможно различных типов в единый "
"результирующий набор. Алгоритм разрешения типов при этом применяется "
"независимо к каждому отдельному столбцу запроса. Подобным образом различные "
"типы сопоставляются при выполнении <literal>INTERSECT</literal> и "
"<literal>EXCEPT</literal> сопоставляют различные типы подобно "
"<literal>UNION</literal>. По такому же алгоритму сопоставляют типы выражений "
"и определяют тип своего результата конструкции <literal>CASE</literal>, "
"<literal>ARRAY</literal>, <literal>VALUES</literal>, <function>GREATEST</"
"function> и <function>LEAST</function>."

#: typeconv.xml:958(title)
msgid ""
"Type Resolution for <literal>UNION</literal>, <literal>CASE</literal>, and "
"Related Constructs"
msgstr ""
"Разрешение типов для <literal>UNION</literal>, <literal>CASE</literal> и "
"связанных конструкций"

#: typeconv.xml:962(para)
msgid ""
"If all inputs are of the same type, and it is not <type>unknown</type>, "
"resolve as that type."
msgstr ""
"Если все данные одного типа и это не тип <type>unknown</type>, выбрать его."

#: typeconv.xml:973(para)
msgid ""
"Somewhat like the treatment of domain inputs for operators and functions, "
"this behavior allows a domain type to be preserved through a <literal>UNION</"
"literal> or similar construct, so long as the user is careful to ensure that "
"all inputs are implicitly or explicitly of that exact type. Otherwise the "
"domain's base type will be preferred."
msgstr ""
"Так же, как домены воспринимаются при выборе операторов и функций, доменные "
"типы могут сохраняться в конструкции <literal>UNION</literal> или подобной, "
"если пользователь позаботится о том, чтобы все входные данные приводились к "
"этому типу явно или неявно. В противном случае предпочтение будет отдано "
"базовому типу домена."

#: typeconv.xml:969(para)
msgid ""
"If any input is of a domain type, treat it as being of the domain's base "
"type for all subsequent steps. <placeholder-1/>"
msgstr ""
"Если тип данных &mdash; домен, далее считать их типом базовый тип домена. "
"<placeholder-1/>"

#: typeconv.xml:985(para)
msgid ""
"If all inputs are of type <type>unknown</type>, resolve as type <type>text</"
"type> (the preferred type of the string category). Otherwise, <type>unknown</"
"type> inputs are ignored."
msgstr ""
"Если все данные типа <type>unknown</type>, выбрать для результата тип "
"<type>text</type> (предпочитаемый для категории string). В противном случае "
"игнорировать значения <type>unknown</type>."

#: typeconv.xml:993(para)
msgid "If the non-unknown inputs are not all of the same type category, fail."
msgstr ""
"Если известные типы входных данных оказываются не из одной категории, "
"констатировать неудачу."

#: typeconv.xml:999(para)
msgid ""
"Choose the first non-unknown input type which is a preferred type in that "
"category, if there is one."
msgstr ""
"Выбрать первый известный предпочитаемый тип из этой категории, если такой "
"есть."

#: typeconv.xml:1006(para)
msgid ""
"Otherwise, choose the last non-unknown input type that allows all the "
"preceding non-unknown inputs to be implicitly converted to it. (There always "
"is such a type, since at least the first type in the list must satisfy this "
"condition.)"
msgstr ""
"В противном случае выбрать последний известный тип, в который можно неявно "
"преобразовать все данные предшествующих известных типов. (Такой тип есть "
"всегда, в крайнем случае этому условию удовлетворяет первый тип.)"

#: typeconv.xml:1015(para)
msgid ""
"Convert all inputs to the selected type. Fail if there is not a conversion "
"from a given input to the selected type."
msgstr ""
"Привести все данные к выбранном типу. Констатировать неудачу, если для каких-"
"либо данных преобразование в этот тип невозможно."

#: typeconv.xml:1027(title)
msgid "Type Resolution with Underspecified Types in a Union"
msgstr "Разрешение типов с частичным определением в Union"

#: typeconv.xml:1029(para)
msgid ""
"<screen>\n"
"SELECT text 'a' AS \"text\" UNION SELECT 'b';\n"
"\n"
" text\n"
"------\n"
" a\n"
" b\n"
"(2 rows)\n"
"</screen> Here, the unknown-type literal <literal>'b'</literal> will be "
"resolved to type <type>text</type>."
msgstr ""
"<screen>\n"
"SELECT text 'a' AS \"text\" UNION SELECT 'b';\n"
"\n"
" text\n"
"------\n"
" a\n"
" b\n"
"(2 rows)\n"
"</screen> В данном случае константа <literal>'b'</literal> неизвестного типа "
"будет преобразована в тип <type>text</type>."

#: typeconv.xml:1044(title)
msgid "Type Resolution in a Simple Union"
msgstr "Разрешение типов в простом объединении"

#: typeconv.xml:1046(para)
msgid ""
"<screen>\n"
"SELECT 1.2 AS \"numeric\" UNION SELECT 1;\n"
"\n"
" numeric\n"
"---------\n"
"       1\n"
"     1.2\n"
"(2 rows)\n"
"</screen> The literal <literal>1.2</literal> is of type <type>numeric</"
"type>, and the <type>integer</type> value <literal>1</literal> can be cast "
"implicitly to <type>numeric</type>, so that type is used."
msgstr ""
"<screen>\n"
"SELECT 1.2 AS \"numeric\" UNION SELECT 1;\n"
"\n"
" numeric\n"
"---------\n"
"       1\n"
"     1.2\n"
"(2 rows)\n"
"</screen> Константа <literal>1.2</literal> имеет тип <type>numeric</type> и "
"целочисленное значение <literal>1</literal> может быть неявно приведено к "
"типу <type>numeric</type>, так что используется этот тип."

#: typeconv.xml:1063(title)
msgid "Type Resolution in a Transposed Union"
msgstr "Разрешение типов в противоположном объединении"

#: typeconv.xml:1065(para)
msgid ""
"<screen>\n"
"SELECT 1 AS \"real\" UNION SELECT CAST('2.2' AS REAL);\n"
"\n"
" real\n"
"------\n"
"    1\n"
"  2.2\n"
"(2 rows)\n"
"</screen> Here, since type <type>real</type> cannot be implicitly cast to "
"<type>integer</type>, but <type>integer</type> can be implicitly cast to "
"<type>real</type>, the union result type is resolved as <type>real</type>."
msgstr ""
"<screen>\n"
"SELECT 1 AS \"real\" UNION SELECT CAST('2.2' AS REAL);\n"
"\n"
" real\n"
"------\n"
"    1\n"
"  2.2\n"
"(2 rows)\n"
"</screen> Здесь значение типа <type>real</type> нельзя неявно привести к "
"<type>integer</type>, но <type>integer</type> можно неявно привести к "
"<type>real</type>, поэтому типом результата объединения будет <type>real</"
"type>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: typeconv.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
