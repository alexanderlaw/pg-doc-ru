# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-08-09 16:00+0300\n"
"PO-Revision-Date: 2017-05-12 10:40+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: rules.xml:5(title)
msgid "The Rule System"
msgstr "Система правил"

#: rules.xml:7(indexterm)
msgid "<primary>rule</primary>"
msgstr "<primary>правило</primary>"

#: rules.xml:11(para)
msgid ""
"This chapter discusses the rule system in <productname>PostgreSQL</"
"productname>. Production rule systems are conceptually simple, but there are "
"many subtle points involved in actually using them."
msgstr ""
"В этой главе обсуждается система правил, реализованная в "
"<productname>PostgreSQL</productname>. Промышленные системы правил по сути "
"довольно простые, но при их использовании приходится сталкиваться с "
"множеством неочевидных вещей."

#: rules.xml:18(para)
msgid ""
"Some other database systems define active database rules, which are usually "
"stored procedures and triggers. In <productname>PostgreSQL</productname>, "
"these can be implemented using functions and triggers as well."
msgstr ""
"В некоторых других базах данных определяются активные правила баз данных, "
"которые обычно реализуются в виде процедур и триггеров. Так же их можно "
"реализовать и в <productname>PostgreSQL</productname>."

#: rules.xml:25(para)
msgid ""
"The rule system (more precisely speaking, the query rewrite rule system) is "
"totally different from stored procedures and triggers. It modifies queries "
"to take rules into consideration, and then passes the modified query to the "
"query planner for planning and execution. It is very powerful, and can be "
"used for many things such as query language procedures, views, and versions. "
"The theoretical foundations and the power of this rule system are also "
"discussed in <xref linkend=\"ston90b\"/> and <xref linkend=\"ong90\"/>."
msgstr ""
"Система правил (точнее говоря, система правил перезаписи запросов) полностью "
"отличается от механизма хранимых процедур и триггеров. Она изменяет запросы "
"по заданным правилам, а затем передаёт модифицированный запрос планировщику "
"для планирования и выполнения. Это очень мощное средство, подходящее для "
"решения множества задач, например, для определения представлений и процедур "
"на языке запросов или реализации версионности. Теоретические основы и "
"преимущества этой системы правил также описаны в <xref remap=\"6\" linkend="
"\"ston90b\"/> и <xref remap=\"6\" linkend=\"ong90\"/> (на английском языке)."

#: rules.xml:38(title)
msgid "The Query Tree"
msgstr "Дерево запроса"

#: rules.xml:40(indexterm)
msgid "<primary>query tree</primary>"
msgstr "<primary>дерево запроса</primary>"

#: rules.xml:44(para)
msgid ""
"To understand how the rule system works it is necessary to know when it is "
"invoked and what its input and results are."
msgstr ""
"Чтобы понять, как работает система правил, нужно знать, когда она "
"вызывается, что принимает на вход и какой результат выдаёт."

#: rules.xml:49(para)
msgid ""
"The rule system is located between the parser and the planner. It takes the "
"output of the parser, one query tree, and the user-defined rewrite rules, "
"which are also query trees with some extra information, and creates zero or "
"more query trees as result. So its input and output are always things the "
"parser itself could have produced and thus, anything it sees is basically "
"representable as an <acronym>SQL</acronym> statement."
msgstr ""
"Система правил внедрена между анализатором запросов и планировщиком. Она "
"принимает разобранный запрос, одно дерево запроса, и определённые "
"пользователем правила перезаписи, тоже представленные деревьями с некоторой "
"дополнительной информацией, и создаёт некоторое количество деревьев запросов "
"в результате. Таким образом, на входе и выходе этой системы оказывается то, "
"что может сформировать анализатор запросов, и как следствие, всё, с чем "
"работает эта система, представимо в виде операторов <acronym>SQL</acronym>."

#: rules.xml:59(para)
msgid ""
"Now what is a query tree? It is an internal representation of an "
"<acronym>SQL</acronym> statement where the single parts that it is built "
"from are stored separately. These query trees can be shown in the server log "
"if you set the configuration parameters <varname>debug_print_parse</"
"varname>, <varname>debug_print_rewritten</varname>, or "
"<varname>debug_print_plan</varname>. The rule actions are also stored as "
"query trees, in the system catalog <structname>pg_rewrite</structname>. They "
"are not formatted like the log output, but they contain exactly the same "
"information."
msgstr ""
"Так что же такое дерево запроса? Это внутреннее представление оператора "
"<acronym>SQL</acronym>, в котором все образующие его части хранятся "
"отдельно. Эти деревья можно увидеть в журнале сервера, если установить "
"параметры конфигурации <varname>debug_print_parse</varname>, "
"<varname>debug_print_rewritten</varname> или <varname>debug_print_plan</"
"varname>. Действия правил также хранятся в виде деревьев запросов, в "
"системном каталоге <structname>pg_rewrite</structname>. Они не форматируются "
"как при выводе в журнал, но содержат точно такую же информацию."

#: rules.xml:72(para)
msgid ""
"Reading a raw query tree requires some experience. But since <acronym>SQL</"
"acronym> representations of query trees are sufficient to understand the "
"rule system, this chapter will not teach how to read them."
msgstr ""
"Для прочтения неформатированного дерева требуется некоторый навык. Но так "
"как представления дерева запросов в виде <acronym>SQL</acronym> достаточно, "
"чтобы понять систему правил, в этой главе не будет рассказываться, как их "
"читать."

#: rules.xml:87(term)
msgid "the command type"
msgstr "тип команды"

#: rules.xml:91(para)
msgid ""
"This is a simple value telling which command (<command>SELECT</command>, "
"<command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</"
"command>) produced the query tree."
msgstr ""
"Это простое значение, говорящее, какая команда (<command>SELECT</command>, "
"<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>) сгенерировала дерево запросов."

# range пришло из QUEL:
# http://citforum.ru/database/osbd/glava_35.shtml
#: rules.xml:103(indexterm)
msgid "<primary>range table</primary>"
msgstr "<primary>список отношений</primary>"

#: rules.xml:101(term)
msgid "the range table <placeholder-1/>"
msgstr "список отношений <placeholder-1/>"

#: rules.xml:106(para)
msgid ""
"The range table is a list of relations that are used in the query. In a "
"<command>SELECT</command> statement these are the relations given after the "
"<literal>FROM</literal> key word."
msgstr ""
"Список отношений представляет собой массив отношений, используемых в "
"запросе. В запросе <command>SELECT</command> он включает отношения, "
"указанные после ключевого слова <literal>FROM</literal>."

#: rules.xml:112(para)
msgid ""
"Every range table entry identifies a table or view and tells by which name "
"it is called in the other parts of the query. In the query tree, the range "
"table entries are referenced by number rather than by name, so here it "
"doesn't matter if there are duplicate names as it would in an <acronym>SQL</"
"acronym> statement. This can happen after the range tables of rules have "
"been merged in. The examples in this chapter will not have this situation."
msgstr ""
"Каждый элемент списка отношений представляет таблицу или представление и "
"говорит, с каким именем они упоминаются в других частях запроса. В дереве "
"запросов записываются номера элементов списка отношений, а не их имена, "
"поэтому для него неактуальна проблема дублирования имён, как для оператора "
"<acronym>SQL</acronym>. Такая проблема может возникнуть при объединении "
"списков отношений, образованных разными правилами. В этой главе данная "
"ситуация рассматриваться не будет."

#: rules.xml:126(term)
msgid "the result relation"
msgstr "результирующее отношение"

#: rules.xml:130(para)
msgid ""
"This is an index into the range table that identifies the relation where the "
"results of the query go."
msgstr ""
"Индекс в списке отношений, указывающий на отношение, которое будет получать "
"результаты запроса."

#: rules.xml:135(para)
msgid ""
"<command>SELECT</command> queries don't have a result relation. (The special "
"case of <command>SELECT INTO</command> is mostly identical to "
"<command>CREATE TABLE</command> followed by <literal>INSERT ... SELECT</"
"literal>, and is not discussed separately here.)"
msgstr ""
"В запросах <command>SELECT</command> результирующее отношение отсутствует. "
"(Особый случай <command>SELECT INTO</command> практически равнозначен "
"<command>CREATE TABLE</command> с последующим <literal>INSERT ... SELECT</"
"literal> и здесь отдельно не рассматривается.)"

#: rules.xml:143(para)
msgid ""
"For <command>INSERT</command>, <command>UPDATE</command>, and "
"<command>DELETE</command> commands, the result relation is the table (or "
"view!) where the changes are to take effect."
msgstr ""
"Для команд <command>INSERT</command>, <command>UPDATE</command> и "
"<command>DELETE</command> результирующим отношением будет таблица (или "
"представление!), в которой будут происходить изменения."

#: rules.xml:154(indexterm)
msgid "<primary>target list</primary>"
msgstr "<primary>выходной список</primary>"

#: rules.xml:152(term)
msgid "the target list <placeholder-1/>"
msgstr "выходной список <placeholder-1/>"

#: rules.xml:157(para)
msgid ""
"The target list is a list of expressions that define the result of the "
"query. In the case of a <command>SELECT</command>, these expressions are the "
"ones that build the final output of the query. They correspond to the "
"expressions between the key words <command>SELECT</command> and "
"<command>FROM</command>. (<literal>*</literal> is just an abbreviation for "
"all the column names of a relation. It is expanded by the parser into the "
"individual columns, so the rule system never sees it.)"
msgstr ""
"Выходной список — это список выражений, определяющих результат запроса. В "
"случае <command>SELECT</command>, это выражения, которые образуют "
"окончательный набор выходных данных. Они соответствуют выражениям, "
"записанным между ключевыми словами <command>SELECT</command> и "
"<command>FROM</command>. (Указание <literal>*</literal> — это просто краткое "
"обозначение имён всех столбцов отношения. Анализатор разворачивает его в "
"список отдельных столбцов, так что система правил никогда не видит его.)"

#: rules.xml:169(para)
msgid ""
"<command>DELETE</command> commands don't need a normal target list because "
"they don't produce any result. Instead, the rule system adds a special "
"<acronym>CTID</acronym> entry to the empty target list, to allow the "
"executor to find the row to be deleted. (<acronym>CTID</acronym> is added "
"when the result relation is an ordinary table. If it is a view, a whole-row "
"variable is added instead, as described in <xref linkend=\"rules-views-update"
"\"/>.)"
msgstr ""
"Командам <command>DELETE</command> не нужен обычный выходной список, так как "
"они не выдают никакие результаты. Вместо этого, система правил добавляет в "
"пустой выходной список специальную запись <acronym>CTID</acronym>, чтобы "
"исполнитель мог найти удаляемую строку. (<acronym>CTID</acronym> "
"добавляется, когда результирующее отношение — обычная таблица. Если это "
"представление, добавляется переменная, содержащая всю строку, как "
"рассказывается в <xref remap=\"6\" linkend=\"rules-views-update\"/>.)"

#: rules.xml:179(para)
msgid ""
"For <command>INSERT</command> commands, the target list describes the new "
"rows that should go into the result relation. It consists of the expressions "
"in the <literal>VALUES</literal> clause or the ones from the "
"<command>SELECT</command> clause in <literal>INSERT ... SELECT</literal>. "
"The first step of the rewrite process adds target list entries for any "
"columns that were not assigned to by the original command but have defaults. "
"Any remaining columns (with neither a given value nor a default) will be "
"filled in by the planner with a constant null expression."
msgstr ""
"Для команд <command>INSERT</command> выходной список описывает новые строки, "
"которые должны попасть в результирующее отношение. Он включает выражения в "
"предложении <literal>VALUES</literal> или предложении <command>SELECT</"
"command> в <literal>INSERT ... SELECT</literal>. На первом этапе процесс "
"перезаписи добавляет элементы выходного списка для столбцов, которым ничего "
"не присвоила исходная команда, но имеющих значения по умолчанию. Все "
"остальные столбцы (без заданного значения и значения по умолчанию) "
"планировщик заполняет константой NULL."

#: rules.xml:191(para)
msgid ""
"For <command>UPDATE</command> commands, the target list describes the new "
"rows that should replace the old ones. In the rule system, it contains just "
"the expressions from the <literal>SET column = expression</literal> part of "
"the command. The planner will handle missing columns by inserting "
"expressions that copy the values from the old row into the new one. Just as "
"for <command>DELETE</command>, the rule system adds a <acronym>CTID</"
"acronym> or whole-row variable so that the executor can identify the old row "
"to be updated."
msgstr ""
"Для команд <command>UPDATE</command> выходной список описывает новые строки, "
"которые должны заменить старые. В системе правил он содержит только "
"выражения из части <literal>SET столбец = выражение</literal>. Для "
"пропущенных столбцов планировщик вставляет выражения, копирующие значения из "
"старой строки в новую. Так же, как и с командой <command>DELETE</command>, "
"система правил добавляет ещё <acronym>CTID</acronym> или переменную со всей "
"строкой, чтобы исполнитель мог найти изменяемую старую строку."

#: rules.xml:202(para)
msgid ""
"Every entry in the target list contains an expression that can be a constant "
"value, a variable pointing to a column of one of the relations in the range "
"table, a parameter, or an expression tree made of function calls, constants, "
"variables, operators, etc."
msgstr ""
"Каждая запись в выходном списке содержит выражение, которое может быть "
"константой, переменной, указывающей на столбец отношения в таблице "
"отношений, параметром или деревом выражений, образованным из констант, "
"переменных, операторов, вызовов функций и т. д."

#: rules.xml:212(term)
msgid "the qualification"
msgstr "условие фильтра"

#: rules.xml:216(para)
msgid ""
"The query's qualification is an expression much like one of those contained "
"in the target list entries. The result value of this expression is a Boolean "
"that tells whether the operation (<command>INSERT</command>, "
"<command>UPDATE</command>, <command>DELETE</command>, or <command>SELECT</"
"command>) for the final result row should be executed or not. It corresponds "
"to the <literal>WHERE</literal> clause of an <acronym>SQL</acronym> "
"statement."
msgstr ""
"Условие фильтра запроса — это выражение, во многом похожее на те, что "
"содержатся в выходном списке. Результат этого выражения — логический, он "
"говорит, должна ли выполняться операция (<command>INSERT</command>, "
"<command>UPDATE</command>, <command>DELETE</command> или <command>SELECT</"
"command>) для данной строки в результате. Оно соответствует предложению "
"<literal>WHERE</literal> <acronym>SQL</acronym>-оператора."

#: rules.xml:229(term)
msgid "the join tree"
msgstr "дерево соединения"

#: rules.xml:233(para)
msgid ""
"The query's join tree shows the structure of the <literal>FROM</literal> "
"clause. For a simple query like <literal>SELECT ... FROM a, b, c</literal>, "
"the join tree is just a list of the <literal>FROM</literal> items, because "
"we are allowed to join them in any order. But when <literal>JOIN</literal> "
"expressions, particularly outer joins, are used, we have to join in the "
"order shown by the joins. In that case, the join tree shows the structure of "
"the <literal>JOIN</literal> expressions. The restrictions associated with "
"particular <literal>JOIN</literal> clauses (from <literal>ON</literal> or "
"<literal>USING</literal> expressions) are stored as qualification "
"expressions attached to those join-tree nodes. It turns out to be convenient "
"to store the top-level <literal>WHERE</literal> expression as a "
"qualification attached to the top-level join-tree item, too. So really the "
"join tree represents both the <literal>FROM</literal> and <literal>WHERE</"
"literal> clauses of a <command>SELECT</command>."
msgstr ""
"Дерево соединения запроса показывает структуру предложения <literal>FROM</"
"literal>. Для простых запросов вида <literal>SELECT ... FROM a, b, c</"
"literal>, дерево соединения — это просто список элементов <literal>FROM</"
"literal>, так как они могут соединяться в любом порядке. Но с выражениями "
"<literal>JOIN</literal>, особенно с внешними соединениями, приходится "
"соединять отношения именно в заданном порядке. В этом случае дерево "
"соединения отражает структуру выражений <literal>JOIN</literal>. "
"Ограничения, связанные с конкретными предложениями <literal>JOIN</literal> "
"(из выражений <literal>ON</literal> или <literal>USING</literal>), тоже "
"сохраняются в виде условных выражений, добавленных к соответствующим узлам "
"дерева соединения. Как оказалось, выражение <literal>WHERE</literal> "
"верхнего уровня тоже удобно хранить как условие, добавленное к элементу "
"верхнего уровня дерева соединения. Поэтому в дереве соединения на самом деле "
"представляются оба предложения оператора <command>SELECT</command> — "
"<literal>FROM</literal> и <literal>WHERE</literal>."

#: rules.xml:251(term)
msgid "the others"
msgstr "другие"

#: rules.xml:255(para)
msgid ""
"The other parts of the query tree like the <literal>ORDER BY</literal> "
"clause aren't of interest here. The rule system substitutes some entries "
"there while applying rules, but that doesn't have much to do with the "
"fundamentals of the rule system."
msgstr ""
"Другие части дерева запроса, например, предложение <literal>ORDER BY</"
"literal>, в данном контексте не представляют интереса. Система правил "
"выполняет в них некоторые подстановки, применяя правила, но это не имеет "
"непосредственного отношения к основам системы правил."

#: rules.xml:79(para)
msgid ""
"When reading the <acronym>SQL</acronym> representations of the query trees "
"in this chapter it is necessary to be able to identify the parts the "
"statement is broken into when it is in the query tree structure. The parts "
"of a query tree are <placeholder-1/>"
msgstr ""
"Читая <acronym>SQL</acronym>-представления деревьев запросов в этой главе, "
"необходимо понимать, на какие части разбивается оператор, когда он "
"преобразуется в структуру дерева запроса. Дерево запроса состоит из "
"следующих частей: <placeholder-1/>"

#: rules.xml:270(title)
msgid "Views and the Rule System"
msgstr "Система правил и представления"

#: rules.xml:272(indexterm)
msgid "<primary>rule</primary> <secondary>and views</secondary>"
msgstr "<primary>правила</primary> <secondary>и представления</secondary>"

#: rules.xml:277(indexterm)
msgid ""
"<primary>view</primary> <secondary>implementation through rules</secondary>"
msgstr ""
"<primary>представление</primary> <secondary>реализация через правила</"
"secondary>"

#: rules.xml:287(programlisting)
#, no-wrap
msgid "CREATE VIEW myview AS SELECT * FROM mytab;"
msgstr "CREATE VIEW myview AS SELECT * FROM mytab;"

#: rules.xml:293(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE myview (<replaceable>same column list as mytab</replaceable>);\n"
"CREATE RULE \"_RETURN\" AS ON SELECT TO myview DO INSTEAD\n"
"    SELECT * FROM mytab;"
msgstr ""
"CREATE TABLE myview (<replaceable>same column list as mytab</replaceable>);\n"
"CREATE RULE \"_RETURN\" AS ON SELECT TO myview DO INSTEAD\n"
"    SELECT * FROM mytab;"

#: rules.xml:282(para)
msgid ""
"Views in <productname>PostgreSQL</productname> are implemented using the "
"rule system. In fact, there is essentially no difference between: "
"<placeholder-1/> compared against the two commands: <placeholder-2/> because "
"this is exactly what the <command>CREATE VIEW</command> command does "
"internally. This has some side effects. One of them is that the information "
"about a view in the <productname>PostgreSQL</productname> system catalogs is "
"exactly the same as it is for a table. So for the parser, there is "
"absolutely no difference between a table and a view. They are the same "
"thing: relations."
msgstr ""
"Представления в <productname>PostgreSQL</productname> реализованы на основе "
"системы правил. Фактически по сути нет никакого отличия <placeholder-1/> от "
"следующих двух команд: <placeholder-2/> так как именно эти действия "
"<command>CREATE VIEW</command> выполняет внутри. Это имеет некоторые "
"побочные эффекты. В частности, информация о представлениях в системных "
"каталогах <productname>PostgreSQL</productname> ничем не отличается от "
"информации о таблицах. Поэтому при анализе запроса нет абсолютно никакой "
"разницы между таблицами и представлениями. Они представляют собой одно и то "
"же — отношения."

#: rules.xml:309(title)
msgid "How <command>SELECT</command> Rules Work"
msgstr "Как работают правила <command>SELECT</command>"

#: rules.xml:311(indexterm)
msgid ""
"<primary>rule</primary> <secondary sortas=\"SELECT\">for SELECT</secondary>"
msgstr ""
"<primary>правило</primary> <secondary sortas=\"SELECT\">для SELECT</"
"secondary>"

#: rules.xml:316(para)
msgid ""
"Rules <literal>ON SELECT</literal> are applied to all queries as the last "
"step, even if the command given is an <command>INSERT</command>, "
"<command>UPDATE</command> or <command>DELETE</command>. And they have "
"different semantics from rules on the other command types in that they "
"modify the query tree in place instead of creating a new one. So "
"<command>SELECT</command> rules are described first."
msgstr ""
"Правила <literal>ON SELECT</literal> применяются ко всем запросам на "
"последнем этапе, даже если это команда <command>INSERT</command>, "
"<command>UPDATE</command> или <command>DELETE</command>. Эти правила "
"отличаются от правил других видов тем, что они модифицируют непосредственно "
"дерево запросов, а не создают новое. Поэтому мы начнём описание с правил "
"<command>SELECT</command>."

#: rules.xml:325(para)
msgid ""
"Currently, there can be only one action in an <literal>ON SELECT</literal> "
"rule, and it must be an unconditional <command>SELECT</command> action that "
"is <literal>INSTEAD</literal>. This restriction was required to make rules "
"safe enough to open them for ordinary users, and it restricts <literal>ON "
"SELECT</literal> rules to act like views."
msgstr ""
"В настоящее время возможно только одно действие в правиле <literal>ON "
"SELECT</literal> и это должно быть безусловное действие <command>SELECT</"
"command>, выполняемое в режиме <literal>INSTEAD</literal>. Это ограничение "
"было введено, чтобы сделать правила достаточно безопасными для применения "
"обычными пользователями, так что действие правил <literal>ON SELECT</"
"literal> сводится к реализации представлений."

#: rules.xml:332(para)
msgid ""
"The examples for this chapter are two join views that do some calculations "
"and some more views using them in turn. One of the two first views is "
"customized later by adding rules for <command>INSERT</command>, "
"<command>UPDATE</command>, and <command>DELETE</command> operations so that "
"the final result will be a view that behaves like a real table with some "
"magic functionality. This is not such a simple example to start from and "
"this makes things harder to get into. But it's better to have one example "
"that covers all the points discussed step by step rather than having many "
"different ones that might mix up in mind."
msgstr ""
"В примерах этой главы рассматриваются два представления с соединением, "
"которые выполняют некоторые вычисления, и которые, в свою очередь, "
"используются другими представлениями. Первое из этих двух представлений "
"затем модифицируется, к нему добавляются правила для операций "
"<command>INSERT</command>, <command>UPDATE</command> и <command>DELETE</"
"command>, так что в итоге получается представление, которое работает как "
"обычная таблица с некоторыми необычными функциями. Это не самый простой "
"пример для начала, поэтому понять некоторые вещи будет сложнее. Но лучше "
"иметь один пример, поэтапно охватывающий все обсуждаемые здесь темы, чем "
"несколько различных, при восприятии которых в итоге может возникнуть "
"путаница."

#: rules.xml:349(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION min(integer, integer) RETURNS integer AS $$\n"
"    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END\n"
"$$ LANGUAGE SQL STRICT;"
msgstr ""
"CREATE FUNCTION min(integer, integer) RETURNS integer AS $$\n"
"    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END\n"
"$$ LANGUAGE SQL STRICT;"

#: rules.xml:345(para)
msgid ""
"For the example, we need a little <literal>min</literal> function that "
"returns the lower of 2 integer values. We create that as: <placeholder-1/>"
msgstr ""
"Например, нам нужна простейшая функция <literal>min</literal>, которая "
"возвратит минимальное из двух целых чисел. Её можно создать так: "
"<placeholder-1/>"

#: rules.xml:360(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE shoe_data (\n"
"    shoename   text,          -- primary key\n"
"    sh_avail   integer,       -- available number of pairs\n"
"    slcolor    text,          -- preferred shoelace color\n"
"    slminlen   real,          -- minimum shoelace length\n"
"    slmaxlen   real,          -- maximum shoelace length\n"
"    slunit     text           -- length unit\n"
");\n"
"\n"
"CREATE TABLE shoelace_data (\n"
"    sl_name    text,          -- primary key\n"
"    sl_avail   integer,       -- available number of pairs\n"
"    sl_color   text,          -- shoelace color\n"
"    sl_len     real,          -- shoelace length\n"
"    sl_unit    text           -- length unit\n"
");\n"
"\n"
"CREATE TABLE unit (\n"
"    un_name    text,          -- primary key\n"
"    un_fact    real           -- factor to transform to cm\n"
");"
msgstr ""
"CREATE TABLE shoe_data (\n"
"    shoename   text,          -- первичный ключ\n"
"    sh_avail   integer,       -- число имеющихся пар\n"
"    slcolor    text,          -- предпочитаемый цвет шнурков\n"
"    slminlen   real,          -- минимальная длина шнурков\n"
"    slmaxlen   real,          -- максимальная длина шнурков\n"
"    slunit     text           -- единица длины\n"
");\n"
"\n"
"CREATE TABLE shoelace_data (\n"
"    sl_name    text,          -- первичный ключ\n"
"    sl_avail   integer,       -- число имеющихся пар\n"
"    sl_color   text,          -- цвет шнурков\n"
"    sl_len     real,          -- длина шнурков\n"
"    sl_unit    text           -- единица длины\n"
");\n"
"\n"
"CREATE TABLE unit (\n"
"    un_name    text,          -- первичный ключ\n"
"    un_fact    real           -- коэффициент для перевода в см\n"
");"

#: rules.xml:356(para)
msgid ""
"The real tables we need in the first two rule system descriptions are these: "
"<placeholder-1/> As you can see, they represent shoe-store data."
msgstr ""
"Таблицы, которые понадобятся нам для описания системы правил, выглядят так: "
"<placeholder-1/> Как можно догадаться, в них хранятся данные обувной фабрики."

#: rules.xml:390(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW shoe AS\n"
"    SELECT sh.shoename,\n"
"           sh.sh_avail,\n"
"           sh.slcolor,\n"
"           sh.slminlen,\n"
"           sh.slminlen * un.un_fact AS slminlen_cm,\n"
"           sh.slmaxlen,\n"
"           sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n"
"           sh.slunit\n"
"      FROM shoe_data sh, unit un\n"
"     WHERE sh.slunit = un.un_name;\n"
"\n"
"CREATE VIEW shoelace AS\n"
"    SELECT s.sl_name,\n"
"           s.sl_avail,\n"
"           s.sl_color,\n"
"           s.sl_len,\n"
"           s.sl_unit,\n"
"           s.sl_len * u.un_fact AS sl_len_cm\n"
"      FROM shoelace_data s, unit u\n"
"     WHERE s.sl_unit = u.un_name;\n"
"\n"
"CREATE VIEW shoe_ready AS\n"
"    SELECT rsh.shoename,\n"
"           rsh.sh_avail,\n"
"           rsl.sl_name,\n"
"           rsl.sl_avail,\n"
"           min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n"
"      FROM shoe rsh, shoelace rsl\n"
"     WHERE rsl.sl_color = rsh.slcolor\n"
"       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n"
"       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;"
msgstr ""
"CREATE VIEW shoe AS\n"
"    SELECT sh.shoename,\n"
"           sh.sh_avail,\n"
"           sh.slcolor,\n"
"           sh.slminlen,\n"
"           sh.slminlen * un.un_fact AS slminlen_cm,\n"
"           sh.slmaxlen,\n"
"           sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n"
"           sh.slunit\n"
"      FROM shoe_data sh, unit un\n"
"     WHERE sh.slunit = un.un_name;\n"
"\n"
"CREATE VIEW shoelace AS\n"
"    SELECT s.sl_name,\n"
"           s.sl_avail,\n"
"           s.sl_color,\n"
"           s.sl_len,\n"
"           s.sl_unit,\n"
"           s.sl_len * u.un_fact AS sl_len_cm\n"
"      FROM shoelace_data s, unit u\n"
"     WHERE s.sl_unit = u.un_name;\n"
"\n"
"CREATE VIEW shoe_ready AS\n"
"    SELECT rsh.shoename,\n"
"           rsh.sh_avail,\n"
"           rsl.sl_name,\n"
"           rsl.sl_avail,\n"
"           min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n"
"      FROM shoe rsh, shoelace rsl\n"
"     WHERE rsl.sl_color = rsh.slcolor\n"
"       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n"
"       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;"

#: rules.xml:387(para)
msgid ""
"The views are created as: <placeholder-1/> The <command>CREATE VIEW</"
"command> command for the <literal>shoelace</literal> view (which is the "
"simplest one we have) will create a relation <literal>shoelace</literal> and "
"an entry in <structname>pg_rewrite</structname> that tells that there is a "
"rewrite rule that must be applied whenever the relation <literal>shoelace</"
"literal> is referenced in a query's range table. The rule has no rule "
"qualification (discussed later, with the non-<command>SELECT</command> "
"rules, since <command>SELECT</command> rules currently cannot have them) and "
"it is <literal>INSTEAD</literal>. Note that rule qualifications are not the "
"same as query qualifications. The action of our rule has a query "
"qualification. The action of the rule is one query tree that is a copy of "
"the <command>SELECT</command> statement in the view creation command."
msgstr ""
"Представления создаются так: <placeholder-1/> Команда <command>CREATE VIEW</"
"command> для представления <literal>shoelace</literal> (самого простого из "
"имеющихся) создаёт отношение <literal>shoelace</literal> и запись в "
"<structname>pg_rewrite</structname> о правиле перезаписи, которое должно "
"применяться, когда в запросе на выборку задействуется отношение "
"<literal>shoelace</literal>. Для этого правила не задаются условия "
"применения (о них рассказывается ниже, в описании правил не для "
"<command>SELECT</command>, так как правила <command>SELECT</command> в "
"настоящее бывают только безусловными) и оно действует в режиме "
"<literal>INSTEAD</literal>. Заметьте, что условия применения отличаются от "
"условий фильтра запроса, например, действие для нашего правила содержит "
"условие фильтра. Действие правила выражается одним деревом запроса, которое "
"является копией оператора <command>SELECT</command> в команде, создающей "
"представление."

#: rules.xml:440(para)
msgid ""
"The two extra range table entries for <literal>NEW</literal> and "
"<literal>OLD</literal> that you can see in the <structname>pg_rewrite</"
"structname> entry aren't of interest for <command>SELECT</command> rules."
msgstr ""
"Два дополнительных элемента списка отношений <literal>NEW</literal> и "
"<literal>OLD</literal>, которые можно увидеть в соответствующей строке "
"<structname>pg_rewrite</structname>, не представляют интереса для правил "
"<command>SELECT</command>."

#: rules.xml:452(programlisting)
#, no-wrap
msgid ""
"INSERT INTO unit VALUES ('cm', 1.0);\n"
"INSERT INTO unit VALUES ('m', 100.0);\n"
"INSERT INTO unit VALUES ('inch', 2.54);\n"
"\n"
"INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');\n"
"INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');\n"
"INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');\n"
"INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');\n"
"\n"
"INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');\n"
"INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');\n"
"INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');\n"
"INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');\n"
"INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');\n"
"INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');\n"
"INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');\n"
"INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');\n"
"\n"
"SELECT * FROM shoelace;\n"
"\n"
" sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"-----------+----------+----------+--------+---------+-----------\n"
" sl1       |        5 | black    |     80 | cm      |        80\n"
" sl2       |        6 | black    |    100 | cm      |       100\n"
" sl7       |        7 | brown    |     60 | cm      |        60\n"
" sl3       |        0 | black    |     35 | inch    |      88.9\n"
" sl4       |        8 | black    |     40 | inch    |     101.6\n"
" sl8       |        1 | brown    |     40 | inch    |     101.6\n"
" sl5       |        4 | brown    |      1 | m       |       100\n"
" sl6       |        0 | brown    |    0.9 | m       |        90\n"
"(8 rows)"
msgstr ""
"INSERT INTO unit VALUES ('cm', 1.0);\n"
"INSERT INTO unit VALUES ('m', 100.0);\n"
"INSERT INTO unit VALUES ('inch', 2.54);\n"
"\n"
"INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');\n"
"INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');\n"
"INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');\n"
"INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');\n"
"\n"
"INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');\n"
"INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');\n"
"INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0, 'inch');\n"
"INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0, 'inch');\n"
"INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0, 'm');\n"
"INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9, 'm');\n"
"INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60, 'cm');\n"
"INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40, 'inch');\n"
"\n"
"SELECT * FROM shoelace;\n"
"\n"
" sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"-----------+----------+----------+--------+---------+-----------\n"
" sl1       |        5 | black    |     80 | cm      |        80\n"
" sl2       |        6 | black    |    100 | cm      |       100\n"
" sl7       |        7 | brown    |     60 | cm      |        60\n"
" sl3       |        0 | black    |     35 | inch    |      88.9\n"
" sl4       |        8 | black    |     40 | inch    |     101.6\n"
" sl8       |        1 | brown    |     40 | inch    |     101.6\n"
" sl5       |        4 | brown    |      1 | m       |       100\n"
" sl6       |        0 | brown    |    0.9 | m       |        90\n"
"(8 rows)"

#: rules.xml:448(para)
msgid ""
"Now we populate <literal>unit</literal>, <literal>shoe_data</literal> and "
"<literal>shoelace_data</literal> and run a simple query on a view: "
"<placeholder-1/>"
msgstr ""
"Сейчас мы наполним таблицы <literal>unit</literal> (единицы измерения), "
"<literal>shoe_data</literal> (данные о туфлях) и <literal>shoelace_data</"
"literal> (данные о шнурках) и выполним простой запрос к представлению: "
"<placeholder-1/>"

#: rules.xml:493(programlisting)
#, no-wrap
msgid ""
"SELECT shoelace.sl_name, shoelace.sl_avail,\n"
"       shoelace.sl_color, shoelace.sl_len,\n"
"       shoelace.sl_unit, shoelace.sl_len_cm\n"
"  FROM shoelace shoelace;"
msgstr ""
"SELECT shoelace.sl_name, shoelace.sl_avail,\n"
"       shoelace.sl_color, shoelace.sl_len,\n"
"       shoelace.sl_unit, shoelace.sl_len_cm\n"
"  FROM shoelace shoelace;"

#: rules.xml:506(programlisting)
#, no-wrap
msgid ""
"SELECT s.sl_name, s.sl_avail,\n"
"       s.sl_color, s.sl_len, s.sl_unit,\n"
"       s.sl_len * u.un_fact AS sl_len_cm\n"
"  FROM shoelace old, shoelace new,\n"
"       shoelace_data s, unit u\n"
" WHERE s.sl_unit = u.un_name;"
msgstr ""
"SELECT s.sl_name, s.sl_avail,\n"
"       s.sl_color, s.sl_len, s.sl_unit,\n"
"       s.sl_len * u.un_fact AS sl_len_cm\n"
"  FROM shoelace old, shoelace new,\n"
"       shoelace_data s, unit u\n"
" WHERE s.sl_unit = u.un_name;"

#: rules.xml:487(para)
msgid ""
"This is the simplest <command>SELECT</command> you can do on our views, so "
"we take this opportunity to explain the basics of view rules. The "
"<literal>SELECT * FROM shoelace</literal> was interpreted by the parser and "
"produced the query tree: <placeholder-1/> and this is given to the rule "
"system. The rule system walks through the range table and checks if there "
"are rules for any relation. When processing the range table entry for "
"<literal>shoelace</literal> (the only one up to now) it finds the "
"<literal>_RETURN</literal> rule with the query tree: <placeholder-2/>"
msgstr ""
"Это самый простой запрос <command>SELECT</command>, который можно выполнить "
"с нашими представлениями, и мы воспользуемся этим, чтобы объяснить азы "
"правил представлений. Запрос <literal>SELECT * FROM shoelace</literal> "
"интерпретируется анализатором запросов и преобразуется в дерево запроса: "
"<placeholder-1/> Это дерево передаётся в систему правил, которая проходит по "
"списку отношений и проверяет, есть ли какие-либо правила для этих отношений. "
"Обрабатывая элемент отношения <literal>shoelace</literal> (сейчас он "
"единственный), система правил находит правило <literal>_RETURN</literal> с "
"деревом запроса: <placeholder-2/>"

#: rules.xml:522(programlisting)
#, no-wrap
msgid ""
"SELECT shoelace.sl_name, shoelace.sl_avail,\n"
"       shoelace.sl_color, shoelace.sl_len,\n"
"       shoelace.sl_unit, shoelace.sl_len_cm\n"
"  FROM (SELECT s.sl_name,\n"
"               s.sl_avail,\n"
"               s.sl_color,\n"
"               s.sl_len,\n"
"               s.sl_unit,\n"
"               s.sl_len * u.un_fact AS sl_len_cm\n"
"          FROM shoelace_data s, unit u\n"
"         WHERE s.sl_unit = u.un_name) shoelace;"
msgstr ""
"SELECT shoelace.sl_name, shoelace.sl_avail,\n"
"       shoelace.sl_color, shoelace.sl_len,\n"
"       shoelace.sl_unit, shoelace.sl_len_cm\n"
"  FROM (SELECT s.sl_name,\n"
"               s.sl_avail,\n"
"               s.sl_color,\n"
"               s.sl_len,\n"
"               s.sl_unit,\n"
"               s.sl_len * u.un_fact AS sl_len_cm\n"
"          FROM shoelace_data s, unit u\n"
"         WHERE s.sl_unit = u.un_name) shoelace;"

#: rules.xml:516(para)
msgid ""
"To expand the view, the rewriter simply creates a subquery range-table entry "
"containing the rule's action query tree, and substitutes this range table "
"entry for the original one that referenced the view. The resulting rewritten "
"query tree is almost the same as if you had typed: <placeholder-1/> There is "
"one difference however: the subquery's range table has two extra entries "
"<literal>shoelace old</literal> and <literal>shoelace new</literal>. These "
"entries don't participate directly in the query, since they aren't "
"referenced by the subquery's join tree or target list. The rewriter uses "
"them to store the access privilege check information that was originally "
"present in the range-table entry that referenced the view. In this way, the "
"executor will still check that the user has proper privileges to access the "
"view, even though there's no direct use of the view in the rewritten query."
msgstr ""
"Чтобы развернуть представление, механизм перезаписи просто формирует новый "
"элемент для списка отношений — подзапрос, содержащий дерево действия "
"правила, и подставляет этот элемент вместо исходного, на который ссылалось "
"представление. Получившееся перезаписанное дерево запроса будет почти таким "
"как дерево запроса: <placeholder-1/> Однако есть одно различие: в списке "
"отношений подзапроса будут содержаться два дополнительных элемента: "
"<literal>shoelace old</literal> и <literal>shoelace new</literal>. Эти "
"элементы не принимают непосредственного участия в запросе, так как они не "
"задействованы в дереве соединения подзапроса и в целевом списке. Механизм "
"перезаписи использует их для хранения информации о проверке прав доступа, "
"которая изначально хранилась в элементе, указывающем на представление. Таким "
"образом, исполнитель будет по-прежнему проверять, имеет ли пользователь "
"необходимые права для доступа к представлению, хотя в перезаписанном запросе "
"это представление не фигурирует непосредственно."

#: rules.xml:547(para)
msgid ""
"That was the first rule applied. The rule system will continue checking the "
"remaining range-table entries in the top query (in this example there are no "
"more), and it will recursively check the range-table entries in the added "
"subquery to see if any of them reference views. (But it won't expand "
"<literal>old</literal> or <literal>new</literal> &mdash; otherwise we'd have "
"infinite recursion!) In this example, there are no rewrite rules for "
"<literal>shoelace_data</literal> or <literal>unit</literal>, so rewriting is "
"complete and the above is the final result given to the planner."
msgstr ""
"Так было применено первое правило. Система правил продолжит проверку "
"оставшихся элементов списка отношений на верхнем уровне запроса (в данном "
"случае таких элементов нет) и рекурсивно проверит элементы списка отношений "
"в добавленном подзапросе, не ссылаются ли они на представления. (Но "
"<literal>old</literal> и <literal>new</literal> разворачиваться не будут "
"&mdash; иначе мы получили бы бесконечную рекурсию!) В этом примере для "
"<literal>shoelace_data</literal> и <literal>unit</literal> нет правил "
"перезаписи, так что перезапись завершается и результат, полученный выше, "
"передаётся планировщику."

#: rules.xml:563(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;\n"
"\n"
" shoename | sh_avail | sl_name | sl_avail | total_avail\n"
"----------+----------+---------+----------+-------------\n"
" sh1      |        2 | sl1     |        5 |           2\n"
" sh3      |        4 | sl7     |        7 |           4\n"
"(2 rows)"
msgstr ""
"SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;\n"
"\n"
" shoename | sh_avail | sl_name | sl_avail | total_avail\n"
"----------+----------+---------+----------+-------------\n"
" sh1      |        2 | sl1     |        5 |           2\n"
" sh3      |        4 | sl7     |        7 |           4\n"
"(2 rows)"

#: rules.xml:558(para)
msgid ""
"Now we want to write a query that finds out for which shoes currently in the "
"store we have the matching shoelaces (color and length) and where the total "
"number of exactly matching pairs is greater or equal to two. <placeholder-1/>"
msgstr ""
"Сейчас мы хотим написать запрос, который выбирает туфли из имеющихся в "
"данный момент, для которых есть подходящие шнурки (по цвету и длине) и число "
"готовых пар больше или равно двум. <placeholder-1/>"

#: rules.xml:577(programlisting)
#, no-wrap
msgid ""
"SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n"
"       shoe_ready.sl_name, shoe_ready.sl_avail,\n"
"       shoe_ready.total_avail\n"
"  FROM shoe_ready shoe_ready\n"
" WHERE shoe_ready.total_avail &gt;= 2;"
msgstr ""
"SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n"
"       shoe_ready.sl_name, shoe_ready.sl_avail,\n"
"       shoe_ready.total_avail\n"
"  FROM shoe_ready shoe_ready\n"
" WHERE shoe_ready.total_avail &gt;= 2;"

#: rules.xml:589(programlisting)
#, no-wrap
msgid ""
"SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n"
"       shoe_ready.sl_name, shoe_ready.sl_avail,\n"
"       shoe_ready.total_avail\n"
"  FROM (SELECT rsh.shoename,\n"
"               rsh.sh_avail,\n"
"               rsl.sl_name,\n"
"               rsl.sl_avail,\n"
"               min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n"
"          FROM shoe rsh, shoelace rsl\n"
"         WHERE rsl.sl_color = rsh.slcolor\n"
"           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n"
"           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready\n"
" WHERE shoe_ready.total_avail &gt;= 2;"
msgstr ""
"SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n"
"       shoe_ready.sl_name, shoe_ready.sl_avail,\n"
"       shoe_ready.total_avail\n"
"  FROM (SELECT rsh.shoename,\n"
"               rsh.sh_avail,\n"
"               rsl.sl_name,\n"
"               rsl.sl_avail,\n"
"               min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n"
"          FROM shoe rsh, shoelace rsl\n"
"         WHERE rsl.sl_color = rsh.slcolor\n"
"           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n"
"           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready\n"
" WHERE shoe_ready.total_avail &gt;= 2;"

#: rules.xml:609(programlisting)
#, no-wrap
msgid ""
"SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n"
"       shoe_ready.sl_name, shoe_ready.sl_avail,\n"
"       shoe_ready.total_avail\n"
"  FROM (SELECT rsh.shoename,\n"
"               rsh.sh_avail,\n"
"               rsl.sl_name,\n"
"               rsl.sl_avail,\n"
"               min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n"
"          FROM (SELECT sh.shoename,\n"
"                       sh.sh_avail,\n"
"                       sh.slcolor,\n"
"                       sh.slminlen,\n"
"                       sh.slminlen * un.un_fact AS slminlen_cm,\n"
"                       sh.slmaxlen,\n"
"                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n"
"                       sh.slunit\n"
"                  FROM shoe_data sh, unit un\n"
"                 WHERE sh.slunit = un.un_name) rsh,\n"
"               (SELECT s.sl_name,\n"
"                       s.sl_avail,\n"
"                       s.sl_color,\n"
"                       s.sl_len,\n"
"                       s.sl_unit,\n"
"                       s.sl_len * u.un_fact AS sl_len_cm\n"
"                  FROM shoelace_data s, unit u\n"
"                 WHERE s.sl_unit = u.un_name) rsl\n"
"         WHERE rsl.sl_color = rsh.slcolor\n"
"           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n"
"           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready\n"
" WHERE shoe_ready.total_avail &gt; 2;"
msgstr ""
"SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n"
"       shoe_ready.sl_name, shoe_ready.sl_avail,\n"
"       shoe_ready.total_avail\n"
"  FROM (SELECT rsh.shoename,\n"
"               rsh.sh_avail,\n"
"               rsl.sl_name,\n"
"               rsl.sl_avail,\n"
"               min(rsh.sh_avail, rsl.sl_avail) AS total_avail\n"
"          FROM (SELECT sh.shoename,\n"
"                       sh.sh_avail,\n"
"                       sh.slcolor,\n"
"                       sh.slminlen,\n"
"                       sh.slminlen * un.un_fact AS slminlen_cm,\n"
"                       sh.slmaxlen,\n"
"                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n"
"                       sh.slunit\n"
"                  FROM shoe_data sh, unit un\n"
"                 WHERE sh.slunit = un.un_name) rsh,\n"
"               (SELECT s.sl_name,\n"
"                       s.sl_avail,\n"
"                       s.sl_color,\n"
"                       s.sl_len,\n"
"                       s.sl_unit,\n"
"                       s.sl_len * u.un_fact AS sl_len_cm\n"
"                  FROM shoelace_data s, unit u\n"
"                 WHERE s.sl_unit = u.un_name) rsl\n"
"         WHERE rsl.sl_color = rsh.slcolor\n"
"           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm\n"
"           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready\n"
" WHERE shoe_ready.total_avail &gt; 2;"

#: rules.xml:574(para)
msgid ""
"The output of the parser this time is the query tree: <placeholder-1/> The "
"first rule applied will be the one for the <literal>shoe_ready</literal> "
"view and it results in the query tree: <placeholder-2/> Similarly, the rules "
"for <literal>shoe</literal> and <literal>shoelace</literal> are substituted "
"into the range table of the subquery, leading to a three-level final query "
"tree: <placeholder-3/>"
msgstr ""
"На этот раз анализатор запроса выводит такое дерево: <placeholder-1/> Первое "
"правило применяется к представлению <literal>shoe_ready</literal> и в "
"результате получается дерево запроса: <placeholder-2/> Подобным образом, "
"правила для <literal>shoe</literal> и <literal>shoelace</literal> "
"подставляются в список отношений, что даёт окончательное дерево запроса: "
"<placeholder-3/>"

#: rules.xml:643(para)
msgid ""
"It turns out that the planner will collapse this tree into a two-level query "
"tree: the bottommost <command>SELECT</command> commands will be "
"<quote>pulled up</quote> into the middle <command>SELECT</command> since "
"there's no need to process them separately. But the middle <command>SELECT</"
"command> will remain separate from the top, because it contains aggregate "
"functions. If we pulled those up it would change the behavior of the topmost "
"<command>SELECT</command>, which we don't want. However, collapsing the "
"query tree is an optimization that the rewrite system doesn't have to "
"concern itself with."
msgstr ""
"На практике планировщик будет сворачивать это дерево до двух уровней: "
"команды нижнего уровня <command>SELECT</command> будут <quote>подняты</"
"quote> к среднему <command>SELECT</command>, так как обрабатывать их "
"отдельно нет необходимости. Но средний оператор <command>SELECT</command> не "
"будет совмещён с верхним, так как он содержит агрегатные функции. Если "
"поднять его выше, поведение самого верхнего <command>SELECT</command> "
"изменится нежелательным образом. В целом же, сворачивание дерева запросов — "
"это оптимизация, которая не должна затрагивать работу механизма перезаписи."

#: rules.xml:658(title)
msgid "View Rules in Non-<command>SELECT</command> Statements"
msgstr "Правила представлений не для <command>SELECT</command>"

#: rules.xml:660(para)
msgid ""
"Two details of the query tree aren't touched in the description of view "
"rules above. These are the command type and the result relation. In fact, "
"the command type is not needed by view rules, but the result relation may "
"affect the way in which the query rewriter works, because special care needs "
"to be taken if the result relation is a view."
msgstr ""
"До этого в описании правил представлений не затрагивались два компонента "
"дерева запросов — тип команды и результирующее отношение. На самом деле, тип "
"команды не важен для правил представления, но результирующее отношение может "
"повлиять на работу механизма перезаписи, потому что если это представление, "
"требуются дополнительные операции."

#: rules.xml:678(programlisting)
#, no-wrap
msgid ""
"SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;\n"
"\n"
"UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;"
msgstr ""
"SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;\n"
"\n"
"UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;"

#: rules.xml:688(para)
msgid ""
"The range tables contain entries for the tables <literal>t1</literal> and "
"<literal>t2</literal>."
msgstr ""
"Списки отношений содержат элементы для таблиц <literal>t1</literal> и "
"<literal>t2</literal>."

#: rules.xml:694(para)
msgid ""
"The target lists contain one variable that points to column <literal>b</"
"literal> of the range table entry for table <literal>t2</literal>."
msgstr ""
"Выходные списки содержат одну переменную, указывающую на столбец <literal>b</"
"literal> элемента-отношения для таблицы <literal>t2</literal>."

#: rules.xml:701(para)
msgid ""
"The qualification expressions compare the columns <literal>a</literal> of "
"both range-table entries for equality."
msgstr ""
"Выражения условий сравнивают столбцы <literal>a</literal> обоих элементов-"
"отношений на равенство."

#: rules.xml:708(para)
msgid ""
"The join trees show a simple join between <literal>t1</literal> and "
"<literal>t2</literal>."
msgstr ""
"Деревья соединений показывают простое соединение между <literal>t1</literal> "
"и <literal>t2</literal>."

#: rules.xml:668(para)
msgid ""
"There are only a few differences between a query tree for a <command>SELECT</"
"command> and one for any other command. Obviously, they have a different "
"command type and for a command other than a <command>SELECT</command>, the "
"result relation points to the range-table entry where the result should go. "
"Everything else is absolutely the same. So having two tables <literal>t1</"
"literal> and <literal>t2</literal> with columns <literal>a</literal> and "
"<literal>b</literal>, the query trees for the two statements: <placeholder-1/"
"> are nearly identical. In particular: <placeholder-2/>"
msgstr ""
"Есть только несколько отличий между деревом запроса для <command>SELECT</"
"command> и деревом для другой команды. Очевидно, у них различные типы "
"команд, и для команды, отличной от <command>SELECT</command>, результирующее "
"отношение указывает на элемент в списке отношений, куда должен попасть "
"результат. Все остальные компоненты в точности те же. Поэтому, например, "
"если взять таблицы <literal>t1</literal> и <literal>t2</literal> со "
"столбцами <literal>a</literal> и <literal>b</literal>, деревья запросов для "
"этих операторов: <placeholder-1/> будут практически одинаковыми. В "
"частности: <placeholder-2/>"

#: rules.xml:722(programlisting)
#, no-wrap
msgid "UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;"
msgstr "UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;"

#: rules.xml:729(programlisting)
#, no-wrap
msgid "SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;"
msgstr "SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;"

#: rules.xml:715(para)
msgid ""
"The consequence is, that both query trees result in similar execution plans: "
"They are both joins over the two tables. For the <command>UPDATE</command> "
"the missing columns from <literal>t1</literal> are added to the target list "
"by the planner and the final query tree will read as: <placeholder-1/> and "
"thus the executor run over the join will produce exactly the same result set "
"as: <placeholder-2/> But there is a little problem in <command>UPDATE</"
"command>: the part of the executor plan that does the join does not care "
"what the results from the join are meant for. It just produces a result set "
"of rows. The fact that one is a <command>SELECT</command> command and the "
"other is an <command>UPDATE</command> is handled higher up in the executor, "
"where it knows that this is an <command>UPDATE</command>, and it knows that "
"this result should go into table <literal>t1</literal>. But which of the "
"rows that are there has to be replaced by the new row?"
msgstr ""
"Как следствие, для обоих деревьев строятся похожие планы выполнения, с "
"соединением двух таблиц. Для <command>UPDATE</command> планировщик добавляет "
"в выходной список недостающие столбцы из <literal>t1</literal> и "
"окончательное дерево становится таким: <placeholder-1/> В результате "
"исполнитель, обрабатывающий соединение, выдаёт тот же результат, что и "
"запрос: <placeholder-2/> Но с <command>UPDATE</command> есть маленькая "
"проблема: часть плана исполнителя, в которой выполняется соединение, не "
"представляет, для чего предназначены результаты соединения. Она просто "
"выдаёт результирующий набор строк. Фактически есть одна команда "
"<command>SELECT</command>, а другая, <command>UPDATE</command>, "
"обрабатывается исполнителем выше, где он уже знает, что это команда "
"<command>UPDATE</command> и что результат должен попасть в таблицу "
"<literal>t1</literal>. Но какие из строк таблицы должны заменяться новыми?"

#: rules.xml:748(indexterm)
msgid "<primary>CTID</primary>"
msgstr "<primary>CTID</primary>"

#: rules.xml:755(programlisting)
#, no-wrap
msgid "SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;"
msgstr "SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;"

#: rules.xml:744(para)
msgid ""
"To resolve this problem, another entry is added to the target list in "
"<command>UPDATE</command> (and also in <command>DELETE</command>) "
"statements: the current tuple ID (<acronym>CTID</acronym>).<placeholder-1/> "
"This is a system column containing the file block number and position in the "
"block for the row. Knowing the table, the <acronym>CTID</acronym> can be "
"used to retrieve the original row of <literal>t1</literal> to be updated. "
"After adding the <acronym>CTID</acronym> to the target list, the query "
"actually looks like: <placeholder-2/> Now another detail of "
"<productname>PostgreSQL</productname> enters the stage. Old table rows "
"aren't overwritten, and this is why <command>ROLLBACK</command> is fast. In "
"an <command>UPDATE</command>, the new result row is inserted into the table "
"(after stripping the <acronym>CTID</acronym>) and in the row header of the "
"old row, which the <acronym>CTID</acronym> pointed to, the <literal>cmax</"
"literal> and <literal>xmax</literal> entries are set to the current command "
"counter and current transaction ID. Thus the old row is hidden, and after "
"the transaction commits the vacuum cleaner can eventually remove the dead "
"row."
msgstr ""
"Для решения этой проблемы в выходной список операторов <command>UPDATE</"
"command> (и <command>DELETE</command>) добавляется ещё один элемент: "
"идентификатор текущего кортежа (Current Tuple ID, <acronym>CTID</acronym>)."
"<placeholder-1/> Это системный столбец, содержащий номер блока в файле и "
"позицию строки в блоке. Зная таблицу, по <acronym>CTID</acronym> можно "
"получить исходную строку в <literal>t1</literal>, подлежащую изменению. С "
"добавленным в выходной список <acronym>CTID</acronym> запрос фактически "
"выглядит так: <placeholder-2/> Теперь мы перейдём ещё к одной особенности "
"<productname>PostgreSQL</productname>. Старые строки таблицы не "
"переписываются, поэтому <command>ROLLBACK</command> выполняется быстро. С "
"командой <command>UPDATE</command> в таблицу вставляется новая строка "
"результата (без <acronym>CTID</acronym>) и в заголовке старой строки, на "
"которую указывает <acronym>CTID</acronym>, в поля <literal>cmax</literal> и "
"<literal>xmax</literal> записываются текущий счётчик команд и идентификатор "
"текущей транзакции. Таким образом, старая строка оказывается скрытой и после "
"фиксирования транзакции процесс очистки может окончательно удалить "
"неактуальную версию строки."

#: rules.xml:771(para)
msgid ""
"Knowing all that, we can simply apply view rules in absolutely the same way "
"to any command. There is no difference."
msgstr ""
"Зная всё это, мы можем применять правила представлений абсолютно таким же "
"образом к любой команде — никаких различий нет."

#: rules.xml:778(title)
msgid "The Power of Views in <productname>PostgreSQL</productname>"
msgstr "Преимущества представлений в <productname>PostgreSQL</productname>"

#: rules.xml:780(para)
msgid ""
"The above demonstrates how the rule system incorporates view definitions "
"into the original query tree. In the second example, a simple "
"<command>SELECT</command> from one view created a final query tree that is a "
"join of 4 tables (<literal>unit</literal> was used twice with different "
"names)."
msgstr ""
"Выше было показано, как система правил внедряет определения представлений в "
"исходное дерево запроса. Во втором примере простой запрос <command>SELECT</"
"command> к одному представлению создал окончательное дерево запроса, "
"соединяющее 4 таблицы (таблица <literal>unit</literal> использовалась дважды "
"с разными именами)."

#: rules.xml:788(para)
msgid ""
"The benefit of implementing views with the rule system is, that the planner "
"has all the information about which tables have to be scanned plus the "
"relationships between these tables plus the restrictive qualifications from "
"the views plus the qualifications from the original query in one single "
"query tree. And this is still the situation when the original query is "
"already a join over views. The planner has to decide which is the best path "
"to execute the query, and the more information the planner has, the better "
"this decision can be. And the rule system as implemented in "
"<productname>PostgreSQL</productname> ensures, that this is all information "
"available about the query up to that point."
msgstr ""
"Преимущество реализации представлений через систему правил заключается в "
"том, что планировщик получает в одном дереве запроса всю информацию о "
"таблицах, которые нужно прочитать, о том, как связаны эти таблицы, об "
"условиях в представлениях, а также об условиях, заданных в исходном запросе. "
"И всё это имеет место, когда сам исходный запрос представляет собой "
"соединение представлений. Планировщик должен выбрать лучший способ "
"выполнения запроса, и чем больше информации он получит, тем лучше может быть "
"его выбор. И то, как в <productname>PostgreSQL</productname> реализована "
"система правил, гарантирует, что ему поступает вся информация, собранная о "
"запросе на данный момент."

#: rules.xml:807(title)
msgid "Updating a View"
msgstr "Изменение представления"

#: rules.xml:809(para)
msgid ""
"What happens if a view is named as the target relation for an "
"<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</"
"command>? Doing the substitutions described above would give a query tree in "
"which the result relation points at a subquery range-table entry, which will "
"not work. There are several ways in which <productname>PostgreSQL</"
"productname> can support the appearance of updating a view, however."
msgstr ""
"Но что произойдёт, если записать имя представления в качестве целевого "
"отношения команды <command>INSERT</command>, <command>UPDATE</command> или "
"<command>DELETE</command>? Если проделать подстановки, описанные выше, будет "
"получено дерево запроса, в котором результирующее отношение указывает на "
"элемент-подзапрос, что не будет работать. Однако <productname>PostgreSQL</"
"productname> даёт ряд возможностей, чтобы сделать представления изменяемыми."

#: rules.xml:819(para)
msgid ""
"If the subquery selects from a single base relation and is simple enough, "
"the rewriter can automatically replace the subquery with the underlying base "
"relation so that the <command>INSERT</command>, <command>UPDATE</command>, "
"or <command>DELETE</command> is applied to the base relation in the "
"appropriate way. Views that are <quote>simple enough</quote> for this are "
"called <firstterm>automatically updatable</firstterm>. For detailed "
"information on the kinds of view that can be automatically updated, see "
"<xref linkend=\"sql-createview\"/>."
msgstr ""
"Если подзапрос выбирает данные из одного базового отношения и он достаточно "
"прост, механизм перезаписи может автоматически заменить его нижележащим "
"базовым отношением, чтобы команды <command>INSERT</command>, "
"<command>UPDATE</command> или <command>DELETE</command> обращались к "
"базовому отношению. Представления, <quote>достаточно простые</quote> для "
"этого, называются <firstterm>автоматически изменяемыми</firstterm>. "
"Подробнее виды представлений, которые могут изменяться автоматически, "
"описаны в <xref remap=\"6\" linkend=\"sql-createview\"/>."

#: rules.xml:830(para)
msgid ""
"Alternatively, the operation may be handled by a user-provided "
"<literal>INSTEAD OF</literal> trigger on the view. Rewriting works slightly "
"differently in this case. For <command>INSERT</command>, the rewriter does "
"nothing at all with the view, leaving it as the result relation for the "
"query. For <command>UPDATE</command> and <command>DELETE</command>, it's "
"still necessary to expand the view query to produce the <quote>old</quote> "
"rows that the command will attempt to update or delete. So the view is "
"expanded as normal, but another unexpanded range-table entry is added to the "
"query to represent the view in its capacity as the result relation."
msgstr ""
"Эту задачу также можно решить, создав триггер <literal>INSTEAD OF</literal> "
"для представления. В этом случае перезапись будет работать немного по-"
"другому. Для <command>INSERT</command> механизм перезаписи не делает с "
"представлением ничего, оставляя его результирующим отношением запроса. Для "
"<command>UPDATE</command> и <command>DELETE</command> ему по-прежнему "
"придётся разворачивать запрос представления, чтобы получить <quote>старые</"
"quote> строки, которые эта команда попытается изменить или удалить. Поэтому "
"представление разворачивается как обычно, но в запрос добавляется ещё один "
"элемент списка отношений, указывающий на представление в роли "
"результирующего отношения."

#: rules.xml:844(para)
msgid ""
"The problem that now arises is how to identify the rows to be updated in the "
"view. Recall that when the result relation is a table, a special "
"<acronym>CTID</acronym> entry is added to the target list to identify the "
"physical locations of the rows to be updated. This does not work if the "
"result relation is a view, because a view does not have any <acronym>CTID</"
"acronym>, since its rows do not have actual physical locations. Instead, for "
"an <command>UPDATE</command> or <command>DELETE</command> operation, a "
"special <literal>wholerow</literal> entry is added to the target list, which "
"expands to include all columns from the view. The executor uses this value "
"to supply the <quote>old</quote> row to the <literal>INSTEAD OF</literal> "
"trigger. It is up to the trigger to work out what to update based on the old "
"and new row values."
msgstr ""
"При этом возникает проблема идентификации строк в представлении, подлежащих "
"изменению. Вспомните, что когда результирующее отношение является таблицей, "
"в выходной список добавляется специальное поле <acronym>CTID</acronym>, "
"указывающее на физическое расположение изменяемых строк. Но это не будет "
"работать, когда результирующее отношение — представление, так как в "
"представлениях нет <acronym>CTID</acronym>, потому что их строки физически "
"нигде не находятся. Вместо этого, для операций <command>UPDATE</command> или "
"<command>DELETE</command> в выходной список добавляется специальный элемент "
"<literal>wholerow</literal> (вся строка), который разворачивается в "
"содержимое всех столбцов представления. Используя этот элемент, исполнитель "
"передаёт строку <quote>old</quote> в триггер <literal>INSTEAD OF</literal>. "
"Какие именно строки должны изменяться фактически, будет решать сам триггер, "
"исходя из полученных значений старых и новых строк."

#: rules.xml:860(para)
msgid ""
"Another possibility is for the user to define <literal>INSTEAD</literal> "
"rules that specify substitute actions for <command>INSERT</command>, "
"<command>UPDATE</command>, and <command>DELETE</command> commands on a view. "
"These rules will rewrite the command, typically into a command that updates "
"one or more tables, rather than views. That is the topic of <xref linkend="
"\"rules-update\"/>."
msgstr ""
"Кроме того, пользователь может определить правила <literal>INSTEAD</"
"literal>, в которых задать действия замены для команд <command>INSERT</"
"command>, <command>UPDATE</command> и <command>DELETE</command> с "
"представлением. Эти правила обычно преобразуют команду в другую команду, "
"изменяющую одну или несколько таблиц, а не представление. Эта тема "
"освещается в <xref remap=\"6\" linkend=\"rules-update\"/>."

#: rules.xml:869(para)
msgid ""
"Note that rules are evaluated first, rewriting the original query before it "
"is planned and executed. Therefore, if a view has <literal>INSTEAD OF</"
"literal> triggers as well as rules on <command>INSERT</command>, "
"<command>UPDATE</command>, or <command>DELETE</command>, then the rules will "
"be evaluated first, and depending on the result, the triggers may not be "
"used at all."
msgstr ""
"Заметьте, что такие правила вычисляются сначала, перезаписывая исходный "
"запрос до того, как он будет планироваться и выполняться. Поэтому, если для "
"представления определены и триггеры <literal>INSTEAD OF</literal>, и правила "
"для <command>INSERT</command>, <command>UPDATE</command> или "
"<command>DELETE</command>, сначала вычисляются правила, а в зависимости от "
"их действия, триггеры могут не вызываться вовсе."

#: rules.xml:878(para)
msgid ""
"Automatic rewriting of an <command>INSERT</command>, <command>UPDATE</"
"command>, or <command>DELETE</command> query on a simple view is always "
"tried last. Therefore, if a view has rules or triggers, they will override "
"the default behavior of automatically updatable views."
msgstr ""
"Автоматическая перезапись запросов <command>INSERT</command>, "
"<command>UPDATE</command> или <command>DELETE</command> с простыми "
"представлениями всегда производится в последнюю очередь. Таким образом, если "
"у представления есть правила или триггеры, они переопределяют поведение "
"автоматически изменяемых представлений."

#: rules.xml:886(para)
msgid ""
"If there are no <literal>INSTEAD</literal> rules or <literal>INSTEAD OF</"
"literal> triggers for the view, and the rewriter cannot automatically "
"rewrite the query as an update on the underlying base relation, an error "
"will be thrown because the executor cannot update a view as such."
msgstr ""
"Если для представления не определены правила <literal>INSTEAD</literal> или "
"триггеры <literal>INSTEAD OF</literal>, и запрос не удаётся автоматически "
"переписать в виде обращения к нижележащему базовому отношению, возникает "
"ошибка, потому что исполнитель не сможет изменить такое представление."

#: rules.xml:898(title)
msgid "Materialized Views"
msgstr "Материализованные представления"

#: rules.xml:900(indexterm)
msgid "<primary>rule</primary> <secondary>and materialized views</secondary>"
msgstr ""
"<primary>правило</primary> <secondary>и материализованные представления</"
"secondary>"

#: rules.xml:905(indexterm)
msgid ""
"<primary>materialized view</primary> <secondary>implementation through "
"rules</secondary>"
msgstr ""
"<primary>материализованные представления</primary> <secondary>реализация "
"через правила</secondary>"

#: rules.xml:910(indexterm)
msgid "<primary>view</primary> <secondary>materialized</secondary>"
msgstr ""
"<primary>представление</primary> <secondary>материализованное</secondary>"

#: rules.xml:920(programlisting)
#, no-wrap
msgid "CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;"
msgstr "CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;"

#: rules.xml:926(programlisting)
#, no-wrap
msgid "CREATE TABLE mymatview AS SELECT * FROM mytab;"
msgstr "CREATE TABLE mymatview AS SELECT * FROM mytab;"

#: rules.xml:935(programlisting)
#, no-wrap
msgid "REFRESH MATERIALIZED VIEW mymatview;"
msgstr "REFRESH MATERIALIZED VIEW mymatview;"

#: rules.xml:915(para)
msgid ""
"Materialized views in <productname>PostgreSQL</productname> use the rule "
"system like views do, but persist the results in a table-like form. The main "
"differences between: <placeholder-1/> and: <placeholder-2/> are that the "
"materialized view cannot subsequently be directly updated and that the query "
"used to create the materialized view is stored in exactly the same way that "
"a view's query is stored, so that fresh data can be generated for the "
"materialized view with: <placeholder-3/> The information about a "
"materialized view in the <productname>PostgreSQL</productname> system "
"catalogs is exactly the same as it is for a table or view. So for the "
"parser, a materialized view is a relation, just like a table or a view. When "
"a materialized view is referenced in a query, the data is returned directly "
"from the materialized view, like from a table; the rule is only used for "
"populating the materialized view."
msgstr ""
"Материализованные представления в <productname>PostgreSQL</productname> "
"основаны на системе правил, как и представления, но их содержимое "
"сохраняется как таблица. Основное отличие между: <placeholder-1/> и этой "
"командой: <placeholder-2/> состоит в том, что материализованное "
"представление впоследствии нельзя будет изменить непосредственно, а запрос, "
"создающий материализованное представление, сохраняется точно так же, как "
"запрос представления, и получить актуальные данные в материализованном "
"представлении можно так: <placeholder-3/> Информация о материализованном "
"представлении в системных каталогах <productname>PostgreSQL</productname> "
"ничем не отличается от информации о таблице или представлении. Поэтому для "
"анализатора запроса материализованное представление является просто "
"отношением, как таблица или представление. Когда запрос обращается к "
"материализованному представлению, данные возвращаются непосредственно из "
"него, как из таблицы; правило применяется, только чтобы его наполнить."

#: rules.xml:954(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE invoice (\n"
"    invoice_no    integer        PRIMARY KEY,\n"
"    seller_no     integer,       -- ID of salesperson\n"
"    invoice_date  date,          -- date of sale\n"
"    invoice_amt   numeric(13,2)  -- amount of sale\n"
");"
msgstr ""
"CREATE TABLE invoice (\n"
"    invoice_no    integer        PRIMARY KEY,\n"
"    seller_no     integer,       -- идентификатор продавца\n"
"    invoice_date  date,          -- дата продажи\n"
"    invoice_amt   numeric(13,2)  -- сумма продажи\n"
");"

#: rules.xml:967(programlisting)
#, no-wrap
msgid ""
"CREATE MATERIALIZED VIEW sales_summary AS\n"
"  SELECT\n"
"      seller_no,\n"
"      invoice_date,\n"
"      sum(invoice_amt)::numeric(13,2) as sales_amt\n"
"    FROM invoice\n"
"    WHERE invoice_date &lt; CURRENT_DATE\n"
"    GROUP BY\n"
"      seller_no,\n"
"      invoice_date\n"
"    ORDER BY\n"
"      seller_no,\n"
"      invoice_date;\n"
"\n"
"CREATE UNIQUE INDEX sales_summary_seller\n"
"  ON sales_summary (seller_no, invoice_date);"
msgstr ""
"CREATE MATERIALIZED VIEW sales_summary AS\n"
"  SELECT\n"
"      seller_no,\n"
"      invoice_date,\n"
"      sum(invoice_amt)::numeric(13,2) as sales_amt\n"
"    FROM invoice\n"
"    WHERE invoice_date &lt; CURRENT_DATE\n"
"    GROUP BY\n"
"      seller_no,\n"
"      invoice_date\n"
"    ORDER BY\n"
"      seller_no,\n"
"      invoice_date;\n"
"\n"
"CREATE UNIQUE INDEX sales_summary_seller\n"
"  ON sales_summary (seller_no, invoice_date);"

#: rules.xml:990(programlisting)
#, no-wrap
msgid "REFRESH MATERIALIZED VIEW sales_summary;"
msgstr "REFRESH MATERIALIZED VIEW sales_summary;"

#: rules.xml:948(para)
msgid ""
"While access to the data stored in a materialized view is often much faster "
"than accessing the underlying tables directly or through a view, the data is "
"not always current; yet sometimes current data is not needed. Consider a "
"table which records sales: <placeholder-1/> If people want to be able to "
"quickly graph historical sales data, they might want to summarize, and they "
"may not care about the incomplete data for the current date: <placeholder-2/"
"> This materialized view might be useful for displaying a graph in the "
"dashboard created for salespeople. A job could be scheduled to update the "
"statistics each night using this SQL statement: <placeholder-3/>"
msgstr ""
"Хотя обращение к данным в материализованном представлении часто выполняется "
"гораздо быстрее, чем обращение к нижележащим таблицам напрямую или через "
"представление, данные в нём не всегда актуальные (но иногда это вполне "
"приемлемо). Рассмотрим таблицу с данными продаж: <placeholder-1/> Если "
"пользователям нужно быстро обработать исторические данные, возможно их "
"интересуют только общие показатели, а полнота данных на текущий момент не "
"важна: <placeholder-2/> Это материализованное представление может быть "
"полезно для построения графика в информационной панели менеджеров по "
"продажам. Для ежесуточного обновления статистики можно запланировать задание "
"по расписанию, которое будет выполнять этот оператор: <placeholder-3/>"

#: rules.xml:995(para)
msgid ""
"Another use for a materialized view is to allow faster access to data "
"brought across from a remote system through a foreign data wrapper. A simple "
"example using <literal>file_fdw</literal> is below, with timings, but since "
"this is using cache on the local system the performance difference compared "
"to access to a remote system would usually be greater than shown here. "
"Notice we are also exploiting the ability to put an index on the "
"materialized view, whereas <literal>file_fdw</literal> does not support "
"indexes; this advantage might not apply for other sorts of foreign data "
"access."
msgstr ""
"Ещё одно применение материализованного представления — предоставить быстрый "
"доступ к данным, получаемым с удалённой системы через обёртку сторонних "
"данных. Ниже приведён простой пример с обёрткой <literal>file_fdw</literal>, "
"с замерами времени, но так как при этом использовался кеш локальной системы, "
"выигрыш в производительности при обращении к удалённой системе обычно будет "
"гораздо больше, чем показано здесь. Заметьте, что мы также использовали "
"возможность добавить индекс в материализованное представление, тогда как "
"<literal>file_fdw</literal> индексы не поддерживает; при других видах "
"доступа к сторонним данным такого преимущества может не быть."

#: rules.xml:1010(programlisting)
#, no-wrap
msgid ""
"CREATE EXTENSION file_fdw;\n"
"CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;\n"
"CREATE FOREIGN TABLE words (word text NOT NULL)\n"
"  SERVER local_file\n"
"  OPTIONS (filename '/usr/share/dict/words');\n"
"CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;\n"
"CREATE UNIQUE INDEX wrd_word ON wrd (word);\n"
"CREATE EXTENSION pg_trgm;\n"
"CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);\n"
"VACUUM ANALYZE wrd;"
msgstr ""
"CREATE EXTENSION file_fdw;\n"
"CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;\n"
"CREATE FOREIGN TABLE words (word text NOT NULL)\n"
"  SERVER local_file\n"
"  OPTIONS (filename '/usr/share/dict/words');\n"
"CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;\n"
"CREATE UNIQUE INDEX wrd_word ON wrd (word);\n"
"CREATE EXTENSION pg_trgm;\n"
"CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);\n"
"VACUUM ANALYZE wrd;"

#: rules.xml:1025(programlisting)
#, no-wrap
msgid ""
"SELECT count(*) FROM words WHERE word = 'caterpiler';\n"
"\n"
" count \n"
"-------\n"
"     0\n"
"(1 row)"
msgstr ""
"SELECT count(*) FROM words WHERE word = 'caterpiler';\n"
"\n"
" count \n"
"-------\n"
"     0\n"
"(1 row)"

#: rules.xml:1036(programlisting)
#, no-wrap
msgid ""
" Aggregate  (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181 rows=1 loops=1)\n"
"   -&gt;  Foreign Scan on words  (cost=0.00..21761.41 rows=1032 width=0) (actual time=188.177..188.177 rows=0 loops=1)\n"
"         Filter: (word = 'caterpiler'::text)\n"
"         Rows Removed by Filter: 479829\n"
"         Foreign File: /usr/share/dict/words\n"
"         Foreign File Size: 4953699\n"
" Planning time: 0.118 ms\n"
" Execution time: 188.273 ms"
msgstr ""
" Aggregate  (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181 rows=1 loops=1)\n"
"   -&gt;  Foreign Scan on words  (cost=0.00..21761.41 rows=1032 width=0) (actual time=188.177..188.177 rows=0 loops=1)\n"
"         Filter: (word = 'caterpiler'::text)\n"
"         Rows Removed by Filter: 479829\n"
"         Foreign File: /usr/share/dict/words\n"
"         Foreign File Size: 4953699\n"
" Planning time: 0.118 ms\n"
" Execution time: 188.273 ms"

#: rules.xml:1049(programlisting)
#, no-wrap
msgid ""
" Aggregate  (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)\n"
"   -&gt;  Index Only Scan using wrd_word on wrd  (cost=0.42..4.44 rows=1 width=0) (actual time=0.039..0.039 rows=0 loops=1)\n"
"         Index Cond: (word = 'caterpiler'::text)\n"
"         Heap Fetches: 0\n"
" Planning time: 0.164 ms\n"
" Execution time: 0.117 ms"
msgstr ""
" Aggregate  (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)\n"
"   -&gt;  Index Only Scan using wrd_word on wrd  (cost=0.42..4.44 rows=1 width=0) (actual time=0.039..0.039 rows=0 loops=1)\n"
"         Index Cond: (word = 'caterpiler'::text)\n"
"         Heap Fetches: 0\n"
" Planning time: 0.164 ms\n"
" Execution time: 0.117 ms"

#: rules.xml:1061(programlisting)
#, no-wrap
msgid ""
"SELECT word FROM words ORDER BY word &lt;-&gt; 'caterpiler' LIMIT 10;\n"
"\n"
"     word     \n"
"---------------\n"
" cater\n"
" caterpillar\n"
" Caterpillar\n"
" caterpillars\n"
" caterpillar's\n"
" Caterpillar's\n"
" caterer\n"
" caterer's\n"
" caters\n"
" catered\n"
"(10 rows)"
msgstr ""
"SELECT word FROM words ORDER BY word &lt;-&gt; 'caterpiler' LIMIT 10;\n"
"\n"
"     word     \n"
"---------------\n"
" cater\n"
" caterpillar\n"
" Caterpillar\n"
" caterpillars\n"
" caterpillar's\n"
" Caterpillar's\n"
" caterer\n"
" caterer's\n"
" caters\n"
" catered\n"
"(10 rows)"

#: rules.xml:1079(programlisting)
#, no-wrap
msgid ""
" Limit  (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594 rows=10 loops=1)\n"
"   -&gt;  Sort  (cost=11583.61..11804.76 rows=88459 width=32) (actual time=1431.589..1431.591 rows=10 loops=1)\n"
"         Sort Key: ((word &lt;-&gt; 'caterpiler'::text))\n"
"         Sort Method: top-N heapsort  Memory: 25kB\n"
"         -&gt;  Foreign Scan on words  (cost=0.00..9672.05 rows=88459 width=32) (actual time=0.057..1286.455 rows=479829 loops=1)\n"
"               Foreign File: /usr/share/dict/words\n"
"               Foreign File Size: 4953699\n"
" Planning time: 0.128 ms\n"
" Execution time: 1431.679 ms"
msgstr ""
" Limit  (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594 rows=10 loops=1)\n"
"   -&gt;  Sort  (cost=11583.61..11804.76 rows=88459 width=32) (actual time=1431.589..1431.591 rows=10 loops=1)\n"
"         Sort Key: ((word &lt;-&gt; 'caterpiler'::text))\n"
"         Sort Method: top-N heapsort  Memory: 25kB\n"
"         -&gt;  Foreign Scan on words  (cost=0.00..9672.05 rows=88459 width=32) (actual time=0.057..1286.455 rows=479829 loops=1)\n"
"               Foreign File: /usr/share/dict/words\n"
"               Foreign File Size: 4953699\n"
" Planning time: 0.128 ms\n"
" Execution time: 1431.679 ms"

#: rules.xml:1093(programlisting)
#, no-wrap
msgid ""
" Limit  (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10 loops=1)\n"
"   -&gt;  Index Scan using wrd_trgm on wrd  (cost=0.29..37020.87 rows=479829 width=10) (actual time=187.219..188.252 rows=10 loops=1)\n"
"         Order By: (word &lt;-&gt; 'caterpiler'::text)\n"
" Planning time: 0.196 ms\n"
" Execution time: 198.640 ms"
msgstr ""
" Limit  (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10 loops=1)\n"
"   -&gt;  Index Scan using wrd_trgm on wrd  (cost=0.29..37020.87 rows=479829 width=10) (actual time=187.219..188.252 rows=10 loops=1)\n"
"         Order By: (word &lt;-&gt; 'caterpiler'::text)\n"
" Planning time: 0.196 ms\n"
" Execution time: 198.640 ms"

#: rules.xml:1007(para)
msgid ""
"Setup: <placeholder-1/> Now let's spell-check a word. Using "
"<literal>file_fdw</literal> directly: <placeholder-2/> With <command>EXPLAIN "
"ANALYZE</command>, we see: <placeholder-3/> If the materialized view is used "
"instead, the query is much faster: <placeholder-4/> Either way, the word is "
"spelled wrong, so let's look for what we might have wanted. Again using "
"<literal>file_fdw</literal>: <placeholder-5/> <placeholder-6/> Using the "
"materialized view: <placeholder-7/> If you can tolerate periodic update of "
"the remote data to the local database, the performance benefit can be "
"substantial."
msgstr ""
"Подготовка: <placeholder-1/> Теперь давайте проверим написание слова. "
"Сначала непосредственно через обёртку <literal>file_fdw</literal>: "
"<placeholder-2/> Выполнив <command>EXPLAIN ANALYZE</command>, мы получаем: "
"<placeholder-3/> Если же теперь обратиться к материализованному "
"представлению, запрос выполнится гораздо быстрее: <placeholder-4/> В любом "
"случае слово записано неправильно, поэтому давайте попробуем найти то, что "
"имелось в виду. Сначала опять через <literal>file_fdw</literal>: "
"<placeholder-5/> <placeholder-6/> Затем через материализованное "
"представление: <placeholder-7/> Если периодическое обновление данных из "
"другого источника в локальной базе данных вас устраивает, этот подход может "
"дать значительный выигрыш в скорости."

#: rules.xml:1108(title)
msgid ""
"Rules on <command>INSERT</command>, <command>UPDATE</command>, and "
"<command>DELETE</command>"
msgstr ""
"Правила для <command>INSERT</command>, <command>UPDATE</command> и "
"<command>DELETE</command>"

#: rules.xml:1110(indexterm)
msgid ""
"<primary>rule</primary> <secondary sortas=\"INSERT\">for INSERT</secondary>"
msgstr ""
"<primary>правило</primary> <secondary sortas=\"INSERT\">для INSERT</"
"secondary>"

#: rules.xml:1115(indexterm)
msgid ""
"<primary>rule</primary> <secondary sortas=\"UPDATE\">for UPDATE</secondary>"
msgstr ""
"<primary>правило</primary> <secondary sortas=\"UPDATE\">для UPDATE</"
"secondary>"

#: rules.xml:1120(indexterm)
msgid ""
"<primary>rule</primary> <secondary sortas=\"DELETE\">for DELETE</secondary>"
msgstr ""
"<primary>правило</primary> <secondary sortas=\"DELETE\">для DELETE</"
"secondary>"

#: rules.xml:1133(para)
msgid "They are allowed to have no action."
msgstr "Они могут не определять действия."

#: rules.xml:1139(para)
msgid "They can have multiple actions."
msgstr "Они могут определять несколько действий."

#: rules.xml:1145(para)
msgid ""
"They can be <literal>INSTEAD</literal> or <literal>ALSO</literal> (the "
"default)."
msgstr ""
"Они могут действовать в режиме <literal>INSTEAD</literal> или <literal>ALSO</"
"literal> (по умолчанию)."

#: rules.xml:1151(para)
msgid ""
"The pseudorelations <literal>NEW</literal> and <literal>OLD</literal> become "
"useful."
msgstr ""
"Становятся полезными псевдоотношения <literal>NEW</literal> и <literal>OLD</"
"literal>."

#: rules.xml:1157(para)
msgid "They can have rule qualifications."
msgstr "Они могут иметь условия применения."

#: rules.xml:1125(para)
msgid ""
"Rules that are defined on <command>INSERT</command>, <command>UPDATE</"
"command>, and <command>DELETE</command> are significantly different from the "
"view rules described in the previous section. First, their <command>CREATE "
"RULE</command> command allows more: <placeholder-1/> Second, they don't "
"modify the query tree in place. Instead they create zero or more new query "
"trees and can throw away the original one."
msgstr ""
"Правила, определяемые для команд <command>INSERT</command>, <command>UPDATE</"
"command> и <command>DELETE</command>, значительно отличаются от правил "
"представлений, описанных в предыдущем разделе. Во-первых, команда "
"<command>CREATE RULE</command> позволяет создавать правила со следующими "
"особенностями: <placeholder-1/> Во-вторых, они не модифицируют само исходное "
"дерево запроса. Вместо этого они создают несколько новых деревьев запросов и "
"могут заменить исходное."

#: rules.xml:1169(para)
msgid ""
"In many cases, tasks that could be performed by rules on <command>INSERT</"
"command>/<command>UPDATE</command>/<command>DELETE</command> are better done "
"with triggers. Triggers are notationally a bit more complicated, but their "
"semantics are much simpler to understand. Rules tend to have surprising "
"results when the original query contains volatile functions: volatile "
"functions may get executed more times than expected in the process of "
"carrying out the rules."
msgstr ""
"Во многих случаях для задач, выполнимых с использованием правил для "
"<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</"
"command>, лучше применять триггеры. Оформляются триггеры чуть сложнее, но "
"понять их смысл гораздо проще. К тому же с правилами могут быть получены "
"неожиданные результаты, когда исходный запрос содержит изменчивые функции: в "
"процессе исполнения правил эти функции могут вызываться большее число раз, "
"чем ожидается."

#: rules.xml:1179(para)
msgid ""
"Also, there are some cases that are not supported by these types of rules at "
"all, notably including <literal>WITH</literal> clauses in the original query "
"and multiple-assignment sub-<literal>SELECT</literal>s in the <literal>SET</"
"literal> list of <command>UPDATE</command> queries. This is because copying "
"these constructs into a rule query would result in multiple evaluations of "
"the sub-query, contrary to the express intent of the query's author."
msgstr ""
"Кроме того, в некоторых случаях эти типы правил вообще нельзя применять; а "
"именно, с предложениями <literal>WITH</literal> в исходном запросе и с "
"вложенными подзапросами <literal>SELECT</literal> с множественным "
"присваиванием в списке <literal>SET</literal> запросов <command>UPDATE</"
"command>. Это объясняется тем, что копирование этих конструкций в запрос "
"правила привело бы к многократному вычислению вложенного запроса, что пошло "
"бы в разрез с выраженными намерениями автора запроса."

#: rules.xml:1190(title)
msgid "How Update Rules Work"
msgstr "Как работают правила для изменения"

#: rules.xml:1195(programlisting)
#, no-wrap
msgid ""
"CREATE [ OR REPLACE ] RULE <replaceable class=\"parameter\">name</replaceable> AS ON <replaceable class=\"parameter\">event</replaceable>\n"
"    TO <replaceable class=\"parameter\">table</replaceable> [ WHERE <replaceable class=\"parameter\">condition</replaceable> ]\n"
"    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable class=\"parameter\">command</replaceable> | ( <replaceable class=\"parameter\">command</replaceable> ; <replaceable class=\"parameter\">command</replaceable> ... ) }"
msgstr ""
"CREATE [ OR REPLACE ] RULE <replaceable class=\"parameter\">имя</replaceable> AS ON <replaceable class=\"parameter\">событие</replaceable>\n"
"    TO <replaceable class=\"parameter\">таблица</replaceable> [ WHERE <replaceable class=\"parameter\">условие</replaceable> ]\n"
"    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable class=\"parameter\">команда</replaceable> | ( <replaceable class=\"parameter\">команда</replaceable> ; <replaceable class=\"parameter\">команда</replaceable> ... ) }"

#: rules.xml:1192(para)
msgid ""
"Keep the syntax: <placeholder-1/> in mind. In the following, "
"<firstterm>update rules</firstterm> means rules that are defined on "
"<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</"
"command>."
msgstr ""
"Запомните синтаксис: <placeholder-1/> В дальнейшем, под <firstterm>правилами "
"для изменения</firstterm> подразумеваются правила, определяемые для команд "
"<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>."

#: rules.xml:1206(para)
msgid ""
"Update rules get applied by the rule system when the result relation and the "
"command type of a query tree are equal to the object and event given in the "
"<command>CREATE RULE</command> command. For update rules, the rule system "
"creates a list of query trees. Initially the query-tree list is empty. There "
"can be zero (<literal>NOTHING</literal> key word), one, or multiple actions. "
"To simplify, we will look at a rule with one action. This rule can have a "
"qualification or not and it can be <literal>INSTEAD</literal> or "
"<literal>ALSO</literal> (the default)."
msgstr ""
"Правила для изменения применяются системой правил, когда результирующее "
"отношение и тип команды в дереве запроса совпадает с объектом и событием, "
"заданным в команде <command>CREATE RULE</command>. Для такого правила "
"система правил создаёт список деревьев запросов. Изначально этот список "
"пуст. С правилом может быть связано ноль (ключевое слово <literal>NOTHING</"
"literal>), одно или несколько действий. Простоты ради мы рассмотрим правило "
"с одним действием. Правило может иметь, а может не иметь условия применения, "
"и действует в режиме <literal>INSTEAD</literal> или <literal>ALSO</literal> "
"(по умолчанию)."

#: rules.xml:1218(para)
msgid ""
"What is a rule qualification? It is a restriction that tells when the "
"actions of the rule should be done and when not. This qualification can only "
"reference the pseudorelations <literal>NEW</literal> and/or <literal>OLD</"
"literal>, which basically represent the relation that was given as object "
"(but with a special meaning)."
msgstr ""
"Что такое условие применения правила? Это условие, которое говорит, когда "
"нужно, а когда не нужно применять действия правила. В этом условии можно "
"обращаться к псевдоотношениям <literal>NEW</literal> и/или <literal>OLD</"
"literal>, которые представляют целевое отношение (но с особым значением)."

#: rules.xml:1232(term)
msgid ""
"No qualification, with either <literal>ALSO</literal> or <literal>INSTEAD</"
"literal>"
msgstr ""
"Без условия применения в режиме <literal>ALSO</literal> или "
"<literal>INSTEAD</literal>"

#: rules.xml:1235(para)
msgid ""
"the query tree from the rule action with the original query tree's "
"qualification added"
msgstr ""
"дерево запроса из действия правила с добавленным условием исходного дерева"

#: rules.xml:1243(term)
msgid "Qualification given and <literal>ALSO</literal>"
msgstr "С условием применения в режиме <literal>ALSO</literal>"

#: rules.xml:1245(para)
msgid ""
"the query tree from the rule action with the rule qualification and the "
"original query tree's qualification added"
msgstr ""
"дерево запроса из действия правила с условием применения правила и условием, "
"добавленным из исходного дерева"

#: rules.xml:1254(term)
msgid "Qualification given and <literal>INSTEAD</literal>"
msgstr "С условием применения в режиме <literal>INSTEAD</literal>"

#: rules.xml:1256(para)
msgid ""
"the query tree from the rule action with the rule qualification and the "
"original query tree's qualification; and the original query tree with the "
"negated rule qualification added"
msgstr ""
"дерево запроса из действия правила с условием применения правила и условием "
"из исходного дерева; также добавляется исходное дерево запроса с условием, "
"обратным условию применения правила"

#: rules.xml:1226(para)
msgid ""
"So we have three cases that produce the following query trees for a one-"
"action rule. <placeholder-1/> Finally, if the rule is <literal>ALSO</"
"literal>, the unchanged original query tree is added to the list. Since only "
"qualified <literal>INSTEAD</literal> rules already add the original query "
"tree, we end up with either one or two output query trees for a rule with "
"one action."
msgstr ""
"Всего есть три варианта формирования деревьев запросов для правила с одним "
"действием. <placeholder-1/> Наконец, для правил <literal>ALSO</literal> в "
"список добавляется исходное дерево запроса без изменений. Так как исходное "
"дерево запроса также добавляют только правила <literal>INSTEAD</literal> с "
"условиями применения, в итоге для правила с одним действием мы можем "
"получить только одно или два дерева запросов."

#: rules.xml:1272(para)
msgid ""
"For <literal>ON INSERT</literal> rules, the original query (if not "
"suppressed by <literal>INSTEAD</literal>) is done before any actions added "
"by rules. This allows the actions to see the inserted row(s). But for "
"<literal>ON UPDATE</literal> and <literal>ON DELETE</literal> rules, the "
"original query is done after the actions added by rules. This ensures that "
"the actions can see the to-be-updated or to-be-deleted rows; otherwise, the "
"actions might do nothing because they find no rows matching their "
"qualifications."
msgstr ""
"Для правил <literal>ON INSERT</literal> исходный запрос (если он не "
"перекрывается режимом <literal>INSTEAD</literal>) выполняется перед "
"действиями, добавленными правилами. Поэтому эти действия могут видеть "
"вставленные строки. Но для правил <literal>ON UPDATE</literal> и <literal>ON "
"DELETE</literal> исходный запрос выполняется после действий, добавленных "
"правилами. При таком порядке эти действия будут видеть строки, подлежащие "
"изменению или удалению; иначе бы действия не работали, не найдя строк, "
"соответствующих их условиям применения (эти строки уже будут изменены или "
"удалены)."

#: rules.xml:1282(para)
msgid ""
"The query trees generated from rule actions are thrown into the rewrite "
"system again, and maybe more rules get applied resulting in more or less "
"query trees. So a rule's actions must have either a different command type "
"or a different result relation than the rule itself is on, otherwise this "
"recursive process will end up in an infinite loop. (Recursive expansion of a "
"rule will be detected and reported as an error.)"
msgstr ""
"Деревья запросов, полученные из действий правил, снова попадают в систему "
"перезаписи, где могут примениться дополнительные правила, добавляющие или "
"убирающие деревья запроса. Поэтому действия правила должны выполнять команды "
"другого типа или работать с другим результирующим отношением, иначе "
"возникнет бесконечная рекурсия. (Система выявляет подобное рекурсивное "
"разворачивание правил и выдаёт ошибку.)"

#: rules.xml:1293(para)
msgid ""
"The query trees found in the actions of the <structname>pg_rewrite</"
"structname> system catalog are only templates. Since they can reference the "
"range-table entries for <literal>NEW</literal> and <literal>OLD</literal>, "
"some substitutions have to be made before they can be used. For any "
"reference to <literal>NEW</literal>, the target list of the original query "
"is searched for a corresponding entry. If found, that entry's expression "
"replaces the reference. Otherwise, <literal>NEW</literal> means the same as "
"<literal>OLD</literal> (for an <command>UPDATE</command>) or is replaced by "
"a null value (for an <command>INSERT</command>). Any reference to "
"<literal>OLD</literal> is replaced by a reference to the range-table entry "
"that is the result relation."
msgstr ""
"Деревья запросов, заданные для действий в системном каталоге "
"<structname>pg_rewrite</structname>, представляют собой только шаблоны. Так "
"как они могут обращаться к элементам <literal>NEW</literal> и <literal>OLD</"
"literal> в списке отношений, их можно будет использовать только после "
"некоторых подстановок. В случае ссылки на <literal>NEW</literal> "
"соответствующий элемент ищется в целевом списке исходного запроса. Если он "
"найден, ссылка заменяется выражением этого элемента. В противном случае "
"<literal>NEW</literal> означает то же самое, что и <literal>OLD</literal> "
"(для команды <command>UPDATE</command>) или заменяется значением NULL (для "
"команды <command>INSERT</command>). Любые ссылки на <literal>OLD</literal> "
"заменяются ссылкой на элемент результирующего отношения в списке отношений."

#: rules.xml:1307(para)
msgid ""
"After the system is done applying update rules, it applies view rules to the "
"produced query tree(s). Views cannot insert new update actions so there is "
"no need to apply update rules to the output of view rewriting."
msgstr ""
"После того как система применит все правила для изменения, она применяет "
"правила представления к полученному дереву (или деревьям) запроса. "
"Представления не могут добавлять новые действия для изменения, поэтому нет "
"необходимости применять такие правила к результату перезаписи представления."

#: rules.xml:1314(title)
msgid "A First Rule Step by Step"
msgstr "Пошаговый разбор первого правила"

#: rules.xml:1323(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE shoelace_log (\n"
"    sl_name    text,          -- shoelace changed\n"
"    sl_avail   integer,       -- new available value\n"
"    log_who    text,          -- who did it\n"
"    log_when   timestamp      -- when\n"
");\n"
"\n"
"CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data\n"
"    WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail\n"
"    DO INSERT INTO shoelace_log VALUES (\n"
"                                    NEW.sl_name,\n"
"                                    NEW.sl_avail,\n"
"                                    current_user,\n"
"                                    current_timestamp\n"
"                                );"
msgstr ""
"CREATE TABLE shoelace_log (\n"
"    sl_name    text,          -- шнурки, количество которых изменилось\n"
"    sl_avail   integer,       -- новое количество\n"
"    log_who    text,          -- кто изменил\n"
"    log_when   timestamp      -- когда\n"
");\n"
"\n"
"CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data\n"
"    WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail\n"
"    DO INSERT INTO shoelace_log VALUES (\n"
"                                    NEW.sl_name,\n"
"                                    NEW.sl_avail,\n"
"                                    current_user,\n"
"                                    current_timestamp\n"
"                                );"

#: rules.xml:1316(para)
msgid ""
"Say we want to trace changes to the <literal>sl_avail</literal> column in "
"the <literal>shoelace_data</literal> relation. So we set up a log table and "
"a rule that conditionally writes a log entry when an <command>UPDATE</"
"command> is performed on <literal>shoelace_data</literal>. <placeholder-1/>"
msgstr ""
"Предположим, что нам нужно отслеживать изменения в столбце "
"<literal>sl_avail</literal> таблицы <literal>shoelace_data</literal>. Мы "
"можем создать таблицу для ведения журнала и правило, которое будет добавлять "
"в неё записи по условию, когда для <literal>shoelace_data</literal> "
"выполняется <command>UPDATE</command>. <placeholder-1/>"

#: rules.xml:1345(programlisting)
#, no-wrap
msgid "UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';"
msgstr "UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';"

#: rules.xml:1351(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM shoelace_log;\n"
"\n"
" sl_name | sl_avail | log_who | log_when                        \n"
"---------+----------+---------+----------------------------------\n"
" sl7     |        6 | Al      | Tue Oct 20 16:14:45 1998 MET DST\n"
"(1 row)"
msgstr ""
"SELECT * FROM shoelace_log;\n"
"\n"
" sl_name | sl_avail | log_who | log_when                        \n"
"---------+----------+---------+----------------------------------\n"
" sl7     |        6 | Al      | Tue Oct 20 16:14:45 1998 MET DST\n"
"(1 row)"

#: rules.xml:1342(para)
msgid ""
"Now someone does: <placeholder-1/> and we look at the log table: "
"<placeholder-2/>"
msgstr ""
"Теперь, если кто-то выполнит: <placeholder-1/> мы увидим в таблице журнала: "
"<placeholder-2/>"

#: rules.xml:1365(programlisting)
#, no-wrap
msgid ""
"UPDATE shoelace_data SET sl_avail = 6\n"
"  FROM shoelace_data shoelace_data\n"
" WHERE shoelace_data.sl_name = 'sl7';"
msgstr ""
"UPDATE shoelace_data SET sl_avail = 6\n"
"  FROM shoelace_data shoelace_data\n"
" WHERE shoelace_data.sl_name = 'sl7';"

#: rules.xml:1374(programlisting)
#, no-wrap
msgid "NEW.sl_avail &lt;&gt; OLD.sl_avail"
msgstr "NEW.sl_avail &lt;&gt; OLD.sl_avail"

#: rules.xml:1380(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old;"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old;"

#: rules.xml:1361(para)
msgid ""
"That's what we expected. What happened in the background is the following. "
"The parser created the query tree: <placeholder-1/> There is a rule "
"<literal>log_shoelace</literal> that is <literal>ON UPDATE</literal> with "
"the rule qualification expression: <placeholder-2/> and the action: "
"<placeholder-3/> (This looks a little strange since you cannot normally "
"write <literal>INSERT ... VALUES ... FROM</literal>. The <literal>FROM</"
"literal> clause here is just to indicate that there are range-table entries "
"in the query tree for <literal>new</literal> and <literal>old</literal>. "
"These are needed so that they can be referenced by variables in the "
"<command>INSERT</command> command's query tree.)"
msgstr ""
"Именно это нам и нужно. При этом внутри происходит следующее. Анализатор "
"запроса создаёт дерево: <placeholder-1/> В системном каталоге находится "
"правило <literal>log_shoelace</literal>, настроенное на изменение "
"(<literal>ON UPDATE</literal>) с условием применения: <placeholder-2/> и "
"действием: <placeholder-3/> (Это выглядит несколько странно, так как обычно "
"нельзя написать <literal>INSERT ... VALUES ... FROM</literal>. Предложение "
"<literal>FROM</literal> здесь добавлено, просто чтобы показать, что в дереве "
"запроса для ссылок <literal>new</literal> и <literal>old</literal> есть "
"элементы в списке отношений. Они необходимы для того, чтобы к ним могли "
"обращаться переменные в дереве запроса команды <command>INSERT</command>.)"

#: rules.xml:1401(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       <emphasis>shoelace_data shoelace_data</emphasis>;"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       <emphasis>shoelace_data shoelace_data</emphasis>;"

#: rules.xml:1412(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" <emphasis>WHERE new.sl_avail &lt;&gt; old.sl_avail</emphasis>;"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" <emphasis>WHERE new.sl_avail &lt;&gt; old.sl_avail</emphasis>;"

#: rules.xml:1395(para)
msgid ""
"The rule is a qualified <literal>ALSO</literal> rule, so the rule system has "
"to return two query trees: the modified rule action and the original query "
"tree. In step 1, the range table of the original query is incorporated into "
"the rule's action query tree. This results in: <placeholder-1/> In step 2, "
"the rule qualification is added to it, so the result set is restricted to "
"rows where <literal>sl_avail</literal> changes: <placeholder-2/> (This looks "
"even stranger, since <literal>INSERT ... VALUES</literal> doesn't have a "
"<literal>WHERE</literal> clause either, but the planner and executor will "
"have no difficulty with it. They need to support this same functionality "
"anyway for <literal>INSERT ... SELECT</literal>.)"
msgstr ""
"Так как это правило <literal>ALSO</literal> с условием применения, система "
"правил должна выдать два дерева запросов: изменённое действие правила и "
"исходное дерево запроса. На первом шаге список отношений исходного запроса "
"вставляется в дерево действия правила и получается: <placeholder-1/> На "
"втором шаге в это дерево добавляется условие применения правила, так что "
"результирующий набор ограничивается строками, в которых меняется "
"<literal>sl_avail</literal>: <placeholder-2/> (Это выглядит ещё более "
"странно, ведь в <literal>INSERT ... VALUES</literal> не записывается и "
"предложение <literal>WHERE</literal>, но планировщик и исполнитель не "
"испытывают затруднений с этим. Они всё равно должны поддерживать эту "
"функциональность для <literal>INSERT ... SELECT</literal>.)"

#: rules.xml:1432(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" WHERE new.sl_avail &lt;&gt; old.sl_avail\n"
"   <emphasis>AND shoelace_data.sl_name = 'sl7'</emphasis>;"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       new.sl_name, new.sl_avail,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" WHERE new.sl_avail &lt;&gt; old.sl_avail\n"
"   <emphasis>AND shoelace_data.sl_name = 'sl7'</emphasis>;"

#: rules.xml:1427(para)
msgid ""
"In step 3, the original query tree's qualification is added, restricting the "
"result set further to only the rows that would have been touched by the "
"original query: <placeholder-1/>"
msgstr ""
"На третьем шаге добавляется условие исходного дерева, что ещё больше "
"ограничивает результирующий набор, оставляя в нём только строки, которые "
"затронул бы исходный запрос: <placeholder-1/>"

#: rules.xml:1448(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       <emphasis>shoelace_data.sl_name</emphasis>, <emphasis>6</emphasis>,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" WHERE <emphasis>6</emphasis> &lt;&gt; old.sl_avail\n"
"   AND shoelace_data.sl_name = 'sl7';"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       <emphasis>shoelace_data.sl_name</emphasis>, <emphasis>6</emphasis>,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" WHERE <emphasis>6</emphasis> &lt;&gt; old.sl_avail\n"
"   AND shoelace_data.sl_name = 'sl7';"

#: rules.xml:1443(para)
msgid ""
"Step 4 replaces references to <literal>NEW</literal> by the target list "
"entries from the original query tree or by the matching variable references "
"from the result relation: <placeholder-1/>"
msgstr ""
"На четвёртом шаге ссылки на <literal>NEW</literal> заменяются элементами "
"выходного списка из исходного дерева запроса или переменными из "
"результирующего отношения: <placeholder-1/>"

#: rules.xml:1463(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       shoelace_data.sl_name, 6,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" WHERE 6 &lt;&gt; <emphasis>shoelace_data.sl_avail</emphasis>\n"
"   AND shoelace_data.sl_name = 'sl7';"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       shoelace_data.sl_name, 6,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data new, shoelace_data old,\n"
"       shoelace_data shoelace_data\n"
" WHERE 6 &lt;&gt; <emphasis>shoelace_data.sl_avail</emphasis>\n"
"   AND shoelace_data.sl_name = 'sl7';"

#: rules.xml:1460(para)
msgid ""
"Step 5 changes <literal>OLD</literal> references into result relation "
"references: <placeholder-1/>"
msgstr ""
"На последнем, пятом шаге ссылки на <literal>OLD</literal> заменяются "
"ссылками на результирующее отношение: <placeholder-1/>"

#: rules.xml:1479(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       shoelace_data.sl_name, 6,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data\n"
" WHERE 6 &lt;&gt; shoelace_data.sl_avail\n"
"   AND shoelace_data.sl_name = 'sl7';\n"
"\n"
"UPDATE shoelace_data SET sl_avail = 6\n"
" WHERE sl_name = 'sl7';"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       shoelace_data.sl_name, 6,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data\n"
" WHERE 6 &lt;&gt; shoelace_data.sl_avail\n"
"   AND shoelace_data.sl_name = 'sl7';\n"
"\n"
"UPDATE shoelace_data SET sl_avail = 6\n"
" WHERE sl_name = 'sl7';"

#: rules.xml:1474(para)
msgid ""
"That's it. Since the rule is <literal>ALSO</literal>, we also output the "
"original query tree. In short, the output from the rule system is a list of "
"two query trees that correspond to these statements: <placeholder-1/> These "
"are executed in this order, and that is exactly what the rule was meant to "
"do."
msgstr ""
"Вот и всё. Так как правило действует в режиме <literal>ALSO</literal>, мы "
"также выводим исходное дерево запроса. Таким образом, система правил выдаёт "
"список с двумя деревьями запросов, соответствующими этим операторам: "
"<placeholder-1/> Они выполняются в показанном порядке и именно это должно "
"делать данное правило."

#: rules.xml:1499(programlisting)
#, no-wrap
msgid ""
"UPDATE shoelace_data SET sl_color = 'green'\n"
" WHERE sl_name = 'sl7';"
msgstr ""
"UPDATE shoelace_data SET sl_color = 'green'\n"
" WHERE sl_name = 'sl7';"

#: rules.xml:1510(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log VALUES (\n"
"       shoelace_data.sl_name, <emphasis>shoelace_data.sl_avail</emphasis>,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data\n"
" WHERE <emphasis>shoelace_data.sl_avail</emphasis> &lt;&gt; shoelace_data.sl_avail\n"
"   AND shoelace_data.sl_name = 'sl7';"
msgstr ""
"INSERT INTO shoelace_log VALUES (\n"
"       shoelace_data.sl_name, <emphasis>shoelace_data.sl_avail</emphasis>,\n"
"       current_user, current_timestamp )\n"
"  FROM shoelace_data\n"
" WHERE <emphasis>shoelace_data.sl_avail</emphasis> &lt;&gt; shoelace_data.sl_avail\n"
"   AND shoelace_data.sl_name = 'sl7';"

#: rules.xml:1495(para)
msgid ""
"The substitutions and the added qualifications ensure that, if the original "
"query would be, say: <placeholder-1/> no log entry would get written. In "
"that case, the original query tree does not contain a target list entry for "
"<literal>sl_avail</literal>, so <literal>NEW.sl_avail</literal> will get "
"replaced by <literal>shoelace_data.sl_avail</literal>. Thus, the extra "
"command generated by the rule is: <placeholder-2/> and that qualification "
"will never be true."
msgstr ""
"Благодаря заменам и добавленным условиям в журнал не добавится запись, "
"например, при таком исходном запросе: <placeholder-1/> В этом случае "
"исходное дерево запроса не содержит элемент выходного списка для "
"<literal>sl_avail</literal>, так что <literal>NEW.sl_avail</literal> будет "
"заменено переменной <literal>shoelace_data.sl_avail</literal>. Таким "
"образом, дополнительная команда, созданная правилом, будет такой: "
"<placeholder-2/> Это условие применения не будет выполняться никогда."

#: rules.xml:1526(programlisting)
#, no-wrap
msgid ""
"UPDATE shoelace_data SET sl_avail = 0\n"
" WHERE sl_color = 'black';"
msgstr ""
"UPDATE shoelace_data SET sl_avail = 0\n"
" WHERE sl_color = 'black';"

#: rules.xml:1536(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log\n"
"SELECT shoelace_data.sl_name, 0,\n"
"       current_user, current_timestamp\n"
"  FROM shoelace_data\n"
" WHERE 0 &lt;&gt; shoelace_data.sl_avail\n"
"   AND <emphasis>shoelace_data.sl_color = 'black'</emphasis>;"
msgstr ""
"INSERT INTO shoelace_log\n"
"SELECT shoelace_data.sl_name, 0,\n"
"       current_user, current_timestamp\n"
"  FROM shoelace_data\n"
" WHERE 0 &lt;&gt; shoelace_data.sl_avail\n"
"   AND <emphasis>shoelace_data.sl_color = 'black'</emphasis>;"

#: rules.xml:1522(para)
msgid ""
"It will also work if the original query modifies multiple rows. So if "
"someone issued the command: <placeholder-1/> four rows in fact get updated "
"(<literal>sl1</literal>, <literal>sl2</literal>, <literal>sl3</literal>, and "
"<literal>sl4</literal>). But <literal>sl3</literal> already has "
"<literal>sl_avail = 0</literal>. In this case, the original query trees "
"qualification is different and that results in the extra query tree: "
"<placeholder-2/> being generated by the rule. This query tree will surely "
"insert three new log entries. And that's absolutely correct."
msgstr ""
"Это также будет работать, если исходный запрос изменяет несколько строк. "
"Так, если кто-то выполнит команду: <placeholder-1/> фактически будут "
"изменены четыре строки (<literal>sl1</literal>, <literal>sl2</literal>, "
"<literal>sl3</literal> и <literal>sl4</literal>). Но для <literal>sl3</"
"literal> значение <literal>sl_avail = 0</literal>. В этом случае условие "
"исходного дерева другое, так что это правило выдаёт такое дополнительное "
"дерево запроса: <placeholder-2/>. С таким деревом запроса в журнал "
"определённо будут добавлены три записи. И это абсолютно правильно."

#: rules.xml:1549(para)
msgid ""
"Here we can see why it is important that the original query tree is executed "
"last. If the <command>UPDATE</command> had been executed first, all the rows "
"would have already been set to zero, so the logging <command>INSERT</"
"command> would not find any row where <literal>0 &lt;&gt; shoelace_data."
"sl_avail</literal>."
msgstr ""
"Здесь мы видим, почему важно, чтобы исходное дерево запроса выполнялось в "
"конце. Если бы оператор <command>UPDATE</command> выполнился сначала, все "
"строки уже получили бы нулевые значения, так что записывающий в журнал "
"<command>INSERT</command> не нашёл бы строк, в которых <literal>0 &lt;&gt; "
"shoelace_data.sl_avail</literal>."

#: rules.xml:1561(title)
msgid "Cooperation with Views"
msgstr "Сочетание с представлениями"

#: rules.xml:1563(indexterm)
msgid "<primary>view</primary><secondary>updating</secondary>"
msgstr "<primary>представление</primary> <secondary>изменение</secondary>"

#: rules.xml:1571(programlisting)
#, no-wrap
msgid ""
"CREATE RULE shoe_ins_protect AS ON INSERT TO shoe\n"
"    DO INSTEAD NOTHING;\n"
"CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe\n"
"    DO INSTEAD NOTHING;\n"
"CREATE RULE shoe_del_protect AS ON DELETE TO shoe\n"
"    DO INSTEAD NOTHING;"
msgstr ""
"CREATE RULE shoe_ins_protect AS ON INSERT TO shoe\n"
"    DO INSTEAD NOTHING;\n"
"CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe\n"
"    DO INSTEAD NOTHING;\n"
"CREATE RULE shoe_del_protect AS ON DELETE TO shoe\n"
"    DO INSTEAD NOTHING;"

#: rules.xml:1565(para)
msgid ""
"A simple way to protect view relations from the mentioned possibility that "
"someone can try to run <command>INSERT</command>, <command>UPDATE</command>, "
"or <command>DELETE</command> on them is to let those query trees get thrown "
"away. So we could create the rules: <placeholder-1/> If someone now tries to "
"do any of these operations on the view relation <literal>shoe</literal>, the "
"rule system will apply these rules. Since the rules have no actions and are "
"<literal>INSTEAD</literal>, the resulting list of query trees will be empty "
"and the whole query will become nothing because there is nothing left to be "
"optimized or executed after the rule system is done with it."
msgstr ""
"Есть один простой вариант защититься от ранее упомянутой возможности "
"выполнять <command>INSERT</command>, <command>UPDATE</command> или "
"<command>DELETE</command> для представлений, когда это нежелательно — "
"создать правила, просто отбрасывающие деревья этих запросов. В нашем случае "
"они будут выглядеть так: <placeholder-1/> Если теперь кто-то попытается "
"выполнить одну из этих операций с представлением <literal>shoe</literal>, "
"система правил применит эти правила. Так как это правила без действий в "
"режиме <literal>INSTEAD</literal>, результирующий список деревьев запроса "
"будет пуст и весь запрос аннулируется, так что после работы системы правил "
"будет нечего оптимизировать и выполнять."

#: rules.xml:1596(programlisting)
#, no-wrap
msgid ""
"CREATE RULE shoelace_ins AS ON INSERT TO shoelace\n"
"    DO INSTEAD\n"
"    INSERT INTO shoelace_data VALUES (\n"
"           NEW.sl_name,\n"
"           NEW.sl_avail,\n"
"           NEW.sl_color,\n"
"           NEW.sl_len,\n"
"           NEW.sl_unit\n"
"    );\n"
"\n"
"CREATE RULE shoelace_upd AS ON UPDATE TO shoelace\n"
"    DO INSTEAD\n"
"    UPDATE shoelace_data\n"
"       SET sl_name = NEW.sl_name,\n"
"           sl_avail = NEW.sl_avail,\n"
"           sl_color = NEW.sl_color,\n"
"           sl_len = NEW.sl_len,\n"
"           sl_unit = NEW.sl_unit\n"
"     WHERE sl_name = OLD.sl_name;\n"
"\n"
"CREATE RULE shoelace_del AS ON DELETE TO shoelace\n"
"    DO INSTEAD\n"
"    DELETE FROM shoelace_data\n"
"     WHERE sl_name = OLD.sl_name;"
msgstr ""
"CREATE RULE shoelace_ins AS ON INSERT TO shoelace\n"
"    DO INSTEAD\n"
"    INSERT INTO shoelace_data VALUES (\n"
"           NEW.sl_name,\n"
"           NEW.sl_avail,\n"
"           NEW.sl_color,\n"
"           NEW.sl_len,\n"
"           NEW.sl_unit\n"
"    );\n"
"\n"
"CREATE RULE shoelace_upd AS ON UPDATE TO shoelace\n"
"    DO INSTEAD\n"
"    UPDATE shoelace_data\n"
"       SET sl_name = NEW.sl_name,\n"
"           sl_avail = NEW.sl_avail,\n"
"           sl_color = NEW.sl_color,\n"
"           sl_len = NEW.sl_len,\n"
"           sl_unit = NEW.sl_unit\n"
"     WHERE sl_name = OLD.sl_name;\n"
"\n"
"CREATE RULE shoelace_del AS ON DELETE TO shoelace\n"
"    DO INSTEAD\n"
"    DELETE FROM shoelace_data\n"
"     WHERE sl_name = OLD.sl_name;"

#: rules.xml:1589(para)
msgid ""
"A more sophisticated way to use the rule system is to create rules that "
"rewrite the query tree into one that does the right operation on the real "
"tables. To do that on the <literal>shoelace</literal> view, we create the "
"following rules: <placeholder-1/>"
msgstr ""
"Более сложный вариант — использовать систему правил для создания правил, "
"преобразующих дерево запроса в выполняющее нужную операцию с реальными "
"таблицами. Чтобы реализовать это с представлением <literal>shoelace</"
"literal>, мы создадим следующие правила: <placeholder-1/>"

#: rules.xml:1631(programlisting)
#, no-wrap
msgid ""
"CREATE RULE shoelace_ins AS ON INSERT TO shoelace\n"
"    DO INSTEAD\n"
"    INSERT INTO shoelace_data VALUES (\n"
"           NEW.sl_name,\n"
"           NEW.sl_avail,\n"
"           NEW.sl_color,\n"
"           NEW.sl_len,\n"
"           NEW.sl_unit\n"
"    )\n"
"    RETURNING\n"
"           shoelace_data.*,\n"
"           (SELECT shoelace_data.sl_len * u.un_fact\n"
"            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);"
msgstr ""
"CREATE RULE shoelace_ins AS ON INSERT TO shoelace\n"
"    DO INSTEAD\n"
"    INSERT INTO shoelace_data VALUES (\n"
"           NEW.sl_name,\n"
"           NEW.sl_avail,\n"
"           NEW.sl_color,\n"
"           NEW.sl_len,\n"
"           NEW.sl_unit\n"
"    )\n"
"    RETURNING\n"
"           shoelace_data.*,\n"
"           (SELECT shoelace_data.sl_len * u.un_fact\n"
"            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);"

#: rules.xml:1624(para)
msgid ""
"If you want to support <literal>RETURNING</literal> queries on the view, you "
"need to make the rules include <literal>RETURNING</literal> clauses that "
"compute the view rows. This is usually pretty trivial for views on a single "
"table, but it's a bit tedious for join views such as <literal>shoelace</"
"literal>. An example for the insert case is: <placeholder-1/> Note that this "
"one rule supports both <command>INSERT</command> and <command>INSERT "
"RETURNING</command> queries on the view &mdash; the <literal>RETURNING</"
"literal> clause is simply ignored for <command>INSERT</command>."
msgstr ""
"Если вы хотите поддерживать также запросы к представлению с "
"<literal>RETURNING</literal>, вам надо создать правила с предложениями "
"<literal>RETURNING</literal>, которые будут вычислять строки представления. "
"Это обычно довольно тривиально для представлений с одной нижележащей "
"таблицей, но несколько затруднительно для представлений с соединением, таких "
"как <literal>shoelace</literal>. Например, для <command>INSERT</command> это "
"будет выглядеть так: <placeholder-1/> Заметьте, что это одно правило "
"поддерживает запросы и <command>INSERT</command>, и <command>INSERT "
"RETURNING</command> к этому представлению &mdash; предложение "
"<literal>RETURNING</literal> просто игнорируется при обычном "
"<command>INSERT</command>."

#: rules.xml:1660(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE shoelace_arrive (\n"
"    arr_name    text,\n"
"    arr_quant   integer\n"
");\n"
"\n"
"CREATE TABLE shoelace_ok (\n"
"    ok_name     text,\n"
"    ok_quant    integer\n"
");\n"
"\n"
"CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok\n"
"    DO INSTEAD\n"
"    UPDATE shoelace\n"
"       SET sl_avail = sl_avail + NEW.ok_quant\n"
"     WHERE sl_name = NEW.ok_name;"
msgstr ""
"CREATE TABLE shoelace_arrive (\n"
"    arr_name    text,\n"
"    arr_quant   integer\n"
");\n"
"\n"
"CREATE TABLE shoelace_ok (\n"
"    ok_name     text,\n"
"    ok_quant    integer\n"
");\n"
"\n"
"CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok\n"
"    DO INSTEAD\n"
"    UPDATE shoelace\n"
"       SET sl_avail = sl_avail + NEW.ok_quant\n"
"     WHERE sl_name = NEW.ok_name;"

#: rules.xml:1681(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM shoelace_arrive;\n"
"\n"
" arr_name | arr_quant\n"
"----------+-----------\n"
" sl3      |        10\n"
" sl6      |        20\n"
" sl8      |        20\n"
"(3 rows)"
msgstr ""
"SELECT * FROM shoelace_arrive;\n"
"\n"
" arr_name | arr_quant\n"
"----------+-----------\n"
" sl3      |        10\n"
" sl6      |        20\n"
" sl8      |        20\n"
"(3 rows)"

#: rules.xml:1694(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM shoelace;\n"
"\n"
" sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"----------+----------+----------+--------+---------+-----------\n"
" sl1      |        5 | black    |     80 | cm      |        80\n"
" sl2      |        6 | black    |    100 | cm      |       100\n"
" sl7      |        6 | brown    |     60 | cm      |        60\n"
" sl3      |        0 | black    |     35 | inch    |      88.9\n"
" sl4      |        8 | black    |     40 | inch    |     101.6\n"
" sl8      |        1 | brown    |     40 | inch    |     101.6\n"
" sl5      |        4 | brown    |      1 | m       |       100\n"
" sl6      |        0 | brown    |    0.9 | m       |        90\n"
"(8 rows)"
msgstr ""
"SELECT * FROM shoelace;\n"
"\n"
" sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"----------+----------+----------+--------+---------+-----------\n"
" sl1      |        5 | black    |     80 | cm      |        80\n"
" sl2      |        6 | black    |    100 | cm      |       100\n"
" sl7      |        6 | brown    |     60 | cm      |        60\n"
" sl3      |        0 | black    |     35 | inch    |      88.9\n"
" sl4      |        8 | black    |     40 | inch    |     101.6\n"
" sl8      |        1 | brown    |     40 | inch    |     101.6\n"
" sl5      |        4 | brown    |      1 | m       |       100\n"
" sl6      |        0 | brown    |    0.9 | m       |        90\n"
"(8 rows)"

#: rules.xml:1712(programlisting)
#, no-wrap
msgid "INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;"
msgstr "INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;"

#: rules.xml:1718(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM shoelace ORDER BY sl_name;\n"
"\n"
" sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"----------+----------+----------+--------+---------+-----------\n"
" sl1      |        5 | black    |     80 | cm      |        80\n"
" sl2      |        6 | black    |    100 | cm      |       100\n"
" sl7      |        6 | brown    |     60 | cm      |        60\n"
" sl4      |        8 | black    |     40 | inch    |     101.6\n"
" sl3      |       10 | black    |     35 | inch    |      88.9\n"
" sl8      |       21 | brown    |     40 | inch    |     101.6\n"
" sl5      |        4 | brown    |      1 | m       |       100\n"
" sl6      |       20 | brown    |    0.9 | m       |        90\n"
"(8 rows)\n"
"\n"
"SELECT * FROM shoelace_log;\n"
"\n"
" sl_name | sl_avail | log_who| log_when                        \n"
"---------+----------+--------+----------------------------------\n"
" sl7     |        6 | Al     | Tue Oct 20 19:14:45 1998 MET DST\n"
" sl3     |       10 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n"
" sl6     |       20 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n"
" sl8     |       21 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n"
"(4 rows)"
msgstr ""
"SELECT * FROM shoelace ORDER BY sl_name;\n"
"\n"
" sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"----------+----------+----------+--------+---------+-----------\n"
" sl1      |        5 | black    |     80 | cm      |        80\n"
" sl2      |        6 | black    |    100 | cm      |       100\n"
" sl7      |        6 | brown    |     60 | cm      |        60\n"
" sl4      |        8 | black    |     40 | inch    |     101.6\n"
" sl3      |       10 | black    |     35 | inch    |      88.9\n"
" sl8      |       21 | brown    |     40 | inch    |     101.6\n"
" sl5      |        4 | brown    |      1 | m       |       100\n"
" sl6      |       20 | brown    |    0.9 | m       |        90\n"
"(8 rows)\n"
"\n"
"SELECT * FROM shoelace_log;\n"
"\n"
" sl_name | sl_avail | log_who| log_when                        \n"
"---------+----------+--------+----------------------------------\n"
" sl7     |        6 | Al     | Tue Oct 20 19:14:45 1998 MET DST\n"
" sl3     |       10 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n"
" sl6     |       20 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n"
" sl8     |       21 | Al     | Tue Oct 20 19:25:16 1998 MET DST\n"
"(4 rows)"

#: rules.xml:1652(para)
msgid ""
"Now assume that once in a while, a pack of shoelaces arrives at the shop and "
"a big parts list along with it. But you don't want to manually update the "
"<literal>shoelace</literal> view every time. Instead we set up two little "
"tables: one where you can insert the items from the part list, and one with "
"a special trick. The creation commands for these are: <placeholder-1/> Now "
"you can fill the table <literal>shoelace_arrive</literal> with the data from "
"the parts list: <placeholder-2/> Take a quick look at the current data: "
"<placeholder-3/> Now move the arrived shoelaces in: <placeholder-4/> and "
"check the results: <placeholder-5/>"
msgstr ""
"Теперь предположим, что на фабрику прибывает партия шнурков с объёмной "
"сопроводительной накладной. Но вы не хотите вручную вносить по одной записи "
"в представление <literal>shoelace</literal>. Вместо этого можно создать две "
"маленькие таблицы: в первую вы будете вставлять записи из накладной, а "
"вторая пригодится для специального приёма. Для этого мы выполним следующие "
"команды: <placeholder-1/> Теперь вы можете наполнить таблицу "
"<literal>shoelace_arrive</literal> данными о поступивших шнурках из "
"накладной: <placeholder-2/> Взгляните на текущие данные: <placeholder-3/> "
"Теперь переместите прибывшие шнурки во вторую таблицу: <placeholder-4/> "
"Проверьте, что получилось: <placeholder-5/>"

#: rules.xml:1751(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_ok\n"
"SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;"
msgstr ""
"INSERT INTO shoelace_ok\n"
"SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;"

#: rules.xml:1760(programlisting)
#, no-wrap
msgid ""
"UPDATE shoelace\n"
"   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace\n"
" WHERE shoelace.sl_name = shoelace_arrive.arr_name;"
msgstr ""
"UPDATE shoelace\n"
"   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace\n"
" WHERE shoelace.sl_name = shoelace_arrive.arr_name;"

#: rules.xml:1774(programlisting)
#, no-wrap
msgid ""
"UPDATE shoelace_data\n"
"   SET sl_name = shoelace.sl_name,\n"
"       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,\n"
"       sl_color = shoelace.sl_color,\n"
"       sl_len = shoelace.sl_len,\n"
"       sl_unit = shoelace.sl_unit\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace, shoelace old,\n"
"       shoelace new, shoelace_data shoelace_data\n"
" WHERE shoelace.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = shoelace.sl_name;"
msgstr ""
"UPDATE shoelace_data\n"
"   SET sl_name = shoelace.sl_name,\n"
"       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,\n"
"       sl_color = shoelace.sl_color,\n"
"       sl_len = shoelace.sl_len,\n"
"       sl_unit = shoelace.sl_unit\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace, shoelace old,\n"
"       shoelace new, shoelace_data shoelace_data\n"
" WHERE shoelace.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = shoelace.sl_name;"

#: rules.xml:1794(programlisting)
#, no-wrap
msgid ""
"UPDATE shoelace_data\n"
"   SET sl_name = s.sl_name,\n"
"       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,\n"
"       sl_color = s.sl_color,\n"
"       sl_len = s.sl_len,\n"
"       sl_unit = s.sl_unit\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace, shoelace old,\n"
"       shoelace new, shoelace_data shoelace_data,\n"
"       shoelace old, shoelace new,\n"
"       shoelace_data s, unit u\n"
" WHERE s.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = s.sl_name;"
msgstr ""
"UPDATE shoelace_data\n"
"   SET sl_name = s.sl_name,\n"
"       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,\n"
"       sl_color = s.sl_color,\n"
"       sl_len = s.sl_len,\n"
"       sl_unit = s.sl_unit\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace, shoelace old,\n"
"       shoelace new, shoelace_data shoelace_data,\n"
"       shoelace old, shoelace new,\n"
"       shoelace_data s, unit u\n"
" WHERE s.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = s.sl_name;"

#: rules.xml:1814(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log\n"
"SELECT s.sl_name,\n"
"       s.sl_avail + shoelace_arrive.arr_quant,\n"
"       current_user,\n"
"       current_timestamp\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace, shoelace old,\n"
"       shoelace new, shoelace_data shoelace_data,\n"
"       shoelace old, shoelace new,\n"
"       shoelace_data s, unit u,\n"
"       shoelace_data old, shoelace_data new\n"
"       shoelace_log shoelace_log\n"
" WHERE s.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = s.sl_name\n"
"   AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;"
msgstr ""
"INSERT INTO shoelace_log\n"
"SELECT s.sl_name,\n"
"       s.sl_avail + shoelace_arrive.arr_quant,\n"
"       current_user,\n"
"       current_timestamp\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n"
"       shoelace_ok old, shoelace_ok new,\n"
"       shoelace shoelace, shoelace old,\n"
"       shoelace new, shoelace_data shoelace_data,\n"
"       shoelace old, shoelace new,\n"
"       shoelace_data s, unit u,\n"
"       shoelace_data old, shoelace_data new\n"
"       shoelace_log shoelace_log\n"
" WHERE s.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = s.sl_name\n"
"   AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;"

#: rules.xml:1745(para)
msgid ""
"It's a long way from the one <literal>INSERT ... SELECT</literal> to these "
"results. And the description of the query-tree transformation will be the "
"last in this chapter. First, there is the parser's output: <placeholder-1/> "
"Now the first rule <literal>shoelace_ok_ins</literal> is applied and turns "
"this into: <placeholder-2/> and throws away the original <command>INSERT</"
"command> on <literal>shoelace_ok</literal>. This rewritten query is passed "
"to the rule system again, and the second applied rule <literal>shoelace_upd</"
"literal> produces: <placeholder-3/> Again it's an <literal>INSTEAD</literal> "
"rule and the previous query tree is trashed. Note that this query still uses "
"the view <literal>shoelace</literal>. But the rule system isn't finished "
"with this step, so it continues and applies the <literal>_RETURN</literal> "
"rule on it, and we get: <placeholder-4/> Finally, the rule "
"<literal>log_shoelace</literal> gets applied, producing the extra query "
"tree: <placeholder-5/> After that the rule system runs out of rules and "
"returns the generated query trees."
msgstr ""
"Чтобы получить эти результаты из одного <literal>INSERT ... SELECT</"
"literal>, была проделана большая работа. Мы подробно опишем всё "
"преобразование дерева запросов в продолжении этой главы. Начнём с дерева, "
"выданного анализатором запроса: <placeholder-1/> Теперь применяется первое "
"правило <literal>shoelace_ok_ins</literal>, создающее такое дерево: "
"<placeholder-2/> и отбрасывающее исходный <command>INSERT</command> в "
"<literal>shoelace_ok</literal>. Этот переписанный запрос снова поступает в "
"систему правил и второе применяемое правило <literal>shoelace_upd</literal> "
"выдаёт: <placeholder-3/> Это тоже правило <literal>INSTEAD</literal>, так "
"что предыдущее дерево запроса отбрасывается. Заметьте, что этот запрос по-"
"прежнему использует представление <literal>shoelace</literal>. Но система "
"правил ещё не закончила свою работу, она продолжает и применяет правило "
"<literal>_RETURN</literal>, так что мы получаем: <placeholder-4/> Наконец, "
"применяется правило <literal>log_shoelace</literal> и выдаётся "
"дополнительное дерево запроса: <placeholder-5/> Теперь, обработав все "
"правила, система правил выдаёт построенные деревья запросов."

#: rules.xml:1841(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace_log\n"
"SELECT s.sl_name,\n"
"       s.sl_avail + shoelace_arrive.arr_quant,\n"
"       current_user,\n"
"       current_timestamp\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,\n"
"       shoelace_data s\n"
" WHERE s.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = s.sl_name\n"
"   AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;\n"
"\n"
"UPDATE shoelace_data\n"
"   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant\n"
"  FROM shoelace_arrive shoelace_arrive,\n"
"       shoelace_data shoelace_data,\n"
"       shoelace_data s\n"
" WHERE s.sl_name = shoelace_arrive.sl_name\n"
"   AND shoelace_data.sl_name = s.sl_name;"
msgstr ""
"INSERT INTO shoelace_log\n"
"SELECT s.sl_name,\n"
"       s.sl_avail + shoelace_arrive.arr_quant,\n"
"       current_user,\n"
"       current_timestamp\n"
"  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,\n"
"       shoelace_data s\n"
" WHERE s.sl_name = shoelace_arrive.arr_name\n"
"   AND shoelace_data.sl_name = s.sl_name\n"
"   AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;\n"
"\n"
"UPDATE shoelace_data\n"
"   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant\n"
"  FROM shoelace_arrive shoelace_arrive,\n"
"       shoelace_data shoelace_data,\n"
"       shoelace_data s\n"
" WHERE s.sl_name = shoelace_arrive.sl_name\n"
"   AND shoelace_data.sl_name = s.sl_name;"

#: rules.xml:1837(para)
msgid ""
"So we end up with two final query trees that are equivalent to the "
"<acronym>SQL</acronym> statements: <placeholder-1/> The result is that data "
"coming from one relation inserted into another, changed into updates on a "
"third, changed into updating a fourth plus logging that final update in a "
"fifth gets reduced into two queries."
msgstr ""
"В итоге мы получаем два дерева запросов, равнозначные следующим операторам "
"<acronym>SQL</acronym>: <placeholder-1/> В результате вся операция, в ходе "
"которой данные, поступающие из одного отношения, вставляются в другое, "
"вставка преобразуется в изменение третьего, что затем становится изменением "
"четвёртого, и запись об этом изменении добавляется в пятое, сводится к двум "
"запросам."

#: rules.xml:1868(para)
msgid ""
"There is a little detail that's a bit ugly. Looking at the two queries, it "
"turns out that the <literal>shoelace_data</literal> relation appears twice "
"in the range table where it could definitely be reduced to one. The planner "
"does not handle it and so the execution plan for the rule systems output of "
"the <command>INSERT</command> will be <literallayout class=\"monospaced\">\n"
"Nested Loop\n"
"  -&gt;  Merge Join\n"
"        -&gt;  Seq Scan\n"
"              -&gt;  Sort\n"
"                    -&gt;  Seq Scan on s\n"
"        -&gt;  Seq Scan\n"
"              -&gt;  Sort\n"
"                    -&gt;  Seq Scan on shoelace_arrive\n"
"  -&gt;  Seq Scan on shoelace_data\n"
"</literallayout> while omitting the extra range table entry would result in "
"a <literallayout class=\"monospaced\">\n"
"Merge Join\n"
"  -&gt;  Seq Scan\n"
"        -&gt;  Sort\n"
"              -&gt;  Seq Scan on s\n"
"  -&gt;  Seq Scan\n"
"        -&gt;  Sort\n"
"              -&gt;  Seq Scan on shoelace_arrive\n"
"</literallayout> which produces exactly the same entries in the log table. "
"Thus, the rule system caused one extra scan on the table "
"<literal>shoelace_data</literal> that is absolutely not necessary. And the "
"same redundant scan is done once more in the <command>UPDATE</command>. But "
"it was a really hard job to make that all possible at all."
msgstr ""
"Здесь можно заметить маленькую не очень красивую деталь. Как видно, в этих "
"двух запросах таблица <literal>shoelace_data</literal> фигурирует в списке "
"отношений дважды, тогда как определённо достаточно и одного вхождения. "
"Планировщик не понимает этого и поэтому для дерева запроса <command>INSERT</"
"command>, выданного системой правил, будет получен такой план: "
"<literallayout class=\"monospaced\">\n"
"Nested Loop\n"
"  -&gt;  Merge Join\n"
"        -&gt;  Seq Scan\n"
"              -&gt;  Sort\n"
"                    -&gt;  Seq Scan on s\n"
"        -&gt;  Seq Scan\n"
"              -&gt;  Sort\n"
"                    -&gt;  Seq Scan on shoelace_arrive\n"
"  -&gt;  Seq Scan on shoelace_data\n"
"</literallayout> Тогда как без лишнего элемента в списке отношений мы "
"получили бы: <literallayout class=\"monospaced\">\n"
"Merge Join\n"
"  -&gt;  Seq Scan\n"
"        -&gt;  Sort\n"
"              -&gt;  Seq Scan on s\n"
"  -&gt;  Seq Scan\n"
"        -&gt;  Sort\n"
"              -&gt;  Seq Scan on shoelace_arrive\n"
"</literallayout> При этом в журнале оказались бы точно такие же записи. "
"Таким образом, применение правил повлекло дополнительное сканирование "
"таблицы <literal>shoelace_data</literal>, в котором не было никакой "
"необходимости. И такое же избыточное сканирование выполняется ещё раз в "
"<command>UPDATE</command>. Отнеситесь к этому с пониманием, ведь сделать всё "
"это возможным в принципе было действительно сложно."

#: rules.xml:1914(programlisting)
#, no-wrap
msgid ""
"INSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);\n"
"INSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);"
msgstr ""
"INSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);\n"
"INSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);"

#: rules.xml:1923(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW shoelace_mismatch AS\n"
"    SELECT * FROM shoelace WHERE NOT EXISTS\n"
"        (SELECT shoename FROM shoe WHERE slcolor = sl_color);"
msgstr ""
"CREATE VIEW shoelace_mismatch AS\n"
"    SELECT * FROM shoelace WHERE NOT EXISTS\n"
"        (SELECT shoename FROM shoe WHERE slcolor = sl_color);"

#: rules.xml:1931(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM shoelace_mismatch;\n"
"\n"
" sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"---------+----------+----------+--------+---------+-----------\n"
" sl9     |        0 | pink     |     35 | inch    |      88.9\n"
" sl10    |     1000 | magenta  |     40 | inch    |     101.6"
msgstr ""
"SELECT * FROM shoelace_mismatch;\n"
"\n"
" sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"---------+----------+----------+--------+---------+-----------\n"
" sl9     |        0 | pink     |     35 | inch    |      88.9\n"
" sl10    |     1000 | magenta  |     40 | inch    |     101.6"

#: rules.xml:1908(para)
msgid ""
"Now we make a final demonstration of the <productname>PostgreSQL</"
"productname> rule system and its power. Say you add some shoelaces with "
"extraordinary colors to your database: <placeholder-1/> We would like to "
"make a view to check which <literal>shoelace</literal> entries do not fit "
"any shoe in color. The view for this is: <placeholder-2/> Its output is: "
"<placeholder-3/>"
msgstr ""
"И наконец, ещё одна, завершающая демонстрация системы правил "
"<productname>PostgreSQL</productname> и всей её мощи. Предположим, что вы "
"добавили в базу данных шнурки с экстраординарными цветами: <placeholder-1/> "
"Давайте создадим представление, чтобы убедиться, что шнурки (записи в "
"<literal>shoelace</literal>) не подходят ни к каким туфлям. Оно будет "
"определено так: <placeholder-2/> Через него мы получаем наши записи: "
"<placeholder-3/>"

#: rules.xml:1947(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW shoelace_can_delete AS\n"
"    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;"
msgstr ""
"CREATE VIEW shoelace_can_delete AS\n"
"    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;"

#: rules.xml:1954(programlisting)
#, no-wrap
msgid ""
"DELETE FROM shoelace WHERE EXISTS\n"
"    (SELECT * FROM shoelace_can_delete\n"
"             WHERE sl_name = shoelace.sl_name);"
msgstr ""
"DELETE FROM shoelace WHERE EXISTS\n"
"    (SELECT * FROM shoelace_can_delete\n"
"             WHERE sl_name = shoelace.sl_name);"

#: rules.xml:1962(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM shoelace;\n"
"\n"
" sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"---------+----------+----------+--------+---------+-----------\n"
" sl1     |        5 | black    |     80 | cm      |        80\n"
" sl2     |        6 | black    |    100 | cm      |       100\n"
" sl7     |        6 | brown    |     60 | cm      |        60\n"
" sl4     |        8 | black    |     40 | inch    |     101.6\n"
" sl3     |       10 | black    |     35 | inch    |      88.9\n"
" sl8     |       21 | brown    |     40 | inch    |     101.6\n"
" sl10    |     1000 | magenta  |     40 | inch    |     101.6\n"
" sl5     |        4 | brown    |      1 | m       |       100\n"
" sl6     |       20 | brown    |    0.9 | m       |        90\n"
"(9 rows)"
msgstr ""
"SELECT * FROM shoelace;\n"
"\n"
" sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm\n"
"---------+----------+----------+--------+---------+-----------\n"
" sl1     |        5 | black    |     80 | cm      |        80\n"
" sl2     |        6 | black    |    100 | cm      |       100\n"
" sl7     |        6 | brown    |     60 | cm      |        60\n"
" sl4     |        8 | black    |     40 | inch    |     101.6\n"
" sl3     |       10 | black    |     35 | inch    |      88.9\n"
" sl8     |       21 | brown    |     40 | inch    |     101.6\n"
" sl10    |     1000 | magenta  |     40 | inch    |     101.6\n"
" sl5     |        4 | brown    |      1 | m       |       100\n"
" sl6     |       20 | brown    |    0.9 | m       |        90\n"
"(9 rows)"

#: rules.xml:1941(para)
msgid ""
"Now we want to set it up so that mismatching shoelaces that are not in stock "
"are deleted from the database. To make it a little harder for "
"<productname>PostgreSQL</productname>, we don't delete it directly. Instead "
"we create one more view: <placeholder-1/> and do it this way: <placeholder-2/"
"> <foreignphrase>Voil&agrave;</foreignphrase>: <placeholder-3/>"
msgstr ""
"Теперь мы хотим, чтобы шнурки, которые ни к чему не подходят, удалялись из "
"базы данных. Чтобы немного усложнить задачу для <productname>PostgreSQL</"
"productname>, мы не будем удалять их непосредственно из таблицы. Вместо "
"этого мы создадим ещё одно представление: <placeholder-1/> И удалим их так: "
"<placeholder-2/> Вуаля: <placeholder-3/>"

#: rules.xml:1980(para)
msgid ""
"A <command>DELETE</command> on a view, with a subquery qualification that in "
"total uses 4 nesting/joined views, where one of them itself has a subquery "
"qualification containing a view and where calculated view columns are used, "
"gets rewritten into one single query tree that deletes the requested data "
"from a real table."
msgstr ""
"Так запрос <command>DELETE</command> для представления с ограничивающим "
"условием-подзапросом, использующим в совокупности 4 вложенных/соединённых "
"представления, с одним из которых тоже связано условие с подзапросом, "
"задействующим представление, и где используются вычисляемые столбцы "
"представлений, переписывается и преобразуется в одно дерево запроса, которое "
"удаляет требуемые данные из реальной таблицы."

#: rules.xml:1990(para)
msgid ""
"There are probably only a few situations out in the real world where such a "
"construct is necessary. But it makes you feel comfortable that it works."
msgstr ""
"На практике ситуации, когда необходима такая сложная конструкция, "
"встречаются довольно редко, но, тем не менее, приятно осознавать, что всё "
"это возможно и работает."

#: rules.xml:2000(title)
msgid "Rules and Privileges"
msgstr "Правила и права"

#: rules.xml:2002(indexterm)
msgid ""
"<primary>privilege</primary> <secondary sortas=\"Regeln\">with rules</"
"secondary>"
msgstr ""
"<primary>права</primary> <secondary sortas=\"Regeln\">с правилами</secondary>"

#: rules.xml:2007(indexterm)
msgid ""
"<primary>privilege</primary> <secondary sortas=\"Sichten\">with views</"
"secondary>"
msgstr ""
"<primary>права</primary> <secondary sortas=\"Sichten\">с представлениями</"
"secondary>"

#: rules.xml:2012(para)
msgid ""
"Due to rewriting of queries by the <productname>PostgreSQL</productname> "
"rule system, other tables/views than those used in the original query get "
"accessed. When update rules are used, this can include write access to "
"tables."
msgstr ""
"В результате переписывания запросов системой правил <productname>PostgreSQL</"
"productname> обращение может происходить не к тем таблицам/представлениям, к "
"которым обращался исходный запрос. С правилами для изменения возможна так же "
"и запись в другие таблицы."

#: rules.xml:2019(para)
msgid ""
"Rewrite rules don't have a separate owner. The owner of a relation (table or "
"view) is automatically the owner of the rewrite rules that are defined for "
"it. The <productname>PostgreSQL</productname> rule system changes the "
"behavior of the default access control system. Relations that are used due "
"to rules get checked against the privileges of the rule owner, not the user "
"invoking the rule. This means that users only need the required privileges "
"for the tables/views that are explicitly named in their queries."
msgstr ""
"Правила перезаписи не имеют отдельного владельца — владельцем правил "
"перезаписи, определённых для отношения (таблицы или представления), "
"автоматически считается владелец этого отношения. Система правил "
"<productname>PostgreSQL</productname> меняет поведение стандартного "
"механизма управления доступом. К отношениям, используемым вследствие "
"применения правил, проверяется доступ владельца правила, но не пользователя, "
"выполняющего запрос. Это значит, что пользователь должен иметь права, "
"необходимые только для обращения к таблицам/представлениям, которые он явно "
"упоминает в своих запросах."

#: rules.xml:2036(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE phone_data (person text, phone text, private boolean);\n"
"CREATE VIEW phone_number AS\n"
"    SELECT person, CASE WHEN NOT private THEN phone END AS phone\n"
"    FROM phone_data;\n"
"GRANT SELECT ON phone_number TO assistant;"
msgstr ""
"CREATE TABLE phone_data (person text, phone text, private boolean);\n"
"CREATE VIEW phone_number AS\n"
"    SELECT person, CASE WHEN NOT private THEN phone END AS phone\n"
"    FROM phone_data;\n"
"GRANT SELECT ON phone_number TO assistant;"

#: rules.xml:2031(para)
msgid ""
"For example: A user has a list of phone numbers where some of them are "
"private, the others are of interest for the assistant of the office. The "
"user can construct the following: <placeholder-1/> Nobody except that user "
"(and the database superusers) can access the <literal>phone_data</literal> "
"table. But because of the <command>GRANT</command>, the assistant can run a "
"<command>SELECT</command> on the <literal>phone_number</literal> view. The "
"rule system will rewrite the <command>SELECT</command> from "
"<literal>phone_number</literal> into a <command>SELECT</command> from "
"<literal>phone_data</literal>. Since the user is the owner of "
"<literal>phone_number</literal> and therefore the owner of the rule, the "
"read access to <literal>phone_data</literal> is now checked against the "
"user's privileges and the query is permitted. The check for accessing "
"<literal>phone_number</literal> is also performed, but this is done against "
"the invoking user, so nobody but the user and the assistant can use it."
msgstr ""
"Например, представим, что у пользователя есть список телефонных номеров, "
"некоторые из которых личные, а некоторые должна знать его ассистентка. Он "
"может построить следующую конструкцию: <placeholder-1/> Никто, кроме него (и "
"суперпользователей базы данных) не сможет обратиться к таблице "
"<literal>phone_data</literal>. Но так как ассистентке было дано "
"(<command>GRANT</command>) соответствующее право, она сможет выполнить "
"<command>SELECT</command> для представления <literal>phone_number</literal>. "
"Система правил преобразует <command>SELECT</command> из "
"<literal>phone_number</literal> в <command>SELECT</command> из таблицы "
"<literal>phone_data</literal>. Так как пользователь является владельцем "
"<literal>phone_number</literal>, он же считается владельцем правила, доступ "
"на чтение <literal>phone_data</literal> проверяется для него, и выполнение "
"запроса разрешается. Проверка прав доступа к <literal>phone_number</literal> "
"тоже выполняется, но при этом проверяется пользователь, выполняющий запрос, "
"так что обращаться к этому представлению смогут только сам пользователь и "
"его ассистентка."

#: rules.xml:2059(para)
msgid ""
"The privileges are checked rule by rule. So the assistant is for now the "
"only one who can see the public phone numbers. But the assistant can set up "
"another view and grant access to that to the public. Then, anyone can see "
"the <literal>phone_number</literal> data through the assistant's view. What "
"the assistant cannot do is to create a view that directly accesses "
"<literal>phone_data</literal>. (Actually the assistant can, but it will not "
"work since every access will be denied during the permission checks.) And as "
"soon as the user notices that the assistant opened their "
"<literal>phone_number</literal> view, the user can revoke the assistant's "
"access. Immediately, any access to the assistant's view would fail."
msgstr ""
"Права проверяются правило за правилом. То есть, в данный момент только "
"ассистентка может видеть открытые телефонные номера. Но она может создать "
"другое представление и дать доступ к нему всем (роли <literal>public</"
"literal>), после чего все смогут видеть данные <literal>phone_number</"
"literal> через представление ассистентки. Что она не может сделать, так это "
"создать представление, которое обращается к <literal>phone_data</literal> "
"напрямую. (Вообще она может это сделать, но такое представление не будет "
"работать, так как при любой попытке прочитать его доступ к таблице будет "
"запрещён.) И как только пользователь заметит, что ассистентка открыла доступ "
"к своему представлению <literal>phone_number</literal>, он может лишить её "
"права чтения этого представления. В результате все сразу потеряют доступ и к "
"представлению ассистентки."

#: rules.xml:2072(para)
msgid ""
"One might think that this rule-by-rule checking is a security hole, but in "
"fact it isn't. But if it did not work this way, the assistant could set up a "
"table with the same columns as <literal>phone_number</literal> and copy the "
"data to there once per day. Then it's the assistant's own data and the "
"assistant can grant access to everyone they want. A <command>GRANT</command> "
"command means, <quote>I trust you</quote>. If someone you trust does the "
"thing above, it's time to think it over and then use <command>REVOKE</"
"command>."
msgstr ""
"Может показаться, что такая проверка <quote>правило-за-правилом</quote> "
"представляет уязвимость, но это не так. Если бы даже этот механизм не "
"работал, ассистентка могла бы создать таблицу со столбцами как в "
"<literal>phone_number</literal> и регулярно копировать туда данные. Тогда "
"это были бы её собственные данные и она могла бы открывать доступ к ним кому "
"угодно. Другими словами, команда <command>GRANT</command> означает <quote>Я "
"доверяю тебе</quote>. Если кто-то, кому вы доверяете, проделывает такие "
"операции, стоит задуматься и, возможно, лишить его доступа к данным, "
"применив <command>REVOKE</command>."

#: rules.xml:2089(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW phone_number AS\n"
"    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';"
msgstr ""
"CREATE VIEW phone_number AS\n"
"    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';"

#: rules.xml:2101(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION tricky(text, text) RETURNS bool AS $$\n"
"BEGIN\n"
"    RAISE NOTICE '% =&gt; %', $1, $2;\n"
"    RETURN true;\n"
"END\n"
"$$ LANGUAGE plpgsql COST 0.0000000000000000000001;\n"
"\n"
"SELECT * FROM phone_number WHERE tricky(person, phone);"
msgstr ""
"CREATE FUNCTION tricky(text, text) RETURNS bool AS $$\n"
"BEGIN\n"
"    RAISE NOTICE '% =&gt; %', $1, $2;\n"
"    RETURN true;\n"
"END\n"
"$$ LANGUAGE plpgsql COST 0.0000000000000000000001;\n"
"\n"
"SELECT * FROM phone_number WHERE tricky(person, phone);"

#: rules.xml:2083(para)
msgid ""
"Note that while views can be used to hide the contents of certain columns "
"using the technique shown above, they cannot be used to reliably conceal the "
"data in unseen rows unless the <literal>security_barrier</literal> flag has "
"been set. For example, the following view is insecure: <placeholder-1/> This "
"view might seem secure, since the rule system will rewrite any "
"<command>SELECT</command> from <literal>phone_number</literal> into a "
"<command>SELECT</command> from <literal>phone_data</literal> and add the "
"qualification that only entries where <literal>phone</literal> does not "
"begin with 412 are wanted. But if the user can create their own functions, "
"it is not difficult to convince the planner to execute the user-defined "
"function prior to the <function>NOT LIKE</function> expression. For example: "
"<placeholder-2/> Every person and phone number in the <literal>phone_data</"
"literal> table will be printed as a <literal>NOTICE</literal>, because the "
"planner will choose to execute the inexpensive <function>tricky</function> "
"function before the more expensive <function>NOT LIKE</function>. Even if "
"the user is prevented from defining new functions, built-in functions can be "
"used in similar attacks. (For example, most casting functions include their "
"input values in the error messages they produce.)"
msgstr ""
"Хотя представления могут применяться для скрытия содержимого определённых "
"столбцов, как описано выше, с их помощью нельзя надёжно скрыть данные в "
"невидимых строках, если только не установлен флаг <literal>security_barrier</"
"literal>. Например, следующее представление небезопасно: <placeholder-1/> "
"Может показаться, что всё в порядке, ведь система правил преобразует "
"<command>SELECT</command> из <literal>phone_number</literal> в "
"<command>SELECT</command> из <literal>phone_data</literal> и добавит "
"ограничивающее условие, чтобы выдавались только строки с полем "
"<literal>phone</literal>, начинающимся не с 412. Но если пользователь может "
"создавать собственные функции, ему будет не сложно заставить планировщик "
"выполнять функцию пользователя перед выражением <function>NOT LIKE</"
"function>. Например: <placeholder-2/> Так он сможет получить все имена и "
"номера телефонов из таблицы <literal>phone_data</literal> через сообщения "
"<literal>NOTICE</literal>, так как планировщик решит, что лучше выполнить "
"недорогую функцию <function>tricky</function> перед более дорогой операцией "
"<function>NOT LIKE</function>. И даже если пользователь не имеет права "
"создавать новые функции, он может использовать для подобных атак встроенные "
"функции. (Например, многие функции приведения показывают входные значения в "
"сообщениях об ошибках.)"

#: rules.xml:2120(para)
msgid ""
"Similar considerations apply to update rules. In the examples of the "
"previous section, the owner of the tables in the example database could "
"grant the privileges <literal>SELECT</literal>, <literal>INSERT</literal>, "
"<literal>UPDATE</literal>, and <literal>DELETE</literal> on the "
"<literal>shoelace</literal> view to someone else, but only <literal>SELECT</"
"literal> on <literal>shoelace_log</literal>. The rule action to write log "
"entries will still be executed successfully, and that other user could see "
"the log entries. But they could not create fake entries, nor could they "
"manipulate or remove existing ones. In this case, there is no possibility of "
"subverting the rules by convincing the planner to alter the order of "
"operations, because the only rule which references <literal>shoelace_log</"
"literal> is an unqualified <literal>INSERT</literal>. This might not be true "
"in more complex scenarios."
msgstr ""
"Подобные соображения распространяются и на правила для изменения. "
"Применительно к примерам предыдущего раздела, владелец таблиц в базе данных "
"может дать кому-нибудь другому для представления <literal>shoelace</literal> "
"права <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal> и <literal>DELETE</literal>, а для <literal>shoelace_log</literal> "
"только <literal>SELECT</literal>. Действие правила, добавляющее записи в "
"журнал, всё равно будет выполняться успешно, а этот другой пользователь "
"сможет видеть записи в журнале. Но он не сможет создавать поддельные записи, "
"равно как и модифицировать или удалять существующие. В этом случае нет "
"никакой возможности заставить планировщик изменить порядок операций, так как "
"единственное правило, которое обращается к <literal>shoelace_log</literal> — "
"это безусловный <literal>INSERT</literal>. В более сложных сценариях это "
"может быть не так."

#: rules.xml:2143(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW phone_number WITH (security_barrier) AS\n"
"    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';"
msgstr ""
"CREATE VIEW phone_number WITH (security_barrier) AS\n"
"    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';"

#: rules.xml:2136(para)
msgid ""
"When it is necessary for a view to provide row level security, the "
"<literal>security_barrier</literal> attribute should be applied to the view. "
"This prevents maliciously-chosen functions and operators from being passed "
"values from rows until after the view has done its work. For example, if the "
"view shown above had been created like this, it would be secure: "
"<placeholder-1/> Views created with the <literal>security_barrier</literal> "
"may perform far worse than views created without this option. In general, "
"there is no way to avoid this: the fastest possible plan must be rejected if "
"it may compromise security. For this reason, this option is not enabled by "
"default."
msgstr ""
"Когда требуется, чтобы представление обеспечивало защиту на уровне строк, к "
"нему нужно применить атрибут <literal>security_barrier</literal>. Это "
"предотвратит утечку содержимого строк из злонамеренно выбранных функций и "
"операторов до того, как строки будут отфильтрованы представлением. Например, "
"показанное выше представление будет безопасным, если создать его так: "
"<placeholder-1/> Представления, созданные с атрибутом "
"<literal>security_barrier</literal>, могут работать гораздо медленнее, чем "
"обычные. И вообще говоря, это неизбежно: самый быстрый план должен быть "
"отвергнут, если он может скомпрометировать защиту. Поэтому данный атрибут по "
"умолчанию не устанавливается."

#: rules.xml:2154(para)
msgid ""
"The query planner has more flexibility when dealing with functions that have "
"no side effects. Such functions are referred to as <literal>LEAKPROOF</"
"literal>, and include many simple, commonly used operators, such as many "
"equality operators. The query planner can safely allow such functions to be "
"evaluated at any point in the query execution process, since invoking them "
"on rows invisible to the user will not leak any information about the unseen "
"rows. Further, functions which do not take arguments or which are not passed "
"any arguments from the security barrier view do not have to be marked as "
"<literal>LEAKPROOF</literal> to be pushed down, as they never receive data "
"from the view. In contrast, a function that might throw an error depending "
"on the values received as arguments (such as one that throws an error in the "
"event of overflow or division by zero) is not leak-proof, and could provide "
"significant information about the unseen rows if applied before the security "
"view's row filters."
msgstr ""
"Планировщик запросов имеет больше свободы, работая с функциями, лишёнными "
"побочных эффектов. Такие функции называются герметичными "
"(<literal>LEAKPROOF</literal>) и включают только простые часто используемые "
"операторы, например, операторы равенства. Планировщик запросов может "
"безопасно вычислять такие функции в любой момент выполнения запроса, так как "
"при вызове их для строк, невидимых пользователю, не просочится никакая "
"информация об этих строках. Более того, функции, которые не принимают "
"аргументы или которым не передаются аргументы из представления с барьером "
"безопасности, можно не помечать как <literal>LEAKPROOF</literal>, чтобы они "
"вышли наружу, так как они никогда не получат данные из представления. И "
"напротив, функции, которые могут вызвать ошибку в зависимости от значений "
"аргументов (например, в случае переполнения или деления на ноль), "
"герметичными не являются, и могут выдать существенную информацию о невидимых "
"строках, если будут выполнены перед фильтрами строк."

#: rules.xml:2171(para)
msgid ""
"It is important to understand that even a view created with the "
"<literal>security_barrier</literal> option is intended to be secure only in "
"the limited sense that the contents of the invisible tuples will not be "
"passed to possibly-insecure functions. The user may well have other means of "
"making inferences about the unseen data; for example, they can see the query "
"plan using <command>EXPLAIN</command>, or measure the run time of queries "
"against the view. A malicious attacker might be able to infer something "
"about the amount of unseen data, or even gain some information about the "
"data distribution or most common values (since these things may affect the "
"run time of the plan; or even, since they are also reflected in the "
"optimizer statistics, the choice of plan). If these types of \"covert channel"
"\" attacks are of concern, it is probably unwise to grant any access to the "
"data at all."
msgstr ""
"Важно понимать, что даже представление, созданное с атрибутом "
"<literal>security_barrier</literal>, остаётся безопасным только в том "
"смысле, что содержимое невидимых строк не будет передаваться потенциально "
"небезопасным функциям. Но пользователь может собрать некоторые сведения о "
"невидимых данных и другими способами; например, он может проанализировать "
"план запроса, полученный с <command>EXPLAIN</command>, или замерить время "
"выполнения запросов с этим представлением. Злоумышленник может сделать "
"определённые выводы об объёме невидимых данных или даже получить некоторую "
"информацию о распределении данных или наиболее частых значениях (так как всё "
"это отражается в статистике для оптимизатора и, как следствие, влияет на "
"время выполнения плана или даже на выбор плана). Если возможность атаки "
"через скрытые каналы вызывает опасения, вероятно, будет разумным не "
"предоставлять никакой доступ к этим данным."

#: rules.xml:2189(title)
msgid "Rules and Command Status"
msgstr "Правила и статус команд"

#: rules.xml:2191(para)
msgid ""
"The <productname>PostgreSQL</productname> server returns a command status "
"string, such as <literal>INSERT 149592 1</literal>, for each command it "
"receives. This is simple enough when there are no rules involved, but what "
"happens when the query is rewritten by rules?"
msgstr ""
"Сервер <productname>PostgreSQL</productname> возвращает строку состояния "
"команды, например, <literal>INSERT 149592 1</literal>, для каждой получаемой "
"команды. Это довольно прозрачно, когда не задействуются правила, но что "
"произойдёт, если правила перезапишут запрос?"

#: rules.xml:2203(para)
msgid ""
"If there is no unconditional <literal>INSTEAD</literal> rule for the query, "
"then the originally given query will be executed, and its command status "
"will be returned as usual. (But note that if there were any conditional "
"<literal>INSTEAD</literal> rules, the negation of their qualifications will "
"have been added to the original query. This might reduce the number of rows "
"it processes, and if so the reported status will be affected.)"
msgstr ""
"Если с запросом не связано безусловное правило <literal>INSTEAD</literal>, "
"то выполняется заданный исходный запрос и его статус выдаётся как обычно. "
"(Но если определены какие-то условные правила <literal>INSTEAD</literal>, к "
"исходному запросу добавляется условие, обратное их условиям применения. Это "
"может повлиять на число обрабатываемых строк и выводимый статус команды.)"

#: rules.xml:2215(para)
msgid ""
"If there is any unconditional <literal>INSTEAD</literal> rule for the query, "
"then the original query will not be executed at all. In this case, the "
"server will return the command status for the last query that was inserted "
"by an <literal>INSTEAD</literal> rule (conditional or unconditional) and is "
"of the same command type (<command>INSERT</command>, <command>UPDATE</"
"command>, or <command>DELETE</command>) as the original query. If no query "
"meeting those requirements is added by any rule, then the returned command "
"status shows the original query type and zeroes for the row-count and OID "
"fields."
msgstr ""
"Если с запросом связано безусловное правило <literal>INSTEAD</literal>, "
"исходный запрос не выполняется вовсе. В этом случае сервер возвратит статус "
"команды от последнего запроса, вставленного правилом <literal>INSTEAD</"
"literal> (условным или безусловным), и тип команды исходного запроса "
"(<command>INSERT</command>, <command>UPDATE</command> или <command>DELETE</"
"command>). Если правила не добавили подходящего запроса, в возвращённом "
"статусе команды показывается исходный тип запроса и нули вместо количества "
"строк и OID."

#: rules.xml:2198(para)
msgid "Rules affect the command status as follows: <placeholder-1/>"
msgstr ""
"Правила влияют на состояния команды следующим образом: <placeholder-1/>"

#: rules.xml:2231(para)
msgid ""
"The programmer can ensure that any desired <literal>INSTEAD</literal> rule "
"is the one that sets the command status in the second case, by giving it the "
"alphabetically last rule name among the active rules, so that it gets "
"applied last."
msgstr ""
"Программист может добиться, чтобы статус команды во втором случае "
"устанавливало нужное правило <literal>INSTEAD</literal>, назначив ему имя, "
"стоящее по алфавиту после других активных правил, чтобы это правило "
"применялось последним."

#: rules.xml:2240(title)
msgid "Rules Versus Triggers"
msgstr "Сравнение правил и триггеров"

#: rules.xml:2242(indexterm)
msgid ""
"<primary>rule</primary> <secondary sortas=\"Trigger\">compared with "
"triggers</secondary>"
msgstr ""
"<primary>правила</primary> <secondary sortas=\"Trigger\">в сравнении с "
"триггерами</secondary>"

#: rules.xml:2247(indexterm)
msgid ""
"<primary>trigger</primary> <secondary sortas=\"Regeln\">compared with rules</"
"secondary>"
msgstr ""
"<primary>триггеры</primary> <secondary sortas=\"Regeln\">в сравнении с "
"правилами</secondary>"

#: rules.xml:2252(para)
msgid ""
"Many things that can be done using triggers can also be implemented using "
"the <productname>PostgreSQL</productname> rule system. One of the things "
"that cannot be implemented by rules are some kinds of constraints, "
"especially foreign keys. It is possible to place a qualified rule that "
"rewrites a command to <literal>NOTHING</literal> if the value of a column "
"does not appear in another table. But then the data is silently thrown away "
"and that's not a good idea. If checks for valid values are required, and in "
"the case of an invalid value an error message should be generated, it must "
"be done by a trigger."
msgstr ""
"Многие вещи, которые можно сделать с помощью триггеров, можно также "
"реализовать, используя систему правил <productname>PostgreSQL</productname>. "
"Однако, используя правила, нельзя реализовать, например, некоторые типы "
"ограничений, в частности, внешние ключи. Хотя можно определить правило с "
"ограничивающим условием, которое будет преобразовать команду в "
"<literal>NOTHING</literal>, если значение ключа не находится в другой "
"таблице, но при этом неподходящие данные будут отбрасываться молча, а это не "
"самый лучший вариант. Также, если требуется проверить правильность значений "
"и, обнаружив неверное значение, выдать ошибку, это нужно делать в триггере."

#: rules.xml:2265(para)
msgid ""
"In this chapter, we focused on using rules to update views. All of the "
"update rule examples in this chapter can also be implemented using "
"<literal>INSTEAD OF</literal> triggers on the views. Writing such triggers "
"is often easier than writing rules, particularly if complex logic is "
"required to perform the update."
msgstr ""
"В этой главе мы разберём использование правил для изменения представлений. "
"Все правила, приведённые в примерах этой главы, можно также заменить "
"триггерами <literal>INSTEAD OF</literal> для представлений. Написать такие "
"триггеры часто бывает проще, чем разработать правила, особенно если для "
"изменений применяется сложная логика."

#: rules.xml:2273(para)
msgid ""
"For the things that can be implemented by both, which is best depends on the "
"usage of the database. A trigger is fired once for each affected row. A rule "
"modifies the query or generates an additional query. So if many rows are "
"affected in one statement, a rule issuing one extra command is likely to be "
"faster than a trigger that is called for every single row and must re-"
"determine what to do many times. However, the trigger approach is "
"conceptually far simpler than the rule approach, and is easier for novices "
"to get right."
msgstr ""
"Для тех задач, которые можно решить обоими способами, лучший выбирается в "
"зависимости от характера использования базы данных. Следует учитывать, что "
"триггер срабатывает для каждой обрабатываемой строки, а правило изменяет "
"существующий запрос или создаёт ещё один. Поэтому, если один оператор "
"обрабатывает сразу много строк, правило, добавляющее дополнительную команду, "
"скорее всего, будет работать быстрее, чем триггер, который вызывается для "
"каждой очередной строки и должен каждый раз определять, что с ней делать. "
"Однако триггеры концептуально гораздо проще правил, и использовать их "
"правильно новичкам гораздо проще."

#: rules.xml:2289(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE computer (\n"
"    hostname        text,    -- indexed\n"
"    manufacturer    text     -- indexed\n"
");\n"
"\n"
"CREATE TABLE software (\n"
"    software        text,    -- indexed\n"
"    hostname        text     -- indexed\n"
");"
msgstr ""
"CREATE TABLE computer (\n"
"    hostname        text,    -- индексированное\n"
"    manufacturer    text     -- индексированное\n"
");\n"
"\n"
"CREATE TABLE software (\n"
"    software        text,    -- индексированное\n"
"    hostname        text     -- индексированное\n"
");"

#: rules.xml:2306(programlisting)
#, no-wrap
msgid "DELETE FROM software WHERE hostname = $1;"
msgstr "DELETE FROM software WHERE hostname = $1;"

#: rules.xml:2315(programlisting)
#, no-wrap
msgid ""
"CREATE RULE computer_del AS ON DELETE TO computer\n"
"    DO DELETE FROM software WHERE hostname = OLD.hostname;"
msgstr ""
"CREATE RULE computer_del AS ON DELETE TO computer\n"
"    DO DELETE FROM software WHERE hostname = OLD.hostname;"

#: rules.xml:2285(para)
msgid ""
"Here we show an example of how the choice of rules versus triggers plays out "
"in one situation. There are two tables: <placeholder-1/> Both tables have "
"many thousands of rows and the indexes on <structfield>hostname</"
"structfield> are unique. The rule or trigger should implement a constraint "
"that deletes rows from <literal>software</literal> that reference a deleted "
"computer. The trigger would use this command: <placeholder-2/> Since the "
"trigger is called for each individual row deleted from <literal>computer</"
"literal>, it can prepare and save the plan for this command and pass the "
"<structfield>hostname</structfield> value in the parameter. The rule would "
"be written as: <placeholder-3/>"
msgstr ""
"Давайте рассмотрим пример, показывающий, как выбор в пользу правил вместо "
"триггеров оказывается выигрышным в определённой ситуации. Пусть у нас есть "
"две таблицы: <placeholder-1/> Обе таблицы содержат несколько тысяч строк, а "
"индексы по полю <structfield>hostname</structfield> являются уникальными. "
"Правило или триггер должны реализовать ограничение, которое удалит строки из "
"таблицы <literal>software</literal>, ссылающиеся на удаляемый компьютер. "
"Триггер выполнял бы такую команду: <placeholder-2/> Так как триггер "
"вызывается для каждой отдельной строки, удаляемой из таблицы "
"<literal>computer</literal>, он может подготовить и сохранить план этой "
"команды, а затем передавать значение <structfield>hostname</structfield> "
"подготовленному запросу в параметрах. Правило же можно записать так: "
"<placeholder-3/>"

#: rules.xml:2324(programlisting)
#, no-wrap
msgid "DELETE FROM computer WHERE hostname = 'mypc.local.net';"
msgstr "DELETE FROM computer WHERE hostname = 'mypc.local.net';"

#: rules.xml:2332(programlisting)
#, no-wrap
msgid ""
"DELETE FROM software WHERE computer.hostname = 'mypc.local.net'\n"
"                       AND software.hostname = computer.hostname;"
msgstr ""
"DELETE FROM software WHERE computer.hostname = 'mypc.local.net'\n"
"                       AND software.hostname = computer.hostname;"

#: rules.xml:2321(para)
msgid ""
"Now we look at different types of deletes. In the case of a: <placeholder-1/"
"> the table <literal>computer</literal> is scanned by index (fast), and the "
"command issued by the trigger would also use an index scan (also fast). The "
"extra command from the rule would be: <placeholder-2/> Since there are "
"appropriate indexes set up, the planner will create a plan of <literallayout "
"class=\"monospaced\">\n"
"Nestloop\n"
"  -&gt;  Index Scan using comp_hostidx on computer\n"
"  -&gt;  Index Scan using soft_hostidx on software\n"
"</literallayout> So there would be not that much difference in speed between "
"the trigger and the rule implementation."
msgstr ""
"Теперь давайте взглянем на разные варианты удаления. В этом случае: "
"<placeholder-1/> таблица <literal>computer</literal> сканируется по индексу "
"(быстро), и команда, выполняемая триггером, так же будет применять "
"сканирование по индексу (тоже быстро). Дополнительной командой правила "
"будет: <placeholder-2/> Так как созданы все необходимые индексы, планировщик "
"создаст план <literallayout class=\"monospaced\">\n"
"Nestloop\n"
"  -&gt;  Index Scan using comp_hostidx on computer\n"
"  -&gt;  Index Scan using soft_hostidx on software\n"
"</literallayout> Таким образом, большого различия в скорости между "
"реализациями с триггером и с правилом не будет."

#: rules.xml:2356(programlisting)
#, no-wrap
msgid ""
"DELETE FROM computer WHERE hostname &gt;= 'old'\n"
"                       AND hostname &lt;  'ole'"
msgstr ""
"DELETE FROM computer WHERE hostname &gt;= 'old'\n"
"                       AND hostname &lt;  'ole'"

#: rules.xml:2363(programlisting)
#, no-wrap
msgid ""
"DELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'\n"
"                       AND software.hostname = computer.hostname;"
msgstr ""
"DELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'\n"
"                       AND software.hostname = computer.hostname;"

#: rules.xml:2379(programlisting)
#, no-wrap
msgid "DELETE FROM computer WHERE hostname ~ '^old';"
msgstr "DELETE FROM computer WHERE hostname ~ '^old';"

#: rules.xml:2350(para)
msgid ""
"With the next delete we want to get rid of all the 2000 computers where the "
"<structfield>hostname</structfield> starts with <literal>old</literal>. "
"There are two possible commands to do that. One is: <placeholder-1/> The "
"command added by the rule will be: <placeholder-2/> with the plan "
"<literallayout class=\"monospaced\">\n"
"Hash Join\n"
"  -&gt;  Seq Scan on software\n"
"  -&gt;  Hash\n"
"    -&gt;  Index Scan using comp_hostidx on computer\n"
"</literallayout> The other possible command is: <placeholder-3/> which "
"results in the following executing plan for the command added by the rule: "
"<literallayout class=\"monospaced\">\n"
"Nestloop\n"
"  -&gt;  Index Scan using comp_hostidx on computer\n"
"  -&gt;  Index Scan using soft_hostidx on software\n"
"</literallayout> This shows, that the planner does not realize that the "
"qualification for <structfield>hostname</structfield> in <literal>computer</"
"literal> could also be used for an index scan on <literal>software</literal> "
"when there are multiple qualification expressions combined with "
"<literal>AND</literal>, which is what it does in the regular-expression "
"version of the command. The trigger will get invoked once for each of the "
"2000 old computers that have to be deleted, and that will result in one "
"index scan over <literal>computer</literal> and 2000 index scans over "
"<literal>software</literal>. The rule implementation will do it with two "
"commands that use indexes. And it depends on the overall size of the table "
"<literal>software</literal> whether the rule will still be faster in the "
"sequential scan situation. 2000 command executions from the trigger over the "
"SPI manager take some time, even if all the index blocks will soon be in the "
"cache."
msgstr ""
"Теперь мы хотим избавиться от 2000 компьютеров, у которых "
"<structfield>hostname</structfield> начинается с <literal>old</literal>. Это "
"можно сделать двумя командами. Первая: <placeholder-1/> Правило преобразует "
"её в: <placeholder-2/> с планом: <literallayout class=\"monospaced\">\n"
"Hash Join\n"
"  -&gt;  Seq Scan on software\n"
"  -&gt;  Hash\n"
"    -&gt;  Index Scan using comp_hostidx on computer\n"
"</literallayout> С другой возможной командой: <placeholder-3/> для запроса, "
"преобразованного правилом, получается следующий план: <literallayout class="
"\"monospaced\">\n"
"Nestloop\n"
"  -&gt;  Index Scan using comp_hostidx on computer\n"
"  -&gt;  Index Scan using soft_hostidx on software\n"
"</literallayout> Это показывает, что планировщик не понимает, что "
"ограничение по <structfield>hostname</structfield> в <literal>computer</"
"literal> можно также использовать для сканирования по индексу в "
"<literal>software</literal>, когда несколько условий объединяются с помощью "
"<literal>AND</literal>, что он успешно делает для варианта команды с "
"регулярным выражением. Триггер будет вызываться для каждой из 2000 удаляемых "
"записей о старых компьютерах, и это приведёт к одному сканированию индекса в "
"таблице <literal>computer</literal> и 2000 сканированиям индекса в таблице "
"<literal>software</literal>. Реализация с правилом делает это двумя "
"командами, применяющими индексы. Будет ли правило быстрее при "
"последовательном сканировании, зависит от общего размера таблицы "
"<literal>software</literal>. С другой стороны, выполнение 2000 команд из "
"триггера через менеджер SPI всё равно займёт время, даже если все блоки "
"индекса вскоре окажутся в кеше."

#: rules.xml:2411(programlisting)
#, no-wrap
msgid "DELETE FROM computer WHERE manufacturer = 'bim';"
msgstr "DELETE FROM computer WHERE manufacturer = 'bim';"

#: rules.xml:2419(programlisting)
#, no-wrap
msgid ""
"DELETE FROM software WHERE computer.manufacturer = 'bim'\n"
"                       AND software.hostname = computer.hostname;"
msgstr ""
"DELETE FROM software WHERE computer.manufacturer = 'bim'\n"
"                       AND software.hostname = computer.hostname;"

#: rules.xml:2427(programlisting)
#, no-wrap
msgid ""
"Nestloop\n"
"  -&gt;  Index Scan using comp_manufidx on computer\n"
"  -&gt;  Index Scan using soft_hostidx on software"
msgstr ""
"Nestloop\n"
"  -&gt;  Index Scan using comp_manufidx on computer\n"
"  -&gt;  Index Scan using soft_hostidx on software"

#: rules.xml:2408(para)
msgid ""
"The last command we look at is: <placeholder-1/> Again this could result in "
"many rows to be deleted from <literal>computer</literal>. So the trigger "
"will again run many commands through the executor. The command generated by "
"the rule will be: <placeholder-2/> The plan for that command will again be "
"the nested loop over two index scans, only using a different index on "
"<literal>computer</literal>: <placeholder-3/> In any of these cases, the "
"extra commands from the rule system will be more or less independent from "
"the number of affected rows in a command."
msgstr ""
"В завершение взгляните на эту команду: <placeholder-1/> Она также может "
"привести к удалению множества строк из таблицы <literal>computer</literal>. "
"Поэтому триггер снова пропустит через исполнитель такое же множество команд. "
"Правило же выдаст следующую команду: <placeholder-2/> План для этой команды "
"снова будет содержать вложенный цикл по двум сканированиям индекса, но на "
"этот раз с другим индексом таблицы <literal>computer</literal>: "
"<placeholder-3/> Во всех этих случаях дополнительные команды будут более-"
"менее независимыми от числа затрагиваемых строк."

#. <para>
#.     Another situation is cases on <command>UPDATE</command> where it depends on the
#.     change of an attribute if an action should be performed or
#.     not. The only way to
#.     create a rule as in the shoelace_log example is to do it with
#.     a rule qualification. That results in an extra query that is
#.     performed always, even if the attribute of interest cannot
#.     change at all because it does not appear in the target list
#.     of the initial query. When this is enabled again, it will be
#.     one more advantage of rules over triggers. Optimization of
#.     a trigger must fail by definition in this case, because the
#.     fact that its actions will only be done when a specific attribute
#.     is updated is hidden in its functionality. The definition of
#.     a trigger only allows to specify it on row level, so whenever a
#.     row is touched, the trigger must be called to make its
#.     decision. The rule system will know it by looking up the
#.     target list and will suppress the additional query completely
#.     if the attribute isn't touched. So the rule, qualified or not,
#.     will only do its scans if there ever could be something to do.
#. </para>
#: rules.xml:2462(para)
msgid ""
"The summary is, rules will only be significantly slower than triggers if "
"their actions result in large and badly qualified joins, a situation where "
"the planner fails."
msgstr ""
"Таким образом, правила будут значительно медленнее триггеров, только если их "
"действия приводят к образованию больших и плохо связанных соединений, когда "
"планировщик оказывается бессилен."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: rules.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
