# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:14+0300\n"
"PO-Revision-Date: 2017-06-22 23:09+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:5(title)
msgid "PL/Python - Python Procedural Language"
msgstr "PL/Python — процедурный язык Python"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:7(indexterm)
msgid "<primary>PL/Python</primary>"
msgstr "<primary>PL/Python</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:8(indexterm)
msgid "<primary>Python</primary>"
msgstr "<primary>Python</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:10(para)
msgid ""
"The <application>PL/Python</application> procedural language allows "
"<productname>PostgreSQL</productname> functions to be written in the <ulink "
"url=\"http://www.python.org\">Python language</ulink>."
msgstr ""
"Процедурный язык <application>PL/Python</application> позволяет писать "
"функции <productname>PostgreSQL</productname> на <ulink url=\"http://www."
"python.org\">языке Python</ulink>."

#. +> REL_10
#: plpython.xml:16(para)
msgid ""
"To install PL/Python in a particular database, use <literal>CREATE EXTENSION "
"plpythonu</literal> (but see also <xref linkend=\"plpython-python23\"/>)."
msgstr ""
"Чтобы установить PL/Python в определённую базу данных, выполните команду "
"<literal>CREATE EXTENSION plpythonu</literal> (но смотрите также <xref remap="
"\"4\" linkend=\"plpython-python23\"/>)."

#. +> REL9_6_3 REL9_6
#: plpython.xml:16(para)
msgid ""
"To install PL/Python in a particular database, use <literal>CREATE EXTENSION "
"plpythonu</literal>, or from the shell command line use <literal>createlang "
"plpythonu <replaceable>dbname</replaceable></literal> (but see also <xref "
"linkend=\"plpython-python23\"/>)."
msgstr ""
"Чтобы установить PL/Python в определённую базу данных, выполните команду "
"<literal>CREATE EXTENSION plpythonu</literal>, либо запустите в оболочке "
"системы <literal>createlang plpythonu <replaceable>имя_данных</replaceable></"
"literal> (но смотрите также <xref remap=\"4\" linkend=\"plpython-python23\"/"
">)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:23(para)
msgid ""
"If a language is installed into <literal>template1</literal>, all "
"subsequently created databases will have the language installed "
"automatically."
msgstr ""
"Если язык устанавливается в <literal>template1</literal>, он будет "
"автоматически установлен во все создаваемые впоследствии базы данных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:29(para)
msgid ""
"PL/Python is only available as an <quote>untrusted</quote> language, meaning "
"it does not offer any way of restricting what users can do in it and is "
"therefore named <literal>plpythonu</literal>. A trusted variant "
"<literal>plpython</literal> might become available in the future if a secure "
"execution mechanism is developed in Python. The writer of a function in "
"untrusted PL/Python must take care that the function cannot be used to do "
"anything unwanted, since it will be able to do anything that could be done "
"by a user logged in as the database administrator. Only superusers can "
"create functions in untrusted languages such as <literal>plpythonu</literal>."
msgstr ""
"PL/Python представлен только в виде <quote>недоверенного</quote> языка, что "
"означает, что он никаким способом не ограничивает действия пользователей, и "
"поэтому он называется <literal>plpythonu</literal>. Доверенная вариация "
"<literal>plpython</literal> может появиться в будущем, если в Python будет "
"разработан безопасный механизм выполнения. Автор функции на недоверенном "
"языке PL/Python должен позаботиться о том, чтобы эту функцию нельзя было "
"использовать не по назначению, так как она может делать всё, что может "
"пользователь с правами администратора баз данных. Создавать функции на "
"недоверенных языках, таких как <literal>plpythonu</literal>, разрешено "
"только суперпользователям."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:43(para)
msgid ""
"Users of source packages must specially enable the build of PL/Python during "
"the installation process. (Refer to the installation instructions for more "
"information.) Users of binary packages might find PL/Python in a separate "
"subpackage."
msgstr ""
"Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/"
"Python в процессе установки. (За дополнительными сведениями обратитесь к "
"инструкциям по установке.) Пользователи двоичных пакетов могут найти PL/"
"Python в отдельном модуле."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:52(title)
msgid "Python 2 vs. Python 3"
msgstr "Python 2 и Python 3"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:64(para)
msgid ""
"The PostgreSQL language named <literal>plpython2u</literal> implements PL/"
"Python based on the Python 2 language variant."
msgstr ""
"Язык PostgreSQL с именем <literal>plpython2u</literal> представляет "
"реализацию PL/Python, основанную на вариации языка Python 2."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:71(para)
msgid ""
"The PostgreSQL language named <literal>plpython3u</literal> implements PL/"
"Python based on the Python 3 language variant."
msgstr ""
"Язык PostgreSQL с именем <literal>plpython3u</literal> представляет "
"реализацию PL/Python, основанную на вариации языка Python 3."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:78(para)
msgid ""
"The language named <literal>plpythonu</literal> implements PL/Python based "
"on the default Python language variant, which is currently Python 2. (This "
"default is independent of what any local Python installations might consider "
"to be their <quote>default</quote>, for example, what <filename>/usr/bin/"
"python</filename> might be.) The default will probably be changed to Python "
"3 in a distant future release of PostgreSQL, depending on the progress of "
"the migration to Python 3 in the Python community."
msgstr ""
"Язык с именем <literal>plpythonu</literal> представляет реализацию PL/"
"Python, основанную на версии Python по умолчанию, в данный момент это Python "
"2. (Этот выбор по умолчанию не зависит от того, какая версия считается "
"локальной версией <quote>по умолчанию</quote>, например, на какую версию "
"указывает <filename>/usr/bin/python</filename>.) Выбор по умолчанию в "
"отдалённом будущем выпуске PostgreSQL может быть сменён на Python 3, в "
"зависимости от того, как будет происходить переход на Python 3 в сообществе "
"Python."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:54(para)
msgid ""
"PL/Python supports both the Python 2 and Python 3 language variants. (The "
"PostgreSQL installation instructions might contain more precise information "
"about the exact supported minor versions of Python.) Because the Python 2 "
"and Python 3 language variants are incompatible in some important aspects, "
"the following naming and transitioning scheme is used by PL/Python to avoid "
"mixing them: <placeholder-1/> This scheme is analogous to the "
"recommendations in <ulink url=\"http://www.python.org/dev/peps/pep-0394/"
"\">PEP 394</ulink> regarding the naming and transitioning of the "
"<command>python</command> command."
msgstr ""
"PL/Python поддерживает две вариации языка: Python 2 и Python 3. (Более "
"точная информация о поддерживаемых второстепенных версиях Python может "
"содержаться в инструкциях по установке PostgreSQL.) Так как языки Python 2 и "
"Python 3 несовместимы в некоторых важных аспектах, во избежание смешения их "
"в PL/Python применяется следующая схема именования: <placeholder-1/> Эта "
"схема аналогична рекомендациям, данным в <ulink url=\"http://www.python.org/"
"dev/peps/pep-0394/\">PEP 394</ulink>, по выбору имени команды "
"<command>python</command> и переходу с версии на версию."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:97(para)
msgid ""
"It depends on the build configuration or the installed packages whether PL/"
"Python for Python 2 or Python 3 or both are available."
msgstr ""
"Будет ли доступен PL/Python для Python 2 или для Python 3, либо сразу для "
"обеих версий, зависит от конфигурации сборки или установленных пакетов."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:103(para)
msgid ""
"The built variant depends on which Python version was found during the "
"installation or which version was explicitly set using the <envar>PYTHON</"
"envar> environment variable; see <xref linkend=\"install-procedure\"/>. To "
"make both variants of PL/Python available in one installation, the source "
"tree has to be configured and built twice."
msgstr ""
"Какая вариация будет собрана, зависит от того, как версия Python будет "
"найдена при установке или будет задана в переменной окружения <envar>PYTHON</"
"envar>; см. <xref remap=\"4\" linkend=\"install-procedure\"/>. Чтобы в одной "
"инсталляции присутствовали обе вариации PL/Python, необходимо "
"сконфигурировать и настроить дерево исходного кода дважды."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:118(para)
msgid ""
"Existing users and users who are currently not interested in Python 3 use "
"the language name <literal>plpythonu</literal> and don't have to change "
"anything for the foreseeable future. It is recommended to gradually "
"<quote>future-proof</quote> the code via migration to Python 2.6/2.7 to "
"simplify the eventual migration to Python 3."
msgstr ""
"Существующие пользователи и пользователи, которым в настоящее время "
"неинтересен Python 3, могут выбрать имя языка <literal>plpythonu</literal> и "
"им не придётся ничего менять в обозримом будущем. Чтобы упростить миграцию "
"на Python 3, которая произойдёт в конце концов, рекомендуется постепенно "
"проверять <quote>готовность к будущему</quote> кода, обновляя его до версий "
"Python 2.6/2.7."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:127(para)
msgid ""
"In practice, many PL/Python functions will migrate to Python 3 with few or "
"no changes."
msgstr ""
"На практике многие функции PL/Python можно мигрировать на Python 3 с "
"минимальными изменениями или вовсе без изменений."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:134(para)
msgid ""
"Users who know that they have heavily Python 2 dependent code and don't plan "
"to ever change it can make use of the <literal>plpython2u</literal> language "
"name. This will continue to work into the very distant future, until Python "
"2 support might be completely dropped by PostgreSQL."
msgstr ""
"Пользователи, знающие, что их код очень сильно зависит от Python 2, и не "
"планирующие когда-либо менять его, могут использовать имя языка "
"<literal>plpython2u</literal>. Это будет работать ещё очень и очень долго, "
"пока в PostgreSQL не будет полностью ликвидирована поддержка Python 2."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:144(para)
msgid ""
"Users who want to dive into Python 3 can use the <literal>plpython3u</"
"literal> language name, which will keep working forever by today's "
"standards. In the distant future, when Python 3 might become the default, "
"they might like to remove the <quote>3</quote> for aesthetic reasons."
msgstr ""
"Пользователи, желающие погрузиться в Python 3, могут выбрать имя языка "
"<literal>plpython3u</literal>, и их код будет работать всегда, по "
"сегодняшним стандартам. В отдалённом будущем, когда версией по умолчанию "
"может стать Python 3, цифру <quote>3</quote> из имени языка можно будет "
"убрать из эстетических соображений."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:154(para)
msgid ""
"Daredevils, who want to build a Python-3-only operating system environment, "
"can change the contents of <link linkend=\"catalog-pg-pltemplate"
"\"><structname>pg_pltemplate</structname></link> to make <literal>plpythonu</"
"literal> be equivalent to <literal>plpython3u</literal>, keeping in mind "
"that this would make their installation incompatible with most of the rest "
"of the world."
msgstr ""
"Смельчаки, желающие уже сегодня получить операционное окружение только с "
"Python 3, могут модифицировать <link linkend=\"catalog-pg-pltemplate"
"\"><structname>pg_pltemplate</structname></link>, чтобы имя "
"<literal>plpythonu</literal> было равнозначно <literal>plpython3u</literal>, "
"отдавая себе отчёт в том, что такая инсталляция будет несовместима с "
"остальным миром."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:113(para)
msgid ""
"This results in the following usage and migration strategy: <placeholder-1/>"
msgstr ""
"В результате формируется такая стратегия использования и смены определённой "
"версии: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:167(para)
msgid ""
"See also the document <ulink url=\"http://docs.python.org/py3k/whatsnew/3.0."
"html\">What's New In Python 3.0</ulink> for more information about porting "
"to Python 3."
msgstr ""
"Дополнительную информацию о переходе на Python 3 можно также найти в "
"описании <ulink url=\"http://docs.python.org/py3k/whatsnew/3.0.html\">Что "
"нового в Python 3.0</ulink>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:174(para)
msgid ""
"It is not allowed to use PL/Python based on Python 2 and PL/Python based on "
"Python 3 in the same session, because the symbols in the dynamic modules "
"would clash, which could result in crashes of the PostgreSQL server process. "
"There is a check that prevents mixing Python major versions in a session, "
"which will abort the session if a mismatch is detected. It is possible, "
"however, to use both PL/Python variants in the same database, from separate "
"sessions."
msgstr ""
"Использовать PL/Python на базе Python 2 и PL/Python на базе Python 3 в одном "
"сеансе нельзя, так как это приведёт к конфликту символов в динамических "
"модулях, что может повлечь сбой серверного процесса PostgreSQL. В системе "
"есть проверка, предотвращающая смешение основных версий Python в одном "
"сеансе, которая прервёт сеанс при выявлении расхождения. Однако использовать "
"обе вариации в одной базе данных всё же возможно, обращаясь к ним в разных "
"сеансах."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:186(title)
msgid "PL/Python Functions"
msgstr "Функции на PL/Python"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:192(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)\n"
"  RETURNS <replaceable>return-type</replaceable>\n"
"AS $$\n"
"  # PL/Python function body\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)\n"
"  RETURNS <replaceable>return-type</replaceable>\n"
"AS $$\n"
"  # Тело функции на PL/Python\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:188(para)
msgid ""
"Functions in PL/Python are declared via the standard <xref linkend=\"sql-"
"createfunction\"/> syntax: <placeholder-1/>"
msgstr ""
"Функции на PL/Python объявляются стандартным образом с помощью команды <xref "
"linkend=\"sql-createfunction\"/>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:201(para)
msgid ""
"The body of a function is simply a Python script. When the function is "
"called, its arguments are passed as elements of the list <varname>args</"
"varname>; named arguments are also passed as ordinary variables to the "
"Python script. Use of named arguments is usually more readable. The result "
"is returned from the Python code in the usual way, with <literal>return</"
"literal> or <literal>yield</literal> (in case of a result-set statement). If "
"you do not provide a return value, Python returns the default <symbol>None</"
"symbol>. <application>PL/Python</application> translates Python's "
"<symbol>None</symbol> into the SQL null value."
msgstr ""
"Тело функции содержит просто скрипт на языке Python. Когда вызывается "
"функция, её аргументы передаются в виде элементов списка <varname>args</"
"varname>; именованные аргументы также передаются скрипту Python как обычные "
"переменные. С применением именованных аргументов скрипт обычно лучше "
"читается. Результат из кода Python возвращается обычным способом, командой "
"<literal>return</literal> или <literal>yield</literal> (в случае функции, "
"возвращающей множество). Если возвращаемое значение не определено, Python "
"возвращает <symbol>None</symbol>. Исполнитель <application>PL/Python</"
"application> преобразует <symbol>None</symbol> языка Python в значение NULL "
"языка SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:218(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION pymax (a integer, b integer)\n"
"  RETURNS integer\n"
"AS $$\n"
"  if a &gt; b:\n"
"    return a\n"
"  return b\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION pymax (a integer, b integer)\n"
"  RETURNS integer\n"
"AS $$\n"
"  if a &gt; b:\n"
"    return a\n"
"  return b\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:231(programlisting)
#, no-wrap
msgid ""
"def __plpython_procedure_pymax_23456():\n"
"  if a &gt; b:\n"
"    return a\n"
"  return b"
msgstr ""
"def __plpython_procedure_pymax_23456():\n"
"  if a &gt; b:\n"
"    return a\n"
"  return b"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:214(para)
msgid ""
"For example, a function to return the greater of two integers can be defined "
"as: <placeholder-1/> The Python code that is given as the body of the "
"function definition is transformed into a Python function. For example, the "
"above results in: <placeholder-2/> assuming that 23456 is the OID assigned "
"to the function by <productname>PostgreSQL</productname>."
msgstr ""
"Например, функцию, возвращающее большее из двух целых чисел, можно "
"определить так: <placeholder-1/> Код на Python, заданный в качестве тела "
"объявляемой функции, становится телом функции Python. Например, для "
"показанного выше объявления получается функция: <placeholder-2/> Здесь 23456 "
"— это OID, который <productname>PostgreSQL</productname> присвоил данной "
"функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:249(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION pystrip(x text)\n"
"  RETURNS text\n"
"AS $$\n"
"  x = x.strip()  # error\n"
"  return x\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION pystrip(x text)\n"
"  RETURNS text\n"
"AS $$\n"
"  x = x.strip()  # ошибка\n"
"  return x\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:264(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION pystrip(x text)\n"
"  RETURNS text\n"
"AS $$\n"
"  global x\n"
"  x = x.strip()  # ok now\n"
"  return x\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION pystrip(x text)\n"
"  RETURNS text\n"
"AS $$\n"
"  global x\n"
"  x = x.strip()  # теперь всё в порядке\n"
"  return x\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:242(para)
msgid ""
"The arguments are set as global variables. Because of the scoping rules of "
"Python, this has the subtle consequence that an argument variable cannot be "
"reassigned inside the function to the value of an expression that involves "
"the variable name itself, unless the variable is redeclared as global in the "
"block. For example, the following won't work: <placeholder-1/> because "
"assigning to <varname>x</varname> makes <varname>x</varname> a local "
"variable for the entire block, and so the <varname>x</varname> on the right-"
"hand side of the assignment refers to a not-yet-assigned local variable "
"<varname>x</varname>, not the PL/Python function parameter. Using the "
"<literal>global</literal> statement, this can be made to work: "
"<placeholder-2/> But it is advisable not to rely on this implementation "
"detail of PL/Python. It is better to treat the function parameters as read-"
"only."
msgstr ""
"Значения аргументов задаются в глобальных переменных. Согласно правилам "
"видимости в Python, тонким следствием этого является то, что переменной "
"аргумента нельзя присвоить внутри функции выражение, включающее имя самой "
"этой переменной, если только эта переменная не объявлена глобальной в "
"текущем блоке. Например, следующий код не будет работать: <placeholder-1/> "
"так как присвоение <varname>x</varname> значения делает <varname>x</varname> "
"локальной переменной для всего блока, и при этом <varname>x</varname> в "
"правой части присваивания оказывается ещё не определённой локальной "
"переменной <varname>x</varname>, а не параметром функции PL/Python. Добавив "
"оператор <literal>global</literal>, это можно исправить: <placeholder-2/> "
"Однако рекомендуется не полагаться на такие особенности реализации PL/"
"Python, а принять, что параметры функции предназначены только для чтения."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:280(title)
msgid "Data Values"
msgstr "Значения данных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:281(para)
msgid ""
"Generally speaking, the aim of PL/Python is to provide a <quote>natural</"
"quote> mapping between the PostgreSQL and the Python worlds. This informs "
"the data mapping rules described below."
msgstr ""
"Вообще говоря, цель исполнителя PL/Python — обеспечить <quote>естественное</"
"quote> соответствие между мирами PostgreSQL и Python. Этим объясняется выбор "
"правил сопоставления данных, описанных ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:289(title)
msgid "Data Type Mapping"
msgstr "Сопоставление типов данных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:296(para)
msgid ""
"PostgreSQL <type>boolean</type> is converted to Python <type>bool</type>."
msgstr ""
"Тип PostgreSQL <type>boolean</type> преобразуется в <type>bool</type> языка "
"Python."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:302(para)
msgid ""
"PostgreSQL <type>smallint</type> and <type>int</type> are converted to "
"Python <type>int</type>. PostgreSQL <type>bigint</type> and <type>oid</type> "
"are converted to <type>long</type> in Python 2 and to <type>int</type> in "
"Python 3."
msgstr ""
"Типы PostgreSQL <type>smallint</type> и <type>int</type> преобразуются в тип "
"<type>int</type> языка Python. Типы PostgreSQL <type>bigint</type> и "
"<type>oid</type> становятся типами <type>long</type> в Python 2 и <type>int</"
"type> в Python 3."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:312(para)
msgid ""
"PostgreSQL <type>real</type> and <type>double</type> are converted to Python "
"<type>float</type>."
msgstr ""
"Типы PostgreSQL <type>real</type> и <type>double</type> преобразуются в тип "
"<type>float</type> языка Python."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:319(para)
msgid ""
"PostgreSQL <type>numeric</type> is converted to Python <type>Decimal</type>. "
"This type is imported from the <literal>cdecimal</literal> package if that "
"is available. Otherwise, <literal>decimal.Decimal</literal> from the "
"standard library will be used. <literal>cdecimal</literal> is significantly "
"faster than <literal>decimal</literal>. In Python 3.3 and up, however, "
"<literal>cdecimal</literal> has been integrated into the standard library "
"under the name <literal>decimal</literal>, so there is no longer any "
"difference."
msgstr ""
"Тип PostgreSQL <type>numeric</type> преобразуется в <type>Decimal</type> "
"среды Python. Этот тип импортируется из пакета <literal>cdecimal</literal>, "
"при его наличии. В противном случае используется <literal>decimal.Decimal</"
"literal> из стандартной библиотеки. Тип <literal>cdecimal</literal> работает "
"значительно быстрее, чем <literal>decimal</literal>. Однако в Python версии "
"3.3 и выше тип <literal>cdecimal</literal> включается в стандартную "
"библиотеку под именем <literal>decimal</literal>, так что теперь этого "
"различия нет."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:334(para)
msgid ""
"PostgreSQL <type>bytea</type> is converted to Python <type>str</type> in "
"Python 2 and to <type>bytes</type> in Python 3. In Python 2, the string "
"should be treated as a byte sequence without any character encoding."
msgstr ""
"Тип PostgreSQL <type>bytea</type> становится типом <type>str</type> в Python "
"2 и <type>bytes</type> в Python 3. В Python 2 такую строку следует "
"воспринимать как последовательность байт без какой-либо определённой "
"кодировки символов."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:343(para)
msgid ""
"All other data types, including the PostgreSQL character string types, are "
"converted to a Python <type>str</type>. In Python 2, this string will be in "
"the PostgreSQL server encoding; in Python 3, it will be a Unicode string "
"like all strings."
msgstr ""
"Все другие типы данных, включая типы символьных строк PostgreSQL, "
"преобразуются в тип <type>str</type> языка Python. В Python 2 эта строка "
"будет передаваться в кодировке сервера PostgreSQL; в Python 3 это будет "
"строка в Unicode, как и все строки."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:352(para) plpython.xml:405(para)
msgid "For nonscalar data types, see below."
msgstr "Информация о нескалярных типах данных приведена ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:290(para)
msgid ""
"When a PL/Python function is called, its arguments are converted from their "
"PostgreSQL data type to a corresponding Python type: <placeholder-1/>"
msgstr ""
"Когда вызывается функция PL/Python, её аргументы преобразуются из типа "
"PostgreSQL в соответствующий тип Python по таким правилам: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:365(para)
msgid ""
"When the PostgreSQL return type is <type>boolean</type>, the return value "
"will be evaluated for truth according to the <emphasis>Python</emphasis> "
"rules. That is, 0 and empty string are false, but notably <literal>'f'</"
"literal> is true."
msgstr ""
"Когда тип результата функции в PostgreSQL — <type>boolean</type>, "
"возвращаемое значение приводится к логическому типу по правилам, принятым в "
"<emphasis>Python</emphasis>. То есть false будет возвращено для 0 и пустой "
"строки, но, обратите внимание, для <literal>'f'</literal> будет возвращено "
"true."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:374(para)
msgid ""
"When the PostgreSQL return type is <type>bytea</type>, the return value will "
"be converted to a string (Python 2) or bytes (Python 3) using the respective "
"Python built-ins, with the result being converted to <type>bytea</type>."
msgstr ""
"Когда тип результата функции PostgreSQL — <type>bytea</type>, возвращаемое "
"значение будет преобразовано в строку (Python 2) или набор байт (Python 3), "
"используя встроенные средства Python, а затем будет приведено к типу "
"<type>bytea</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:383(para)
msgid ""
"For all other PostgreSQL return types, the return value is converted to a "
"string using the Python built-in <literal>str</literal>, and the result is "
"passed to the input function of the PostgreSQL data type. (If the Python "
"value is a <type>float</type>, it is converted using the <literal>repr</"
"literal> built-in instead of <literal>str</literal>, to avoid loss of "
"precision.)"
msgstr ""
"Для всех других типов результата PostgreSQL возвращаемое значение "
"преобразуется в строку с помощью встроенной в Python функции <literal>str</"
"literal>, и полученная строка передаётся функции ввода типа данных "
"PostgreSQL. (Если значение в Python имеет тип <type>float</type>, оно "
"преобразуется встроенной функцией <literal>repr</literal>, а не "
"<literal>str</literal>, для недопущения потери точности.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:392(para)
msgid ""
"Strings in Python 2 are required to be in the PostgreSQL server encoding "
"when they are passed to PostgreSQL. Strings that are not valid in the "
"current server encoding will raise an error, but not all encoding mismatches "
"can be detected, so garbage data can still result when this is not done "
"correctly. Unicode strings are converted to the correct encoding "
"automatically, so it can be safer and more convenient to use those. In "
"Python 3, all strings are Unicode strings."
msgstr ""
"Из кода Python 2 строки должны передаваться в PostgreSQL в кодировке сервера "
"PostgreSQL. При передаче строки, неприемлемой для текущей кодировки сервера, "
"возникает ошибка, но не все несоответствия кодировки могут быть выявлены, "
"так что с некорректной кодировкой всё же могут быть получены нечитаемые "
"строки. Строки Unicode переводятся в нужную кодировку автоматически, так что "
"использовать их может быть безопаснее и удобнее. В Python 3 все строки имеют "
"кодировку Unicode."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:359(para)
msgid ""
"When a PL/Python function returns, its return value is converted to the "
"function's declared PostgreSQL return data type as follows: <placeholder-1/> "
"Note that logical mismatches between the declared PostgreSQL return type and "
"the Python data type of the actual return object are not flagged; the value "
"will be converted in any case."
msgstr ""
"При завершении функции PL/Python её значение результата преобразуется в тип "
"данных, объявленный как тип результата в PostgreSQL, следующим образом: "
"<placeholder-1/> Заметьте, что логические несоответствия между объявленным в "
"PostgreSQL типом результата и типом фактически возвращаемого объекта Python "
"игнорируются — значение преобразуется в любом случае."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:418(title)
msgid "Null, None"
msgstr "Null, None"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:420(indexterm)
msgid ""
"<primary>null value</primary><secondary sortas=\"PL/Python\">in PL/Python</"
"secondary>"
msgstr ""
"<primary>NULL-значение</primary> <secondary sortas=\"PL/Python\">в PL/"
"Python</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:431(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION pymax (a integer, b integer)\n"
"  RETURNS integer\n"
"AS $$\n"
"  if (a is None) or (b is None):\n"
"    return None\n"
"  if a &gt; b:\n"
"    return a\n"
"  return b\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION pymax (a integer, b integer)\n"
"  RETURNS integer\n"
"AS $$\n"
"  if (a is None) or (b is None):\n"
"    return None\n"
"  if a &gt; b:\n"
"    return a\n"
"  return b\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:419(para)
msgid ""
"If an SQL null value<placeholder-1/> is passed to a function, the argument "
"value will appear as <symbol>None</symbol> in Python. For example, the "
"function definition of <function>pymax</function> shown in <xref linkend="
"\"plpython-funcs\"/> will return the wrong answer for null inputs. We could "
"add <literal>STRICT</literal> to the function definition to make "
"<productname>PostgreSQL</productname> do something more reasonable: if a "
"null value is passed, the function will not be called at all, but will just "
"return a null result automatically. Alternatively, we could check for null "
"inputs in the function body: <placeholder-2/> As shown above, to return an "
"SQL null value from a PL/Python function, return the value <symbol>None</"
"symbol>. This can be done whether the function is strict or not."
msgstr ""
"Если функции передаётся значение SQL NULL<placeholder-1/>, в Python "
"значением этого аргумента будет <symbol>None</symbol>. Например, функция "
"<function>pymax</function>, определённая как показано в <xref linkend="
"\"plpython-funcs\"/>, возвратит неверный ответ, получив аргументы NULL. Мы "
"могли бы добавить указание <literal>STRICT</literal> в определение функции, "
"чтобы <productname>PostgreSQL</productname> поступал немного разумнее: при "
"передаче значения NULL функция вовсе не будет вызываться, будет сразу "
"возвращён результат NULL. С другой стороны, мы могли бы проверить аргументы "
"на NULL в теле функции: <placeholder-2/> Как показано выше, чтобы выдать из "
"функции PL/Python значение SQL NULL, нужно вернуть значение <symbol>None</"
"symbol>. Это можно сделать и в строгой, и в нестрогой функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:450(title)
msgid "Arrays, Lists"
msgstr "Массивы, списки"

#. +> REL_10
#: plpython.xml:456(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION return_arr()\n"
"  RETURNS int[]\n"
"AS $$\n"
"return [1, 2, 3, 4, 5]\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT return_arr();\n"
" return_arr  \n"
"-------------\n"
" {1,2,3,4,5}\n"
"(1 row)"
msgstr ""
"CREATE FUNCTION return_arr()\n"
"  RETURNS int[]\n"
"AS $$\n"
"return [1, 2, 3, 4, 5]\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT return_arr();\n"
" return_arr  \n"
"-------------\n"
" {1,2,3,4,5}\n"
"(1 row)"

#. +> REL_10
#: plpython.xml:475(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$\n"
"plpy.info(x, type(x))\n"
"return x\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);\n"
"INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)\n"
" test_type_conversion_array_int4 \n"
"---------------------------------\n"
" {{1,2,3},{4,5,6}}\n"
"(1 row)"
msgstr ""
"CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$\n"
"plpy.info(x, type(x))\n"
"return x\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);\n"
"INFO:  ([[1, 2, 3], [4, 5, 6]], &lt;type 'list'&gt;)\n"
" test_type_conversion_array_int4 \n"
"---------------------------------\n"
" {{1,2,3},{4,5,6}}\n"
"(1 row)"

#. +> REL_10
#: plpython.xml:451(para)
msgid ""
"SQL array values are passed into PL/Python as a Python list. To return an "
"SQL array value out of a PL/Python function, return a Python list: "
"<placeholder-1/> Multidimensional arrays are passed into PL/Python as nested "
"Python lists. A 2-dimensional array is a list of lists, for example. When "
"returning a multi-dimensional SQL array out of a PL/Python function, the "
"inner lists at each level must all be of the same size. For example: "
"<placeholder-2/> Other Python sequences, like tuples, are also accepted for "
"backwards-compatibility with PostgreSQL versions 9.6 and below, when multi-"
"dimensional arrays were not supported. However, they are always treated as "
"one-dimensional arrays, because they are ambiguous with composite types. For "
"the same reason, when a composite type is used in a multi-dimensional array, "
"it must be represented by a tuple, rather than a list."
msgstr ""
"Значения массивов SQL передаются в PL/Python в виде списка Python. Чтобы "
"вернуть значение массива SQL из функции PL/Python, возвратите список Python: "
"<placeholder-1/> Многомерные массивы передаются в PL/Python в виде вложенных "
"списков Python. Например, двухмерный массив представляется как список "
"списков. При передаче многомерного массива SQL из функции PL/Python "
"необходимо, чтобы все внутренние списки на каждом уровне имели одинаковый "
"размер. Например: <placeholder-2/> Другие последовательности Python, "
"например кортежи, тоже принимаются для обратной совместимости с PostgreSQL "
"версии 9.6 и ниже (где многомерные массивы не поддерживались). Однако они "
"всегда воспринимаются как одномерные массивы, чтобы не возникало "
"неоднозначности с составными типами. По этой же причине когда в многомерном "
"массиве используется составной тип, он должен представляться как кортеж, а "
"не список."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:501(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION return_str_arr()\n"
"  RETURNS varchar[]\n"
"AS $$\n"
"return \"hello\"\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT return_str_arr();\n"
" return_str_arr\n"
"----------------\n"
" {h,e,l,l,o}\n"
"(1 row)"
msgstr ""
"CREATE FUNCTION return_str_arr()\n"
"  RETURNS varchar[]\n"
"AS $$\n"
"return \"hello\"\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT return_str_arr();\n"
" return_str_arr\n"
"----------------\n"
" {h,e,l,l,o}\n"
"(1 row)"

#. +> REL_10
#: plpython.xml:497(para)
msgid ""
"Note that in Python, strings are sequences, which can have undesirable "
"effects that might be familiar to Python programmers: <placeholder-1/>"
msgstr ""
"Учтите, что в Python и строки являются последовательностями, что может "
"давать неожиданные эффекты, хорошо знакомые тем, кто программирует на "
"Python: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:518(title)
msgid "Composite Types"
msgstr "Составные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:525(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE employee (\n"
"  name text,\n"
"  salary integer,\n"
"  age integer\n"
");\n"
"\n"
"CREATE FUNCTION overpaid (e employee)\n"
"  RETURNS boolean\n"
"AS $$\n"
"  if e[\"salary\"] &gt; 200000:\n"
"    return True\n"
"  if (e[\"age\"] &lt; 30) and (e[\"salary\"] &gt; 100000):\n"
"    return True\n"
"  return False\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE TABLE employee (\n"
"  name text,\n"
"  salary integer,\n"
"  age integer\n"
");\n"
"\n"
"CREATE FUNCTION overpaid (e employee)\n"
"  RETURNS boolean\n"
"AS $$\n"
"  if e[\"salary\"] &gt; 200000:\n"
"    return True\n"
"  if (e[\"age\"] &lt; 30) and (e[\"salary\"] &gt; 100000):\n"
"    return True\n"
"  return False\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:519(para)
msgid ""
"Composite-type arguments are passed to the function as Python mappings. The "
"element names of the mapping are the attribute names of the composite type. "
"If an attribute in the passed row has the null value, it has the value "
"<symbol>None</symbol> in the mapping. Here is an example: <placeholder-1/>"
msgstr ""
"Аргументы составного типа передаются функции в виде сопоставлений Python. "
"Именами элементов сопоставления являются атрибуты составного типа. Если "
"атрибут в переданной строке имеет значение NULL, он передаётся в "
"сопоставлении значением <symbol>None</symbol>. Пример работы с составным "
"типом: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:548(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE named_value AS (\n"
"  name   text,\n"
"  value  integer\n"
");"
msgstr ""
"CREATE TYPE named_value AS (\n"
"  name   text,\n"
"  value  integer\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:559(term)
msgid ""
"Sequence type (a tuple or list, but not a set because it is not indexable)"
msgstr ""
"Последовательность (кортеж или список, но не множество, так как оно не "
"индексируется)"

#. +> REL_10
#: plpython.xml:568(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  return ( name, value )\n"
"  # or alternatively, as tuple: return [ name, value ]\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  return ( name, value )\n"
"  # или альтернативный вариант, в виде кортежа: return [ name, value ]\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:562(para)
msgid ""
"Returned sequence objects must have the same number of items as the "
"composite result type has fields. The item with index 0 is assigned to the "
"first field of the composite type, 1 to the second and so on. For example: "
"<placeholder-1/> To return a SQL null for any column, insert <symbol>None</"
"symbol> at the corresponding position."
msgstr ""
"В возвращаемых объектах последовательностей должно быть столько элементов, "
"сколько полей в составном типе результата. Элемент с индексом 0 "
"присваивается первому полю составного типа, с индексом 1 — второму и т. д. "
"Например: <placeholder-1/> Чтобы выдать SQL NULL для какого-нибудь столбца, "
"вставьте в соответствующую позицию <symbol>None</symbol>."

#. +> REL_10
#: plpython.xml:580(para)
msgid ""
"When an array of composite types is returned, it cannot be returned as a "
"list, because it is ambiguous whether the Python list represents a composite "
"type, or another array dimension."
msgstr ""
"Когда возвращается массив составных значений, его нельзя представить в виде "
"списка, так как невозможно однозначно определить, представляет ли список "
"Python составной тип или ещё одну размерность массива."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:589(term)
msgid "Mapping (dictionary)"
msgstr "Сопоставление (словарь)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:595(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  return { \"name\": name, \"value\": value }\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  return { \"name\": name, \"value\": value }\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:591(para)
msgid ""
"The value for each result type column is retrieved from the mapping with the "
"column name as key. Example: <placeholder-1/> Any extra dictionary key/value "
"pairs are ignored. Missing keys are treated as errors. To return a SQL null "
"value for any column, insert <symbol>None</symbol> with the corresponding "
"column name as the key."
msgstr ""
"Значение столбца результата получается из сопоставления, в котором ключом "
"является имя столбца. Например: <placeholder-1/> Любые дополнительные пары "
"ключ/значение в словаре игнорируются, а отсутствие нужных ключей считается "
"ошибкой. Чтобы выдать SQL NULL для какого-нибудь столбца, вставьте "
"<symbol>None</symbol> с именем соответствующего столбца в качестве ключа."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:612(term)
msgid "Object (any object providing method <literal>__getattr__</literal>)"
msgstr "Объект (любой объект с методом <literal>__getattr__</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:618(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  class named_value:\n"
"    def __init__ (self, n, v):\n"
"      self.name = n\n"
"      self.value = v\n"
"  return named_value(name, value)\n"
"\n"
"  # or simply\n"
"  class nv: pass\n"
"  nv.name = name\n"
"  nv.value = value\n"
"  return nv\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  class named_value:\n"
"    def __init__ (self, n, v):\n"
"      self.name = n\n"
"      self.value = v\n"
"  return named_value(name, value)\n"
"\n"
"  # или просто\n"
"  class nv: pass\n"
"  nv.name = name\n"
"  nv.value = value\n"
"  return nv\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:614(para)
msgid "This works the same as a mapping. Example: <placeholder-1/>"
msgstr "Объект передаётся аналогично сопоставлению. Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:544(para)
msgid ""
"There are multiple ways to return row or composite types from a Python "
"function. The following examples assume we have: <placeholder-1/> A "
"composite result can be returned as a: <placeholder-2/>"
msgstr ""
"Возвратить составной тип или строку таблицы из функции Python можно "
"несколькими способами. В следующих примерах предполагается, что у нас "
"объявлен тип: <placeholder-1/> Результат этого типа можно вернуть как: "
"<placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:643(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$\n"
"return (1, 2)\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT * FROM multiout_simple();"
msgstr ""
"CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$\n"
"return (1, 2)\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT * FROM multiout_simple();"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:641(para)
msgid ""
"Functions with <literal>OUT</literal> parameters are also supported. For "
"example: <placeholder-1/>"
msgstr ""
"Также поддерживаются функции с параметрами <literal>OUT</literal> "
"(выходными). Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:654(title)
msgid "Set-returning Functions"
msgstr "Функции, возвращающие множества"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:661(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE greeting AS (\n"
"  how text,\n"
"  who text\n"
");"
msgstr ""
"CREATE TYPE greeting AS (\n"
"  how text,\n"
"  who text\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:672(term)
msgid "Sequence type (tuple, list, set)"
msgstr "Последовательность (кортеж, список, множество)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:675(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION greet (how text)\n"
"  RETURNS SETOF greeting\n"
"AS $$\n"
"  # return tuple containing lists as composite types\n"
"  # all other combinations work also\n"
"  return ( [ how, \"World\" ], [ how, \"PostgreSQL\" ], [ how, \"PL/Python\" ] )\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION greet (how text)\n"
"  RETURNS SETOF greeting\n"
"AS $$\n"
"  # возвращает кортеж, содержащий списки в качестве составных типов\n"
"  # также будут работать и остальные комбинации\n"
"  return ( [ how, \"World\" ], [ how, \"PostgreSQL\" ], [ how, \"PL/Python\" ] )\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:689(term)
msgid ""
"Iterator (any object providing <symbol>__iter__</symbol> and <symbol>next</"
"symbol> methods)"
msgstr ""
"Итератор (любой объект, реализующий методы <symbol>__iter__</symbol> и "
"<symbol>next</symbol>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:693(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION greet (how text)\n"
"  RETURNS SETOF greeting\n"
"AS $$\n"
"  class producer:\n"
"    def __init__ (self, how, who):\n"
"      self.how = how\n"
"      self.who = who\n"
"      self.ndx = -1\n"
"\n"
"    def __iter__ (self):\n"
"      return self\n"
"\n"
"    def next (self):\n"
"      self.ndx += 1\n"
"      if self.ndx == len(self.who):\n"
"        raise StopIteration\n"
"      return ( self.how, self.who[self.ndx] )\n"
"\n"
"  return producer(how, [ \"World\", \"PostgreSQL\", \"PL/Python\" ])\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION greet (how text)\n"
"  RETURNS SETOF greeting\n"
"AS $$\n"
"  class producer:\n"
"    def __init__ (self, how, who):\n"
"      self.how = how\n"
"      self.who = who\n"
"      self.ndx = -1\n"
"\n"
"    def __iter__ (self):\n"
"      return self\n"
"\n"
"    def next (self):\n"
"      self.ndx += 1\n"
"      if self.ndx == len(self.who):\n"
"        raise StopIteration\n"
"      return ( self.how, self.who[self.ndx] )\n"
"\n"
"  return producer(how, [ \"World\", \"PostgreSQL\", \"PL/Python\" ])\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:720(term)
msgid "Generator (<literal>yield</literal>)"
msgstr "Генератор (<literal>yield</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:723(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION greet (how text)\n"
"  RETURNS SETOF greeting\n"
"AS $$\n"
"  for who in [ \"World\", \"PostgreSQL\", \"PL/Python\" ]:\n"
"    yield ( how, who )\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION greet (how text)\n"
"  RETURNS SETOF greeting\n"
"AS $$\n"
"  for who in [ \"World\", \"PostgreSQL\", \"PL/Python\" ]:\n"
"    yield ( how, who )\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:655(para)
msgid ""
"A <application>PL/Python</application> function can also return sets of "
"scalar or composite types. There are several ways to achieve this because "
"the returned object is internally turned into an iterator. The following "
"examples assume we have composite type: <placeholder-1/> A set result can be "
"returned from a: <placeholder-2/>"
msgstr ""
"Функция <application>PL/Python</application> также может возвращать "
"множества, содержащие скалярные и составные типы. Это можно осуществить "
"разными способами, так как возвращаемый объект внутри превращается в "
"итератор. В следующих примерах предполагается, что у нас есть составной тип: "
"<placeholder-1/> Множество в качестве результата можно возвратить, применив: "
"<placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:742(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$\n"
"return [(1, 2)] * n\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT * FROM multiout_simple_setof(3);"
msgstr ""
"CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$\n"
"return [(1, 2)] * n\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT * FROM multiout_simple_setof(3);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:738(para)
msgid ""
"Set-returning functions with <literal>OUT</literal> parameters (using "
"<literal>RETURNS SETOF record</literal>) are also supported. For example: "
"<placeholder-1/>"
msgstr ""
"Также поддерживаются функции, возвращающие множества, с параметрами "
"<literal>OUT</literal> (объявленные с <literal>RETURNS SETOF record</"
"literal>). Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:754(title)
msgid "Sharing Data"
msgstr "Совместное использование данных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:760(indexterm)
msgid "<primary>global data</primary> <secondary>in PL/Python</secondary>"
msgstr ""
"<primary>глобальные данные</primary> <secondary>в PL/Python</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:755(para)
msgid ""
"The global dictionary <varname>SD</varname> is available to store data "
"between function calls. This variable is private static data. The global "
"dictionary <varname>GD</varname> is public data, available to all Python "
"functions within a session. Use with care.<placeholder-1/>"
msgstr ""
"Для хранения данных между вызовами функции предусмотрен глобальный словарь "
"<varname>SD</varname>, объявленный как частный статический. Для размещения "
"публичных данных предназначен глобальный словарь <varname>GD</varname>, "
"доступный всем функциями на Python в сеансе. Обращайтесь с ними осторожно."
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:764(para)
msgid ""
"Each function gets its own execution environment in the Python interpreter, "
"so that global data and function arguments from <function>myfunc</function> "
"are not available to <function>myfunc2</function>. The exception is the data "
"in the <varname>GD</varname> dictionary, as mentioned above."
msgstr ""
"Каждая функция получает собственную среду выполнения в интерпретаторе "
"Python, так что глобальные данные и аргументы функции, например "
"<function>myfunc</function>, не будут доступны в <function>myfunc2</"
"function>. Исключение составляют данные в словаре <varname>GD</varname>, как "
"сказано выше."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:774(title)
msgid "Anonymous Code Blocks"
msgstr "Анонимные блоки кода"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:780(programlisting)
#, no-wrap
msgid ""
"DO $$\n"
"    # PL/Python code\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"DO $$\n"
"    # Код на PL/Python\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:776(para)
msgid ""
"PL/Python also supports anonymous code blocks called with the <xref linkend="
"\"sql-do\"/> statement: <placeholder-1/> An anonymous code block receives no "
"arguments, and whatever value it might return is discarded. Otherwise it "
"behaves just like a function."
msgstr ""
"PL/Python также поддерживает анонимные блоки кода, которые выполняются "
"оператором <xref linkend=\"sql-do\"/>: <placeholder-1/> Анонимный блок кода "
"не принимает аргументы, а любое значение, которое он мог бы вернуть, "
"отбрасывается. В остальном он работает подобно коду функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:792(title)
msgid "Trigger Functions"
msgstr "Триггерные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:794(indexterm)
msgid "<primary>trigger</primary> <secondary>in PL/Python</secondary>"
msgstr "<primary>триггер</primary> <secondary>в PL/Python</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:804(literal)
msgid "TD[\"event\"]"
msgstr "TD[\"event\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:806(para)
msgid ""
"contains the event as a string: <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, <literal>DELETE</literal>, or <literal>TRUNCATE</literal>."
msgstr ""
"содержит название события в виде строки: <literal>INSERT</literal>, "
"<literal>UPDATE</literal>, <literal>DELETE</literal> или <literal>TRUNCATE</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:815(literal)
msgid "TD[\"when\"]"
msgstr "TD[\"when\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:817(para)
msgid ""
"contains one of <literal>BEFORE</literal>, <literal>AFTER</literal>, or "
"<literal>INSTEAD OF</literal>."
msgstr ""
"содержит одну из строк: <literal>BEFORE</literal>, <literal>AFTER</literal> "
"или <literal>INSTEAD OF</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:825(literal)
msgid "TD[\"level\"]"
msgstr "TD[\"level\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:827(para)
msgid "contains <literal>ROW</literal> or <literal>STATEMENT</literal>."
msgstr "содержит <literal>ROW</literal> или <literal>STATEMENT</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:834(literal)
msgid "TD[\"new\"]"
msgstr "TD[\"new\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:835(literal)
msgid "TD[\"old\"]"
msgstr "TD[\"old\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:837(para)
msgid ""
"For a row-level trigger, one or both of these fields contain the respective "
"trigger rows, depending on the trigger event."
msgstr ""
"Для триггера уровня строки одно или оба этих поля содержат соответствующие "
"строки триггера, в зависимости от события триггера."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:845(literal)
msgid "TD[\"name\"]"
msgstr "TD[\"name\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:847(para)
msgid "contains the trigger name."
msgstr "содержит имя триггера."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:854(literal)
msgid "TD[\"table_name\"]"
msgstr "TD[\"table_name\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:856(para)
msgid "contains the name of the table on which the trigger occurred."
msgstr "содержит имя таблицы, для которой сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:863(literal)
msgid "TD[\"table_schema\"]"
msgstr "TD[\"table_schema\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:865(para)
msgid "contains the schema of the table on which the trigger occurred."
msgstr "содержит схему таблицы, для которой сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:872(literal)
msgid "TD[\"relid\"]"
msgstr "TD[\"relid\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:874(para)
msgid "contains the OID of the table on which the trigger occurred."
msgstr "содержит OID таблицы, для которой сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:881(literal)
msgid "TD[\"args\"]"
msgstr "TD[\"args\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:883(para)
msgid ""
"If the <command>CREATE TRIGGER</command> command included arguments, they "
"are available in <literal>TD[\"args\"][0]</literal> to <literal>TD[\"args\"]"
"[<replaceable>n</replaceable>-1]</literal>."
msgstr ""
"Если в команде <command>CREATE TRIGGER</command> задавались аргументы, их "
"можно получить как элементы массива с <literal>TD[\"args\"][0]</literal> по "
"<literal>TD[\"args\"][<replaceable>n</replaceable>-1]</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:799(para)
msgid ""
"When a function is used as a trigger, the dictionary <literal>TD</literal> "
"contains trigger-related values: <placeholder-1/>"
msgstr ""
"Когда функция используется как триггер, словарь <literal>TD</literal> "
"содержит значения, связанные с работой триггера: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:893(para)
msgid ""
"If <literal>TD[\"when\"]</literal> is <literal>BEFORE</literal> or "
"<literal>INSTEAD OF</literal> and <literal>TD[\"level\"]</literal> is "
"<literal>ROW</literal>, you can return <literal>None</literal> or <literal>"
"\"OK\"</literal> from the Python function to indicate the row is unmodified, "
"<literal>\"SKIP\"</literal> to abort the event, or if <literal>TD[\"event"
"\"]</literal> is <command>INSERT</command> or <command>UPDATE</command> you "
"can return <literal>\"MODIFY\"</literal> to indicate you've modified the new "
"row. Otherwise the return value is ignored."
msgstr ""
"Если в <literal>TD[\"when\"]</literal> передано <literal>BEFORE</literal> "
"или <literal>INSTEAD OF</literal>, а в <literal>TD[\"level\"]</literal> — "
"<literal>ROW</literal>, вы можете вернуть значение <literal>None</literal> "
"или <literal>\"OK\"</literal> из функции Python, чтобы показать, что строка "
"не была изменена, значение <literal>\"SKIP\"</literal>, чтобы прервать "
"событие, либо, если в <literal>TD[\"event\"]</literal> передана команда "
"<command>INSERT</command> или <command>UPDATE</command>, вы можете вернуть "
"<literal>\"MODIFY\"</literal>, чтобы показать, что новая строка была "
"изменена. Во всех других случаях возвращаемое значение игнорируется."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:907(title)
msgid "Database Access"
msgstr "Обращение к базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:909(para)
msgid ""
"The PL/Python language module automatically imports a Python module called "
"<literal>plpy</literal>. The functions and constants in this module are "
"available to you in the Python code as <literal>plpy.<replaceable>foo</"
"replaceable></literal>."
msgstr ""
"Исполнитель языка PL/Python автоматически импортирует модуль Python с именем "
"<literal>plpy</literal>. Вы в своём коде можете использовать функции и "
"константы, объявленные в этом модуле, обращаясь к ним по именам вида "
"<literal>plpy.<replaceable>имя</replaceable></literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:917(title)
msgid "Database Access Functions"
msgstr "Функции обращения к базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:919(para)
msgid ""
"The <literal>plpy</literal> module provides several functions to execute "
"database commands:"
msgstr ""
"Модуль <literal>plpy</literal> содержит различные функции для выполнения "
"команд в базе данных:"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:926(function) plpython.xml:1024(function)
msgid "execute"
msgstr "execute"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:926(replaceable) plpython.xml:1023(replaceable)
#: plpython.xml:1085(replaceable)
msgid "query"
msgstr "запрос"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:926(replaceable) plpython.xml:1024(replaceable)
msgid "max-rows"
msgstr "макс-строк"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:926(literal) plpython.xml:1023(literal)
#: plpython.xml:1086(literal)
msgid "plpy.<placeholder-1/>(<placeholder-2/> [, <placeholder-3/>])"
msgstr "plpy.<placeholder-1/>(<placeholder-2/> [, <placeholder-3/>])"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:928(para)
msgid ""
"Calling <function>plpy.execute</function> with a query string and an "
"optional row limit argument causes that query to be run and the result to be "
"returned in a result object."
msgstr ""
"При вызове <function>plpy.execute</function> со строкой запроса и "
"необязательным аргументом, ограничивающим число строк, выполняется заданный "
"запрос, а то, что он выдаёт, возвращается в виде объекта результата."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:937(programlisting)
#, no-wrap
msgid "rv = plpy.execute(\"SELECT * FROM my_table\", 5)"
msgstr "rv = plpy.execute(\"SELECT * FROM my_table\", 5)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:943(programlisting)
#, no-wrap
msgid "foo = rv[i][\"my_column\"]"
msgstr "foo = rv[i][\"my_column\"]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:934(para)
msgid ""
"The result object emulates a list or dictionary object. The result object "
"can be accessed by row number and column name. For example: <placeholder-1/> "
"returns up to 5 rows from <literal>my_table</literal>. If <literal>my_table</"
"literal> has a column <literal>my_column</literal>, it would be accessed as: "
"<placeholder-2/> The number of rows returned can be obtained using the built-"
"in <function>len</function> function."
msgstr ""
"Объект результата имитирует список или словарь. Получить из него данные "
"можно по номеру строки и имени столбца. Например, команда: <placeholder-1/> "
"вернёт не более 5 строк из отношения <literal>my_table</literal>. Если в "
"<literal>my_table</literal> есть столбец <literal>my_column</literal>, к "
"нему можно обратиться так: <placeholder-2/> Число возвращённых в этом "
"объекте строк можно получить, воспользовавшись встроенной функцией "
"<function>len</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:954(function)
msgid "nrows"
msgstr "nrows"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:954(literal) plpython.xml:966(literal)
#: plpython.xml:975(literal) plpython.xml:976(literal)
#: plpython.xml:977(literal) plpython.xml:995(literal)
msgid "<placeholder-1/>()"
msgstr "<placeholder-1/>()"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:956(para)
msgid ""
"Returns the number of rows processed by the command. Note that this is not "
"necessarily the same as the number of rows returned. For example, an "
"<command>UPDATE</command> command will set this value but won't return any "
"rows (unless <literal>RETURNING</literal> is used)."
msgstr ""
"Возвращает число строк, обработанных командой. Заметьте, что это число не "
"обязательно будет равно числу возвращённых строк. Например, команда "
"<command>UPDATE</command> устанавливает это значение, но не возвращает строк "
"(без указания <literal>RETURNING</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:966(function)
msgid "status"
msgstr "status"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:968(para)
msgid "The <function>SPI_execute()</function> return value."
msgstr "Значение состояния, возвращённое <function>SPI_execute()</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:975(function)
msgid "colnames"
msgstr "colnames"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:976(function)
msgid "coltypes"
msgstr "coltypes"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:977(function)
msgid "coltypmods"
msgstr "coltypmods"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:979(para)
msgid ""
"Return a list of column names, list of column type OIDs, and list of type-"
"specific type modifiers for the columns, respectively."
msgstr ""
"Возвращают список имён столбцов, список OID типов столбцов и список "
"модификаторов типа этих столбцов, соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:984(para)
msgid ""
"These methods raise an exception when called on a result object from a "
"command that did not produce a result set, e.g., <command>UPDATE</command> "
"without <literal>RETURNING</literal>, or <command>DROP TABLE</command>. But "
"it is OK to use these methods on a result set containing zero rows."
msgstr ""
"Эти методы вызывают исключение, когда им передаётся объект, полученный от "
"команды, не возвращающей результирующий набор, например, <command>UPDATE</"
"command> без <literal>RETURNING</literal>, либо <command>DROP TABLE</"
"command>. Но эти методы вполне можно использовать с результатом, содержащим "
"ноль строк."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:995(function)
msgid "__str__"
msgstr "__str__"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:997(para)
msgid ""
"The standard <literal>__str__</literal> method is defined so that it is "
"possible for example to debug query execution results using <literal>plpy."
"debug(rv)</literal>."
msgstr ""
"Стандартный метод <literal>__str__</literal> определён так, чтобы можно "
"было, например, вывести отладочное сообщение с результатами запроса, вызвав "
"<literal>plpy.debug(rv)</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:950(para)
msgid "The result object has these additional methods: <placeholder-1/>"
msgstr ""
"Для объекта результата определены следующие дополнительные методы: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1007(para)
msgid "The result object can be modified."
msgstr "Объект результата может быть изменён."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1011(para)
msgid ""
"Note that calling <literal>plpy.execute</literal> will cause the entire "
"result set to be read into memory. Only use that function when you are sure "
"that the result set will be relatively small. If you don't want to risk "
"excessive memory usage when fetching large results, use <literal>plpy."
"cursor</literal> rather than <literal>plpy.execute</literal>."
msgstr ""
"Заметьте, что при вызове <literal>plpy.execute</literal> весь набор "
"результатов будет прочитан в память. Эту функцию следует использовать, "
"только если вы знаете, что набор будет относительно небольшим. Если вы "
"хотите исключить риск переполнения памяти при выборке результатов большого "
"объёма, используйте <literal>plpy.cursor</literal> вместо <literal>plpy."
"execute</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1023(function)
msgid "prepare"
msgstr "prepare"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1023(replaceable)
msgid "argtypes"
msgstr "типы_аргументов"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1024(replaceable) plpython.xml:1086(replaceable)
msgid "plan"
msgstr "план"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1024(replaceable) plpython.xml:1086(replaceable)
msgid "arguments"
msgstr "аргументы"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1024(literal)
msgid ""
"plpy.<placeholder-1/>(<placeholder-2/> [, <placeholder-3/> [, <placeholder-4/"
">]])"
msgstr ""
"plpy.<placeholder-1/>(<placeholder-2/> [, <placeholder-3/> [, <placeholder-4/"
">]])"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1027(indexterm)
msgid "<primary>preparing a query</primary><secondary>in PL/Python</secondary>"
msgstr ""
"<primary>подготовка запроса</primary> <secondary>в PL/Python</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1031(programlisting)
#, no-wrap
msgid "plan = plpy.prepare(\"SELECT last_name FROM my_users WHERE first_name = $1\", [\"text\"])"
msgstr "plan = plpy.prepare(\"SELECT last_name FROM my_users WHERE first_name = $1\", [\"text\"])"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1026(para)
msgid ""
"<placeholder-1/> <function>plpy.prepare</function> prepares the execution "
"plan for a query. It is called with a query string and a list of parameter "
"types, if you have parameter references in the query. For example: "
"<placeholder-2/> <literal>text</literal> is the type of the variable you "
"will be passing for <literal>$1</literal>. The second argument is optional "
"if you don't want to pass any parameters to the query."
msgstr ""
"<placeholder-1/> Функция <function>plpy.prepare</function> подготавливает "
"план выполнения для запроса. Она вызывается со строкой запроса и списком "
"типов параметров (если в запросе есть параметры). Например: <placeholder-2/> "
"Здесь <literal>text</literal> представляет переменную, передаваемую в "
"качестве параметра <literal>$1</literal>. Второй аргумент необязателен, если "
"запросу не нужно передавать никакие параметры."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1041(programlisting)
#, no-wrap
msgid "rv = plpy.execute(plan, [\"name\"], 5)"
msgstr "rv = plpy.execute(plan, [\"name\"], 5)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1038(para)
msgid ""
"After preparing a statement, you use a variant of the function "
"<function>plpy.execute</function> to run it: <placeholder-1/> Pass the plan "
"as the first argument (instead of the query string), and a list of values to "
"substitute into the query as the second argument. The second argument is "
"optional if the query does not expect any parameters. The third argument is "
"the optional row limit as before."
msgstr ""
"Чтобы запустить подготовленный оператор на выполнение, используйте вариацию "
"функции <function>plpy.execute</function>: <placeholder-1/> Передайте план в "
"первом аргументе (вместо строки запроса), а список значений, которые будут "
"подставлены в запрос, — во втором. Второй аргумент можно опустить, если "
"запрос не принимает никакие параметры. Третий аргумент, как и раньше, задаёт "
"необязательное ограничение максимального числа строк."

#. +> REL_10
#: plpython.xml:1053(programlisting)
#, no-wrap
msgid "rv = plan.execute([\"name\"], 5)"
msgstr "rv = plan.execute([\"name\"], 5)"

#. +> REL_10
#: plpython.xml:1050(para)
msgid ""
"Alternatively, you can call the <function>execute</function> method on the "
"plan object: <placeholder-1/>"
msgstr ""
"Вы также можете вызвать метод <function>execute</function> объекта плана: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1058(para)
msgid ""
"Query parameters and result row fields are converted between PostgreSQL and "
"Python data types as described in <xref linkend=\"plpython-data\"/>."
msgstr ""
"Параметры запросов и поля строк результата преобразуются между типами данных "
"PostgreSQL и Python как описано в <xref remap=\"6\" linkend=\"plpython-data"
"\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1070(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION usesavedplan() RETURNS trigger AS $$\n"
"    if \"plan\" in SD:\n"
"        plan = SD[\"plan\"]\n"
"    else:\n"
"        plan = plpy.prepare(\"SELECT 1\")\n"
"        SD[\"plan\"] = plan\n"
"    # rest of function\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION usesavedplan() RETURNS trigger AS $$\n"
"    if \"plan\" in SD:\n"
"        plan = SD[\"plan\"]\n"
"    else:\n"
"        plan = plpy.prepare(\"SELECT 1\")\n"
"        SD[\"plan\"] = plan\n"
"    # остальной код функции\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1063(para)
msgid ""
"When you prepare a plan using the PL/Python module it is automatically "
"saved. Read the SPI documentation (<xref linkend=\"spi\"/>) for a "
"description of what this means. In order to make effective use of this "
"across function calls one needs to use one of the persistent storage "
"dictionaries <literal>SD</literal> or <literal>GD</literal> (see <xref "
"linkend=\"plpython-sharing\"/>). For example: <placeholder-1/>"
msgstr ""
"Когда вы подготавливаете план, используя модуль PL/Python, он сохраняется "
"автоматически. Что это означает, вы можете узнать в документации SPI (<xref "
"linkend=\"spi\"/>). Чтобы эффективно использовать это в нескольких вызовах "
"функции, может потребоваться применить словарь постоянного хранения "
"<literal>SD</literal> или <literal>GD</literal> (см. <xref remap=\"4\" "
"linkend=\"plpython-sharing\"/>). Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1085(function) plpython.xml:1086(function)
msgid "cursor"
msgstr "cursor"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1085(literal)
msgid "plpy.<placeholder-1/>(<placeholder-2/>)"
msgstr "plpy.<placeholder-1/>(<placeholder-2/>)"

#. +> REL_10
#: plpython.xml:1088(para)
msgid ""
"The <literal>plpy.cursor</literal> function accepts the same arguments as "
"<literal>plpy.execute</literal> (except for the row limit) and returns a "
"cursor object, which allows you to process large result sets in smaller "
"chunks. As with <literal>plpy.execute</literal>, either a query string or a "
"plan object along with a list of arguments can be used, or the "
"<function>cursor</function> function can be called as a method of the plan "
"object."
msgstr ""
"Функция <literal>plpy.cursor</literal> принимает те же аргументы, что и "
"<literal>plpy.execute</literal> (кроме ограничения строк) и возвращает "
"объект курсора, который позволяет обрабатывать объёмные наборы результатов "
"небольшими порциями. Как и <literal>plpy.execute</literal>, этой функции "
"можно передать строку запроса или объект плана со списком аргументов, а "
"можно вызывать функцию <function>cursor</function> как метод объекта плана."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1098(para)
msgid ""
"The cursor object provides a <literal>fetch</literal> method that accepts an "
"integer parameter and returns a result object. Each time you call "
"<literal>fetch</literal>, the returned object will contain the next batch of "
"rows, never larger than the parameter value. Once all rows are exhausted, "
"<literal>fetch</literal> starts returning an empty result object. Cursor "
"objects also provide an <ulink url=\"http://docs.python.org/library/stdtypes."
"html#iterator-types\">iterator interface</ulink>, yielding one row at a time "
"until all rows are exhausted. Data fetched that way is not returned as "
"result objects, but rather as dictionaries, each dictionary corresponding to "
"a single result row."
msgstr ""
"Объект курсора реализует метод <literal>fetch</literal>, который принимает "
"целочисленный параметр и возвращает объект результата. При каждом следующем "
"вызове <literal>fetch</literal> возвращаемый объект будет содержать "
"следующий набор строк, в количестве, не превышающем значение параметра. "
"Когда строки закончатся, <literal>fetch</literal> начнёт возвращать пустой "
"объект результата. Объекты курсора также предоставляют <ulink url=\"http://"
"docs.python.org/library/stdtypes.html#iterator-types\">интерфейс итератора</"
"ulink>, выдающий по строке за один раз, пока не будут выданы все строки. "
"Данные, выбираемые таким образом, возвращаются не как объекты результата, а "
"как словари (одной строке результата соответствует один словарь)."

#. +> REL_10
#: plpython.xml:1114(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$\n"
"odd = 0\n"
"for row in plpy.cursor(\"select num from largetable\"):\n"
"    if row['num'] % 2:\n"
"         odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$\n"
"odd = 0\n"
"cursor = plpy.cursor(\"select num from largetable\")\n"
"while True:\n"
"    rows = cursor.fetch(batch_size)\n"
"    if not rows:\n"
"        break\n"
"    for row in rows:\n"
"        if row['num'] % 2:\n"
"            odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$\n"
"odd = 0\n"
"plan = plpy.prepare(\"select num from largetable where num % $1 &lt;&gt; 0\", [\"integer\"])\n"
"rows = list(plpy.cursor(plan, [2]))  # or: = list(plan.cursor([2]))\n"
"\n"
"return len(rows)\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$\n"
"odd = 0\n"
"for row in plpy.cursor(\"select num from largetable\"):\n"
"    if row['num'] % 2:\n"
"         odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$\n"
"odd = 0\n"
"cursor = plpy.cursor(\"select num from largetable\")\n"
"while True:\n"
"    rows = cursor.fetch(batch_size)\n"
"    if not rows:\n"
"        break\n"
"    for row in rows:\n"
"        if row['num'] % 2:\n"
"            odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$\n"
"odd = 0\n"
"plan = plpy.prepare(\"select num from largetable where num % $1 &lt;&gt; 0\", [\"integer\"])\n"
"rows = list(plpy.cursor(plan, [2]))  # или: = list(plan.cursor([2]))\n"
"\n"
"return len(rows)\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1112(para)
msgid ""
"An example of two ways of processing data from a large table is: "
"<placeholder-1/>"
msgstr ""
"Следующий пример демонстрирует обработку содержимого большой таблицы двумя "
"способами: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1146(para)
msgid ""
"Cursors are automatically disposed of. But if you want to explicitly release "
"all resources held by a cursor, use the <literal>close</literal> method. "
"Once closed, a cursor cannot be fetched from anymore."
msgstr ""
"Курсоры ликвидируются автоматически. Но если вы хотите явно освободить все "
"ресурсы, занятые курсором, вызовите метод <literal>close</literal>. "
"Продолжать получать данные через курсор, который был закрыт, нельзя."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1153(para)
msgid ""
"Do not confuse objects created by <literal>plpy.cursor</literal> with DB-API "
"cursors as defined by the <ulink url=\"http://www.python.org/dev/peps/"
"pep-0249/\">Python Database API specification</ulink>. They don't have "
"anything in common except for the name."
msgstr ""
"Не путайте объекты, создаваемые функцией <literal>plpy.cursor</literal>, с "
"курсорами DB-API, определёнными в <ulink url=\"http://www.python.org/dev/"
"peps/pep-0249/\">спецификации API для работы с базами данных в Python</"
"ulink>. Они не имеют ничего общего, кроме имени."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1168(title)
msgid "Trapping Errors"
msgstr "Обработка ошибок"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1179(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION try_adding_joe() RETURNS text AS $$\n"
"    try:\n"
"        plpy.execute(\"INSERT INTO users(username) VALUES ('joe')\")\n"
"    except plpy.SPIError:\n"
"        return \"something went wrong\"\n"
"    else:\n"
"        return \"Joe added\"\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION try_adding_joe() RETURNS text AS $$\n"
"    try:\n"
"        plpy.execute(\"INSERT INTO users(username) VALUES ('joe')\")\n"
"    except plpy.SPIError:\n"
"        return \"something went wrong\"\n"
"    else:\n"
"        return \"Joe added\"\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1170(para)
msgid ""
"Functions accessing the database might encounter errors, which will cause "
"them to abort and raise an exception. Both <function>plpy.execute</function> "
"and <function>plpy.prepare</function> can raise an instance of a subclass of "
"<literal>plpy.SPIError</literal>, which by default will terminate the "
"function. This error can be handled just like any other Python exception, by "
"using the <literal>try/except</literal> construct. For example: "
"<placeholder-1/>"
msgstr ""
"Функции, обращающиеся к базе данных, могут сталкиваться с ошибками, в "
"результате которых они будут прерываться и вызывать исключение. Обе функции "
"<function>plpy.execute</function> и <function>plpy.prepare</function> могут "
"вызывать экземпляр подкласса исключения <literal>plpy.SPIError</literal>, "
"которое по умолчание прекращает выполнение функции. Эту ошибку можно "
"обработать, как и любое другое исключение в Python, применив конструкцию "
"<literal>try/except</literal>. Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1206(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$\n"
"from plpy import spiexceptions\n"
"try:\n"
"    plan = plpy.prepare(\"INSERT INTO fractions (frac) VALUES ($1 / $2)\", [\"int\", \"int\"])\n"
"    plpy.execute(plan, [numerator, denominator])\n"
"except spiexceptions.DivisionByZero:\n"
"    return \"denominator cannot equal zero\"\n"
"except spiexceptions.UniqueViolation:\n"
"    return \"already have that fraction\"\n"
"except plpy.SPIError, e:\n"
"    return \"other error, SQLSTATE %s\" % e.sqlstate\n"
"else:\n"
"    return \"fraction inserted\"\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$\n"
"from plpy import spiexceptions\n"
"try:\n"
"    plan = plpy.prepare(\"INSERT INTO fractions (frac) VALUES ($1 / $2)\", [\"int\", \"int\"])\n"
"    plpy.execute(plan, [numerator, denominator])\n"
"except spiexceptions.DivisionByZero:\n"
"    return \"denominator cannot equal zero\"\n"
"except spiexceptions.UniqueViolation:\n"
"    return \"already have that fraction\"\n"
"except plpy.SPIError, e:\n"
"    return \"other error, SQLSTATE %s\" % e.sqlstate\n"
"else:\n"
"    return \"fraction inserted\"\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1191(para)
msgid ""
"The actual class of the exception being raised corresponds to the specific "
"condition that caused the error. Refer to <xref linkend=\"errcodes-table\"/> "
"for a list of possible conditions. The module <literal>plpy.spiexceptions</"
"literal> defines an exception class for each <productname>PostgreSQL</"
"productname> condition, deriving their names from the condition name. For "
"instance, <literal>division_by_zero</literal> becomes "
"<literal>DivisionByZero</literal>, <literal>unique_violation</literal> "
"becomes <literal>UniqueViolation</literal>, <literal>fdw_error</literal> "
"becomes <literal>FdwError</literal>, and so on. Each of these exception "
"classes inherits from <literal>SPIError</literal>. This separation makes it "
"easier to handle specific errors, for instance: <placeholder-1/> Note that "
"because all exceptions from the <literal>plpy.spiexceptions</literal> module "
"inherit from <literal>SPIError</literal>, an <literal>except</literal> "
"clause handling it will catch any database access error."
msgstr ""
"Фактический класс вызываемого исключения соответствует определённому условию "
"возникновения ошибки. Список всех возможных условий приведён в <xref remap="
"\"6\" linkend=\"errcodes-table\"/>. В модуле <literal>plpy.spiexceptions</"
"literal> определяются классы исключений для каждого условия "
"<productname>PostgreSQL</productname>, с именами, производными от имён "
"условий. Например, имя <literal>division_by_zero</literal> становится именем "
"<literal>DivisionByZero</literal>, <literal>unique_violation</literal> — "
"именем <literal>UniqueViolation</literal>, <literal>fdw_error</literal> — "
"именем <literal>FdwError</literal> и т. д. Все эти классы исключений "
"наследуются от <literal>SPIError</literal>. Такое разделение на классы "
"упрощает обработку определённых ошибок, например: <placeholder-1/> Заметьте, "
"что так как все исключения из модуля <literal>plpy.spiexceptions</literal> "
"наследуются от исключения <literal>SPIError</literal>, команда "
"<literal>except</literal>, обрабатывающая это исключение, будет "
"перехватывать все ошибки при обращении к базе данных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1228(para)
msgid ""
"As an alternative way of handling different error conditions, you can catch "
"the <literal>SPIError</literal> exception and determine the specific error "
"condition inside the <literal>except</literal> block by looking at the "
"<literal>sqlstate</literal> attribute of the exception object. This "
"attribute is a string value containing the <quote>SQLSTATE</quote> error "
"code. This approach provides approximately the same functionality"
msgstr ""
"В качестве другого варианта обработки различных условий ошибок, вы можете "
"перехватывать исключение <literal>SPIError</literal> и определять конкретное "
"условие ошибки внутри блока <literal>except</literal> по значению атрибута "
"<literal>sqlstate</literal> объекта исключения. Этот атрибут содержит строку "
"с кодом ошибки <quote>SQLSTATE</quote>. Конечный результат при таком подходе "
"примерно тот же."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1241(title)
msgid "Explicit Subtransactions"
msgstr "Неявные подтранзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1243(para)
msgid ""
"Recovering from errors caused by database access as described in <xref "
"linkend=\"plpython-trapping\"/> can lead to an undesirable situation where "
"some operations succeed before one of them fails, and after recovering from "
"that error the data is left in an inconsistent state. PL/Python offers a "
"solution to this problem in the form of explicit subtransactions."
msgstr ""
"Перехват ошибок, произошедших при обращении к базе данных, как описано в "
"<xref remap=\"6\" linkend=\"plpython-trapping\"/>, может привести к "
"нежелательной ситуации, когда часть операций будет успешно выполнена, прежде "
"чем произойдёт сбой. Данные останутся в несогласованном состоянии после "
"обработки такой ошибки. PL/Python предлагает решение этой проблемы в форме "
"неявных подтранзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1253(title)
msgid "Subtransaction Context Managers"
msgstr "Менеджеры контекста подтранзакций"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1258(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION transfer_funds() RETURNS void AS $$\n"
"try:\n"
"    plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n"
"    plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\n"
"except plpy.SPIError, e:\n"
"    result = \"error transferring funds: %s\" % e.args\n"
"else:\n"
"    result = \"funds transferred correctly\"\n"
"plan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\n"
"plpy.execute(plan, [result])\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION transfer_funds() RETURNS void AS $$\n"
"try:\n"
"    plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n"
"    plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\n"
"except plpy.SPIError, e:\n"
"    result = \"error transferring funds: %s\" % e.args\n"
"else:\n"
"    result = \"funds transferred correctly\"\n"
"plan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\n"
"plpy.execute(plan, [result])\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1255(para)
msgid ""
"Consider a function that implements a transfer between two accounts: "
"<placeholder-1/> If the second <literal>UPDATE</literal> statement results "
"in an exception being raised, this function will report the error, but the "
"result of the first <literal>UPDATE</literal> will nevertheless be "
"committed. In other words, the funds will be withdrawn from Joe's account, "
"but will not be transferred to Mary's account."
msgstr ""
"Рассмотрим функцию, осуществляющую перевод средств между двумя счетами: "
"<placeholder-1/> Если при выполнении второго оператора <literal>UPDATE</"
"literal> произойдёт исключение, эта функция сообщит об ошибке, но результат "
"первого <literal>UPDATE</literal> будет, тем не менее, зафиксирован. Другими "
"словами, средства будут списаны со счёта Джо, но не зачислятся на счёт Мэри."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1289(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION transfer_funds2() RETURNS void AS $$\n"
"try:\n"
"    with plpy.subtransaction():\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\n"
"except plpy.SPIError, e:\n"
"    result = \"error transferring funds: %s\" % e.args\n"
"else:\n"
"    result = \"funds transferred correctly\"\n"
"plan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\n"
"plpy.execute(plan, [result])\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION transfer_funds2() RETURNS void AS $$\n"
"try:\n"
"    with plpy.subtransaction():\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\n"
"except plpy.SPIError, e:\n"
"    result = \"error transferring funds: %s\" % e.args\n"
"else:\n"
"    result = \"funds transferred correctly\"\n"
"plan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\n"
"plpy.execute(plan, [result])\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1279(para)
msgid ""
"To avoid such issues, you can wrap your <literal>plpy.execute</literal> "
"calls in an explicit subtransaction. The <literal>plpy</literal> module "
"provides a helper object to manage explicit subtransactions that gets "
"created with the <literal>plpy.subtransaction()</literal> function. Objects "
"created by this function implement the <ulink url=\"http://docs.python.org/"
"library/stdtypes.html#context-manager-types\"> context manager interface</"
"ulink>. Using explicit subtransactions we can rewrite our function as: "
"<placeholder-1/> Note that the use of <literal>try/catch</literal> is still "
"required. Otherwise the exception would propagate to the top of the Python "
"stack and would cause the whole function to abort with a "
"<productname>PostgreSQL</productname> error, so that the "
"<literal>operations</literal> table would not have any row inserted into it. "
"The subtransaction context manager does not trap errors, it only assures "
"that all database operations executed inside its scope will be atomically "
"committed or rolled back. A rollback of the subtransaction block occurs on "
"any kind of exception exit, not only ones caused by errors originating from "
"database access. A regular Python exception raised inside an explicit "
"subtransaction block would also cause the subtransaction to be rolled back."
msgstr ""
"Во избежание таких проблем, вы можете завернуть вызовы <literal>plpy."
"execute</literal> в явную подтранзакцию. Модуль <literal>plpy</literal> "
"предоставляет вспомогательный объект для управления явными подтранзакциями, "
"создаваемый функцией <literal>plpy.subtransaction()</literal>. Объекты, "
"созданные этой функцией, реализуют <ulink url=\"http://docs.python.org/"
"library/stdtypes.html#context-manager-types\">интерфейс менеджера контекста</"
"ulink>. Используя явные подтранзакции, мы можем переписать нашу функцию так: "
"<placeholder-1/> Заметьте, что конструкция <literal>try/catch</literal> по-"
"прежнему нужна. Без неё исключение распространится вверх по стеку Python и "
"приведёт к прерыванию всей функции с ошибкой <productname>PostgreSQL</"
"productname>, так что в таблицу <literal>operations</literal> запись не "
"добавится. Менеджер контекста подтранзакции не перехватывает ошибки, он "
"только гарантирует, что все операции с базой данных в его области действия "
"будут атомарно зафиксированы или отменены. Откат блока подтранзакции "
"происходит при исключении любого вида, а не только исключения, вызванного "
"ошибками при обращении к базе данных. Обычное исключение Python, вызванное "
"внутри блока явной подтранзакции, также приведёт к откату этой подтранзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1320(title)
msgid "Older Python Versions"
msgstr "Старые версии Python"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1332(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION transfer_funds_old() RETURNS void AS $$\n"
"try:\n"
"    subxact = plpy.subtransaction()\n"
"    subxact.enter()\n"
"    try:\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\n"
"    except:\n"
"        import sys\n"
"        subxact.exit(*sys.exc_info())\n"
"        raise\n"
"    else:\n"
"        subxact.exit(None, None, None)\n"
"except plpy.SPIError, e:\n"
"    result = \"error transferring funds: %s\" % e.args\n"
"else:\n"
"    result = \"funds transferred correctly\"\n"
"\n"
"plan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\n"
"plpy.execute(plan, [result])\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION transfer_funds_old() RETURNS void AS $$\n"
"try:\n"
"    subxact = plpy.subtransaction()\n"
"    subxact.enter()\n"
"    try:\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n"
"        plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\n"
"    except:\n"
"        import sys\n"
"        subxact.exit(*sys.exc_info())\n"
"        raise\n"
"    else:\n"
"        subxact.exit(None, None, None)\n"
"except plpy.SPIError, e:\n"
"    result = \"error transferring funds: %s\" % e.args\n"
"else:\n"
"    result = \"funds transferred correctly\"\n"
"\n"
"plan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\n"
"plpy.execute(plan, [result])\n"
"$$ LANGUAGE plpythonu;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1322(para)
msgid ""
"Context managers syntax using the <literal>with</literal> keyword is "
"available by default in Python 2.6. If using PL/Python with an older Python "
"version, it is still possible to use explicit subtransactions, although not "
"as transparently. You can call the subtransaction manager's "
"<literal>__enter__</literal> and <literal>__exit__</literal> functions using "
"the <literal>enter</literal> and <literal>exit</literal> convenience "
"aliases. The example function that transfers funds could be written as: "
"<placeholder-1/>"
msgstr ""
"Синтаксис использования менеджеров контекста с ключевым словом "
"<literal>with</literal> по умолчанию поддерживается в Python 2.6. В PL/"
"Python с более старой версией Python тоже возможно использовать явные "
"подтранзакции, хотя и не так прозрачно. При этом вы можете вызывать методы "
"<literal>__enter__</literal> и <literal>__exit__</literal> менеджера "
"контекста по удобным псевдонимам <literal>enter</literal> и <literal>exit</"
"literal>. Для такого случая функцию перечисления средств можно переписать "
"так: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1358(para)
msgid ""
"Although context managers were implemented in Python 2.5, to use the "
"<literal>with</literal> syntax in that version you need to use a <ulink url="
"\"http://docs.python.org/release/2.5/ref/future.html\">future statement</"
"ulink>. Because of implementation details, however, you cannot use future "
"statements in PL/Python functions."
msgstr ""
"Хотя менеджеры контекста были реализованы в 2.5, для использования "
"синтаксиса <literal>with</literal> в этой версии нужно применить <ulink url="
"\"http://docs.python.org/release/2.5/ref/future.html\">&laquo;будущий "
"оператор&raquo;</ulink>. Однако по техническим причинам &laquo;будущие "
"операторы&raquo; в функциях PL/Python использовать нельзя."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1371(title)
msgid "Utility Functions"
msgstr "Вспомогательные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1375(replaceable) plpython.xml:1376(replaceable)
#: plpython.xml:1377(replaceable) plpython.xml:1378(replaceable)
#: plpython.xml:1379(replaceable) plpython.xml:1380(replaceable)
#: plpython.xml:1381(replaceable)
msgid "msg, **kwargs"
msgstr "msg, **kwargs"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1375(literal)
msgid "plpy.debug(<placeholder-1/>)"
msgstr "plpy.debug(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1376(literal)
msgid "plpy.log(<placeholder-1/>)"
msgstr "plpy.log(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1377(literal)
msgid "plpy.info(<placeholder-1/>)"
msgstr "plpy.info(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1378(literal)
msgid "plpy.notice(<placeholder-1/>)"
msgstr "plpy.notice(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1379(literal)
msgid "plpy.warning(<placeholder-1/>)"
msgstr "plpy.warning(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1380(literal)
msgid "plpy.error(<placeholder-1/>)"
msgstr "plpy.error(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1381(literal)
msgid "plpy.fatal(<placeholder-1/>)"
msgstr "plpy.fatal(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1383(indexterm)
msgid "<primary>elog</primary><secondary>in PL/Python</secondary>"
msgstr "<primary>elog</primary> <secondary>в PL/Python</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1372(para)
msgid ""
"The <literal>plpy</literal> module also provides the functions "
"<placeholder-1/> <placeholder-2/> <function>plpy.error</function> and "
"<function>plpy.fatal</function> actually raise a Python exception which, if "
"uncaught, propagates out to the calling query, causing the current "
"transaction or subtransaction to be aborted. <literal>raise plpy."
"Error(<replaceable>msg</replaceable>)</literal> and <literal>raise plpy."
"Fatal(<replaceable>msg</replaceable>)</literal> are equivalent to calling "
"<literal>plpy.error(<replaceable>msg</replaceable>)</literal> and "
"<literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>, respectively "
"but the <literal>raise</literal> form does not allow passing keyword "
"arguments. The other functions only generate messages of different priority "
"levels. Whether messages of a particular priority are reported to the "
"client, written to the server log, or both is controlled by the <xref "
"linkend=\"guc-log-min-messages\"/> and <xref linkend=\"guc-client-min-"
"messages\"/> configuration variables. See <xref linkend=\"runtime-config\"/> "
"for more information."
msgstr ""
"Модуль <literal>plpy</literal> также предоставляет функции <placeholder-1/> "
"<placeholder-2/> Функции <function>plpy.error</function> и <function>plpy."
"fatal</function> на самом деле выдают исключение Python, которое, если его "
"не перехватить, распространяется в вызывающий запрос, что приводит к "
"прерыванию текущей транзакции или подтранзакции. Команды <literal>raise plpy."
"Error(<replaceable>msg</replaceable>)</literal> и <literal>raise plpy."
"Fatal(<replaceable>msg</replaceable>)</literal> равнозначны вызовам "
"<literal>plpy.error(<replaceable>msg</replaceable>)</literal> и "
"<literal>plpy.fatal(<replaceable>msg</replaceable>)</literal>, "
"соответственно, но форма <literal>raise</literal> не позволяет передавать "
"аргументы с ключами. Другие функции просто выдают сообщения разных уровней "
"важности. Будут ли сообщения определённого уровня передаваться клиентам и/"
"или записываться в журнал сервера, определяется конфигурационными "
"переменными <xref linkend=\"guc-log-min-messages\"/> и <xref linkend=\"guc-"
"client-min-messages\"/>. За дополнительными сведениями обратитесь к <xref "
"remap=\"3\" linkend=\"runtime-config\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1400(para)
msgid ""
"The <replaceable>msg</replaceable> argument is given as a positional "
"argument. For backward compatibility, more than one positional argument can "
"be given. In that case, the string representation of the tuple of positional "
"arguments becomes the message reported to the client."
msgstr ""
"Аргумент <replaceable>msg</replaceable> задаётся как позиционный. Для "
"обратной совместимости может быть передано несколько позиционных аргументов. "
"В этом случае сообщением для клиента становится строковое представление "
"кортежа позиционных аргументов."

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1410(literal)
msgid "detail"
msgstr "detail"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1411(literal)
msgid "hint"
msgstr "hint"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1412(literal)
msgid "sqlstate"
msgstr "sqlstate"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1413(literal)
msgid "schema_name"
msgstr "schema_name"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1414(literal)
msgid "table_name"
msgstr "table_name"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1415(literal)
msgid "column_name"
msgstr "column_name"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1416(literal)
msgid "datatype_name"
msgstr "datatype_name"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1417(literal)
msgid "constraint_name"
msgstr "constraint_name"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1422(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION raise_custom_exception() RETURNS void AS $$\n"
"plpy.error(\"custom exception message\",\n"
"           detail=\"some info about exception\",\n"
"           hint=\"hint for users\")\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"=# SELECT raise_custom_exception();\n"
"ERROR:  plpy.Error: custom exception message\n"
"DETAIL:  some info about exception\n"
"HINT:  hint for users\n"
"CONTEXT:  Traceback (most recent call last):\n"
"  PL/Python function \"raise_custom_exception\", line 4, in &lt;module&gt;\n"
"    hint=\"hint for users\")\n"
"PL/Python function \"raise_custom_exception\""
msgstr ""
"CREATE FUNCTION raise_custom_exception() RETURNS void AS $$\n"
"plpy.error(\"custom exception message\",\n"
"           detail=\"some info about exception\",\n"
"           hint=\"hint for users\")\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"=# SELECT raise_custom_exception();\n"
"ERROR:  plpy.Error: custom exception message\n"
"DETAIL:  some info about exception\n"
"HINT:  hint for users\n"
"CONTEXT:  Traceback (most recent call last):\n"
"  PL/Python function \"raise_custom_exception\", line 4, in &lt;module&gt;\n"
"    hint=\"hint for users\")\n"
"PL/Python function \"raise_custom_exception\""

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1407(para)
msgid ""
"The following keyword-only arguments are accepted: <placeholder-1/> The "
"string representation of the objects passed as keyword-only arguments is "
"used to enrich the messages reported to the client. For example: "
"<placeholder-2/>"
msgstr ""
"Дополнительно только по ключам принимаются следующие аргументы: "
"<placeholder-1/> Строковое представление объектов, передаваемых в аргументах "
"по ключам, позволяет выдать клиенту более богатую информацию. Например: "
"<placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1449(programlisting)
#, no-wrap
msgid ""
"plpy.execute(\"UPDATE tbl SET %s = %s WHERE key = %s\" % (\n"
"    plpy.quote_ident(colname),\n"
"    plpy.quote_nullable(newvalue),\n"
"    plpy.quote_literal(keyvalue)))"
msgstr ""
"plpy.execute(\"UPDATE tbl SET %s = %s WHERE key = %s\" % (\n"
"    plpy.quote_ident(colname),\n"
"    plpy.quote_nullable(newvalue),\n"
"    plpy.quote_literal(keyvalue)))"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1440(para)
msgid ""
"Another set of utility functions are <literal>plpy."
"quote_literal(<replaceable>string</replaceable>)</literal>, <literal>plpy."
"quote_nullable(<replaceable>string</replaceable>)</literal>, and "
"<literal>plpy.quote_ident(<replaceable>string</replaceable>)</literal>. They "
"are equivalent to the built-in quoting functions described in <xref linkend="
"\"functions-string\"/>. They are useful when constructing ad-hoc queries. A "
"PL/Python equivalent of dynamic SQL from <xref linkend=\"plpgsql-quote-"
"literal-example\"/> would be: <placeholder-1/>"
msgstr ""
"Ещё один набор вспомогательных функций образуют <literal>plpy."
"quote_literal(<replaceable>строка</replaceable>)</literal>, <literal>plpy."
"quote_nullable(<replaceable>строка</replaceable>)</literal> и <literal>plpy."
"quote_ident(<replaceable>строка</replaceable>)</literal>. Они равнозначны "
"встроенным функциям заключения в кавычки, описанным в <xref remap=\"6\" "
"linkend=\"functions-string\"/>. Они полезны при конструировании свободно "
"составляемых запросов. На PL/Python динамический SQL, показанный в <xref "
"remap=\"6\" linkend=\"plpgsql-quote-literal-example\"/>, формируется так: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1459(title)
msgid "Environment Variables"
msgstr "Переменные окружения"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1472(envar)
msgid "PYTHONHOME"
msgstr "PYTHONHOME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1476(envar)
msgid "PYTHONPATH"
msgstr "PYTHONPATH"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1480(envar)
msgid "PYTHONY2K"
msgstr "PYTHONY2K"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1484(envar)
msgid "PYTHONOPTIMIZE"
msgstr "PYTHONOPTIMIZE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1488(envar)
msgid "PYTHONDEBUG"
msgstr "PYTHONDEBUG"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1492(envar)
msgid "PYTHONVERBOSE"
msgstr "PYTHONVERBOSE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1496(envar)
msgid "PYTHONCASEOK"
msgstr "PYTHONCASEOK"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1500(envar)
msgid "PYTHONDONTWRITEBYTECODE"
msgstr "PYTHONDONTWRITEBYTECODE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1504(envar)
msgid "PYTHONIOENCODING"
msgstr "PYTHONIOENCODING"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1508(envar)
msgid "PYTHONUSERBASE"
msgstr "PYTHONUSERBASE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1512(envar)
msgid "PYTHONHASHSEED"
msgstr "PYTHONHASHSEED"

#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:1461(para)
msgid ""
"Some of the environment variables that are accepted by the Python "
"interpreter can also be used to affect PL/Python behavior. They would need "
"to be set in the environment of the main PostgreSQL server process, for "
"example in a start script. The available environment variables depend on the "
"version of Python; see the Python documentation for details. At the time of "
"this writing, the following environment variables have an affect on PL/"
"Python, assuming an adequate Python version: <placeholder-1/> (It appears to "
"be a Python implementation detail beyond the control of PL/Python that some "
"of the environment variables listed on the <command>python</command> man "
"page are only effective in a command-line interpreter and not an embedded "
"Python interpreter.)"
msgstr ""
"Некоторые переменные окружения, воспринимаемые интерпретатором Python, тоже "
"могут влиять на поведение PL/Python. При необходимости их нужно установить в "
"среде основного серверного процесса PostgreSQL, например, в скрипте запуска. "
"Множество доступных переменных окружения зависит от версии Python; за "
"подробностями обратитесь к документации Python. На момент написания этой "
"документации, на поведение PL/Python влияли следующие переменные окружения, "
"при наличии подходящей версии Python: <placeholder-1/> (Похоже, что "
"вследствие тонкостей реализации Python, не зависящих от исполнителя PL/"
"Python, некоторые переменные окружения, перечисленные на странице "
"руководства man <command>python</command>, действуют только в интерпретаторе "
"для командной строки, но не во встраиваемом интерпретаторе Python.)"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: plpython.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: plpython.xml:457(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION return_arr()\n"
"  RETURNS int[]\n"
"AS $$\n"
"return (1, 2, 3, 4, 5)\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT return_arr();\n"
" return_arr  \n"
"-------------\n"
" {1,2,3,4,5}\n"
"(1 row)"
msgstr ""
"CREATE FUNCTION return_arr()\n"
"  RETURNS int[]\n"
"AS $$\n"
"return (1, 2, 3, 4, 5)\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"SELECT return_arr();\n"
" return_arr  \n"
"-------------\n"
" {1,2,3,4,5}\n"
"(1 row)"

#. +> REL9_6_3 REL9_6
#: plpython.xml:452(para)
msgid ""
"SQL array values are passed into PL/Python as a Python list. To return an "
"SQL array value out of a PL/Python function, return a Python sequence, for "
"example a list or tuple: <placeholder-1/> Note that in Python, strings are "
"sequences, which can have undesirable effects that might be familiar to "
"Python programmers: <placeholder-2/>"
msgstr ""
"Значения массивов SQL передаются в PL/Python в виде списка Python. Чтобы "
"вернуть массив SQL из функции PL/Python, возвратите последовательность "
"Python, например, список или кортеж: <placeholder-1/> Учтите, что в Python и "
"строки являются последовательностями, что может давать неожиданные эффекты, "
"хорошо знакомые тем, кто программирует на Python: <placeholder-2/>"

#. +> REL9_6_3 REL9_6
#: plpython.xml:541(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  return [ name, value ]\n"
"  # or alternatively, as tuple: return ( name, value )\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION make_pair (name text, value integer)\n"
"  RETURNS named_value\n"
"AS $$\n"
"  return [ name, value ]\n"
"  # или в виде кортежа: return ( name, value )\n"
"$$ LANGUAGE plpythonu;"

#. +> REL9_6_3 REL9_6
#: plpython.xml:701(para)
msgid ""
"Due to Python <ulink url=\"http://bugs.python.org/issue1483133\">bug "
"#1483133</ulink>, some debug versions of Python 2.4 (configured and compiled "
"with option <literal>--with-pydebug</literal>) are known to crash the "
"<productname>PostgreSQL</productname> server when using an iterator to "
"return a set result. Unpatched versions of Fedora 4 contain this bug. It "
"does not happen in production versions of Python or on patched versions of "
"Fedora 4."
msgstr ""
"Из-за <ulink url=\"http://bugs.python.org/issue1483133\">ошибки 1483133</"
"ulink> в Python, некоторые отладочные версии Python 2.4 (сконфигурированные "
"и скомпилированные с ключом <literal>--with-pydebug</literal>) выводят из "
"строя сервер <productname>PostgreSQL</productname>, когда итератор "
"возвращает набор результатов. Эта ошибка проявляется в неисправленных "
"версиях Fedora 4, но не в выпускаемых версиях Python и в исправленной Fedora "
"4."

#. +> REL9_6_3 REL9_6
#: plpython.xml:1061(para)
msgid ""
"The <literal>plpy.cursor</literal> function accepts the same arguments as "
"<literal>plpy.execute</literal> (except for the row limit) and returns a "
"cursor object, which allows you to process large result sets in smaller "
"chunks. As with <literal>plpy.execute</literal>, either a query string or a "
"plan object along with a list of arguments can be used."
msgstr ""
"Функция <literal>plpy.cursor</literal> принимает те же аргументы, что и "
"<literal>plpy.execute</literal> (кроме ограничения строк) и возвращает "
"объект курсора, который позволяет обрабатывать объёмные наборы результатов "
"небольшими порциями. Как и <literal>plpy.execute</literal>, этой функции "
"можно передать строку запроса или объект плана со списком аргументов."

#. +> REL9_6_3 REL9_6
#: plpython.xml:1085(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$\n"
"odd = 0\n"
"for row in plpy.cursor(\"select num from largetable\"):\n"
"    if row['num'] % 2:\n"
"         odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$\n"
"odd = 0\n"
"cursor = plpy.cursor(\"select num from largetable\")\n"
"while True:\n"
"    rows = cursor.fetch(batch_size)\n"
"    if not rows:\n"
"        break\n"
"    for row in rows:\n"
"        if row['num'] % 2:\n"
"            odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$\n"
"odd = 0\n"
"plan = plpy.prepare(\"select num from largetable where num % $1 &lt;&gt; 0\", [\"integer\"])\n"
"rows = list(plpy.cursor(plan, [2]))\n"
"\n"
"return len(rows)\n"
"$$ LANGUAGE plpythonu;"
msgstr ""
"CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$\n"
"odd = 0\n"
"for row in plpy.cursor(\"select num from largetable\"):\n"
"    if row['num'] % 2:\n"
"         odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$\n"
"odd = 0\n"
"cursor = plpy.cursor(\"select num from largetable\")\n"
"while True:\n"
"    rows = cursor.fetch(batch_size)\n"
"    if not rows:\n"
"        break\n"
"    for row in rows:\n"
"        if row['num'] % 2:\n"
"            odd += 1\n"
"return odd\n"
"$$ LANGUAGE plpythonu;\n"
"\n"
"CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$\n"
"odd = 0\n"
"plan = plpy.prepare(\"select num from largetable where num % $1 &lt;&gt; 0\", [\"integer\"])\n"
"rows = list(plpy.cursor(plan, [2]))\n"
"\n"
"return len(rows)\n"
"$$ LANGUAGE plpythonu;"

#~ msgid ""
#~ "The <replaceable>msg</replaceable> argument is given as a positional "
#~ "argument. For backward compatibility, more than one positional argument "
#~ "can be given. In that case, the string representation of the tuple of "
#~ "positional arguments becomes the message reported to the client. The "
#~ "following keyword-only arguments are accepted: "
#~ "<literal><replaceable>detail</replaceable>, <replaceable>hint</"
#~ "replaceable>, <replaceable>sqlstate</replaceable>, <replaceable>schema</"
#~ "replaceable>, <replaceable>table</replaceable>, <replaceable>column</"
#~ "replaceable>, <replaceable>datatype</replaceable> , "
#~ "<replaceable>constraint</replaceable></literal>. The string "
#~ "representation of the objects passed as keyword-only arguments is used to "
#~ "enrich the messages reported to the client. For example: <placeholder-1/>"
#~ msgstr ""
#~ "Аргумент <replaceable>msg</replaceable> передаётся как позиционный. Для "
#~ "обратной совместимости может быть передано несколько позиционных "
#~ "аргументов. В этом случае сообщением для клиента становится строковое "
#~ "представление кортежа позиционных аргументов. Дополнительно только по "
#~ "ключам принимаются следующие аргументы: <literal><replaceable>detail</"
#~ "replaceable>, <replaceable>hint</replaceable>, <replaceable>sqlstate</"
#~ "replaceable>, <replaceable>schema</replaceable>, <replaceable>table</"
#~ "replaceable>, <replaceable>column</replaceable>, <replaceable>datatype</"
#~ "replaceable>, <replaceable>constraint</replaceable></literal>. Строковое "
#~ "представление объектов, передаваемых в аргументах по ключам, позволяет "
#~ "выдать клиенту более богатую информацию. Например: <placeholder-1/>"
