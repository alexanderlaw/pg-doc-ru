# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-21 15:22+0300\n"
"PO-Revision-Date: 2017-09-28 17:53+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5(title)
msgid "Functions and Operators"
msgstr "Функции и операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7(indexterm)
msgid "<primary>function</primary>"
msgstr "<primary>функция</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11(indexterm)
msgid "<primary>operator</primary>"
msgstr "<primary>оператор</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15(para)
msgid ""
"<productname>PostgreSQL</productname> provides a large number of functions "
"and operators for the built-in data types. Users can also define their own "
"functions and operators, as described in <xref linkend=\"server-programming"
"\"/>. The <application>psql</application> commands <command>\\df</command> "
"and <command>\\do</command> can be used to list all available functions and "
"operators, respectively."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет огромное количество "
"функций и операторов для встроенных типов данных. Кроме того, пользователи "
"могут определять свои функции операторы, как описано в <xref remap=\"6\" "
"linkend=\"server-programming\"/>. Просмотреть все существующие функции и "
"операторы можно в <application>psql</application> с помощью команд <command>"
"\\df</command> и <command>\\do</command>, соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:25(para)
msgid ""
"If you are concerned about portability then note that most of the functions "
"and operators described in this chapter, with the exception of the most "
"trivial arithmetic and comparison operators and some explicitly marked "
"functions, are not specified by the <acronym>SQL</acronym> standard. Some of "
"this extended functionality is present in other <acronym>SQL</acronym> "
"database management systems, and in many cases this functionality is "
"compatible and consistent between the various implementations. This chapter "
"is also not exhaustive; additional functions appear in relevant sections of "
"the manual."
msgstr ""
"Если для вас важна переносимость, учтите, что практически все функции и "
"операторы, описанные в этой главе, за исключением простейших арифметических "
"и операторов сравнения, а также явно отмеченных функций, не описаны в "
"стандарте <acronym>SQL</acronym>. Тем не менее, частично эта расширенная "
"функциональность присутствует и в других СУБД <acronym>SQL</acronym> и во "
"многих случаях различные реализации одинаковых функций оказываются "
"аналогичными и совместимыми. В этой главе не описываются абсолютно все "
"функции; некоторые дополнительные функции рассматриваются в других разделах "
"документации."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:40(title)
msgid "Logical Operators"
msgstr "Логические операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:42(indexterm)
msgid "<primary>operator</primary> <secondary>logical</secondary>"
msgstr "<primary>оператор</primary> <secondary>логический</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:47(indexterm)
msgid ""
"<primary>Boolean</primary> <secondary>operators</secondary> <see>operators, "
"logical</see>"
msgstr ""
"<primary>Булевы</primary> <secondary>операторы</secondary> <see>операторы, "
"логические</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:56(indexterm)
msgid "<primary>AND (operator)</primary>"
msgstr "<primary>AND (оператор)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:60(indexterm)
msgid "<primary>OR (operator)</primary>"
msgstr "<primary>OR (оператор)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:64(indexterm)
msgid "<primary>NOT (operator)</primary>"
msgstr "<primary>NOT (оператор)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:68(indexterm)
msgid "<primary>conjunction</primary>"
msgstr "<primary>конъюнкция</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:72(indexterm)
msgid "<primary>disjunction</primary>"
msgstr "<primary>дизъюнкция</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:76(indexterm)
msgid "<primary>negation</primary>"
msgstr "<primary>отрицание</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:81(literal) func.xml:278(literal) func.xml:283(literal)
#: func.xml:288(literal) func.xml:293(literal)
msgid "AND"
msgstr "AND"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:82(literal)
msgid "OR"
msgstr "OR"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:83(literal)
msgid "NOT"
msgstr "NOT"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:94(replaceable) func.xml:151(replaceable) func.xml:278(replaceable)
#: func.xml:283(replaceable) func.xml:288(replaceable)
#: func.xml:293(replaceable) func.xml:298(replaceable)
#: func.xml:303(replaceable)
msgctxt "replaceable"
msgid "a"
msgstr "a"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:95(replaceable) func.xml:298(replaceable) func.xml:303(replaceable)
msgctxt "replaceable"
msgid "b"
msgstr "b"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:96(entry)
msgid "<replaceable>a</replaceable> AND <replaceable>b</replaceable>"
msgstr "<replaceable>a</replaceable> AND <replaceable>b</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:97(entry)
msgid "<replaceable>a</replaceable> OR <replaceable>b</replaceable>"
msgstr "<replaceable>a</replaceable> OR <replaceable>b</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:103(entry) func.xml:104(entry) func.xml:105(entry)
#: func.xml:106(entry) func.xml:110(entry) func.xml:113(entry)
#: func.xml:117(entry) func.xml:120(entry) func.xml:158(entry)
#: func.xml:164(entry)
msgid "TRUE"
msgstr "TRUE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:111(entry) func.xml:112(entry) func.xml:124(entry)
#: func.xml:125(entry) func.xml:126(entry) func.xml:127(entry)
#: func.xml:131(entry) func.xml:133(entry) func.xml:159(entry)
#: func.xml:163(entry)
msgid "FALSE"
msgstr "FALSE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:118(entry) func.xml:119(entry) func.xml:132(entry)
#: func.xml:134(entry) func.xml:138(entry) func.xml:139(entry)
#: func.xml:140(entry) func.xml:141(entry) func.xml:168(entry)
#: func.xml:169(entry)
msgctxt "entry"
msgid "NULL"
msgstr "NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:152(entry)
msgid "NOT <replaceable>a</replaceable>"
msgstr "NOT <replaceable>a</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:53(para)
msgid ""
"The usual logical operators are available: <placeholder-1/> <placeholder-2/> "
"<placeholder-3/> <placeholder-4/> <placeholder-5/> <placeholder-6/> "
"<placeholder-7/> <acronym>SQL</acronym> uses a three-valued logic system "
"with true, false, and <literal>null</literal>, which represents "
"<quote>unknown</quote>. Observe the following truth tables: <placeholder-8/> "
"<placeholder-9/>"
msgstr ""
"Набор логических операторов включает обычные: <placeholder-1/> "
"<placeholder-2/> <placeholder-3/> <placeholder-4/> <placeholder-5/> "
"<placeholder-6/> <placeholder-7/> В <acronym>SQL</acronym> работает "
"логическая система с тремя состояниями: true (истина), false (ложь) и "
"<literal>NULL</literal>, <quote>неопределённое</quote> состояние. "
"Рассмотрите следующие таблицы истинности: <placeholder-8/> <placeholder-9/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:176(para)
msgid ""
"The operators <literal>AND</literal> and <literal>OR</literal> are "
"commutative, that is, you can switch the left and right operand without "
"affecting the result. But see <xref linkend=\"syntax-express-eval\"/> for "
"more information about the order of evaluation of subexpressions."
msgstr ""
"Операторы <literal>AND</literal> и <literal>OR</literal> коммутативны, то "
"есть от перемены мест операндов результат не меняется. Однако значение может "
"иметь порядок вычисления подвыражений. Подробнее это описано в <xref remap="
"\"6\" linkend=\"syntax-express-eval\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:186(title)
msgid "Comparison Functions and Operators"
msgstr "Функции и операторы сравнения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:188(indexterm)
msgid "<primary>comparison</primary> <secondary>operators</secondary>"
msgstr "<primary>сравнение</primary> <secondary>операторы</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:193(para)
msgid ""
"The usual comparison operators are available, as shown in <xref linkend="
"\"functions-comparison-op-table\"/>."
msgstr ""
"Набор операторов сравнения включает обычные операторы, перечисленные в <xref "
"remap=\"6\" linkend=\"functions-comparison-op-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:199(title)
msgid "Comparison Operators"
msgstr "Операторы сравнения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:203(entry) func.xml:604(entry) func.xml:3724(entry)
#: func.xml:4158(entry) func.xml:6757(entry) func.xml:8384(entry)
#: func.xml:8920(entry) func.xml:9348(entry) func.xml:11046(entry)
#: func.xml:11139(entry) func.xml:12438(entry) func.xml:12913(entry)
msgid "Operator"
msgstr "Оператор"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:204(entry) func.xml:272(entry) func.xml:549(entry)
#: func.xml:605(entry) func.xml:762(entry) func.xml:1109(entry)
#: func.xml:1163(entry) func.xml:1359(entry) func.xml:1592(entry)
#: func.xml:3400(entry) func.xml:3515(entry) func.xml:3725(entry)
#: func.xml:4159(entry) func.xml:4565(entry) func.xml:4751(entry)
#: func.xml:4965(entry) func.xml:5106(entry) func.xml:5163(entry)
#: func.xml:5219(entry) func.xml:5300(entry) func.xml:5752(entry)
#: func.xml:5868(entry) func.xml:6098(entry) func.xml:6349(entry)
#: func.xml:6528(entry) func.xml:6888(entry) func.xml:7980(entry)
#: func.xml:8280(entry) func.xml:8385(entry) func.xml:8602(entry)
#: func.xml:8705(entry) func.xml:8921(entry) func.xml:9031(entry)
#: func.xml:9231(entry) func.xml:9276(entry) func.xml:9350(entry)
#: func.xml:9445(entry) func.xml:9809(entry) func.xml:11048(entry)
#: func.xml:11141(entry) func.xml:11276(entry) func.xml:11499(entry)
#: func.xml:11939(entry) func.xml:12439(entry) func.xml:12623(entry)
#: func.xml:12914(entry) func.xml:13112(entry) func.xml:13255(entry)
#: func.xml:13702(entry) func.xml:14119(entry) func.xml:14278(entry)
#: func.xml:14398(entry) func.xml:14500(entry) func.xml:15488(entry)
#: func.xml:15597(entry) func.xml:15745(entry) func.xml:16215(entry)
#: func.xml:16673(entry) func.xml:16957(entry) func.xml:17273(entry)
#: func.xml:17332(entry) func.xml:17363(entry) func.xml:17496(entry)
#: func.xml:17605(entry) func.xml:17703(entry) func.xml:17768(entry)
#: func.xml:17847(entry) func.xml:17887(entry) func.xml:18245(entry)
#: func.xml:18363(entry) func.xml:18498(entry) func.xml:18753(entry)
#: func.xml:18833(entry) func.xml:18924(entry) func.xml:18993(entry)
#: func.xml:19419(entry) func.xml:19671(entry) func.xml:19742(entry)
#: func.xml:19825(entry) func.xml:19903(entry) func.xml:20070(entry)
#: func.xml:20430(entry) func.xml:20517(entry) func.xml:20652(entry)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:210(literal) func.xml:8927(literal) func.xml:12460(literal)
#: func.xml:12935(literal)
msgid "&lt;"
msgstr "&lt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:211(entry) func.xml:12461(entry) func.xml:12936(entry)
msgid "less than"
msgstr "меньше"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:215(literal) func.xml:8947(literal) func.xml:12467(literal)
#: func.xml:12942(literal)
msgid "&gt;"
msgstr "&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:216(entry) func.xml:12468(entry) func.xml:12943(entry)
msgid "greater than"
msgstr "больше"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:220(literal) func.xml:8932(literal) func.xml:12474(literal)
#: func.xml:12949(literal)
msgid "&lt;="
msgstr "&lt;="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:221(entry)
msgid "less than or equal to"
msgstr "меньше или равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:225(literal) func.xml:8942(literal) func.xml:12481(literal)
#: func.xml:12956(literal)
msgid "&gt;="
msgstr "&gt;="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:226(entry)
msgid "greater than or equal to"
msgstr "больше или равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:230(literal) func.xml:8937(literal) func.xml:12446(literal)
#: func.xml:12921(literal)
msgid "="
msgstr "="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:231(entry) func.xml:12447(entry) func.xml:12922(entry)
msgid "equal"
msgstr "равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:235(entry)
msgid "<literal>&lt;&gt;</literal> or <literal>!=</literal>"
msgstr "<literal>&lt;&gt;</literal> или <literal>!=</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:236(entry) func.xml:12454(entry) func.xml:12929(entry)
msgid "not equal"
msgstr "не равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:243(para)
msgid ""
"The <literal>!=</literal> operator is converted to <literal>&lt;&gt;</"
"literal> in the parser stage. It is not possible to implement <literal>!=</"
"literal> and <literal>&lt;&gt;</literal> operators that do different things."
msgstr ""
"Оператор <literal>!=</literal> преобразуется в <literal>&lt;&gt;</literal> "
"на стадии разбора запроса. Как следствие, реализовать операторы <literal>!=</"
"literal> и <literal>&lt;&gt;</literal> по-разному невозможно."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:251(para)
msgid ""
"Comparison operators are available for all relevant data types. All "
"comparison operators are binary operators that return values of type "
"<type>boolean</type>; expressions like <literal>1 &lt; 2 &lt; 3</literal> "
"are not valid (because there is no <literal>&lt;</literal> operator to "
"compare a Boolean value with <literal>3</literal>)."
msgstr ""
"Операторы сравнения определены для всех типов данных, для которых они имеют "
"смысл. Все операторы сравнения представляют собой бинарные операторы, "
"возвращающие значения типа <type>boolean</type>; при этом выражения вида "
"<literal>1 &lt; 2 &lt; 3</literal> недопустимы (так как не существует "
"оператора <literal>&lt;</literal>, который бы сравнивал булево значение с "
"<literal>3</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:260(para)
msgid ""
"There are also some comparison predicates, as shown in <xref linkend="
"\"functions-comparison-pred-table\"/>. These behave much like operators, but "
"have special syntax mandated by the SQL standard."
msgstr ""
"Существует также несколько предикатов сравнения; они приведены в <xref remap="
"\"6\" linkend=\"functions-comparison-pred-table\"/>. Они работают подобно "
"операторам, но имеют особый синтаксис, установленный стандартом SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:267(title)
msgid "Comparison Predicates"
msgstr "Предикаты сравнения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:271(entry)
msgid "Predicate"
msgstr "Предикат"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:278(literal)
msgid "BETWEEN"
msgstr "BETWEEN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:278(replaceable) func.xml:283(replaceable)
#: func.xml:288(replaceable) func.xml:293(replaceable)
#: func.xml:774(replaceable) func.xml:1172(replaceable)
#: func.xml:1177(replaceable) func.xml:1187(replaceable)
#: func.xml:1193(replaceable) func.xml:1203(replaceable)
#: func.xml:1209(replaceable) func.xml:1220(replaceable)
#: func.xml:1227(replaceable) func.xml:1238(replaceable)
#: func.xml:1244(replaceable) func.xml:1254(replaceable)
#: func.xml:1260(replaceable) func.xml:1270(replaceable)
#: func.xml:1276(replaceable) func.xml:1286(replaceable)
#: func.xml:1292(replaceable) func.xml:4620(replaceable)
msgctxt "replaceable"
msgid "x"
msgstr "x"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:278(replaceable) func.xml:283(replaceable)
#: func.xml:288(replaceable) func.xml:293(replaceable)
#: func.xml:1219(replaceable) func.xml:1226(replaceable)
msgctxt "replaceable"
msgid "y"
msgstr "y"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:279(entry)
msgid "between"
msgstr "между"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:283(literal)
msgid "NOT BETWEEN"
msgstr "NOT BETWEEN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:284(entry)
msgid "not between"
msgstr "не между"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:288(literal)
msgid "BETWEEN SYMMETRIC"
msgstr "BETWEEN SYMMETRIC"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:289(entry)
msgid "between, after sorting the comparison values"
msgstr "между, после сортировки сравниваемых значений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:293(literal)
msgid "NOT BETWEEN SYMMETRIC"
msgstr "NOT BETWEEN SYMMETRIC"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:294(entry)
msgid "not between, after sorting the comparison values"
msgstr "не между, после сортировки сравниваемых значений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:298(literal)
msgid "IS DISTINCT FROM"
msgstr "IS DISTINCT FROM"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:299(entry)
msgid "not equal, treating null like an ordinary value"
msgstr "не равно, при этом NULL воспринимается как обычное значение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:303(literal)
msgid "IS NOT DISTINCT FROM"
msgstr "IS NOT DISTINCT FROM"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:304(entry)
msgid "equal, treating null like an ordinary value"
msgstr "равно, при этом NULL воспринимается как обычное значение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:308(replaceable) func.xml:313(replaceable)
#: func.xml:318(replaceable) func.xml:323(replaceable)
#: func.xml:13265(replaceable) func.xml:13279(replaceable)
#: func.xml:13301(replaceable) func.xml:13322(replaceable)
#: func.xml:13340(replaceable) func.xml:13358(replaceable)
#: func.xml:13375(replaceable) func.xml:13401(replaceable)
#: func.xml:13416(replaceable) func.xml:13433(replaceable)
#: func.xml:13450(replaceable) func.xml:13501(replaceable)
#: func.xml:13519(replaceable) func.xml:13538(replaceable)
#: func.xml:13557(replaceable) func.xml:13580(replaceable)
#: func.xml:13959(replaceable) func.xml:13983(replaceable)
#: func.xml:14007(replaceable) func.xml:14848(replaceable)
#: func.xml:14904(replaceable) func.xml:14960(replaceable)
#: func.xml:14961(replaceable) func.xml:15025(replaceable)
#: func.xml:15173(replaceable) func.xml:15204(replaceable)
#: func.xml:15245(replaceable) func.xml:15246(replaceable)
#: func.xml:15282(replaceable)
msgid "expression"
msgstr "выражение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:308(literal)
msgid "IS NULL"
msgstr "IS NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:309(entry)
msgid "is null"
msgstr "эквивалентно NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:313(literal)
msgid "IS NOT NULL"
msgstr "IS NOT NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:314(entry)
msgid "is not null"
msgstr "не эквивалентно NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:318(literal)
msgid "ISNULL"
msgstr "ISNULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:319(entry)
msgid "is null (nonstandard syntax)"
msgstr "эквивалентно NULL (нестандартный синтаксис)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:323(literal)
msgid "NOTNULL"
msgstr "NOTNULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:324(entry)
msgid "is not null (nonstandard syntax)"
msgstr "не эквивалентно NULL (нестандартный синтаксис)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:328(replaceable) func.xml:333(replaceable)
#: func.xml:338(replaceable) func.xml:343(replaceable)
#: func.xml:348(replaceable) func.xml:353(replaceable)
msgid "boolean_expression"
msgstr "логическое_выражение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:328(literal)
msgid "IS TRUE"
msgstr "IS TRUE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:329(entry)
msgid "is true"
msgstr "истина"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:333(literal)
msgid "IS NOT TRUE"
msgstr "IS NOT TRUE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:334(entry)
msgid "is false or unknown"
msgstr "ложь или неопределённость"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:338(literal)
msgid "IS FALSE"
msgstr "IS FALSE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:339(entry)
msgid "is false"
msgstr "ложь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:343(literal)
msgid "IS NOT FALSE"
msgstr "IS NOT FALSE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:344(entry)
msgid "is true or unknown"
msgstr "истина или неопределённость"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:348(literal)
msgid "IS UNKNOWN"
msgstr "IS UNKNOWN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:349(entry)
msgid "is unknown"
msgstr "неопределённость"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:353(literal)
msgid "IS NOT UNKNOWN"
msgstr "IS NOT UNKNOWN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:354(entry)
msgid "is true or false"
msgstr "истина или ложь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:361(indexterm)
msgid "<primary>BETWEEN</primary>"
msgstr "<primary>BETWEEN</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:382(indexterm)
msgid "<primary>BETWEEN SYMMETRIC</primary>"
msgstr "<primary>BETWEEN SYMMETRIC</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:360(para)
msgid ""
"<placeholder-1/> The <token>BETWEEN</token> predicate simplifies range "
"tests: <synopsis>\n"
"<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> is equivalent to <synopsis>\n"
"<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND "
"<replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>\n"
"</synopsis> Notice that <token>BETWEEN</token> treats the endpoint values as "
"included in the range. <literal>NOT BETWEEN</literal> does the opposite "
"comparison: <synopsis>\n"
"<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> is equivalent to <synopsis>\n"
"<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR "
"<replaceable>a</replaceable> &gt; <replaceable>y</replaceable>\n"
"</synopsis> <placeholder-2/> <literal>BETWEEN SYMMETRIC</literal> is like "
"<literal>BETWEEN</literal> except there is no requirement that the argument "
"to the left of <literal>AND</literal> be less than or equal to the argument "
"on the right. If it is not, those two arguments are automatically swapped, "
"so that a nonempty range is always implied."
msgstr ""
"<placeholder-1/> Предикат <token>BETWEEN</token> упрощает проверки "
"интервала: <synopsis>\n"
"<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> равнозначно выражению <synopsis>\n"
"<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND "
"<replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>\n"
"</synopsis> Заметьте, что <token>BETWEEN</token> считает, что границы "
"интервала также включаются в интервал. <literal>NOT BETWEEN</literal> "
"выполняет противоположное сравнение: <synopsis>\n"
"<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> равнозначно выражению <synopsis>\n"
"<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR "
"<replaceable>a</replaceable> &gt; <replaceable>y</replaceable>\n"
"</synopsis> <placeholder-2/> Предикат <literal>BETWEEN SYMMETRIC</literal> "
"аналогичен <literal>BETWEEN</literal>, за исключением того, что аргумент "
"слева от <literal>AND</literal> не обязательно должен быть меньше или равен "
"аргументу справа. Если это не так, аргументы автоматически меняются местами, "
"так что всегда подразумевается непустой интервал."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:393(indexterm) func.xml:15149(indexterm)
msgid "<primary>IS DISTINCT FROM</primary>"
msgstr "<primary>IS DISTINCT FROM</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:396(indexterm) func.xml:15153(indexterm)
msgid "<primary>IS NOT DISTINCT FROM</primary>"
msgstr "<primary>IS NOT DISTINCT FROM</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:392(para)
msgid ""
"<placeholder-1/> <placeholder-2/> Ordinary comparison operators yield null "
"(signifying <quote>unknown</quote>), not true or false, when either input is "
"null. For example, <literal>7 = NULL</literal> yields null, as does "
"<literal>7 &lt;&gt; NULL</literal>. When this behavior is not suitable, use "
"the <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> "
"predicates: <synopsis>\n"
"<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>\n"
"<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</"
"replaceable>\n"
"</synopsis> For non-null inputs, <literal>IS DISTINCT FROM</literal> is the "
"same as the <literal>&lt;&gt;</literal> operator. However, if both inputs "
"are null it returns false, and if only one input is null it returns true. "
"Similarly, <literal>IS NOT DISTINCT FROM</literal> is identical to "
"<literal>=</literal> for non-null inputs, but it returns true when both "
"inputs are null, and false when only one input is null. Thus, these "
"predicates effectively act as though null were a normal data value, rather "
"than <quote>unknown</quote>."
msgstr ""
"<placeholder-1/> <placeholder-2/> Обычные операторы сравнения выдают NULL "
"(что означает <quote>неопределённость</quote>), а не true или false, когда "
"любое из сравниваемых значений NULL. Например, <literal>7 = NULL</literal> "
"выдаёт NULL, так же, как и <literal>7 &lt;&gt; NULL</literal>. Когда это "
"поведение нежелательно, можно использовать предикаты <literal>IS <optional> "
"NOT </optional> DISTINCT FROM</literal>: <synopsis>\n"
"<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>\n"
"<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</"
"replaceable>\n"
"</synopsis> Для значений не NULL условие <literal>IS DISTINCT FROM</literal> "
"работает так же, как оператор <literal>&lt;&gt;</literal>. Однако, если оба "
"сравниваемых значения NULL, результат будет false, и только если одно из "
"значений NULL, возвращается true. Аналогично, условие <literal>IS NOT "
"DISTINCT FROM</literal> равносильно <literal>=</literal> для значений не "
"NULL, но возвращает true, если оба сравниваемых значения NULL и false в "
"противном случае. Таким образом, эти предикаты по сути работают с NULL, как "
"с обычным значением, а не с <quote>неопределённостью</quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:419(indexterm)
msgid "<primary>IS NULL</primary>"
msgstr "<primary>IS NULL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:422(indexterm)
msgid "<primary>IS NOT NULL</primary>"
msgstr "<primary>IS NOT NULL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:425(indexterm)
msgid "<primary>ISNULL</primary>"
msgstr "<primary>ISNULL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:428(indexterm)
msgid "<primary>NOTNULL</primary>"
msgstr "<primary>NOTNULL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:441(indexterm)
msgid "<primary>null value</primary><secondary>comparing</secondary>"
msgstr "<primary>NULL</primary> <secondary>сравнение</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:418(para)
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> To check "
"whether a value is or is not null, use the predicates: <synopsis>\n"
"<replaceable>expression</replaceable> IS NULL\n"
"<replaceable>expression</replaceable> IS NOT NULL\n"
"</synopsis> or the equivalent, but nonstandard, predicates: <synopsis>\n"
"<replaceable>expression</replaceable> ISNULL\n"
"<replaceable>expression</replaceable> NOTNULL\n"
"</synopsis> <placeholder-5/>"
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> Для "
"проверки, содержит ли значение NULL или нет, используются предикаты: "
"<synopsis>\n"
"<replaceable>выражение</replaceable> IS NULL\n"
"<replaceable>выражение</replaceable> IS NOT NULL\n"
"</synopsis> или равнозначные (но нестандартные) предикаты: <synopsis>\n"
"<replaceable>выражение</replaceable> ISNULL\n"
"<replaceable>выражение</replaceable> NOTNULL\n"
"</synopsis> <placeholder-5/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:444(para)
msgid ""
"Do <emphasis>not</emphasis> write <literal><replaceable>expression</"
"replaceable> = NULL</literal> because <literal>NULL</literal> is not "
"<quote>equal to</quote> <literal>NULL</literal>. (The null value represents "
"an unknown value, and it is not known whether two unknown values are equal.)"
msgstr ""
"Заметьте, что проверка <literal><replaceable>выражение</replaceable> = NULL</"
"literal> <emphasis>не</emphasis> будет работать, так как <literal>NULL</"
"literal> считается не <quote>равным</quote> <literal>NULL</literal>. "
"(Значение NULL представляет неопределённость, и равны ли две "
"неопределённости, тоже не определено.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:453(para)
msgid ""
"Some applications might expect that <literal><replaceable>expression</"
"replaceable> = NULL</literal> returns true if <replaceable>expression</"
"replaceable> evaluates to the null value. It is highly recommended that "
"these applications be modified to comply with the SQL standard. However, if "
"that cannot be done the <xref linkend=\"guc-transform-null-equals\"/> "
"configuration variable is available. If it is enabled, "
"<productname>PostgreSQL</productname> will convert <literal>x = NULL</"
"literal> clauses to <literal>x IS NULL</literal>."
msgstr ""
"Некоторые приложения могут ожидать, что <literal><replaceable>выражение</"
"replaceable> = NULL</literal> вернёт true, если результатом "
"<replaceable>выражения</replaceable> является NULL. Такие приложения "
"настоятельно рекомендуется исправить и привести в соответствие со стандартом "
"SQL. Однако, в случаях, когда это невозможно, это поведение можно изменить с "
"помощью параметра конфигурации <xref linkend=\"guc-transform-null-equals\"/"
">. Когда этот параметр включён, <productname>PostgreSQL</productname> "
"преобразует условие <literal>x = NULL</literal> в <literal>x IS NULL</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:466(para)
msgid ""
"If the <replaceable>expression</replaceable> is row-valued, then <literal>IS "
"NULL</literal> is true when the row expression itself is null or when all "
"the row's fields are null, while <literal>IS NOT NULL</literal> is true when "
"the row expression itself is non-null and all the row's fields are non-null. "
"Because of this behavior, <literal>IS NULL</literal> and <literal>IS NOT "
"NULL</literal> do not always return inverse results for row-valued "
"expressions; in particular, a row-valued expression that contains both null "
"and non-null fields will return false for both tests. In some cases, it may "
"be preferable to write <replaceable>row</replaceable> <literal>IS DISTINCT "
"FROM NULL</literal> or <replaceable>row</replaceable> <literal>IS NOT "
"DISTINCT FROM NULL</literal>, which will simply check whether the overall "
"row value is null without any additional tests on the row fields."
msgstr ""
"Если <replaceable>выражение</replaceable> возвращает табличную строку, тогда "
"<literal>IS NULL</literal> будет истинным, когда само выражение — NULL или "
"все поля строки — NULL, а <literal>IS NOT NULL</literal> будет истинным, "
"когда само выражение не NULL, и все поля строки так же не NULL. Вследствие "
"такого определения, <literal>IS NULL</literal> и <literal>IS NOT NULL</"
"literal> не всегда будут возвращать взаимодополняющие результаты для таких "
"выражений; в частности такие выражения со строками, одни поля которых NULL, "
"а другие не NULL, будут ложными одновременно. В некоторых случаях имеет "
"смысл написать <replaceable>строка</replaceable> <literal>IS DISTINCT FROM "
"NULL</literal> или <replaceable>строка</replaceable> <literal>IS NOT "
"DISTINCT FROM NULL</literal>, чтобы просто проверить, равно ли NULL всё "
"значение строки, без каких-либо дополнительных проверок полей строки."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:483(indexterm)
msgid "<primary>IS TRUE</primary>"
msgstr "<primary>IS TRUE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:486(indexterm)
msgid "<primary>IS NOT TRUE</primary>"
msgstr "<primary>IS NOT TRUE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:489(indexterm)
msgid "<primary>IS FALSE</primary>"
msgstr "<primary>IS FALSE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:492(indexterm)
msgid "<primary>IS NOT FALSE</primary>"
msgstr "<primary>IS NOT FALSE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:495(indexterm)
msgid "<primary>IS UNKNOWN</primary>"
msgstr "<primary>IS UNKNOWN</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:498(indexterm)
msgid "<primary>IS NOT UNKNOWN</primary>"
msgstr "<primary>IS NOT UNKNOWN</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:482(para)
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> "
"<placeholder-5/> <placeholder-6/> Boolean values can also be tested using "
"the predicates <synopsis>\n"
"<replaceable>boolean_expression</replaceable> IS TRUE\n"
"<replaceable>boolean_expression</replaceable> IS NOT TRUE\n"
"<replaceable>boolean_expression</replaceable> IS FALSE\n"
"<replaceable>boolean_expression</replaceable> IS NOT FALSE\n"
"<replaceable>boolean_expression</replaceable> IS UNKNOWN\n"
"<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN\n"
"</synopsis> These will always return true or false, never a null value, even "
"when the operand is null. A null input is treated as the logical value "
"<quote>unknown</quote>. Notice that <literal>IS UNKNOWN</literal> and "
"<literal>IS NOT UNKNOWN</literal> are effectively the same as <literal>IS "
"NULL</literal> and <literal>IS NOT NULL</literal>, respectively, except that "
"the input expression must be of Boolean type."
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> "
"<placeholder-5/> <placeholder-6/> Логические значения можно также проверить "
"с помощью предикатов <synopsis>\n"
"<replaceable>логическое_выражение</replaceable> IS TRUE\n"
"<replaceable>логическое_выражение</replaceable> IS NOT TRUE\n"
"<replaceable>логическое_выражение</replaceable> IS FALSE\n"
"<replaceable>логическое_выражение</replaceable> IS NOT FALSE\n"
"<replaceable>логическое_выражение</replaceable> IS UNKNOWN\n"
"<replaceable>логическое_выражение</replaceable> IS NOT UNKNOWN\n"
"</synopsis> Они всегда возвращают true или false и никогда NULL, даже если "
"какой-любо операнд — NULL. Они интерпретируют значение NULL как "
"<quote>неопределённость</quote>. Заметьте, что <literal>IS UNKNOWN</literal> "
"и <literal>IS NOT UNKNOWN</literal> по сути равнозначны <literal>IS NULL</"
"literal> и <literal>IS NOT NULL</literal>, соответственно, за исключением "
"того, что выражение может быть только булевого типа."

#. IS OF does not conform to the ISO SQL behavior, so it is undocumented here
#. <para>
#. <indexterm>
#. <primary>IS OF</primary>
#. </indexterm>
#. <indexterm>
#. <primary>IS NOT OF</primary>
#. </indexterm>
#. It is possible to check the data type of an expression using the
#. predicates
#. <synopsis>
#. <replaceable>expression</replaceable> IS OF (typename, ...)
#. <replaceable>expression</replaceable> IS NOT OF (typename, ...)
#. </synopsis>
#. They return a boolean value based on whether the expression's data
#. type is one of the listed data types.
#. </para>
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:538(para)
msgid ""
"Some comparison-related functions are also available, as shown in <xref "
"linkend=\"functions-comparison-func-table\"/>."
msgstr ""
"Также имеется несколько связанных со сравнениями функций; они перечислены в "
"<xref remap=\"6\" linkend=\"functions-comparison-func-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:544(title)
msgid "Comparison Functions"
msgstr "Функции сравнения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:548(entry) func.xml:760(entry) func.xml:1107(entry)
#: func.xml:1357(entry) func.xml:1590(entry) func.xml:3398(entry)
#: func.xml:3513(entry) func.xml:5750(entry) func.xml:6886(entry)
#: func.xml:8279(entry) func.xml:8600(entry) func.xml:8703(entry)
#: func.xml:9029(entry) func.xml:9229(entry) func.xml:9274(entry)
#: func.xml:9443(entry) func.xml:9807(entry) func.xml:11275(entry)
#: func.xml:11497(entry) func.xml:11939(entry) func.xml:12621(entry)
#: func.xml:13110(entry) func.xml:13251(entry) func.xml:13698(entry)
#: func.xml:14114(entry) func.xml:14273(entry) func.xml:14396(entry)
#: func.xml:14498(entry) func.xml:15485(entry) func.xml:15595(entry)
#: func.xml:18991(entry)
msgid "Function"
msgstr "Функция"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:550(entry) func.xml:606(entry) func.xml:763(entry)
#: func.xml:1360(entry) func.xml:1593(entry) func.xml:3401(entry)
#: func.xml:3516(entry) func.xml:3726(entry) func.xml:4160(entry)
#: func.xml:5753(entry) func.xml:6099(entry) func.xml:6529(entry)
#: func.xml:6758(entry) func.xml:6889(entry) func.xml:8281(entry)
#: func.xml:8386(entry) func.xml:8603(entry) func.xml:8706(entry)
#: func.xml:8922(entry) func.xml:9032(entry) func.xml:9232(entry)
#: func.xml:9277(entry) func.xml:9351(entry) func.xml:9446(entry)
#: func.xml:9810(entry) func.xml:11049(entry) func.xml:11142(entry)
#: func.xml:11277(entry) func.xml:11500(entry) func.xml:12440(entry)
#: func.xml:12624(entry) func.xml:12915(entry) func.xml:13113(entry)
msgid "Example"
msgstr "Пример"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:551(entry) func.xml:8282(entry) func.xml:11050(entry)
#: func.xml:11278(entry) func.xml:11501(entry)
msgid "Example Result"
msgstr "Результат примера"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:557(indexterm)
msgid "<primary>num_nonnulls</primary>"
msgstr "<primary>num_nonnulls</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:560(literal)
msgid "num_nonnulls(VARIADIC \"any\")"
msgstr "num_nonnulls(VARIADIC \"any\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:562(entry)
msgid "returns the number of non-null arguments"
msgstr "возвращает число аргументов, отличных от NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:563(literal)
msgid "num_nonnulls(1, NULL, 2)"
msgstr "num_nonnulls(1, NULL, 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:564(literal) func.xml:637(literal) func.xml:728(literal)
#: func.xml:845(literal) func.xml:897(literal) func.xml:1003(literal)
#: func.xml:1090(literal) func.xml:2259(literal) func.xml:11081(literal)
#: func.xml:12660(literal) func.xml:12719(literal)
msgctxt "literal"
msgid "2"
msgstr "2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:568(indexterm)
msgid "<primary>num_nulls</primary>"
msgstr "<primary>num_nulls</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:571(literal)
msgid "num_nulls(VARIADIC \"any\")"
msgstr "num_nulls(VARIADIC \"any\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:573(entry)
msgid "returns the number of null arguments"
msgstr "возвращает число аргументов NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:574(literal)
msgid "num_nulls(1, NULL, 2)"
msgstr "num_nulls(1, NULL, 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:575(literal) func.xml:644(literal) func.xml:920(literal)
#: func.xml:3589(literal)
msgctxt "literal"
msgid "1"
msgstr "1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:584(title)
msgid "Mathematical Functions and Operators"
msgstr "Математические функции и операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:586(para)
msgid ""
"Mathematical operators are provided for many <productname>PostgreSQL</"
"productname> types. For types without standard mathematical conventions (e."
"g., date/time types) we describe the actual behavior in subsequent sections."
msgstr ""
"Математические операторы определены для множества типов "
"<productname>PostgreSQL</productname>. Как работают эти операции с типами, "
"для которых нет стандартных соглашений о математических действиях (например, "
"с типами даты/времени), мы опишем в последующих разделах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:594(para)
msgid ""
"<xref linkend=\"functions-math-op-table\"/> shows the available mathematical "
"operators."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-op-table\"/> перечислены все "
"доступные математические операторы."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:599(title)
msgid "Mathematical Operators"
msgstr "Математические операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:607(entry) func.xml:764(entry) func.xml:1361(entry)
#: func.xml:1594(entry) func.xml:3402(entry) func.xml:3517(entry)
#: func.xml:3727(entry) func.xml:6563(entry) func.xml:6759(entry)
#: func.xml:6890(entry) func.xml:9033(entry) func.xml:9233(entry)
#: func.xml:9278(entry) func.xml:9352(entry) func.xml:9447(entry)
#: func.xml:9811(entry) func.xml:12441(entry) func.xml:12625(entry)
#: func.xml:12916(entry) func.xml:13114(entry)
msgid "Result"
msgstr "Результат"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:613(literal) func.xml:4658(literal) func.xml:6765(literal)
#: func.xml:6771(literal) func.xml:6777(literal) func.xml:6783(literal)
#: func.xml:6789(literal) func.xml:6795(literal) func.xml:8391(literal)
#: func.xml:8997(literal) func.xml:13033(literal)
msgid "+"
msgstr "+"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:614(entry) func.xml:8998(entry)
msgid "addition"
msgstr "сложение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:615(literal)
msgid "2 + 3"
msgstr "2 + 3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:616(literal) func.xml:658(literal) func.xml:686(literal)
#: func.xml:3432(literal) func.xml:3628(literal) func.xml:9497(literal)
#: func.xml:11514(literal)
msgctxt "literal"
msgid "5"
msgstr "5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:620(literal) func.xml:6801(literal) func.xml:6807(literal)
#: func.xml:6813(literal) func.xml:6819(literal) func.xml:6825(literal)
#: func.xml:6831(literal) func.xml:6837(literal) func.xml:6843(literal)
#: func.xml:6849(literal) func.xml:8396(literal) func.xml:9002(literal)
#: func.xml:9007(literal) func.xml:11188(literal) func.xml:11196(literal)
#: func.xml:11204(literal) func.xml:13047(literal)
msgid "-"
msgstr "-"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:621(entry) func.xml:9003(entry) func.xml:9008(entry)
msgid "subtraction"
msgstr "вычитание"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:622(literal)
msgid "2 - 3"
msgstr "2 - 3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:623(literal) func.xml:1016(literal)
msgid "-1"
msgstr "-1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:627(literal) func.xml:4653(literal) func.xml:6855(literal)
#: func.xml:6861(literal) func.xml:6867(literal) func.xml:8401(literal)
#: func.xml:13040(literal)
msgid "*"
msgstr "*"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:628(entry)
msgid "multiplication"
msgstr "умножение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:629(literal)
msgid "2 * 3"
msgstr "2 * 3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:630(literal) func.xml:9079(literal)
msgid "6"
msgstr "6"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:634(literal) func.xml:6873(literal) func.xml:8406(literal)
msgid "/"
msgstr "/"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:635(entry)
msgid "division (integer division truncates the result)"
msgstr "деление (при целочисленном делении остаток отбрасывается)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:636(literal)
msgid "4 / 2"
msgstr "4 / 2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:641(literal)
msgid "%"
msgstr "%"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:642(entry)
msgid "modulo (remainder)"
msgstr "остаток от деления"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:643(literal)
msgid "5 % 4"
msgstr "5 % 4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:648(literal) func.xml:4757(literal)
msgid "^"
msgstr "^"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:649(entry)
msgid "exponentiation (associates left to right)"
msgstr "возведение в степень (вычисляется слева направо)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:650(literal)
msgid "2.0 ^ 3.0"
msgstr "2.0 ^ 3.0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:651(literal)
msgid "8"
msgstr "8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:655(literal)
msgid "|/"
msgstr "|/"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:656(entry) func.xml:1027(entry)
msgid "square root"
msgstr "квадратный корень"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:657(literal)
msgid "|/ 25.0"
msgstr "|/ 25.0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:662(literal)
msgid "||/"
msgstr "||/"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:663(entry) func.xml:790(entry)
msgid "cube root"
msgstr "кубический корень"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:664(literal)
msgid "||/ 27.0"
msgstr "||/ 27.0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:665(literal) func.xml:792(literal) func.xml:1066(literal)
#: func.xml:1078(literal) func.xml:1485(literal) func.xml:3460(literal)
#: func.xml:6999(literal) func.xml:7047(literal) func.xml:9485(literal)
#: func.xml:11074(literal) func.xml:11095(literal) func.xml:12695(literal)
msgctxt "literal"
msgid "3"
msgstr "3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:669(literal)
msgid "!"
msgstr "!"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:670(entry)
msgid "factorial"
msgstr "факториал"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:671(literal)
msgid "5 !"
msgstr "5 !"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:672(literal) func.xml:679(literal) func.xml:1614(literal)
msgid "120"
msgstr "120"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:676(literal) func.xml:9392(literal)
msgid "!!"
msgstr "!!"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:677(entry)
msgid "factorial (prefix operator)"
msgstr "факториал (префиксная форма)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:678(literal)
msgid "!! 5"
msgstr "!! 5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:683(literal)
msgid "@"
msgstr "@"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:684(entry) func.xml:777(entry)
msgid "absolute value"
msgstr "модуль числа (абсолютное значение)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:685(literal)
msgid "@ -5.0"
msgstr "@ -5.0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:690(literal) func.xml:3740(literal) func.xml:8987(literal)
msgid "&amp;"
msgstr "&amp;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:691(entry) func.xml:3741(entry) func.xml:8988(entry)
msgid "bitwise AND"
msgstr "битовый AND"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:692(literal)
msgid "91 &amp; 15"
msgstr "91 &amp; 15"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:693(literal)
msgid "11"
msgstr "11"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:697(literal) func.xml:3747(literal) func.xml:8992(literal)
msgid "|"
msgstr "|"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:698(entry) func.xml:3748(entry) func.xml:8993(entry)
msgid "bitwise OR"
msgstr "битовый OR"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:699(literal)
msgid "32 | 3"
msgstr "32 | 3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:700(literal)
msgid "35"
msgstr "35"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:704(literal) func.xml:3754(literal) func.xml:8411(literal)
#: func.xml:8416(literal)
msgid "#"
msgstr "#"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:705(entry) func.xml:3755(entry)
msgid "bitwise XOR"
msgstr "битовый XOR"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:706(literal)
msgid "17 # 5"
msgstr "17 # 5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:707(literal) func.xml:6989(literal) func.xml:7037(literal)
msgctxt "literal"
msgid "20"
msgstr "20"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:711(literal) func.xml:3761(literal) func.xml:4166(literal)
#: func.xml:8982(literal)
msgid "~"
msgstr "~"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:712(entry) func.xml:3762(entry) func.xml:8983(entry)
msgid "bitwise NOT"
msgstr "битовый NOT"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:713(literal)
msgid "~1"
msgstr "~1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:714(literal)
msgid "-2"
msgstr "-2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:718(literal) func.xml:3768(literal) func.xml:8446(literal)
#: func.xml:8957(literal) func.xml:12998(literal)
msgid "&lt;&lt;"
msgstr "&lt;&lt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:719(entry) func.xml:3769(entry)
msgid "bitwise shift left"
msgstr "битовый сдвиг влево"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:720(literal)
msgid "1 &lt;&lt; 4"
msgstr "1 &lt;&lt; 4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:721(literal)
msgctxt "literal"
msgid "16"
msgstr "16"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:725(literal) func.xml:3775(literal) func.xml:8451(literal)
#: func.xml:8967(literal) func.xml:13005(literal)
msgid "&gt;&gt;"
msgstr "&gt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:726(entry) func.xml:3776(entry)
msgid "bitwise shift right"
msgstr "битовый сдвиг вправо"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:727(literal)
msgid "8 &gt;&gt; 2"
msgstr "8 &gt;&gt; 2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:735(para)
msgid ""
"The bitwise operators work only on integral data types, whereas the others "
"are available for all numeric data types. The bitwise operators are also "
"available for the bit string types <type>bit</type> and <type>bit varying</"
"type>, as shown in <xref linkend=\"functions-bit-string-op-table\"/>."
msgstr ""
"Битовые операторы работают только с целостными типами данных, тогда как "
"другие и работают и с остальными числовыми типами. Битовые операции также "
"работают с битовыми строками <type>bit</type> и <type>bit varying</type>, "
"как показано в <xref remap=\"6\" linkend=\"functions-bit-string-op-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:743(para)
msgid ""
"<xref linkend=\"functions-math-func-table\"/> shows the available "
"mathematical functions. In the table, <literal>dp</literal> indicates "
"<type>double precision</type>. Many of these functions are provided in "
"multiple forms with different argument types. Except where noted, any given "
"form of a function returns the same data type as its argument. The functions "
"working with <type>double precision</type> data are mostly implemented on "
"top of the host system's C library; accuracy and behavior in boundary cases "
"can therefore vary depending on the host system."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-func-table\"/> перечислены все "
"существующие математические функции. Сокращение <literal>dp</literal> в ней "
"обозначает тип <type>double precision</type> (плавающее с двойной "
"точностью). Многие из этих функций имеют несколько форм с разными типами "
"аргументов. За исключением случаев, где это указано явно, любая форма "
"функции возвращает результат того же типа, что и аргумент. Функции, "
"работающие с данными <type>double precision</type>, в массе своей используют "
"реализации из системных библиотек сервера, поэтому точность и поведение в "
"граничных случаях может зависеть от системы сервера."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:756(title)
msgid "Mathematical Functions"
msgstr "Математические функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:761(entry) func.xml:1108(entry) func.xml:1358(entry)
#: func.xml:1591(entry) func.xml:3399(entry) func.xml:3514(entry)
#: func.xml:5751(entry) func.xml:6887(entry) func.xml:7979(entry)
#: func.xml:8601(entry) func.xml:8704(entry) func.xml:9030(entry)
#: func.xml:9230(entry) func.xml:9275(entry) func.xml:9349(entry)
#: func.xml:9444(entry) func.xml:9808(entry) func.xml:11498(entry)
#: func.xml:11939(entry) func.xml:12622(entry) func.xml:13111(entry)
#: func.xml:13253(entry) func.xml:13700(entry) func.xml:14117(entry)
#: func.xml:14276(entry) func.xml:14397(entry) func.xml:14499(entry)
#: func.xml:15487(entry) func.xml:15596(entry) func.xml:15745(entry)
#: func.xml:16215(entry) func.xml:16673(entry) func.xml:16957(entry)
#: func.xml:17496(entry) func.xml:17605(entry) func.xml:17703(entry)
#: func.xml:17847(entry) func.xml:17887(entry) func.xml:18245(entry)
#: func.xml:18363(entry) func.xml:18498(entry) func.xml:18753(entry)
#: func.xml:18833(entry) func.xml:18924(entry) func.xml:18992(entry)
#: func.xml:19419(entry) func.xml:19671(entry) func.xml:19742(entry)
#: func.xml:19825(entry) func.xml:19903(entry) func.xml:20070(entry)
#: func.xml:20652(entry)
msgid "Return Type"
msgstr "Тип результата"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:771(indexterm)
msgid "<primary>abs</primary>"
msgstr "<primary>abs</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:774(function)
msgid "abs(<placeholder-1/>)"
msgstr "abs(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:776(entry) func.xml:802(entry) func.xml:815(entry)
#: func.xml:855(entry) func.xml:868(entry) func.xml:881(entry)
#: func.xml:894(entry) func.xml:979(entry) func.xml:1013(entry)
#: func.xml:1026(entry) func.xml:1039(entry)
msgid "(same as input)"
msgstr "тип аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:778(literal)
msgid "abs(-17.4)"
msgstr "abs(-17.4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:779(literal)
msgid "17.4"
msgstr "17.4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:784(indexterm)
msgid "<primary>cbrt</primary>"
msgstr "<primary>cbrt</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:787(type) func.xml:789(type) func.xml:800(type) func.xml:813(type)
#: func.xml:826(type) func.xml:828(type) func.xml:853(type) func.xml:866(type)
#: func.xml:879(type) func.xml:892(type) func.xml:930(type) func.xml:941(type)
#: func.xml:942(type) func.xml:944(type) func.xml:964(type) func.xml:966(type)
#: func.xml:977(type) func.xml:1011(type) func.xml:1024(type)
#: func.xml:1037(type) func.xml:1058(type) func.xml:1120(type)
#: func.xml:1129(type)
msgid "dp"
msgstr "dp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:787(function)
msgid "cbrt(<placeholder-1/>)"
msgstr "cbrt(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:791(literal)
msgid "cbrt(27.0)"
msgstr "cbrt(27.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:797(indexterm)
msgid "<primary>ceil</primary>"
msgstr "<primary>ceil</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:800(type) func.xml:813(type) func.xml:839(type) func.xml:840(type)
#: func.xml:842(type) func.xml:853(type) func.xml:866(type) func.xml:879(type)
#: func.xml:892(type) func.xml:901(type) func.xml:902(type) func.xml:903(type)
#: func.xml:951(type) func.xml:952(type) func.xml:953(type) func.xml:977(type)
#: func.xml:986(type) func.xml:987(type) func.xml:998(type) func.xml:1011(type)
#: func.xml:1024(type) func.xml:1037(type) func.xml:1046(type)
#: func.xml:1047(type) func.xml:1070(type) func.xml:5788(type)
#: func.xml:5811(type) func.xml:18591(type) func.xml:19493(type)
msgid "numeric"
msgstr "numeric"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:800(function)
msgid "ceil(<placeholder-1/> or <placeholder-2/>)"
msgstr "ceil(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:803(entry)
msgid "nearest integer greater than or equal to argument"
msgstr "ближайшее целое, большее или равное аргументу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:804(literal)
msgid "ceil(-42.8)"
msgstr "ceil(-42.8)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:805(literal)
msgid "-42"
msgstr "-42"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:810(indexterm)
msgid "<primary>ceiling</primary>"
msgstr "<primary>ceiling</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:813(function)
msgid "ceiling(<placeholder-1/> or <placeholder-2/>)"
msgstr "ceiling(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:816(entry)
msgid ""
"nearest integer greater than or equal to argument (same as <function>ceil</"
"function>)"
msgstr ""
"ближайшее целое, большее или равное аргументу (равнозначно <function>ceil</"
"function>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:817(literal)
msgid "ceiling(-95.3)"
msgstr "ceiling(-95.3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:818(literal)
msgid "-95"
msgstr "-95"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:823(indexterm)
msgid "<primary>degrees</primary>"
msgstr "<primary>degrees</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:826(function)
msgid "degrees(<placeholder-1/>)"
msgstr "degrees(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:829(entry)
msgid "radians to degrees"
msgstr "преобразование радианов в градусы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:830(literal)
msgid "degrees(0.5)"
msgstr "degrees(0.5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:831(literal)
msgid "28.6478897565412"
msgstr "28.6478897565&zwsp;412"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:836(indexterm)
msgid "<primary>div</primary>"
msgstr "<primary>div</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:839(parameter) func.xml:914(parameter)
msgctxt "parameter"
msgid "y"
msgstr "y"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:840(parameter) func.xml:902(parameter) func.xml:915(parameter)
msgctxt "parameter"
msgid "x"
msgstr "x"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:839(function)
msgid ""
"div(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"div(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:843(entry)
msgid "integer quotient of <parameter>y</parameter>/<parameter>x</parameter>"
msgstr ""
"целочисленный результат <parameter>y</parameter>/<parameter>x</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:844(literal)
msgid "div(9,4)"
msgstr "div(9,4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:850(indexterm)
msgid "<primary>exp</primary>"
msgstr "<primary>exp</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:853(function)
msgid "exp(<placeholder-1/> or <placeholder-2/>)"
msgstr "exp(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:856(entry)
msgid "exponential"
msgstr "экспонента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:857(literal)
msgid "exp(1.0)"
msgstr "exp(1.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:858(literal)
msgid "2.71828182845905"
msgstr "2.7182818284&zwsp;5905"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:863(indexterm)
msgid "<primary>floor</primary>"
msgstr "<primary>floor</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:866(function)
msgid "floor(<placeholder-1/> or <placeholder-2/>)"
msgstr "floor(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:869(entry)
msgid "nearest integer less than or equal to argument"
msgstr "ближайшее целое, меньшее или равное аргументу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:870(literal)
msgid "floor(-42.8)"
msgstr "floor(-42.8)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:871(literal)
msgid "-43"
msgstr "-43"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:876(indexterm)
msgid "<primary>ln</primary>"
msgstr "<primary>ln</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:879(function)
msgid "ln(<placeholder-1/> or <placeholder-2/>)"
msgstr "ln(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:882(entry)
msgid "natural logarithm"
msgstr "натуральный логарифм"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:883(literal)
msgid "ln(2.0)"
msgstr "ln(2.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:884(literal)
msgid "0.693147180559945"
msgstr "0.6931471805&zwsp;59945"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:889(indexterm)
msgid "<primary>log</primary>"
msgstr "<primary>log</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:892(function)
msgid "log(<placeholder-1/> or <placeholder-2/>)"
msgstr "log(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:895(entry)
msgid "base 10 logarithm"
msgstr "логарифм по основанию 10"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:896(literal)
msgid "log(100.0)"
msgstr "log(100.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:901(parameter) func.xml:942(parameter) func.xml:952(parameter)
msgctxt "parameter"
msgid "b"
msgstr "b"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:901(function)
msgid ""
"log(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"log(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:904(entry)
msgid "logarithm to base <parameter>b</parameter>"
msgstr "логарифм по основанию <parameter>b</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:905(literal)
msgid "log(2.0, 64.0)"
msgstr "log(2.0, 64.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:906(literal)
msgid "6.0000000000"
msgstr "6.0000000000"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:911(indexterm)
msgid "<primary>mod</primary>"
msgstr "<primary>mod</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:914(function)
msgid "mod(<placeholder-1/>, <placeholder-2/>)"
msgstr "mod(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:917(entry)
msgid "(same as argument types)"
msgstr "зависит от типов аргументов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:918(entry)
msgid "remainder of <parameter>y</parameter>/<parameter>x</parameter>"
msgstr "остаток от деления <parameter>y</parameter>/<parameter>x</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:919(literal)
msgid "mod(9,4)"
msgstr "mod(9,4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:925(indexterm)
msgid "<primary>pi</primary>"
msgstr "<primary>pi</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:928(function)
msgctxt "function"
msgid "pi()"
msgstr "pi()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:931(entry)
msgid "<quote>&pi;</quote> constant"
msgstr "константа <quote>&pi;</quote>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:932(literal)
msgctxt "literal"
msgid "pi()"
msgstr "pi()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:933(literal)
msgid "3.14159265358979"
msgstr "3.1415926535&zwsp;8979"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:938(indexterm)
msgid "<primary>power</primary>"
msgstr "<primary>power</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:941(parameter) func.xml:951(parameter)
msgctxt "parameter"
msgid "a"
msgstr "a"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:941(function) func.xml:951(function)
msgid ""
"power(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"power(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:945(entry) func.xml:954(entry)
msgid ""
"<parameter>a</parameter> raised to the power of <parameter>b</parameter>"
msgstr "<parameter>a</parameter> возводится в степень <parameter>b</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:946(literal) func.xml:955(literal)
msgid "power(9.0, 3.0)"
msgstr "power(9.0, 3.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:947(literal) func.xml:956(literal)
msgid "729"
msgstr "729"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:961(indexterm)
msgid "<primary>radians</primary>"
msgstr "<primary>radians</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:964(function)
msgid "radians(<placeholder-1/>)"
msgstr "radians(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:967(entry)
msgid "degrees to radians"
msgstr "преобразование градусов в радианы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:968(literal)
msgid "radians(45.0)"
msgstr "radians(45.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:969(literal)
msgid "0.785398163397448"
msgstr "0.7853981633&zwsp;97448"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:974(indexterm)
msgid "<primary>round</primary>"
msgstr "<primary>round</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:977(function)
msgid "round(<placeholder-1/> or <placeholder-2/>)"
msgstr "round(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:980(entry)
msgid "round to nearest integer"
msgstr "округление до ближайшего целого"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:981(literal)
msgid "round(42.4)"
msgstr "round(42.4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:982(literal) func.xml:1042(literal)
msgid "42"
msgstr "42"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:986(parameter) func.xml:1046(parameter)
msgid "v"
msgstr "v"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:986(parameter) func.xml:1046(parameter)
msgctxt "parameter"
msgid "s"
msgstr "s"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:986(type) func.xml:1046(type) func.xml:1058(type)
#: func.xml:1059(type) func.xml:1070(type) func.xml:1071(type)
#: func.xml:1083(type) func.xml:1404(type) func.xml:1417(type)
#: func.xml:1454(type) func.xml:1465(type) func.xml:1482(type)
#: func.xml:1493(type) func.xml:1606(type) func.xml:1640(type)
#: func.xml:1825(type) func.xml:1843(type) func.xml:1854(type)
#: func.xml:1870(type) func.xml:2130(type) func.xml:2177(type)
#: func.xml:2194(type) func.xml:2234(type) func.xml:2251(type)
#: func.xml:2301(type) func.xml:3429(type) func.xml:3440(type)
#: func.xml:3457(type) func.xml:3468(type) func.xml:3584(type)
#: func.xml:3599(type) func.xml:3614(type) func.xml:5775(type)
#: func.xml:7155(type) func.xml:7156(type) func.xml:7157(type)
#: func.xml:7176(type) func.xml:7177(type) func.xml:7178(type)
#: func.xml:7179(type) func.xml:7180(type) func.xml:7181(type)
#: func.xml:7202(type) func.xml:7203(type) func.xml:7223(type)
#: func.xml:7224(type) func.xml:7225(type) func.xml:7226(type)
#: func.xml:7227(type) func.xml:7247(type) func.xml:7248(type)
#: func.xml:7249(type) func.xml:7250(type) func.xml:7251(type)
#: func.xml:8651(type) func.xml:8657(type) func.xml:9075(type)
#: func.xml:9112(type) func.xml:9146(type) func.xml:9154(type)
#: func.xml:11056(type) func.xml:11071(type) func.xml:11509(type)
#: func.xml:12657(type) func.xml:12689(type) func.xml:12692(type)
#: func.xml:12700(type) func.xml:12703(type) func.xml:12711(type)
#: func.xml:12714(type) func.xml:12783(type) func.xml:12786(type)
#: func.xml:12797(type) func.xml:15800(type) func.xml:15812(type)
#: func.xml:15819(type) func.xml:15826(type) func.xml:15875(type)
#: func.xml:15882(type) func.xml:18370(type) func.xml:18395(type)
#: func.xml:19070(type) func.xml:19095(type) func.xml:19113(type)
#: func.xml:19130(type) func.xml:19426(type) func.xml:20084(type)
#: func.xml:20098(type) func.xml:20112(type) func.xml:20133(type)
#: func.xml:20147(type) func.xml:20161(type) func.xml:20175(type)
#: func.xml:20189(type) func.xml:20203(type) func.xml:20217(type)
#: func.xml:20670(type)
msgid "int"
msgstr "int"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:986(function)
msgid ""
"round(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"round(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:988(entry)
msgid "round to <parameter>s</parameter> decimal places"
msgstr ""
"округление <parameter>v</parameter> до <parameter>s</parameter> десятичных "
"знаков"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:989(literal)
msgid "round(42.4382, 2)"
msgstr "round(42.4382, 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:990(literal)
msgid "42.44"
msgstr "42.44"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:995(indexterm)
msgid "<primary>scale</primary>"
msgstr "<primary>scale</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:998(function)
msgid "scale(<placeholder-1/>)"
msgstr "scale(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1000(type) func.xml:9482(type) func.xml:9494(type)
#: func.xml:9669(type) func.xml:9681(type) func.xml:9724(type)
#: func.xml:9844(type) func.xml:9852(type) func.xml:9863(type)
#: func.xml:9871(type) func.xml:9882(type) func.xml:11205(type)
#: func.xml:14412(type) func.xml:14575(type) func.xml:14578(type)
#: func.xml:14591(type) func.xml:14620(type) func.xml:14680(type)
#: func.xml:17506(type) func.xml:17511(type) func.xml:17978(type)
#: func.xml:17983(type) func.xml:18074(type) func.xml:18079(type)
#: func.xml:18115(type) func.xml:18120(type) func.xml:18125(type)
#: func.xml:18130(type) func.xml:18135(type) func.xml:18140(type)
#: func.xml:18145(type) func.xml:18150(type) func.xml:18155(type)
#: func.xml:18170(type) func.xml:18201(type) func.xml:19759(type)
#: func.xml:19833(type) func.xml:19840(type) func.xml:19847(type)
#: func.xml:20447(type)
msgid "integer"
msgstr "integer"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1001(entry)
msgid ""
"scale of the argument (the number of decimal digits in the fractional part)"
msgstr "масштаб аргумента (число десятичных цифр в дробной части)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1002(literal)
msgid "scale(8.41)"
msgstr "scale(8.41)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1008(indexterm)
msgid "<primary>sign</primary>"
msgstr "<primary>sign</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1011(function)
msgid "sign(<placeholder-1/> or <placeholder-2/>)"
msgstr "sign(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1014(entry)
msgid "sign of the argument (-1, 0, +1)"
msgstr "знак аргумента (-1, 0, +1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1015(literal)
msgid "sign(-8.4)"
msgstr "sign(-8.4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1021(indexterm)
msgid "<primary>sqrt</primary>"
msgstr "<primary>sqrt</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1024(function)
msgid "sqrt(<placeholder-1/> or <placeholder-2/>)"
msgstr "sqrt(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1028(literal)
msgid "sqrt(2.0)"
msgstr "sqrt(2.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1029(literal)
msgid "1.4142135623731"
msgstr "1.4142135623&zwsp;731"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1034(indexterm) func.xml:9239(indexterm) func.xml:9284(indexterm)
msgid "<primary>trunc</primary>"
msgstr "<primary>trunc</primary>"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1037(function)
msgid "trunc(<placeholder-1/> or <placeholder-2/>)"
msgstr "trunc(<placeholder-1/> или <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1040(entry)
msgid "truncate toward zero"
msgstr "округление к нулю"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1041(literal)
msgid "trunc(42.8)"
msgstr "trunc(42.8)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1046(function)
msgid ""
"trunc(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"trunc(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1048(entry)
msgid "truncate to <parameter>s</parameter> decimal places"
msgstr "округление к 0 до <parameter>s</parameter> десятичных знаков"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1049(literal)
msgid "trunc(42.4382, 2)"
msgstr "trunc(42.4382, 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1050(literal)
msgid "42.43"
msgstr "42.43"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1055(indexterm)
msgid "<primary>width_bucket</primary>"
msgstr "<primary>width_bucket</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1058(parameter) func.xml:1070(parameter) func.xml:1082(parameter)
msgid "operand"
msgstr "operand"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1058(parameter) func.xml:1070(parameter)
msgid "b1"
msgstr "b1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1058(parameter) func.xml:1070(parameter)
msgid "b2"
msgstr "b2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1058(parameter) func.xml:1070(parameter) func.xml:2267(parameter)
msgid "count"
msgstr "count"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1058(function) func.xml:1070(function)
msgid ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>)"
msgstr ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1060(entry) func.xml:1072(entry)
msgid ""
"return the bucket number to which <parameter>operand</parameter> would be "
"assigned in a histogram having <parameter>count</parameter> equal-width "
"buckets spanning the range <parameter>b1</parameter> to <parameter>b2</"
"parameter>; returns <literal>0</literal> or <literal><parameter>count</"
"parameter>+1</literal> for an input outside the range"
msgstr ""
"возвращает номер группы, в которую попадёт <parameter>operand</parameter> в "
"гистограмме с числом групп <parameter>count</parameter> равного размера, в "
"диапазоне от <parameter>b1</parameter> до <parameter>b2</parameter>; "
"возвращает <literal>0</literal> или <literal><parameter>count</parameter>+1</"
"literal>, если операнд лежит вне диапазона"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1065(literal) func.xml:1077(literal)
msgid "width_bucket(5.35, 0.024, 10.06, 5)"
msgstr "width_bucket(5.35, 0.024, 10.06, 5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1082(type) func.xml:2000(type) func.xml:2030(type)
#: func.xml:11603(type) func.xml:12632(type) func.xml:12676(type)
#: func.xml:12711(type) func.xml:12724(type) func.xml:12737(type)
#: func.xml:12748(type) func.xml:12760(type) func.xml:14590(type)
#: func.xml:14592(type) func.xml:14619(type) func.xml:14621(type)
msgid "anyelement"
msgstr "anyelement"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1082(parameter)
msgid "thresholds"
msgstr "thresholds"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1082(type) func.xml:12632(type) func.xml:12635(type)
#: func.xml:12643(type) func.xml:12646(type) func.xml:12654(type)
#: func.xml:12665(type) func.xml:12680(type) func.xml:12689(type)
#: func.xml:12700(type) func.xml:12711(type) func.xml:12724(type)
#: func.xml:12737(type) func.xml:12740(type) func.xml:12748(type)
#: func.xml:12751(type) func.xml:12760(type) func.xml:12763(type)
#: func.xml:12771(type) func.xml:12783(type) func.xml:12794(type)
#: func.xml:12817(type) func.xml:12829(type)
msgid "anyarray"
msgstr "anyarray"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1082(function)
msgid ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1084(entry)
msgid ""
"return the bucket number to which <parameter>operand</parameter> would be "
"assigned given an array listing the lower bounds of the buckets; returns "
"<literal>0</literal> for an input less than the first lower bound; the "
"<parameter>thresholds</parameter> array <emphasis>must be sorted</emphasis>, "
"smallest first, or unexpected results will be obtained"
msgstr ""
"возвращает номер группы, в которую попадёт <parameter>operand</parameter> "
"(группы определяются нижними границами, передаваемыми в "
"<parameter>thresholds</parameter>); возвращает 0, если операнд оказывается "
"левее нижней границы; массив <parameter>thresholds</parameter> "
"<emphasis>должен быть отсортирован</emphasis> по возрастанию, иначе будут "
"получены неожиданные результаты"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1089(literal)
msgid ""
"width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])"
msgstr ""
"width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1096(para)
msgid ""
"<xref linkend=\"functions-math-random-table\"/> shows functions for "
"generating random numbers."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-random-table\"/> перечислены "
"все функции для генерации случайных чисел."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1102(title)
msgid "Random Functions"
msgstr "Случайные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1115(indexterm)
msgid "<primary>random</primary>"
msgstr "<primary>random</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1118(function)
msgid "random()"
msgstr "random()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1121(entry)
msgid "random value in the range 0.0 &lt;= x &lt; 1.0"
msgstr "случайное число в диапазоне 0.0 &lt;= x &lt; 1.0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1126(indexterm)
msgid "<primary>setseed</primary>"
msgstr "<primary>setseed</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1129(function)
msgid "setseed(<placeholder-1/>)"
msgstr "setseed(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1131(type) func.xml:18850(type) func.xml:18858(type)
#: func.xml:19032(type) func.xml:19168(type) func.xml:19200(type)
#: func.xml:19218(type) func.xml:19267(type) func.xml:19286(type)
#: func.xml:19302(type) func.xml:20079(type) func.xml:20086(type)
#: func.xml:20093(type) func.xml:20100(type) func.xml:20121(type)
#: func.xml:20142(type) func.xml:20149(type) func.xml:20156(type)
#: func.xml:20163(type)
msgid "void"
msgstr "void"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1132(entry)
msgid ""
"set seed for subsequent <literal>random()</literal> calls (value between "
"-1.0 and 1.0, inclusive)"
msgstr ""
"задаёт отправную точку для последующих вызовов <literal>random()</literal> "
"(значение между -1.0 и 1.0, включая границы)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1139(para)
msgid ""
"The characteristics of the values returned by <literal><function>random()</"
"function></literal> depend on the system implementation. It is not suitable "
"for cryptographic applications; see <xref linkend=\"pgcrypto\"/> module for "
"an alternative."
msgstr ""
"Характеристики значений, возвращаемых функцией <literal><function>random()</"
"function></literal> зависят от системы. Для применения в криптографии они "
"непригодны; альтернативы описаны в <xref remap=\"6\" linkend=\"pgcrypto\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1146(para)
msgid ""
"Finally, <xref linkend=\"functions-math-trig-table\"/> shows the available "
"trigonometric functions. All trigonometric functions take arguments and "
"return values of type <type>double precision</type>. Each of the "
"trigonometric functions comes in two variants, one that measures angles in "
"radians and one that measures angles in degrees."
msgstr ""
"Наконец, в <xref remap=\"6\" linkend=\"functions-math-trig-table\"/> "
"перечислены все имеющиеся тригонометрические функции. Все эти функции "
"принимают аргументы и возвращают значения типа <type>double precision</"
"type>. У каждой функции имеются две вариации — одна измеряет углы в "
"радианах, а вторая в градусах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1156(title)
msgid "Trigonometric Functions"
msgstr "Тригонометрические функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1161(entry)
msgid "Function (radians)"
msgstr "Функции (в радианах)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1162(entry)
msgid "Function (degrees)"
msgstr "Функции (в градусах)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1170(indexterm)
msgid "<primary>acos</primary>"
msgstr "<primary>acos</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1172(function)
msgid "acos(<placeholder-1/>)"
msgstr "acos(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1175(indexterm)
msgid "<primary>acosd</primary>"
msgstr "<primary>acosd</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1177(function)
msgid "acosd(<placeholder-1/>)"
msgstr "acosd(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1179(entry)
msgid "inverse cosine"
msgstr "арккосинус"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1184(indexterm)
msgid "<primary>asin</primary>"
msgstr "<primary>asin</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1187(function)
msgid "asin(<placeholder-1/>)"
msgstr "asin(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1190(indexterm)
msgid "<primary>asind</primary>"
msgstr "<primary>asind</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1193(function)
msgid "asind(<placeholder-1/>)"
msgstr "asind(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1195(entry)
msgid "inverse sine"
msgstr "арксинус"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1200(indexterm)
msgid "<primary>atan</primary>"
msgstr "<primary>atan</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1203(function)
msgid "atan(<placeholder-1/>)"
msgstr "atan(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1206(indexterm)
msgid "<primary>atand</primary>"
msgstr "<primary>atand</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1209(function)
msgid "atand(<placeholder-1/>)"
msgstr "atand(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1211(entry)
msgid "inverse tangent"
msgstr "арктангенс"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1216(indexterm)
msgid "<primary>atan2</primary>"
msgstr "<primary>atan2</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1219(function)
msgid "atan2(<placeholder-1/>, <placeholder-2/>)"
msgstr "atan2(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1223(indexterm)
msgid "<primary>atan2d</primary>"
msgstr "<primary>atan2d</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1226(function)
msgid "atan2d(<placeholder-1/>, <placeholder-2/>)"
msgstr "atan2d(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1229(entry)
msgid ""
"inverse tangent of <literal><replaceable>y</replaceable>/<replaceable>x</"
"replaceable></literal>"
msgstr ""
"арктангенс <literal><replaceable>y</replaceable>/<replaceable>x</"
"replaceable></literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1235(indexterm)
msgid "<primary>cos</primary>"
msgstr "<primary>cos</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1238(function)
msgid "cos(<placeholder-1/>)"
msgstr "cos(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1241(indexterm)
msgid "<primary>cosd</primary>"
msgstr "<primary>cosd</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1244(function)
msgid "cosd(<placeholder-1/>)"
msgstr "cosd(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1246(entry)
msgid "cosine"
msgstr "косинус"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1251(indexterm)
msgid "<primary>cot</primary>"
msgstr "<primary>cot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1254(function)
msgid "cot(<placeholder-1/>)"
msgstr "cot(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1257(indexterm)
msgid "<primary>cotd</primary>"
msgstr "<primary>cotd</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1260(function)
msgid "cotd(<placeholder-1/>)"
msgstr "cotd(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1262(entry)
msgid "cotangent"
msgstr "котангенс"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1267(indexterm)
msgid "<primary>sin</primary>"
msgstr "<primary>sin</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1270(function)
msgid "sin(<placeholder-1/>)"
msgstr "sin(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1273(indexterm)
msgid "<primary>sind</primary>"
msgstr "<primary>sind</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1276(function)
msgid "sind(<placeholder-1/>)"
msgstr "sind(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1278(entry)
msgid "sine"
msgstr "синус"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1283(indexterm)
msgid "<primary>tan</primary>"
msgstr "<primary>tan</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1286(function)
msgid "tan(<placeholder-1/>)"
msgstr "tan(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1289(indexterm)
msgid "<primary>tand</primary>"
msgstr "<primary>tand</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1292(function)
msgid "tand(<placeholder-1/>)"
msgstr "tand(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1294(entry)
msgid "tangent"
msgstr "тангенс"

#. +> REL_10
#: func.xml:1301(para)
msgid ""
"Another way to work with angles measured in degrees is to use the unit "
"transformation functions <literal><function>radians()</function></literal> "
"and <literal><function>degrees()</function></literal> shown earlier. "
"However, using the degree-based trigonometric functions is preferred, as "
"that way avoids round-off error for special cases such as <literal>sind(30)</"
"literal>."
msgstr ""
"Также можно работать с углами в градусах, применяя вышеупомянутые функции "
"преобразования единиц <literal><function>radians()</function></literal> и "
"<literal><function>degrees()</function></literal>. Однако предпочтительнее "
"использовать тригонометрические функции с градусами, так как это позволяет "
"избежать ошибок округления в особых случаях, например, при вычислении "
"<literal>sind(30)</literal>."

#. +> REL9_6_3 REL9_6
#: func.xml:1301(para)
msgid ""
"Another way to work with angles measured in degrees is to use the unit "
"transformation functions <literal><function>radians()</function></literal> "
"and <literal><function>degrees()</function></literal> shown earlier. "
"However, using the degree-based trigonometric functions is preferred, as "
"that way avoids roundoff error for special cases such as <literal>sind(30)</"
"literal>."
msgstr ""
"Также можно работать с углами в градусах, применяя вышеупомянутые функции "
"преобразования единиц <literal><function>radians()</function></literal> и "
"<literal><function>degrees()</function></literal>. Однако предпочтительнее "
"использовать тригонометрические функции с градусами, так как это позволяет "
"избежать ошибок округления в особых случаях, например, при вычислении "
"<literal>sind(30)</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1315(title)
msgid "String Functions and Operators"
msgstr "Строковые функции и операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1317(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating string values. Strings in this context include values of the "
"types <type>character</type>, <type>character varying</type>, and "
"<type>text</type>. Unless otherwise noted, all of the functions listed below "
"work on all of these types, but be wary of potential effects of automatic "
"space-padding when using the <type>character</type> type. Some functions "
"also exist natively for the bit-string types."
msgstr ""
"В этом разделе описаны функции и операторы для работы с текстовыми строками. "
"Под строками в данном контексте подразумеваются значения типов "
"<type>character</type>, <type>character varying</type> и <type>text</type>. "
"Если не отмечено обратное, все нижеперечисленные функции работают со всеми "
"этими типами, хотя с типом <type>character</type> следует учитывать "
"возможные эффекты автоматического дополнения строк пробелами. Некоторые из "
"этих функций также поддерживают битовые строки."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1328(para)
msgid ""
"<acronym>SQL</acronym> defines some string functions that use key words, "
"rather than commas, to separate arguments. Details are in <xref linkend="
"\"functions-string-sql\"/>. <productname>PostgreSQL</productname> also "
"provides versions of these functions that use the regular function "
"invocation syntax (see <xref linkend=\"functions-string-other\"/>)."
msgstr ""
"В <acronym>SQL</acronym> определены несколько строковых функций, в которых "
"аргументы разделяются не запятыми, а ключевыми словами. Они перечислены в "
"<xref remap=\"6\" linkend=\"functions-string-sql\"/>. "
"<productname>PostgreSQL</productname> также предоставляет варианты этих "
"функций с синтаксисом, обычным для функций (см. <xref remap=\"4\" linkend="
"\"functions-string-other\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1339(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.3, these functions would "
"silently accept values of several non-string data types as well, due to the "
"presence of implicit coercions from those data types to <type>text</type>. "
"Those coercions have been removed because they frequently caused surprising "
"behaviors. However, the string concatenation operator (<literal>||</"
"literal>) still accepts non-string input, so long as at least one input is "
"of a string type, as shown in <xref linkend=\"functions-string-sql\"/>. For "
"other cases, insert an explicit coercion to <type>text</type> if you need to "
"duplicate the previous behavior."
msgstr ""
"До версии 8.3 в <productname>PostgreSQL</productname> эти функции также "
"прозрачно принимали значения некоторых не строковых типов, неявно приводя "
"эти значения к типу <type>text</type>. Сейчас такие приведения исключены, "
"так как они часто приводили к неожиданным результатам. Однако оператор "
"конкатенации строк (<literal>||</literal>) по-прежнему принимает не только "
"строковые данные, если хотя бы один аргумент имеет строковый тип, как "
"показано в <xref remap=\"6\" linkend=\"functions-string-sql\"/>. Во всех "
"остальных случаях для повторения предыдущего поведения потребуется добавить "
"явное преобразование в <type>text</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1353(title)
msgid "<acronym>SQL</acronym> String Functions and Operators"
msgstr "Строковые функции и операторы языка <acronym>SQL</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1367(parameter) func.xml:1368(parameter) func.xml:1402(parameter)
#: func.xml:1439(parameter) func.xml:1452(parameter) func.xml:1465(parameter)
#: func.xml:1480(parameter) func.xml:1493(parameter) func.xml:1504(parameter)
#: func.xml:1516(parameter) func.xml:1534(parameter) func.xml:1551(parameter)
#: func.xml:1568(parameter) func.xml:1604(parameter) func.xml:1622(parameter)
#: func.xml:1694(parameter) func.xml:1718(parameter) func.xml:1736(parameter)
#: func.xml:1752(parameter) func.xml:1807(parameter) func.xml:1841(parameter)
#: func.xml:1852(parameter) func.xml:1869(parameter) func.xml:1891(parameter)
#: func.xml:1909(parameter) func.xml:1963(parameter) func.xml:1983(parameter)
#: func.xml:2015(parameter) func.xml:2046(parameter) func.xml:2063(parameter)
#: func.xml:2080(parameter) func.xml:2096(parameter) func.xml:2113(parameter)
#: func.xml:2130(parameter) func.xml:2144(parameter) func.xml:2193(parameter)
#: func.xml:2214(parameter) func.xml:2232(parameter) func.xml:2249(parameter)
#: func.xml:2267(parameter) func.xml:2283(parameter) func.xml:2317(parameter)
#: func.xml:3408(parameter) func.xml:3409(parameter) func.xml:3427(parameter)
#: func.xml:3440(parameter) func.xml:3455(parameter) func.xml:3468(parameter)
#: func.xml:3485(parameter) func.xml:3527(parameter) func.xml:3545(parameter)
#: func.xml:3582(parameter) func.xml:3597(parameter) func.xml:3612(parameter)
#: func.xml:3636(parameter) func.xml:3652(parameter) func.xml:3668(parameter)
msgctxt "parameter"
msgid "string"
msgstr "string"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1367(literal) func.xml:3408(literal) func.xml:3733(literal)
#: func.xml:9371(literal) func.xml:9385(literal) func.xml:11182(literal)
#: func.xml:12509(literal) func.xml:12516(literal) func.xml:12523(literal)
#: func.xml:12530(literal)
msgid "||"
msgstr "||"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1369(type) func.xml:1389(type) func.xml:1441(type)
#: func.xml:1467(type) func.xml:1495(type) func.xml:1505(type)
#: func.xml:1517(type) func.xml:1536(type) func.xml:1555(type)
#: func.xml:1570(type) func.xml:1622(type) func.xml:1623(type)
#: func.xml:1625(type) func.xml:1642(type) func.xml:1662(type)
#: func.xml:1676(type) func.xml:1680(type) func.xml:1721(type)
#: func.xml:1736(type) func.xml:1752(type) func.xml:1753(type)
#: func.xml:1770(type) func.xml:1772(type) func.xml:1789(type)
#: func.xml:1792(type) func.xml:1809(type) func.xml:1824(type)
#: func.xml:1827(type) func.xml:1869(type) func.xml:1871(type)
#: func.xml:1873(type) func.xml:1891(type) func.xml:1892(type)
#: func.xml:1894(type) func.xml:1911(type) func.xml:1925(type)
#: func.xml:1963(type) func.xml:1965(type) func.xml:1983(type)
#: func.xml:1985(type) func.xml:2001(type) func.xml:2015(type)
#: func.xml:2017(type) func.xml:2031(type) func.xml:2046(type)
#: func.xml:2063(type) func.xml:2080(type) func.xml:2082(type)
#: func.xml:2096(type) func.xml:2113(type) func.xml:2130(type)
#: func.xml:2132(type) func.xml:2144(type) func.xml:2145(type)
#: func.xml:2146(type) func.xml:2148(type) func.xml:2163(type)
#: func.xml:2176(type) func.xml:2179(type) func.xml:2193(type)
#: func.xml:2195(type) func.xml:2197(type) func.xml:2214(type)
#: func.xml:2215(type) func.xml:2217(type) func.xml:2232(type)
#: func.xml:2233(type) func.xml:2236(type) func.xml:2269(type)
#: func.xml:2283(type) func.xml:2284(type) func.xml:2286(type)
#: func.xml:2304(type) func.xml:2317(type) func.xml:2318(type)
#: func.xml:2319(type) func.xml:2321(type) func.xml:3545(type)
#: func.xml:3546(type) func.xml:3563(type) func.xml:3565(type)
#: func.xml:3638(type) func.xml:5762(type) func.xml:5764(type)
#: func.xml:5769(type) func.xml:5770(type) func.xml:5775(type)
#: func.xml:5776(type) func.xml:5782(type) func.xml:5783(type)
#: func.xml:5788(type) func.xml:5789(type) func.xml:5798(type)
#: func.xml:5809(type) func.xml:5820(type) func.xml:6982(type)
#: func.xml:6993(type) func.xml:7007(type) func.xml:7017(type)
#: func.xml:7253(type) func.xml:7304(type) func.xml:9044(type)
#: func.xml:9051(type) func.xml:9088(type) func.xml:9167(type)
#: func.xml:9504(type) func.xml:9516(type) func.xml:9531(type)
#: func.xml:9578(type) func.xml:9590(type) func.xml:9614(type)
#: func.xml:9648(type) func.xml:9650(type) func.xml:9657(type)
#: func.xml:9659(type) func.xml:9702(type) func.xml:9774(type)
#: func.xml:9820(type) func.xml:9832(type) func.xml:9844(type)
#: func.xml:9852(type) func.xml:9863(type) func.xml:9871(type)
#: func.xml:9882(type) func.xml:11064(type) func.xml:11078(type)
#: func.xml:11162(type) func.xml:11189(type) func.xml:11572(type)
#: func.xml:11682(type) func.xml:11805(type) func.xml:12668(type)
#: func.xml:12771(type) func.xml:12774(type) func.xml:12805(type)
#: func.xml:15763(type) func.xml:15838(type) func.xml:15839(type)
#: func.xml:15901(type) func.xml:16963(type) func.xml:16968(type)
#: func.xml:16973(type) func.xml:16978(type) func.xml:16984(type)
#: func.xml:16990(type) func.xml:16995(type) func.xml:17000(type)
#: func.xml:17005(type) func.xml:17010(type) func.xml:17015(type)
#: func.xml:17027(type) func.xml:17032(type) func.xml:17037(type)
#: func.xml:17042(type) func.xml:17047(type) func.xml:17052(type)
#: func.xml:17062(type) func.xml:17067(type) func.xml:17072(type)
#: func.xml:17077(type) func.xml:17082(type) func.xml:17114(type)
#: func.xml:17124(type) func.xml:17502(type) func.xml:17516(type)
#: func.xml:17611(type) func.xml:17616(type) func.xml:17621(type)
#: func.xml:17626(type) func.xml:17973(type) func.xml:17993(type)
#: func.xml:18256(type) func.xml:18268(type) func.xml:18505(type)
#: func.xml:18533(type) func.xml:18577(type) func.xml:18933(type)
#: func.xml:19149(type) func.xml:19165(type) func.xml:19181(type)
#: func.xml:19197(type) func.xml:19299(type) func.xml:19318(type)
#: func.xml:19336(type) func.xml:19355(type) func.xml:19454(type)
#: func.xml:19474(type) func.xml:19485(type) func.xml:19495(type)
#: func.xml:19689(type) func.xml:19751(type) func.xml:19910(type)
#: func.xml:19941(type) func.xml:19943(type) func.xml:19950(type)
#: func.xml:19959(type) func.xml:20452(type) func.xml:20457(type)
#: func.xml:20462(type) func.xml:20470(type) func.xml:20559(type)
#: func.xml:20564(type) func.xml:20572(type) func.xml:20581(type)
msgctxt "type"
msgid "text"
msgstr "text"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1372(indexterm)
msgid ""
"<primary>character string</primary> <secondary>concatenation</secondary>"
msgstr ""
"<primary>символьная строка</primary> <secondary>конкатенация</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1370(entry) func.xml:3411(entry)
msgid "String concatenation <placeholder-1/>"
msgstr "Конкатенация строк <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1377(literal)
msgid "'Post' || 'greSQL'"
msgstr "'Post' || 'greSQL'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1378(literal)
msgid "PostgreSQL"
msgstr "PostgreSQL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1382(entry)
msgid ""
"<literal><parameter>string</parameter> <literal>||</literal> <parameter>non-"
"string</parameter></literal> or <literal><parameter>non-string</parameter> "
"<literal>||</literal> <parameter>string</parameter></literal>"
msgstr ""
"<literal><parameter>string</parameter> <literal>||</literal> <parameter>не "
"string</parameter></literal> или <literal><parameter>не string</parameter> "
"<literal>||</literal> <parameter>string</parameter></literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1390(entry)
msgid "String concatenation with one non-string input"
msgstr "Конкатенация строк с одним не строковым операндом"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1393(literal)
msgid "'Value: ' || 42"
msgstr "'Value: ' || 42"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1394(literal)
msgid "Value: 42"
msgstr "Value: 42"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1399(indexterm)
msgid "<primary>bit_length</primary>"
msgstr "<primary>bit_length</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1402(function)
msgid "bit_length(<placeholder-1/>)"
msgstr "bit_length(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1405(entry)
msgid "Number of bits in string"
msgstr "Число бит в строке"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1406(literal)
msgid "bit_length('jose')"
msgstr "bit_length('jose')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1407(literal)
msgid "32"
msgstr "32"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1412(indexterm)
msgid "<primary>char_length</primary>"
msgstr "<primary>char_length</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1411(entry)
msgid ""
"<placeholder-1/> <literal><function>char_length(<parameter>string</"
"parameter>)</function></literal> or "
"<literal><function>character_length(<parameter>string</parameter>)</"
"function></literal>"
msgstr ""
"<placeholder-1/> <literal><function>char_length(<parameter>string</"
"parameter>)</function></literal> или "
"<literal><function>character_length(<parameter>string</parameter>)</"
"function></literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1420(indexterm)
msgid "<primary>character string</primary> <secondary>length</secondary>"
msgstr "<primary>строка символов</primary> <secondary>длина</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1424(indexterm)
msgid ""
"<primary>length</primary> <secondary sortas=\"character string\">of a "
"character string</secondary> <see>character string, length</see>"
msgstr ""
"<primary>длина</primary> <secondary sortas=\"символьная строка\">строки "
"символов</secondary> <see>строка символов, длина</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1418(entry)
msgid "Number of characters in string <placeholder-1/> <placeholder-2/>"
msgstr "Число символов в строке <placeholder-1/> <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1430(literal)
msgid "char_length('jose')"
msgstr "char_length('jose')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1431(literal) func.xml:1457(literal) func.xml:1848(literal)
#: func.xml:1861(literal) func.xml:12789(literal) func.xml:12800(literal)
msgctxt "literal"
msgid "4"
msgstr "4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1436(indexterm) func.xml:13083(indexterm)
msgid "<primary>lower</primary>"
msgstr "<primary>lower</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1439(function)
msgid "lower(<placeholder-1/>)"
msgstr "lower(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1442(entry)
msgid "Convert string to lower case"
msgstr "Переводит символы строки в нижний регистр"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1443(literal)
msgid "lower('TOM')"
msgstr "lower('TOM')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1444(literal)
msgid "tom"
msgstr "tom"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1449(indexterm) func.xml:3424(indexterm)
msgid "<primary>octet_length</primary>"
msgstr "<primary>octet_length</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1452(function) func.xml:3427(function)
msgid "octet_length(<placeholder-1/>)"
msgstr "octet_length(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1455(entry)
msgid "Number of bytes in string"
msgstr "Число байт в строке"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1456(literal)
msgid "octet_length('jose')"
msgstr "octet_length('jose')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1462(indexterm) func.xml:3437(indexterm)
msgid "<primary>overlay</primary>"
msgstr "<primary>overlay</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1465(optional) func.xml:1493(optional) func.xml:3440(optional)
#: func.xml:3468(optional)
msgid "for <placeholder-1/>"
msgstr "for <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1465(function) func.xml:3440(function)
msgid ""
"overlay(<placeholder-1/> placing <placeholder-2/> from <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"overlay(<placeholder-1/> placing <placeholder-2/> from <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1468(entry) func.xml:3443(entry)
msgid "Replace substring"
msgstr "Заменяет подстроку"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1471(literal)
msgid "overlay('Txxxxas' placing 'hom' from 2 for 4)"
msgstr "overlay('Txxxxas' placing 'hom' from 2 for 4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1472(literal)
msgid "Thomas"
msgstr "Thomas"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1477(indexterm) func.xml:3452(indexterm)
msgid "<primary>position</primary>"
msgstr "<primary>position</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1480(parameter) func.xml:2249(parameter) func.xml:3455(parameter)
msgid "substring"
msgstr "substring"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1480(function) func.xml:3455(function)
msgid "position(<placeholder-1/> in <placeholder-2/>)"
msgstr "position(<placeholder-1/> in <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1483(entry) func.xml:3458(entry)
msgid "Location of specified substring"
msgstr "Положение указанной подстроки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1484(literal)
msgid "position('om' in 'Thomas')"
msgstr "position('om' in 'Thomas')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1490(indexterm) func.xml:3465(indexterm) func.xml:3982(indexterm)
#: func.xml:4128(indexterm)
msgid "<primary>substring</primary>"
msgstr "<primary>substring</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1493(optional) func.xml:3468(optional)
msgid "from <placeholder-1/>"
msgstr "from <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1493(function) func.xml:3468(function)
msgid "substring(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "substring(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1496(entry) func.xml:3471(entry)
msgid "Extract substring"
msgstr "Извлекает подстроку"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1499(literal)
msgid "substring('Thomas' from 2 for 3)"
msgstr "substring('Thomas' from 2 for 3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1500(literal)
msgid "hom"
msgstr "hom"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1504(replaceable) func.xml:1516(replaceable)
#: func.xml:3886(replaceable) func.xml:3887(replaceable)
#: func.xml:3987(replaceable) func.xml:3988(replaceable)
msgctxt "replaceable"
msgid "pattern"
msgstr "шаблон"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1504(function)
msgid "substring(<placeholder-1/> from <placeholder-2/>)"
msgstr "substring(<placeholder-1/> from <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1506(entry)
msgid ""
"Extract substring matching POSIX regular expression. See <xref linkend="
"\"functions-matching\"/> for more information on pattern matching."
msgstr ""
"Извлекает подстроку, соответствующую регулярному выражению в стиле POSIX. "
"Подробно шаблоны описаны в <xref remap=\"6\" linkend=\"functions-matching\"/"
">."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1511(literal)
msgid "substring('Thomas' from '...$')"
msgstr "substring('Thomas' from '...$')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1512(literal)
msgid "mas"
msgstr "mas"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1516(replaceable)
msgid "escape"
msgstr "спецсимвол"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1516(function)
msgid "substring(<placeholder-1/> from <placeholder-2/> for <placeholder-3/>)"
msgstr "substring(<placeholder-1/> from <placeholder-2/> for <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1518(entry)
msgid ""
"Extract substring matching <acronym>SQL</acronym> regular expression. See "
"<xref linkend=\"functions-matching\"/> for more information on pattern "
"matching."
msgstr ""
"Извлекает подстроку, соответствующую регулярному выражению в стиле "
"<acronym>SQL</acronym>. Подробно шаблоны описаны в <xref remap=\"6\" linkend="
"\"functions-matching\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1523(literal)
msgid "substring('Thomas' from '%#\"o_a#\"_' for '#')"
msgstr "substring('Thomas' from '%#\"o_a#\"_' for '#')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1524(literal)
msgid "oma"
msgstr "oma"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1529(indexterm) func.xml:3480(indexterm)
msgid "<primary>trim</primary>"
msgstr "<primary>trim</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1532(optional) func.xml:1549(optional)
msgid "leading | trailing | both"
msgstr "leading | trailing | both"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1533(parameter) func.xml:1552(parameter) func.xml:1623(parameter)
#: func.xml:1892(parameter) func.xml:2215(parameter)
msgid "characters"
msgstr "characters"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1532(function)
msgid ""
"trim(<placeholder-1/> <optional><placeholder-2/></optional> from "
"<placeholder-3/>)"
msgstr ""
"trim(<placeholder-1/> <optional><placeholder-2/></optional> from "
"<placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1537(entry)
msgid ""
"Remove the longest string containing only characters from "
"<parameter>characters</parameter> (a space by default) from the start, end, "
"or both ends (<literal>both</literal> is the default) of <parameter>string</"
"parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с начала "
"(<literal>leading</literal>), с конца (<literal>trailing</literal>) или с "
"обеих сторон (<literal>both</literal>, (по умолчанию)) строки "
"<parameter>string</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1543(literal)
msgid "trim(both 'xyz' from 'yxTomxx')"
msgstr "trim(both 'xyz' from 'yxTomxx')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1544(literal) func.xml:1560(literal) func.xml:3494(literal)
msgid "Tom"
msgstr "Tom"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1550(optional)
msgctxt "optional"
msgid "from"
msgstr "from"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1552(optional) func.xml:2267(optional) func.xml:10171(optional)
#: func.xml:10454(optional) func.xml:10519(optional) func.xml:12677(optional)
#: func.xml:12711(optional) func.xml:12771(optional) func.xml:12805(optional)
msgid ", <placeholder-1/>"
msgstr ", <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1549(function)
msgid ""
"trim(<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> )"
msgstr ""
"trim(<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> )"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1556(entry)
msgid "Non-standard syntax for <function>trim()</function>"
msgstr "Нестандартный синтаксис <function>trim()</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1559(literal)
msgid "trim(both from 'yxTomxx', 'xyz')"
msgstr "trim(both from 'yxTomxx', 'xyz')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1565(indexterm) func.xml:13086(indexterm)
msgid "<primary>upper</primary>"
msgstr "<primary>upper</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1568(function)
msgid "upper(<placeholder-1/>)"
msgstr "upper(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1571(entry)
msgid "Convert string to upper case"
msgstr "Переводит символы строки в верхний регистр"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1572(literal)
msgid "upper('tom')"
msgstr "upper('tom')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1573(literal)
msgid "TOM"
msgstr "TOM"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1579(para)
msgid ""
"Additional string manipulation functions are available and are listed in "
"<xref linkend=\"functions-string-other\"/>. Some of them are used internally "
"to implement the <acronym>SQL</acronym>-standard string functions listed in "
"<xref linkend=\"functions-string-sql\"/>."
msgstr ""
"Кроме этого, в <productname>PostgreSQL</productname> есть и другие функции "
"для работы со строками, перечисленные в <xref remap=\"6\" linkend="
"\"functions-string-other\"/>. Некоторые из них используются в качестве "
"внутренней реализации стандартных строковых функций <acronym>SQL</acronym>, "
"приведённых в <xref remap=\"6\" linkend=\"functions-string-sql\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1586(title)
msgid "Other String Functions"
msgstr "Другие строковые функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1601(indexterm)
msgid "<primary>ascii</primary>"
msgstr "<primary>ascii</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1604(function)
msgid "ascii(<placeholder-1/>)"
msgstr "ascii(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1607(entry)
msgid ""
"<acronym>ASCII</acronym> code of the first character of the argument. For "
"<acronym>UTF8</acronym> returns the Unicode code point of the character. For "
"other multibyte encodings, the argument must be an <acronym>ASCII</acronym> "
"character."
msgstr ""
"Возвращает <acronym>ASCII</acronym>-код первого символа аргумента. Для "
"<acronym>UTF8</acronym> возвращает код символа в Unicode. Для других "
"многобайтных кодировок аргумент должен быть <acronym>ASCII</acronym>-"
"символом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1613(literal)
msgid "ascii('x')"
msgstr "ascii('x')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1619(indexterm) func.xml:3524(indexterm)
msgid "<primary>btrim</primary>"
msgstr "<primary>btrim</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1623(optional) func.xml:1871(optional) func.xml:1892(optional)
#: func.xml:2195(optional) func.xml:2215(optional) func.xml:2284(optional)
#: func.xml:9648(optional) func.xml:9657(optional) func.xml:9669(optional)
#: func.xml:9681(optional) func.xml:11747(optional) func.xml:18533(optional)
#: func.xml:18547(optional) func.xml:19047(optional)
msgid ", <placeholder-1/> <placeholder-2/>"
msgstr ", <placeholder-1/> <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1622(function)
msgid "btrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "btrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1626(entry)
msgid ""
"Remove the longest string consisting only of characters in "
"<parameter>characters</parameter> (a space by default) from the start and "
"end of <parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, состоящую только из символов "
"<parameter>characters</parameter> (по умолчанию пробелов), с начала и с "
"конца строки <parameter>string</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1631(literal)
msgid "btrim('xyxtrimyyx', 'xyz')"
msgstr "btrim('xyxtrimyyx', 'xyz')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1632(literal) func.xml:3537(literal)
msgid "trim"
msgstr "trim"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1637(indexterm)
msgid "<primary>chr</primary>"
msgstr "<primary>chr</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1640(function)
msgid "chr(<placeholder-1/>)"
msgstr "chr(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1643(entry)
msgid ""
"Character with the given code. For <acronym>UTF8</acronym> the argument is "
"treated as a Unicode code point. For other multibyte encodings the argument "
"must designate an <acronym>ASCII</acronym> character. The NULL (0) character "
"is not allowed because text data types cannot store such bytes."
msgstr ""
"Возвращает символ с данным кодом. Для <acronym>UTF8</acronym> аргумент "
"воспринимается как код символа Unicode, а для других кодировок он должен "
"указывать на <acronym>ASCII</acronym>-символ. Код 0 (NULL) не допускается, "
"так как байты с нулевым кодом в текстовых строках сохранить нельзя."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1650(literal)
msgid "chr(65)"
msgstr "chr(65)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1651(literal)
msgid "A"
msgstr "A"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1656(indexterm)
msgid "<primary>concat</primary>"
msgstr "<primary>concat</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1659(parameter) func.xml:1660(parameter) func.xml:1677(parameter)
#: func.xml:1678(parameter) func.xml:1824(parameter) func.xml:2161(parameter)
#: func.xml:2176(parameter)
msgid "str"
msgstr "str"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1659(type) func.xml:1660(type) func.xml:1677(type)
#: func.xml:1678(type) func.xml:1790(type) func.xml:14293(type)
#: func.xml:14296(type) func.xml:14316(type) func.xml:14319(type)
#: func.xml:14339(type) func.xml:14342(type) func.xml:14362(type)
#: func.xml:14365(type)
msgid "\"any\""
msgstr "\"any\""

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1659(function)
msgid ""
"concat(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/"
"> [, ...] ])"
msgstr ""
"concat(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/"
"> [, ...] ])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1663(entry)
msgid ""
"Concatenate the text representations of all the arguments. NULL arguments "
"are ignored."
msgstr "Соединяет текстовые представления всех аргументов, игнорируя NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1667(literal)
msgid "concat('abcde', 2, NULL, 22)"
msgstr "concat('abcde', 2, NULL, 22)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1668(literal)
msgid "abcde222"
msgstr "abcde222"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1673(indexterm)
msgid "<primary>concat_ws</primary>"
msgstr "<primary>concat_ws</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1676(parameter)
msgid "sep"
msgstr "sep"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1676(function)
msgid ""
"concat_ws(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
"> [, <placeholder-5/> <placeholder-6/> [, ...] ])"
msgstr ""
"concat_ws(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
"> [, <placeholder-5/> <placeholder-6/> [, ...] ])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1681(entry)
msgid ""
"Concatenate all but the first argument with separators. The first argument "
"is used as the separator string. NULL arguments are ignored."
msgstr ""
"Соединяет все аргументы, кроме первого, через разделитель, игнорируя "
"аргументы NULL. Разделитель указывается в первом аргументе."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1685(literal)
msgid "concat_ws(',', 'abcde', 2, NULL, 22)"
msgstr "concat_ws(',', 'abcde', 2, NULL, 22)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1686(literal)
msgid "abcde,2,22"
msgstr "abcde,2,22"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1691(indexterm)
msgid "<primary>convert</primary>"
msgstr "<primary>convert</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1694(type) func.xml:1698(type) func.xml:1718(type)
#: func.xml:1739(type) func.xml:1755(type) func.xml:1769(type)
#: func.xml:1852(type) func.xml:3410(type) func.xml:3442(type)
#: func.xml:3470(type) func.xml:3487(type) func.xml:3528(type)
#: func.xml:3530(type) func.xml:3548(type) func.xml:3562(type)
#: func.xml:3655(type) func.xml:3671(type) func.xml:19355(type)
#: func.xml:19952(type)
msgid "bytea"
msgstr "bytea"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1695(parameter) func.xml:1719(parameter)
msgid "src_encoding"
msgstr "src_encoding"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1695(type) func.xml:1696(type) func.xml:1719(type)
#: func.xml:1737(type) func.xml:1853(type) func.xml:1950(type)
#: func.xml:15751(type) func.xml:15757(type) func.xml:15770(type)
#: func.xml:15776(type) func.xml:15788(type) func.xml:15889(type)
#: func.xml:15895(type) func.xml:17057(type) func.xml:19002(type)
#: func.xml:19029(type) func.xml:19047(type) func.xml:19070(type)
#: func.xml:19095(type) func.xml:19113(type) func.xml:19130(type)
#: func.xml:19438(type) func.xml:19520(type)
msgctxt "type"
msgid "name"
msgstr "name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1696(parameter) func.xml:1737(parameter)
msgid "dest_encoding"
msgstr "dest_encoding"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1694(function)
msgid ""
"convert(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"convert(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1699(entry)
msgid ""
"Convert string to <parameter>dest_encoding</parameter>. The original "
"encoding is specified by <parameter>src_encoding</parameter>. The "
"<parameter>string</parameter> must be valid in this encoding. Conversions "
"can be defined by <command>CREATE CONVERSION</command>. Also there are some "
"predefined conversions. See <xref linkend=\"conversion-names\"/> for "
"available conversions."
msgstr ""
"Преобразует строку <parameter>string</parameter> из кодировки "
"<parameter>src_encoding</parameter> в <parameter>dest_encoding</parameter>. "
"Переданная строка должна быть допустимой для исходной кодировки. "
"Преобразования могут быть определены с помощью <command>CREATE CONVERSION</"
"command>. Все встроенные преобразования перечислены в <xref remap=\"6\" "
"linkend=\"conversion-names\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1708(literal)
msgid "convert('text_in_utf8', 'UTF8', 'LATIN1')"
msgstr "convert('text_in_utf8'&zwsp;, 'UTF8', 'LATIN1')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1709(entry)
msgid ""
"<literal>text_in_utf8</literal> represented in Latin-1 encoding (ISO 8859-1)"
msgstr ""
"строка <literal>text_in_utf8</literal>, представленная в кодировке Latin-1 "
"(ISO 8859-1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1715(indexterm)
msgid "<primary>convert_from</primary>"
msgstr "<primary>convert_from</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1718(function)
msgid ""
"convert_from(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"convert_from(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1722(entry)
msgid ""
"Convert string to the database encoding. The original encoding is specified "
"by <parameter>src_encoding</parameter>. The <parameter>string</parameter> "
"must be valid in this encoding."
msgstr ""
"Преобразует строку <parameter>string</parameter> из кодировки "
"<parameter>src_encoding</parameter> в кодировку базы данных. Переданная "
"строка должна быть допустимой для исходной кодировки."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1727(literal)
msgid "convert_from('text_in_utf8', 'UTF8')"
msgstr "convert_from('text_in_utf8'&zwsp;, 'UTF8')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1728(entry)
msgid ""
"<literal>text_in_utf8</literal> represented in the current database encoding"
msgstr ""
"строка <literal>text_in_utf8</literal>, представленная в кодировке текущей "
"базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1733(indexterm)
msgid "<primary>convert_to</primary>"
msgstr "<primary>convert_to</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1736(function)
msgid ""
"convert_to(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"convert_to(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1740(entry)
msgid "Convert string to <parameter>dest_encoding</parameter>."
msgstr "Преобразует строку в кодировку <parameter>dest_encoding</parameter>."

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1743(literal)
msgid "convert_to('some text', 'UTF8')"
msgstr "convert_to('некоторый текст', 'UTF8')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1744(entry)
msgid "<literal>some text</literal> represented in the UTF8 encoding"
msgstr "<literal>некоторый текст</literal>, представленный в кодировке UTF8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1749(indexterm) func.xml:3542(indexterm)
msgid "<primary>decode</primary>"
msgstr "<primary>decode</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1753(parameter) func.xml:1770(parameter) func.xml:3546(parameter)
#: func.xml:3563(parameter)
msgctxt "parameter"
msgid "format"
msgstr "format"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1752(function) func.xml:3545(function)
msgid ""
"decode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"decode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1756(entry) func.xml:3549(entry)
msgid ""
"Decode binary data from textual representation in <parameter>string</"
"parameter>. Options for <parameter>format</parameter> are same as in "
"<function>encode</function>."
msgstr ""
"Получает двоичные данные из текстового представления в <parameter>string</"
"parameter>. Значения параметра <parameter>format</parameter> те же, что и "
"для функции <function>encode</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1760(literal)
msgid "decode('MTIzAAE=', 'base64')"
msgstr "decode('MTIzAAE=', 'base64')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1761(literal)
msgid "\\x3132330001"
msgstr "\\x3132330001"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1766(indexterm) func.xml:3559(indexterm)
msgid "<primary>encode</primary>"
msgstr "<primary>encode</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1769(parameter) func.xml:3562(parameter)
msgid "data"
msgstr "data"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1769(function) func.xml:3562(function)
msgid ""
"encode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"encode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1773(entry) func.xml:3566(entry)
msgid ""
"Encode binary data into a textual representation. Supported formats are: "
"<literal>base64</literal>, <literal>hex</literal>, <literal>escape</"
"literal>. <literal>escape</literal> converts zero bytes and high-bit-set "
"bytes to octal sequences (<literal>\\</literal><replaceable>nnn</"
"replaceable>) and doubles backslashes."
msgstr ""
"Переводит двоичные данные в текстовое представление в одном из форматов: "
"<literal>base64</literal>, <literal>hex</literal>, <literal>escape</"
"literal>. Формат <literal>escape</literal> преобразует нулевые байты и байты "
"с 1 в старшем бите в восьмеричные последовательности <literal>\\nnn</"
"literal> и дублирует обратную косую черту."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1780(literal)
msgid "encode(E'123\\\\000\\\\001', 'base64')"
msgstr "encode(E'123&zwsp;\\\\000&zwsp;\\\\001', 'base64')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1781(literal)
msgid "MTIzAAE="
msgstr "MTIzAAE="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1786(indexterm) func.xml:3153(indexterm)
msgid "<primary>format</primary>"
msgstr "<primary>format</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1789(function) func.xml:3151(function)
msgctxt "function"
msgid "format"
msgstr "format"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1789(parameter)
msgid "formatstr"
msgstr "formatstr"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1790(parameter)
msgid "formatarg"
msgstr "formatarg"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1789(literal)
msgid ""
"<placeholder-1/>(<placeholder-2/> <placeholder-3/> [, <placeholder-4/> "
"<placeholder-5/> [, ...] ])"
msgstr ""
"<placeholder-1/>(<placeholder-2/> <placeholder-3/> [, <placeholder-4/> "
"<placeholder-5/> [, ...] ])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1793(entry)
msgid ""
"Format arguments according to a format string. This function is similar to "
"the C function <function>sprintf</function>. See <xref linkend=\"functions-"
"string-format\"/>."
msgstr ""
"Форматирует аргумент в соответствии со строкой формата. Эта функция работает "
"подобно <function>sprintf</function> в языке C. См. <xref remap=\"4\" "
"linkend=\"functions-string-format\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1798(literal)
msgid "format('Hello %s, %1$s', 'World')"
msgstr "format('Hello %s, %1$s', 'World')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1799(literal)
msgid "Hello World, World"
msgstr "Hello World, World"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1804(indexterm)
msgid "<primary>initcap</primary>"
msgstr "<primary>initcap</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1807(function)
msgid "initcap(<placeholder-1/>)"
msgstr "initcap(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1810(entry)
msgid ""
"Convert the first letter of each word to upper case and the rest to lower "
"case. Words are sequences of alphanumeric characters separated by non-"
"alphanumeric characters."
msgstr ""
"Переводит первую букву каждого слова в строке в верхний регистр, а остальные "
"&mdash; в нижний. Словами считаются последовательности алфавитно-цифровых "
"символов, разделённые любыми другими символами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1815(literal)
msgid "initcap('hi THOMAS')"
msgstr "initcap('hi THOMAS')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1816(literal)
msgid "Hi Thomas"
msgstr "Hi Thomas"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1821(indexterm)
msgid "<primary>left</primary>"
msgstr "<primary>left</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1825(parameter) func.xml:2177(parameter)
msgctxt "parameter"
msgid "n"
msgstr "n"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1824(function)
msgid ""
"left(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"left(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1828(entry)
msgid ""
"Return first <replaceable>n</replaceable> characters in the string. When "
"<replaceable>n</replaceable> is negative, return all but last |"
"<replaceable>n</replaceable>| characters."
msgstr ""
"Возвращает первые <replaceable>n</replaceable> символов в строке. Когда "
"<replaceable>n</replaceable> меньше нуля, возвращаются все символы слева, "
"кроме последних |<replaceable>n</replaceable>|."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1832(literal)
msgid "left('abcde', 2)"
msgstr "left('abcde', 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1833(literal)
msgid "ab"
msgstr "ab"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1838(indexterm) func.xml:3609(indexterm) func.xml:8576(indexterm)
#: func.xml:9477(indexterm)
msgid "<primary>length</primary>"
msgstr "<primary>length</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1841(function) func.xml:3612(function) func.xml:8644(function)
#: func.xml:9480(function)
msgid "length(<placeholder-1/>)"
msgstr "length(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1844(entry)
msgid "Number of characters in <parameter>string</parameter>"
msgstr "Число символов в строке <parameter>string</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1847(literal)
msgid "length('jose')"
msgstr "length('jose')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1853(parameter) func.xml:2284(parameter)
msgid "encoding"
msgstr "encoding"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1852(function)
msgid ""
"length(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> )"
msgstr ""
"length(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> )"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1855(entry)
msgid ""
"Number of characters in <parameter>string</parameter> in the given "
"<parameter>encoding</parameter>. The <parameter>string</parameter> must be "
"valid in this encoding."
msgstr ""
"Число символов, которые содержит строка <parameter>string</parameter> в "
"заданной кодировке <parameter>encoding</parameter>. Переданная строка должна "
"быть допустимой в этой кодировке."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1860(literal)
msgid "length('jose', 'UTF8')"
msgstr "length('jose', 'UTF8')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1866(indexterm)
msgid "<primary>lpad</primary>"
msgstr "<primary>lpad</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1870(parameter) func.xml:2194(parameter) func.xml:19941(parameter)
#: func.xml:19950(parameter)
msgctxt "parameter"
msgid "length"
msgstr "length"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1871(parameter) func.xml:2195(parameter)
msgid "fill"
msgstr "fill"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1869(function)
msgid ""
"lpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"
msgstr ""
"lpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1874(entry)
msgid ""
"Fill up the <parameter>string</parameter> to length <parameter>length</"
"parameter> by prepending the characters <parameter>fill</parameter> (a space "
"by default). If the <parameter>string</parameter> is already longer than "
"<parameter>length</parameter> then it is truncated (on the right)."
msgstr ""
"Дополняет строку <parameter>string</parameter> слева до длины "
"<parameter>length</parameter> символами <parameter>fill</parameter> (по "
"умолчанию пробелами). Если длина строки уже больше заданной, она обрезается "
"справа."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1882(literal)
msgid "lpad('hi', 5, 'xy')"
msgstr "lpad('hi', 5, 'xy')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1883(literal)
msgid "xyxhi"
msgstr "xyxhi"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1888(indexterm)
msgid "<primary>ltrim</primary>"
msgstr "<primary>ltrim</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1891(function)
msgid "ltrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "ltrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1895(entry)
msgid ""
"Remove the longest string containing only characters from "
"<parameter>characters</parameter> (a space by default) from the start of "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с начала строки "
"<parameter>string</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1900(literal)
msgid "ltrim('zzzytest', 'xyz')"
msgstr "ltrim('zzzytest', 'xyz')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1901(literal) func.xml:2224(literal)
msgid "test"
msgstr "test"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1906(indexterm) func.xml:3633(indexterm)
msgid "<primary>md5</primary>"
msgstr "<primary>md5</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1909(function) func.xml:3636(function)
msgid "md5(<placeholder-1/>)"
msgstr "md5(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1912(entry) func.xml:3639(entry)
msgid ""
"Calculates the MD5 hash of <parameter>string</parameter>, returning the "
"result in hexadecimal"
msgstr ""
"Вычисляет MD5-хеш строки <parameter>string</parameter> и возвращает "
"результат в 16-ричном виде"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1916(literal)
msgid "md5('abc')"
msgstr "md5('abc')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1917(literal)
msgid "900150983cd24fb0 d6963f7d28e17f72"
msgstr "90015098&zwsp;3cd24fb0 d6963f7d&zwsp;28e17f72"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1922(indexterm)
msgid "<primary>parse_ident</primary>"
msgstr "<primary>parse_ident</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1925(parameter)
msgid "qualified_identifier"
msgstr "qualified_identifier"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1926(parameter)
msgid "strictmode"
msgstr "strictmode"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1926(type) func.xml:7057(type) func.xml:7065(type)
#: func.xml:7073(type) func.xml:8633(type) func.xml:8639(type)
#: func.xml:9179(type) func.xml:9358(type) func.xml:9365(type)
#: func.xml:9407(type) func.xml:9414(type) func.xml:11747(type)
#: func.xml:11772(type) func.xml:11966(type) func.xml:13146(type)
#: func.xml:13157(type) func.xml:13168(type) func.xml:13179(type)
#: func.xml:13190(type) func.xml:15781(type) func.xml:15852(type)
#: func.xml:16224(type) func.xml:16231(type) func.xml:16240(type)
#: func.xml:16248(type) func.xml:16256(type) func.xml:16263(type)
#: func.xml:16271(type) func.xml:16278(type) func.xml:16286(type)
#: func.xml:16293(type) func.xml:16301(type) func.xml:16308(type)
#: func.xml:16316(type) func.xml:16323(type) func.xml:16331(type)
#: func.xml:16338(type) func.xml:16346(type) func.xml:16353(type)
#: func.xml:16361(type) func.xml:16368(type) func.xml:16376(type)
#: func.xml:16383(type) func.xml:16391(type) func.xml:16398(type)
#: func.xml:16406(type) func.xml:16413(type) func.xml:16419(type)
#: func.xml:16680(type) func.xml:16686(type) func.xml:16692(type)
#: func.xml:16698(type) func.xml:16704(type) func.xml:16710(type)
#: func.xml:16716(type) func.xml:16722(type) func.xml:16728(type)
#: func.xml:16734(type) func.xml:16740(type) func.xml:16746(type)
#: func.xml:16752(type) func.xml:17089(type) func.xml:17094(type)
#: func.xml:17099(type) func.xml:17739(type) func.xml:17988(type)
#: func.xml:18160(type) func.xml:18165(type) func.xml:18216(type)
#: func.xml:18372(type) func.xml:18383(type) func.xml:18390(type)
#: func.xml:18397(type) func.xml:18533(type) func.xml:18547(type)
#: func.xml:19002(type) func.xml:19047(type) func.xml:19910(type)
#: func.xml:19941(type) func.xml:19950(type) func.xml:19959(type)
#: func.xml:20107(type) func.xml:20114(type) func.xml:20128(type)
#: func.xml:20135(type) func.xml:20170(type) func.xml:20177(type)
#: func.xml:20184(type) func.xml:20191(type) func.xml:20198(type)
#: func.xml:20205(type) func.xml:20212(type) func.xml:20219(type)
msgid "boolean"
msgstr "boolean"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1925(function)
msgid ""
"parse_ident(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/> DEFAULT true ] )"
msgstr ""
"parse_ident(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/> DEFAULT true ] )"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1928(type) func.xml:2048(type) func.xml:2098(type)
#: func.xml:9456(type) func.xml:9554(type) func.xml:9624(type)
#: func.xml:9739(type) func.xml:9820(type) func.xml:9834(type)
#: func.xml:11085(type) func.xml:11092(type) func.xml:11169(type)
#: func.xml:11176(type) func.xml:11197(type) func.xml:11213(type)
#: func.xml:12808(type) func.xml:17516(type) func.xml:19070(type)
#: func.xml:19095(type) func.xml:19113(type) func.xml:19130(type)
#: func.xml:20589(type) func.xml:20600(type)
msgid "text[]"
msgstr "text[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1929(entry)
msgid ""
"Split <parameter>qualified_identifier</parameter> into an array of "
"identifiers, removing any quoting of individual identifiers. By default, "
"extra characters after the last identifier are considered an error; but if "
"the second parameter is <literal>false</literal>, then such extra characters "
"are ignored. (This behavior is useful for parsing names for objects like "
"functions.) Note that this function does not truncate over-length "
"identifiers. If you want truncation you can cast the result to <type>name[]</"
"type>."
msgstr ""
"Раскладывает полный идентификатор, задаваемый параметром "
"<parameter>qualified_identifier</parameter>, на массив идентификаторов, "
"удаляя кавычки, обрамляющие отдельные идентификаторы. По умолчанию лишние "
"символы после последнего идентификатора вызывают ошибку, но если отключить "
"строгий режим (передать во втором параметре <literal>false</literal>), такие "
"символы игнорируются. (Это поведение полезно для разбора имён таких "
"объектов, как функции.) Заметьте, что эта функция не усекает чрезмерно "
"длинные идентификаторы. Если вы хотите получить усечённые имена, можно "
"привести результат к <type>name[]</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1939(literal)
msgid "parse_ident('\"SomeSchema\".someTable')"
msgstr "parse_ident('\"SomeSchema\".someTable')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1940(literal)
msgid "{SomeSchema,sometable}"
msgstr "{SomeSchema,sometable}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1945(indexterm)
msgid "<primary>pg_client_encoding</primary>"
msgstr "<primary>pg_client_encoding</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1948(function)
msgctxt "function"
msgid "pg_client_encoding()"
msgstr "pg_client_encoding()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1951(entry)
msgid "Current client encoding name"
msgstr "Возвращает имя текущей клиентской кодировки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1954(literal)
msgctxt "literal"
msgid "pg_client_encoding()"
msgstr "pg_client_encoding()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1955(literal) func.xml:2380(literal) func.xml:2386(literal)
#: func.xml:2663(literal) func.xml:2789(literal)
msgid "SQL_ASCII"
msgstr "SQL_ASCII"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1960(indexterm)
msgid "<primary>quote_ident</primary>"
msgstr "<primary>quote_ident</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1963(function)
msgid "quote_ident(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_ident(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1966(entry)
msgid ""
"Return the given string suitably quoted to be used as an identifier in an "
"<acronym>SQL</acronym> statement string. Quotes are added only if necessary "
"(i.e., if the string contains non-identifier characters or would be case-"
"folded). Embedded quotes are properly doubled. See also <xref linkend="
"\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве идентификатора в "
"<acronym>SQL</acronym> -операторе. При необходимости идентификатор "
"заключается в кавычки (например, если он содержит символы, недопустимые в "
"открытом виде, или буквы в разном регистре). Если переданная строка содержит "
"кавычки, они дублируются. См. также <xref remap=\"4\" linkend=\"plpgsql-"
"quote-literal-example\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1974(literal)
msgid "quote_ident('Foo bar')"
msgstr "quote_ident('Foo bar')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1975(literal)
msgid "\"Foo bar\""
msgstr "\"Foo bar\""

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1980(indexterm)
msgid "<primary>quote_literal</primary>"
msgstr "<primary>quote_literal</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1983(function) func.xml:2000(function)
msgid "quote_literal(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_literal(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1986(entry)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"<acronym>SQL</acronym> statement string. Embedded single-quotes and "
"backslashes are properly doubled. Note that <function>quote_literal</"
"function> returns null on null input; if the argument might be null, "
"<function>quote_nullable</function> is often more suitable. See also <xref "
"linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве текстовой строки "
"в <acronym>SQL</acronym>-операторе. Включённые символы апостроф и обратная "
"косая черта при этом дублируются. Заметьте, что <function>quote_literal</"
"function> возвращает NULL, когда на вход ей передаётся строка NULL; если же "
"нужно получить представление и такого аргумента, лучше использовать "
"<function>quote_nullable</function>. См. также <xref remap=\"4\" linkend="
"\"plpgsql-quote-literal-example\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1995(literal)
msgid "quote_literal(E'O\\'Reilly')"
msgstr "quote_literal(E'O\\'Reilly')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:1996(literal)
msgid "'O''Reilly'"
msgstr "'O''Reilly'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2000(parameter) func.xml:2030(parameter)
msgctxt "parameter"
msgid "value"
msgstr "value"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2002(entry)
msgid ""
"Coerce the given value to text and then quote it as a literal. Embedded "
"single-quotes and backslashes are properly doubled."
msgstr ""
"Переводит данное значение в текстовый вид и заключает в апострофы как "
"текстовую строку. Символы апостроф и обратная косая черта при этом "
"дублируются."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2006(literal)
msgid "quote_literal(42.5)"
msgstr "quote_literal(42.5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2007(literal) func.xml:2038(literal)
msgid "'42.5'"
msgstr "'42.5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2012(indexterm)
msgid "<primary>quote_nullable</primary>"
msgstr "<primary>quote_nullable</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2015(function) func.xml:2030(function)
msgid "quote_nullable(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_nullable(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2018(entry)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"<acronym>SQL</acronym> statement string; or, if the argument is null, return "
"<literal>NULL</literal>. Embedded single-quotes and backslashes are properly "
"doubled. See also <xref linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве текстовой строки "
"в <acronym>SQL</acronym>-операторе; при этом для аргумента NULL возвращается "
"строка <literal>NULL</literal>. Символы апостроф и обратная косая черта "
"дублируются должным образом. См. также <xref remap=\"4\" linkend=\"plpgsql-"
"quote-literal-example\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2025(literal)
msgid "quote_nullable(NULL)"
msgstr "quote_nullable(NULL)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2026(literal)
msgctxt "literal"
msgid "NULL"
msgstr "NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2032(entry)
msgid ""
"Coerce the given value to text and then quote it as a literal; or, if the "
"argument is null, return <literal>NULL</literal>. Embedded single-quotes and "
"backslashes are properly doubled."
msgstr ""
"Переводит данное значение в текстовый вид и заключает в апострофы как "
"текстовую строку, при этом для аргумента NULL возвращается строка "
"<literal>NULL</literal>. Символы апостроф и обратная косая черта дублируются "
"должным образом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2037(literal)
msgid "quote_nullable(42.5)"
msgstr "quote_nullable(42.5)"

#. +> REL_10
#: func.xml:2043(indexterm) func.xml:4134(indexterm)
msgid "<primary>regexp_match</primary>"
msgstr "<primary>regexp_match</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2046(parameter) func.xml:2063(parameter) func.xml:2080(parameter)
#: func.xml:2096(parameter) func.xml:2113(parameter)
msgctxt "parameter"
msgid "pattern"
msgstr "pattern"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2046(parameter) func.xml:2063(parameter) func.xml:2080(parameter)
#: func.xml:2096(parameter) func.xml:2113(parameter)
msgid "flags"
msgstr "flags"

#. +> REL_10
#: func.xml:2046(function)
msgid ""
"regexp_match(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"regexp_match(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"

#. +> REL_10
#: func.xml:2049(entry)
msgid ""
"Return captured substring(s) resulting from the first match of a POSIX "
"regular expression to the <parameter>string</parameter>. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Возвращает подходящие подстроки, полученные из первого вхождения регулярного "
"выражения POSIX в строке <parameter>string</parameter>. Подробности описаны "
"в <xref remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#. +> REL9_6_3 REL9_6
#: func.xml:2049(entry)
msgid ""
"Return all captured substrings resulting from matching a POSIX regular "
"expression against the <parameter>string</parameter>. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Возвращает все подходящие подстроки, полученные в результате применения "
"регулярного выражения в стиле POSIX к <parameter>string</parameter>. "
"Подробности описаны в <xref remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#. +> REL_10
#: func.xml:2054(literal)
msgid "regexp_match('foobarbequebaz', '(bar)(beque)')"
msgstr "regexp_match('foobar&zwsp;bequebaz', '(bar)(beque)')"

#. +> REL9_6_3 REL9_6
#: func.xml:2054(literal)
msgid "regexp_matches('foobarbequebaz', '(bar)(beque)')"
msgstr "regexp_matches&zwsp;('foobar&zwsp;bequebaz', '(bar)(beque)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2055(literal)
msgid "{bar,beque}"
msgstr "{bar,beque}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2060(indexterm) func.xml:4137(indexterm)
msgid "<primary>regexp_matches</primary>"
msgstr "<primary>regexp_matches</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2063(function)
msgid ""
"regexp_matches(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"regexp_matches&zwsp;(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2065(type)
msgid "setof text[]"
msgstr "setof text[]"

#. +> REL_10
#: func.xml:2066(entry)
msgid ""
"Return captured substring(s) resulting from matching a POSIX regular "
"expression to the <parameter>string</parameter>. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Возвращает подходящие подстроки, полученные в результате применения "
"регулярного выражения POSIX к <parameter>string</parameter>. Подробности "
"описаны в <xref remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#. +> REL_10
#: func.xml:2071(literal)
msgid "regexp_matches('foobarbequebaz', 'ba.', 'g')"
msgstr "regexp_matches('foobar&zwsp;bequebaz', 'ba.', 'g')"

#. +> REL_10
#: func.xml:2072(literal)
msgid "{baz}"
msgstr "{baz}"

#. +> REL_10
#: func.xml:2072(entry)
msgid "<literal>{bar}</literal><placeholder-1/> (2 rows)"
msgstr "<literal>{bar}</literal><placeholder-1/> (2 строки)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2077(indexterm) func.xml:4131(indexterm)
msgid "<primary>regexp_replace</primary>"
msgstr "<primary>regexp_replace</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2080(parameter)
msgid "replacement"
msgstr "replacement"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2080(function)
msgid ""
"regexp_replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>])"
msgstr ""
"regexp_replace&zwsp;(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2083(entry)
msgid ""
"Replace substring(s) matching a POSIX regular expression. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Заменяет подстроки, соответствующие заданному регулярному выражению в стиле "
"POSIX. Подробности описаны в <xref remap=\"6\" linkend=\"functions-posix-"
"regexp\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2087(literal)
msgid "regexp_replace('Thomas', '.[mN]a.', 'M')"
msgstr "regexp_replace('Thomas', '.[mN]a.', 'M')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2088(literal)
msgid "ThM"
msgstr "ThM"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2093(indexterm) func.xml:4143(indexterm)
msgid "<primary>regexp_split_to_array</primary>"
msgstr "<primary>regexp_split_to_array</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2096(function)
msgid ""
"regexp_split_to_array(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ])"
msgstr ""
"regexp_split_to_array(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2099(entry) func.xml:2116(entry)
msgid ""
"Split <parameter>string</parameter> using a POSIX regular expression as the "
"delimiter. See <xref linkend=\"functions-posix-regexp\"/> for more "
"information."
msgstr ""
"Разделяет содержимое <parameter>string</parameter> на элементы, используя в "
"качестве разделителя регулярное выражение POSIX. Подробности описаны в <xref "
"remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2104(literal)
msgid "regexp_split_to_array('hello world', E'\\\\s+')"
msgstr "regexp_split_to_array('hello world', E'\\\\s+')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2105(literal)
msgid "{hello,world}"
msgstr "{hello,world}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2110(indexterm) func.xml:4140(indexterm)
msgid "<primary>regexp_split_to_table</primary>"
msgstr "<primary>regexp_split&zwsp;_to_table</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2113(function)
msgid ""
"regexp_split_to_table(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"regexp_split_to_table(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2115(type) func.xml:11585(type) func.xml:11664(type)
#: func.xml:15858(type) func.xml:19912(type)
msgid "setof text"
msgstr "setof text"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2121(literal)
msgid "regexp_split_to_table('hello world', E'\\\\s+')"
msgstr "regexp_split_to_table('hello world', E'\\\\s+')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2122(literal)
msgid "world"
msgstr "world"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2122(entry)
msgid "<literal>hello</literal><placeholder-1/> (2 rows)"
msgstr "<literal>hello</literal> <placeholder-1/> (2 строки)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2127(indexterm)
msgid "<primary>repeat</primary>"
msgstr "<primary>repeat</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2130(parameter) func.xml:2301(parameter)
msgctxt "parameter"
msgid "number"
msgstr "number"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2130(function)
msgid ""
"repeat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"repeat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2133(entry)
msgid ""
"Repeat <parameter>string</parameter> the specified <parameter>number</"
"parameter> of times"
msgstr ""
"Повторяет содержимое <parameter>string</parameter> указанное число "
"(<parameter>number</parameter>) раз"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2135(literal)
msgid "repeat('Pg', 4)"
msgstr "repeat('Pg', 4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2136(literal)
msgid "PgPgPgPg"
msgstr "PgPgPgPg"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2141(indexterm)
msgid "<primary>replace</primary>"
msgstr "<primary>replace</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2145(parameter) func.xml:2267(parameter) func.xml:2318(parameter)
msgctxt "parameter"
msgid "from"
msgstr "from"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2146(parameter) func.xml:2319(parameter)
msgid "to"
msgstr "to"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2144(function)
msgid ""
"replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2149(entry)
msgid ""
"Replace all occurrences in <parameter>string</parameter> of substring "
"<parameter>from</parameter> with substring <parameter>to</parameter>"
msgstr ""
"Заменяет все вхождения в <parameter>string</parameter> подстроки "
"<parameter>from</parameter> подстрокой <parameter>to</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2152(literal)
msgid "replace('abcdefabcdef', 'cd', 'XX')"
msgstr "replace('abcdefabcdef', 'cd', 'XX')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2153(literal)
msgid "abXXefabXXef"
msgstr "abXXefabXXef"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2158(indexterm)
msgid "<primary>reverse</primary>"
msgstr "<primary>reverse</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2161(function)
msgid "reverse(<placeholder-1/>)"
msgstr "reverse(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2164(entry)
msgid "Return reversed string."
msgstr "Возвращает перевёрнутую строку"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2167(literal)
msgid "reverse('abcde')"
msgstr "reverse('abcde')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2168(literal)
msgid "edcba"
msgstr "edcba"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2173(indexterm)
msgid "<primary>right</primary>"
msgstr "<primary>right</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2176(function)
msgid ""
"right(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"right(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2180(entry)
msgid ""
"Return last <replaceable>n</replaceable> characters in the string. When "
"<replaceable>n</replaceable> is negative, return all but first |"
"<replaceable>n</replaceable>| characters."
msgstr ""
"Возвращает последние <replaceable>n</replaceable> символов в строке. Когда "
"<replaceable>n</replaceable> меньше нуля, возвращаются все символы справа, "
"кроме первых |<replaceable>n</replaceable>|."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2184(literal)
msgid "right('abcde', 2)"
msgstr "right('abcde', 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2185(literal)
msgid "de"
msgstr "de"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2190(indexterm)
msgid "<primary>rpad</primary>"
msgstr "<primary>rpad</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2193(function)
msgid ""
"rpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"
msgstr ""
"rpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2198(entry)
msgid ""
"Fill up the <parameter>string</parameter> to length <parameter>length</"
"parameter> by appending the characters <parameter>fill</parameter> (a space "
"by default). If the <parameter>string</parameter> is already longer than "
"<parameter>length</parameter> then it is truncated."
msgstr ""
"Дополняет строку <parameter>string</parameter> справа до длины "
"<parameter>length</parameter> символами <parameter>fill</parameter> (по "
"умолчанию пробелами). Если длина строки уже больше заданной, она обрезается."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2205(literal)
msgid "rpad('hi', 5, 'xy')"
msgstr "rpad('hi', 5, 'xy')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2206(literal)
msgid "hixyx"
msgstr "hixyx"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2211(indexterm)
msgid "<primary>rtrim</primary>"
msgstr "<primary>rtrim</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2214(function)
msgid "rtrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "rtrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2218(entry)
msgid ""
"Remove the longest string containing only characters from "
"<parameter>characters</parameter> (a space by default) from the end of "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с конца строки "
"<parameter>string</parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2223(literal)
msgid "rtrim('testxxzx', 'xyz')"
msgstr "rtrim('testxxzx', 'xyz')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2229(indexterm)
msgid "<primary>split_part</primary>"
msgstr "<primary>split_part</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2233(parameter)
msgctxt "parameter"
msgid "delimiter"
msgstr "delimiter"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2234(parameter) func.xml:7030(parameter) func.xml:7041(parameter)
msgctxt "parameter"
msgid "field"
msgstr "field"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2232(function)
msgid ""
"split_part(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"split_part(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2237(entry)
msgid ""
"Split <parameter>string</parameter> on <parameter>delimiter</parameter> and "
"return the given field (counting from one)"
msgstr ""
"Разделяет строку <parameter>string</parameter> по символу "
"<parameter>delimiter</parameter> и возвращает элемент по заданному номеру "
"(считая с 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2240(literal)
msgid "split_part('abc~@~def~@~ghi', '~@~', 2)"
msgstr "split_part('abc~@~def&zwsp;~@~ghi', '~@~', 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2241(literal)
msgid "def"
msgstr "def"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2246(indexterm)
msgid "<primary>strpos</primary>"
msgstr "<primary>strpos</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2249(function)
msgid "strpos(<placeholder-1/>, <placeholder-2/>)"
msgstr "strpos(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2252(entry)
msgid ""
"Location of specified substring (same as "
"<literal>position(<parameter>substring</parameter> in <parameter>string</"
"parameter>)</literal>, but note the reversed argument order)"
msgstr ""
"Возвращает положение указанной подстроки (подобно "
"<literal>position(<parameter>substring</parameter> in <parameter>string</"
"parameter>)</literal>, но с другим порядком аргументов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2258(literal)
msgid "strpos('high', 'ig')"
msgstr "strpos('high', 'ig')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2264(indexterm)
msgid "<primary>substr</primary>"
msgstr "<primary>substr</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2267(function)
msgid "substr(<placeholder-1/>, <placeholder-2/> <placeholder-3/>)"
msgstr "substr(<placeholder-1/>, <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2270(entry)
msgid ""
"Extract substring (same as <literal>substring(<parameter>string</parameter> "
"from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)"
msgstr ""
"Извлекает подстроку (подобно <literal>substring(<parameter>string</"
"parameter> from <parameter>from</parameter> for <parameter>count</"
"parameter>)</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2274(literal)
msgid "substr('alphabet', 3, 2)"
msgstr "substr('alphabet', 3, 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2275(literal)
msgid "ph"
msgstr "ph"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2280(indexterm)
msgid "<primary>to_ascii</primary>"
msgstr "<primary>to_ascii</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2283(function)
msgid "to_ascii(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_ascii(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2287(entry)
msgid ""
"Convert <parameter>string</parameter> to <acronym>ASCII</acronym> from "
"another encoding (only supports conversion from <literal>LATIN1</literal>, "
"<literal>LATIN2</literal>, <literal>LATIN9</literal>, and <literal>WIN1250</"
"literal> encodings)"
msgstr ""
"Преобразует <parameter>string</parameter> в <acronym>ASCII</acronym> из "
"кодировки <parameter>encoding</parameter> (поддерживаются только "
"<literal>LATIN1</literal>, <literal>LATIN2</literal>, <literal>LATIN9</"
"literal> и <literal>WIN1250</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2292(literal)
msgid "to_ascii('Karel')"
msgstr "to_ascii('Karel')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2293(literal)
msgid "Karel"
msgstr "Karel"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2298(indexterm)
msgid "<primary>to_hex</primary>"
msgstr "<primary>to_hex</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2302(type) func.xml:11945(type) func.xml:11951(type)
#: func.xml:11957(type) func.xml:11961(type) func.xml:11962(type)
#: func.xml:11966(type) func.xml:11967(type) func.xml:13395(type)
#: func.xml:13403(type) func.xml:13817(type) func.xml:14299(type)
#: func.xml:14322(type) func.xml:14513(type) func.xml:14526(type)
#: func.xml:14539(type) func.xml:17709(type) func.xml:17714(type)
#: func.xml:17729(type) func.xml:17734(type) func.xml:18084(type)
#: func.xml:19433(type) func.xml:19440(type) func.xml:19447(type)
#: func.xml:19456(type) func.xml:19467(type) func.xml:19476(type)
#: func.xml:19483(type) func.xml:19505(type) func.xml:19515(type)
#: func.xml:19522(type) func.xml:19529(type) func.xml:19838(type)
#: func.xml:19845(type) func.xml:19854(type) func.xml:19941(type)
#: func.xml:19950(type) func.xml:20077(type) func.xml:20091(type)
#: func.xml:20105(type) func.xml:20126(type) func.xml:20140(type)
#: func.xml:20154(type) func.xml:20168(type) func.xml:20182(type)
#: func.xml:20196(type) func.xml:20210(type)
msgctxt "type"
msgid "bigint"
msgstr "bigint"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2301(function)
msgid "to_hex(<placeholder-1/> <placeholder-2/> or <placeholder-3/>)"
msgstr "to_hex(<placeholder-1/> <placeholder-2/> или <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2305(entry)
msgid ""
"Convert <parameter>number</parameter> to its equivalent hexadecimal "
"representation"
msgstr "Преобразует число <parameter>number</parameter> в 16-ричный вид"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2308(literal)
msgid "to_hex(2147483647)"
msgstr "to_hex(2147483647)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2309(literal)
msgid "7fffffff"
msgstr "7fffffff"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2314(indexterm)
msgid "<primary>translate</primary>"
msgstr "<primary>translate</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2317(function)
msgid ""
"translate(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"translate(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2322(entry)
msgid ""
"Any character in <parameter>string</parameter> that matches a character in "
"the <parameter>from</parameter> set is replaced by the corresponding "
"character in the <parameter>to</parameter> set. If <parameter>from</"
"parameter> is longer than <parameter>to</parameter>, occurrences of the "
"extra characters in <parameter>from</parameter> are removed."
msgstr ""
"Заменяет символы в <parameter>string</parameter>, найденные в наборе "
"<parameter>from</parameter>, на соответствующие символы в множестве "
"<parameter>to</parameter>. Если строка <parameter>from</parameter> длиннее "
"<parameter>to</parameter>, найденные в исходной строке лишние символы "
"<parameter>from</parameter> удаляются."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2330(literal)
msgid "translate('12345', '143', 'ax')"
msgstr "translate('12345', '143', 'ax')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2331(literal)
msgid "a2x5"
msgstr "a2x5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2338(para)
msgid ""
"The <function>concat</function>, <function>concat_ws</function> and "
"<function>format</function> functions are variadic, so it is possible to "
"pass the values to be concatenated or formatted as an array marked with the "
"<literal>VARIADIC</literal> keyword (see <xref linkend=\"xfunc-sql-variadic-"
"functions\"/>). The array's elements are treated as if they were separate "
"ordinary arguments to the function. If the variadic array argument is NULL, "
"<function>concat</function> and <function>concat_ws</function> return NULL, "
"but <function>format</function> treats a NULL as a zero-element array."
msgstr ""
"Функции <function>concat</function>, <function>concat_ws</function> и "
"<function>format</function> принимают переменное число аргументов, так что "
"им для объединения или форматирования можно передавать значения в виде "
"массива, помеченного ключевым словом <literal>VARIADIC</literal> (см. <xref "
"remap=\"4\" linkend=\"xfunc-sql-variadic-functions\"/>). Элементы такого "
"массива обрабатываются, как если бы они были обычными аргументами функции. "
"Если вместо массива в соответствующем аргументе передаётся NULL, функции "
"<function>concat</function> и <function>concat_ws</function> возвращают "
"NULL, а <function>format</function> воспринимает NULL как массив нулевого "
"размера."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2350(para)
msgid ""
"See also the aggregate function <function>string_agg</function> in <xref "
"linkend=\"functions-aggregate\"/>."
msgstr ""
"См. также агрегатную функцию <function>string_agg</function> в <xref remap="
"\"6\" linkend=\"functions-aggregate\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2356(title)
msgid "Built-in Conversions"
msgstr "Встроенные преобразования"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2362(para)
msgid ""
"The conversion names follow a standard naming scheme: The official name of "
"the source encoding with all non-alphanumeric characters replaced by "
"underscores, followed by <literal>_to_</literal>, followed by the similarly "
"processed destination encoding name. Therefore, the names might deviate from "
"the customary encoding names."
msgstr ""
"Имена преобразований следуют стандартной схеме именования. К официальному "
"названию исходной кодировки, в котором все не алфавитно-цифровые символы "
"заменяются подчёркиваниями, добавляется <literal>_to_</literal>, а за ним "
"аналогично подготовленное имя целевой кодировки. Таким образом, имена "
"кодировок могут не совпадать буквально с общепринятыми названиями."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2360(entry)
msgid "Conversion Name <placeholder-1/>"
msgstr "Имя преобразования <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2372(entry)
msgid "Source Encoding"
msgstr "Исходная кодировка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2373(entry)
msgid "Destination Encoding"
msgstr "Целевая кодировка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2379(literal)
msgid "ascii_to_mic"
msgstr "ascii_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2381(literal) func.xml:2399(literal) func.xml:2411(literal)
#: func.xml:2423(literal) func.xml:2441(literal) func.xml:2459(literal)
#: func.xml:2513(literal) func.xml:2525(literal) func.xml:2543(literal)
#: func.xml:2555(literal) func.xml:2573(literal) func.xml:2633(literal)
#: func.xml:2662(literal) func.xml:2668(literal) func.xml:2674(literal)
#: func.xml:2680(literal) func.xml:2686(literal) func.xml:2692(literal)
#: func.xml:2698(literal) func.xml:2704(literal) func.xml:2710(literal)
#: func.xml:2716(literal) func.xml:2722(literal) func.xml:2728(literal)
#: func.xml:2734(literal) func.xml:2740(literal) func.xml:2746(literal)
#: func.xml:2752(literal) func.xml:2765(literal) func.xml:3023(literal)
#: func.xml:3047(literal) func.xml:3089(literal)
msgid "MULE_INTERNAL"
msgstr "MULE_INTERNAL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2385(literal)
msgid "ascii_to_utf8"
msgstr "ascii_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2387(literal) func.xml:2405(literal) func.xml:2417(literal)
#: func.xml:2435(literal) func.xml:2447(literal) func.xml:2465(literal)
#: func.xml:2471(literal) func.xml:2477(literal) func.xml:2483(literal)
#: func.xml:2489(literal) func.xml:2495(literal) func.xml:2501(literal)
#: func.xml:2507(literal) func.xml:2519(literal) func.xml:2531(literal)
#: func.xml:2549(literal) func.xml:2561(literal) func.xml:2579(literal)
#: func.xml:2597(literal) func.xml:2603(literal) func.xml:2609(literal)
#: func.xml:2615(literal) func.xml:2621(literal) func.xml:2639(literal)
#: func.xml:2657(literal) func.xml:2771(literal) func.xml:2777(literal)
#: func.xml:2783(literal) func.xml:2788(literal) func.xml:2794(literal)
#: func.xml:2800(literal) func.xml:2806(literal) func.xml:2812(literal)
#: func.xml:2818(literal) func.xml:2824(literal) func.xml:2830(literal)
#: func.xml:2836(literal) func.xml:2842(literal) func.xml:2848(literal)
#: func.xml:2854(literal) func.xml:2860(literal) func.xml:2866(literal)
#: func.xml:2872(literal) func.xml:2878(literal) func.xml:2884(literal)
#: func.xml:2890(literal) func.xml:2896(literal) func.xml:2902(literal)
#: func.xml:2908(literal) func.xml:2914(literal) func.xml:2920(literal)
#: func.xml:2926(literal) func.xml:2932(literal) func.xml:2938(literal)
#: func.xml:2944(literal) func.xml:2950(literal) func.xml:2956(literal)
#: func.xml:2962(literal) func.xml:2968(literal) func.xml:2974(literal)
#: func.xml:2980(literal) func.xml:2986(literal) func.xml:2992(literal)
#: func.xml:2998(literal) func.xml:3004(literal) func.xml:3010(literal)
#: func.xml:3029(literal) func.xml:3053(literal) func.xml:3065(literal)
#: func.xml:3071(literal) func.xml:3095(literal) func.xml:3107(literal)
#: func.xml:3113(literal) func.xml:3118(literal) func.xml:3125(literal)
#: func.xml:3130(literal)
msgid "UTF8"
msgstr "UTF8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2391(literal)
msgid "big5_to_euc_tw"
msgstr "big5_to_euc_tw"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2392(literal) func.xml:2398(literal) func.xml:2404(literal)
#: func.xml:2453(literal) func.xml:2669(literal) func.xml:2795(literal)
msgid "BIG5"
msgstr "BIG5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2393(literal) func.xml:2452(literal) func.xml:2458(literal)
#: func.xml:2464(literal) func.xml:2693(literal) func.xml:2819(literal)
msgid "EUC_TW"
msgstr "EUC_TW"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2397(literal)
msgid "big5_to_mic"
msgstr "big5_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2403(literal)
msgid "big5_to_utf8"
msgstr "big5_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2409(literal)
msgid "euc_cn_to_mic"
msgstr "euc_cn_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2410(literal) func.xml:2416(literal) func.xml:2675(literal)
#: func.xml:2801(literal)
msgid "EUC_CN"
msgstr "EUC_CN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2415(literal)
msgid "euc_cn_to_utf8"
msgstr "euc_cn_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2421(literal)
msgid "euc_jp_to_mic"
msgstr "euc_jp_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2422(literal) func.xml:2428(literal) func.xml:2434(literal)
#: func.xml:2681(literal) func.xml:2759(literal) func.xml:2807(literal)
msgid "EUC_JP"
msgstr "EUC_JP"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2427(literal)
msgid "euc_jp_to_sjis"
msgstr "euc_jp_to_sjis"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2429(literal) func.xml:2735(literal) func.xml:2758(literal)
#: func.xml:2764(literal) func.xml:2770(literal) func.xml:2939(literal)
msgid "SJIS"
msgstr "SJIS"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2433(literal)
msgid "euc_jp_to_utf8"
msgstr "euc_jp_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2439(literal)
msgid "euc_kr_to_mic"
msgstr "euc_kr_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2440(literal) func.xml:2446(literal) func.xml:2687(literal)
#: func.xml:2813(literal)
msgid "EUC_KR"
msgstr "EUC_KR"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2445(literal)
msgid "euc_kr_to_utf8"
msgstr "euc_kr_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2451(literal)
msgid "euc_tw_to_big5"
msgstr "euc_tw_to_big5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2457(literal)
msgid "euc_tw_to_mic"
msgstr "euc_tw_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2463(literal)
msgid "euc_tw_to_utf8"
msgstr "euc_tw_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2469(literal)
msgid "gb18030_to_utf8"
msgstr "gb18030_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2470(literal) func.xml:2825(literal)
msgid "GB18030"
msgstr "GB18030"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2475(literal)
msgid "gbk_to_utf8"
msgstr "gbk_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2476(literal) func.xml:2831(literal)
msgid "GBK"
msgstr "GBK"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2481(literal)
msgid "iso_8859_10_to_utf8"
msgstr "iso_8859_10_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2482(literal) func.xml:2843(literal)
msgid "LATIN6"
msgstr "LATIN6"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2487(literal)
msgid "iso_8859_13_to_utf8"
msgstr "iso_8859_13_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2488(literal) func.xml:2849(literal)
msgid "LATIN7"
msgstr "LATIN7"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2493(literal)
msgid "iso_8859_14_to_utf8"
msgstr "iso_8859_14_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2494(literal) func.xml:2855(literal)
msgid "LATIN8"
msgstr "LATIN8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2499(literal)
msgid "iso_8859_15_to_utf8"
msgstr "iso_8859_15_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2500(literal) func.xml:2861(literal)
msgid "LATIN9"
msgstr "LATIN9"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2505(literal)
msgid "iso_8859_16_to_utf8"
msgstr "iso_8859_16_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2506(literal) func.xml:2867(literal)
msgid "LATIN10"
msgstr "LATIN10"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2511(literal)
msgid "iso_8859_1_to_mic"
msgstr "iso_8859_1_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2512(literal) func.xml:2518(literal) func.xml:2699(literal)
#: func.xml:2837(literal)
msgid "LATIN1"
msgstr "LATIN1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2517(literal)
msgid "iso_8859_1_to_utf8"
msgstr "iso_8859_1_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2523(literal)
msgid "iso_8859_2_to_mic"
msgstr "iso_8859_2_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2524(literal) func.xml:2530(literal) func.xml:2536(literal)
#: func.xml:2705(literal) func.xml:2873(literal) func.xml:3017(literal)
msgid "LATIN2"
msgstr "LATIN2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2529(literal)
msgid "iso_8859_2_to_utf8"
msgstr "iso_8859_2_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2535(literal)
msgid "iso_8859_2_to_windows_1250"
msgstr "iso_8859_2_to_windows_1250"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2537(literal) func.xml:2741(literal) func.xml:2957(literal)
#: func.xml:3016(literal) func.xml:3022(literal) func.xml:3028(literal)
msgid "WIN1250"
msgstr "WIN1250"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2541(literal)
msgid "iso_8859_3_to_mic"
msgstr "iso_8859_3_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2542(literal) func.xml:2548(literal) func.xml:2711(literal)
#: func.xml:2879(literal)
msgid "LATIN3"
msgstr "LATIN3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2547(literal)
msgid "iso_8859_3_to_utf8"
msgstr "iso_8859_3_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2553(literal)
msgid "iso_8859_4_to_mic"
msgstr "iso_8859_4_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2554(literal) func.xml:2560(literal) func.xml:2717(literal)
#: func.xml:2885(literal)
msgid "LATIN4"
msgstr "LATIN4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2559(literal)
msgid "iso_8859_4_to_utf8"
msgstr "iso_8859_4_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2565(literal)
msgid "iso_8859_5_to_koi8_r"
msgstr "iso_8859_5_to_koi8_r"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2566(literal) func.xml:2572(literal) func.xml:2578(literal)
#: func.xml:2584(literal) func.xml:2590(literal) func.xml:2627(literal)
#: func.xml:2723(literal) func.xml:2891(literal) func.xml:3035(literal)
#: func.xml:3077(literal)
msgid "ISO_8859_5"
msgstr "ISO_8859_5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2567(literal) func.xml:2626(literal) func.xml:2632(literal)
#: func.xml:2638(literal) func.xml:2644(literal) func.xml:2650(literal)
#: func.xml:2729(literal) func.xml:2927(literal) func.xml:3041(literal)
#: func.xml:3083(literal)
msgid "KOI8R"
msgstr "KOI8R"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2571(literal)
msgid "iso_8859_5_to_mic"
msgstr "iso_8859_5_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2577(literal)
msgid "iso_8859_5_to_utf8"
msgstr "iso_8859_5_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2583(literal)
msgid "iso_8859_5_to_windows_1251"
msgstr "iso_8859_5_to_windows_1251"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2585(literal) func.xml:2645(literal) func.xml:2747(literal)
#: func.xml:2963(literal) func.xml:3034(literal) func.xml:3040(literal)
#: func.xml:3046(literal) func.xml:3052(literal) func.xml:3058(literal)
msgid "WIN1251"
msgstr "WIN1251"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2589(literal)
msgid "iso_8859_5_to_windows_866"
msgstr "iso_8859_5_to_windows_866"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2591(literal) func.xml:2651(literal) func.xml:2753(literal)
#: func.xml:3005(literal) func.xml:3059(literal) func.xml:3076(literal)
#: func.xml:3082(literal) func.xml:3088(literal) func.xml:3094(literal)
#: func.xml:3100(literal)
msgid "WIN866"
msgstr "WIN866"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2595(literal)
msgid "iso_8859_6_to_utf8"
msgstr "iso_8859_6_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2596(literal) func.xml:2897(literal)
msgid "ISO_8859_6"
msgstr "ISO_8859_6"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2601(literal)
msgid "iso_8859_7_to_utf8"
msgstr "iso_8859_7_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2602(literal) func.xml:2903(literal)
msgid "ISO_8859_7"
msgstr "ISO_8859_7"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2607(literal)
msgid "iso_8859_8_to_utf8"
msgstr "iso_8859_8_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2608(literal) func.xml:2909(literal)
msgid "ISO_8859_8"
msgstr "ISO_8859_8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2613(literal)
msgid "iso_8859_9_to_utf8"
msgstr "iso_8859_9_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2614(literal) func.xml:2915(literal)
msgid "LATIN5"
msgstr "LATIN5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2619(literal)
msgid "johab_to_utf8"
msgstr "johab_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2620(literal) func.xml:2921(literal)
msgid "JOHAB"
msgstr "JOHAB"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2625(literal)
msgid "koi8_r_to_iso_8859_5"
msgstr "koi8_r_to_iso_8859_5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2631(literal)
msgid "koi8_r_to_mic"
msgstr "koi8_r_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2637(literal)
msgid "koi8_r_to_utf8"
msgstr "koi8_r_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2643(literal)
msgid "koi8_r_to_windows_1251"
msgstr "koi8_r_to_windows_1251"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2649(literal)
msgid "koi8_r_to_windows_866"
msgstr "koi8_r_to_windows_866"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2655(literal)
msgid "koi8_u_to_utf8"
msgstr "koi8_u_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2656(literal) func.xml:2933(literal)
msgid "KOI8U"
msgstr "KOI8U"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2661(literal)
msgid "mic_to_ascii"
msgstr "mic_to_ascii"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2667(literal)
msgid "mic_to_big5"
msgstr "mic_to_big5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2673(literal)
msgid "mic_to_euc_cn"
msgstr "mic_to_euc_cn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2679(literal)
msgid "mic_to_euc_jp"
msgstr "mic_to_euc_jp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2685(literal)
msgid "mic_to_euc_kr"
msgstr "mic_to_euc_kr"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2691(literal)
msgid "mic_to_euc_tw"
msgstr "mic_to_euc_tw"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2697(literal)
msgid "mic_to_iso_8859_1"
msgstr "mic_to_iso_8859_1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2703(literal)
msgid "mic_to_iso_8859_2"
msgstr "mic_to_iso_8859_2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2709(literal)
msgid "mic_to_iso_8859_3"
msgstr "mic_to_iso_8859_3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2715(literal)
msgid "mic_to_iso_8859_4"
msgstr "mic_to_iso_8859_4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2721(literal)
msgid "mic_to_iso_8859_5"
msgstr "mic_to_iso_8859_5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2727(literal)
msgid "mic_to_koi8_r"
msgstr "mic_to_koi8_r"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2733(literal)
msgid "mic_to_sjis"
msgstr "mic_to_sjis"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2739(literal)
msgid "mic_to_windows_1250"
msgstr "mic_to_windows_1250"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2745(literal)
msgid "mic_to_windows_1251"
msgstr "mic_to_windows_1251"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2751(literal)
msgid "mic_to_windows_866"
msgstr "mic_to_windows_866"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2757(literal)
msgid "sjis_to_euc_jp"
msgstr "sjis_to_euc_jp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2763(literal)
msgid "sjis_to_mic"
msgstr "sjis_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2769(literal)
msgid "sjis_to_utf8"
msgstr "sjis_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2775(literal)
msgid "tcvn_to_utf8"
msgstr "tcvn_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2776(literal) func.xml:2945(literal)
msgid "WIN1258"
msgstr "WIN1258"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2781(literal)
msgid "uhc_to_utf8"
msgstr "uhc_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2782(literal) func.xml:2951(literal)
msgid "UHC"
msgstr "UHC"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2787(literal)
msgid "utf8_to_ascii"
msgstr "utf8_to_ascii"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2793(literal)
msgid "utf8_to_big5"
msgstr "utf8_to_big5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2799(literal)
msgid "utf8_to_euc_cn"
msgstr "utf8_to_euc_cn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2805(literal)
msgid "utf8_to_euc_jp"
msgstr "utf8_to_euc_jp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2811(literal)
msgid "utf8_to_euc_kr"
msgstr "utf8_to_euc_kr"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2817(literal)
msgid "utf8_to_euc_tw"
msgstr "utf8_to_euc_tw"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2823(literal)
msgid "utf8_to_gb18030"
msgstr "utf8_to_gb18030"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2829(literal)
msgid "utf8_to_gbk"
msgstr "utf8_to_gbk"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2835(literal)
msgid "utf8_to_iso_8859_1"
msgstr "utf8_to_iso_8859_1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2841(literal)
msgid "utf8_to_iso_8859_10"
msgstr "utf8_to_iso_8859_10"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2847(literal)
msgid "utf8_to_iso_8859_13"
msgstr "utf8_to_iso_8859_13"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2853(literal)
msgid "utf8_to_iso_8859_14"
msgstr "utf8_to_iso_8859_14"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2859(literal)
msgid "utf8_to_iso_8859_15"
msgstr "utf8_to_iso_8859_15"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2865(literal)
msgid "utf8_to_iso_8859_16"
msgstr "utf8_to_iso_8859_16"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2871(literal)
msgid "utf8_to_iso_8859_2"
msgstr "utf8_to_iso_8859_2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2877(literal)
msgid "utf8_to_iso_8859_3"
msgstr "utf8_to_iso_8859_3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2883(literal)
msgid "utf8_to_iso_8859_4"
msgstr "utf8_to_iso_8859_4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2889(literal)
msgid "utf8_to_iso_8859_5"
msgstr "utf8_to_iso_8859_5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2895(literal)
msgid "utf8_to_iso_8859_6"
msgstr "utf8_to_iso_8859_6"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2901(literal)
msgid "utf8_to_iso_8859_7"
msgstr "utf8_to_iso_8859_7"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2907(literal)
msgid "utf8_to_iso_8859_8"
msgstr "utf8_to_iso_8859_8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2913(literal)
msgid "utf8_to_iso_8859_9"
msgstr "utf8_to_iso_8859_9"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2919(literal)
msgid "utf8_to_johab"
msgstr "utf8_to_johab"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2925(literal)
msgid "utf8_to_koi8_r"
msgstr "utf8_to_koi8_r"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2931(literal)
msgid "utf8_to_koi8_u"
msgstr "utf8_to_koi8_u"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2937(literal)
msgid "utf8_to_sjis"
msgstr "utf8_to_sjis"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2943(literal)
msgid "utf8_to_tcvn"
msgstr "utf8_to_tcvn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2949(literal)
msgid "utf8_to_uhc"
msgstr "utf8_to_uhc"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2955(literal)
msgid "utf8_to_windows_1250"
msgstr "utf8_to_windows_1250"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2961(literal)
msgid "utf8_to_windows_1251"
msgstr "utf8_to_windows_1251"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2967(literal)
msgid "utf8_to_windows_1252"
msgstr "utf8_to_windows_1252"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2969(literal) func.xml:3064(literal)
msgid "WIN1252"
msgstr "WIN1252"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2973(literal)
msgid "utf8_to_windows_1253"
msgstr "utf8_to_windows_1253"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2975(literal)
msgid "WIN1253"
msgstr "WIN1253"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2979(literal)
msgid "utf8_to_windows_1254"
msgstr "utf8_to_windows_1254"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2981(literal)
msgid "WIN1254"
msgstr "WIN1254"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2985(literal)
msgid "utf8_to_windows_1255"
msgstr "utf8_to_windows_1255"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2987(literal)
msgid "WIN1255"
msgstr "WIN1255"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2991(literal)
msgid "utf8_to_windows_1256"
msgstr "utf8_to_windows_1256"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2993(literal) func.xml:3070(literal)
msgid "WIN1256"
msgstr "WIN1256"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2997(literal)
msgid "utf8_to_windows_1257"
msgstr "utf8_to_windows_1257"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:2999(literal)
msgid "WIN1257"
msgstr "WIN1257"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3003(literal)
msgid "utf8_to_windows_866"
msgstr "utf8_to_windows_866"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3009(literal)
msgid "utf8_to_windows_874"
msgstr "utf8_to_windows_874"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3011(literal) func.xml:3106(literal)
msgid "WIN874"
msgstr "WIN874"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3015(literal)
msgid "windows_1250_to_iso_8859_2"
msgstr "windows_1250_to_iso_8859_2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3021(literal)
msgid "windows_1250_to_mic"
msgstr "windows_1250_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3027(literal)
msgid "windows_1250_to_utf8"
msgstr "windows_1250_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3033(literal)
msgid "windows_1251_to_iso_8859_5"
msgstr "windows_1251_to_iso_8859_5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3039(literal)
msgid "windows_1251_to_koi8_r"
msgstr "windows_1251_to_koi8_r"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3045(literal)
msgid "windows_1251_to_mic"
msgstr "windows_1251_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3051(literal)
msgid "windows_1251_to_utf8"
msgstr "windows_1251_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3057(literal)
msgid "windows_1251_to_windows_866"
msgstr "windows_1251_to_windows_866"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3063(literal)
msgid "windows_1252_to_utf8"
msgstr "windows_1252_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3069(literal)
msgid "windows_1256_to_utf8"
msgstr "windows_1256_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3075(literal)
msgid "windows_866_to_iso_8859_5"
msgstr "windows_866_to_iso_8859_5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3081(literal)
msgid "windows_866_to_koi8_r"
msgstr "windows_866_to_koi8_r"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3087(literal)
msgid "windows_866_to_mic"
msgstr "windows_866_to_mic"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3093(literal)
msgid "windows_866_to_utf8"
msgstr "windows_866_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3099(literal)
msgid "windows_866_to_windows_1251"
msgstr "windows_866_to_windows_1251"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3101(literal)
msgid "WIN"
msgstr "WIN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3105(literal)
msgid "windows_874_to_utf8"
msgstr "windows_874_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3111(literal)
msgid "euc_jis_2004_to_utf8"
msgstr "euc_jis_2004_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3112(literal) func.xml:3119(literal) func.xml:3136(literal)
#: func.xml:3143(literal)
msgid "EUC_JIS_2004"
msgstr "EUC_JIS_2004"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3117(literal)
msgid "utf8_to_euc_jis_2004"
msgstr "utf8_to_euc_jis_2004"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3123(literal)
msgid "shift_jis_2004_to_utf8"
msgstr "shift_jis_2004_to_utf8"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3124(literal) func.xml:3131(literal) func.xml:3137(literal)
#: func.xml:3142(literal)
msgid "SHIFT_JIS_2004"
msgstr "SHIFT_JIS_2004"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3129(literal)
msgid "utf8_to_shift_jis_2004"
msgstr "utf8_to_shift_jis_2004"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3135(literal)
msgid "euc_jis_2004_to_shift_jis_2004"
msgstr "euc_jis_2004_to_shift_jis_2004"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3141(literal)
msgid "shift_jis_2004_to_euc_jis_2004"
msgstr "shift_jis_2004_to_euc_jis_2004"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3157(para)
msgid ""
"The function <function>format</function> produces output formatted according "
"to a format string, in a style similar to the C function <function>sprintf</"
"function>."
msgstr ""
"Функция <function>format</function> выдаёт текст, отформатированный в "
"соответствии со строкой формата, подобно функции <function>sprintf</"
"function> в C."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3163(para)
msgid ""
"<synopsis>\n"
"<function>format</function>(<parameter>formatstr</parameter> <type>text</"
"type> [, <parameter>formatarg</parameter> <type>\"any\"</type> [, ...] ])\n"
"</synopsis> <replaceable>formatstr</replaceable> is a format string that "
"specifies how the result should be formatted. Text in the format string is "
"copied directly to the result, except where <firstterm>format specifiers</"
"firstterm> are used. Format specifiers act as placeholders in the string, "
"defining how subsequent function arguments should be formatted and inserted "
"into the result. Each <replaceable>formatarg</replaceable> argument is "
"converted to text according to the usual output rules for its data type, and "
"then formatted and inserted into the result string according to the format "
"specifier(s)."
msgstr ""
"<synopsis>\n"
"<function>format</function>(<parameter>formatstr</parameter> <type>text</"
"type> [, <parameter>formatarg</parameter> <type>\"any\"</type> [, ...] ])\n"
"</synopsis> <replaceable>formatstr</replaceable> &mdash; строка, "
"определяющая, как будет форматироваться результат. Обычный текст в строке "
"формата непосредственно копируется в результат, за исключением "
"<firstterm>спецификаторов формата</firstterm>. Спецификаторы формата "
"представляют собой местозаполнители, определяющие, как должны "
"форматироваться и выводиться в результате аргументы функции. Каждый аргумент "
"<replaceable>formatarg</replaceable> преобразуется в текст по правилам "
"выводам своего типа данных, а затем форматируется и вставляется в "
"результирующую строку согласно спецификаторам формата."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3187(term)
msgid "<replaceable>position</replaceable> (optional)"
msgstr "<replaceable>позиция</replaceable> (необязателен)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3189(para)
msgid ""
"A string of the form <literal><replaceable>n</replaceable>$</literal> where "
"<replaceable>n</replaceable> is the index of the argument to print. Index 1 "
"means the first argument after <replaceable>formatstr</replaceable>. If the "
"<replaceable>position</replaceable> is omitted, the default is to use the "
"next argument in sequence."
msgstr ""
"Строка вида <literal><replaceable>n</replaceable>$</literal>, где "
"<replaceable>n</replaceable> &mdash; индекс выводимого аргумента. Индекс, "
"равный 1, выбирает первый аргумент после <replaceable>formatstr</"
"replaceable>. Если <replaceable>позиция</replaceable> опускается, по "
"умолчанию используется следующий аргумент по порядку."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3200(term)
msgid "<replaceable>flags</replaceable> (optional)"
msgstr "<replaceable>флаги</replaceable> (необязателен)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3202(para)
msgid ""
"Additional options controlling how the format specifier's output is "
"formatted. Currently the only supported flag is a minus sign (<literal>-</"
"literal>) which will cause the format specifier's output to be left-"
"justified. This has no effect unless the <replaceable>width</replaceable> "
"field is also specified."
msgstr ""
"Дополнительные параметры, управляющие форматированием данного спецификатора. "
"В настоящее время поддерживается только знак минус (<literal>-</literal>), "
"который выравнивает результата спецификатора по левому краю. Он работает, "
"только если также определена <replaceable>ширина</replaceable>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3213(term)
msgid "<replaceable>width</replaceable> (optional)"
msgstr "<replaceable>ширина</replaceable> (необязателен)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3215(para)
msgid ""
"Specifies the <emphasis>minimum</emphasis> number of characters to use to "
"display the format specifier's output. The output is padded on the left or "
"right (depending on the <literal>-</literal> flag) with spaces as needed to "
"fill the width. A too-small width does not cause truncation of the output, "
"but is simply ignored. The width may be specified using any of the "
"following: a positive integer; an asterisk (<literal>*</literal>) to use the "
"next function argument as the width; or a string of the form "
"<literal>*<replaceable>n</replaceable>$</literal> to use the <replaceable>n</"
"replaceable>th function argument as the width."
msgstr ""
"Задаёт <emphasis>минимальное</emphasis> число символов, которое будет "
"занимать результат данного спецификатора. Выводимое значение выравнивается "
"по правой или левой стороне (в зависимости от флага <literal>-</literal>) с "
"дополнением необходимым числом пробелов. Если ширина слишком мала, она "
"просто игнорируется, т. е. результат не усекается. Ширину можно обозначить "
"положительным целым, звёздочкой (<literal>*</literal>), тогда ширина будет "
"получена из следующего аргумента функции, или строкой вида "
"<literal>*<replaceable>n</replaceable>$</literal>, тогда ширина будет "
"задаваться в <replaceable>n</replaceable>-ом аргументе функции."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3227(para)
msgid ""
"If the width comes from a function argument, that argument is consumed "
"before the argument that is used for the format specifier's value. If the "
"width argument is negative, the result is left aligned (as if the <literal>-"
"</literal> flag had been specified) within a field of length <function>abs</"
"function>(<replaceable>width</replaceable>)."
msgstr ""
"Если ширина передаётся в аргументе функции, этот аргумент выбирается до "
"аргумента, используемого для спецификатора. Если аргумент ширины "
"отрицательный, результат выравнивается по левой стороне (как если бы был "
"указан флаг <literal>-</literal>) в рамках поля длины <function>abs</"
"function>(<replaceable>ширина</replaceable>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3238(term)
msgid "<replaceable>type</replaceable> (required)"
msgstr "<replaceable>тип</replaceable> (обязателен)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3245(para)
msgid ""
"<literal>s</literal> formats the argument value as a simple string. A null "
"value is treated as an empty string."
msgstr ""
"<literal>s</literal> форматирует значение аргумента как простую строку. "
"Значение NULL представляется пустой строкой."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3251(para)
msgid ""
"<literal>I</literal> treats the argument value as an SQL identifier, double-"
"quoting it if necessary. It is an error for the value to be null (equivalent "
"to <function>quote_ident</function>)."
msgstr ""
"<literal>I</literal> обрабатывает значение аргумента как SQL-идентификатор, "
"при необходимости заключая его в кавычки. Значение NULL для такого "
"преобразования считается ошибочным (так же, как и для <function>quote_ident</"
"function>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3259(para)
msgid ""
"<literal>L</literal> quotes the argument value as an SQL literal. A null "
"value is displayed as the string <literal>NULL</literal>, without quotes "
"(equivalent to <function>quote_nullable</function>)."
msgstr ""
"<literal>L</literal> заключает значение аргумента в апострофы, как строку "
"SQL. Значение NULL выводится буквально, как <literal>NULL</literal>, без "
"кавычек (так же, как и с <function>quote_nullable</function>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3240(para)
msgid ""
"The type of format conversion to use to produce the format specifier's "
"output. The following types are supported: <placeholder-1/>"
msgstr ""
"Тип спецификатора определяет преобразование соответствующего выводимого "
"значения. Поддерживаются следующие типы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3177(para)
msgid ""
"Format specifiers are introduced by a <literal>%</literal> character and "
"have the form <synopsis>\n"
"%[<replaceable>position</replaceable>][<replaceable>flags</replaceable>]"
"[<replaceable>width</replaceable>]<replaceable>type</replaceable>\n"
"</synopsis> where the component fields are: <placeholder-1/>"
msgstr ""
"Спецификаторы формата предваряются символом <literal>%</literal> и имеют "
"форму <synopsis>\n"
"%[<replaceable>позиция</replaceable>][<replaceable>флаги</replaceable>]"
"[<replaceable>ширина</replaceable>]<replaceable>тип</replaceable>\n"
"</synopsis> Здесь: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3272(para)
msgid ""
"In addition to the format specifiers described above, the special sequence "
"<literal>%%</literal> may be used to output a literal <literal>%</literal> "
"character."
msgstr ""
"В дополнение к спецификаторам, описанным выше, можно использовать "
"спецпоследовательность <literal>%%</literal>, которая просто выведет символ "
"<literal>%</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3277(para)
msgid ""
"Here are some examples of the basic format conversions: <screen>\n"
"SELECT format('Hello %s', 'World');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Hello World</"
"computeroutput>\n"
"\n"
"SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, "
"three, %</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\\'Reilly');\n"
"<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO \"Foo "
"bar\" VALUES('O''Reilly')</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\\\Program "
"Files');\n"
"<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "
"locations VALUES(E'C:\\\\Program Files')</computeroutput>\n"
"</screen>"
msgstr ""
"Несколько пример простых преобразований формата: <screen>\n"
"SELECT format('Hello %s', 'World');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Hello World</"
"computeroutput>\n"
"\n"
"SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing one, "
"two, three, %</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\\'Reilly');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO "
"\"Foo bar\" VALUES('O''Reilly')</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\\\Program "
"Files');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO "
"locations VALUES(E'C:\\\\Program Files')</computeroutput>\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3295(para)
msgid ""
"Here are examples using <replaceable>width</replaceable> fields and the "
"<literal>-</literal> flag: <screen>\n"
"SELECT format('|%10s|', 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%-10s|', 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', 10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', -10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', 10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', -10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"</screen>"
msgstr ""
"Следующие примеры иллюстрируют использование поля <replaceable>ширина</"
"replaceable> и флага <literal>-</literal>: <screen>\n"
"SELECT format('|%10s|', 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%-10s|', 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', 10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', -10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', 10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', -10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3320(para)
msgid ""
"These examples show use of <replaceable>position</replaceable> fields: "
"<screen>\n"
"SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, "
"one</computeroutput>\n"
"\n"
"SELECT format('|%*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       bar|</"
"computeroutput>\n"
"\n"
"SELECT format('|%1$*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"</screen>"
msgstr ""
"Эти примеры показывают применение полей <replaceable>позиция</replaceable>: "
"<screen>\n"
"SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing three, "
"two, one</computeroutput>\n"
"\n"
"SELECT format('|%*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       bar|</"
"computeroutput>\n"
"\n"
"SELECT format('|%1$*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3335(para)
msgid ""
"Unlike the standard C function <function>sprintf</function>, "
"<productname>PostgreSQL</productname>'s <function>format</function> function "
"allows format specifiers with and without <replaceable>position</"
"replaceable> fields to be mixed in the same format string. A format "
"specifier without a <replaceable>position</replaceable> field always uses "
"the next argument after the last argument consumed. In addition, the "
"<function>format</function> function does not require all function arguments "
"to be used in the format string. For example: <screen>\n"
"SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, "
"three</computeroutput>\n"
"</screen>"
msgstr ""
"В отличие от стандартной функции C <function>sprintf</function>, функция "
"<function>format</function> в <productname>PostgreSQL</productname> "
"позволяет комбинировать в одной строке спецификаторы с полями "
"<replaceable>позиция</replaceable> и без них. Спецификатор формата без поля "
"<replaceable>позиция</replaceable> всегда использует следующий аргумент "
"после последнего выбранного. Кроме того, функция <function>format</function> "
"не требует, чтобы в строке формата использовались все аргументы функции. "
"Пример этого поведения: <screen>\n"
"SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing three, "
"two, three</computeroutput>\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3352(para)
msgid ""
"The <literal>%I</literal> and <literal>%L</literal> format specifiers are "
"particularly useful for safely constructing dynamic SQL statements. See "
"<xref linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Спецификаторы формата <literal>%I</literal> и <literal>%L</literal> особенно "
"полезны для безопасного составления динамических операторов SQL. См. <xref "
"remap=\"4\" linkend=\"plpgsql-quote-literal-example\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3363(title)
msgid "Binary String Functions and Operators"
msgstr "Функции и операторы двоичных строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3365(indexterm)
msgid "<primary>binary data</primary> <secondary>functions</secondary>"
msgstr "<primary>двоичные данные</primary> <secondary>функции</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3370(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating values of type <type>bytea</type>."
msgstr ""
"В этом разделе описываются функции и операторы для работы с данными типа "
"<type>bytea</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3375(para)
msgid ""
"<acronym>SQL</acronym> defines some string functions that use key words, "
"rather than commas, to separate arguments. Details are in <xref linkend="
"\"functions-binarystring-sql\"/>. <productname>PostgreSQL</productname> also "
"provides versions of these functions that use the regular function "
"invocation syntax (see <xref linkend=\"functions-binarystring-other\"/>)."
msgstr ""
"В <acronym>SQL</acronym> определены несколько строковых функций, в которых "
"аргументы разделяются не запятыми, а ключевыми словами. Подробнее это "
"описано в <xref remap=\"6\" linkend=\"functions-binarystring-sql\"/>. "
"<productname>PostgreSQL</productname> также предоставляет варианты этих "
"функций с синтаксисом, обычным для функций (см. <xref remap=\"4\" linkend="
"\"functions-binarystring-other\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3386(para)
msgid ""
"The sample results shown on this page assume that the server parameter <link "
"linkend=\"guc-bytea-output\"><varname>bytea_output</varname></link> is set "
"to <literal>escape</literal> (the traditional PostgreSQL format)."
msgstr ""
"В примерах, приведённых на этой странице, подразумевается, что параметр "
"сервера <link linkend=\"guc-bytea-output\"><varname>bytea_output</varname></"
"link> равен <literal>escape</literal> (выбран традиционный формат "
"PostgreSQL)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3394(title)
msgid "<acronym>SQL</acronym> Binary String Functions and Operators"
msgstr ""
"<acronym>SQL</acronym>-функции и операторы для работы с двоичными строками"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3413(indexterm)
msgid "<primary>binary string</primary> <secondary>concatenation</secondary>"
msgstr "<primary>двоичные строки</primary> <secondary>конкатенация</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3418(literal)
msgid "E'\\\\\\\\Post'::bytea || E'\\\\047gres\\\\000'::bytea"
msgstr "E'\\\\\\\\Post'::bytea || E'\\\\047gres&zwsp;\\\\000'::bytea"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3419(literal)
msgid "\\\\Post'gres\\000"
msgstr "\\\\Post'gres&zwsp;\\000"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3430(entry)
msgid "Number of bytes in binary string"
msgstr "Число байт в двоичной строке"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3431(literal)
msgid "octet_length(E'jo\\\\000se'::bytea)"
msgstr "octet_length(E'jo\\\\000se'::bytea)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3446(literal)
msgid ""
"overlay(E'Th\\\\000omas'::bytea placing E'\\\\002\\\\003'::bytea from 2 for "
"3)"
msgstr ""
"overlay(E'Th\\\\000&zwsp;omas'::bytea placing E'\\\\002\\\\003'::bytea from "
"2 for 3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3447(literal)
msgid "T\\\\002\\\\003mas"
msgstr "T\\\\002&zwsp;\\\\003&zwsp;mas"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3459(literal)
msgid "position(E'\\\\000om'::bytea in E'Th\\\\000omas'::bytea)"
msgstr "position(E'\\\\000om'::bytea in E'Th\\\\000&zwsp;omas'::bytea)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3474(literal)
msgid "substring(E'Th\\\\000omas'::bytea from 2 for 3)"
msgstr "substring(E'Th\\\\000&zwsp;omas'::bytea from 2 for 3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3475(literal)
msgid "h\\000o"
msgstr "h\\000o"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3483(optional)
msgid "both"
msgstr "both"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3484(parameter) func.xml:3528(parameter)
msgid "bytes"
msgstr "bytes"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3483(function)
msgid "trim(<placeholder-1/> <placeholder-2/> from <placeholder-3/>)"
msgstr "trim(<placeholder-1/> <placeholder-2/> from <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3488(entry) func.xml:3531(entry)
msgid ""
"Remove the longest string containing only bytes appearing in "
"<parameter>bytes</parameter> from the start and end of <parameter>string</"
"parameter>"
msgstr ""
"Удаляет наибольшую строку, содержащую только байты, заданные в параметре "
"<parameter>bytes</parameter>, с начала и с конца строки <parameter>string</"
"parameter>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3493(literal)
msgid "trim(E'\\\\000\\\\001'::bytea from E'\\\\000Tom\\\\001'::bytea)"
msgstr "trim(E'\\\\000\\\\001'::bytea from E'\\\\000Tom\\\\001'::bytea)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3500(para)
msgid ""
"Additional binary string manipulation functions are available and are listed "
"in <xref linkend=\"functions-binarystring-other\"/>. Some of them are used "
"internally to implement the <acronym>SQL</acronym>-standard string functions "
"listed in <xref linkend=\"functions-binarystring-sql\"/>."
msgstr ""
"В <productname>PostgreSQL</productname> есть и другие функции для работы с "
"двоичными строками, перечисленные в <xref remap=\"6\" linkend=\"functions-"
"binarystring-other\"/>. Некоторые из них используются в качестве внутренней "
"реализации стандартных функций <acronym>SQL</acronym>, приведённых в <xref "
"remap=\"6\" linkend=\"functions-binarystring-sql\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3509(title)
msgid "Other Binary String Functions"
msgstr "Другие функции для работы с двоичными строками"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3527(function)
msgid ""
"btrim(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"btrim(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3536(literal)
msgid "btrim(E'\\\\000trim\\\\001'::bytea, E'\\\\000\\\\001'::bytea)"
msgstr "btrim(E'\\\\000trim\\\\001'::bytea, E'\\\\000\\\\001'::bytea)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3553(literal)
msgid "decode(E'123\\\\000456', 'escape')"
msgstr "decode(E'123&zwsp;\\\\000456', 'escape')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3554(literal) func.xml:3574(literal)
msgid "123\\000456"
msgstr "123\\000456"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3573(literal)
msgid "encode(E'123\\\\000456'::bytea, 'escape')"
msgstr "encode(E'123&zwsp;\\\\000456'::bytea, 'escape')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3579(indexterm)
msgid "<primary>get_bit</primary>"
msgstr "<primary>get_bit</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3582(parameter) func.xml:3597(parameter) func.xml:3653(parameter)
#: func.xml:3669(parameter) func.xml:19941(parameter) func.xml:19950(parameter)
msgctxt "parameter"
msgid "offset"
msgstr "offset"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3582(function)
msgid "get_bit(<placeholder-1/>, <placeholder-2/>)"
msgstr "get_bit(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3585(entry)
msgid "Extract bit from string"
msgstr "Извлекает бит из строки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3588(literal)
msgid "get_bit(E'Th\\\\000omas'::bytea, 45)"
msgstr "get_bit(E'Th\\\\000&zwsp;omas'::bytea, 45)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3594(indexterm)
msgid "<primary>get_byte</primary>"
msgstr "<primary>get_byte</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3597(function)
msgid "get_byte(<placeholder-1/>, <placeholder-2/>)"
msgstr "get_byte(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3600(entry)
msgid "Extract byte from string"
msgstr "Извлекает байт из строки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3603(literal)
msgid "get_byte(E'Th\\\\000omas'::bytea, 4)"
msgstr "get_byte(E'Th\\\\000&zwsp;omas'::bytea, 4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3604(literal)
msgid "109"
msgstr "109"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3617(indexterm)
msgid "<primary>binary string</primary> <secondary>length</secondary>"
msgstr "<primary>двоичная строка</primary> <secondary>длина</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3621(indexterm)
msgid ""
"<primary>length</primary> <secondary sortas=\"binary string\">of a binary "
"string</secondary> <see>binary strings, length</see>"
msgstr ""
"<primary>длина</primary> <secondary sortas=\"двоичная строка\">двоичной "
"строки</secondary> <see>двоичные строки, длина</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3615(entry)
msgid "Length of binary string <placeholder-1/> <placeholder-2/>"
msgstr "Длина двоичной строки <placeholder-1/> <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3627(literal)
msgid "length(E'jo\\\\000se'::bytea)"
msgstr "length(E'jo\\\\000se'::bytea)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3643(literal)
msgid "md5(E'Th\\\\000omas'::bytea)"
msgstr "md5(E'Th\\\\000&zwsp;omas'::bytea)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3644(literal)
msgid "8ab2d3c9689aaf18 b4958c334c82d8b1"
msgstr "8ab2d3c9&zwsp;689aaf18 b4958c33&zwsp;4c82d8b1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3649(indexterm)
msgid "<primary>set_bit</primary>"
msgstr "<primary>set_bit</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3653(parameter) func.xml:3669(parameter)
msgid "newvalue"
msgstr "newvalue"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3652(function)
msgid "set_bit(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_bit(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3656(entry)
msgid "Set bit in string"
msgstr "Устанавливает значение бита в строке"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3659(literal)
msgid "set_bit(E'Th\\\\000omas'::bytea, 45, 0)"
msgstr "set_bit(E'Th\\\\000&zwsp;omas'::bytea, 45, 0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3660(literal)
msgid "Th\\000omAs"
msgstr "Th\\000omAs"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3665(indexterm)
msgid "<primary>set_byte</primary>"
msgstr "<primary>set_byte</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3668(function)
msgid "set_byte(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_byte(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3672(entry)
msgid "Set byte in string"
msgstr "Устанавливает значение байта в строке"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3675(literal)
msgid "set_byte(E'Th\\\\000omas'::bytea, 4, 64)"
msgstr "set_byte(E'Th\\\\000&zwsp;omas'::bytea, 4, 64)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3676(literal)
msgid "Th\\000o@as"
msgstr "Th\\000o@as"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3682(para)
msgid ""
"<function>get_byte</function> and <function>set_byte</function> number the "
"first byte of a binary string as byte 0. <function>get_bit</function> and "
"<function>set_bit</function> number bits from the right within each byte; "
"for example bit 0 is the least significant bit of the first byte, and bit 15 "
"is the most significant bit of the second byte."
msgstr ""
"Для функций <function>get_byte</function> и <function>set_byte</function> "
"байты нумеруется с 0. Функции <function>get_bit</function> и "
"<function>set_bit</function> нумеруют биты справа налево; например, бит 0 "
"будет меньшим значащим битом первого байта, а бит 15 &mdash; большим "
"значащим битом второго байта."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3690(para)
msgid ""
"See also the aggregate function <function>string_agg</function> in <xref "
"linkend=\"functions-aggregate\"/> and the large object functions in <xref "
"linkend=\"lo-funcs\"/>."
msgstr ""
"См. также агрегатную функцию <function>string_agg</function> в <xref remap="
"\"6\" linkend=\"functions-aggregate\"/> и функции для работы с большими "
"объектами в <xref remap=\"6\" linkend=\"lo-funcs\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3699(title)
msgid "Bit String Functions and Operators"
msgstr "Функции и операторы для работы с битовыми строками"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3701(indexterm)
msgid "<primary>bit strings</primary> <secondary>functions</secondary>"
msgstr "<primary>битовые строки</primary> <secondary>функции</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3706(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating bit strings, that is values of the types <type>bit</type> and "
"<type>bit varying</type>. Aside from the usual comparison operators, the "
"operators shown in <xref linkend=\"functions-bit-string-op-table\"/> can be "
"used. Bit string operands of <literal>&amp;</literal>, <literal>|</literal>, "
"and <literal>#</literal> must be of equal length. When bit shifting, the "
"original length of the string is preserved, as shown in the examples."
msgstr ""
"В этом разделе описываются функции и операторы, предназначенные для работы с "
"битовыми строками, то есть с данными типов <type>bit</type> и <type>bit "
"varying</type>. Помимо обычных операторов сравнения, с такими данными можно "
"использовать операторы, перечисленные в <xref remap=\"6\" linkend="
"\"functions-bit-string-op-table\"/>. Заметьте, что операторы <literal>&amp;</"
"literal>, <literal>|</literal> и <literal>#</literal> работают только с "
"двоичными строками одинаковой длины. Операторы побитового сдвига сохраняют "
"длины исходных строк, как показано в примерах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3719(title)
msgid "Bit String Operators"
msgstr "Операторы для работы с битовыми строками"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3734(entry)
msgid "concatenation"
msgstr "конкатенация"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3735(literal)
msgid "B'10001' || B'011'"
msgstr "B'10001' || B'011'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3736(literal)
msgid "10001011"
msgstr "10001011"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3742(literal)
msgid "B'10001' &amp; B'01101'"
msgstr "B'10001' &amp; B'01101'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3743(literal)
msgid "00001"
msgstr "00001"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3749(literal)
msgid "B'10001' | B'01101'"
msgstr "B'10001' | B'01101'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3750(literal)
msgid "11101"
msgstr "11101"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3756(literal)
msgid "B'10001' # B'01101'"
msgstr "B'10001' # B'01101'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3757(literal)
msgid "11100"
msgstr "11100"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3763(literal)
msgid "~ B'10001'"
msgstr "~ B'10001'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3764(literal)
msgid "01110"
msgstr "01110"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3770(literal)
msgid "B'10001' &lt;&lt; 3"
msgstr "B'10001' &lt;&lt; 3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3771(literal)
msgid "01000"
msgstr "01000"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3777(literal)
msgid "B'10001' &gt;&gt; 2"
msgstr "B'10001' &gt;&gt; 2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3778(literal)
msgid "00100"
msgstr "00100"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3784(para)
msgid ""
"The following <acronym>SQL</acronym>-standard functions work on bit strings "
"as well as character strings: <literal><function>length</function></"
"literal>, <literal><function>bit_length</function></literal>, "
"<literal><function>octet_length</function></literal>, "
"<literal><function>position</function></literal>, "
"<literal><function>substring</function></literal>, "
"<literal><function>overlay</function></literal>."
msgstr ""
"Следующие функции языка <acronym>SQL</acronym> работают как с символьными, "
"так и с битовыми строками: <literal><function>length</function></literal>, "
"<literal><function>bit_length</function></literal>, "
"<literal><function>octet_length</function></literal>, "
"<literal><function>position</function></literal>, "
"<literal><function>substring</function></literal>, "
"<literal><function>overlay</function></literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3795(para)
msgid ""
"The following functions work on bit strings as well as binary strings: "
"<literal><function>get_bit</function></literal>, <literal><function>set_bit</"
"function></literal>. When working with a bit string, these functions number "
"the first (leftmost) bit of the string as bit 0."
msgstr ""
"С битовыми и двоичными строками работают функции <literal><function>get_bit</"
"function></literal> и <literal><function>set_bit</function></literal>. При "
"работе с битовыми строками эти функции нумеруют биты слева направо и самый "
"левый бит считается нулевым."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3808(programlisting)
#, no-wrap
msgid ""
"44::bit(10)                    <lineannotation>0000101100</lineannotation>\n"
"44::bit(3)                     <lineannotation>100</lineannotation>\n"
"cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>\n"
"'1110'::bit(4)::integer        <lineannotation>14</lineannotation>"
msgstr ""
"44::bit(10)                    <lineannotation>0000101100</lineannotation>\n"
"44::bit(3)                     <lineannotation>100</lineannotation>\n"
"cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>\n"
"'1110'::bit(4)::integer        <lineannotation>14</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3804(para)
msgid ""
"In addition, it is possible to cast integral values to and from type "
"<type>bit</type>. Some examples: <placeholder-1/> Note that casting to just "
"<quote>bit</quote> means casting to <literal>bit(1)</literal>, and so will "
"deliver only the least significant bit of the integer."
msgstr ""
"Кроме того, целые значения можно преобразовать в тип <type>bit</type> и "
"обратно. Например: <placeholder-1/> Заметьте, что приведение к типу "
"<quote>bit</quote> без длины будет означать приведение к <literal>bit(1)</"
"literal>, и в результате будет получен только один менее значащий бит числа."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3820(para)
msgid ""
"Casting an integer to <type>bit(n)</type> copies the rightmost <literal>n</"
"literal> bits. Casting an integer to a bit string width wider than the "
"integer itself will sign-extend on the left."
msgstr ""
"Приведение целого числа к типу <type>bit(n)</type> копирует правые "
"<literal>n</literal> бит числа. Если же целое преобразуется в битовую строку "
"большей длины, чем требуется для этого числа, она дополняется слева битами "
"знака числа."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3831(title)
msgid "Pattern Matching"
msgstr "Поиск по шаблону"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3833(indexterm)
msgid "<primary>pattern matching</primary>"
msgstr "<primary>поиск по шаблону</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3837(para)
msgid ""
"There are three separate approaches to pattern matching provided by "
"<productname>PostgreSQL</productname>: the traditional <acronym>SQL</"
"acronym> <function>LIKE</function> operator, the more recent "
"<function>SIMILAR TO</function> operator (added in SQL:1999), and "
"<acronym>POSIX</acronym>-style regular expressions. Aside from the basic "
"<quote>does this string match this pattern?</quote> operators, functions are "
"available to extract or replace matching substrings and to split a string at "
"matching locations."
msgstr ""
"<productname>PostgreSQL</productname> предлагает три разных способа поиска "
"текста по шаблону: традиционный оператор <function>LIKE</function> языка "
"<acronym>SQL</acronym>, более современный <function>SIMILAR TO</function> "
"(добавленный в SQL:1999) и регулярные выражения в стиле <acronym>POSIX</"
"acronym>. Помимо простых операторов, отвечающих на вопрос "
"<quote>соответствует ли строка этому шаблону?</quote>, в "
"<productname>PostgreSQL</productname> есть функции для извлечения или замены "
"соответствующих подстрок и для разделения строки по заданному шаблону."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3850(para)
msgid ""
"If you have pattern matching needs that go beyond this, consider writing a "
"user-defined function in Perl or Tcl."
msgstr ""
"Если этих встроенных возможностей оказывается недостаточно, вы можете "
"написать собственные функции на языке Perl или Tcl."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3857(para)
msgid ""
"While most regular-expression searches can be executed very quickly, regular "
"expressions can be contrived that take arbitrary amounts of time and memory "
"to process. Be wary of accepting regular-expression search patterns from "
"hostile sources. If you must do so, it is advisable to impose a statement "
"timeout."
msgstr ""
"Хотя чаще всего поиск по регулярному выражению бывает очень быстрым, "
"регулярные выражения бывают и настолько сложными, что их обработка может "
"занять приличное время и объём памяти. Поэтому опасайтесь шаблонов "
"регулярных выражений, поступающих из недоверенных источников. Если у вас нет "
"другого выхода, рекомендуется ввести тайм-аут для операторов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3865(para)
msgid ""
"Searches using <function>SIMILAR TO</function> patterns have the same "
"security hazards, since <function>SIMILAR TO</function> provides many of the "
"same capabilities as <acronym>POSIX</acronym>-style regular expressions."
msgstr ""
"Поиск с шаблонами <function>SIMILAR TO</function> несёт те же риски "
"безопасности, так как конструкция <function>SIMILAR TO</function> "
"предоставляет во многом те же возможности, что и регулярные выражения в "
"стиле <acronym>POSIX</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3872(para)
msgid ""
"<function>LIKE</function> searches, being much simpler than the other two "
"options, are safer to use with possibly-hostile pattern sources."
msgstr ""
"Поиск с <function>LIKE</function> гораздо проще, чем два другие варианта, "
"поэтому его безопаснее использовать с недоверенными источниками шаблонов "
"поиска."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3879(function)
msgid "LIKE"
msgstr "LIKE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3881(indexterm)
msgid "<primary>LIKE</primary>"
msgstr "<primary>LIKE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3886(replaceable) func.xml:3887(replaceable)
#: func.xml:3987(replaceable) func.xml:3988(replaceable)
msgctxt "replaceable"
msgid "string"
msgstr "строка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3886(replaceable) func.xml:3887(replaceable)
#: func.xml:3987(replaceable) func.xml:3988(replaceable)
msgid "escape-character"
msgstr "спецсимвол"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3886(optional) func.xml:3887(optional) func.xml:3987(optional)
#: func.xml:3988(optional)
msgid "ESCAPE <placeholder-1/>"
msgstr "ESCAPE <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3885(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> LIKE <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT LIKE <placeholder-5/> <placeholder-6/>"
msgstr ""
"<placeholder-1/> LIKE <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT LIKE <placeholder-5/> <placeholder-6/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3890(para)
msgid ""
"The <function>LIKE</function> expression returns true if the "
"<replaceable>string</replaceable> matches the supplied <replaceable>pattern</"
"replaceable>. (As expected, the <function>NOT LIKE</function> expression "
"returns false if <function>LIKE</function> returns true, and vice versa. An "
"equivalent expression is <literal>NOT (<replaceable>string</replaceable> "
"LIKE <replaceable>pattern</replaceable>)</literal>.)"
msgstr ""
"Выражение <function>LIKE</function> возвращает true, если "
"<replaceable>строка</replaceable> соответствует заданному "
"<replaceable>шаблону</replaceable>. (Как можно было ожидать, выражение "
"<function>NOT LIKE</function> возвращает false, когда <function>LIKE</"
"function> возвращает true, и наоборот. Этому выражению равносильно выражение "
"<literal>NOT (<replaceable>строка</replaceable> LIKE <replaceable>шаблон</"
"replaceable>)</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3901(para)
msgid ""
"If <replaceable>pattern</replaceable> does not contain percent signs or "
"underscores, then the pattern only represents the string itself; in that "
"case <function>LIKE</function> acts like the equals operator. An underscore "
"(<literal>_</literal>) in <replaceable>pattern</replaceable> stands for "
"(matches) any single character; a percent sign (<literal>%</literal>) "
"matches any sequence of zero or more characters."
msgstr ""
"Если <replaceable>шаблон</replaceable> не содержит знаков процента и "
"подчёркиваний, тогда шаблон представляет в точности строку и <function>LIKE</"
"function> работает как оператор сравнения. Подчёркивание (<literal>_</"
"literal>) в <replaceable>шаблоне</replaceable> подменяет (вместо него "
"подходит) любой символ; а знак процента (<literal>%</literal>) подменяет "
"любую (в том числе и пустую) последовательность символов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3913(programlisting)
#, no-wrap
msgid ""
"'abc' LIKE 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'a%'     <lineannotation>true</lineannotation>\n"
"'abc' LIKE '_b_'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'c'      <lineannotation>false</lineannotation>"
msgstr ""
"'abc' LIKE 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'a%'     <lineannotation>true</lineannotation>\n"
"'abc' LIKE '_b_'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'c'      <lineannotation>false</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3911(para) func.xml:4086(para) func.xml:4216(para)
#: func.xml:4248(para) func.xml:4284(para) func.xml:4362(para)
#: func.xml:4423(para)
msgid "Some examples: <placeholder-1/>"
msgstr "Несколько примеров: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3921(para)
msgid ""
"<function>LIKE</function> pattern matching always covers the entire string. "
"Therefore, if it's desired to match a sequence anywhere within a string, the "
"pattern must start and end with a percent sign."
msgstr ""
"При проверке по шаблону <function>LIKE</function> всегда рассматривается вся "
"строка. Поэтому, если нужно найти последовательность символов где-то в "
"середине строки, шаблон должен начинаться и заканчиваться знаками процента."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3927(para)
msgid ""
"To match a literal underscore or percent sign without matching other "
"characters, the respective character in <replaceable>pattern</replaceable> "
"must be preceded by the escape character. The default escape character is "
"the backslash but a different one can be selected by using the "
"<literal>ESCAPE</literal> clause. To match the escape character itself, "
"write two escape characters."
msgstr ""
"Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, "
"перед соответствующим символом в <replaceable>шаблоне</replaceable> нужно "
"добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная "
"косая черта, но с помощью предложения <literal>ESCAPE</literal> можно "
"выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте "
"его."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3938(para) func.xml:4633(para)
msgid ""
"If you have <xref linkend=\"guc-standard-conforming-strings\"/> turned off, "
"any backslashes you write in literal string constants will need to be "
"doubled. See <xref linkend=\"sql-syntax-strings\"/> for more information."
msgstr ""
"Если параметр <xref linkend=\"guc-standard-conforming-strings\"/> выключен, "
"каждый символ обратной косой черты, записываемый в текстовой константе, "
"нужно дублировать. Подробнее это описано в <xref remap=\"6\" linkend=\"sql-"
"syntax-strings\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3945(para)
msgid ""
"It's also possible to select no escape character by writing <literal>ESCAPE "
"''</literal>. This effectively disables the escape mechanism, which makes it "
"impossible to turn off the special meaning of underscore and percent signs "
"in the pattern."
msgstr ""
"Также можно отказаться от спецсимвола, написав <literal>ESCAPE ''</literal>. "
"При этом механизм спецпоследовательностей фактически отключается и "
"использовать знаки процента и подчёркивания буквально в шаблоне нельзя."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3952(para)
msgid ""
"The key word <token>ILIKE</token> can be used instead of <token>LIKE</token> "
"to make the match case-insensitive according to the active locale. This is "
"not in the <acronym>SQL</acronym> standard but is a <productname>PostgreSQL</"
"productname> extension."
msgstr ""
"Вместо <token>LIKE</token> можно использовать ключевое слово <token>ILIKE</"
"token>, чтобы поиск был регистр-независимым с учётом текущей языковой среды. "
"Этот оператор не описан в стандарте <acronym>SQL</acronym>; это расширение "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3959(para)
msgid ""
"The operator <literal>~~</literal> is equivalent to <function>LIKE</"
"function>, and <literal>~~*</literal> corresponds to <function>ILIKE</"
"function>. There are also <literal>!~~</literal> and <literal>!~~*</literal> "
"operators that represent <function>NOT LIKE</function> and <function>NOT "
"ILIKE</function>, respectively. All of these operators are "
"<productname>PostgreSQL</productname>-specific."
msgstr ""
"Кроме того, в <productname>PostgreSQL</productname> есть оператор "
"<literal>~~</literal>, равнозначный <function>LIKE</function>, и "
"<literal>~~*</literal>, соответствующий <function>ILIKE</function>. Есть "
"также два оператора <literal>!~~</literal> и <literal>!~~*</literal>, "
"представляющие <function>NOT LIKE</function> и <function>NOT ILIKE</"
"function>, соответственно. Все эти операторы можно отнести к особенностям "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3972(title)
msgid "<function>SIMILAR TO</function> Regular Expressions"
msgstr "Регулярные выражения <function>SIMILAR TO</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3974(indexterm)
msgid "<primary>regular expression</primary>"
msgstr "<primary>регулярное выражение</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3979(indexterm)
msgid "<primary>SIMILAR TO</primary>"
msgstr "<primary>SIMILAR TO</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3986(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> SIMILAR TO <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT SIMILAR TO <placeholder-5/> <placeholder-6/>"
msgstr ""
"<placeholder-1/> SIMILAR TO <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT SIMILAR TO <placeholder-5/> <placeholder-6/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:3991(para)
msgid ""
"The <function>SIMILAR TO</function> operator returns true or false depending "
"on whether its pattern matches the given string. It is similar to "
"<function>LIKE</function>, except that it interprets the pattern using the "
"SQL standard's definition of a regular expression. SQL regular expressions "
"are a curious cross between <function>LIKE</function> notation and common "
"regular expression notation."
msgstr ""
"Оператор <function>SIMILAR TO</function> возвращает true или false в "
"зависимости от того, соответствует ли данная строка шаблону или нет. Он "
"работает подобно оператору <function>LIKE</function>, только его шаблоны "
"соответствуют определению регулярных выражений в стандарте SQL. Регулярные "
"выражения SQL представляют собой любопытный гибрид синтаксиса "
"<function>LIKE</function> с синтаксисом обычных регулярных выражений."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4001(para)
msgid ""
"Like <function>LIKE</function>, the <function>SIMILAR TO</function> operator "
"succeeds only if its pattern matches the entire string; this is unlike "
"common regular expression behavior where the pattern can match any part of "
"the string. Also like <function>LIKE</function>, <function>SIMILAR TO</"
"function> uses <literal>_</literal> and <literal>%</literal> as wildcard "
"characters denoting any single character and any string, respectively (these "
"are comparable to <literal>.</literal> and <literal>.*</literal> in POSIX "
"regular expressions)."
msgstr ""
"Как и <function>LIKE</function>, условие <function>SIMILAR TO</function> "
"истинно, только если шаблон соответствует всей строке; это отличается от "
"условий с регулярными выражениями, в которых шаблон может соответствовать "
"любой части строки. Также подобно <function>LIKE</function>, "
"<function>SIMILAR TO</function> воспринимает символы <literal>_</literal> и "
"<literal>%</literal> как знаки подстановки, подменяющие любой один символ "
"или любую подстроку, соответственно (в регулярных выражениях POSIX им "
"аналогичны символы <literal>.</literal> и <literal>.*</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4021(para)
msgid "<literal>|</literal> denotes alternation (either of two alternatives)."
msgstr "<literal>|</literal> означает выбор (одного из двух вариантов)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4026(para)
msgid ""
"<literal>*</literal> denotes repetition of the previous item zero or more "
"times."
msgstr ""
"<literal>*</literal> означает повторение предыдущего элемента 0 и более раз."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4032(para)
msgid ""
"<literal>+</literal> denotes repetition of the previous item one or more "
"times."
msgstr ""
"<literal>+</literal> означает повторение предыдущего элемента 1 и более раз."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4038(para)
msgid ""
"<literal>?</literal> denotes repetition of the previous item zero or one "
"time."
msgstr ""
"<literal>?</literal> означает вхождение предыдущего элемента 0 или 1 раз."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4044(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes "
"repetition of the previous item exactly <replaceable>m</replaceable> times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>}</literal> "
"означает повторяет предыдущего элемента ровно <replaceable>m</replaceable> "
"раз."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4050(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>,}</literal> "
"denotes repetition of the previous item <replaceable>m</replaceable> or more "
"times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>,}</literal> "
"означает повторение предыдущего элемента <replaceable>m</replaceable> или "
"более раз."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4056(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal> denotes repetition "
"of the previous item at least <replaceable>m</replaceable> and not more than "
"<replaceable>n</replaceable> times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal> означает повторение "
"предыдущего элемента не менее чем <replaceable>m</replaceable> и не более "
"чем <replaceable>n</replaceable> раз."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4063(para)
msgid ""
"Parentheses <literal>()</literal> can be used to group items into a single "
"logical item."
msgstr ""
"Скобки <literal>()</literal> объединяют несколько элементов в одну "
"логическую группу."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4069(para)
msgid ""
"A bracket expression <literal>[...]</literal> specifies a character class, "
"just as in POSIX regular expressions."
msgstr ""
"Квадратные скобки <literal>[...]</literal> обозначают класс символов так же, "
"как и в регулярных выражениях POSIX."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4014(para)
msgid ""
"In addition to these facilities borrowed from <function>LIKE</function>, "
"<function>SIMILAR TO</function> supports these pattern-matching "
"metacharacters borrowed from POSIX regular expressions: <placeholder-1/> "
"Notice that the period (<literal>.</literal>) is not a metacharacter for "
"<function>SIMILAR TO</function>."
msgstr ""
"Помимо средств описания шаблонов, позаимствованных от <function>LIKE</"
"function>, <function>SIMILAR TO</function> поддерживает следующие "
"метасимволы, унаследованные от регулярных выражений POSIX: <placeholder-1/> "
"Обратите внимание, точка (<literal>.</literal>) не является метасимволом для "
"оператора <function>SIMILAR TO</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4080(para)
msgid ""
"As with <function>LIKE</function>, a backslash disables the special meaning "
"of any of these metacharacters; or a different escape character can be "
"specified with <literal>ESCAPE</literal>."
msgstr ""
"Как и с <function>LIKE</function>, обратная косая черта отменяет специальное "
"значение любого из этих метасимволов, а предложение <literal>ESCAPE</"
"literal> позволяет выбрать другой спецсимвол."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4088(programlisting)
#, no-wrap
msgid ""
"'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>\n"
"'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>"
msgstr ""
"'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>\n"
"'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4096(para)
msgid ""
"The <function>substring</function> function with three parameters, "
"<function>substring(<replaceable>string</replaceable> from "
"<replaceable>pattern</replaceable> for <replaceable>escape-character</"
"replaceable>)</function>, provides extraction of a substring that matches an "
"SQL regular expression pattern. As with <literal>SIMILAR TO</literal>, the "
"specified pattern must match the entire data string, or else the function "
"fails and returns null. To indicate the part of the pattern that should be "
"returned on success, the pattern must contain two occurrences of the escape "
"character followed by a double quote (<literal>\"</literal>). The text "
"matching the portion of the pattern between these markers is returned."
msgstr ""
"Функция <function>substring</function> с тремя параметрами, "
"<function>substring(<replaceable>строка</replaceable> from "
"<replaceable>шаблон</replaceable> for <replaceable>спецсимвол</"
"replaceable>)</function> извлекает подстроку, соответствующую шаблону "
"регулярного выражения SQL. Как и с <literal>SIMILAR TO</literal>, указанному "
"шаблону должна соответствовать вся строка, в противном случае функция не "
"найдёт ничего и вернёт NULL. Для обозначения части шаблона, которая должна "
"быть возвращена в случае успеха, шаблон должен содержать два спецсимвола и "
"кавычки (<literal>\"</literal>) после каждого. Эта функция возвращает часть "
"шаблона между двумя такими маркерами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4114(programlisting)
#, no-wrap
msgid ""
"substring('foobar' from '%#\"o_b#\"%' for '#')   <lineannotation>oob</lineannotation>\n"
"substring('foobar' from '#\"o_b#\"%' for '#')    <lineannotation>NULL</lineannotation>"
msgstr ""
"substring('foobar' from '%#\"o_b#\"%' for '#')   <lineannotation>oob</lineannotation>\n"
"substring('foobar' from '#\"o_b#\"%' for '#')    <lineannotation>NULL</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4112(para)
msgid ""
"Some examples, with <literal>#\"</literal> delimiting the return string: "
"<placeholder-1/>"
msgstr ""
"Несколько примеров с маркерами <literal>#\"</literal>, выделяющими "
"возвращаемую строку: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4122(title)
msgid "<acronym>POSIX</acronym> Regular Expressions"
msgstr "Регулярные выражения <acronym>POSIX</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4124(indexterm)
msgid ""
"<primary>regular expression</primary> <seealso>pattern matching</seealso>"
msgstr ""
"<primary>регулярное выражение</primary> <seealso>поиск по шаблону</seealso>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4147(para)
msgid ""
"<xref linkend=\"functions-posix-table\"/> lists the available operators for "
"pattern matching using POSIX regular expressions."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-posix-table\"/> перечислены все "
"существующие операторы для проверки строк регулярными выражениями POSIX."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4153(title)
msgid "Regular Expression Match Operators"
msgstr "Операторы регулярных выражений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4167(entry)
msgid "Matches regular expression, case sensitive"
msgstr "Проверяет соответствие регулярному выражению с учётом регистра"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4168(literal)
msgid "'thomas' ~ '.*thomas.*'"
msgstr "'thomas' ~ '.*thomas.*'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4172(literal)
msgid "~*"
msgstr "~*"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4173(entry)
msgid "Matches regular expression, case insensitive"
msgstr "Проверяет соответствие регулярному выражению без учёта регистра"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4174(literal)
msgid "'thomas' ~* '.*Thomas.*'"
msgstr "'thomas' ~* '.*Thomas.*'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4178(literal)
msgid "!~"
msgstr "!~"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4179(entry)
msgid "Does not match regular expression, case sensitive"
msgstr "Проверяет несоответствие регулярному выражению с учётом регистра"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4180(literal)
msgid "'thomas' !~ '.*Thomas.*'"
msgstr "'thomas' !~ '.*Thomas.*'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4184(literal)
msgid "!~*"
msgstr "!~*"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4185(entry)
msgid "Does not match regular expression, case insensitive"
msgstr "Проверяет несоответствие регулярному выражению без учёта регистра"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4186(literal)
msgid "'thomas' !~* '.*vadim.*'"
msgstr "'thomas' !~* '.*vadim.*'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4192(para)
msgid ""
"<acronym>POSIX</acronym> regular expressions provide a more powerful means "
"for pattern matching than the <function>LIKE</function> and "
"<function>SIMILAR TO</function> operators. Many Unix tools such as "
"<command>egrep</command>, <command>sed</command>, or <command>awk</command> "
"use a pattern matching language that is similar to the one described here."
msgstr ""
"Регулярные выражения <acronym>POSIX</acronym> предоставляют более мощные "
"средства поиска по шаблонам, чем операторы <function>LIKE</function> и "
"<function>SIMILAR TO</function>. Во многих командах Unix, таких как "
"<command>egrep</command>, <command>sed</command> и <command>awk</command> "
"используется язык шаблонов, похожий на описанный здесь."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4201(para)
msgid ""
"A regular expression is a character sequence that is an abbreviated "
"definition of a set of strings (a <firstterm>regular set</firstterm>). A "
"string is said to match a regular expression if it is a member of the "
"regular set described by the regular expression. As with <function>LIKE</"
"function>, pattern characters match string characters exactly unless they "
"are special characters in the regular expression language &mdash; but "
"regular expressions use different special characters than <function>LIKE</"
"function> does. Unlike <function>LIKE</function> patterns, a regular "
"expression is allowed to match anywhere within a string, unless the regular "
"expression is explicitly anchored to the beginning or end of the string."
msgstr ""
"Регулярное выражение &mdash; это последовательность символов, представляющая "
"собой краткое определение набора строк (<firstterm>регулярное множество</"
"firstterm>). Строка считается соответствующей регулярному выражению, если "
"она является членом регулярного множества, описываемого регулярным "
"выражением. Как и для <function>LIKE</function>, символы шаблона "
"непосредственно соответствуют символам строки, за исключением специальных "
"символов языка регулярных выражений. При этом спецсимволы регулярных "
"выражений отличается от спецсимволов <function>LIKE</function>. В отличие от "
"шаблонов <function>LIKE</function>, регулярное выражение может совпадать с "
"любой частью строки, если только оно не привязано явно к началу и/или концу "
"строки."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4218(programlisting)
#, no-wrap
msgid ""
"'abc' ~ 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' ~ '^a'     <lineannotation>true</lineannotation>\n"
"'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>\n"
"'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>"
msgstr ""
"'abc' ~ 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' ~ '^a'     <lineannotation>true</lineannotation>\n"
"'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>\n"
"'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4226(para)
msgid ""
"The <acronym>POSIX</acronym> pattern language is described in much greater "
"detail below."
msgstr ""
"Более подробно язык шаблонов в стиле <acronym>POSIX</acronym> описан ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4231(para)
msgid ""
"The <function>substring</function> function with two parameters, "
"<function>substring(<replaceable>string</replaceable> from "
"<replaceable>pattern</replaceable>)</function>, provides extraction of a "
"substring that matches a POSIX regular expression pattern. It returns null "
"if there is no match, otherwise the portion of the text that matched the "
"pattern. But if the pattern contains any parentheses, the portion of the "
"text that matched the first parenthesized subexpression (the one whose left "
"parenthesis comes first) is returned. You can put parentheses around the "
"whole expression if you want to use parentheses within it without triggering "
"this exception. If you need parentheses in the pattern before the "
"subexpression you want to extract, see the non-capturing parentheses "
"described below."
msgstr ""
"Функция <function>substring</function> с двумя параметрами, "
"<function>substring(<replaceable>строка</replaceable> from "
"<replaceable>шаблон</replaceable>)</function>, извлекает подстроку, "
"соответствующую шаблону регулярного выражения POSIX. Она возвращает фрагмент "
"текста, подходящий шаблону, если таковой находится в строке, либо NULL в "
"противном случае. Но если шаблон содержит скобки, она возвращает первое "
"подвыражение, заключённое в скобки (то, которое начинается с самой первой "
"открывающей скобки). Если вы хотите использовать скобки, но не в таком "
"особом режиме, можно просто заключить в них всё выражение. Если же вам нужно "
"включить скобки в шаблон до подвыражения, которое вы хотите извлечь, это "
"можно сделать, используя группы без захвата, которые будут описаны ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4250(programlisting)
#, no-wrap
msgid ""
"substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>\n"
"substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>"
msgstr ""
"substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>\n"
"substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4256(para)
msgid ""
"The <function>regexp_replace</function> function provides substitution of "
"new text for substrings that match POSIX regular expression patterns. It has "
"the syntax <function>regexp_replace</function>(<replaceable>source</"
"replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</"
"replaceable> <optional>, <replaceable>flags</replaceable></optional>). The "
"<replaceable>source</replaceable> string is returned unchanged if there is "
"no match to the <replaceable>pattern</replaceable>. If there is a match, the "
"<replaceable>source</replaceable> string is returned with the "
"<replaceable>replacement</replaceable> string substituted for the matching "
"substring. The <replaceable>replacement</replaceable> string can contain "
"<literal>\\</literal><replaceable>n</replaceable>, where <replaceable>n</"
"replaceable> is 1 through 9, to indicate that the source substring matching "
"the <replaceable>n</replaceable>'th parenthesized subexpression of the "
"pattern should be inserted, and it can contain <literal>\\&amp;</literal> to "
"indicate that the substring matching the entire pattern should be inserted. "
"Write <literal>\\\\</literal> if you need to put a literal backslash in the "
"replacement text. The <replaceable>flags</replaceable> parameter is an "
"optional text string containing zero or more single-letter flags that change "
"the function's behavior. Flag <literal>i</literal> specifies case-"
"insensitive matching, while flag <literal>g</literal> specifies replacement "
"of each matching substring rather than only the first one. Supported flags "
"(though not <literal>g</literal>) are described in <xref linkend=\"posix-"
"embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_replace</function> подставляет другой текст вместо "
"подстрок, соответствующих шаблонам регулярных выражений POSIX. Она имеет "
"синтаксис <function>regexp_replace</function>(<replaceable>исходная_строка</"
"replaceable>, <replaceable>шаблон</replaceable>, <replaceable>замена</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если "
"<replaceable>исходная_строка</replaceable> не содержит фрагмента, "
"подходящего под <replaceable>шаблон</replaceable>, она возвращается "
"неизменной. Если же соответствие находится, возвращается "
"<replaceable>исходная_строка</replaceable>, в которой вместо "
"соответствующего фрагмента подставляется <replaceable>замена</replaceable>. "
"Строка <replaceable>замена</replaceable> может содержать <literal>\\</"
"literal><replaceable>n</replaceable>, где <replaceable>n</replaceable> "
"&mdash; число от 1 до 9, указывающее на исходный фрагмент, соответствующий "
"<replaceable>n</replaceable>-ому подвыражению в скобках, и может содержать "
"обозначение <literal>\\&amp;</literal>, указывающее, что будет вставлен "
"фрагмент, соответствующий всему шаблону. Если же в текст замены нужно "
"включить обратную косую черту буквально, следует написать <literal>\\\\</"
"literal>. В необязательном параметре <replaceable>флаги</replaceable> "
"передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, "
"меняющих поведение функции. Флаг <literal>i</literal> включает поиск без "
"учёта регистра, а флаг <literal>g</literal> указывает, что заменяться должны "
"все подходящие подстроки, а не только первая из них. Допустимые флаги (кроме "
"<literal>g</literal>) описаны в <xref remap=\"6\" linkend=\"posix-embedded-"
"options-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4286(programlisting)
#, no-wrap
msgid ""
"regexp_replace('foobarbaz', 'b..', 'X')\n"
"                                   <lineannotation>fooXbaz</lineannotation>\n"
"regexp_replace('foobarbaz', 'b..', 'X', 'g')\n"
"                                   <lineannotation>fooXX</lineannotation>\n"
"regexp_replace('foobarbaz', 'b(..)', E'X\\\\1Y', 'g')\n"
"                                   <lineannotation>fooXarYXazY</lineannotation>"
msgstr ""
"regexp_replace('foobarbaz', 'b..', 'X')\n"
"                                   <lineannotation>fooXbaz</lineannotation>\n"
"regexp_replace('foobarbaz', 'b..', 'X', 'g')\n"
"                                   <lineannotation>fooXX</lineannotation>\n"
"regexp_replace('foobarbaz', 'b(..)', E'X\\\\1Y', 'g')\n"
"                                   <lineannotation>fooXarYXazY</lineannotation>"

#. +> REL_10
#: func.xml:4296(para)
msgid ""
"The <function>regexp_match</function> function returns a text array of "
"captured substring(s) resulting from the first match of a POSIX regular "
"expression pattern to a string. It has the syntax <function>regexp_match</"
"function>(<replaceable>string</replaceable>, <replaceable>pattern</"
"replaceable> <optional>, <replaceable>flags</replaceable></optional>). If "
"there is no match, the result is <literal>NULL</literal>. If a match is "
"found, and the <replaceable>pattern</replaceable> contains no parenthesized "
"subexpressions, then the result is a single-element text array containing "
"the substring matching the whole pattern. If a match is found, and the "
"<replaceable>pattern</replaceable> contains parenthesized subexpressions, "
"then the result is a text array whose <replaceable>n</replaceable>'th "
"element is the substring matching the <replaceable>n</replaceable>'th "
"parenthesized subexpression of the <replaceable>pattern</replaceable> (not "
"counting <quote>non-capturing</quote> parentheses; see below for details). "
"The <replaceable>flags</replaceable> parameter is an optional text string "
"containing zero or more single-letter flags that change the function's "
"behavior. Supported flags are described in <xref linkend=\"posix-embedded-"
"options-table\"/>."
msgstr ""
"Функция <function>regexp_match</function> возвращает текстовый массив из "
"всех подходящих подстрок, полученных из первого вхождения шаблона "
"регулярного выражения POSIX в строке. Она имеет синтаксис "
"<function>regexp_match</function>(<replaceable>строка</replaceable>, "
"<replaceable>шаблон</replaceable> <optional>, <replaceable>флаги</"
"replaceable></optional>). Если вхождение не находится, результатом будет "
"<literal>NULL</literal>. Если вхождение находится и <replaceable>шаблон</"
"replaceable> не содержит подвыражений в скобках, результатом будет текстовый "
"массив с одним элементом, содержащим подстроку, соответствующую всему "
"шаблону. Если вхождение находится и <replaceable>шаблон</replaceable> "
"содержит подвыражения в скобках, результатом будет текстовый массив, в "
"котором <replaceable>n</replaceable>-ым элементом будет <replaceable>n</"
"replaceable>-ое заключённое в скобки подвыражение <replaceable>шаблона</"
"replaceable> (не считая <quote>незахватывающих</quote> скобок; подробнее см. "
"ниже). В параметре <replaceable>флаги</replaceable> передаётся "
"необязательная текстовая строка, содержащая ноль или более однобуквенных "
"флагов, меняющих поведение функции. Допустимые флаги описаны в <xref remap="
"\"6\" linkend=\"posix-embedded-options-table\"/>."

#. +> REL_10
#: func.xml:4320(programlisting)
#, no-wrap
msgid ""
"SELECT regexp_match('foobarbequebaz', 'bar.*que');\n"
" regexp_match\n"
"--------------\n"
" {barbeque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_match('foobarbequebaz', '(bar)(beque)');\n"
" regexp_match\n"
"--------------\n"
" {bar,beque}\n"
"(1 row)"
msgstr ""
"SELECT regexp_match('foobarbequebaz', 'bar.*que');\n"
" regexp_match\n"
"--------------\n"
" {barbeque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_match('foobarbequebaz', '(bar)(beque)');\n"
" regexp_match\n"
"--------------\n"
" {bar,beque}\n"
"(1 row)"

#. +> REL_10
#: func.xml:4335(programlisting)
#, no-wrap
msgid ""
"SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];\n"
" regexp_match\n"
"--------------\n"
" barbeque\n"
"(1 row)"
msgstr ""
"SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];\n"
" regexp_match\n"
"--------------\n"
" barbeque\n"
"(1 row)"

#. +> REL_10
#: func.xml:4318(para)
msgid ""
"Some examples: <placeholder-1/> In the common case where you just want the "
"whole matching substring or <literal>NULL</literal> for no match, write "
"something like <placeholder-2/>"
msgstr ""
"Некоторые примеры: <placeholder-1/> В общем случае просто получить всю "
"найденную подстроку или <literal>NULL</literal>, если нет соответствия, "
"можно примерно так: <placeholder-2/>"

#. +> REL_10
#: func.xml:4344(para)
msgid ""
"The <function>regexp_matches</function> function returns a set of text "
"arrays of captured substring(s) resulting from matching a POSIX regular "
"expression pattern to a string. It has the same syntax as "
"<function>regexp_match</function>. This function returns no rows if there is "
"no match, one row if there is a match and the <literal>g</literal> flag is "
"not given, or <replaceable>N</replaceable> rows if there are <replaceable>N</"
"replaceable> matches and the <literal>g</literal> flag is given. Each "
"returned row is a text array containing the whole matched substring or the "
"substrings matching parenthesized subexpressions of the "
"<replaceable>pattern</replaceable>, just as described above for "
"<function>regexp_match</function>. <function>regexp_matches</function> "
"accepts all the flags shown in <xref linkend=\"posix-embedded-options-table"
"\"/>, plus the <literal>g</literal> flag which commands it to return all "
"matches, not just the first one."
msgstr ""
"Функция <function>regexp_matches</function> возвращает набор текстовых "
"массивов со всеми подходящими подстроками, полученными в результате "
"применения регулярного выражения POSIX к строке. Она имеет тот же синтаксис, "
"что и <function>regexp_match</function>. Эта функция не возвращает никаких "
"строк, если вхождений нет; возвращает одну строку, если найдено одно "
"вхождение и не передан флаг <literal>g</literal>, или <replaceable>N</"
"replaceable> строк, если найдено <replaceable>N</replaceable> вхождений и "
"передан флаг <literal>g</literal>. Каждая возвращаемая строка представляет "
"собой текстовый массив, содержащий всю найденную подстроку или подстроки, "
"соответствующие заключённым в скобки подвыражениям <replaceable>шаблона</"
"replaceable>, как и описанный выше результат <function>regexp_match</"
"function>. Функция <function>regexp_matches</function> принимает все флаги, "
"показанные в <xref remap=\"6\" linkend=\"posix-embedded-options-table\"/>, а "
"также флаг <literal>g</literal>, указывающий ей выдать все вхождения, а не "
"только первое."

#. +> REL_10
#: func.xml:4364(programlisting)
#, no-wrap
msgid ""
"SELECT regexp_matches('foo', 'not there');\n"
" regexp_matches\n"
"----------------\n"
"(0 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches\n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)"
msgstr ""
"SELECT regexp_matches('foo', 'not there');\n"
" regexp_matches\n"
"----------------\n"
"(0 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches\n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4388(programlisting)
#, no-wrap
msgid "SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;"
msgstr "SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;"

#. +> REL_10
#: func.xml:4380(para)
msgid ""
"In most cases <function>regexp_matches()</function> should be used with the "
"<literal>g</literal> flag, since if you only want the first match, it's "
"easier and more efficient to use <function>regexp_match()</function>. "
"However, <function>regexp_match()</function> only exists in "
"<productname>PostgreSQL</productname> version 10 and up. When working in "
"older versions, a common trick is to place a <function>regexp_matches()</"
"function> call in a sub-select, for example: <placeholder-1/> This produces "
"a text array if there's a match, or <literal>NULL</literal> if not, the same "
"as <function>regexp_match()</function> would do. Without the sub-select, "
"this query would produce no output at all for table rows without a match, "
"which is typically not the desired behavior."
msgstr ""
"В большинстве случаев <function>regexp_matches()</function> должна "
"применяться с флагом <literal>g</literal>, так как если вас интересует "
"только первое вхождение, проще и эффективнее использовать функцию "
"<function>regexp_match()</function>. Однако <function>regexp_match()</"
"function> существует только в <productname>PostgreSQL</productname> версии "
"10 и выше. В старых версиях обычно помещали вызов "
"<function>regexp_matches()</function> во вложенный SELECT, например, так: "
"<placeholder-1/> В результате выдаётся текстовый массив, если вхождение "
"найдено, или <literal>NULL</literal> в противном случае, так же как с "
"<function>regexp_match()</function>. Без вложенного SELECT этот запрос не "
"возвращает никакие строки, если соответствие не находится, а это обычно не "
"то, что нужно."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4398(para)
msgid ""
"The <function>regexp_split_to_table</function> function splits a string "
"using a POSIX regular expression pattern as a delimiter. It has the syntax "
"<function>regexp_split_to_table</function>(<replaceable>string</"
"replaceable>, <replaceable>pattern</replaceable> <optional>, "
"<replaceable>flags</replaceable></optional>). If there is no match to the "
"<replaceable>pattern</replaceable>, the function returns the "
"<replaceable>string</replaceable>. If there is at least one match, for each "
"match it returns the text from the end of the last match (or the beginning "
"of the string) to the beginning of the match. When there are no more "
"matches, it returns the text from the end of the last match to the end of "
"the string. The <replaceable>flags</replaceable> parameter is an optional "
"text string containing zero or more single-letter flags that change the "
"function's behavior. <function>regexp_split_to_table</function> supports the "
"flags described in <xref linkend=\"posix-embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_split_to_table</function> разделяет строку, "
"используя в качестве разделителя шаблон регулярного выражения POSIX. Она "
"имеет синтаксис <function>regexp_split_to_table</"
"function>(<replaceable>строка</replaceable>, <replaceable>шаблон</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если "
"<replaceable>шаблон</replaceable> не находится в переданной строке, "
"возвращается вся <replaceable>строка</replaceable> целиком. Если находится "
"минимум одно вхождение, для каждого такого вхождения возвращается текст от "
"конца предыдущего вхождения (или начала строки) до начала вхождения. После "
"последнего найденного вхождения возвращается фрагмент от его конца до конца "
"строки. В необязательном параметре <replaceable>флаги</replaceable> "
"передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, "
"меняющих поведение функции. Флаги, которые поддерживает "
"<function>regexp_split_to_table</function>, описаны в <xref remap=\"6\" "
"linkend=\"posix-embedded-options-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4414(para)
msgid ""
"The <function>regexp_split_to_array</function> function behaves the same as "
"<function>regexp_split_to_table</function>, except that "
"<function>regexp_split_to_array</function> returns its result as an array of "
"<type>text</type>. It has the syntax <function>regexp_split_to_array</"
"function>(<replaceable>string</replaceable>, <replaceable>pattern</"
"replaceable> <optional>, <replaceable>flags</replaceable></optional>). The "
"parameters are the same as for <function>regexp_split_to_table</function>."
msgstr ""
"Функция <function>regexp_split_to_array</function> ведёт себя подобно "
"<function>regexp_split_to_table</function>, за исключением того, что "
"<function>regexp_split_to_array</function> возвращает результат в массиве "
"элементов типа <type>text</type>. Она имеет синтаксис "
"<function>regexp_split_to_array</function>(<replaceable>строка</"
"replaceable>, <replaceable>шаблон</replaceable> <optional>, "
"<replaceable>флаги</replaceable></optional>). Параметры у этой функции те "
"же, что и у <function>regexp_split_to_table</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4425(programlisting)
#, no-wrap
msgid ""
"SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\\\s+') AS foo;\n"
"  foo   \n"
"-------\n"
" the    \n"
" quick  \n"
" brown  \n"
" fox    \n"
" jumps \n"
" over   \n"
" the    \n"
" lazy   \n"
" dog    \n"
"(9 rows)\n"
"\n"
"SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\\\s+');\n"
"              regexp_split_to_array             \n"
"-----------------------------------------------\n"
" {the,quick,brown,fox,jumps,over,the,lazy,dog}\n"
"(1 row)\n"
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\\\s*') AS foo;\n"
" foo \n"
"-----\n"
" t         \n"
" h         \n"
" e         \n"
" q         \n"
" u         \n"
" i         \n"
" c         \n"
" k         \n"
" b         \n"
" r         \n"
" o         \n"
" w         \n"
" n         \n"
" f         \n"
" o         \n"
" x         \n"
"(16 rows)"
msgstr ""
"SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\\\s+') AS foo;\n"
"  foo   \n"
"-------\n"
" the    \n"
" quick  \n"
" brown  \n"
" fox    \n"
" jumps \n"
" over   \n"
" the    \n"
" lazy   \n"
" dog    \n"
"(9 rows)\n"
"\n"
"SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\\\s+');\n"
"              regexp_split_to_array             \n"
"-----------------------------------------------\n"
" {the,quick,brown,fox,jumps,over,the,lazy,dog}\n"
"(1 row)\n"
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\\\s*') AS foo;\n"
" foo \n"
"-----\n"
" t         \n"
" h         \n"
" e         \n"
" q         \n"
" u         \n"
" i         \n"
" c         \n"
" k         \n"
" b         \n"
" r         \n"
" o         \n"
" w         \n"
" n         \n"
" f         \n"
" o         \n"
" x         \n"
"(16 rows)"

#. +> REL_10
#: func.xml:4470(para)
msgid ""
"As the last example demonstrates, the regexp split functions ignore zero-"
"length matches that occur at the start or end of the string or immediately "
"after a previous match. This is contrary to the strict definition of regexp "
"matching that is implemented by <function>regexp_match</function> and "
"<function>regexp_matches</function>, but is usually the most convenient "
"behavior in practice. Other software systems such as Perl use similar "
"definitions."
msgstr ""
"Как показывает последний пример, функции разделения по регулярным выражениям "
"игнорируют вхождения нулевой длины, идущие в начале и в конце строки, а "
"также непосредственно за предыдущим вхождением. Это поведение противоречит "
"строгому определению поиска по регулярным выражениям, который реализуют "
"функции <function>regexp_match</function> и <function>regexp_matches</"
"function>, но обычно более удобно на практике. Подобное поведение "
"наблюдается и в других программных средах, например в Perl."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4483(title)
msgid "Regular Expression Details"
msgstr "Подробное описание регулярных выражений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4485(para)
msgid ""
"<productname>PostgreSQL</productname>'s regular expressions are implemented "
"using a software package written by Henry Spencer. Much of the description "
"of regular expressions below is copied verbatim from his manual."
msgstr ""
"Регулярные выражения в <productname>PostgreSQL</productname> реализованы с "
"использованием программного пакета, который разработал Генри Спенсер (Henry "
"Spencer). Практически всё следующее описание регулярных выражений дословно "
"скопировано из его руководства."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4492(para)
msgid ""
"Regular expressions (<acronym>RE</acronym>s), as defined in <acronym>POSIX</"
"acronym> 1003.2, come in two forms: <firstterm>extended</firstterm> "
"<acronym>RE</acronym>s or <acronym>ERE</acronym>s (roughly those of "
"<command>egrep</command>), and <firstterm>basic</firstterm> <acronym>RE</"
"acronym>s or <acronym>BRE</acronym>s (roughly those of <command>ed</"
"command>). <productname>PostgreSQL</productname> supports both forms, and "
"also implements some extensions that are not in the POSIX standard, but have "
"become widely used due to their availability in programming languages such "
"as Perl and Tcl. <acronym>RE</acronym>s using these non-POSIX extensions are "
"called <firstterm>advanced</firstterm> <acronym>RE</acronym>s or "
"<acronym>ARE</acronym>s in this documentation. AREs are almost an exact "
"superset of EREs, but BREs have several notational incompatibilities (as "
"well as being much more limited). We first describe the ARE and ERE forms, "
"noting features that apply only to AREs, and then describe how BREs differ."
msgstr ""
"Регулярное выражение (Regular expression, <acronym>RE</acronym>), согласно "
"определению в <acronym>POSIX</acronym> 1003.2, может иметь две формы: "
"<firstterm>расширенное</firstterm> <acronym>RE</acronym> или <acronym>ERE</"
"acronym> (грубо говоря, это выражения которые понимает <command>egrep</"
"command>) и <firstterm>простое</firstterm> <acronym>RE</acronym> или "
"<acronym>BRE</acronym> (грубо говоря, это выражения для <command>ed</"
"command>). <productname>PostgreSQL</productname> поддерживает обе формы, а "
"кроме того реализует некоторые расширения, не предусмотренные стандартом "
"POSIX, но широко используемые вследствие их доступности в некоторых языках "
"программирования, например в Perl и Tcl. Регулярные выражения, использующие "
"эти несовместимые с POSIX расширения, здесь называются "
"<firstterm>усовершенствованными</firstterm> <acronym>RE</acronym> или "
"<acronym>ARE</acronym>. ARE практически представляют собой надмножество ERE, "
"тогда как BRE отличаются некоторой несовместимостью в записи (помимо того, "
"что они гораздо более ограничены). Сначала мы опишем формы ARE и ERE, "
"отметив особенности, присущие только ARE, а затем расскажем, чем от них "
"отличаются BRE."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4513(para)
msgid ""
"<productname>PostgreSQL</productname> always initially presumes that a "
"regular expression follows the ARE rules. However, the more limited ERE or "
"BRE rules can be chosen by prepending an <firstterm>embedded option</"
"firstterm> to the RE pattern, as described in <xref linkend=\"posix-"
"metasyntax\"/>. This can be useful for compatibility with applications that "
"expect exactly the <acronym>POSIX</acronym> 1003.2 rules."
msgstr ""
"<productname>PostgreSQL</productname> изначально всегда предполагает, что "
"регулярное выражение следует правилам ARE. Однако можно переключиться на "
"более ограниченные правила ERE или BRE, добавив в шаблон RE "
"<firstterm>встроенный параметр</firstterm>, как описано в <xref remap=\"6\" "
"linkend=\"posix-metasyntax\"/>. Это может быть полезно для совместимости с "
"приложениями, ожидающими от СУБД строгого следования правилам "
"<acronym>POSIX</acronym> 1003.2."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4523(para)
msgid ""
"A regular expression is defined as one or more <firstterm>branches</"
"firstterm>, separated by <literal>|</literal>. It matches anything that "
"matches one of the branches."
msgstr ""
"Регулярное выражение определяется как одна или более <firstterm>ветвей</"
"firstterm>, разделённых символами <literal>|</literal>. Оно считается "
"соответствующим всему, что соответствует одной из этих ветвей."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4530(para)
msgid ""
"A branch is zero or more <firstterm>quantified atoms</firstterm> or "
"<firstterm>constraints</firstterm>, concatenated. It matches a match for the "
"first, followed by a match for the second, etc; an empty branch matches the "
"empty string."
msgstr ""
"Ветвь &mdash; это ноль или несколько <firstterm>количественных атомов</"
"firstterm> или <firstterm>ограничений</firstterm>, соединённых вместе. "
"Соответствие ветви в целом образуется из соответствия первой части, за "
"которым следует соответствие второй части и т. д.; пустой ветви "
"соответствует пустая строка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4537(para)
msgid ""
"A quantified atom is an <firstterm>atom</firstterm> possibly followed by a "
"single <firstterm>quantifier</firstterm>. Without a quantifier, it matches a "
"match for the atom. With a quantifier, it can match some number of matches "
"of the atom. An <firstterm>atom</firstterm> can be any of the possibilities "
"shown in <xref linkend=\"posix-atoms-table\"/>. The possible quantifiers and "
"their meanings are shown in <xref linkend=\"posix-quantifiers-table\"/>."
msgstr ""
"Количественный атом &mdash; это <firstterm>атом</firstterm>, за которым "
"может следовать <firstterm>определитель количества</firstterm>. Без этого "
"определителя ему соответствует одно вхождение атома. С определителем "
"количества ему может соответствовать некоторое число вхождений этого атома. "
"Все возможные <firstterm>атомы</firstterm> перечислены в <xref remap=\"6\" "
"linkend=\"posix-atoms-table\"/>. Варианты определителей количества и их "
"значения перечислены в <xref remap=\"6\" linkend=\"posix-quantifiers-table\"/"
">."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4548(para)
msgid ""
"A <firstterm>constraint</firstterm> matches an empty string, but matches "
"only when specific conditions are met. A constraint can be used where an "
"atom could be used, except it cannot be followed by a quantifier. The simple "
"constraints are shown in <xref linkend=\"posix-constraints-table\"/>; some "
"more constraints are described later."
msgstr ""
"<firstterm>Ограничению</firstterm> соответствует пустая строка, но это "
"соответствие возможно только при выполнении определённых условий. "
"Ограничения могут использоваться там же, где и атомы, за исключением того, "
"что их нельзя дополнять определителями количества. Простые ограничения "
"показаны в <xref remap=\"6\" linkend=\"posix-constraints-table\"/>; "
"некоторые дополнительные ограничения описаны ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4559(title)
msgid "Regular Expression Atoms"
msgstr "Атомы регулярных выражений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4564(entry)
msgid "Atom"
msgstr "Атом"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4571(literal)
msgid "("
msgstr "("

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4571(replaceable) func.xml:4578(replaceable)
#: func.xml:4767(replaceable) func.xml:4774(replaceable)
#: func.xml:4781(replaceable) func.xml:4788(replaceable)
msgid "re"
msgstr "re"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4571(literal) func.xml:4578(literal) func.xml:4767(literal)
#: func.xml:4774(literal) func.xml:4781(literal) func.xml:4788(literal)
msgid ")"
msgstr ")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4572(entry)
msgid ""
"(where <replaceable>re</replaceable> is any regular expression) matches a "
"match for <replaceable>re</replaceable>, with the match noted for possible "
"reporting"
msgstr ""
"(где <replaceable>re</replaceable> &mdash; любое регулярное выражение) "
"описывает соответствие <replaceable>re</replaceable>, при этом данное "
"соответствие захватывается для последующей обработки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4578(literal)
msgid "(?:"
msgstr "(?:"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4579(entry)
msgid ""
"as above, but the match is not noted for reporting (a <quote>non-capturing</"
"quote> set of parentheses) (AREs only)"
msgstr ""
"подобно предыдущему, но соответствие не захватывается (т. е. это набор "
"скобок <quote>без захвата</quote>) (применимо только к ARE)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4585(literal)
msgid "."
msgstr "."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4586(entry)
msgid "matches any single character"
msgstr "соответствует любому символу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4590(literal)
msgid "["
msgstr "["

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4590(replaceable)
msgid "chars"
msgstr "символы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4590(literal)
msgid "]"
msgstr "]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4591(entry)
msgid ""
"a <firstterm>bracket expression</firstterm>, matching any one of the "
"<replaceable>chars</replaceable> (see <xref linkend=\"posix-bracket-"
"expressions\"/> for more detail)"
msgstr ""
"<firstterm>выражение в квадратных скобках</firstterm>, соответствует любому "
"из <replaceable>символов</replaceable> (подробнее это описано в <xref remap="
"\"6\" linkend=\"posix-bracket-expressions\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4597(literal) func.xml:4604(literal) func.xml:5058(literal)
#: func.xml:5066(literal) func.xml:5225(literal) func.xml:5231(literal)
msgid "\\"
msgstr "\\"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4597(replaceable)
msgid "k"
msgstr "k"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4598(entry)
msgid ""
"(where <replaceable>k</replaceable> is a non-alphanumeric character) matches "
"that character taken as an ordinary character, e.g., <literal>\\\\</literal> "
"matches a backslash character"
msgstr ""
"(где <replaceable>k</replaceable> &mdash; не алфавитно-цифровой символ) "
"соответствует обычному символу буквально, т. е. <literal>\\\\</literal> "
"соответствует обратной косой черте"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4604(replaceable)
msgctxt "replaceable"
msgid "c"
msgstr "c"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4605(entry)
msgid ""
"where <replaceable>c</replaceable> is alphanumeric (possibly followed by "
"other characters) is an <firstterm>escape</firstterm>, see <xref linkend="
"\"posix-escape-sequences\"/> (AREs only; in EREs and BREs, this matches "
"<replaceable>c</replaceable>)"
msgstr ""
"где <replaceable>c</replaceable> &mdash; алфавитно-цифровой символ (за "
"которым могут следовать другие символы), это <firstterm>спецсимвол</"
"firstterm>, см. <xref remap=\"4\" linkend=\"posix-escape-sequences\"/> "
"(применим только к ARE; в ERE и BRE этому атому соответствует "
"<replaceable>c</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4612(literal) func.xml:4668(literal) func.xml:4673(literal)
#: func.xml:4679(literal) func.xml:4701(literal) func.xml:4706(literal)
#: func.xml:4712(literal)
msgid "{"
msgstr "{"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4613(entry)
msgid ""
"when followed by a character other than a digit, matches the left-brace "
"character <literal>{</literal>; when followed by a digit, it is the "
"beginning of a <replaceable>bound</replaceable> (see below)"
msgstr ""
"когда за этим символом следует любой символ, кроме цифры, этот атом "
"соответствует левой фигурной скобке (<literal>{</literal>), если же за ним "
"следует цифра, это обозначает начало <replaceable>границы</replaceable> (см. "
"ниже)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4621(entry)
msgid ""
"where <replaceable>x</replaceable> is a single character with no other "
"significance, matches that character"
msgstr ""
"(где <replaceable>x</replaceable> &mdash; один символ, не имеющий "
"специального значения) соответствует этому символу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4628(para)
msgid "An RE cannot end with a backslash (<literal>\\</literal>)."
msgstr ""
"Выражение RE не может заканчиваться обратной косой чертой (<literal>\\</"
"literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4641(title)
msgid "Regular Expression Quantifiers"
msgstr "Определители количества в регулярных выражениях"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4646(entry)
msgid "Quantifier"
msgstr "Определитель"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4647(entry)
msgid "Matches"
msgstr "Соответствует"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4654(entry)
msgid "a sequence of 0 or more matches of the atom"
msgstr "0 или более вхождений атома"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4659(entry)
msgid "a sequence of 1 or more matches of the atom"
msgstr "1 или более вхождений атома"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4663(literal) func.xml:11161(literal)
msgid "?"
msgstr "?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4664(entry)
msgid "a sequence of 0 or 1 matches of the atom"
msgstr "0 или 1 вхождение атома"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4668(replaceable) func.xml:4673(replaceable)
#: func.xml:4679(replaceable) func.xml:4701(replaceable)
#: func.xml:4706(replaceable) func.xml:4712(replaceable)
#: func.xml:5225(replaceable)
msgctxt "replaceable"
msgid "m"
msgstr "m"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4668(literal) func.xml:4679(literal)
msgid "}"
msgstr "}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4669(entry)
msgid "a sequence of exactly <replaceable>m</replaceable> matches of the atom"
msgstr "ровно <replaceable>m</replaceable> вхождений атома"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4673(literal)
msgid ",}"
msgstr ",}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4674(entry)
msgid "a sequence of <replaceable>m</replaceable> or more matches of the atom"
msgstr "<replaceable>m</replaceable> или более вхождений атома"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4679(literal) func.xml:4712(literal)
msgid ","
msgstr ","

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4679(replaceable) func.xml:4712(replaceable)
msgctxt "replaceable"
msgid "n"
msgstr "n"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4680(entry)
msgid ""
"a sequence of <replaceable>m</replaceable> through <replaceable>n</"
"replaceable> (inclusive) matches of the atom; <replaceable>m</replaceable> "
"cannot exceed <replaceable>n</replaceable>"
msgstr ""
"от <replaceable>m</replaceable> до <replaceable>n</replaceable> (включая "
"границы) вхождений атома; <replaceable>m</replaceable> не может быть больше "
"<replaceable>n</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4686(literal)
msgid "*?"
msgstr "*?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4687(entry)
msgid "non-greedy version of <literal>*</literal>"
msgstr "не жадная версия <literal>*</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4691(literal)
msgid "+?"
msgstr "+?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4692(entry)
msgid "non-greedy version of <literal>+</literal>"
msgstr "не жадная версия <literal>+</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4696(literal)
msgid "??"
msgstr "??"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4697(entry)
msgid "non-greedy version of <literal>?</literal>"
msgstr "не жадная версия <literal>?</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4701(literal) func.xml:4712(literal)
msgid "}?"
msgstr "}?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4702(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>}</literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>}</"
"literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4706(literal)
msgid ",}?"
msgstr ",}?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4707(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>,}</literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,}"
"</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4713(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</"
"literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4719(para)
msgid ""
"The forms using <literal>{</literal><replaceable>...</replaceable><literal>}"
"</literal> are known as <firstterm>bounds</firstterm>. The numbers "
"<replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound "
"are unsigned decimal integers with permissible values from 0 to 255 "
"inclusive."
msgstr ""
"В формах с <literal>{</literal><replaceable>...</replaceable><literal>}</"
"literal> числа <replaceable>m</replaceable> и <replaceable>n</replaceable> "
"определяют так называемые <firstterm>границы</firstterm> количества. Эти "
"числа должны быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 "
"включительно."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4726(para)
msgid ""
"<firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match "
"the same possibilities as their corresponding normal (<firstterm>greedy</"
"firstterm>) counterparts, but prefer the smallest number rather than the "
"largest number of matches. See <xref linkend=\"posix-matching-rules\"/> for "
"more detail."
msgstr ""
"<firstterm>Не жадные</firstterm> определители (допустимые только в ARE) "
"описывают те же возможные соответствия, что и аналогичные им обычные (&laquo;"
"<firstterm>жадные</firstterm>&raquo;), но предпочитают выбирать наименьшее, "
"а не наибольшее количество вхождений. Подробнее это описано в <xref remap="
"\"6\" linkend=\"posix-matching-rules\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4735(para)
msgid ""
"A quantifier cannot immediately follow another quantifier, e.g., "
"<literal>**</literal> is invalid. A quantifier cannot begin an expression or "
"subexpression or follow <literal>^</literal> or <literal>|</literal>."
msgstr ""
"Определители количества не могут следовать один за другим, например запись "
"<literal>**</literal> будет ошибочной. Кроме того, определители не могут "
"стоять в начале выражения или подвыражения и идти сразу после <literal>^</"
"literal> или <literal>|</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4745(title)
msgid "Regular Expression Constraints"
msgstr "Ограничения в регулярных выражениях"

# #-#-#-#-#  -  #-#-#-#-#
# refragment
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4750(entry)
msgid "Constraint"
msgstr "Ограничение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4758(entry)
msgid "matches at the beginning of the string"
msgstr "соответствует началу строки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4762(literal)
msgid "$"
msgstr "$"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4763(entry)
msgid "matches at the end of the string"
msgstr "соответствует концу строки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4767(literal)
msgid "(?="
msgstr "(?="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4768(entry)
msgid ""
"<firstterm>positive lookahead</firstterm> matches at any point where a "
"substring matching <replaceable>re</replaceable> begins (AREs only)"
msgstr ""
"<firstterm>позитивный просмотр вперёд</firstterm> находит соответствие там, "
"где начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4774(literal)
msgid "(?!"
msgstr "(?!"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4775(entry)
msgid ""
"<firstterm>negative lookahead</firstterm> matches at any point where no "
"substring matching <replaceable>re</replaceable> begins (AREs only)"
msgstr ""
"<firstterm>негативный просмотр вперёд</firstterm> находит соответствие там, "
"где не начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4781(literal)
msgid "(?&lt;="
msgstr "(?&lt;="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4782(entry)
msgid ""
"<firstterm>positive lookbehind</firstterm> matches at any point where a "
"substring matching <replaceable>re</replaceable> ends (AREs only)"
msgstr ""
"<firstterm>позитивный просмотр назад</firstterm> находит соответствие там, "
"где заканчивается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4788(literal)
msgid "(?&lt;!"
msgstr "(?&lt;!"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4789(entry)
msgid ""
"<firstterm>negative lookbehind</firstterm> matches at any point where no "
"substring matching <replaceable>re</replaceable> ends (AREs only)"
msgstr ""
"<firstterm>негативный просмотр назад</firstterm> находит соответствие там, "
"где не заканчивается подстрока, соответствующая <replaceable>re</"
"replaceable> (только для ARE)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4797(para)
msgid ""
"Lookahead and lookbehind constraints cannot contain <firstterm>back "
"references</firstterm> (see <xref linkend=\"posix-escape-sequences\"/>), and "
"all parentheses within them are considered non-capturing."
msgstr ""
"Ограничения просмотра вперёд и назад не могут содержать <firstterm>ссылки "
"назад</firstterm> (см. <xref remap=\"4\" linkend=\"posix-escape-sequences\"/"
">), и все скобки в них считаются &laquo;скобками без захвата&raquo;."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4805(title)
msgid "Bracket Expressions"
msgstr "Выражения в квадратных скобках"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4807(para)
msgid ""
"A <firstterm>bracket expression</firstterm> is a list of characters enclosed "
"in <literal>[]</literal>. It normally matches any single character from the "
"list (but see below). If the list begins with <literal>^</literal>, it "
"matches any single character <emphasis>not</emphasis> from the rest of the "
"list. If two characters in the list are separated by <literal>-</literal>, "
"this is shorthand for the full range of characters between those two "
"(inclusive) in the collating sequence, e.g., <literal>[0-9]</literal> in "
"<acronym>ASCII</acronym> matches any decimal digit. It is illegal for two "
"ranges to share an endpoint, e.g., <literal>a-c-e</literal>. Ranges are very "
"collating-sequence-dependent, so portable programs should avoid relying on "
"them."
msgstr ""
"<firstterm>Выражение в квадратных скобках</firstterm> содержит список "
"символов, заключённый в <literal>[]</literal>. Обычно ему соответствует "
"любой символ из списка (об исключении написано ниже). Если список начинается "
"с <literal>^</literal>, ему соответствует любой символ, который "
"<emphasis>не</emphasis> перечисляется далее в этом списке. Если два символа "
"в списке разделяются знаком <literal>-</literal>, это воспринимается как "
"краткая запись полного интервала символов между двумя заданными (и включая "
"их) в порядке сортировки; например выражению <literal>[0-9]</literal> в "
"<acronym>ASCII</acronym> соответствует любая десятичная цифра. Два интервала "
"не могут разделять одну границу, т. е. выражение <literal>a-c-e</literal> "
"недопустимо. Интервалы зависят от порядка сортировки, который может "
"меняться, поэтому в переносимых программах их лучше не использовать."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4824(para)
msgid ""
"To include a literal <literal>]</literal> in the list, make it the first "
"character (after <literal>^</literal>, if that is used). To include a "
"literal <literal>-</literal>, make it the first or last character, or the "
"second endpoint of a range. To use a literal <literal>-</literal> as the "
"first endpoint of a range, enclose it in <literal>[.</literal> and "
"<literal>.]</literal> to make it a collating element (see below). With the "
"exception of these characters, some combinations using <literal>[</literal> "
"(see next paragraphs), and escapes (AREs only), all other special characters "
"lose their special significance within a bracket expression. In particular, "
"<literal>\\</literal> is not special when following ERE or BRE rules, though "
"it is special (as introducing an escape) in AREs."
msgstr ""
"Чтобы включить в список <literal>]</literal>, этот символ нужно написать "
"первым (сразу за <literal>^</literal>, если он присутствует). Чтобы включить "
"в список символ <literal>-</literal>, его нужно написать первым или "
"последним, либо как вторую границу интервала. Указать <literal>-</literal> в "
"качестве первой границы интервал можно, заключив его между <literal>[.</"
"literal> и <literal>.]</literal>, чтобы он стал элементом сортировки (см. "
"ниже). За исключением этих символов, некоторых комбинаций с <literal>[</"
"literal> (см. следующие абзацы) и спецсимволов (в ARE), все остальные "
"специальные символы в квадратных скобках теряют своё особое значение. В "
"частности, символ <literal>\\</literal> по правилам ERE или BRE "
"воспринимается как обычный, хотя в ARE он экранирует символ, следующий за "
"ним."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4840(para)
msgid ""
"Within a bracket expression, a collating element (a character, a multiple-"
"character sequence that collates as if it were a single character, or a "
"collating-sequence name for either) enclosed in <literal>[.</literal> and "
"<literal>.]</literal> stands for the sequence of characters of that "
"collating element. The sequence is treated as a single element of the "
"bracket expression's list. This allows a bracket expression containing a "
"multiple-character collating element to match more than one character, e.g., "
"if the collating sequence includes a <literal>ch</literal> collating "
"element, then the RE <literal>[[.ch.]]*c</literal> matches the first five "
"characters of <literal>chchcc</literal>."
msgstr ""
"Выражения в квадратных скобках могут содержать элемент сортировки (символ "
"или последовательность символов или имя такой последовательности), "
"определение которого заключается между <literal>[.</literal> и <literal>.]</"
"literal>. Определяющая его последовательность воспринимается в выражении в "
"скобках как один элемент. Это позволяет включать в такие выражения элементы, "
"соответствующие последовательности нескольких символов. Например, с "
"элементом сортировки <literal>ch</literal> в квадратных скобках регулярному "
"выражению <literal>[[.ch.]]*c</literal> будут соответствовать первые пять "
"символов строки <literal>chchcc</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4856(para)
msgid ""
"<productname>PostgreSQL</productname> currently does not support multi-"
"character collating elements. This information describes possible future "
"behavior."
msgstr ""
"В настоящее время <productname>PostgreSQL</productname> не поддерживает "
"элементы сортировки, состоящие из нескольких символов. Эта информация "
"относится к возможному в будущем поведению."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4862(para)
msgid ""
"Within a bracket expression, a collating element enclosed in <literal>[=</"
"literal> and <literal>=]</literal> is an <firstterm>equivalence class</"
"firstterm>, standing for the sequences of characters of all collating "
"elements equivalent to that one, including itself. (If there are no other "
"equivalent collating elements, the treatment is as if the enclosing "
"delimiters were <literal>[.</literal> and <literal>.]</literal>.) For "
"example, if <literal>o</literal> and <literal>^</literal> are the members of "
"an equivalence class, then <literal>[[=o=]]</literal>, <literal>[[=^=]]</"
"literal>, and <literal>[o^]</literal> are all synonymous. An equivalence "
"class cannot be an endpoint of a range."
msgstr ""
"В квадратных скобках могут содержаться элементы сортировки, заключённые "
"между <literal>[=</literal> и <literal>=]</literal>, обозначающие "
"<firstterm>классы эквивалентности</firstterm>, т. е. последовательности "
"символов из всех элементов сортировки, эквивалентных указанному, включая его "
"самого. (Если для этого символа нет эквивалентных, он обрабатывается, как "
"заключённый между <literal>[.</literal> и <literal>.]</literal>.) Например, "
"если <literal>е</literal> и <literal>ё</literal> &mdash; члены одного класса "
"эквивалентности, выражения <literal>[[=е=]]</literal>, <literal>[[=ё=]]</"
"literal> и <literal>[её]</literal> будут равнозначными. Класс "
"эквивалентности нельзя указать в качестве границы интервала."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4876(para)
msgid ""
"Within a bracket expression, the name of a character class enclosed in "
"<literal>[:</literal> and <literal>:]</literal> stands for the list of all "
"characters belonging to that class. Standard character class names are: "
"<literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</"
"literal>, <literal>cntrl</literal>, <literal>digit</literal>, "
"<literal>graph</literal>, <literal>lower</literal>, <literal>print</"
"literal>, <literal>punct</literal>, <literal>space</literal>, "
"<literal>upper</literal>, <literal>xdigit</literal>. These stand for the "
"character classes defined in <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>. A locale can provide "
"others. A character class cannot be used as an endpoint of a range."
msgstr ""
"В квадратных скобках может также содержаться имя класса символов, "
"заключённое между <literal>[:</literal> и <literal>:]</literal>, и "
"заменяющее список всех символов этого класса. Стандартные имена классов: "
"<literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</"
"literal>, <literal>cntrl</literal>, <literal>digit</literal>, "
"<literal>graph</literal>, <literal>lower</literal>, <literal>print</"
"literal>, <literal>punct</literal>, <literal>space</literal>, "
"<literal>upper</literal> и <literal>xdigit</literal>. Весь этот набор "
"классов определён в <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> и он может меняться в "
"зависимости от локали (языковой среды). Класс символов также нельзя "
"использовать в качестве границы интервала."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4893(para)
msgid ""
"There are two special cases of bracket expressions: the bracket expressions "
"<literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> are "
"constraints, matching empty strings at the beginning and end of a word "
"respectively. A word is defined as a sequence of word characters that is "
"neither preceded nor followed by word characters. A word character is an "
"<literal>alnum</literal> character (as defined by "
"<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>) or an underscore. This is an extension, compatible with but "
"not specified by <acronym>POSIX</acronym> 1003.2, and should be used with "
"caution in software intended to be portable to other systems. The constraint "
"escapes described below are usually preferable; they are no more standard, "
"but are easier to type."
msgstr ""
"Есть два особых вида выражений в квадратных скобках: выражения <literal>[[:"
"&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, представляющие собой "
"ограничения, соответствующие пустым строкам в начале и конце слова. Слово в "
"данном контексте определяется как последовательность словосоставляющих "
"символов, перед или после которой нет словосоставляющих символов. "
"Словосоставляющий символ &mdash; это символ класса <literal>alnum</literal> "
"(определённого в <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>) или подчёркивание. "
"Это расширение совместимо со стандартом <acronym>POSIX</acronym> 1003.2, но "
"не описано в нём, и поэтому его следует использовать с осторожностью там, "
"где важна совместимость с другими системами. Обычно лучше использовать "
"ограничивающие спецсимволы, описанные ниже; они также не совсем стандартны, "
"но набрать их легче."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4912(title)
msgid "Regular Expression Escapes"
msgstr "Спецсимволы регулярных выражений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4914(para)
msgid ""
"<firstterm>Escapes</firstterm> are special sequences beginning with <literal>"
"\\</literal> followed by an alphanumeric character. Escapes come in several "
"varieties: character entry, class shorthands, constraint escapes, and back "
"references. A <literal>\\</literal> followed by an alphanumeric character "
"but not constituting a valid escape is illegal in AREs. In EREs, there are "
"no escapes: outside a bracket expression, a <literal>\\</literal> followed "
"by an alphanumeric character merely stands for that character as an ordinary "
"character, and inside a bracket expression, <literal>\\</literal> is an "
"ordinary character. (The latter is the one actual incompatibility between "
"EREs and AREs.)"
msgstr ""
"<firstterm>Спецсимволы</firstterm> &mdash; это специальные команды, "
"состоящие из <literal>\\</literal> и последующего алфавитно-цифрового "
"символа. Можно выделить следующие категории спецсимволов: обозначения "
"символов, коды классов, ограничения и ссылки назад. Символ <literal>\\</"
"literal>, за которым идёт алфавитно-цифровой символ, не образующий "
"допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет: "
"вне квадратных скобок пара из <literal>\\</literal> и последующего алфавитно-"
"цифрового символа, воспринимается просто как данный символ, а в квадратных "
"скобках и сам символ <literal>\\</literal> воспринимается просто как "
"обратная косая черта. (Последнее на самом деле нарушает совместимость между "
"ERE и ARE.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4927(para)
msgid ""
"<firstterm>Character-entry escapes</firstterm> exist to make it easier to "
"specify non-printing and other inconvenient characters in REs. They are "
"shown in <xref linkend=\"posix-character-entry-escapes-table\"/>."
msgstr ""
"<firstterm>Спецобозначения символов</firstterm> введены для того, чтобы "
"облегчить ввод в RE непечатаемых и других неудобных символов. Они приведены "
"в <xref remap=\"6\" linkend=\"posix-character-entry-escapes-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4933(para)
msgid ""
"<firstterm>Class-shorthand escapes</firstterm> provide shorthands for "
"certain commonly-used character classes. They are shown in <xref linkend="
"\"posix-class-shorthand-escapes-table\"/>."
msgstr ""
"<firstterm>Коды классов</firstterm> представляют собой краткий способ записи "
"имён некоторых распространённых классов символов. Они перечислены в <xref "
"remap=\"6\" linkend=\"posix-class-shorthand-escapes-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4939(para)
msgid ""
"A <firstterm>constraint escape</firstterm> is a constraint, matching the "
"empty string if specific conditions are met, written as an escape. They are "
"shown in <xref linkend=\"posix-constraint-escapes-table\"/>."
msgstr ""
"<firstterm>Спецсимволы ограничений</firstterm> обозначают ограничения, "
"которым при совпадении определённых условий соответствует пустая строка. Они "
"перечислены в <xref remap=\"6\" linkend=\"posix-constraint-escapes-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4946(para)
msgid ""
"A <firstterm>back reference</firstterm> (<literal>\\</"
"literal><replaceable>n</replaceable>) matches the same string matched by the "
"previous parenthesized subexpression specified by the number <replaceable>n</"
"replaceable> (see <xref linkend=\"posix-constraint-backref-table\"/>). For "
"example, <literal>([bc])\\1</literal> matches <literal>bb</literal> or "
"<literal>cc</literal> but not <literal>bc</literal> or <literal>cb</"
"literal>. The subexpression must entirely precede the back reference in the "
"RE. Subexpressions are numbered in the order of their leading parentheses. "
"Non-capturing parentheses do not define subexpressions."
msgstr ""
"<firstterm>Ссылка назад</firstterm> (<literal>\\</literal><replaceable>n</"
"replaceable>) соответствует той же строке, какой соответствовало предыдущее "
"подвыражение в скобках под номером <replaceable>n</replaceable> (см. <xref "
"remap=\"4\" linkend=\"posix-constraint-backref-table\"/>). Например, "
"<literal>([bc])\\1</literal> соответствует <literal>bb</literal> или "
"<literal>cc</literal>, но не <literal>bc</literal> или <literal>cb</"
"literal>. Это подвыражение должно полностью предшествовать ссылке назад в "
"RE. Нумеруются подвыражения в порядке следования их открывающих скобок. При "
"этом скобки без захвата исключаются из рассмотрения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4959(title)
msgid "Regular Expression Character-entry Escapes"
msgstr "Спецобозначения символов в регулярных выражениях"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4964(entry) func.xml:5105(entry) func.xml:5162(entry)
#: func.xml:5218(entry)
msgid "Escape"
msgstr "Спецсимвол"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4971(literal)
msgid "\\a"
msgstr "\\a"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4972(entry)
msgid "alert (bell) character, as in C"
msgstr "символ звонка, как в C"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4976(literal)
msgid "\\b"
msgstr "\\b"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4977(entry)
msgid "backspace, as in C"
msgstr "символ &laquo;забой&raquo;, как в C"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4981(literal)
msgid "\\B"
msgstr "\\B"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4982(entry)
msgid ""
"synonym for backslash (<literal>\\</literal>) to help reduce the need for "
"backslash doubling"
msgstr ""
"синоним для обратной косой черты (<literal>\\</literal>), сокращающий "
"потребность в дублировании этого символа"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4987(literal)
msgid "\\c"
msgstr "\\c"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4987(replaceable) func.xml:13716(replaceable)
#: func.xml:13737(replaceable) func.xml:13758(replaceable)
#: func.xml:13775(replaceable) func.xml:13793(replaceable)
#: func.xml:13811(replaceable) func.xml:13831(replaceable)
#: func.xml:13851(replaceable) func.xml:13871(replaceable)
#: func.xml:13890(replaceable) func.xml:13911(replaceable)
#: func.xml:13935(replaceable)
msgid "X"
msgstr "X"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4988(entry)
msgid ""
"(where <replaceable>X</replaceable> is any character) the character whose "
"low-order 5 bits are the same as those of <replaceable>X</replaceable>, and "
"whose other bits are all zero"
msgstr ""
"(где <replaceable>X</replaceable> &mdash; любой символ) символ, младшие 5 "
"бит которого те же, что и у <replaceable>X</replaceable>, а остальные равны 0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4994(literal)
msgid "\\e"
msgstr "\\e"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:4995(entry)
msgid ""
"the character whose collating-sequence name is <literal>ESC</literal>, or "
"failing that, the character with octal value <literal>033</literal>"
msgstr ""
"символ, определённый в последовательности сортировки с именем <literal>ESC</"
"literal>, либо, если таковой не определён, символ с восьмеричным значением "
"<literal>033</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5001(literal)
msgid "\\f"
msgstr "\\f"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5002(entry)
msgid "form feed, as in C"
msgstr "подача формы, как в C"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5006(literal)
msgid "\\n"
msgstr "\\n"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5007(entry)
msgid "newline, as in C"
msgstr "новая строка, как в C"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5011(literal)
msgid "\\r"
msgstr "\\r"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5012(entry)
msgid "carriage return, as in C"
msgstr "возврат каретки, как в C"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5016(literal)
msgid "\\t"
msgstr "\\t"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5017(entry)
msgid "horizontal tab, as in C"
msgstr "горизонтальная табуляция, как в C"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5021(literal)
msgid "\\u"
msgstr "\\u"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5021(replaceable)
msgid "wxyz"
msgstr "wxyz"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5022(entry)
msgid ""
"(where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits) "
"the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>wxyz</replaceable>"
msgstr ""
"(где <replaceable>wxyz</replaceable> ровно четыре шестнадцатеричные цифры) "
"символ с шестнадцатеричным кодом <literal>0x</literal><replaceable>wxyz</"
"replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5029(literal)
msgid "\\U"
msgstr "\\U"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5029(replaceable)
msgid "stuvwxyz"
msgstr "stuvwxyz"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5030(entry)
msgid ""
"(where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal "
"digits) the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>stuvwxyz</replaceable>"
msgstr ""
"(где <replaceable>stuvwxyz</replaceable> ровно восемь шестнадцатеричных "
"цифр) символ с шестнадцатеричным кодом <literal>0x</"
"literal><replaceable>stuvwxyz</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5038(literal)
msgid "\\v"
msgstr "\\v"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5039(entry)
msgid "vertical tab, as in C"
msgstr "вертикальная табуляция, как в C"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5043(literal)
msgid "\\x"
msgstr "\\x"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5043(replaceable)
msgid "hhh"
msgstr "hhh"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5044(entry)
msgid ""
"(where <replaceable>hhh</replaceable> is any sequence of hexadecimal digits) "
"the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>hhh</replaceable> (a single character no matter how "
"many hexadecimal digits are used)"
msgstr ""
"(где <replaceable>hhh</replaceable> &mdash; несколько шестнадцатеричных "
"цифр) символ с шестнадцатеричным кодом <literal>0x</"
"literal><replaceable>hhh</replaceable> (символ всегда один вне зависимости "
"от числа шестнадцатеричных цифр)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5053(literal)
msgid "\\0"
msgstr "\\0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5054(entry)
msgid "the character whose value is <literal>0</literal> (the null byte)"
msgstr "символ с кодом <literal>0</literal> (нулевой байт)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5058(replaceable)
msgid "xy"
msgstr "xy"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5059(entry)
msgid ""
"(where <replaceable>xy</replaceable> is exactly two octal digits, and is not "
"a <firstterm>back reference</firstterm>) the character whose octal value is "
"<literal>0</literal><replaceable>xy</replaceable>"
msgstr ""
"(где <replaceable>xy</replaceable> &mdash; ровно две восьмеричных цифры, не "
"<firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</"
"literal><replaceable>xy</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5066(replaceable)
msgid "xyz"
msgstr "xyz"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5067(entry)
msgid ""
"(where <replaceable>xyz</replaceable> is exactly three octal digits, and is "
"not a <firstterm>back reference</firstterm>) the character whose octal value "
"is <literal>0</literal><replaceable>xyz</replaceable>"
msgstr ""
"(где <replaceable>xyz</replaceable> &mdash; ровно три восьмеричных цифры, не "
"<firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</"
"literal><replaceable>xyz</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5076(para)
msgid ""
"Hexadecimal digits are <literal>0</literal>-<literal>9</literal>, "
"<literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-"
"<literal>F</literal>. Octal digits are <literal>0</literal>-<literal>7</"
"literal>."
msgstr ""
"Шестнадцатеричные цифры записываются символами <literal>0</literal>-"
"<literal>9</literal> и <literal>a</literal>-<literal>f</literal> или "
"<literal>A</literal>-<literal>F</literal>. Восьмеричные цифры &mdash; цифры "
"от <literal>0</literal> до <literal>7</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5082(para)
msgid ""
"Numeric character-entry escapes specifying values outside the ASCII range "
"(0-127) have meanings dependent on the database encoding. When the encoding "
"is UTF-8, escape values are equivalent to Unicode code points, for example "
"<literal>\\u1234</literal> means the character <literal>U+1234</literal>. "
"For other multibyte encodings, character-entry escapes usually just specify "
"the concatenation of the byte values for the character. If the escape value "
"does not correspond to any legal character in the database encoding, no "
"error will be raised, but it will never match any data."
msgstr ""
"Спецпоследовательности с числовыми кодами, задающими значения вне диапазона "
"ASCII (0-127), воспринимаются по-разному в зависимости от кодировки базы "
"данных. Когда база данных имеет кодировку UTF-8, спецкод равнозначен позиции "
"символа в Unicode, например, <literal>\\u1234</literal> обозначает символ "
"<literal>U+1234</literal>. Для других многобайтных кодировок "
"спецпоследовательности обычно просто задают серию байт, определяющих символ. "
"Если в кодировке базы данных отсутствует символ, заданный "
"спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей "
"соответствовать."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5093(para)
msgid ""
"The character-entry escapes are always taken as ordinary characters. For "
"example, <literal>\\135</literal> is <literal>]</literal> in ASCII, but "
"<literal>\\135</literal> does not terminate a bracket expression."
msgstr ""
"Символы, переданные спецобозначением, всегда воспринимаются как обычные "
"символы. Например, <literal>\\135</literal> кодирует <literal>]</literal> в "
"ASCII, но спецпоследовательность <literal>\\135</literal> не будет закрывать "
"выражение в квадратных скобках."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5100(title)
msgid "Regular Expression Class-shorthand Escapes"
msgstr "Спецкоды классов в регулярных выражениях"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5112(literal)
msgid "\\d"
msgstr "\\d"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5113(literal)
msgid "[[:digit:]]"
msgstr "[[:digit:]]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5117(literal)
msgid "\\s"
msgstr "\\s"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5118(literal)
msgid "[[:space:]]"
msgstr "[[:space:]]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5122(literal)
msgid "\\w"
msgstr "\\w"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5123(entry)
msgid "<literal>[[:alnum:]_]</literal> (note underscore is included)"
msgstr "<literal>[[:alnum:]_]</literal> (подчёркивание также включается)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5128(literal)
msgid "\\D"
msgstr "\\D"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5129(literal)
msgid "[^[:digit:]]"
msgstr "[^[:digit:]]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5133(literal)
msgid "\\S"
msgstr "\\S"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5134(literal)
msgid "[^[:space:]]"
msgstr "[^[:space:]]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5138(literal)
msgid "\\W"
msgstr "\\W"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5139(entry)
msgid "<literal>[^[:alnum:]_]</literal> (note underscore is included)"
msgstr "<literal>[^[:alnum:]_]</literal> (подчёркивание также включается)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5146(para)
msgid ""
"Within bracket expressions, <literal>\\d</literal>, <literal>\\s</literal>, "
"and <literal>\\w</literal> lose their outer brackets, and <literal>\\D</"
"literal>, <literal>\\S</literal>, and <literal>\\W</literal> are illegal. "
"(So, for example, <literal>[a-c\\d]</literal> is equivalent to <literal>[a-"
"c[:digit:]]</literal>. Also, <literal>[a-c\\D]</literal>, which is "
"equivalent to <literal>[a-c^[:digit:]]</literal>, is illegal.)"
msgstr ""
"В выражениях в квадратных скобках спецсимволы <literal>\\d</literal>, "
"<literal>\\s</literal> и <literal>\\w</literal> теряют свои внешние "
"квадратные скобки, а <literal>\\D</literal>, <literal>\\S</literal> и "
"<literal>\\W</literal> &mdash; недопустимы. (Так что, например запись "
"<literal>[a-c\\d]</literal> равнозначна <literal>[a-c[:digit:]]</literal>. А "
"запись <literal>[a-c\\D]</literal>, которая была бы равнозначна <literal>[a-"
"c^[:digit:]]</literal>, &mdash; недопустима.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5157(title)
msgid "Regular Expression Constraint Escapes"
msgstr "Спецсимволы ограничений в регулярных выражений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5169(literal)
msgid "\\A"
msgstr "\\A"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5170(entry)
msgid ""
"matches only at the beginning of the string (see <xref linkend=\"posix-"
"matching-rules\"/> for how this differs from <literal>^</literal>)"
msgstr ""
"соответствует только началу строки (чем это отличается от <literal>^</"
"literal>, описано в <xref remap=\"6\" linkend=\"posix-matching-rules\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5176(literal)
msgid "\\m"
msgstr "\\m"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5177(entry)
msgid "matches only at the beginning of a word"
msgstr "соответствует только началу слова"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5181(literal)
msgid "\\M"
msgstr "\\M"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5182(entry)
msgid "matches only at the end of a word"
msgstr "соответствует только концу слова"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5186(literal)
msgid "\\y"
msgstr "\\y"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5187(entry)
msgid "matches only at the beginning or end of a word"
msgstr "соответствует только началу или концу слова"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5191(literal)
msgid "\\Y"
msgstr "\\Y"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5192(entry)
msgid "matches only at a point that is not the beginning or end of a word"
msgstr "соответствует только положению не в начале и не в конце слова"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5197(literal)
msgid "\\Z"
msgstr "\\Z"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5198(entry)
msgid ""
"matches only at the end of the string (see <xref linkend=\"posix-matching-"
"rules\"/> for how this differs from <literal>$</literal>)"
msgstr ""
"соответствует только концу строки (чем это отличается от <literal>$</"
"literal>, описано в <xref remap=\"6\" linkend=\"posix-matching-rules\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5206(para)
msgid ""
"A word is defined as in the specification of <literal>[[:&lt;:]]</literal> "
"and <literal>[[:&gt;:]]</literal> above. Constraint escapes are illegal "
"within bracket expressions."
msgstr ""
"Определением слова здесь служит то же, что было приведено выше в описании "
"<literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>. В квадратных "
"скобках спецсимволы ограничений не допускаются."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5213(title)
msgid "Regular Expression Back References"
msgstr "Ссылки назад в регулярных выражениях"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5226(entry)
msgid ""
"(where <replaceable>m</replaceable> is a nonzero digit) a back reference to "
"the <replaceable>m</replaceable>'th subexpression"
msgstr ""
"(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0) &mdash; "
"ссылка назад на подвыражение под номером <replaceable>m</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5231(replaceable)
msgid "mnn"
msgstr "mnn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5232(entry)
msgid ""
"(where <replaceable>m</replaceable> is a nonzero digit, and <replaceable>nn</"
"replaceable> is some more digits, and the decimal value <replaceable>mnn</"
"replaceable> is not greater than the number of closing capturing parentheses "
"seen so far) a back reference to the <replaceable>mnn</replaceable>'th "
"subexpression"
msgstr ""
"(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0, а "
"<replaceable>nn</replaceable> &mdash; ещё несколько цифр с десятичным "
"значением <replaceable>mnn</replaceable>, не превышающим число закрытых до "
"этого скобок с захватом) ссылка назад на подвыражение под номером "
"<replaceable>mnn</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5243(para)
msgid ""
"There is an inherent ambiguity between octal character-entry escapes and "
"back references, which is resolved by the following heuristics, as hinted at "
"above. A leading zero always indicates an octal escape. A single non-zero "
"digit, not followed by another digit, is always taken as a back reference. A "
"multi-digit sequence not starting with a zero is taken as a back reference "
"if it comes after a suitable subexpression (i.e., the number is in the legal "
"range for a back reference), and otherwise is taken as octal."
msgstr ""
"Регулярным выражениям присуща неоднозначность между восьмеричными кодами "
"символов и ссылками назад, которая разрешается следующим образом (это "
"упоминалось выше). Ведущий ноль всегда считается признаком восьмеричной "
"последовательности. Единственная цифра, отличная от 0, за которой не следует "
"ещё одна цифра, всегда воспринимается как ссылка назад. Последовательность "
"из нескольких цифр, которая начинается не с 0, воспринимается как ссылка "
"назад, если она идёт за подходящим подвыражением (т. е. число оказывается в "
"диапазоне, допустимом для ссылки назад), в противном случае она "
"воспринимается как восьмеричное число."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5259(title)
msgid "Regular Expression Metasyntax"
msgstr "Метасинтаксис регулярных выражений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5261(para)
msgid ""
"In addition to the main syntax described above, there are some special forms "
"and miscellaneous syntactic facilities available."
msgstr ""
"В дополнение к основному синтаксису, описанному выше, можно использовать "
"также несколько особых форм и разнообразные синтаксические удобства."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5266(para)
msgid ""
"An RE can begin with one of two special <firstterm>director</firstterm> "
"prefixes. If an RE begins with <literal>***:</literal>, the rest of the RE "
"is taken as an ARE. (This normally has no effect in <productname>PostgreSQL</"
"productname>, since REs are assumed to be AREs; but it does have an effect "
"if ERE or BRE mode had been specified by the <replaceable>flags</"
"replaceable> parameter to a regex function.) If an RE begins with "
"<literal>***=</literal>, the rest of the RE is taken to be a literal string, "
"with all characters considered ordinary characters."
msgstr ""
"Регулярное выражение может начинаться с одного из двух специальных префиксов "
"режима. Если RE начинается с <literal>***:</literal>, его продолжение "
"рассматривается как ARE. (В <productname>PostgreSQL</productname> это обычно "
"не имеет значения, так как регулярные выражения воспринимаются как ARE по "
"умолчанию; но это может быть полезно, когда параметр <replaceable>флаги</"
"replaceable> функций regex включает режим ERE или BRE.) Если RE начинается с "
"<literal>***=</literal>, его продолжение воспринимается как обычная "
"текстовая строка, все его символы воспринимаются буквально."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5278(para)
msgid ""
"An ARE can begin with <firstterm>embedded options</firstterm>: a sequence "
"<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal> "
"(where <replaceable>xyz</replaceable> is one or more alphabetic characters) "
"specifies options affecting the rest of the RE. These options override any "
"previously determined options &mdash; in particular, they can override the "
"case-sensitivity behavior implied by a regex operator, or the "
"<replaceable>flags</replaceable> parameter to a regex function. The "
"available option letters are shown in <xref linkend=\"posix-embedded-options-"
"table\"/>. Note that these same option letters are used in the "
"<replaceable>flags</replaceable> parameters of regex functions."
msgstr ""
"ARE может начинаться со <firstterm>встроенных параметров</firstterm>: "
"последовательности <literal>(?</literal><replaceable>xyz</"
"replaceable><literal>)</literal> (где <replaceable>xyz</replaceable> &mdash; "
"один или несколько алфавитно-цифровых символов), определяющих параметры "
"остального регулярного выражения. Эти параметры переопределяют любые ранее "
"определённые параметры, в частности они могут переопределить режим "
"чувствительности к регистру, подразумеваемый для оператора regex, или "
"параметр <replaceable>флаги</replaceable> функции regex. Допустимые буквы "
"параметров показаны в <xref remap=\"6\" linkend=\"posix-embedded-options-"
"table\"/>. Заметьте, что те же буквы используются в параметре "
"<replaceable>флаги</replaceable> функций regex."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5294(title)
msgid "ARE Embedded-option Letters"
msgstr "Буквы встроенных параметров ARE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5299(entry)
msgid "Option"
msgstr "Параметр"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5306(literal)
msgctxt "literal"
msgid "b"
msgstr "b"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5307(entry)
msgid "rest of RE is a BRE"
msgstr "продолжение регулярного выражения &mdash; BRE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5311(literal)
msgctxt "literal"
msgid "c"
msgstr "c"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5312(entry)
msgid "case-sensitive matching (overrides operator type)"
msgstr "поиск соответствий с учётом регистра (переопределяет тип оператора)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5316(literal)
msgid "e"
msgstr "e"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5317(entry)
msgid "rest of RE is an ERE"
msgstr "продолжение RE &mdash; ERE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5321(literal)
msgid "i"
msgstr "i"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5322(entry)
msgid ""
"case-insensitive matching (see <xref linkend=\"posix-matching-rules\"/>) "
"(overrides operator type)"
msgstr ""
"поиск соответствий без учёта регистра (см. <xref remap=\"4\" linkend=\"posix-"
"matching-rules\"/>) (переопределяет тип оператора)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5327(literal)
msgctxt "literal"
msgid "m"
msgstr "m"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5328(entry)
msgid "historical synonym for <literal>n</literal>"
msgstr "исторически сложившийся синоним <literal>n</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5332(literal)
msgctxt "literal"
msgid "n"
msgstr "n"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5333(entry)
msgid ""
"newline-sensitive matching (see <xref linkend=\"posix-matching-rules\"/>)"
msgstr ""
"поиск соответствий с учётом перевода строк (см. <xref remap=\"4\" linkend="
"\"posix-matching-rules\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5338(literal)
msgid "p"
msgstr "p"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5339(entry)
msgid ""
"partial newline-sensitive matching (see <xref linkend=\"posix-matching-rules"
"\"/>)"
msgstr ""
"переводы строк учитываются частично (см. <xref remap=\"4\" linkend=\"posix-"
"matching-rules\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5344(literal)
msgid "q"
msgstr "q"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5345(entry)
msgid ""
"rest of RE is a literal (<quote>quoted</quote>) string, all ordinary "
"characters"
msgstr ""
"продолжение регулярного выражения &mdash; обычная строка (<quote>в кавычках</"
"quote>), содержимое которой воспринимается буквально"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5350(literal)
msgctxt "literal"
msgid "s"
msgstr "s"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5351(entry)
msgid "non-newline-sensitive matching (default)"
msgstr "поиск соответствий без учёта перевода строк (по умолчанию)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5355(literal) func.xml:9361(literal) func.xml:9368(literal)
#: func.xml:9417(literal) func.xml:12449(literal) func.xml:12456(literal)
#: func.xml:12463(literal) func.xml:12470(literal) func.xml:12477(literal)
#: func.xml:12484(literal) func.xml:12491(literal) func.xml:12498(literal)
#: func.xml:12505(literal) func.xml:12924(literal) func.xml:12931(literal)
#: func.xml:12938(literal) func.xml:12945(literal) func.xml:12952(literal)
#: func.xml:12959(literal) func.xml:12966(literal) func.xml:12973(literal)
#: func.xml:12980(literal) func.xml:12994(literal) func.xml:13001(literal)
#: func.xml:13008(literal) func.xml:13015(literal) func.xml:13022(literal)
#: func.xml:13029(literal)
msgid "t"
msgstr "t"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5356(entry)
msgid "tight syntax (default; see below)"
msgstr "компактный синтаксис (по умолчанию; см. ниже)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5360(literal)
msgid "w"
msgstr "w"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5361(entry)
msgid ""
"inverse partial newline-sensitive (<quote>weird</quote>) matching (see <xref "
"linkend=\"posix-matching-rules\"/>)"
msgstr ""
"переводы строк учитываются частично, но в другом, <quote>странном</quote> "
"режиме (см. <xref remap=\"4\" linkend=\"posix-matching-rules\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5366(literal)
msgctxt "literal"
msgid "x"
msgstr "x"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5367(entry)
msgid "expanded syntax (see below)"
msgstr "развёрнутый синтаксис (см. ниже)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5373(para)
msgid ""
"Embedded options take effect at the <literal>)</literal> terminating the "
"sequence. They can appear only at the start of an ARE (after the "
"<literal>***:</literal> director if any)."
msgstr ""
"Внедрённые параметры начинают действовать сразу после скобки <literal>)</"
"literal>, завершающей их последовательность. Они могут находиться только в "
"начале ARE (после указания <literal>***:</literal>, если оно присутствует)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5392(para)
msgid ""
"a white-space character or <literal>#</literal> preceded by <literal>\\</"
"literal> is retained"
msgstr ""
"пробельный символ или <literal>#</literal>, за которым следует <literal>\\</"
"literal>, сохраняется"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5398(para)
msgid ""
"white space or <literal>#</literal> within a bracket expression is retained"
msgstr ""
"пробельный символ или <literal>#</literal> внутри выражения в квадратных "
"скобках сохраняется"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5403(para)
msgid ""
"white space and comments cannot appear within multi-character symbols, such "
"as <literal>(?:</literal>"
msgstr ""
"пробельные символы и комментарии не могут присутствовать в составных "
"символах, например, в <literal>(?:</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5379(para)
msgid ""
"In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which "
"all characters are significant, there is an <firstterm>expanded</firstterm> "
"syntax, available by specifying the embedded <literal>x</literal> option. In "
"the expanded syntax, white-space characters in the RE are ignored, as are "
"all characters between a <literal>#</literal> and the following newline (or "
"the end of the RE). This permits paragraphing and commenting a complex RE. "
"There are three exceptions to that basic rule: <placeholder-1/> For this "
"purpose, white-space characters are blank, tab, newline, and any character "
"that belongs to the <replaceable>space</replaceable> character class."
msgstr ""
"Помимо обычного (<firstterm>компактного</firstterm>) синтаксиса RE, в "
"котором имеют значение все символы, поддерживается также "
"<firstterm>развёрнутый</firstterm> синтаксис, включить который можно с "
"помощью встроенного параметра <literal>x</literal>. В развёрнутом синтаксисе "
"игнорируются пробельные символы, а также все символы от <literal>#</literal> "
"до конца строки (или конца RE). Это позволяет разделять RE на строки и "
"добавлять в него комментарии. Но есть три исключения: <placeholder-1/> В "
"данном контексте пробельными символами считаются пробел, табуляция, перевод "
"строки и любой другой символ, относящийся к классу символов "
"<replaceable>space</replaceable>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5414(para)
msgid ""
"Finally, in an ARE, outside bracket expressions, the sequence <literal>(?#</"
"literal><replaceable>ttt</replaceable><literal>)</literal> (where "
"<replaceable>ttt</replaceable> is any text not containing a <literal>)</"
"literal>) is a comment, completely ignored. Again, this is not allowed "
"between the characters of multi-character symbols, like <literal>(?:</"
"literal>. Such comments are more a historical artifact than a useful "
"facility, and their use is deprecated; use the expanded syntax instead."
msgstr ""
"И наконец, в ARE последовательность <literal>(?#</literal><replaceable>ttt</"
"replaceable><literal>)</literal> (где <replaceable>ttt</replaceable> &mdash; "
"любой текст, не содержащий <literal>)</literal>) вне квадратных скобок также "
"считается комментарием и полностью игнорируется. При этом она так же не "
"может находиться внутри составных символов, таких как <literal>(?:</"
"literal>. Эти комментарии в большей степени историческое наследие, чем "
"полезное средство; они считаются устаревшими, а вместо них рекомендуется "
"использовать развёрнутый синтаксис."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5425(para)
msgid ""
"<emphasis>None</emphasis> of these metasyntax extensions is available if an "
"initial <literal>***=</literal> director has specified that the user's input "
"be treated as a literal string rather than as an RE."
msgstr ""
"<emphasis>Ни одно</emphasis> из этих расширений метасинтаксиса не будет "
"работать, если выражение начинается с префикса <literal>***=</literal>, "
"после которого строка воспринимается буквально, а не как RE."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5434(title)
msgid "Regular Expression Matching Rules"
msgstr "Правила соответствия регулярным выражениям"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5436(para)
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string. If the RE "
"could match more than one substring starting at that point, either the "
"longest possible match or the shortest possible match will be taken, "
"depending on whether the RE is <firstterm>greedy</firstterm> or "
"<firstterm>non-greedy</firstterm>."
msgstr ""
"В случае, когда RE может соответствовать более чем одной подстроке в "
"заданной строке, соответствующей RE считается подстрока, которая начинается "
"в ней первой. Если к данной позиции подобных соответствующих подстрок "
"оказывается несколько, из них выбирается либо самая длинная, либо самая "
"короткая из возможных, в зависимости от того, какой режим выбран в RE: "
"<firstterm>жадный</firstterm> или <firstterm>не жадный</firstterm>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5449(para)
msgid ""
"Most atoms, and all constraints, have no greediness attribute (because they "
"cannot match variable amounts of text anyway)."
msgstr ""
"Большинство атомов и все ограничения не имеют признака жадности (так как они "
"всё равно не могут соответствовать подстрокам разного состава)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5455(para)
msgid "Adding parentheses around an RE does not change its greediness."
msgstr "Скобки, окружающие RE, не влияют на его &laquo;жадность&raquo;."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5460(para)
msgid ""
"A quantified atom with a fixed-repetition quantifier (<literal>{</"
"literal><replaceable>m</replaceable><literal>}</literal> or <literal>{</"
"literal><replaceable>m</replaceable><literal>}?</literal>) has the same "
"greediness (possibly none) as the atom itself."
msgstr ""
"Атом с определителем фиксированного количества (<literal>{</"
"literal><replaceable>m</replaceable><literal>}</literal> или <literal>{</"
"literal><replaceable>m</replaceable><literal>}?</literal>) имеет ту же "
"характеристику жадности (или может не иметь её), как и сам атом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5469(para)
msgid ""
"A quantified atom with other normal quantifiers (including <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}</literal> with <replaceable>m</replaceable> equal to "
"<replaceable>n</replaceable>) is greedy (prefers longest match)."
msgstr ""
"Атом с другими обычными определителями количества (включая <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}</literal>, где <replaceable>m</replaceable> равняется "
"<replaceable>n</replaceable>) считается жадным (предпочитает соответствие "
"максимальной длины)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5477(para)
msgid ""
"A quantified atom with a non-greedy quantifier (including <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}?</literal> with <replaceable>m</replaceable> equal to "
"<replaceable>n</replaceable>) is non-greedy (prefers shortest match)."
msgstr ""
"Атом с не жадным определителем количества (включая <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}?</literal>, где <replaceable>m</replaceable> равно "
"<replaceable>n</replaceable>) считается не жадным (предпочитает соответствие "
"минимальной длины)."

#. +> REL9_6_3 REL9_6
#: func.xml:5477(para)
msgid ""
"The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal> can "
"be used to force greediness or non-greediness, respectively, on a "
"subexpression or a whole RE. This is useful when you need the whole RE to "
"have a greediness attribute different from what's deduced from its elements. "
"As an example, suppose that we are trying to separate a string containing "
"some digits into the digits and the parts before and after them. We might "
"try to do that like this: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*)(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput>\n"
"</screen> That didn't work: the first <literal>.*</literal> is greedy so it "
"<quote>eats</quote> as much as it can, leaving the <literal>\\d+</literal> "
"to match at the last possible place, the last digit. We might try to fix "
"that by making it non-greedy: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*?)(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput>\n"
"</screen> That didn't work either, because now the RE as a whole is non-"
"greedy and so it ends the overall match as soon as possible. We can get what "
"we want by forcing the RE as a whole to be greedy: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput>\n"
"</screen> Controlling the RE's overall greediness separately from its "
"components' greediness allows great flexibility in handling variable-length "
"patterns."
msgstr ""
"Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению "
"или всему RE, можно использовать определители <literal>{1,1}</literal> и "
"<literal>{1,1}?</literal>, соответственно. Это полезно, когда вам нужно, "
"чтобы общая характеристика жадности RE отличалась от той, что вытекает из "
"его элементов. Например, предположим, что вы пытаетесь выделить из строки, "
"содержащей несколько цифр, эти цифры и части до и после них. Можно "
"попытаться сделать это так: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*)(\\d+)(.*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput>\n"
"</screen> Но это не будет работать: первая группа <literal>.*</literal> — "
"&laquo;жадная&raquo;, она <quote>съест</quote> всё, что сможет, оставляя для "
"соответствия <literal>\\d+</literal> только последнюю возможность, то есть "
"последнюю цифру. Можно попытаться сделать запрос &laquo;нежадным&raquo;: "
"<screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*?)(\\d+)(.*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput>\n"
"</screen> И это не будет работать, так теперь весь RE в целом стал нежадным, "
"и все соответствия завершаются как можно раньше. Но мы можем получить нужный "
"результат, явно сделав жадным всё RE: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput>\n"
"</screen> Управление общей характеристикой &laquo;жадности&raquo; RE "
"независимо от &laquo;жадности&raquo; его компонентов даёт большую гибкость в "
"описании шаблонов переменной длины."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5485(para)
msgid ""
"A branch &mdash; that is, an RE that has no top-level <literal>|</literal> "
"operator &mdash; has the same greediness as the first quantified atom in it "
"that has a greediness attribute."
msgstr ""
"Ветвь (RE без оператора <literal>|</literal> на верхнем уровне) имеет ту же "
"характеристику жадности, что и первый количественный атом в нём, имеющий "
"атрибут жадности."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5492(para)
msgid ""
"An RE consisting of two or more branches connected by the <literal>|</"
"literal> operator is always greedy."
msgstr ""
"RE, образованное из двух или более ветвей, соединённых оператором <literal>|"
"</literal>, всегда считается жадным."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5445(para)
msgid ""
"Whether an RE is greedy or not is determined by the following rules: "
"<placeholder-1/>"
msgstr ""
"Где жадный или не жадный характер RE определяется по следующим правилам: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5500(para)
msgid ""
"The above rules associate greediness attributes not only with individual "
"quantified atoms, but with branches and entire REs that contain quantified "
"atoms. What that means is that the matching is done in such a way that the "
"branch, or whole RE, matches the longest or shortest possible substring "
"<emphasis>as a whole</emphasis>. Once the length of the entire match is "
"determined, the part of it that matches any particular subexpression is "
"determined on the basis of the greediness attribute of that subexpression, "
"with subexpressions starting earlier in the RE taking priority over ones "
"starting later."
msgstr ""
"Эти правила связывают характеристики жадности не только с отдельными "
"количественными атомами, но и с ветвями и целыми RE, содержащими "
"количественные атомы. Это означает, что при сопоставлении ветвь или целое RE "
"может соответствовать максимально длинной или короткой подстроке <emphasis>в "
"целом</emphasis>. Когда определена длина всего соответствия, часть его, "
"соответствующая конкретному подвыражению, определяется с учётом "
"характеристики жадности для этого подвыражения, при этом подвыражения, "
"начинающиеся в RE раньше, имеют больший приоритет, чем следующие за ними."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5512(para)
msgid ""
"An example of what this means: <screen>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');\n"
"<lineannotation>Result: </lineannotation><computeroutput>123</"
"computeroutput>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');\n"
"<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>\n"
"</screen> In the first case, the RE as a whole is greedy because "
"<literal>Y*</literal> is greedy. It can match beginning at the <literal>Y</"
"literal>, and it matches the longest possible string starting there, i.e., "
"<literal>Y123</literal>. The output is the parenthesized part of that, or "
"<literal>123</literal>. In the second case, the RE as a whole is non-greedy "
"because <literal>Y*?</literal> is non-greedy. It can match beginning at the "
"<literal>Y</literal>, and it matches the shortest possible string starting "
"there, i.e., <literal>Y1</literal>. The subexpression <literal>[0-9]{1,3}</"
"literal> is greedy but it cannot change the decision as to the overall match "
"length; so it is forced to match just <literal>1</literal>."
msgstr ""
"Это иллюстрирует следующий пример: <screen>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>123</"
"computeroutput>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>1</"
"computeroutput>\n"
"</screen> В первом случае, RE в целом жадное, так как жадным является атом "
"<literal>Y*</literal>. Соответствие ему начинается с буквы <literal>Y</"
"literal> и оно включает подстроку максимальной длины с этого места, т. е. "
"подстроку <literal>Y123</literal>. Результат выражения &mdash; её часть, "
"соответствующая подвыражению в скобках, т. е. <literal>123</literal>. Во "
"втором случае, RE в целом наследует не жадный характер от атома <literal>Y*?"
"</literal>. Соответствие ему так же начинается с <literal>Y</literal>, но "
"включает оно подстроку минимальной длины с этого места, т. е. <literal>Y1</"
"literal>. И хотя подвыражение <literal>[0-9]{1,3}</literal> имеет жадный "
"характер, оно не может повлиять на выбор длины соответствия в целом, поэтому "
"ему остаётся только подстрока <literal>1</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5532(para)
msgid ""
"In short, when an RE contains both greedy and non-greedy subexpressions, the "
"total match length is either as long as possible or as short as possible, "
"according to the attribute assigned to the whole RE. The attributes assigned "
"to the subexpressions only affect how much of that match they are allowed to "
"<quote>eat</quote> relative to each other."
msgstr ""
"Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё "
"соответствие будет максимально длинным или коротким в зависимости от "
"характеристики всего RE. Характеристики, связанные с подвыражениями, влияют "
"только на то, какую часть подстроки может <quote>поглотить</quote> одно "
"подвыражение относительно другого."

#. +> REL_10
#: func.xml:5540(para)
msgid ""
"The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal> can "
"be used to force greediness or non-greediness, respectively, on a "
"subexpression or a whole RE. This is useful when you need the whole RE to "
"have a greediness attribute different from what's deduced from its elements. "
"As an example, suppose that we are trying to separate a string containing "
"some digits into the digits and the parts before and after them. We might "
"try to do that like this: <screen>\n"
"SELECT regexp_match('abc01234xyz', '(.*)(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput>\n"
"</screen> That didn't work: the first <literal>.*</literal> is greedy so it "
"<quote>eats</quote> as much as it can, leaving the <literal>\\d+</literal> "
"to match at the last possible place, the last digit. We might try to fix "
"that by making it non-greedy: <screen>\n"
"SELECT regexp_match('abc01234xyz', '(.*?)(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput>\n"
"</screen> That didn't work either, because now the RE as a whole is non-"
"greedy and so it ends the overall match as soon as possible. We can get what "
"we want by forcing the RE as a whole to be greedy: <screen>\n"
"SELECT regexp_match('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput>\n"
"</screen> Controlling the RE's overall greediness separately from its "
"components' greediness allows great flexibility in handling variable-length "
"patterns."
msgstr ""
"Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению "
"или всему RE, можно использовать определители <literal>{1,1}</literal> и "
"<literal>{1,1}?</literal>, соответственно. Это полезно, когда вам нужно, "
"чтобы общая характеристика жадности RE отличалась от той, что вытекает из "
"его элементов. Например, предположим, что вы пытаетесь выделить из строки, "
"содержащей несколько цифр, эти цифры и части до и после них. Можно "
"попытаться сделать это так: <screen>\n"
"SELECT regexp_match('abc01234xyz', '(.*)(\\d+)(.*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput>\n"
"</screen> Но это не будет работать: первая группа <literal>.*</literal> — "
"&laquo;жадная&raquo;, она <quote>съест</quote> всё, что сможет, оставляя для "
"соответствия <literal>\\d+</literal> только последнюю возможность, то есть "
"последнюю цифру. Можно попытаться сделать запрос &laquo;нежадным&raquo;: "
"<screen>\n"
"SELECT regexp_match('abc01234xyz', '(.*?)(\\d+)(.*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput>\n"
"</screen> И это не будет работать, так теперь весь RE в целом стал нежадным, "
"и все соответствия завершаются как можно раньше. Но мы можем получить нужный "
"результат, явно сделав жадным всё RE: <screen>\n"
"SELECT regexp_match('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput>\n"
"</screen> Управление общей характеристикой &laquo;жадности&raquo; RE "
"независимо от &laquo;жадности&raquo; его компонентов даёт большую гибкость в "
"описании шаблонов переменной длины."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5572(para)
msgid ""
"When deciding what is a longer or shorter match, match lengths are measured "
"in characters, not collating elements. An empty string is considered longer "
"than no match at all. For example: <literal>bb*</literal> matches the three "
"middle characters of <literal>abbbc</literal>; <literal>(week|wee)(night|"
"knights)</literal> matches all ten characters of <literal>weeknights</"
"literal>; when <literal>(.*).*</literal> is matched against <literal>abc</"
"literal> the parenthesized subexpression matches all three characters; and "
"when <literal>(a*)*</literal> is matched against <literal>bc</literal> both "
"the whole RE and the parenthesized subexpression match an empty string."
msgstr ""
"При определении более длинного или более короткого соответствия длины "
"соответствий определяются в символах, а не в элементах сортировки. Пустая "
"строка считается длиннее, чем отсутствие соответствия. Например, выражению "
"<literal>bb*</literal> соответствуют три символа в середине строки "
"<literal>abbbc</literal>, выражению <literal>(week|wee)(night|knights)</"
"literal> &mdash; все десять символов <literal>weeknights</literal>; когда "
"выражение <literal>(.*).*</literal> сопоставляется со строкой <literal>abc</"
"literal>, подвыражению в скобках соответствуют все три символа; а когда "
"<literal>(a*)*</literal> сопоставляется со строкой <literal>bc</literal>, то "
"и RE в целом, и подстроке в скобках соответствует пустая строка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5589(para)
msgid ""
"If case-independent matching is specified, the effect is much as if all case "
"distinctions had vanished from the alphabet. When an alphabetic that exists "
"in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, e.g., <literal>x</literal> becomes <literal>[xX]</"
"literal>. When it appears inside a bracket expression, all case counterparts "
"of it are added to the bracket expression, e.g., <literal>[x]</literal> "
"becomes <literal>[xX]</literal> and <literal>[^x]</literal> becomes "
"<literal>[^xX]</literal>."
msgstr ""
"Игнорирование регистра символов даёт практически тот же эффект, как если бы "
"в алфавите исчезли различия прописных и строчных букв. Если буква, "
"существующая и в верхнем, и в нижнем регистре, фигурирует вне квадратных "
"скобок как обычный символ, она по сути преобразуется в выражение в "
"квадратных скобках, содержащее оба варианта, например <literal>x</literal> "
"становится <literal>[xX]</literal>. Если же она фигурирует в выражении в "
"квадратных скобках, в это выражение добавляются все её варианты, например "
"<literal>[x]</literal> становится <literal>[xX]</literal>, а <literal>[^x]</"
"literal> &mdash; <literal>[^xX]</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5603(para)
msgid ""
"If newline-sensitive matching is specified, <literal>.</literal> and bracket "
"expressions using <literal>^</literal> will never match the newline "
"character (so that matches will never cross newlines unless the RE "
"explicitly arranges it) and <literal>^</literal> and <literal>$</literal> "
"will match the empty string after and before a newline respectively, in "
"addition to matching at beginning and end of string respectively. But the "
"ARE escapes <literal>\\A</literal> and <literal>\\Z</literal> continue to "
"match beginning or end of string <emphasis>only</emphasis>."
msgstr ""
"Когда включён режим учёта перевода строк, атом <literal>.</literal> и "
"выражения в квадратных скобках с <literal>^</literal> никогда не будут "
"соответствовать символам конца строки (так что соответствия никогда не будут "
"пересекать границы строк, если в RE нет явных указаний на эти символы), а "
"<literal>^</literal> и <literal>$</literal> будут соответствовать пустой "
"подстроке не только в начале и конце всего текста, но и в начале и конце "
"каждой отдельной его строки. Однако спецсимволы ARE <literal>\\A</literal> и "
"<literal>\\Z</literal> по-прежнему будут соответствовать <emphasis>только</"
"emphasis> началу и концу всего текста."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5617(para)
msgid ""
"If partial newline-sensitive matching is specified, this affects <literal>.</"
"literal> and bracket expressions as with newline-sensitive matching, but not "
"<literal>^</literal> and <literal>$</literal>."
msgstr ""
"В режиме, когда переводы строк учитываются частично, особый смысл перевод "
"строк имеет для атома <literal>.</literal> и выражений в квадратных скобках, "
"но не для <literal>^</literal> и <literal>$</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5624(para)
msgid ""
"If inverse partial newline-sensitive matching is specified, this affects "
"<literal>^</literal> and <literal>$</literal> as with newline-sensitive "
"matching, but not <literal>.</literal> and bracket expressions. This isn't "
"very useful but is provided for symmetry."
msgstr ""
"В обратном частичном режиме, перевод строк имеет особый смысл для "
"<literal>^</literal> и <literal>$</literal>, как и в режиме с учётом "
"перевода строк, но не для <literal>.</literal> и выражений в квадратных "
"скобках. Данный режим не очень полезен, но существует для симметрии."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5634(title)
msgid "Limits and Compatibility"
msgstr "Пределы и совместимость"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5636(para)
msgid ""
"No particular limit is imposed on the length of REs in this implementation. "
"However, programs intended to be highly portable should not employ REs "
"longer than 256 bytes, as a POSIX-compliant implementation can refuse to "
"accept such REs."
msgstr ""
"В текущей реализации отсутствует какой-либо явно заданный предел длины RE. "
"Однако, разрабатывая программы высокой степени переносимости, не следует "
"применять RE длиннее 256 байт, так как другая POSIX-совместимая реализация "
"может отказаться обрабатывать такие регулярные выражения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5644(para)
msgid ""
"The only feature of AREs that is actually incompatible with POSIX EREs is "
"that <literal>\\</literal> does not lose its special significance inside "
"bracket expressions. All other ARE features use syntax which is illegal or "
"has undefined or unspecified effects in POSIX EREs; the <literal>***</"
"literal> syntax of directors likewise is outside the POSIX syntax for both "
"BREs and EREs."
msgstr ""
"Единственная особенность ARE, действительно несовместимая с ERE стандарта "
"POSIX проявляется в том, что в ARE знак <literal>\\</literal> не теряет своё "
"специальное значение в квадратных скобках. Все другие расширения ARE "
"используют синтаксические возможности, которые не определены, не допустимы "
"или не поддерживаются в ERE; синтаксис переключения режимов (<literal>***</"
"literal>) также выходит за рамки синтаксиса POSIX как для BRE, так и для ERE."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5654(para)
msgid ""
"Many of the ARE extensions are borrowed from Perl, but some have been "
"changed to clean them up, and a few Perl extensions are not present. "
"Incompatibilities of note include <literal>\\b</literal>, <literal>\\B</"
"literal>, the lack of special treatment for a trailing newline, the addition "
"of complemented bracket expressions to the things affected by newline-"
"sensitive matching, the restrictions on parentheses and back references in "
"lookahead/lookbehind constraints, and the longest/shortest-match (rather "
"than first-match) matching semantics."
msgstr ""
"Многие расширения ARE заимствованы из языка Perl, но некоторые были "
"изменены, оптимизированы, а несколько расширений Perl были исключены. В "
"результате имеют место следующие несовместимости: атомы <literal>\\b</"
"literal> и <literal>\\B</literal>, отсутствие специальной обработки "
"завершающего перевода строки, добавление исключений в квадратных скобках в "
"число случаев, когда учитывается перевод строк, особые условия для скобок и "
"ссылок назад в ограничениях просмотра вперёд/назад и семантика "
"<quote>наиболее длинное/короткое соответствие</quote> (вместо <quote>первое "
"соответствие</quote>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5672(para)
msgid ""
"In AREs, <literal>\\</literal> followed by an alphanumeric character is "
"either an escape or an error, while in previous releases, it was just "
"another way of writing the alphanumeric. This should not be much of a "
"problem because there was no reason to write such a sequence in earlier "
"releases."
msgstr ""
"В ARE <literal>\\</literal> с последующим алфавитно-цифровым символом "
"представляет либо спецсимвол, либо ошибочную последовательность, тогда как в "
"предыдущих версиях так можно было записывать алфавитно-цифровые символы. Это "
"не должно быть большой проблемой, так как раньше не было причин использовать "
"такие последовательности."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5681(para)
msgid ""
"In AREs, <literal>\\</literal> remains a special character within "
"<literal>[]</literal>, so a literal <literal>\\</literal> within a bracket "
"expression must be written <literal>\\\\</literal>."
msgstr ""
"В ARE знак <literal>\\</literal> сохраняет своё специальное значение в "
"<literal>[]</literal>, поэтому, чтобы передать <literal>\\</literal> в "
"квадратных скобках буквально, его нужно записать как <literal>\\\\</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5666(para)
msgid ""
"Two significant incompatibilities exist between AREs and the ERE syntax "
"recognized by pre-7.4 releases of <productname>PostgreSQL</productname>: "
"<placeholder-1/>"
msgstr ""
"Важно отметить две несовместимости синтаксиса ARE и регулярных выражений "
"ERE, которые воспринимал <productname>PostgreSQL</productname> до версии "
"7.4: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5692(title)
msgid "Basic Regular Expressions"
msgstr "Простые регулярные выражения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5694(para)
msgid ""
"BREs differ from EREs in several respects. In BREs, <literal>|</literal>, "
"<literal>+</literal>, and <literal>?</literal> are ordinary characters and "
"there is no equivalent for their functionality. The delimiters for bounds "
"are <literal>\\{</literal> and <literal>\\}</literal>, with <literal>{</"
"literal> and <literal>}</literal> by themselves ordinary characters. The "
"parentheses for nested subexpressions are <literal>\\(</literal> and "
"<literal>\\)</literal>, with <literal>(</literal> and <literal>)</literal> "
"by themselves ordinary characters. <literal>^</literal> is an ordinary "
"character except at the beginning of the RE or the beginning of a "
"parenthesized subexpression, <literal>$</literal> is an ordinary character "
"except at the end of the RE or the end of a parenthesized subexpression, and "
"<literal>*</literal> is an ordinary character if it appears at the beginning "
"of the RE or the beginning of a parenthesized subexpression (after a "
"possible leading <literal>^</literal>). Finally, single-digit back "
"references are available, and <literal>\\&lt;</literal> and <literal>\\&gt;</"
"literal> are synonyms for <literal>[[:&lt;:]]</literal> and <literal>[[:"
"&gt;:]]</literal> respectively; no other escapes are available in BREs."
msgstr ""
"BRE имеют ряд отличий от ERE. В BRE знаки <literal>|</literal>, <literal>+</"
"literal> и <literal>?</literal> теряют специальное значение, а замены им "
"нет. Границы количества окружаются символами <literal>\\{</literal> и "
"<literal>\\}</literal>, тогда как <literal>{</literal> и <literal>}</"
"literal> рассматриваются как обычные символы. Вложенные подвыражения "
"помещаются между <literal>\\(</literal> и <literal>\\)</literal>, а "
"<literal>(</literal> и <literal>)</literal> представляют обычные символы. "
"Символ <literal>^</literal> воспринимается как обычный, если только он не "
"находится в начале RE или подвыражения в скобках, <literal>$</literal> "
"&mdash; тоже обычный символ, если он находится не в конце RE или в конце "
"подвыражения в скобках, и <literal>*</literal> &mdash; обычный символ, когда "
"он находится в начале RE или подвыражения в скобках (возможно, после "
"начального <literal>^</literal>). И, наконец, в BRE работают ссылки назад с "
"одной цифрой, <literal>\\&lt;</literal> и <literal>\\&gt;</literal> &mdash; "
"синонимы для <literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, "
"соответственно; никакие другие спецсимволы в BRE не поддерживаются."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5728(title)
msgid "Data Type Formatting Functions"
msgstr "Функции форматирования данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5730(indexterm)
msgid "<primary>formatting</primary>"
msgstr "<primary>форматирование</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5734(para)
msgid ""
"The <productname>PostgreSQL</productname> formatting functions provide a "
"powerful set of tools for converting various data types (date/time, integer, "
"floating point, numeric) to formatted strings and for converting from "
"formatted strings to specific data types. <xref linkend=\"functions-"
"formatting-table\"/> lists them. These functions all follow a common calling "
"convention: the first argument is the value to be formatted and the second "
"argument is a template that defines the output or input format."
msgstr ""
"Функции форматирования в <productname>PostgreSQL</productname> предоставляют "
"богатый набор инструментов для преобразования самых разных типов данных "
"(дата/время, целое, числа с плавающей и фиксированной точкой) в "
"форматированные строки и обратно. Все они перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-table\"/>. Все эти функции следует одному "
"соглашению: в первом аргументе передаётся значение, которое нужно "
"отформатировать, а во втором &mdash; шаблон, определяющий формат ввода или "
"вывода."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5746(title)
msgid "Formatting Functions"
msgstr "Функции форматирования"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5759(indexterm)
msgid "<primary>to_char</primary>"
msgstr "<primary>to_char</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5762(type) func.xml:6900(type) func.xml:6910(type)
#: func.xml:6982(type) func.xml:7007(type) func.xml:7009(type)
#: func.xml:7031(type) func.xml:7064(type) func.xml:7140(type)
#: func.xml:7232(type)
msgid "timestamp"
msgstr "timestamp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5762(function) func.xml:5769(function) func.xml:5775(function)
#: func.xml:5788(function)
msgid "to_char(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_char(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5765(entry)
msgid "convert time stamp to string"
msgstr "преобразует время в текст"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5766(literal)
msgid "to_char(current_timestamp, 'HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'HH12:MI:SS')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5769(type) func.xml:6902(type) func.xml:6911(type)
#: func.xml:6993(type) func.xml:7017(type) func.xml:7018(type)
#: func.xml:7042(type) func.xml:7072(type) func.xml:7084(type)
#: func.xml:7086(type) func.xml:7097(type) func.xml:7099(type)
#: func.xml:7110(type) func.xml:7112(type) func.xml:7186(type)
#: func.xml:15514(type)
msgid "interval"
msgstr "interval"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5771(entry)
msgid "convert interval to string"
msgstr "преобразует интервал в текст"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5772(literal)
msgid "to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')"
msgstr "to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5777(entry)
msgid "convert integer to string"
msgstr "преобразует целое в текст"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5778(literal)
msgid "to_char(125, '999')"
msgstr "to_char(125, '999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5781(function)
msgid "to_char"
msgstr "to_char"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5781(type) func.xml:6984(type) func.xml:6994(type)
#: func.xml:7033(type) func.xml:7043(type) func.xml:7182(type)
#: func.xml:7204(type) func.xml:7228(type) func.xml:7252(type)
#: func.xml:7332(type) func.xml:8609(type) func.xml:8621(type)
#: func.xml:8627(type) func.xml:8645(type) func.xml:8684(type)
#: func.xml:8690(type) func.xml:8757(type) func.xml:8807(type)
#: func.xml:8808(type) func.xml:13719(type) func.xml:13722(type)
#: func.xml:13740(type) func.xml:13743(type) func.xml:13761(type)
#: func.xml:13764(type) func.xml:13778(type) func.xml:13781(type)
#: func.xml:13796(type) func.xml:13799(type) func.xml:13814(type)
#: func.xml:13834(type) func.xml:13837(type) func.xml:13854(type)
#: func.xml:13857(type) func.xml:13874(type) func.xml:13877(type)
#: func.xml:13893(type) func.xml:13896(type) func.xml:13914(type)
#: func.xml:13917(type) func.xml:13938(type) func.xml:13941(type)
#: func.xml:14157(type) func.xml:14203(type) func.xml:14345(type)
#: func.xml:14368(type) func.xml:14552(type) func.xml:14565(type)
msgid "double precision"
msgstr "double precision"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5781(literal) func.xml:8807(literal) func.xml:12631(literal)
#: func.xml:12642(literal) func.xml:12688(literal) func.xml:12699(literal)
#: func.xml:12723(literal) func.xml:12736(literal) func.xml:12747(literal)
#: func.xml:12782(literal) func.xml:13197(literal) func.xml:16228(literal)
#: func.xml:16260(literal) func.xml:16275(literal) func.xml:16290(literal)
#: func.xml:16305(literal) func.xml:16320(literal) func.xml:16335(literal)
#: func.xml:16350(literal) func.xml:16365(literal) func.xml:16380(literal)
#: func.xml:16395(literal) func.xml:16410(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5784(entry)
msgid "convert real/double precision to string"
msgstr "преобразует плавающее одинарной/двойной точности в текст"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5785(literal)
msgid "to_char(125.8::real, '999D9')"
msgstr "to_char(125.8::real, '999D9')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5790(entry)
msgid "convert numeric to string"
msgstr "преобразует числовое значение в текст"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5791(literal)
msgid "to_char(-125.8, '999D99S')"
msgstr "to_char(-125.8, '999D99S')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5795(indexterm)
msgid "<primary>to_date</primary>"
msgstr "<primary>to_date</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5798(function)
msgid "to_date(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_date(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5800(type) func.xml:6939(type) func.xml:7055(type)
#: func.xml:7161(type)
msgid "date"
msgstr "date"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5801(entry)
msgid "convert string to date"
msgstr "преобразует текст в дату"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5802(literal)
msgid "to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"
msgstr "to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5806(indexterm)
msgid "<primary>to_number</primary>"
msgstr "<primary>to_number</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5809(function)
msgid "to_number(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_number(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5812(entry)
msgid "convert string to numeric"
msgstr "преобразует текст в число"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5813(literal)
msgid "to_number('12,454.8-', '99G999D9S')"
msgstr "to_number('12,454.8-', '99G999D9S')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5817(indexterm) func.xml:7329(indexterm)
msgid "<primary>to_timestamp</primary>"
msgstr "<primary>to_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5820(function)
msgid "to_timestamp(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_timestamp(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5822(type) func.xml:6924(type) func.xml:6969(type)
#: func.xml:7257(type) func.xml:7274(type) func.xml:7289(type)
#: func.xml:7320(type) func.xml:7334(type) func.xml:7989(type)
#: func.xml:7995(type) func.xml:15833(type) func.xml:15870(type)
#: func.xml:17856(type) func.xml:18048(type) func.xml:18089(type)
#: func.xml:18563(type) func.xml:18797(type)
msgid "timestamp with time zone"
msgstr "timestamp with time zone"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5823(entry)
msgid "convert string to time stamp"
msgstr "преобразует строку во время"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5824(literal)
msgid "to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"
msgstr "to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5831(para)
msgid ""
"There is also a single-argument <function>to_timestamp</function> function; "
"see <xref linkend=\"functions-datetime-table\"/>."
msgstr ""
"Также имеется функция <function>to_timestamp</function> с одним аргументом; "
"см. <xref remap=\"4\" linkend=\"functions-datetime-table\"/>."

#. +> REL_10
#: func.xml:5838(para)
msgid ""
"<function>to_timestamp</function> and <function>to_date</function> exist to "
"handle input formats that cannot be converted by simple casting. For most "
"standard date/time formats, simply casting the source string to the required "
"data type works, and is much easier. Similarly, <function>to_number</"
"function> is unnecessary for standard numeric representations."
msgstr ""
"Функции <function>to_timestamp</function> и <function>to_date</function> "
"предназначены для работы с входными форматами, которые нельзя преобразовать "
"простым приведением. Для большинства стандартных форматов даты/времени "
"работает простое приведение исходной строки к требуемому типу и использовать "
"его гораздо легче. Так же и функцию <function>to_number</function> нет "
"необходимости использовать для стандартных представлений чисел."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5848(para)
msgid ""
"In a <function>to_char</function> output template string, there are certain "
"patterns that are recognized and replaced with appropriately-formatted data "
"based on the given value. Any text that is not a template pattern is simply "
"copied verbatim. Similarly, in an input template string (for the other "
"functions), template patterns identify the values to be supplied by the "
"input data string."
msgstr ""
"Шаблон вывода <function>to_char</function> может содержать ряд кодов, "
"которые распознаются при форматировании и заменяются соответствующими "
"данными. Любой текст, который не является кодом, копируется в результат в "
"неизменном виде. Подобным образом, в строке шаблона ввода (для других "
"функций) коды шаблона определяют, какие значения содержит передаваемая "
"текстовая строка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5857(para)
msgid ""
"<xref linkend=\"functions-formatting-datetime-table\"/> shows the template "
"patterns available for formatting date and time values."
msgstr ""
"Все коды форматирования даты и времени перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-datetime-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5863(title)
msgid "Template Patterns for Date/Time Formatting"
msgstr "Коды форматирования даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5867(entry) func.xml:6348(entry)
msgid "Pattern"
msgstr "Код"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5873(literal)
msgid "HH"
msgstr "HH"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5874(entry) func.xml:5878(entry)
msgid "hour of day (01-12)"
msgstr "час (01-12)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5877(literal)
msgid "HH12"
msgstr "HH12"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5881(literal)
msgid "HH24"
msgstr "HH24"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5882(entry)
msgid "hour of day (00-23)"
msgstr "час (00-23)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5885(literal) func.xml:6390(literal)
msgid "MI"
msgstr "MI"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5886(entry)
msgid "minute (00-59)"
msgstr "минута (00-59)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5889(literal)
msgid "SS"
msgstr "SS"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5890(entry)
msgid "second (00-59)"
msgstr "секунда (00-59)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5893(literal)
msgid "MS"
msgstr "MS"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5894(entry)
msgid "millisecond (000-999)"
msgstr "миллисекунда (000-999)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5897(literal)
msgid "US"
msgstr "US"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5898(entry)
msgid "microsecond (000000-999999)"
msgstr "микросекунда (000000-999999)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5901(literal)
msgid "SSSS"
msgstr "SSSS"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5902(entry)
msgid "seconds past midnight (0-86399)"
msgstr "число секунд с начала суток (0-86399)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5905(entry)
msgid ""
"<literal>AM</literal>, <literal>am</literal>, <literal>PM</literal> or "
"<literal>pm</literal>"
msgstr ""
"<literal>AM</literal>, <literal>am</literal>, <literal>PM</literal> или "
"<literal>pm</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5907(entry)
msgid "meridiem indicator (without periods)"
msgstr "обозначение времени до/после полудня (без точек)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5910(entry)
msgid ""
"<literal>A.M.</literal>, <literal>a.m.</literal>, <literal>P.M.</literal> or "
"<literal>p.m.</literal>"
msgstr ""
"<literal>A.M.</literal>, <literal>a.m.</literal>, <literal>P.M.</literal> "
"или <literal>p.m.</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5912(entry)
msgid "meridiem indicator (with periods)"
msgstr "обозначение времени до/после полудня (с точками)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5915(literal)
msgid "Y,YYY"
msgstr "Y,YYY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5916(entry)
msgid "year (4 or more digits) with comma"
msgstr "год (4 или более цифр) с разделителем"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5919(literal)
msgid "YYYY"
msgstr "YYYY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5920(entry)
msgid "year (4 or more digits)"
msgstr "год (4 или более цифр)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5923(literal)
msgid "YYY"
msgstr "YYY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5924(entry)
msgid "last 3 digits of year"
msgstr "последние 3 цифры года"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5927(literal)
msgid "YY"
msgstr "YY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5928(entry)
msgid "last 2 digits of year"
msgstr "последние 2 цифры года"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5931(literal)
msgctxt "literal"
msgid "Y"
msgstr "Y"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5932(entry)
msgid "last digit of year"
msgstr "последняя цифра года"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5935(literal)
msgid "IYYY"
msgstr "IYYY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5936(entry)
msgid "ISO 8601 week-numbering year (4 or more digits)"
msgstr "недельный год по ISO 8601 (4 или более цифр)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5939(literal)
msgid "IYY"
msgstr "IYY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5940(entry)
msgid "last 3 digits of ISO 8601 week-numbering year"
msgstr "последние 3 цифры недельного года по ISO 8601"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5943(literal)
msgid "IY"
msgstr "IY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5944(entry)
msgid "last 2 digits of ISO 8601 week-numbering year"
msgstr "последние 2 цифры недельного года по ISO 8601"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5947(literal)
msgid "I"
msgstr "I"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5948(entry)
msgid "last digit of ISO 8601 week-numbering year"
msgstr "последняя цифра недельного года по ISO 8601"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5951(entry)
msgid ""
"<literal>BC</literal>, <literal>bc</literal>, <literal>AD</literal> or "
"<literal>ad</literal>"
msgstr ""
"<literal>BC</literal>, <literal>bc</literal>, <literal>AD</literal> или "
"<literal>ad</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5953(entry)
msgid "era indicator (without periods)"
msgstr "обозначение эры (без точек)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5956(entry)
msgid ""
"<literal>B.C.</literal>, <literal>b.c.</literal>, <literal>A.D.</literal> or "
"<literal>a.d.</literal>"
msgstr ""
"<literal>B.C.</literal>, <literal>b.c.</literal>, <literal>A.D.</literal> "
"или <literal>a.d.</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5958(entry)
msgid "era indicator (with periods)"
msgstr "обозначение эры (с точками)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5961(literal)
msgid "MONTH"
msgstr "MONTH"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5962(entry)
msgid "full upper case month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца в верхнем регистре (дополненное пробелами до 9 "
"символов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5965(literal)
msgid "Month"
msgstr "Month"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5966(entry)
msgid "full capitalized month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца с большой буквы (дополненное пробелами до 9 символов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5969(literal) func.xml:7726(literal) func.xml:7933(literal)
msgctxt "literal"
msgid "month"
msgstr "month"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5970(entry)
msgid "full lower case month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца в нижнем регистре (дополненное пробелами до 9 "
"символов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5973(literal)
msgid "MON"
msgstr "MON"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5974(entry)
msgid ""
"abbreviated upper case month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца в верхнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5977(literal)
msgid "Mon"
msgstr "Mon"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5978(entry)
msgid ""
"abbreviated capitalized month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца с большой буквы (3 буквы в английском; в других "
"языках длина может меняться)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5981(literal)
msgid "mon"
msgstr "mon"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5982(entry)
msgid ""
"abbreviated lower case month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца в нижнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5985(literal)
msgid "MM"
msgstr "MM"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5986(entry)
msgid "month number (01-12)"
msgstr "номер месяца (01-12)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5989(literal)
msgid "DAY"
msgstr "DAY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5990(entry)
msgid "full upper case day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели в верхнем регистре (дополненное пробелами до 9 "
"символов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5993(literal)
msgid "Day"
msgstr "Day"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5994(entry)
msgid "full capitalized day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели с большой буквы (дополненное пробелами до 9 "
"символов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5997(literal) func.xml:7500(literal) func.xml:7931(literal)
msgctxt "literal"
msgid "day"
msgstr "day"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:5998(entry)
msgid "full lower case day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели в нижнем регистре (дополненное пробелами до 9 "
"символов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6001(literal)
msgid "DY"
msgstr "DY"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6002(entry)
msgid ""
"abbreviated upper case day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели в верхнем регистре (3 буквы в английском; в "
"других языках может меняться)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6005(literal)
msgid "Dy"
msgstr "Dy"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6006(entry)
msgid ""
"abbreviated capitalized day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели с большой буквы (3 буквы в английском; в "
"других языках длина может меняться)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6009(literal)
msgid "dy"
msgstr "dy"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6010(entry)
msgid ""
"abbreviated lower case day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели в нижнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6013(literal)
msgid "DDD"
msgstr "DDD"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6014(entry)
msgid "day of year (001-366)"
msgstr "номер дня в году (001-366)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6017(literal)
msgid "IDDD"
msgstr "IDDD"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6018(entry)
msgid ""
"day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of "
"the first ISO week)"
msgstr ""
"номер дня в году по ISO 8601 (001-371; 1 день &mdash; понедельник первой "
"недели по ISO)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6021(literal)
msgid "DD"
msgstr "DD"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6022(entry)
msgid "day of month (01-31)"
msgstr "день месяца (01-31)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6025(literal) func.xml:6382(literal)
msgid "D"
msgstr "D"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6026(entry)
msgid ""
"day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</"
"literal>)"
msgstr ""
"номер дня недели, считая с воскресенья (<literal>1</literal>) до субботы "
"(<literal>7</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6029(literal)
msgid "ID"
msgstr "ID"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6030(entry)
msgid ""
"ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday "
"(<literal>7</literal>)"
msgstr ""
"номер дня недели по ISO 8601, считая с понедельника (<literal>1</literal>) "
"до воскресенья (<literal>7</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6033(literal)
msgid "W"
msgstr "W"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6034(entry)
msgid ""
"week of month (1-5) (the first week starts on the first day of the month)"
msgstr "неделя месяца (1-5) (первая неделя начинается в первое число месяца)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6037(literal)
msgid "WW"
msgstr "WW"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6038(entry)
msgid ""
"week number of year (1-53) (the first week starts on the first day of the "
"year)"
msgstr ""
"номер недели в году (1-53) (первая неделя начинается в первый день года)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6041(literal)
msgid "IW"
msgstr "IW"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6042(entry)
msgid ""
"week number of ISO 8601 week-numbering year (01-53; the first Thursday of "
"the year is in week 1)"
msgstr ""
"номер недели в году по ISO 8601 (01-53; первый четверг года относится к "
"неделе 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6045(literal)
msgid "CC"
msgstr "CC"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6046(entry)
msgid "century (2 digits) (the twenty-first century starts on 2001-01-01)"
msgstr "век (2 цифры) (двадцать первый век начался 2001-01-01)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6049(literal)
msgid "J"
msgstr "J"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6050(entry)
msgid "Julian Day (integer days since November 24, 4714 BC at midnight UTC)"
msgstr "День по юлианскому календарю (номер дня с 24 ноября 4714 г. до н. э.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6053(literal)
msgid "Q"
msgstr "Q"

#. +> REL_10
#: func.xml:6054(entry)
msgctxt "entry"
msgid "quarter"
msgstr "квартал"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6057(literal)
msgid "RM"
msgstr "RM"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6058(entry)
msgid "month in upper case Roman numerals (I-XII; I=January)"
msgstr "номер месяца римскими цифрами в верхнем регистре (I-XII; I=январь)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6061(literal)
msgid "rm"
msgstr "rm"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6062(entry)
msgid "month in lower case Roman numerals (i-xii; i=January)"
msgstr "номер месяца римскими цифрами в нижнем регистре (i-xii; i=январь)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6065(literal)
msgid "TZ"
msgstr "TZ"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6066(entry)
msgid ""
"upper case time-zone abbreviation (only supported in <function>to_char</"
"function>)"
msgstr ""
"сокращённое название часового пояса в верхнем регистре (поддерживается "
"только в <function>to_char</function>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6070(literal)
msgid "tz"
msgstr "tz"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6071(entry)
msgid ""
"lower case time-zone abbreviation (only supported in <function>to_char</"
"function>)"
msgstr ""
"сокращённое название часового пояса в нижнем регистре (поддерживается только "
"в <function>to_char</function>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6075(literal)
msgid "OF"
msgstr "OF"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6076(entry)
msgid ""
"time-zone offset from UTC (only supported in <function>to_char</function>)"
msgstr ""
"смещение часового пояса от UTC (поддерживается только в <function>to_char</"
"function>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6083(para)
msgid ""
"Modifiers can be applied to any template pattern to alter its behavior. For "
"example, <literal>FMMonth</literal> is the <literal>Month</literal> pattern "
"with the <literal>FM</literal> modifier. <xref linkend=\"functions-"
"formatting-datetimemod-table\"/> shows the modifier patterns for date/time "
"formatting."
msgstr ""
"К любым кодам форматирования можно добавить модификаторы, изменяющие их "
"поведение. Например, шаблон форматирования <literal>FMMonth</literal> "
"включает код <literal>Month</literal> с модификатором <literal>FM</literal>. "
"Модификаторы, предназначенные для форматирования даты/времени, перечислены в "
"<xref remap=\"6\" linkend=\"functions-formatting-datetimemod-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6093(title)
msgid "Template Pattern Modifiers for Date/Time Formatting"
msgstr "Модификаторы кодов для форматирования даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6097(entry) func.xml:6527(entry)
msgid "Modifier"
msgstr "Модификатор"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6104(entry) func.xml:6534(entry)
msgid "<literal>FM</literal> prefix"
msgstr "Приставка <literal>FM</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6105(entry)
msgid "fill mode (suppress leading zeroes and padding blanks)"
msgstr "режим заполнения (подавляет ведущие нули и дополнение пробелами)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6106(literal)
msgid "FMMonth"
msgstr "FMMonth"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6109(entry) func.xml:6539(entry)
msgid "<literal>TH</literal> suffix"
msgstr "Окончание <literal>TH</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6110(entry) func.xml:6540(entry)
msgid "upper case ordinal number suffix"
msgstr "окончание порядкового числительного в верхнем регистре"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6111(entry)
msgid "<literal>DDTH</literal>, e.g., <literal>12TH</literal>"
msgstr "<literal>DDTH</literal>, например <literal>12TH</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6114(entry) func.xml:6544(entry)
msgid "<literal>th</literal> suffix"
msgstr "Окончание <literal>th</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6115(entry) func.xml:6545(entry)
msgid "lower case ordinal number suffix"
msgstr "окончание порядкового числительного в нижнем регистре"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6116(entry)
msgid "<literal>DDth</literal>, e.g., <literal>12th</literal>"
msgstr "<literal>DDth</literal>, например <literal>12th</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6119(entry)
msgid "<literal>FX</literal> prefix"
msgstr "Приставка <literal>FX</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6120(entry)
msgid "fixed format global option (see usage notes)"
msgstr "глобальный параметр фиксированного формата (см. замечания)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6121(literal)
msgid "FX&nbsp;Month&nbsp;DD&nbsp;Day"
msgstr "FX&nbsp;Month&nbsp;DD&nbsp;Day"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6124(entry)
msgid "<literal>TM</literal> prefix"
msgstr "Приставка <literal>TM</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6125(entry)
msgid ""
"translation mode (print localized day and month names based on <xref linkend="
"\"guc-lc-time\"/>)"
msgstr ""
"режим перевода (выводятся локализованные названия дней и месяцев, исходя из "
"<xref linkend=\"guc-lc-time\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6127(literal)
msgid "TMMonth"
msgstr "TMMonth"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6130(entry)
msgid "<literal>SP</literal> suffix"
msgstr "Окончание <literal>SP</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6131(entry)
msgid "spell mode (not implemented)"
msgstr "режим числа прописью (не реализован)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6132(literal)
msgid "DDSP"
msgstr "DDSP"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6143(para)
msgid ""
"<literal>FM</literal> suppresses leading zeroes and trailing blanks that "
"would otherwise be added to make the output of a pattern be fixed-width. In "
"<productname>PostgreSQL</productname>, <literal>FM</literal> modifies only "
"the next specification, while in Oracle <literal>FM</literal> affects all "
"subsequent specifications, and repeated <literal>FM</literal> modifiers "
"toggle fill mode on and off."
msgstr ""
"<literal>FM</literal> подавляет дополняющие пробелы и нули справа, которые в "
"противном случае будут добавлены, чтобы результат имел фиксированную ширину. "
"В <productname>PostgreSQL</productname> модификатор <literal>FM</literal> "
"действует только на следующий код, тогда как в Oracle <literal>FM</literal> "
"её действие распространяется на все последующие коды, пока не будет "
"отключено последующим модификатором <literal>FM</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6155(para)
msgid ""
"<literal>TM</literal> does not include trailing blanks. "
"<function>to_timestamp</function> and <function>to_date</function> ignore "
"the <literal>TM</literal> modifier."
msgstr ""
"<literal>TM</literal> не затрагивает замыкающие пробелы. Функции "
"<function>to_timestamp</function> и <function>to_date</function> игнорируют "
"указание <literal>TM</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6163(para)
msgid ""
"<function>to_timestamp</function> and <function>to_date</function> skip "
"multiple blank spaces in the input string unless the <literal>FX</literal> "
"option is used. For example, <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;"
"&nbsp;JUN', 'YYYY MON')</literal> works, but "
"<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</"
"literal> returns an error because <function>to_timestamp</function> expects "
"one space only. <literal>FX</literal> must be specified as the first item in "
"the template."
msgstr ""
"<function>to_timestamp</function> и <function>to_date</function> пропускают "
"повторяющиеся пробелы во входной строке, если только не используется "
"параметр <literal>FX</literal>. Например, <literal>to_timestamp('2000&nbsp;"
"&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> будет работать, но "
"<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</"
"literal> вернёт ошибку, так как <function>to_timestamp</function> в данном "
"случае ожидает только один разделяющий пробел. Приставка <literal>FX</"
"literal> должна быть первой в шаблоне."

#. +> REL9_6_3 REL9_6
#: func.xml:6163(para)
msgid ""
"In conversions from string to <type>timestamp</type> or <type>date</type>, "
"the <literal>CC</literal> (century) field is ignored if there is a "
"<literal>YYY</literal>, <literal>YYYY</literal> or <literal>Y,YYY</literal> "
"field. If <literal>CC</literal> is used with <literal>YY</literal> or "
"<literal>Y</literal> then the year is computed as the year in the specified "
"century. If the century is specified but the year is not, the first year of "
"the century is assumed."
msgstr ""
"В преобразованиях из строки в тип <type>timestamp</type> или <type>date</"
"type>, поле <literal>CC</literal> (век) игнорируется, если шаблон включает "
"поля <literal>YYY</literal>, <literal>YYYY</literal> или <literal>Y,YYY</"
"literal>. Когда <literal>CC</literal> используется с <literal>YY</literal> "
"или <literal>Y</literal>, год вычисляется как год данного столетия. Если "
"присутствует только код столетия, без года, подразумевается первый год этого "
"века."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6176(para)
msgid ""
"Ordinary text is allowed in <function>to_char</function> templates and will "
"be output literally. You can put a substring in double quotes to force it to "
"be interpreted as literal text even if it contains pattern key words. For "
"example, in <literal>'\"Hello Year \"YYYY'</literal>, the <literal>YYYY</"
"literal> will be replaced by the year data, but the single <literal>Y</"
"literal> in <literal>Year</literal> will not be. In <function>to_date</"
"function>, <function>to_number</function>, and <function>to_timestamp</"
"function>, double-quoted strings skip the number of input characters "
"contained in the string, e.g. <literal>\"XX\"</literal> skips two input "
"characters."
msgstr ""
"Шаблоны для функций <function>to_char</function> могут содержать обычный "
"текст; он будет выведен в неизменном виде. Чтобы вывести текст "
"принудительно, например, если в нём оказываются поддерживаемые коды, его "
"можно заключить в кавычки. Например, в строке <literal>'\"Hello Year "
"\"YYYY'</literal>, код <literal>YYYY</literal> будет заменён номером года, а "
"буква <literal>Y</literal> в слове <literal>Year</literal> останется "
"неизменной. В функциях <function>to_date</function>, <function>to_number</"
"function> и <function>to_timestamp</function> при обработке подстроки в "
"кавычках просто пропускаются символы входной строки по числу символов в "
"подстроке, например для <literal>\"XX\"</literal> будут пропущены два "
"символа."

#. +> REL9_6_3 REL9_6
#: func.xml:6176(para)
msgid ""
"An ISO 8601 week-numbering date (as distinct from a Gregorian date) can be "
"specified to <function>to_timestamp</function> and <function>to_date</"
"function> in one of two ways: <placeholder-1/>"
msgstr ""
"Даты по недельному календарю ISO 8601 (отличающиеся от григорианских) можно "
"передать функциям <function>to_timestamp</function> и <function>to_date</"
"function> одним из двух способов: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6191(para)
msgid ""
"If you want to have a double quote in the output you must precede it with a "
"backslash, for example <literal>'\\\"YYYY Month\\\"'</literal>."
msgstr ""
"Если вы хотите получить в результате кавычки, перед ними нужно добавить "
"обратную косую черту, например так: <literal>'\\\"YYYY Month\\\"'</literal>."

#. +> REL_10
#: func.xml:6199(para)
msgid ""
"In <function>to_timestamp</function> and <function>to_date</function>, if "
"the year format specification is less than four digits, e.g. <literal>YYY</"
"literal>, and the supplied year is less than four digits, the year will be "
"adjusted to be nearest to the year 2020, e.g. <literal>95</literal> becomes "
"1995."
msgstr ""
"Если в функциях <function>to_timestamp</function> и <function>to_date</"
"function> формат года определяется менее, чем 4 цифрами, например, как "
"<literal>YYY</literal>, и в переданном значении года тоже меньше 4 цифр, год "
"пересчитывается в максимально близкий к году 2020, т. е. <literal>95</"
"literal> воспринимается как 1995."

#. +> REL_10
#: func.xml:6209(para)
msgid ""
"In <function>to_timestamp</function> and <function>to_date</function>, the "
"<literal>YYYY</literal> conversion has a restriction when processing years "
"with more than 4 digits. You must use some non-digit character or template "
"after <literal>YYYY</literal>, otherwise the year is always interpreted as 4 "
"digits. For example (with the year 20000): <literal>to_date('200001131', "
"'YYYYMMDD')</literal> will be interpreted as a 4-digit year; instead use a "
"non-digit separator after the year, like <literal>to_date('20000-1131', "
"'YYYY-MMDD')</literal> or <literal>to_date('20000Nov31', 'YYYYMonDD')</"
"literal>."
msgstr ""
"В функциях <function>to_timestamp</function> и <function>to_date</function> "
"с преобразованием <literal>YYYY</literal> связано ограничение, когда "
"обрабатываемый год записывается более чем 4 цифрами. После <literal>YYYY</"
"literal> необходимо будет добавить нецифровой символ или соответствующий "
"код, иначе год всегда будет восприниматься как 4 цифры. Например, в "
"<literal>to_date('200001131', 'YYYYMMDD')</literal> (с годом 20000) год "
"будет интерпретирован как состоящий из 4 цифр; чтобы исправить ситуацию, "
"нужно добавить нецифровой разделитель после года, как в "
"<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>, или код как в "
"<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>."

#. +> REL_10
#: func.xml:6225(para)
msgid ""
"In <function>to_timestamp</function> and <function>to_date</function>, the "
"<literal>CC</literal> (century) field is accepted but ignored if there is a "
"<literal>YYY</literal>, <literal>YYYY</literal> or <literal>Y,YYY</literal> "
"field. If <literal>CC</literal> is used with <literal>YY</literal> or "
"<literal>Y</literal> then the result is computed as that year in the "
"specified century. If the century is specified but the year is not, the "
"first year of the century is assumed."
msgstr ""
"Функции <function>to_timestamp</function> и <function>to_date</function> "
"принимают поле <literal>CC</literal> (век), но игнорируют его, если в "
"шаблоне есть поле <literal>YYY</literal>, <literal>YYYY</literal> или "
"<literal>Y,YYY</literal>. Если <literal>CC</literal> используется с "
"<literal>YY</literal> или <literal>Y</literal>, результатом будет год в "
"данном столетии. Если присутствует только код столетия, без года, "
"подразумевается первый год этого века."

#. +> REL_10
#: func.xml:6238(para)
msgid ""
"In <function>to_timestamp</function> and <function>to_date</function>, "
"weekday names or numbers (<literal>DAY</literal>, <literal>D</literal>, and "
"related field types) are accepted but are ignored for purposes of computing "
"the result. The same is true for quarter (<literal>Q</literal>) fields."
msgstr ""
"Функции <function>to_timestamp</function> и <function>to_date</function> "
"принимают названия и номера дней недели (<literal>DAY</literal>, <literal>D</"
"literal> и связанные типы полей), но игнорируют их при вычислении "
"результата. То же самое происходит с полями квартала (<literal>Q</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6254(para)
msgid ""
"Year, week number, and weekday: for example <literal>to_date('2006-42-4', "
"'IYYY-IW-ID')</literal> returns the date <literal>2006-10-19</literal>. If "
"you omit the weekday it is assumed to be 1 (Monday)."
msgstr ""
"Год, номер недели и дня недели: например, <literal>to_date('2006-42-4', "
"'IYYY-IW-ID')</literal> возвращает дату <literal>2006-10-19</literal>. Если "
"день недели опускается, он считается равным 1 (понедельнику)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6262(para)
msgid ""
"Year and day of year: for example <literal>to_date('2006-291', 'IYYY-IDDD')</"
"literal> also returns <literal>2006-10-19</literal>."
msgstr ""
"Год и день года: например, <literal>to_date('2006-291', 'IYYY-IDDD')</"
"literal> также возвращает <literal>2006-10-19</literal>."

#. +> REL_10
#: func.xml:6248(para)
msgid ""
"In <function>to_timestamp</function> and <function>to_date</function>, an "
"ISO 8601 week-numbering date (as distinct from a Gregorian date) can be "
"specified in one of two ways: <placeholder-1/>"
msgstr ""
"Функциям <function>to_timestamp</function> и <function>to_date</function> "
"можно передать даты по недельному календарю ISO 8601 (отличающиеся от "
"григорианских) одним из двух способов: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6269(para)
msgid ""
"Attempting to enter a date using a mixture of ISO 8601 week-numbering fields "
"and Gregorian date fields is nonsensical, and will cause an error. In the "
"context of an ISO 8601 week-numbering year, the concept of a <quote>month</"
"quote> or <quote>day of month</quote> has no meaning. In the context of a "
"Gregorian year, the ISO week has no meaning."
msgstr ""
"Попытка ввести дату из смеси полей григорианского и недельного календаря ISO "
"8601 бессмысленна, поэтому это будет считаться ошибкой. В контексте ISO 8601 "
"понятия <quote>номер месяца</quote> и <quote>день месяца</quote> не "
"существуют, а в григорианском календаре нет понятия номера недели по ISO."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6278(para)
msgid ""
"While <function>to_date</function> will reject a mixture of Gregorian and "
"ISO week-numbering date fields, <function>to_char</function> will not, since "
"output format specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> "
"can be useful. But avoid writing something like <literal>IYYY-MM-DD</"
"literal>; that would yield surprising results near the start of the year. "
"(See <xref linkend=\"functions-datetime-extract\"/> for more information.)"
msgstr ""
"Тогда как <function>to_date</function> не примет смесь полей григорианского "
"и недельного календаря ISO, <function>to_char</function> способна на это, "
"так как форматы вроде <literal>YYYY-MM-DD (IYYY-IDDD)</literal> могут быть "
"полезны. Но избегайте форматов типа <literal>IYYY-MM-DD</literal>; в "
"противном случае с датами в начале года возможны сюрпризы. (За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend="
"\"functions-datetime-extract\"/>.)"

#. +> REL_10
#: func.xml:6292(para)
msgid ""
"In <function>to_timestamp</function>, millisecond (<literal>MS</literal>) or "
"microsecond (<literal>US</literal>) fields are used as the seconds digits "
"after the decimal point. For example <literal>to_timestamp('12.3', 'SS.MS')</"
"literal> is not 3 milliseconds, but 300, because the conversion treats it as "
"12 + 0.3 seconds. So, for the format <literal>SS.MS</literal>, the input "
"values <literal>12.3</literal>, <literal>12.30</literal>, and "
"<literal>12.300</literal> specify the same number of milliseconds. To get "
"three milliseconds, one must write <literal>12.003</literal>, which the "
"conversion treats as 12 + 0.003 = 12.003 seconds."
msgstr ""
"Функция <function>to_timestamp</function> воспринимает поля миллисекунд "
"(<literal>MS</literal>) или микросекунд (<literal>US</literal>) как дробную "
"часть число секунд. Например, <literal>to_timestamp('12.3', 'SS.MS')</"
"literal> — это не 3 миллисекунды, а 300, так как это значение воспринимается "
"как 12 + 0.3 секунды. Это значит, что для формата <literal>SS.MS</literal> "
"входные значения <literal>12.3</literal>, <literal>12.30</literal> и "
"<literal>12.300</literal> задают одно и то же число миллисекунд. Чтобы "
"получить три миллисекунды, время нужно записать в виде <literal>12.003</"
"literal>, тогда оно будет воспринято как 12 + 0.003 = 12.003 сек."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6307(para)
msgid ""
"Here is a more complex example: <literal>to_timestamp('15:12:02.020.001230', "
"'HH24:MI:SS.MS.US')</literal> is 15 hours, 12 minutes, and 2 seconds + 20 "
"milliseconds + 1230 microseconds = 2.021230 seconds."
msgstr ""
"Ещё более сложный пример: <literal>to_timestamp('15:12:02.020.001230', 'HH24:"
"MI:SS.MS.US')</literal> будет преобразовано в 15 часов, 12 минут и 2 секунды "
"+ 20 миллисекунд + 1230 микросекунд = 2.021230 seconds."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6317(para)
msgid ""
"<function>to_char(..., 'ID')</function>'s day of the week numbering matches "
"the <function>extract(isodow from ...)</function> function, but "
"<function>to_char(..., 'D')</function>'s does not match "
"<function>extract(dow from ...)</function>'s day numbering."
msgstr ""
"Нумерация дней недели в <function>to_char(..., 'ID')</function> "
"соответствует функции <function>extract(isodow from ...)</function>, но "
"нумерация <function>to_char(..., 'D')</function> не соответствует нумерации, "
"принятой в <function>extract(dow from ...)</function>."

#. +> REL_10
#: func.xml:6326(para)
msgid ""
"<function>to_char(interval)</function> formats <literal>HH</literal> and "
"<literal>HH12</literal> as shown on a 12-hour clock, for example zero hours "
"and 36 hours both output as <literal>12</literal>, while <literal>HH24</"
"literal> outputs the full hour value, which can exceed 23 in an "
"<type>interval</type> value."
msgstr ""
"Функция <function>to_char(interval)</function> обрабатывает форматы "
"<literal>HH</literal> and <literal>HH12</literal> в рамках 12 часов, то есть "
"0 и 36 часов будут выводиться как <literal>12</literal>, тогда как "
"<literal>HH24</literal> выводит число часов полностью, и для значений "
"<type>interval</type> результат может превышать 23."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6138(para)
msgid "Usage notes for date/time formatting: <placeholder-1/>"
msgstr "Замечания по использованию форматов даты/времени: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6338(para)
msgid ""
"<xref linkend=\"functions-formatting-numeric-table\"/> shows the template "
"patterns available for formatting numeric values."
msgstr ""
"Коды форматирования числовых значений перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-numeric-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6344(title)
msgid "Template Patterns for Numeric Formatting"
msgstr "Коды форматирования чисел"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6354(literal)
msgid "9"
msgstr "9"

#. +> REL_10
#: func.xml:6355(entry)
msgid "digit position (can be dropped if insignificant)"
msgstr "позиция цифры (может отсутствовать, если цифра незначащая)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6358(literal) func.xml:12706(literal)
msgid "0"
msgstr "0"

#. +> REL_10
#: func.xml:6359(entry)
msgid "digit position (will not be dropped, even if insignificant)"
msgstr "позиция цифры (присутствует всегда, даже если цифра незначащая)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6362(entry)
msgid "<literal>.</literal> (period)"
msgstr "<literal>.</literal> (точка)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6363(entry)
msgid "decimal point"
msgstr "десятичная точка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6366(entry)
msgid "<literal>,</literal> (comma)"
msgstr "<literal>,</literal> (запятая)"

#. +> REL_10
#: func.xml:6367(entry)
msgid "group (thousands) separator"
msgstr "разделитель групп (тысяч)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6370(literal)
msgid "PR"
msgstr "PR"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6371(entry)
msgid "negative value in angle brackets"
msgstr "отрицательное значение в угловых скобках"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6374(literal)
msgid "S"
msgstr "S"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6375(entry)
msgid "sign anchored to number (uses locale)"
msgstr "знак, добавляемый к числу (с учётом локали)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6378(literal)
msgid "L"
msgstr "L"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6379(entry)
msgid "currency symbol (uses locale)"
msgstr "символ денежной единицы (с учётом локали)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6383(entry)
msgid "decimal point (uses locale)"
msgstr "разделитель целой и дробной части числа (с учётом локали)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6386(literal)
msgid "G"
msgstr "G"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6387(entry)
msgid "group separator (uses locale)"
msgstr "разделитель групп (с учётом локали)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6391(entry)
msgid "minus sign in specified position (if number &lt; 0)"
msgstr "знак минус в заданной позиции (если число &lt; 0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6394(literal)
msgid "PL"
msgstr "PL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6395(entry)
msgid "plus sign in specified position (if number &gt; 0)"
msgstr "знак плюс в заданной позиции (если число &gt; 0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6398(literal)
msgid "SG"
msgstr "SG"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6399(entry)
msgid "plus/minus sign in specified position"
msgstr "знак плюс или минус в заданной позиции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6402(literal)
msgid "RN"
msgstr "RN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6403(entry)
msgid "Roman numeral (input between 1 and 3999)"
msgstr "число римскими цифрами (в диапазоне от 1 до 3999)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6406(entry)
msgid "<literal>TH</literal> or <literal>th</literal>"
msgstr "<literal>TH</literal> или <literal>th</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6407(entry)
msgid "ordinal number suffix"
msgstr "окончание порядкового числительного"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6410(literal)
msgid "V"
msgstr "V"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6411(entry)
msgid "shift specified number of digits (see notes)"
msgstr "сдвиг на заданное количество цифр (см. замечания)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6414(literal)
msgid "EEEE"
msgstr "EEEE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6415(entry)
msgid "exponent for scientific notation"
msgstr "экспоненциальная запись числа"

#. +> REL_10
#: func.xml:6426(para)
msgid ""
"<literal>0</literal> specifies a digit position that will always be printed, "
"even if it contains a leading/trailing zero. <literal>9</literal> also "
"specifies a digit position, but if it is a leading zero then it will be "
"replaced by a space, while if it is a trailing zero and fill mode is "
"specified then it will be deleted. (For <function>to_number()</function>, "
"these two pattern characters are equivalent.)"
msgstr ""
"<literal>0</literal> обозначает позицию цифры, которая будет выводиться "
"всегда, даже если это незначащий ноль слева или справа. <literal>9</literal> "
"также обозначает позицию цифры, но если это незначащий ноль слева, он "
"заменяется пробелом, а если справа и задан режим заполнения, он удаляется. "
"(Для функции <function>to_number()</function> эти два символа равнозначны.)"

#. +> REL_10
#: func.xml:6437(para)
msgid ""
"The pattern characters <literal>S</literal>, <literal>L</literal>, "
"<literal>D</literal>, and <literal>G</literal> represent the sign, currency "
"symbol, decimal point, and thousands separator characters defined by the "
"current locale (see <xref linkend=\"guc-lc-monetary\"/> and <xref linkend="
"\"guc-lc-numeric\"/>). The pattern characters period and comma represent "
"those exact characters, with the meanings of decimal point and thousands "
"separator, regardless of locale."
msgstr ""
"Символы шаблона <literal>S</literal>, <literal>L</literal>, <literal>D</"
"literal> и <literal>G</literal> представляют знак, символ денежной единицы, "
"десятичную точку и разделитель тысяч, как их определяет текущая локаль (см. "
"<xref remap=\"4\" linkend=\"guc-lc-monetary\"/> и <xref remap=\"4\" linkend="
"\"guc-lc-numeric\"/>). Символы точка и запятая представляют те же символы, "
"обозначающие десятичную точку и разделитель тысяч, но не зависят от локали."

#. +> REL_10
#: func.xml:6449(para)
msgid ""
"If no explicit provision is made for a sign in <function>to_char()</"
"function>'s pattern, one column will be reserved for the sign, and it will "
"be anchored to (appear just left of) the number. If <literal>S</literal> "
"appears just left of some <literal>9</literal>'s, it will likewise be "
"anchored to the number."
msgstr ""
"Если в шаблоне <function>to_char()</function> отсутствует явное указание "
"положения знака, для него резервируется одна позиция рядом с числом (слева "
"от него). Если левее нескольких <literal>9</literal> помещён <literal>S</"
"literal>, знак также будет приписан слева к числу."

#. +> REL_10
#: func.xml:6459(para)
msgid ""
"A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or "
"<literal>MI</literal> is not anchored to the number; for example, "
"<literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;"
"&nbsp;12'</literal> but <literal>to_char(-12, 'S9999')</literal> produces "
"<literal>'&nbsp;&nbsp;-12'</literal>. (The Oracle implementation does not "
"allow the use of <literal>MI</literal> before <literal>9</literal>, but "
"rather requires that <literal>9</literal> precede <literal>MI</literal>.)"
msgstr ""
"Знак числа, полученный кодами <literal>SG</literal>, <literal>PL</literal> "
"или <literal>MI</literal>, не присоединяется к числу; например, "
"<literal>to_char(-12, 'MI9999')</literal> выдаёт <literal>'-&nbsp;&nbsp;12'</"
"literal>, тогда как <literal>to_char(-12, 'S9999')</literal> &mdash; "
"<literal>'&nbsp;&nbsp;-12'</literal>. (В Oracle <literal>MI</literal> не "
"может идти перед <literal>9</literal>, наоборот <literal>9</literal> нужно "
"указать перед <literal>MI</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6473(para)
msgid ""
"<literal>TH</literal> does not convert values less than zero and does not "
"convert fractional numbers."
msgstr ""
"<literal>TH</literal> не преобразует значения меньше 0 и не поддерживает "
"дробные числа."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6480(para)
msgid ""
"<literal>PL</literal>, <literal>SG</literal>, and <literal>TH</literal> are "
"<productname>PostgreSQL</productname> extensions."
msgstr ""
"<literal>PL</literal>, <literal>SG</literal> и <literal>TH</literal> &mdash; "
"расширения <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6488(para)
msgid ""
"<literal>V</literal> with <function>to_char</function> multiplies the input "
"values by <literal>10^<replaceable>n</replaceable></literal>, where "
"<replaceable>n</replaceable> is the number of digits following <literal>V</"
"literal>. <literal>V</literal> with <function>to_number</function> divides "
"in a similar manner. <function>to_char</function> and <function>to_number</"
"function> do not support the use of <literal>V</literal> combined with a "
"decimal point (e.g., <literal>99.9V99</literal> is not allowed)."
msgstr ""
"<literal>V</literal> c <function>to_char</function> умножает вводимое "
"значение на <literal>10^<replaceable>n</replaceable></literal>, где "
"<replaceable>n</replaceable> — число цифр, следующих за <literal>V</"
"literal>. <literal>V</literal> с <function>to_number</function> подобным "
"образом делит значение. Функции <function>to_char</function> и "
"<function>to_number</function> не поддерживают <literal>V</literal> с "
"дробными числами (например, <literal>99.9V99</literal> не допускается)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6503(para)
msgid ""
"<literal>EEEE</literal> (scientific notation) cannot be used in combination "
"with any of the other formatting patterns or modifiers other than digit and "
"decimal point patterns, and must be at the end of the format string (e.g., "
"<literal>9.99EEEE</literal> is a valid pattern)."
msgstr ""
"Код <literal>EEEE</literal> (научная запись) не может сочетаться с любыми "
"другими вариантами форматирования или модификаторами, за исключением цифр и "
"десятичной точки, и должен располагаться в конце строки шаблона (например, "
"<literal>9.99EEEE</literal> &mdash; допустимый шаблон)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6421(para)
msgid "Usage notes for numeric formatting: <placeholder-1/>"
msgstr "Замечания по использованию форматов чисел: <placeholder-1/>"

#. +> REL_10
#: func.xml:6513(para)
msgid ""
"Certain modifiers can be applied to any template pattern to alter its "
"behavior. For example, <literal>FM99.99</literal> is the <literal>99.99</"
"literal> pattern with the <literal>FM</literal> modifier. <xref linkend="
"\"functions-formatting-numericmod-table\"/> shows the modifier patterns for "
"numeric formatting."
msgstr ""
"Для изменения поведения кодов к ним могут быть применены определённые "
"модификаторы. Например, <literal>FM99.99</literal> обрабатывается как код "
"<literal>99.99</literal> с модификатором <literal>FM</literal>. Все "
"модификаторы для форматирования чисел перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-numericmod-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6523(title)
msgid "Template Pattern Modifiers for Numeric Formatting"
msgstr "Модификаторы шаблонов для форматирования чисел"

#. +> REL_10
#: func.xml:6535(entry)
msgid "fill mode (suppress trailing zeroes and padding blanks)"
msgstr "режим заполнения (подавляет завершающие нули и дополнение пробелами)"

#. +> REL_10
#: func.xml:6536(literal)
msgid "FM99.99"
msgstr "FM99.99"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6541(literal)
msgid "999TH"
msgstr "999TH"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6546(literal)
msgid "999th"
msgstr "999th"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6552(para)
msgid ""
"<xref linkend=\"functions-formatting-examples-table\"/> shows some examples "
"of the use of the <function>to_char</function> function."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-formatting-examples-table\"/> "
"приведены некоторые примеры использования функции <function>to_char</"
"function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6558(title)
msgid "<function>to_char</function> Examples"
msgstr "Примеры <function>to_char</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6562(entry) func.xml:7978(entry)
msgid "Expression"
msgstr "Выражение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6568(literal)
msgid "to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6569(literal)
msgid "'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'"
msgstr "'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6572(literal)
msgid "to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6573(literal)
msgid "'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'"
msgstr "'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6576(literal)
msgid "to_char(-0.1, '99.99')"
msgstr "to_char(-0.1, '99.99')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6577(literal)
msgid "'&nbsp;&nbsp;-.10'"
msgstr "'&nbsp;&nbsp;-.10'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6580(literal)
msgid "to_char(-0.1, 'FM9.99')"
msgstr "to_char(-0.1, 'FM9.99')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6581(literal)
msgid "'-.1'"
msgstr "'-.1'"

#. +> REL_10
#: func.xml:6584(literal)
msgid "to_char(-0.1, 'FM90.99')"
msgstr "to_char(-0.1, 'FM90.99')"

#. +> REL_10
#: func.xml:6585(literal)
msgid "'-0.1'"
msgstr "'-0.1'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6588(literal)
msgid "to_char(0.1, '0.9')"
msgstr "to_char(0.1, '0.9')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6589(literal)
msgid "'&nbsp;0.1'"
msgstr "'&nbsp;0.1'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6592(literal)
msgid "to_char(12, '9990999.9')"
msgstr "to_char(12, '9990999.9')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6593(literal)
msgid "'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'"
msgstr "'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6596(literal)
msgid "to_char(12, 'FM9990999.9')"
msgstr "to_char(12, 'FM9990999.9')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6597(literal)
msgid "'0012.'"
msgstr "'0012.'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6600(literal)
msgid "to_char(485, '999')"
msgstr "to_char(485, '999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6601(literal)
msgid "'&nbsp;485'"
msgstr "'&nbsp;485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6604(literal)
msgid "to_char(-485, '999')"
msgstr "to_char(-485, '999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6605(literal) func.xml:6665(literal)
msgid "'-485'"
msgstr "'-485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6608(literal)
msgid "to_char(485, '9&nbsp;9&nbsp;9')"
msgstr "to_char(485, '9&nbsp;9&nbsp;9')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6609(literal)
msgid "'&nbsp;4&nbsp;8&nbsp;5'"
msgstr "'&nbsp;4&nbsp;8&nbsp;5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6612(literal)
msgid "to_char(1485, '9,999')"
msgstr "to_char(1485, '9,999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6613(literal)
msgid "'&nbsp;1,485'"
msgstr "'&nbsp;1,485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6616(literal)
msgid "to_char(1485, '9G999')"
msgstr "to_char(1485, '9G999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6617(literal)
msgid "'&nbsp;1&nbsp;485'"
msgstr "'&nbsp;1&nbsp;485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6620(literal)
msgid "to_char(148.5, '999.999')"
msgstr "to_char(148.5, '999.999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6621(literal)
msgid "'&nbsp;148.500'"
msgstr "'&nbsp;148.500'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6624(literal)
msgid "to_char(148.5, 'FM999.999')"
msgstr "to_char(148.5, 'FM999.999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6625(literal)
msgid "'148.5'"
msgstr "'148.5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6628(literal)
msgid "to_char(148.5, 'FM999.990')"
msgstr "to_char(148.5, 'FM999.990')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6629(literal)
msgid "'148.500'"
msgstr "'148.500'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6632(literal)
msgid "to_char(148.5, '999D999')"
msgstr "to_char(148.5, '999D999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6633(literal)
msgid "'&nbsp;148,500'"
msgstr "'&nbsp;148,500'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6636(literal)
msgid "to_char(3148.5, '9G999D999')"
msgstr "to_char(3148.5, '9G999D999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6637(literal)
msgid "'&nbsp;3&nbsp;148,500'"
msgstr "'&nbsp;3&nbsp;148,500'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6640(literal)
msgid "to_char(-485, '999S')"
msgstr "to_char(-485, '999S')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6641(literal) func.xml:6645(literal)
msgid "'485-'"
msgstr "'485-'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6644(literal)
msgid "to_char(-485, '999MI')"
msgstr "to_char(-485, '999MI')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6648(literal)
msgid "to_char(485, '999MI')"
msgstr "to_char(485, '999MI')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6649(literal)
msgid "'485&nbsp;'"
msgstr "'485&nbsp;'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6652(literal)
msgid "to_char(485, 'FM999MI')"
msgstr "to_char(485, 'FM999MI')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6653(literal)
msgid "'485'"
msgstr "'485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6656(literal)
msgid "to_char(485, 'PL999')"
msgstr "to_char(485, 'PL999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6657(literal) func.xml:6661(literal)
msgid "'+485'"
msgstr "'+485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6660(literal)
msgid "to_char(485, 'SG999')"
msgstr "to_char(485, 'SG999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6664(literal)
msgid "to_char(-485, 'SG999')"
msgstr "to_char(-485, 'SG999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6668(literal)
msgid "to_char(-485, '9SG99')"
msgstr "to_char(-485, '9SG99')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6669(literal)
msgid "'4-85'"
msgstr "'4-85'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6672(literal)
msgid "to_char(-485, '999PR')"
msgstr "to_char(-485, '999PR')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6673(literal)
msgid "'&lt;485&gt;'"
msgstr "'&lt;485&gt;'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6676(literal)
msgid "to_char(485, 'L999')"
msgstr "to_char(485, 'L999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6677(literal)
msgid "'DM&nbsp;485'"
msgstr "'DM&nbsp;485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6680(literal)
msgid "to_char(485, 'RN')"
msgstr "to_char(485, 'RN')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6681(literal)
msgid "'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'"
msgstr "'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6684(literal)
msgid "to_char(485, 'FMRN')"
msgstr "to_char(485, 'FMRN')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6685(literal)
msgid "'CDLXXXV'"
msgstr "'CDLXXXV'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6688(literal)
msgid "to_char(5.2, 'FMRN')"
msgstr "to_char(5.2, 'FMRN')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6689(literal)
msgid "'V'"
msgstr "'V'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6692(literal)
msgid "to_char(482, '999th')"
msgstr "to_char(482, '999th')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6693(literal)
msgid "'&nbsp;482nd'"
msgstr "'&nbsp;482nd'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6696(literal)
msgid "to_char(485, '\"Good&nbsp;number:\"999')"
msgstr "to_char(485, '\"Good&nbsp;number:\"999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6697(literal)
msgid "'Good&nbsp;number:&nbsp;485'"
msgstr "'Good&nbsp;number:&nbsp;485'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6700(literal)
msgid "to_char(485.8, '\"Pre:\"999\"&nbsp;Post:\"&nbsp;.999')"
msgstr "to_char(485.8, '\"Pre:\"999\"&nbsp;Post:\"&nbsp;.999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6701(literal)
msgid "'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'"
msgstr "'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6704(literal)
msgid "to_char(12, '99V999')"
msgstr "to_char(12, '99V999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6705(literal)
msgid "'&nbsp;12000'"
msgstr "'&nbsp;12000'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6708(literal)
msgid "to_char(12.4, '99V999')"
msgstr "to_char(12.4, '99V999')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6709(literal)
msgid "'&nbsp;12400'"
msgstr "'&nbsp;12400'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6712(literal)
msgid "to_char(12.45, '99V9')"
msgstr "to_char(12.45, '99V9')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6713(literal)
msgid "'&nbsp;125'"
msgstr "'&nbsp;125'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6716(literal)
msgid "to_char(0.0004859, '9.99EEEE')"
msgstr "to_char(0.0004859, '9.99EEEE')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6717(literal)
msgid "' 4.86e-04'"
msgstr "' 4.86e-04'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6727(title)
msgid "Date/Time Functions and Operators"
msgstr "Операторы и функции даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6729(para)
msgid ""
"<xref linkend=\"functions-datetime-table\"/> shows the available functions "
"for date/time value processing, with details appearing in the following "
"subsections. <xref linkend=\"operators-datetime-table\"/> illustrates the "
"behaviors of the basic arithmetic operators (<literal>+</literal>, "
"<literal>*</literal>, etc.). For formatting functions, refer to <xref "
"linkend=\"functions-formatting\"/>. You should be familiar with the "
"background information on date/time data types from <xref linkend=\"datatype-"
"datetime\"/>."
msgstr ""
"Все существующие функции для обработки даты/времени перечислены в <xref "
"remap=\"6\" linkend=\"functions-datetime-table\"/>, а подробнее они описаны "
"в следующих подразделах. Поведение основных арифметических операторов "
"(<literal>+</literal>, <literal>*</literal> и т. д.) описано в <xref remap="
"\"6\" linkend=\"operators-datetime-table\"/>. Функции форматирования этих "
"типов данных были перечислены в <xref remap=\"6\" linkend=\"functions-"
"formatting\"/>. Общую информацию об этих типах вы получили (или можете "
"получить) в <xref remap=\"6\" linkend=\"datatype-datetime\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6741(para)
msgid ""
"All the functions and operators described below that take <type>time</type> "
"or <type>timestamp</type> inputs actually come in two variants: one that "
"takes <type>time with time zone</type> or <type>timestamp with time zone</"
"type>, and one that takes <type>time without time zone</type> or "
"<type>timestamp without time zone</type>. For brevity, these variants are "
"not shown separately. Also, the <literal>+</literal> and <literal>*</"
"literal> operators come in commutative pairs (for example both date + "
"integer and integer + date); we show only one of each such pair."
msgstr ""
"Все описанные ниже функции и операторы принимают две разновидности типов "
"<type>time</type> или <type>timestamp</type>: с часовым поясом (<type>time "
"with time zone</type> и <type>timestamp with time zone</type>) и без него "
"(<type>time without time zone</type> и <type>timestamp without time zone</"
"type>). Для краткости здесь они рассматриваются вместе. Кроме того, "
"операторы <literal>+</literal> и <literal>*</literal> обладают "
"переместительным свойством (например, date + integer = integer + date); "
"здесь будет приведён только один вариант для каждой пары."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6752(title)
msgid "Date/Time Operators"
msgstr "Операторы даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6766(literal)
msgid "date '2001-09-28' + integer '7'"
msgstr "date '2001-09-28' + integer '7'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6767(literal)
msgid "date '2001-10-05'"
msgstr "date '2001-10-05'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6772(literal)
msgid "date '2001-09-28' + interval '1 hour'"
msgstr "date '2001-09-28' + interval '1 hour'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6773(literal)
msgid "timestamp '2001-09-28 01:00:00'"
msgstr "timestamp '2001-09-28 01:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6778(literal)
msgid "date '2001-09-28' + time '03:00'"
msgstr "date '2001-09-28' + time '03:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6779(literal)
msgid "timestamp '2001-09-28 03:00:00'"
msgstr "timestamp '2001-09-28 03:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6784(literal)
msgid "interval '1 day' + interval '1 hour'"
msgstr "interval '1 day' + interval '1 hour'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6785(literal)
msgid "interval '1 day 01:00:00'"
msgstr "interval '1 day 01:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6790(literal)
msgid "timestamp '2001-09-28 01:00' + interval '23 hours'"
msgstr "timestamp '2001-09-28 01:00' + interval '23 hours'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6791(literal)
msgid "timestamp '2001-09-29 00:00:00'"
msgstr "timestamp '2001-09-29 00:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6796(literal)
msgid "time '01:00' + interval '3 hours'"
msgstr "time '01:00' + interval '3 hours'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6797(literal)
msgid "time '04:00:00'"
msgstr "time '04:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6802(literal)
msgid "- interval '23 hours'"
msgstr "- interval '23 hours'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6803(literal)
msgid "interval '-23:00:00'"
msgstr "interval '-23:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6808(literal)
msgid "date '2001-10-01' - date '2001-09-28'"
msgstr "date '2001-10-01' - date '2001-09-28'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6809(entry)
msgid "<literal>integer '3'</literal> (days)"
msgstr "<literal>integer '3'</literal> (дня)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6814(literal)
msgid "date '2001-10-01' - integer '7'"
msgstr "date '2001-10-01' - integer '7'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6815(literal)
msgid "date '2001-09-24'"
msgstr "date '2001-09-24'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6820(literal)
msgid "date '2001-09-28' - interval '1 hour'"
msgstr "date '2001-09-28' - interval '1 hour'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6821(literal)
msgid "timestamp '2001-09-27 23:00:00'"
msgstr "timestamp '2001-09-27 23:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6826(literal)
msgid "time '05:00' - time '03:00'"
msgstr "time '05:00' - time '03:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6827(literal)
msgid "interval '02:00:00'"
msgstr "interval '02:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6832(literal)
msgid "time '05:00' - interval '2 hours'"
msgstr "time '05:00' - interval '2 hours'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6833(literal)
msgid "time '03:00:00'"
msgstr "time '03:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6838(literal)
msgid "timestamp '2001-09-28 23:00' - interval '23 hours'"
msgstr "timestamp '2001-09-28 23:00' - interval '23 hours'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6839(literal)
msgid "timestamp '2001-09-28 00:00:00'"
msgstr "timestamp '2001-09-28 00:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6844(literal)
msgid "interval '1 day' - interval '1 hour'"
msgstr "interval '1 day' - interval '1 hour'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6845(literal)
msgid "interval '1 day -01:00:00'"
msgstr "interval '1 day -01:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6850(literal)
msgid "timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'"
msgstr "timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6851(literal)
msgid "interval '1 day 15:00:00'"
msgstr "interval '1 day 15:00:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6856(literal)
msgid "900 * interval '1 second'"
msgstr "900 * interval '1 second'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6857(literal)
msgid "interval '00:15:00'"
msgstr "interval '00:15:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6862(literal)
msgid "21 * interval '1 day'"
msgstr "21 * interval '1 day'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6863(literal)
msgid "interval '21 days'"
msgstr "interval '21 days'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6868(literal)
msgid "double precision '3.5' * interval '1 hour'"
msgstr "double precision '3.5' * interval '1 hour'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6869(literal)
msgid "interval '03:30:00'"
msgstr "interval '03:30:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6874(literal)
msgid "interval '1 hour' / double precision '1.5'"
msgstr "interval '1 hour' / double precision '1.5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6875(literal)
msgid "interval '00:40:00'"
msgstr "interval '00:40:00'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6882(title)
msgid "Date/Time Functions"
msgstr "Функции даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6897(indexterm)
msgid "<primary>age</primary>"
msgstr "<primary>age</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6900(function)
msgid "age(<placeholder-1/>, <placeholder-2/>)"
msgstr "age(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6903(entry)
msgid ""
"Subtract arguments, producing a <quote>symbolic</quote> result that uses "
"years and months, rather than just days"
msgstr ""
"Вычитает аргументы и выдаёт <quote>символический</quote> результат с годами "
"и месяцами, а не просто днями"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6905(literal)
msgid "age(timestamp '2001-04-10', timestamp '1957-06-13')"
msgstr "age(timestamp '2001-04-10', timestamp '1957-06-13')"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6906(literal)
msgid "43 years 9 mons 27 days"
msgstr "43 years 9 mons 27 days (43 года 9 месяцев 27 дней)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6910(function)
msgid "age(<placeholder-1/>)"
msgstr "age(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6912(entry)
msgid "Subtract from <function>current_date</function> (at midnight)"
msgstr ""
"Вычитает дату/время из <function>current_date</function> (полночь текущего "
"дня)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6913(literal)
msgid "age(timestamp '1957-06-13')"
msgstr "age(timestamp '1957-06-13')"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6914(literal)
msgid "43 years 8 mons 3 days"
msgstr "43 years 8 mons 3 days (43 года 8 месяцев 3 дня)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6919(indexterm)
msgid "<primary>clock_timestamp</primary>"
msgstr "<primary>clock_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6922(function)
msgid "clock_timestamp()"
msgstr "clock_timestamp&zwsp;()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6925(entry)
msgid ""
"Current date and time (changes during statement execution); see <xref "
"linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (меняется в процессе выполнения операторов); см. <xref "
"remap=\"4\" linkend=\"functions-datetime-current\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6934(indexterm)
msgid "<primary>current_date</primary>"
msgstr "<primary>current_date</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6937(function)
msgid "current_date"
msgstr "current_date"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6940(entry)
msgid "Current date; see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата; см. <xref remap=\"4\" linkend=\"functions-datetime-current\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6949(indexterm)
msgid "<primary>current_time</primary>"
msgstr "<primary>current_time</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6952(function)
msgid "current_time"
msgstr "current_time"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6954(type) func.xml:8004(type) func.xml:8006(type)
msgid "time with time zone"
msgstr "time with time zone"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6955(entry) func.xml:7126(entry)
msgid "Current time of day; see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущее время суток; см. <xref remap=\"4\" linkend=\"functions-datetime-"
"current\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6964(indexterm)
msgid "<primary>current_timestamp</primary>"
msgstr "<primary>current_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6967(function)
msgid "current_timestamp"
msgstr "current_timestamp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6970(entry) func.xml:7141(entry) func.xml:7275(entry)
#: func.xml:7321(entry)
msgid ""
"Current date and time (start of current transaction); see <xref linkend="
"\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (на момент начала транзакции); см. <xref remap=\"4\" "
"linkend=\"functions-datetime-current\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6979(indexterm) func.xml:7447(indexterm)
msgid "<primary>date_part</primary>"
msgstr "<primary>date_part</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6982(function) func.xml:6993(function)
msgid "date_part(<placeholder-1/>, <placeholder-2/>)"
msgstr "date_part(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6985(entry) func.xml:6995(entry)
msgid ""
"Get subfield (equivalent to <function>extract</function>); see <xref linkend="
"\"functions-datetime-extract\"/>"
msgstr ""
"Возвращает поле даты (равнозначно <function>extract</function>); см. <xref "
"remap=\"4\" linkend=\"functions-datetime-extract\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6988(literal)
msgid "date_part('hour', timestamp '2001-02-16 20:38:40')"
msgstr "date_part('hour', timestamp '2001-02-16 20:38:40')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:6998(literal)
msgid "date_part('month', interval '2 years 3 months')"
msgstr "date_part('month', interval '2 years 3 months')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7004(indexterm) func.xml:7898(indexterm)
msgid "<primary>date_trunc</primary>"
msgstr "<primary>date_trunc</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7007(function) func.xml:7017(function)
msgid "date_trunc(<placeholder-1/>, <placeholder-2/>)"
msgstr "date_trunc(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7010(entry) func.xml:7019(entry)
msgid ""
"Truncate to specified precision; see also <xref linkend=\"functions-datetime-"
"trunc\"/>"
msgstr ""
"Отсекает компоненты даты до заданной точности; см. также <xref linkend="
"\"functions-datetime-trunc\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7012(literal)
msgid "date_trunc('hour', timestamp '2001-02-16 20:38:40')"
msgstr "date_trunc('hour', timestamp '2001-02-16 20:38:40')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7013(literal)
msgid "2001-02-16 20:00:00"
msgstr "2001-02-16 20:00:00"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7021(literal)
msgid "date_trunc('hour', interval '2 days 3 hours 40 minutes')"
msgstr "date_trunc('hour', interval '2 days 3 hours 40 minutes')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7022(literal)
msgid "2 days 03:00:00"
msgstr "2 days 03:00:00"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7027(indexterm) func.xml:7450(indexterm)
msgid "<primary>extract</primary>"
msgstr "<primary>extract</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7030(function) func.xml:7041(function)
msgid "extract"
msgstr "extract"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7030(literal) func.xml:7041(literal)
msgid "<placeholder-1/>(<placeholder-2/> from <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/> from <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7034(entry) func.xml:7044(entry)
msgid "Get subfield; see <xref linkend=\"functions-datetime-extract\"/>"
msgstr ""
"Возвращает поле даты; см. <xref remap=\"4\" linkend=\"functions-datetime-"
"extract\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7036(literal)
msgid "extract(hour from timestamp '2001-02-16 20:38:40')"
msgstr "extract(hour from timestamp '2001-02-16 20:38:40')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7046(literal)
msgid "extract(month from interval '2 years 3 months')"
msgstr "extract(month from interval '2 years 3 months')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7052(indexterm)
msgid "<primary>isfinite</primary>"
msgstr "<primary>isfinite</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7055(function) func.xml:7064(function) func.xml:7072(function)
msgid "isfinite(<placeholder-1/>)"
msgstr "isfinite(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7058(entry)
msgid "Test for finite date (not +/-infinity)"
msgstr "Проверяет конечность даты (её отличие от +/-бесконечности)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7059(literal)
msgid "isfinite(date '2001-02-16')"
msgstr "isfinite(date '2001-02-16')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7060(literal) func.xml:7068(literal) func.xml:7076(literal)
#: func.xml:13160(literal) func.xml:13182(literal) func.xml:13193(literal)
msgctxt "literal"
msgid "true"
msgstr "true"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7066(entry)
msgid "Test for finite time stamp (not +/-infinity)"
msgstr "Проверяет конечность времени (его отличие от +/-бесконечности)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7067(literal)
msgid "isfinite(timestamp '2001-02-16 21:28:30')"
msgstr "isfinite(timestamp '2001-02-16 21:28:30')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7074(entry)
msgid "Test for finite interval"
msgstr "Проверяет конечность интервала"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7075(literal)
msgid "isfinite(interval '4 hours')"
msgstr "isfinite(interval '4 hours')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7081(indexterm)
msgid "<primary>justify_days</primary>"
msgstr "<primary>justify_days</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7084(function)
msgid "justify_days(<placeholder-1/>)"
msgstr "justify_days(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7087(entry)
msgid "Adjust interval so 30-day time periods are represented as months"
msgstr ""
"Преобразует интервал так, что каждый 30-дневный период считается одним "
"месяцем"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7088(literal)
msgid "justify_days(interval '35 days')"
msgstr "justify_days(interval '35 days')"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7089(literal)
msgid "1 mon 5 days"
msgstr "1 mon 5 days (1 месяц 5 дней)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7094(indexterm)
msgid "<primary>justify_hours</primary>"
msgstr "<primary>justify_hours</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7097(function)
msgid "justify_hours(<placeholder-1/>)"
msgstr "justify_hours(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7100(entry)
msgid "Adjust interval so 24-hour time periods are represented as days"
msgstr ""
"Преобразует интервал так, что каждый 24-часовой период считается одним днём"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7101(literal)
msgid "justify_hours(interval '27 hours')"
msgstr "justify_hours(interval '27 hours')"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7102(literal)
msgid "1 day 03:00:00"
msgstr "1 day 03:00:00 (1 день 03:00:00)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7107(indexterm)
msgid "<primary>justify_interval</primary>"
msgstr "<primary>justify_interval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7110(function)
msgid "justify_interval(<placeholder-1/>)"
msgstr "justify_interval(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7113(entry)
msgid ""
"Adjust interval using <function>justify_days</function> and "
"<function>justify_hours</function>, with additional sign adjustments"
msgstr ""
"Преобразует интервал с применением <function>justify_days</function> и "
"<function>justify_hours</function> и дополнительно корректирует знаки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7114(literal)
msgid "justify_interval(interval '1 mon -1 hour')"
msgstr "justify_interval(interval '1 mon -1 hour')"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7115(literal)
msgid "29 days 23:00:00"
msgstr "29 days 23:00:00 (29 дней 23:00:00)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7120(indexterm)
msgid "<primary>localtime</primary>"
msgstr "<primary>localtime</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7123(function)
msgid "localtime"
msgstr "localtime"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7125(type) func.xml:7208(type)
msgid "time"
msgstr "time"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7135(indexterm)
msgid "<primary>localtimestamp</primary>"
msgstr "<primary>localtimestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7138(function)
msgid "localtimestamp"
msgstr "localtimestamp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7150(indexterm)
msgid "<primary>make_date</primary>"
msgstr "<primary>make_date</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7155(parameter) func.xml:7223(parameter) func.xml:7247(parameter)
msgctxt "parameter"
msgid "year"
msgstr "year"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7156(parameter) func.xml:7224(parameter) func.xml:7248(parameter)
msgctxt "parameter"
msgid "month"
msgstr "month"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7157(parameter) func.xml:7225(parameter) func.xml:7249(parameter)
msgctxt "parameter"
msgid "day"
msgstr "day"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7154(function)
msgid ""
"make_date(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"make_date(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7162(entry)
msgid "Create date from year, month and day fields"
msgstr "Образует дату из полей: year (год), month (месяц) и day (день)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7165(literal)
msgid "make_date(2013, 7, 15)"
msgstr "make_date(2013, 7, 15)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7166(literal)
msgid "2013-07-15"
msgstr "2013-07-15"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7171(indexterm)
msgid "<primary>make_interval</primary>"
msgstr "<primary>make_interval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7176(parameter)
msgid "years"
msgstr "years"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7177(parameter)
msgid "months"
msgstr "months"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7178(parameter)
msgid "weeks"
msgstr "weeks"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7179(parameter)
msgid "days"
msgstr "days"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7180(parameter)
msgid "hours"
msgstr "hours"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7181(parameter)
msgid "mins"
msgstr "mins"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7182(parameter)
msgid "secs"
msgstr "secs"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7175(function)
msgid ""
"make_interval(<placeholder-1/> <placeholder-2/> DEFAULT 0, <placeholder-3/> "
"<placeholder-4/> DEFAULT 0, <placeholder-5/> <placeholder-6/> DEFAULT 0, "
"<placeholder-7/> <placeholder-8/> DEFAULT 0, <placeholder-9/> "
"<placeholder-10/> DEFAULT 0, <placeholder-11/> <placeholder-12/> DEFAULT 0, "
"<placeholder-13/> <placeholder-14/> DEFAULT 0.0)"
msgstr ""
"make_interval(<placeholder-1/> <placeholder-2/> DEFAULT 0, <placeholder-3/> "
"<placeholder-4/> DEFAULT 0, <placeholder-5/> <placeholder-6/> DEFAULT 0, "
"<placeholder-7/> <placeholder-8/> DEFAULT 0, <placeholder-9/> "
"<placeholder-10/> DEFAULT 0, <placeholder-11/> <placeholder-12/> DEFAULT 0, "
"<placeholder-13/> <placeholder-14/> DEFAULT 0.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7187(entry)
msgid ""
"Create interval from years, months, weeks, days, hours, minutes and seconds "
"fields"
msgstr ""
"Образует интервал из полей: years (годы), months (месяцы), weeks (недели), "
"days (дни), hours (часы), minutes (минуты) и secs (секунды)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7191(literal)
msgid "make_interval(days =&gt; 10)"
msgstr "make_interval(days =&gt; 10)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7192(literal)
msgid "10 days"
msgstr "10 days"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7197(indexterm)
msgid "<primary>make_time</primary>"
msgstr "<primary>make_time</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7202(parameter) func.xml:7226(parameter) func.xml:7250(parameter)
msgctxt "parameter"
msgid "hour"
msgstr "hour"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7203(parameter) func.xml:7227(parameter) func.xml:7251(parameter)
msgid "min"
msgstr "min"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7204(parameter) func.xml:7228(parameter) func.xml:7252(parameter)
msgid "sec"
msgstr "sec"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7201(function)
msgid ""
"make_time(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"make_time(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7209(entry)
msgid "Create time from hour, minute and seconds fields"
msgstr "Образует время из полей: hour (час), minute (минута) и sec (секунда)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7212(literal)
msgid "make_time(8, 15, 23.5)"
msgstr "make_time(8, 15, 23.5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7213(literal)
msgid "08:15:23.5"
msgstr "08:15:23.5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7218(indexterm)
msgid "<primary>make_timestamp</primary>"
msgstr "<primary>make_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7222(function)
msgid ""
"make_timestamp(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>)"
msgstr ""
"make_timestamp(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7233(entry)
msgid "Create timestamp from year, month, day, hour, minute and seconds fields"
msgstr ""
"Образует дату и время из полей: year (год), month (месяц), day (день), hour "
"(час), minute (минута) и sec (секунда)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7236(literal)
msgid "make_timestamp(2013, 7, 15, 8, 15, 23.5)"
msgstr "make_timestamp(2013, 7, 15, 8, 15, 23.5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7237(literal)
msgid "2013-07-15 08:15:23.5"
msgstr "2013-07-15 08:15:23.5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7242(indexterm)
msgid "<primary>make_timestamptz</primary>"
msgstr "<primary>make_timestamptz</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7253(parameter)
msgctxt "parameter"
msgid "timezone"
msgstr "timezone"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7246(function)
msgid ""
"make_timestamptz(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>, <optional><placeholder-13/> <placeholder-14/></optional>)"
msgstr ""
"make_timestamptz(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>, <optional><placeholder-13/> <placeholder-14/></optional>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7258(entry)
msgid ""
"Create timestamp with time zone from year, month, day, hour, minute and "
"seconds fields; if <parameter>timezone</parameter> is not specified, the "
"current time zone is used"
msgstr ""
"Образует дату и время с часовым поясом из полей: year (год), month (месяц), "
"day (день), hour (час), minute (минута) и sec (секунда). Если параметр "
"<parameter>timezone</parameter> (часовой пояс) не указан, используется "
"текущий часовой пояс."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7263(literal)
msgid "make_timestamptz(2013, 7, 15, 8, 15, 23.5)"
msgstr "make_timestamptz(2013, 7, 15, 8, 15, 23.5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7264(literal)
msgid "2013-07-15 08:15:23.5+01"
msgstr "2013-07-15 08:15:23.5+01"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7269(indexterm)
msgid "<primary>now</primary>"
msgstr "<primary>now</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7272(function)
msgid "now()"
msgstr "now()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7284(indexterm)
msgid "<primary>statement_timestamp</primary>"
msgstr "<primary>statement_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7287(function)
msgid "statement_timestamp()"
msgstr "statement_timestamp()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7290(entry)
msgid ""
"Current date and time (start of current statement); see <xref linkend="
"\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (на момент начала текущего оператора); см. <xref remap="
"\"4\" linkend=\"functions-datetime-current\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7299(indexterm)
msgid "<primary>timeofday</primary>"
msgstr "<primary>timeofday</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7302(function)
msgid "timeofday()"
msgstr "timeofday()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7305(entry)
msgid ""
"Current date and time (like <function>clock_timestamp</function>, but as a "
"<type>text</type> string); see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (как <function>clock_timestamp</function>, но в виде "
"строки типа <type>text</type>); см. <xref remap=\"4\" linkend=\"functions-"
"datetime-current\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7315(indexterm)
msgid "<primary>transaction_timestamp</primary>"
msgstr "<primary>transaction_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7318(function)
msgid "transaction_timestamp()"
msgstr "transaction_timestamp()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7332(function)
msgid "to_timestamp(<placeholder-1/>)"
msgstr "to_timestamp(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7335(entry)
msgid "Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to timestamp"
msgstr ""
"Преобразует время эпохи Unix (число секунд с 1970-01-01 00:00:00+00) в "
"стандартное время"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7337(literal)
msgid "to_timestamp(1284352323)"
msgstr "to_timestamp(1284352323)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7338(literal)
msgid "2010-09-13 04:32:03+00"
msgstr "2010-09-13 04:32:03+00"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7345(indexterm)
msgid "<primary>OVERLAPS</primary>"
msgstr "<primary>OVERLAPS</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7344(para)
msgid ""
"<placeholder-1/> In addition to these functions, the SQL <literal>OVERLAPS</"
"literal> operator is supported: <synopsis>\n"
"(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) "
"OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</"
"replaceable>)\n"
"(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) "
"OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</"
"replaceable>)\n"
"</synopsis> This expression yields true when two time periods (defined by "
"their endpoints) overlap, false when they do not overlap. The endpoints can "
"be specified as pairs of dates, times, or time stamps; or as a date, time, "
"or time stamp followed by an interval. When a pair of values is provided, "
"either the start or the end can be written first; <literal>OVERLAPS</"
"literal> automatically takes the earlier value of the pair as the start. "
"Each time period is considered to represent the half-open interval "
"<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</"
"replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless "
"<replaceable>start</replaceable> and <replaceable>end</replaceable> are "
"equal in which case it represents that single time instant. This means for "
"instance that two time periods with only an endpoint in common do not "
"overlap."
msgstr ""
"<placeholder-1/> В дополнение к этим функциям поддерживается SQL-оператор "
"<literal>OVERLAPS</literal>: <synopsis>\n"
"(<replaceable>начало1</replaceable>, <replaceable>конец1</replaceable>) "
"OVERLAPS (<replaceable>начало2</replaceable>, <replaceable>конец2</"
"replaceable>)\n"
"(<replaceable>начало1</replaceable>, <replaceable>длительность1</"
"replaceable>) OVERLAPS (<replaceable>начало2</replaceable>, "
"<replaceable>длительность2</replaceable>)\n"
"</synopsis> Его результатом будет true, когда два периода времени "
"(определённые своими границами) пересекаются, и false в противном случае. "
"Границы периода можно задать либо в виде пары дат, времени или дат со "
"временем, либо как дату, время (или дату со временем) c интервалом. Когда "
"указывается пара значений, первым может быть и начало, и конец периода: "
"<literal>OVERLAPS</literal> автоматически считает началом периода меньшее "
"значение. Периоды времени считаются наполовину открытыми, т. е. "
"<replaceable>начало</replaceable><literal>&lt;=</literal><replaceable>время</"
"replaceable><literal>&lt;</literal><replaceable>конец</replaceable>, если "
"только <replaceable>начало</replaceable> и <replaceable>конец</replaceable> "
"не равны &mdash; в этом случае период представляет один момент времени. Это "
"означает, например, что два периода, имеющие только общую границу, не будут "
"считаться пересекающимися."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7371(lineannotation) func.xml:7374(lineannotation)
#: func.xml:7377(lineannotation) func.xml:7380(lineannotation)
#: func.xml:7433(lineannotation) func.xml:7437(lineannotation)
#: func.xml:7439(lineannotation) func.xml:7441(lineannotation)
#: func.xml:7482(lineannotation) func.xml:7484(lineannotation)
#: func.xml:7509(lineannotation) func.xml:7512(lineannotation)
#: func.xml:7529(lineannotation) func.xml:7544(lineannotation)
#: func.xml:7564(lineannotation) func.xml:7583(lineannotation)
#: func.xml:7586(lineannotation) func.xml:7595(lineannotation)
#: func.xml:7609(lineannotation) func.xml:7624(lineannotation)
#: func.xml:7644(lineannotation) func.xml:7646(lineannotation)
#: func.xml:7672(lineannotation) func.xml:7686(lineannotation)
#: func.xml:7706(lineannotation) func.xml:7720(lineannotation)
#: func.xml:7736(lineannotation) func.xml:7739(lineannotation)
#: func.xml:7742(lineannotation) func.xml:7756(lineannotation)
#: func.xml:7772(lineannotation) func.xml:7775(lineannotation)
#: func.xml:7832(lineannotation) func.xml:7847(lineannotation)
#: func.xml:7887(lineannotation) func.xml:7890(lineannotation)
msgid "Result:"
msgstr "Результат:"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7371(computeroutput) func.xml:7380(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "true"
msgstr "true"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7374(computeroutput) func.xml:7377(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "false"
msgstr "false"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7368(screen)
#, no-wrap
msgid ""
"SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-7/><placeholder-8/>"
msgstr ""
"SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-7/><placeholder-8/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7383(para)
msgid ""
"When adding an <type>interval</type> value to (or subtracting an "
"<type>interval</type> value from) a <type>timestamp with time zone</type> "
"value, the days component advances or decrements the date of the "
"<type>timestamp with time zone</type> by the indicated number of days. "
"Across daylight saving time changes (when the session time zone is set to a "
"time zone that recognizes DST), this means <literal>interval '1 day'</"
"literal> does not necessarily equal <literal>interval '24 hours'</literal>. "
"For example, with the session time zone set to <literal>CST7CDT</literal>, "
"<literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</"
"literal> will produce <literal>timestamp with time zone '2005-04-03 "
"12:00-06'</literal>, while adding <literal>interval '24 hours'</literal> to "
"the same initial <type>timestamp with time zone</type> produces "
"<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there "
"is a change in daylight saving time at <literal>2005-04-03 02:00</literal> "
"in time zone <literal>CST7CDT</literal>."
msgstr ""
"При добавлении к дате со временем типа <type>timestamp with time zone</type> "
"значения <type>interval</type> (или при вычитании из него <type>interval</"
"type>), поле дней в этой дате увеличивается (или уменьшается) на указанное "
"число дней. При пересечении границы перехода на летнее время (если в часовом "
"поясе текущего сеанса производится этот переход) это означает, что "
"<literal>interval '1 day'</literal> и <literal>interval '24 hours'</literal> "
"не обязательно будут равны. Например, в часовом поясе <literal>CST7CDT</"
"literal> результатом выражения <literal>timestamp with time zone '2005-04-02 "
"12:00-07' + interval '1 day' </literal> будет <literal>timestamp with time "
"zone '2005-04-03 12:00-06'</literal>, тогда как, если добавить "
"<literal>interval '24 hours'</literal> к тому же значению <type>timestamp "
"with time zone</type>, в результате получится <literal>timestamp with time "
"zone '2005-04-03 13:00-06'</literal>. Эта разница объясняется тем, что "
"<literal>2005-04-03 02:00</literal> в часовом поясе <literal>CST7CDT</"
"literal> произошёл переход на летнее время."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7401(para)
msgid ""
"Note there can be ambiguity in the <literal>months</literal> field returned "
"by <function>age</function> because different months have different numbers "
"of days. <productname>PostgreSQL</productname>'s approach uses the month "
"from the earlier of the two dates when calculating partial months. For "
"example, <literal>age('2004-06-01', '2004-04-30')</literal> uses April to "
"yield <literal>1 mon 1 day</literal>, while using May would yield <literal>1 "
"mon 2 days</literal> because May has 31 days, while April has only 30."
msgstr ""
"Обратите внимание на возможную неоднозначность в поле <literal>months</"
"literal> в результате функции <function>age</function>, вызванную тем, что "
"число дней в разных месяцах неодинаково. Вычисляя оставшиеся дни месяца, "
"<productname>PostgreSQL</productname> рассматривает месяц меньшей из двух "
"дат. Например, результатом <literal>age('2004-06-01', '2004-04-30')</"
"literal> будет <literal>1 mon 1 day</literal>, так как в апреле 30 дней, а "
"то же выражение с датой 30 мая выдаст <literal>1 mon 2 days</literal>, так "
"как в мае 31 день."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7411(para)
msgid ""
"Subtraction of dates and timestamps can also be complex. One conceptually "
"simple way to perform subtraction is to convert each value to a number of "
"seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the "
"results; this produces the number of <emphasis>seconds</emphasis> between "
"the two values. This will adjust for the number of days in each month, "
"timezone changes, and daylight saving time adjustments. Subtraction of date "
"or timestamp values with the <quote><literal>-</literal></quote> operator "
"returns the number of days (24-hours) and hours/minutes/seconds between the "
"values, making the same adjustments. The <function>age</function> function "
"returns years, months, days, and hours/minutes/seconds, performing field-by-"
"field subtraction and then adjusting for negative field values. The "
"following queries illustrate the differences in these approaches. The sample "
"results were produced with <literal>timezone = 'US/Eastern'</literal>; there "
"is a daylight saving time change between the two dates used:"
msgstr ""
"Вычитание дат и дат со временем также может быть нетривиальной операцией. "
"Один принципиально простой способ выполнить такое вычисление &mdash; "
"преобразовать каждое значение в количество секунд, используя "
"<literal>EXTRACT(EPOCH FROM ...)</literal>, а затем найти разницу "
"результатов; при этом будет получено число <emphasis>секунд</emphasis> между "
"двумя датами. При этом будет учтено неодинаковое число дней в месяцах, "
"изменения часовых поясов и переходы на летнее время. При вычитании дат или "
"дат со временем с помощью оператора <quote><literal>-</literal></quote> "
"выдаётся число дней (по 24 часа) и часов/минут/секунд между данными "
"значениями, с учётом тех же факторов. Функция <function>age</function> "
"возвращает число лет, месяцев, дней и часов/минут/секунд, выполняя вычитание "
"по полям, а затем пересчитывая отрицательные значения. Различие этих "
"подходов иллюстрируют следующие запросы. Показанные результаты были получены "
"для часового пояса <literal>'US/Eastern'</literal>; между двумя заданными "
"датами произошёл переход на летнее время:"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7433(computeroutput)
#, no-wrap
msgid "10537200"
msgstr "10537200"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7437(computeroutput)
#, no-wrap
msgid "121.958333333333"
msgstr "121.958333333333"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7439(computeroutput)
#, no-wrap
msgid "121 days 23:00:00"
msgstr "121 days 23:00:00"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7441(computeroutput)
#, no-wrap
msgid "4 mons"
msgstr "4 mons"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7430(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))\n"
"        / 60 / 60 / 24;\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-7/><placeholder-8/>"
msgstr ""
"SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))\n"
"        / 60 / 60 / 24;\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-7/><placeholder-8/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7445(title)
msgid "<function>EXTRACT</function>, <function>date_part</function>"
msgstr "<function>EXTRACT</function>, <function>date_part</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7455(replaceable)
msgctxt "replaceable"
msgid "field"
msgstr "field"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7455(replaceable)
msgid "source"
msgstr "source"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7454(synopsis)
#, no-wrap
msgid "EXTRACT(<placeholder-1/> FROM <placeholder-2/>)"
msgstr "EXTRACT(<placeholder-1/> FROM <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7474(literal) func.xml:7937(literal)
msgid "century"
msgstr "century"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7476(para)
msgid "The century"
msgstr "Век:"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7482(computeroutput) func.xml:7609(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "20"
msgstr "20"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7484(computeroutput)
#, no-wrap
msgid "21"
msgstr "21"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7480(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-3/><placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7487(para)
msgid ""
"The first century starts at 0001-01-01 00:00:00 AD, although they did not "
"know it at the time. This definition applies to all Gregorian calendar "
"countries. There is no century number 0, you go from -1 century to 1 "
"century. If you disagree with this, please write your complaint to: Pope, "
"Cathedral Saint-Peter of Roma, Vatican."
msgstr ""
"Первый век начался 0001-01-01 00:00:00, хотя люди в то время и не считали "
"так. Это определение распространяется на все страны с григорианским "
"календарём. Века с номером 0 нет было; считается, что 1 наступил после -1. "
"Если такое положение вещей вас не устраивает, направляйте жалобы по адресу: "
"Ватикан, Собор Святого Петра, Папе."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7502(para)
msgid ""
"For <type>timestamp</type> values, the day (of the month) field (1 - 31) ; "
"for <type>interval</type> values, the number of days"
msgstr ""
"Для значений <type>timestamp</type> это день месяца (1 - 31), для значений "
"<type>interval</type> &mdash; число дней"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7509(computeroutput) func.xml:7887(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "16"
msgstr "16"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7512(computeroutput) func.xml:7772(computeroutput)
#, no-wrap
msgid "40"
msgstr "40"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7507(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');\n"
"<placeholder-3/><placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7521(literal) func.xml:7936(literal)
msgid "decade"
msgstr "decade"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7523(para)
msgid "The year field divided by 10"
msgstr "Год, делённый на 10"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7529(computeroutput)
#, no-wrap
msgid "200"
msgstr "200"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7527(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7535(literal)
msgid "dow"
msgstr "dow"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7537(para)
msgid ""
"The day of the week as Sunday (<literal>0</literal>) to Saturday "
"(<literal>6</literal>)"
msgstr ""
"День недели, считая с воскресенья (<literal>0</literal>) до субботы "
"(<literal>6</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7544(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "5"
msgstr "5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7542(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7546(para)
msgid ""
"Note that <function>extract</function>'s day of the week numbering differs "
"from that of the <function>to_char(..., 'D')</function> function."
msgstr ""
"Заметьте, что в <function>extract</function> дни недели нумеруются не так, "
"как в функции <function>to_char(..., 'D')</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7556(literal)
msgid "doy"
msgstr "doy"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7558(para)
msgid "The day of the year (1 - 365/366)"
msgstr "День года (1 - 365/366)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7564(computeroutput)
#, no-wrap
msgid "47"
msgstr "47"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7562(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7570(literal)
msgid "epoch"
msgstr "epoch"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7572(para)
msgid ""
"For <type>timestamp with time zone</type> values, the number of seconds "
"since 1970-01-01 00:00:00 UTC (can be negative); for <type>date</type> and "
"<type>timestamp</type> values, the number of seconds since 1970-01-01 "
"00:00:00 local time; for <type>interval</type> values, the total number of "
"seconds in the interval"
msgstr ""
"Для значений <type>timestamp with time zone</type> это число секунд с "
"1970-01-01 00:00:00 UTC (может быть отрицательным); для значений <type>date</"
"type> и <type>timestamp</type> это число секунд с 1970-01-01 00:00:00 по "
"местному времени, а для <type>interval</type> &mdash; общая длительность "
"интервала в секундах"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7583(computeroutput)
#, no-wrap
msgid "982384720.12"
msgstr "982384720.12"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7586(computeroutput)
#, no-wrap
msgid "442800"
msgstr "442800"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7581(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE\n"
" '2001-02-16 20:38:40.12-08');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');\n"
"<placeholder-3/><placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7589(para)
msgid ""
"You can convert an epoch value back to a time stamp with "
"<function>to_timestamp</function>:"
msgstr ""
"Преобразовать время эпохи назад, в значение дата/время, с помощью "
"<function>to_timestamp</function> можно так:"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7595(computeroutput)
#, no-wrap
msgid "2001-02-17 04:38:40.12+00"
msgstr "2001-02-17 04:38:40.12+00"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7593(screen)
#, no-wrap
msgid ""
"SELECT to_timestamp(982384720.12);\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT to_timestamp(982384720.12);\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7601(literal) func.xml:7930(literal)
msgctxt "literal"
msgid "hour"
msgstr "hour"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7603(para)
msgid "The hour field (0 - 23)"
msgstr "Час (0 - 23)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7607(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7615(literal)
msgid "isodow"
msgstr "isodow"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7617(para)
msgid ""
"The day of the week as Monday (<literal>1</literal>) to Sunday (<literal>7</"
"literal>)"
msgstr ""
"День недели, считая с понедельника (<literal>1</literal>) до воскресенья "
"(<literal>7</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7624(computeroutput) func.xml:7832(computeroutput)
#, no-wrap
msgid "7"
msgstr "7"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7622(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7626(para)
msgid ""
"This is identical to <literal>dow</literal> except for Sunday. This matches "
"the <acronym>ISO</acronym> 8601 day of the week numbering."
msgstr ""
"Результат отличается от <literal>dow</literal> только для воскресенья. Такая "
"нумерация соответствует <acronym>ISO</acronym> 8601."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7635(literal)
msgid "isoyear"
msgstr "isoyear"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7637(para)
msgid ""
"The <acronym>ISO</acronym> 8601 week-numbering year that the date falls in "
"(not applicable to intervals)"
msgstr ""
"Год по недельному календарю <acronym>ISO</acronym> 8601, в который попадает "
"дата (неприменимо к интервалам)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7644(computeroutput)
#, no-wrap
msgid "2005"
msgstr "2005"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7646(computeroutput)
#, no-wrap
msgid "2006"
msgstr "2006"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7642(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');\n"
"<placeholder-3/><placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7649(para)
msgid ""
"Each <acronym>ISO</acronym> 8601 week-numbering year begins with the Monday "
"of the week containing the 4th of January, so in early January or late "
"December the <acronym>ISO</acronym> year may be different from the Gregorian "
"year. See the <literal>week</literal> field for more information."
msgstr ""
"Год по недельному календарю <acronym>ISO</acronym> начинается с понедельника "
"недели, в которой оказывается 4 января, так что в начале января или в конце "
"декабря год по <acronym>ISO</acronym> может отличаться от года по "
"григорианскому календарю. Подробнее об этом рассказывается в описании поля "
"<literal>week</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7656(para)
msgid "This field is not available in PostgreSQL releases prior to 8.3."
msgstr "Этого поля не было в PostgreSQL до версии 8.3."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7663(literal) func.xml:7926(literal)
msgid "microseconds"
msgstr "microseconds"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7665(para)
msgid ""
"The seconds field, including fractional parts, multiplied by 1 000 000; note "
"that this includes full seconds"
msgstr ""
"Значение секунд с дробной частью, умноженное на 1 000 000; заметьте, что оно "
"включает и целые секунды"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7672(computeroutput)
#, no-wrap
msgid "28500000"
msgstr "28500000"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7670(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7678(literal) func.xml:7938(literal)
msgid "millennium"
msgstr "millennium"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7680(para)
msgid "The millennium"
msgstr "Тысячелетие"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7686(computeroutput) func.xml:7739(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "3"
msgstr "3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7684(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7689(para)
msgid ""
"Years in the 1900s are in the second millennium. The third millennium "
"started January 1, 2001."
msgstr ""
"Годы 20 века относятся ко второму тысячелетию. Третье тысячелетие началось 1 "
"января 2001 г."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7697(literal) func.xml:7927(literal)
msgid "milliseconds"
msgstr "milliseconds"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7699(para)
msgid ""
"The seconds field, including fractional parts, multiplied by 1000. Note that "
"this includes full seconds."
msgstr ""
"Значение секунд с дробной частью, умноженное на 1 000; заметьте, что оно "
"включает и целые секунды."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7706(computeroutput)
#, no-wrap
msgid "28500"
msgstr "28500"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7704(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7712(literal) func.xml:7929(literal)
msgid "minute"
msgstr "minute"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7714(para)
msgid "The minutes field (0 - 59)"
msgstr "Минуты (0 - 59)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7720(computeroutput)
#, no-wrap
msgid "38"
msgstr "38"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7718(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7728(para)
msgid ""
"For <type>timestamp</type> values, the number of the month within the year "
"(1 - 12) ; for <type>interval</type> values, the number of months, modulo 12 "
"(0 - 11)"
msgstr ""
"Для значений <type>timestamp</type> это номер месяца в году (1 - 12), а для "
"<type>interval</type> &mdash; остаток от деления числа месяцев на 12 (в "
"интервале 0 - 11)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7736(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "2"
msgstr "2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7742(computeroutput) func.xml:7756(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "1"
msgstr "1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7734(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');\n"
"<placeholder-3/><placeholder-4/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');\n"
"<placeholder-5/><placeholder-6/>"
msgstr ""
"SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');\n"
"<placeholder-3/><placeholder-4/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');\n"
"<placeholder-5/><placeholder-6/>"

#. +> REL_10
#: func.xml:7748(literal) func.xml:7934(literal)
msgctxt "literal"
msgid "quarter"
msgstr "quarter"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7750(para)
msgid "The quarter of the year (1 - 4) that the date is in"
msgstr "Квартал года (1 - 4), к которому относится дата"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7754(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7762(literal) func.xml:7928(literal)
msgid "second"
msgstr "second"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7766(simpara)
msgid "60 if leap seconds are implemented by the operating system"
msgstr "60, если операционная система поддерживает секунды координации"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7764(para)
msgid "The seconds field, including fractional parts (0 - 59<placeholder-1/>)"
msgstr "Секунды, включая дробную часть (0 - 59<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7775(computeroutput)
#, no-wrap
msgid "28.5"
msgstr "28.5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7770(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');\n"
"<placeholder-3/><placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7780(literal)
msgctxt "literal"
msgid "timezone"
msgstr "timezone"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7782(para)
msgid ""
"The time zone offset from UTC, measured in seconds. Positive values "
"correspond to time zones east of UTC, negative values to zones west of UTC. "
"(Technically, <productname>PostgreSQL</productname> does not use UTC because "
"leap seconds are not handled.)"
msgstr ""
"Смещение часового пояса от UTC, представленное в секундах. Положительные "
"значения соответствуют часовым поясам к востоку от UTC, а отрицательные "
"&mdash; к западу. (Строго говоря, в <productname>PostgreSQL</productname> "
"используется не UTC, так как секунды координации не учитываются.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7793(literal)
msgid "timezone_hour"
msgstr "timezone_hour"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7795(para)
msgid "The hour component of the time zone offset"
msgstr "Поле часов в смещении часового пояса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7802(literal)
msgid "timezone_minute"
msgstr "timezone_minute"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7804(para)
msgid "The minute component of the time zone offset"
msgstr "Поле минут в смещении часового пояса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7811(literal) func.xml:7932(literal)
msgid "week"
msgstr "week"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7813(para)
msgid ""
"The number of the <acronym>ISO</acronym> 8601 week-numbering week of the "
"year. By definition, ISO weeks start on Mondays and the first week of a year "
"contains January 4 of that year. In other words, the first Thursday of a "
"year is in week 1 of that year."
msgstr ""
"Номер недели в году по недельному календарю <acronym>ISO</acronym> 8601. По "
"определению, недели <acronym>ISO</acronym> 8601 начинаются с понедельника, а "
"первая неделя года включает 4 января этого года. Другими словами, первый "
"четверг года всегда оказывается в 1 неделе этого года."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7819(para)
msgid ""
"In the ISO week-numbering system, it is possible for early-January dates to "
"be part of the 52nd or 53rd week of the previous year, and for late-December "
"dates to be part of the first week of the next year. For example, "
"<literal>2005-01-01</literal> is part of the 53rd week of year 2004, and "
"<literal>2006-01-01</literal> is part of the 52nd week of year 2005, while "
"<literal>2012-12-31</literal> is part of the first week of 2013. It's "
"recommended to use the <literal>isoyear</literal> field together with "
"<literal>week</literal> to get consistent results."
msgstr ""
"В системе нумерации недель ISO первые числа января могут относиться к 52-ой "
"или 53-ей неделе предыдущего года, а последние числа декабря &mdash; к "
"первой неделе следующего года. Например, <literal>2005-01-01</literal> "
"относится к 53-ей неделе 2004 г., а <literal>2006-01-01</literal> &mdash; к "
"52-ей неделе 2005 г., тогда как <literal>2012-12-31</literal> включается в "
"первую неделю 2013 г. Поэтому для получения согласованных результатов "
"рекомендуется использовать поле <literal>isoyear</literal> в паре с "
"<literal>week</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7830(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7838(literal) func.xml:7935(literal)
msgctxt "literal"
msgid "year"
msgstr "year"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7840(para)
msgid ""
"The year field. Keep in mind there is no <literal>0 AD</literal>, so "
"subtracting <literal>BC</literal> years from <literal>AD</literal> years "
"should be done with care."
msgstr ""
"Поле года. Учтите, что года <literal>0</literal> не было, и это следует "
"иметь в виду, вычитая из годов нашей эры годы до нашей эры."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7847(computeroutput)
#, no-wrap
msgid "2001"
msgstr "2001"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7845(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7458(para)
msgid ""
"The <function>extract</function> function retrieves subfields such as year "
"or hour from date/time values. <replaceable>source</replaceable> must be a "
"value expression of type <type>timestamp</type>, <type>time</type>, or "
"<type>interval</type>. (Expressions of type <type>date</type> are cast to "
"<type>timestamp</type> and can therefore be used as well.) "
"<replaceable>field</replaceable> is an identifier or string that selects "
"what field to extract from the source value. The <function>extract</"
"function> function returns values of type <type>double precision</type>. The "
"following are valid field names: <placeholder-1/>"
msgstr ""
"Функция <function>extract</function> получает из значений даты/времени поля, "
"такие как год или час. Здесь <replaceable>источник</replaceable> &mdash; "
"значение типа <type>timestamp</type>, <type>time</type> или <type>interval</"
"type>. (Выражения типа <type>date</type> приводятся к типу <type>timestamp</"
"type>, так что допускается и этот тип.) Указанное <replaceable>поле</"
"replaceable> представляет собой идентификатор, по которому из источника "
"выбирается заданное поле. Функция <function>extract</function> возвращает "
"значения типа <type>double precision</type>. Допустимые поля: <placeholder-1/"
">"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7856(para)
msgid ""
"When the input value is +/-Infinity, <function>extract</function> returns +/-"
"Infinity for monotonically-increasing fields (<literal>epoch</literal>, "
"<literal>julian</literal>, <literal>year</literal>, <literal>isoyear</"
"literal>, <literal>decade</literal>, <literal>century</literal>, and "
"<literal>millennium</literal>). For other fields, NULL is returned. "
"<productname>PostgreSQL</productname> versions before 9.6 returned zero for "
"all cases of infinite input."
msgstr ""
"С аргументом +/-бесконечность <function>extract</function> возвращает +/-"
"бесконечность для монотонно увеличивающихся полей (<literal>epoch</literal>, "
"<literal>julian</literal>, <literal>year</literal>, <literal>isoyear</"
"literal>, <literal>decade</literal>, <literal>century</literal> и "
"<literal>millennium</literal>). Для других полей возвращается NULL. До "
"версии 9.6 <productname>PostgreSQL</productname> возвращал ноль для всех "
"случаев с бесконечными аргументами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7866(para)
msgid ""
"The <function>extract</function> function is primarily intended for "
"computational processing. For formatting date/time values for display, see "
"<xref linkend=\"functions-formatting\"/>."
msgstr ""
"Функция <function>extract</function> в основном предназначена для "
"вычислительных целей. Функции форматирования даты/времени описаны в <xref "
"remap=\"6\" linkend=\"functions-formatting\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7872(para)
msgid ""
"The <function>date_part</function> function is modeled on the traditional "
"<productname>Ingres</productname> equivalent to the <acronym>SQL</acronym>-"
"standard function <function>extract</function>: <synopsis>\n"
"date_part('<replaceable>field</replaceable>', <replaceable>source</"
"replaceable>)\n"
"</synopsis> Note that here the <replaceable>field</replaceable> parameter "
"needs to be a string value, not a name. The valid field names for "
"<function>date_part</function> are the same as for <function>extract</"
"function>."
msgstr ""
"Функция <function>date_part</function> эмулирует традиционный для "
"<productname>Ingres</productname> эквивалент стандартной <acronym>SQL</"
"acronym>-функции <function>extract</function>: <synopsis>\n"
"date_part('<replaceable>поле</replaceable>', <replaceable>источник</"
"replaceable>)\n"
"</synopsis> Заметьте, что здесь параметр <replaceable>поле</replaceable> "
"должен быть строковым значением, а не именем. Функция <function>date_part</"
"function> воспринимает те же поля, что и <function>extract</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7890(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "4"
msgstr "4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7885(screen)
#, no-wrap
msgid ""
"SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT date_part('hour', INTERVAL '4 hours 3 minutes');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT date_part('hour', INTERVAL '4 hours 3 minutes');\n"
"<placeholder-3/><placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7896(function)
msgid "date_trunc"
msgstr "date_trunc"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7902(para)
msgid ""
"The function <function>date_trunc</function> is conceptually similar to the "
"<function>trunc</function> function for numbers."
msgstr ""
"Функция <function>date_trunc</function> работает подобно <function>trunc</"
"function> для чисел."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7907(para)
msgid ""
"<synopsis>\n"
"date_trunc('<replaceable>field</replaceable>', <replaceable>source</"
"replaceable>)\n"
"</synopsis> <replaceable>source</replaceable> is a value expression of type "
"<type>timestamp</type> or <type>interval</type>. (Values of type <type>date</"
"type> and <type>time</type> are cast automatically to <type>timestamp</type> "
"or <type>interval</type>, respectively.) <replaceable>field</replaceable> "
"selects to which precision to truncate the input value. The return value is "
"of type <type>timestamp</type> or <type>interval</type> with all fields that "
"are less significant than the selected one set to zero (or one, for day and "
"month)."
msgstr ""
"<synopsis>\n"
"date_trunc('<replaceable>поле</replaceable>', <replaceable>значение</"
"replaceable>)\n"
"</synopsis> Здесь <replaceable>значение</replaceable> &mdash; это выражение "
"типа <type>timestamp</type> или <type>interval</type>. (Значения типов "
"<type>date</type> и <type>time</type> автоматически приводятся к типам "
"<type>timestamp</type> и <type>interval</type>, соответственно.) Параметр "
"<replaceable>поле</replaceable> определяет, до какой точности обрезать "
"переданное значение. Возвращаемое значение будет иметь тип <type>timestamp</"
"type> или <type>interval</type> и все его значения, менее значимые, чем "
"заданное поле, будут равны нулю (или единице, если это номер дня или месяца)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7923(para)
msgid "Valid values for <replaceable>field</replaceable> are: <placeholder-1/>"
msgstr ""
"Параметр <replaceable>поле</replaceable> может принимать следующие значения: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7942(para)
msgid ""
"Examples: <screen>\n"
"SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"20:00:00</computeroutput>\n"
"\n"
"SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 "
"00:00:00</computeroutput>\n"
"</screen>"
msgstr ""
"Примеры: <screen>\n"
"SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"20:00:00</computeroutput>\n"
"\n"
"SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-01-01 "
"00:00:00</computeroutput>\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7955(literal)
msgid "AT TIME ZONE"
msgstr "AT TIME ZONE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7957(indexterm)
msgid "<primary>time zone</primary> <secondary>conversion</secondary>"
msgstr "<primary>часовой пояс</primary> <secondary>преобразование</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7962(indexterm)
msgid "<primary>AT TIME ZONE</primary>"
msgstr "<primary>AT TIME ZONE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7966(para)
msgid ""
"The <literal>AT TIME ZONE</literal> construct allows conversions of time "
"stamps to different time zones. <xref linkend=\"functions-datetime-"
"zoneconvert-table\"/> shows its variants."
msgstr ""
"Конструкция <literal>AT TIME ZONE</literal> позволяет переводить время в "
"разные часовые пояса. Все её разновидности показаны в <xref remap=\"6\" "
"linkend=\"functions-datetime-zoneconvert-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7974(title)
msgid "<literal>AT TIME ZONE</literal> Variants"
msgstr "Разновидности <literal>AT TIME ZONE</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7987(type) func.xml:7997(type)
msgid "timestamp without time zone"
msgstr "timestamp without time zone"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7987(replaceable) func.xml:7995(replaceable)
#: func.xml:8004(replaceable)
msgid "zone"
msgstr "часовой_пояс"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7987(literal) func.xml:7995(literal) func.xml:8004(literal)
msgid "<placeholder-1/> AT TIME ZONE <placeholder-2/>"
msgstr "<placeholder-1/> AT TIME ZONE <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7990(entry)
msgid ""
"Treat given time stamp <emphasis>without time zone</emphasis> as located in "
"the specified time zone"
msgstr ""
"Воспринимает заданное время <emphasis>без указания часового пояса</emphasis> "
"как время в указанном часовом поясе"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:7998(entry)
msgid ""
"Convert given time stamp <emphasis>with time zone</emphasis> to the new time "
"zone, with no time zone designation"
msgstr ""
"Переводит данное значение timestamp <emphasis>с часовым поясом</emphasis> в "
"другой часовой пояс, но не сохраняет информацию о нём в результате"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8007(entry)
msgid ""
"Convert given time <emphasis>with time zone</emphasis> to the new time zone"
msgstr ""
"Переводит данное время <emphasis>с часовым поясом</emphasis> в другой "
"часовой пояс"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8013(para)
msgid ""
"In these expressions, the desired time zone <replaceable>zone</replaceable> "
"can be specified either as a text string (e.g., <literal>'PST'</literal>) or "
"as an interval (e.g., <literal>INTERVAL '-08:00'</literal>). In the text "
"case, a time zone name can be specified in any of the ways described in "
"<xref linkend=\"datatype-timezones\"/>."
msgstr ""
"В этих выражениях желаемый <replaceable>часовой_пояс</replaceable> можно "
"задать либо в виде текстовой строки (например, <literal>'PST'</literal>) или "
"как интервал (например, <literal>INTERVAL '-08:00'</literal>). В первом "
"случае название часового пояса можно указать любым из способов, описанных в "
"<xref remap=\"6\" linkend=\"datatype-timezones\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8021(para)
msgid ""
"Examples (assuming the local time zone is <literal>PST8PDT</literal>): "
"<screen>\n"
"SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"19:38:40-08</computeroutput>\n"
"\n"
"SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE "
"'MST';\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"18:38:40</computeroutput>\n"
"</screen> The first example takes a time stamp without time zone and "
"interprets it as MST time (UTC-7), which is then converted to PST (UTC-8) "
"for display. The second example takes a time stamp specified in EST (UTC-5) "
"and converts it to local time in MST (UTC-7)."
msgstr ""
"Примеры (в предположении, что местный часовой пояс <literal>PST8PDT</"
"literal>): <screen>\n"
"SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"19:38:40-08</computeroutput>\n"
"\n"
"SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE "
"'MST';\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"18:38:40</computeroutput>\n"
"</screen> В первом примере время без часового пояса интерпретируется как "
"время в часовом поясе MST (UTC-7), а затем оно преобразуется в PST (UTC-8) "
"для вывода. Во втором примере время, указанное с часовым поясом EST (UTC-5), "
"преобразуется во время для часового пояса MST (UTC-7)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8035(para)
msgid ""
"The function <literal><function>timezone</function>(<replaceable>zone</"
"replaceable>, <replaceable>timestamp</replaceable>)</literal> is equivalent "
"to the SQL-conforming construct <literal><replaceable>timestamp</"
"replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>."
msgstr ""
"Функция <literal><function>timezone</function>(<replaceable>часовой_пояс</"
"replaceable>, <replaceable>время</replaceable>)</literal> равнозначна SQL-"
"совместимой конструкции <literal><replaceable>время</replaceable> AT TIME "
"ZONE <replaceable>часовой_пояс</replaceable></literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8044(title)
msgid "Current Date/Time"
msgstr "Текущая дата/время"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8046(indexterm)
msgid "<primary>date</primary> <secondary>current</secondary>"
msgstr "<primary>дата</primary> <secondary>текущая</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8051(indexterm)
msgid "<primary>time</primary> <secondary>current</secondary>"
msgstr "<primary>время</primary> <secondary>текущее</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8056(para)
msgid ""
"<productname>PostgreSQL</productname> provides a number of functions that "
"return values related to the current date and time. These SQL-standard "
"functions all return values based on the start time of the current "
"transaction: <synopsis>\n"
"CURRENT_DATE\n"
"CURRENT_TIME\n"
"CURRENT_TIMESTAMP\n"
"CURRENT_TIME(<replaceable>precision</replaceable>)\n"
"CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)\n"
"LOCALTIME\n"
"LOCALTIMESTAMP\n"
"LOCALTIME(<replaceable>precision</replaceable>)\n"
"LOCALTIMESTAMP(<replaceable>precision</replaceable>)\n"
"</synopsis>"
msgstr ""
"<productname>PostgreSQL</productname> предоставляет набор функций, результат "
"которых зависит от текущей даты и времени. Все следующие функции "
"соответствуют стандарту SQL и возвращают значения, отражающие время начала "
"текущей транзакции: <synopsis>\n"
"CURRENT_DATE\n"
"CURRENT_TIME\n"
"CURRENT_TIMESTAMP\n"
"CURRENT_TIME(<replaceable>точность</replaceable>)\n"
"CURRENT_TIMESTAMP(<replaceable>точность</replaceable>)\n"
"LOCALTIME\n"
"LOCALTIMESTAMP\n"
"LOCALTIME(<replaceable>точность</replaceable>)\n"
"LOCALTIMESTAMP(<replaceable>точность</replaceable>)\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8074(para)
msgid ""
"<function>CURRENT_TIME</function> and <function>CURRENT_TIMESTAMP</function> "
"deliver values with time zone; <function>LOCALTIME</function> and "
"<function>LOCALTIMESTAMP</function> deliver values without time zone."
msgstr ""
"<function>CURRENT_TIME</function> и <function>CURRENT_TIMESTAMP</function> "
"возвращают время с часовым поясом. В результатах <function>LOCALTIME</"
"function> и <function>LOCALTIMESTAMP</function> нет информации о часовом "
"поясе."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8081(para)
msgid ""
"<function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, "
"<function>LOCALTIME</function>, and <function>LOCALTIMESTAMP</function> can "
"optionally take a precision parameter, which causes the result to be rounded "
"to that many fractional digits in the seconds field. Without a precision "
"parameter, the result is given to the full available precision."
msgstr ""
"<function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, "
"<function>LOCALTIME</function> и <function>LOCALTIMESTAMP</function> могут "
"принимать необязательный параметр точности, определяющий, до какого знака "
"после запятой следует округлять поле секунд. Если этот параметр отсутствует, "
"результат будет иметь максимально возможную точность."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8092(para)
msgid ""
"Some examples: <screen>\n"
"SELECT CURRENT_TIME;\n"
"<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_DATE;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP(2);\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.66-05</computeroutput>\n"
"\n"
"SELECT LOCALTIMESTAMP;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522</computeroutput>\n"
"</screen>"
msgstr ""
"Несколько примеров: <screen>\n"
"SELECT CURRENT_TIME;\n"
"<lineannotation>Результат: </"
"lineannotation><computeroutput>14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_DATE;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP(2);\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.66-05</computeroutput>\n"
"\n"
"SELECT LOCALTIMESTAMP;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522</computeroutput>\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8112(para)
msgid ""
"Since these functions return the start time of the current transaction, "
"their values do not change during the transaction. This is considered a "
"feature: the intent is to allow a single transaction to have a consistent "
"notion of the <quote>current</quote> time, so that multiple modifications "
"within the same transaction bear the same time stamp."
msgstr ""
"Так как эти функции возвращают время начала текущей транзакции, во время "
"транзакции эти значения не меняются. Это считается не ошибкой, а "
"особенностью реализации: цель такого поведения в том, чтобы в одной "
"транзакции <quote>текущее</quote> время было одинаковым и для разных "
"изменений в одной транзакций записывалась одна отметка времени."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8123(para)
msgid "Other database systems might advance these values more frequently."
msgstr "В других СУБД эти значения могут изменяться чаще."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8129(para)
msgid ""
"<productname>PostgreSQL</productname> also provides functions that return "
"the start time of the current statement, as well as the actual current time "
"at the instant the function is called. The complete list of non-SQL-standard "
"time functions is: <synopsis>\n"
"transaction_timestamp()\n"
"statement_timestamp()\n"
"clock_timestamp()\n"
"timeofday()\n"
"now()\n"
"</synopsis>"
msgstr ""
"В <productname>PostgreSQL</productname> есть также функции, возвращающие "
"время начала текущего оператора, а также текущее время в момент вызова "
"функции. Таким образом, в <productname>PostgreSQL</productname> есть "
"следующие функции, не описанные в стандарте SQL: <synopsis>\n"
"transaction_timestamp()\n"
"statement_timestamp()\n"
"clock_timestamp()\n"
"timeofday()\n"
"now()\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8143(para)
msgid ""
"<function>transaction_timestamp()</function> is equivalent to "
"<function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect what "
"it returns. <function>statement_timestamp()</function> returns the start "
"time of the current statement (more specifically, the time of receipt of the "
"latest command message from the client). <function>statement_timestamp()</"
"function> and <function>transaction_timestamp()</function> return the same "
"value during the first command of a transaction, but might differ during "
"subsequent commands. <function>clock_timestamp()</function> returns the "
"actual current time, and therefore its value changes even within a single "
"SQL command. <function>timeofday()</function> is a historical "
"<productname>PostgreSQL</productname> function. Like "
"<function>clock_timestamp()</function>, it returns the actual current time, "
"but as a formatted <type>text</type> string rather than a <type>timestamp "
"with time zone</type> value. <function>now()</function> is a traditional "
"<productname>PostgreSQL</productname> equivalent to "
"<function>transaction_timestamp()</function>."
msgstr ""
"Функция <function>transaction_timestamp()</function> равнозначна конструкции "
"<function>CURRENT_TIMESTAMP</function>, но в её названии явно отражено, что "
"она возвращает. Функция <function>statement_timestamp()</function> "
"возвращает время начала текущего оператора (более точно, время получения "
"последнего командного сообщения от клиента). Функции "
"<function>statement_timestamp()</function> и "
"<function>transaction_timestamp()</function> возвращают одно и то же "
"значение в первой команде транзакции, но в последующих их показания будут "
"расходиться. Функция <function>clock_timestamp()</function> возвращает "
"фактическое текущее время, так что её значение меняется в рамках одной "
"команды SQL. Функция <function>timeofday()</function> существует в "
"<productname>PostgreSQL</productname> по историческим причинам и, подобно "
"<function>clock_timestamp()</function>, она возвращает фактическое текущее "
"время, но представленное в виде форматированной строки типа <type>text</"
"type>, а не значения <type>timestamp with time zone</type>. Функция "
"<function>now()</function> &mdash; традиционный для <productname>PostgreSQL</"
"productname> эквивалент функции <function>transaction_timestamp()</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8169(programlisting)
#, no-wrap
msgid ""
"SELECT CURRENT_TIMESTAMP;\n"
"SELECT now();\n"
"SELECT TIMESTAMP 'now';  -- incorrect for use with DEFAULT"
msgstr ""
"SELECT CURRENT_TIMESTAMP;\n"
"SELECT now();\n"
"SELECT TIMESTAMP 'now';  -- не подходит для DEFAULT"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8164(para)
msgid ""
"All the date/time data types also accept the special literal value "
"<literal>now</literal> to specify the current date and time (again, "
"interpreted as the transaction start time). Thus, the following three all "
"return the same result: <placeholder-1/>"
msgstr ""
"Все типы даты/времени также принимают специальное буквальное значение "
"<literal>now</literal>, подразумевающее текущую дату и время (тоже на момент "
"начала транзакции). Таким образом, результат следующих трёх операторов будет "
"одинаковым: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8177(para)
msgid ""
"You do not want to use the third form when specifying a <literal>DEFAULT</"
"literal> clause while creating a table. The system will convert "
"<literal>now</literal> to a <type>timestamp</type> as soon as the constant "
"is parsed, so that when the default value is needed, the time of the table "
"creation would be used! The first two forms will not be evaluated until the "
"default value is used, because they are function calls. Thus they will give "
"the desired behavior of defaulting to the time of row insertion."
msgstr ""
"Третья форма не подходит для указания в качестве значения <literal>DEFAULT</"
"literal> при создании таблицы. Система преобразует <literal>now</literal> в "
"значение <type>timestamp</type> в момент разбора константы, поэтому, когда "
"будет вставляться значение по умолчанию, в соответствующем столбце окажется "
"время создания таблицы! Первые две формы не будут вычисляться, пока не "
"потребуется значение по умолчанию, так как это вызовы функции. Поэтому они "
"дадут желаемый результат при добавлении строки в таблицу."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8191(title)
msgid "Delaying Execution"
msgstr "Задержка выполнения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8193(indexterm)
msgid "<primary>pg_sleep</primary>"
msgstr "<primary>pg_sleep</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8196(indexterm)
msgid "<primary>pg_sleep_for</primary>"
msgstr "<primary>pg_sleep_for</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8199(indexterm)
msgid "<primary>pg_sleep_until</primary>"
msgstr "<primary>pg_sleep_until</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8202(indexterm)
msgid "<primary>sleep</primary>"
msgstr "<primary>sleep</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8205(indexterm)
msgid "<primary>delay</primary>"
msgstr "<primary>задержка</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8228(programlisting)
#, no-wrap
msgid ""
"SELECT pg_sleep(1.5);\n"
"SELECT pg_sleep_for('5 minutes');\n"
"SELECT pg_sleep_until('tomorrow 03:00');"
msgstr ""
"SELECT pg_sleep(1.5);\n"
"SELECT pg_sleep_for('5 minutes');\n"
"SELECT pg_sleep_until('tomorrow 03:00');"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8209(para)
msgid ""
"The following functions are available to delay execution of the server "
"process: <synopsis>\n"
"pg_sleep(<replaceable>seconds</replaceable>)\n"
"pg_sleep_for(<type>interval</type>)\n"
"pg_sleep_until(<type>timestamp with time zone</type>)\n"
"</synopsis> <function>pg_sleep</function> makes the current session's "
"process sleep until <replaceable>seconds</replaceable> seconds have elapsed. "
"<replaceable>seconds</replaceable> is a value of type <type>double "
"precision</type>, so fractional-second delays can be specified. "
"<function>pg_sleep_for</function> is a convenience function for larger sleep "
"times specified as an <type>interval</type>. <function>pg_sleep_until</"
"function> is a convenience function for when a specific wake-up time is "
"desired. For example: <placeholder-1/>"
msgstr ""
"В случае необходимости вы можете приостановить выполнение серверного "
"процесса, используя следующие функции: <synopsis>\n"
"pg_sleep(<replaceable>сек</replaceable>)\n"
"pg_sleep_for(<type>interval</type>)\n"
"pg_sleep_until(<type>timestamp with time zone</type>)\n"
"</synopsis> Функция <function>pg_sleep</function> переводит процесс текущего "
"сеанса в спящее состояние на указанное число секунд (<replaceable>сек</"
"replaceable>). Параметр <replaceable>сек</replaceable> имеет тип "
"<type>double precision</type>, так что в нём можно указать и дробное число. "
"Функция <function>pg_sleep_for</function> введена для удобства, ей можно "
"передать большие значения задержки в типе <type>interval</type>. А "
"<function>pg_sleep_until</function> удобнее использовать, когда необходимо "
"задать определённое время выхода из спящего состояния. Например: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8236(para)
msgid ""
"The effective resolution of the sleep interval is platform-specific; 0.01 "
"seconds is a common value. The sleep delay will be at least as long as "
"specified. It might be longer depending on factors such as server load. In "
"particular, <function>pg_sleep_until</function> is not guaranteed to wake up "
"exactly at the specified time, but it will not wake up any earlier."
msgstr ""
"Действительное разрешение интервала задержки зависит от платформы; обычно "
"это 0.01. Фактическая длительность задержки не будет меньше указанного "
"времени, но может быть больше, в зависимости, например от нагрузки на "
"сервер. В частности, не гарантируется, что <function>pg_sleep_until</"
"function> проснётся именно в указанное время, но она точно не проснётся "
"раньше."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8246(para)
msgid ""
"Make sure that your session does not hold more locks than necessary when "
"calling <function>pg_sleep</function> or its variants. Otherwise other "
"sessions might have to wait for your sleeping process, slowing down the "
"entire system."
msgstr ""
"Прежде чем вызывать <function>pg_sleep</function> или её вариации, убедитесь "
"в том, что в текущем сеансе нет ненужных блокировок. В противном случае в "
"состояние ожидания могут перейти и другие сеансы, так что это отразится на "
"системе в целом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8259(title) func.xml:8275(title)
msgid "Enum Support Functions"
msgstr "Функции для перечислений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8268(programlisting)
#, no-wrap
msgid "CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');"
msgstr ""
"CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green',\n"
" 'blue', 'purple');"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8261(para)
msgid ""
"For enum types (described in <xref linkend=\"datatype-enum\"/>), there are "
"several functions that allow cleaner programming without hard-coding "
"particular values of an enum type. These are listed in <xref linkend="
"\"functions-enum-table\"/>. The examples assume an enum type created as: "
"<placeholder-1/>"
msgstr ""
"Для типов перечислений (описанных в <xref remap=\"6\" linkend=\"datatype-enum"
"\"/>) предусмотрено несколько функций, которые позволяют сделать код чище, "
"не &laquo;зашивая&raquo; в нём конкретные значения перечисления. Эти функции "
"перечислены в <xref remap=\"6\" linkend=\"functions-enum-table\"/>. В этих "
"примерах подразумевается, что перечисление создано так: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8288(indexterm)
msgid "<primary>enum_first</primary>"
msgstr "<primary>enum_first</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8291(literal)
msgid "enum_first(anyenum)"
msgstr "enum_first(anyenum)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8293(entry)
msgid "Returns the first value of the input enum type"
msgstr "Возвращает первое значение заданного перечисления"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8294(literal)
msgid "enum_first(null::rainbow)"
msgstr "enum_first(null::rainbow)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8295(literal)
msgid "red"
msgstr "red"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8299(indexterm)
msgid "<primary>enum_last</primary>"
msgstr "<primary>enum_last</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8302(literal)
msgid "enum_last(anyenum)"
msgstr "enum_last(anyenum)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8304(entry)
msgid "Returns the last value of the input enum type"
msgstr "Возвращает последнее значение заданного перечисления"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8305(literal)
msgid "enum_last(null::rainbow)"
msgstr "enum_last(null::rainbow)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8306(literal)
msgid "purple"
msgstr "purple"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8310(indexterm)
msgid "<primary>enum_range</primary>"
msgstr "<primary>enum_range</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8313(literal)
msgid "enum_range(anyenum)"
msgstr "enum_range(anyenum)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8315(entry)
msgid "Returns all values of the input enum type in an ordered array"
msgstr "Возвращает все значения заданного перечисления в упорядоченном массиве"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8316(literal)
msgid "enum_range(null::rainbow)"
msgstr "enum_range(null::rainbow)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8317(literal)
msgid "{red,orange,yellow,green,blue,purple}"
msgstr "{red,orange,yellow,green,blue,purple}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8320(literal)
msgid "enum_range(anyenum, anyenum)"
msgstr "enum_range(anyenum, anyenum)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8321(entry)
msgid ""
"Returns the range between the two given enum values, as an ordered array. "
"The values must be from the same enum type. If the first parameter is null, "
"the result will start with the first value of the enum type. If the second "
"parameter is null, the result will end with the last value of the enum type."
msgstr ""
"Возвращает набор значений, лежащих между двумя заданными, в виде "
"упорядоченного массива. Эти значения должны принадлежать одному "
"перечислению. Если первый параметр равен NULL, функция возвращает первое "
"значение перечисления, а если NULL второй &mdash; последнее."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8329(literal)
msgid "enum_range('orange'::rainbow, 'green'::rainbow)"
msgstr "enum_range('orange'::rainbow, 'green'::rainbow)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8330(literal)
msgid "{orange,yellow,green}"
msgstr "{orange,yellow,green}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8333(literal)
msgid "enum_range(NULL, 'green'::rainbow)"
msgstr "enum_range(NULL, 'green'::rainbow)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8334(literal)
msgid "{red,orange,yellow,green}"
msgstr "{red,orange,yellow,green}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8337(literal)
msgid "enum_range('orange'::rainbow, NULL)"
msgstr "enum_range('orange'::rainbow, NULL)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8338(literal)
msgid "{orange,yellow,green,blue,purple}"
msgstr "{orange,yellow,green,blue,purple}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8344(para)
msgid ""
"Notice that except for the two-argument form of <function>enum_range</"
"function>, these functions disregard the specific value passed to them; they "
"care only about its declared data type. Either null or a specific value of "
"the type can be passed, with the same result. It is more common to apply "
"these functions to a table column or function argument than to a hardwired "
"type name as suggested by the examples."
msgstr ""
"Заметьте, что за исключением варианта <function>enum_range</function> с "
"двумя аргументами, эти функции не обращают внимание на конкретное переданное "
"им значение; их интересует только объявленный тип. Они возвращают один и тот "
"же результат, когда им передаётся NULL или любое другое значение типа. "
"Обычно эти функции применяются к столбцам таблицы или аргументам внешних "
"функций, а не к предопределённым типам, как показано в этих примерах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8355(title)
msgid "Geometric Functions and Operators"
msgstr "Геометрические функции и операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8357(para)
msgid ""
"The geometric types <type>point</type>, <type>box</type>, <type>lseg</type>, "
"<type>line</type>, <type>path</type>, <type>polygon</type>, and "
"<type>circle</type> have a large set of native support functions and "
"operators, shown in <xref linkend=\"functions-geometry-op-table\"/>, <xref "
"linkend=\"functions-geometry-func-table\"/>, and <xref linkend=\"functions-"
"geometry-conv-table\"/>."
msgstr ""
"Для геометрических типов <type>point</type>, <type>box</type>, <type>lseg</"
"type>, <type>line</type>, <type>path</type>, <type>polygon</type> и "
"<type>circle</type> разработан большой набор встроенных функций и "
"операторов, представленный в <xref remap=\"6\" linkend=\"functions-geometry-"
"op-table\"/>, <xref remap=\"6\" linkend=\"functions-geometry-func-table\"/> "
"и <xref remap=\"6\" linkend=\"functions-geometry-conv-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8368(para)
msgid ""
"Note that the <quote>same as</quote> operator, <literal>~=</literal>, "
"represents the usual notion of equality for the <type>point</type>, "
"<type>box</type>, <type>polygon</type>, and <type>circle</type> types. Some "
"of these types also have an <literal>=</literal> operator, but <literal>=</"
"literal> compares for equal <emphasis>areas</emphasis> only. The other "
"scalar comparison operators (<literal>&lt;=</literal> and so on) likewise "
"compare areas for these types."
msgstr ""
"Заметьте, что оператор <quote>идентичности</quote>, <literal>~=</literal>, "
"представляет обычное сравнение на равенство значений <type>point</type>, "
"<type>box</type>, <type>polygon</type> и <type>circle</type>. Для некоторых "
"из этих типов определён также оператор <literal>=</literal>, но <literal>=</"
"literal> проверяет только равенство <emphasis>площадей</emphasis>. Другие "
"скалярные операторы сравнения (<literal>&lt;=</literal> и т. д.) так же "
"сравнивают площади значений этих типов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8380(title)
msgid "Geometric Operators"
msgstr "Геометрические операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8392(entry) func.xml:8397(entry)
msgid "Translation"
msgstr "Сдвиг"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8393(literal)
msgid "box '((0,0),(1,1))' + point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' + point '(2.0,0)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8398(literal)
msgid "box '((0,0),(1,1))' - point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' - point '(2.0,0)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8402(entry) func.xml:8407(entry)
msgid "Scaling/rotation"
msgstr "Масштабирование/поворот"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8403(literal)
msgid "box '((0,0),(1,1))' * point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' * point '(2.0,0)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8408(literal)
msgid "box '((0,0),(2,2))' / point '(2.0,0)'"
msgstr "box '((0,0),(2,2))' / point '(2.0,0)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8412(entry)
msgid "Point or box of intersection"
msgstr "Точка или прямоугольник в пересечении"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8413(literal)
msgid "box '((1,-1),(-1,1))' # box '((1,1),(-2,-2))'"
msgstr "box '((1,-1),(-1,1))' # box '((1,1),(-2,-2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8417(entry)
msgid "Number of points in path or polygon"
msgstr "Число точек в пути или вершин в многоугольнике"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8418(literal)
msgid "# path '((1,0),(0,1),(-1,0))'"
msgstr "# path '((1,0),(0,1),(-1,0))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8421(literal)
msgid "@-@"
msgstr "@-@"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8422(entry)
msgid "Length or circumference"
msgstr "Длина, периметр или длина окружности"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8423(literal)
msgid "@-@ path '((0,0),(1,0))'"
msgstr "@-@ path '((0,0),(1,0))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8426(literal) func.xml:9357(literal)
msgid "@@"
msgstr "@@"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8427(entry)
msgid "Center"
msgstr "Центр"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8428(literal)
msgid "@@ circle '((0,0),10)'"
msgstr "@@ circle '((0,0),10)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8431(literal)
msgid "##"
msgstr "##"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8432(entry)
msgid "Closest point to first operand on second operand"
msgstr "Точка, ближайшая к первому операнду и принадлежащая второму"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8433(literal)
msgid "point '(0,0)' ## lseg '((2,0),(0,2))'"
msgstr "point '(0,0)' ## lseg '((2,0),(0,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8436(literal) func.xml:9399(literal)
msgid "&lt;-&gt;"
msgstr "&lt;-&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8437(entry)
msgid "Distance between"
msgstr "Расстояние между операндами"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8438(literal)
msgid "circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'"
msgstr "circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8441(literal) func.xml:8977(literal) func.xml:9378(literal)
#: func.xml:12502(literal) func.xml:12991(literal)
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8442(entry)
msgid "Overlaps? (One point in common makes this true.)"
msgstr ""
"Пересекаются ли операнды? (Для положительного ответа достаточно одной общей "
"точки.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8443(literal)
msgid "box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8447(entry)
msgid "Is strictly left of?"
msgstr "Строго слева?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8448(literal)
msgid "circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'"
msgstr "circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8452(entry)
msgid "Is strictly right of?"
msgstr "Строго справа?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8453(literal)
msgid "circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'"
msgstr "circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8456(literal) func.xml:13012(literal)
msgid "&amp;&lt;"
msgstr "&amp;&lt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8457(entry)
msgid "Does not extend to the right of?"
msgstr "Не простирается правее?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8458(literal)
msgid "box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8461(literal) func.xml:13019(literal)
msgid "&amp;&gt;"
msgstr "&amp;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8462(entry)
msgid "Does not extend to the left of?"
msgstr "Не простирается левее?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8463(literal)
msgid "box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8466(literal)
msgid "&lt;&lt;|"
msgstr "&lt;&lt;|"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8467(entry)
msgid "Is strictly below?"
msgstr "Строго ниже?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8468(literal)
msgid "box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'"
msgstr "box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8471(literal)
msgid "|&gt;&gt;"
msgstr "|&gt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8472(entry)
msgid "Is strictly above?"
msgstr "Строго выше?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8473(literal)
msgid "box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'"
msgstr "box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8476(literal)
msgid "&amp;&lt;|"
msgstr "&amp;&lt;|"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8477(entry)
msgid "Does not extend above?"
msgstr "Не простирается выше?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8478(literal)
msgid "box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8481(literal)
msgid "|&amp;&gt;"
msgstr "|&amp;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8482(entry)
msgid "Does not extend below?"
msgstr "Не простирается ниже?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8483(literal)
msgid "box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8486(literal)
msgid "&lt;^"
msgstr "&lt;^"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8487(entry)
msgid "Is below (allows touching)?"
msgstr "Ниже (может касаться)?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8488(literal)
msgid "circle '((0,0),1)' &lt;^ circle '((0,5),1)'"
msgstr "circle '((0,0),1)' &lt;^ circle '((0,5),1)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8491(literal)
msgid "&gt;^"
msgstr "&gt;^"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8492(entry)
msgid "Is above (allows touching)?"
msgstr "Выше (может касаться)?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8493(literal)
msgid "circle '((0,5),1)' &gt;^ circle '((0,0),1)'"
msgstr "circle '((0,5),1)' &gt;^ circle '((0,0),1)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8496(literal)
msgid "?#"
msgstr "?#"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8497(entry)
msgid "Intersects?"
msgstr "Пересекает?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8498(literal)
msgid "lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'"
msgstr "lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8501(literal) func.xml:8506(literal)
msgid "?-"
msgstr "?-"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8502(entry)
msgid "Is horizontal?"
msgstr "Горизонтальный объект?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8503(literal)
msgid "?- lseg '((-1,0),(1,0))'"
msgstr "?- lseg '((-1,0),(1,0))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8507(entry)
msgid "Are horizontally aligned?"
msgstr "Выровнены по горизонтали?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8508(literal)
msgid "point '(1,0)' ?- point '(0,0)'"
msgstr "point '(1,0)' ?- point '(0,0)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8511(literal) func.xml:8516(literal) func.xml:11168(literal)
msgid "?|"
msgstr "?|"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8512(entry)
msgid "Is vertical?"
msgstr "Вертикальный объект?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8513(literal)
msgid "?| lseg '((-1,0),(1,0))'"
msgstr "?| lseg '((-1,0),(1,0))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8517(entry)
msgid "Are vertically aligned?"
msgstr "Выровнены по вертикали?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8518(literal)
msgid "point '(0,1)' ?| point '(0,0)'"
msgstr "point '(0,1)' ?| point '(0,0)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8521(literal)
msgid "?-|"
msgstr "?-|"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8522(entry)
msgid "Is perpendicular?"
msgstr "Перпендикулярны?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8523(literal)
msgid "lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'"
msgstr "lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8526(literal)
msgid "?||"
msgstr "?||"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8527(entry)
msgid "Are parallel?"
msgstr "Параллельны?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8528(literal)
msgid "lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'"
msgstr "lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8531(literal) func.xml:9406(literal) func.xml:11147(literal)
#: func.xml:12488(literal) func.xml:12963(literal) func.xml:12970(literal)
msgid "@&gt;"
msgstr "@&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8532(entry)
msgid "Contains?"
msgstr "Первый объект включает второй?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8533(literal)
msgid "circle '((0,0),2)' @&gt; point '(1,1)'"
msgstr "circle '((0,0),2)' @&gt; point '(1,1)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8536(literal) func.xml:9413(literal) func.xml:11154(literal)
#: func.xml:12495(literal) func.xml:12977(literal) func.xml:12984(literal)
msgid "&lt;@"
msgstr "&lt;@"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8537(entry)
msgid "Contained in or on?"
msgstr "Первый объект включён во второй?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8538(literal)
msgid "point '(1,1)' &lt;@ circle '((0,0),2)'"
msgstr "point '(1,1)' &lt;@ circle '((0,0),2)'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8541(literal)
msgid "~="
msgstr "~="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8542(entry)
msgid "Same as?"
msgstr "Одинаковы?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8543(literal)
msgid "polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'"
msgstr "polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8550(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.2, the containment operators "
"<literal>@&gt;</literal> and <literal>&lt;@</literal> were respectively "
"called <literal>~</literal> and <literal>@</literal>. These names are still "
"available, but are deprecated and will eventually be removed."
msgstr ""
"До <productname>PostgreSQL</productname> 8.2 операторы включения "
"<literal>@&gt;</literal> и <literal>&lt;@</literal> назывались "
"соответственно <literal>~</literal> и <literal>@</literal>. Эти имена по-"
"прежнему доступны, но считаются устаревшими и в конце концов будут удалены."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8558(indexterm)
msgid "<primary>area</primary>"
msgstr "<primary>area</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8561(indexterm)
msgid "<primary>center</primary>"
msgstr "<primary>center</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8564(indexterm)
msgid "<primary>diameter</primary>"
msgstr "<primary>diameter</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8567(indexterm)
msgid "<primary>height</primary>"
msgstr "<primary>height</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8570(indexterm)
msgid "<primary>isclosed</primary>"
msgstr "<primary>isclosed</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8573(indexterm)
msgid "<primary>isopen</primary>"
msgstr "<primary>isopen</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8579(indexterm)
msgid "<primary>npoints</primary>"
msgstr "<primary>npoints</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8582(indexterm)
msgid "<primary>pclose</primary>"
msgstr "<primary>pclose</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8585(indexterm)
msgid "<primary>popen</primary>"
msgstr "<primary>popen</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8588(indexterm)
msgid "<primary>radius</primary>"
msgstr "<primary>radius</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8591(indexterm)
msgid "<primary>width</primary>"
msgstr "<primary>width</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8596(title)
msgid "Geometric Functions"
msgstr "Геометрические функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8608(replaceable) func.xml:8614(replaceable)
#: func.xml:8644(replaceable)
msgid "object"
msgstr "объект"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8608(function)
msgid "area(<placeholder-1/>)"
msgstr "area(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8610(entry)
msgid "area"
msgstr "площадь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8611(literal)
msgid "area(box '((0,0),(1,1))')"
msgstr "area(box '((0,0),(1,1))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8614(function)
msgid "center(<placeholder-1/>)"
msgstr "center(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8615(type) func.xml:8722(type) func.xml:8728(type)
#: func.xml:8757(type) func.xml:8769(type) func.xml:8786(type)
#: func.xml:8810(type) func.xml:8816(type) func.xml:8822(type)
#: func.xml:8828(type) func.xml:8834(type)
msgctxt "type"
msgid "point"
msgstr "point"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8616(entry)
msgid "center"
msgstr "центр"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8617(literal)
msgid "center(box '((0,0),(1,2))')"
msgstr "center(box '((0,0),(1,2))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8620(type) func.xml:8683(type) func.xml:8715(type)
#: func.xml:8752(type) func.xml:8758(type) func.xml:8764(type)
#: func.xml:8821(type) func.xml:8850(type) func.xml:8856(type)
msgid "circle"
msgstr "circle"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8620(function)
msgid "diameter(<placeholder-1/>)"
msgstr "diameter(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8622(entry)
msgid "diameter of circle"
msgstr "диаметр круга"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8623(literal)
msgid "diameter(circle '((0,0),2.0)')"
msgstr "diameter(circle '((0,0),2.0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8626(type) func.xml:8689(type) func.xml:8717(type)
#: func.xml:8723(type) func.xml:8729(type) func.xml:8735(type)
#: func.xml:8740(type) func.xml:8741(type) func.xml:8750(type)
#: func.xml:8779(type) func.xml:8815(type) func.xml:8843(type)
msgid "box"
msgstr "box"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8626(function)
msgid "height(<placeholder-1/>)"
msgstr "height(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8628(entry)
msgid "vertical size of box"
msgstr "вертикальный размер прямоугольника"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8629(literal)
msgid "height(box '((0,0),(1,1))')"
msgstr "height(box '((0,0),(1,1))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8632(type) func.xml:8638(type) func.xml:8650(type)
#: func.xml:8662(type) func.xml:8663(type) func.xml:8677(type)
#: func.xml:8678(type) func.xml:8798(type) func.xml:8862(type)
msgid "path"
msgstr "path"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8632(function)
msgid "isclosed(<placeholder-1/>)"
msgstr "isclosed(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8634(entry)
msgid "a closed path?"
msgstr "замкнутый путь?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8635(literal)
msgid "isclosed(path '((0,0),(1,1),(2,0))')"
msgstr "isclosed(path '((0,0),(1,1),(2,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8638(function)
msgid "isopen(<placeholder-1/>)"
msgstr "isopen(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8640(entry)
msgid "an open path?"
msgstr "открытый путь?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8641(literal)
msgid "isopen(path '[(0,0),(1,1),(2,0)]')"
msgstr "isopen(path '[(0,0),(1,1),(2,0)]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8646(entry)
msgctxt "entry"
msgid "length"
msgstr "длина"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8647(literal)
msgid "length(path '((-1,0),(1,0))')"
msgstr "length(path '((-1,0),(1,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8650(function) func.xml:8656(function)
msgid "npoints(<placeholder-1/>)"
msgstr "npoints(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8652(entry) func.xml:8658(entry)
msgid "number of points"
msgstr "число точек"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8653(literal)
msgid "npoints(path '[(0,0),(1,1),(2,0)]')"
msgstr "npoints(path '[(0,0),(1,1),(2,0)]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8656(type) func.xml:8734(type) func.xml:8763(type)
#: func.xml:8796(type) func.xml:8833(type) func.xml:8845(type)
#: func.xml:8851(type) func.xml:8857(type) func.xml:8863(type)
msgid "polygon"
msgstr "polygon"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8659(literal)
msgid "npoints(polygon '((1,1),(0,0))')"
msgstr "npoints(polygon '((1,1),(0,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8662(function)
msgid "pclose(<placeholder-1/>)"
msgstr "pclose(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8664(entry)
msgid "convert path to closed"
msgstr "преобразует путь в замкнутый"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8665(literal)
msgid "pclose(path '[(0,0),(1,1),(2,0)]')"
msgstr "pclose(path '[(0,0),(1,1),(2,0)]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8677(function)
msgid "popen(<placeholder-1/>)"
msgstr "popen(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8679(entry)
msgid "convert path to open"
msgstr "преобразует путь в открытый"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8680(literal)
msgid "popen(path '((0,0),(1,1),(2,0))')"
msgstr "popen(path '((0,0),(1,1),(2,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8683(function)
msgid "radius(<placeholder-1/>)"
msgstr "radius(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8685(entry)
msgid "radius of circle"
msgstr "радиус окружности"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8686(literal)
msgid "radius(circle '((0,0),2.0)')"
msgstr "radius(circle '((0,0),2.0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8689(function)
msgid "width(<placeholder-1/>)"
msgstr "width(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8691(entry)
msgid "horizontal size of box"
msgstr "горизонтальный размер прямоугольника"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8692(literal)
msgid "width(box '((0,0),(1,1))')"
msgstr "width(box '((0,0),(1,1))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8699(title)
msgid "Geometric Type Conversion Functions"
msgstr "Функции преобразования геометрических типов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8712(indexterm)
msgid "<primary>box</primary>"
msgstr "<primary>box</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8715(function) func.xml:8722(function) func.xml:8734(function)
msgid "box(<placeholder-1/>)"
msgstr "box(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8718(entry)
msgid "circle to box"
msgstr "окружность в прямоугольник"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8719(literal)
msgid "box(circle '((0,0),2.0)')"
msgstr "box(circle '((0,0),2.0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8724(entry)
msgid "point to empty box"
msgstr "точка в пустой прямоугольник"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8725(literal)
msgid "box(point '(0,0)')"
msgstr "box(point '(0,0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8728(function)
msgid "box(<placeholder-1/>, <placeholder-2/>)"
msgstr "box(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8730(entry)
msgid "points to box"
msgstr "точки в прямоугольник"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8731(literal)
msgid "box(point '(0,0)', point '(1,1)')"
msgstr "box(point '(0,0)', point '(1,1)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8736(entry)
msgid "polygon to box"
msgstr "многоугольник в прямоугольник"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8737(literal)
msgid "box(polygon '((0,0),(1,1),(2,0))')"
msgstr "box(polygon '((0,0),(1,1),(2,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8740(function)
msgid "bound_box(<placeholder-1/>, <placeholder-2/>)"
msgstr "bound_box(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8742(entry)
msgid "boxes to bounding box"
msgstr "прямоугольники в окружающий прямоугольник"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8743(literal)
msgid "bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')"
msgstr "bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8747(indexterm)
msgid "<primary>circle</primary>"
msgstr "<primary>круг</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8750(function) func.xml:8763(function)
msgid "circle(<placeholder-1/>)"
msgstr "circle(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8753(entry)
msgid "box to circle"
msgstr "прямоугольник в окружность"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8754(literal)
msgid "circle(box '((0,0),(1,1))')"
msgstr "circle(box '((0,0),(1,1))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8757(function)
msgid "circle(<placeholder-1/>, <placeholder-2/>)"
msgstr "circle(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8759(entry)
msgid "center and radius to circle"
msgstr "окружность из центра и радиуса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8760(literal)
msgid "circle(point '(0,0)', 2.0)"
msgstr "circle(point '(0,0)', 2.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8765(entry)
msgid "polygon to circle"
msgstr "многоугольник в окружность"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8766(literal)
msgid "circle(polygon '((0,0),(1,1),(2,0))')"
msgstr "circle(polygon '((0,0),(1,1),(2,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8769(function)
msgid "line(<placeholder-1/>, <placeholder-2/>)"
msgstr "line(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8770(type)
msgid "line"
msgstr "line"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8771(entry)
msgid "points to line"
msgstr "точки в прямую"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8772(literal)
msgid "line(point '(-1,0)', point '(1,0)')"
msgstr "line(point '(-1,0)', point '(1,0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8776(indexterm)
msgid "<primary>lseg</primary>"
msgstr "<primary>lseg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8779(function)
msgid "lseg(<placeholder-1/>)"
msgstr "lseg(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8781(type) func.xml:8787(type) func.xml:8827(type)
msgid "lseg"
msgstr "lseg"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8782(entry)
msgid "box diagonal to line segment"
msgstr "диагональ прямоугольника в отрезок"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8783(literal)
msgid "lseg(box '((-1,0),(1,0))')"
msgstr "lseg(box '((-1,0),(1,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8786(function)
msgid "lseg(<placeholder-1/>, <placeholder-2/>)"
msgstr "lseg(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8788(entry)
msgid "points to line segment"
msgstr "точки в отрезок"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8789(literal)
msgid "lseg(point '(-1,0)', point '(1,0)')"
msgstr "lseg(point '(-1,0)', point '(1,0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8793(indexterm)
msgid "<primary>path</primary>"
msgstr "<primary>path</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8796(function)
msgid "path(<placeholder-1/>)"
msgstr "path(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8799(entry)
msgid "polygon to path"
msgstr "многоугольник в путь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8800(literal)
msgid "path(polygon '((0,0),(1,1),(2,0))')"
msgstr "path(polygon '((0,0),(1,1),(2,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8804(indexterm)
msgid "<primary>point</primary>"
msgstr "<primary>точка</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8807(function)
msgctxt "function"
msgid "point"
msgstr "point"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8811(entry)
msgid "construct point"
msgstr "образует точку"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8812(literal)
msgid "point(23.4, -44.5)"
msgstr "point(23.4, -44.5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8815(function) func.xml:8821(function) func.xml:8827(function)
#: func.xml:8833(function)
msgid "point(<placeholder-1/>)"
msgstr "point(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8817(entry)
msgid "center of box"
msgstr "центр прямоугольника"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8818(literal)
msgid "point(box '((-1,0),(1,0))')"
msgstr "point(box '((-1,0),(1,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8823(entry)
msgid "center of circle"
msgstr "центр окружности"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8824(literal)
msgid "point(circle '((0,0),2.0)')"
msgstr "point(circle '((0,0),2.0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8829(entry)
msgid "center of line segment"
msgstr "центр отрезка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8830(literal)
msgid "point(lseg '((-1,0),(1,0))')"
msgstr "point(lseg '((-1,0),(1,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8835(entry)
msgid "center of polygon"
msgstr "центр многоугольника"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8836(literal)
msgid "point(polygon '((0,0),(1,1),(2,0))')"
msgstr "point(polygon '((0,0),(1,1),(2,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8840(indexterm)
msgid "<primary>polygon</primary>"
msgstr "<primary>многоугольник</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8843(function) func.xml:8850(function) func.xml:8862(function)
msgid "polygon(<placeholder-1/>)"
msgstr "polygon(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8846(entry)
msgid "box to 4-point polygon"
msgstr "прямоугольник в многоугольник с 4 вершинами"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8847(literal)
msgid "polygon(box '((0,0),(1,1))')"
msgstr "polygon(box '((0,0),(1,1))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8852(entry)
msgid "circle to 12-point polygon"
msgstr "круг в многоугольник с 12 вершинами"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8853(literal)
msgid "polygon(circle '((0,0),2.0)')"
msgstr "polygon(circle '((0,0),2.0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8856(replaceable)
msgid "npts"
msgstr "число_точек"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8856(function)
msgid "polygon(<placeholder-1/>, <placeholder-2/>)"
msgstr "polygon(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8858(entry)
msgid ""
"circle to <replaceable class=\"parameter\">npts</replaceable>-point polygon"
msgstr ""
"окружность с заданным <replaceable class=\"parameter\">числом_точек</"
"replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8859(literal)
msgid "polygon(12, circle '((0,0),2.0)')"
msgstr "polygon(12, circle '((0,0),2.0)')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8864(entry)
msgid "path to polygon"
msgstr "путь в многоугольник"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8865(literal)
msgid "polygon(path '((0,0),(1,1),(2,0))')"
msgstr "polygon(path '((0,0),(1,1),(2,0))')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8871(para)
msgid ""
"It is possible to access the two component numbers of a <type>point</type> "
"as though the point were an array with indexes 0 and 1. For example, if "
"<literal>t.p</literal> is a <type>point</type> column then <literal>SELECT "
"p[0] FROM t</literal> retrieves the X coordinate and <literal>UPDATE t SET "
"p[1] = ...</literal> changes the Y coordinate. In the same way, a value of "
"type <type>box</type> or <type>lseg</type> can be treated as an array of two "
"<type>point</type> values."
msgstr ""
"К двум компонентам типа <type>point</type> (точка) можно обратиться, как к "
"элементам массива с индексами 0 и 1. Например, если <literal>t.p</literal> "
"&mdash; столбец типа <type>point</type>, <literal>SELECT p[0] FROM t</"
"literal> вернёт координату X, а <literal>UPDATE t SET p[1] = ...</literal> "
"изменит координату Y. Таким же образом, значение типа <type>box</type> или "
"<type>lseg</type> можно воспринимать как массив двух значений типа "
"<type>point</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8881(para)
msgid ""
"The <function>area</function> function works for the types <type>box</type>, "
"<type>circle</type>, and <type>path</type>. The <function>area</function> "
"function only works on the <type>path</type> data type if the points in the "
"<type>path</type> are non-intersecting. For example, the <type>path</type> "
"<literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal> will "
"not work; however, the following visually identical <type>path</type> "
"<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</"
"literal> will work. If the concept of an intersecting versus non-"
"intersecting <type>path</type> is confusing, draw both of the above "
"<type>path</type>s side by side on a piece of graph paper."
msgstr ""
"Функция <function>area</function> работает с типами <type>box</type>, "
"<type>circle</type> и <type>path</type>. При этом для типа <type>path</type> "
"заданный путь не должен быть самопересекающимся. Например, эта функция не "
"примет значение типа <type>path</type> <literal>'((0,0),(0,1),(2,1),(2,2),"
"(1,2),(1,0),(0,0))'::PATH</literal>, но примет визуально идентичный путь "
"<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</"
"literal>. Если вы не вполне поняли, что здесь подразумевается под "
"самопересечением пути, нарисуйте на бумаге две фигуры по приведённым "
"координатам."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8901(title)
msgid "Network Address Functions and Operators"
msgstr "Функции и операторы для работы с сетевыми адресами"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8903(para)
msgid ""
"<xref linkend=\"cidr-inet-operators-table\"/> shows the operators available "
"for the <type>cidr</type> and <type>inet</type> types. The operators "
"<literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;"
"</literal>, <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal> "
"test for subnet inclusion. They consider only the network parts of the two "
"addresses (ignoring any host part) and determine whether one network is "
"identical to or a subnet of the other."
msgstr ""
"В <xref linkend=\"cidr-inet-operators-table\"/> показаны операторы, "
"работающие с типами <type>cidr</type> и <type>inet</type>. Операторы "
"<literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;"
"</literal>, <literal>&gt;&gt;=</literal> и <literal>&amp;&amp;</literal> "
"проверяют включения подсетей, рассматривая только биты сети в обоих адресах "
"(игнорируя биты узлов) и определяя, идентична ли одна сеть другой или её "
"подсети."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8916(title)
msgid "<type>cidr</type> and <type>inet</type> Operators"
msgstr "Операторы для типов <type>cidr</type> и <type>inet</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8928(entry)
msgid "is less than"
msgstr "меньше"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8929(literal)
msgid "inet '192.168.1.5' &lt; inet '192.168.1.6'"
msgstr "inet '192.168.1.5' &lt; inet '192.168.1.6'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8933(entry)
msgid "is less than or equal"
msgstr "меньше или равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8934(literal)
msgid "inet '192.168.1.5' &lt;= inet '192.168.1.5'"
msgstr "inet '192.168.1.5' &lt;= inet '192.168.1.5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8938(entry)
msgid "equals"
msgstr "равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8939(literal)
msgid "inet '192.168.1.5' = inet '192.168.1.5'"
msgstr "inet '192.168.1.5' = inet '192.168.1.5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8943(entry)
msgid "is greater or equal"
msgstr "больше или равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8944(literal)
msgid "inet '192.168.1.5' &gt;= inet '192.168.1.5'"
msgstr "inet '192.168.1.5' &gt;= inet '192.168.1.5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8948(entry)
msgid "is greater than"
msgstr "больше"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8949(literal)
msgid "inet '192.168.1.5' &gt; inet '192.168.1.4'"
msgstr "inet '192.168.1.5' &gt; inet '192.168.1.4'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8952(literal) func.xml:12453(literal) func.xml:12928(literal)
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8953(entry)
msgid "is not equal"
msgstr "не равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8954(literal)
msgid "inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'"
msgstr "inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8958(entry) func.xml:12496(entry)
msgid "is contained by"
msgstr "содержится в"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8959(literal)
msgid "inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'"
msgstr "inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8962(literal)
msgid "&lt;&lt;="
msgstr "&lt;&lt;="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8963(entry)
msgid "is contained by or equals"
msgstr "равно или содержится в"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8964(literal)
msgid "inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'"
msgstr "inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8968(entry) func.xml:12489(entry)
msgid "contains"
msgstr "содержит"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8969(literal)
msgid "inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'"
msgstr "inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8972(literal)
msgid "&gt;&gt;="
msgstr "&gt;&gt;="

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8973(entry)
msgid "contains or equals"
msgstr "равно или содержит"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8974(literal)
msgid "inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'"
msgstr "inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8978(entry)
msgid "contains or is contained by"
msgstr "содержит или содержится в"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8979(literal)
msgid "inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'"
msgstr "inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8984(literal)
msgid "~ inet '192.168.1.6'"
msgstr "~ inet '192.168.1.6'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8989(literal)
msgid "inet '192.168.1.6' &amp; inet '0.0.0.255'"
msgstr "inet '192.168.1.6' &amp; inet '0.0.0.255'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8994(literal)
msgid "inet '192.168.1.6' | inet '0.0.0.255'"
msgstr "inet '192.168.1.6' | inet '0.0.0.255'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:8999(literal)
msgid "inet '192.168.1.6' + 25"
msgstr "inet '192.168.1.6' + 25"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9004(literal)
msgid "inet '192.168.1.43' - 36"
msgstr "inet '192.168.1.43' - 36"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9009(literal)
msgid "inet '192.168.1.43' - inet '192.168.1.19'"
msgstr "inet '192.168.1.43' - inet '192.168.1.19'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9015(para)
msgid ""
"<xref linkend=\"cidr-inet-functions-table\"/> shows the functions available "
"for use with the <type>cidr</type> and <type>inet</type> types. The "
"<function>abbrev</function>, <function>host</function>, and <function>text</"
"function> functions are primarily intended to offer alternative display "
"formats."
msgstr ""
"В <xref remap=\"6\" linkend=\"cidr-inet-functions-table\"/> перечислены "
"функции, работающие с типами <type>cidr</type> и <type>inet</type>. Функции "
"<function>abbrev</function>, <function>host</function> и <function>text</"
"function> предназначены в основном для вывода данных в альтернативных "
"форматах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9025(title)
msgid "<type>cidr</type> and <type>inet</type> Functions"
msgstr "Функции для типов <type>cidr</type> и <type>inet</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9039(indexterm)
msgid "<primary>abbrev</primary>"
msgstr "<primary>abbrev</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9042(type) func.xml:9061(type) func.xml:9063(type)
#: func.xml:9073(type) func.xml:9086(type) func.xml:9098(type)
#: func.xml:9100(type) func.xml:9110(type) func.xml:9122(type)
#: func.xml:9124(type) func.xml:9134(type) func.xml:9146(type)
#: func.xml:9148(type) func.xml:9165(type) func.xml:9177(type)
#: func.xml:9189(type) func.xml:15794(type) func.xml:15806(type)
msgid "inet"
msgstr "inet"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9042(function) func.xml:9050(function)
msgid "abbrev(<placeholder-1/>)"
msgstr "abbrev(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9045(entry) func.xml:9052(entry)
msgid "abbreviated display format as text"
msgstr "вывод адрес в кратком текстовом виде"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9046(literal)
msgid "abbrev(inet '10.1.0.0/16')"
msgstr "abbrev(inet '10.1.0.0/16')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9047(literal)
msgid "10.1.0.0/16"
msgstr "10.1.0.0/16"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9050(type) func.xml:9136(type) func.xml:9154(type)
#: func.xml:9155(type) func.xml:9191(type)
msgid "cidr"
msgstr "cidr"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9053(literal)
msgid "abbrev(cidr '10.1.0.0/16')"
msgstr "abbrev(cidr '10.1.0.0/16')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9054(literal)
msgid "10.1/16"
msgstr "10.1/16"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9058(indexterm)
msgid "<primary>broadcast</primary>"
msgstr "<primary>broadcast</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9061(function)
msgid "broadcast(<placeholder-1/>)"
msgstr "broadcast(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9064(entry)
msgid "broadcast address for network"
msgstr "широковещательный адрес сети"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9065(literal)
msgid "broadcast('192.168.1.5/24')"
msgstr "broadcast('192.168.1.5/&zwsp;24')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9066(literal)
msgid "192.168.1.255/24"
msgstr "192.168.1.255/&zwsp;24"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9070(indexterm)
msgid "<primary>family</primary>"
msgstr "<primary>family</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9073(function)
msgid "family(<placeholder-1/>)"
msgstr "family(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9076(entry)
msgid ""
"extract family of address; <literal>4</literal> for IPv4, <literal>6</"
"literal> for IPv6"
msgstr ""
"возвращает семейство адреса; <literal>4</literal> для адреса IPv4, "
"<literal>6</literal> для IPv6"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9078(literal)
msgid "family('::1')"
msgstr "family('::1')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9083(indexterm)
msgid "<primary>host</primary>"
msgstr "<primary>host</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9086(function)
msgid "host(<placeholder-1/>)"
msgstr "host(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9089(entry)
msgid "extract IP address as text"
msgstr "извлекает IP-адрес в виде текста"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9090(literal)
msgid "host('192.168.1.5/24')"
msgstr "host('192.168.1.5/&zwsp;24')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9091(literal)
msgid "192.168.1.5"
msgstr "192.168.1.5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9095(indexterm)
msgid "<primary>hostmask</primary>"
msgstr "<primary>hostmask</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9098(function)
msgid "hostmask(<placeholder-1/>)"
msgstr "hostmask(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9101(entry)
msgid "construct host mask for network"
msgstr "вычисляет маску узла для сетевого адреса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9102(literal)
msgid "hostmask('192.168.23.20/30')"
msgstr "hostmask('192.168.23.20/&zwsp;30')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9103(literal)
msgid "0.0.0.3"
msgstr "0.0.0.3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9107(indexterm)
msgid "<primary>masklen</primary>"
msgstr "<primary>masklen</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9110(function)
msgid "masklen(<placeholder-1/>)"
msgstr "masklen(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9113(entry)
msgid "extract netmask length"
msgstr "выдаёт длину маски сети"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9114(literal)
msgid "masklen('192.168.1.5/24')"
msgstr "masklen('192.168.1.5/&zwsp;24')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9115(literal)
msgid "24"
msgstr "24"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9119(indexterm)
msgid "<primary>netmask</primary>"
msgstr "<primary>netmask</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9122(function)
msgid "netmask(<placeholder-1/>)"
msgstr "netmask(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9125(entry)
msgid "construct netmask for network"
msgstr "вычисляет маску сети для сетевого адреса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9126(literal)
msgid "netmask('192.168.1.5/24')"
msgstr "netmask('192.168.1.5/&zwsp;24')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9127(literal)
msgid "255.255.255.0"
msgstr "255.255.255.0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9131(indexterm)
msgid "<primary>network</primary>"
msgstr "<primary>network</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9134(function)
msgid "network(<placeholder-1/>)"
msgstr "network(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9137(entry)
msgid "extract network part of address"
msgstr "извлекает компонент сети из адреса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9138(literal)
msgid "network('192.168.1.5/24')"
msgstr "network('192.168.1.5/&zwsp;24')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9139(literal)
msgid "192.168.1.0/24"
msgstr "192.168.1.0/24"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9143(indexterm)
msgid "<primary>set_masklen</primary>"
msgstr "<primary>set_masklen</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9146(function) func.xml:9154(function)
msgid "set_masklen(<placeholder-1/>, <placeholder-2/>)"
msgstr "set_masklen(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9149(entry)
msgid "set netmask length for <type>inet</type> value"
msgstr "задаёт размер маски для значения <type>inet</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9150(literal)
msgid "set_masklen('192.168.1.5/24', 16)"
msgstr "set_masklen('192.168.1.5/&zwsp;24', 16)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9151(literal)
msgid "192.168.1.5/16"
msgstr "192.168.1.5/16"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9156(entry)
msgid "set netmask length for <type>cidr</type> value"
msgstr "задаёт размер маски для значения <type>cidr</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9157(literal)
msgid "set_masklen('192.168.1.0/24'::cidr, 16)"
msgstr "set_masklen('192.168.1.0/&zwsp;24'::cidr, 16)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9158(literal)
msgid "192.168.0.0/16"
msgstr "192.168.0.0/16"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9162(indexterm)
msgid "<primary>text</primary>"
msgstr "<primary>text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9165(function)
msgid "text(<placeholder-1/>)"
msgstr "text(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9168(entry)
msgid "extract IP address and netmask length as text"
msgstr "выводит в текстовом виде IP-адрес и длину маски"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9169(literal)
msgid "text(inet '192.168.1.5')"
msgstr "text(inet '192.168.1.5')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9170(literal)
msgid "192.168.1.5/32"
msgstr "192.168.1.5/32"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9174(indexterm)
msgid "<primary>inet_same_family</primary>"
msgstr "<primary>inet_same_family</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9177(function)
msgid "inet_same_family(<placeholder-1/>, <placeholder-2/>)"
msgstr "inet_same_family(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9180(entry)
msgid "are the addresses from the same family?"
msgstr "адреса относятся к одному семейству?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9181(literal)
msgid "inet_same_family('192.168.1.5/24', '::1')"
msgstr "inet_same_family('192.168.1.5/24', '::1')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9182(literal) func.xml:13149(literal) func.xml:13171(literal)
msgctxt "literal"
msgid "false"
msgstr "false"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9186(indexterm)
msgid "<primary>inet_merge</primary>"
msgstr "<primary>inet_merge</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9189(function)
msgid "inet_merge(<placeholder-1/>, <placeholder-2/>)"
msgstr "inet_merge(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9192(entry)
msgid "the smallest network which includes both of the given networks"
msgstr "наименьшая сеть, включающая обе заданные сети"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9193(literal)
msgid "inet_merge('192.168.1.5/24', '192.168.2.5/24')"
msgstr "inet_merge('192.168.1.5/24', '192.168.2.5/24')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9194(literal)
msgid "192.168.0.0/22"
msgstr "192.168.0.0/22"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9200(para)
msgid ""
"Any <type>cidr</type> value can be cast to <type>inet</type> implicitly or "
"explicitly; therefore, the functions shown above as operating on <type>inet</"
"type> also work on <type>cidr</type> values. (Where there are separate "
"functions for <type>inet</type> and <type>cidr</type>, it is because the "
"behavior should be different for the two cases.) Also, it is permitted to "
"cast an <type>inet</type> value to <type>cidr</type>. When this is done, any "
"bits to the right of the netmask are silently zeroed to create a valid "
"<type>cidr</type> value. In addition, you can cast a text value to "
"<type>inet</type> or <type>cidr</type> using normal casting syntax: for "
"example, <literal>inet(<replaceable>expression</replaceable>)</literal> or "
"<literal><replaceable>colname</replaceable>::cidr</literal>."
msgstr ""
"Любое значение <type>cidr</type> можно привести к типу <type>inet</type>, "
"явно или нет; поэтому все функции, показанные выше с типом <type>inet</"
"type>, также будут работать со значениями <type>cidr</type>. (Некоторые из "
"функций указаны отдельно для типов <type>inet</type> и <type>cidr</type>, "
"потому что их поведение с разными типами различается.) Кроме того, значение "
"<type>inet</type> тоже можно привести к типу <type>cidr</type>. При этом все "
"биты справа от сетевой маски просто обнуляются, чтобы значение стало "
"допустимым для типа <type>cidr</type>. К типам <type>inet</type> и "
"<type>cidr</type> можно привести и обычные текстовые значения, используя "
"обычный синтаксис, например: <literal>inet(<replaceable>выражение</"
"replaceable>)</literal> или <literal><replaceable>столбец</replaceable>::"
"cidr</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9216(para)
msgid ""
"<xref linkend=\"macaddr-functions-table\"/> shows the functions available "
"for use with the <type>macaddr</type> type. The function "
"<literal><function>trunc(<type>macaddr</type>)</function></literal> returns "
"a MAC address with the last 3 bytes set to zero. This can be used to "
"associate the remaining prefix with a manufacturer."
msgstr ""
"В <xref remap=\"6\" linkend=\"macaddr-functions-table\"/> приведена функция, "
"предназначенная для работы с типом <type>macaddr</type>. Функция "
"<literal><function>trunc(<type>macaddr</type>)</function></literal> "
"возвращает MAC-адрес, последние 3 байта в котором равны 0. Это может быть "
"полезно для вычисления префикса, определяющего производителя."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9225(title)
msgid "<type>macaddr</type> Functions"
msgstr "Функции <type>macaddr</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9242(type) func.xml:9244(type)
msgid "macaddr"
msgstr "macaddr"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9242(function) func.xml:9287(function)
msgid "trunc(<placeholder-1/>)"
msgstr "trunc(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9245(entry)
msgid "set last 3 bytes to zero"
msgstr "обнуляет последние 3 байта"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9246(literal)
msgid "trunc(macaddr '12:34:56:78:90:ab')"
msgstr "trunc(macaddr '12:34:56:&zwsp;78:90:ab')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9247(literal)
msgid "12:34:56:00:00:00"
msgstr "12:34:56:&zwsp;00:00:00"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9253(para)
msgid ""
"The <type>macaddr</type> type also supports the standard relational "
"operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for "
"lexicographical ordering, and the bitwise arithmetic operators (<literal>~</"
"literal>, <literal>&amp;</literal> and <literal>|</literal>) for NOT, AND "
"and OR."
msgstr ""
"Тип <type>macaddr</type> также поддерживает стандартные реляционные "
"операторы лексической сортировки (<literal>&gt;</literal>, <literal>&lt;=</"
"literal> и т. д.) и операторы битовой арифметики (<literal>~</literal>, "
"<literal>&amp;</literal> и <literal>|</literal>), соответствующие операциям "
"NOT, AND и OR."

#. +> REL_10
#: func.xml:9261(para)
msgid ""
"<xref linkend=\"macaddr8-functions-table\"/> shows the functions available "
"for use with the <type>macaddr8</type> type. The function "
"<literal><function>trunc(<type>macaddr8</type>)</function></literal> returns "
"a MAC address with the last 5 bytes set to zero. This can be used to "
"associate the remaining prefix with a manufacturer."
msgstr ""
"В <xref remap=\"6\" linkend=\"macaddr8-functions-table\"/> приведены "
"функции, предназначенные для работы с типом <type>macaddr8</type>. Функция "
"<literal><function>trunc(<type>macaddr8</type>)</function></literal> "
"возвращает MAC-адрес, последние 5 байт в котором равны нулю. Это может быть "
"полезно для вычисления префикса, определяющего производителя."

#. +> REL_10
#: func.xml:9270(title)
msgid "<type>macaddr8</type> Functions"
msgstr "Функции <type>macaddr8</type>"

#. +> REL_10
#: func.xml:9287(type) func.xml:9289(type) func.xml:9299(type)
#: func.xml:9301(type)
msgid "macaddr8"
msgstr "macaddr8"

#. +> REL_10
#: func.xml:9290(entry)
msgid "set last 5 bytes to zero"
msgstr "обнуляет последние 5 байт"

#. +> REL_10
#: func.xml:9291(literal)
msgid "trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')"
msgstr "trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')"

#. +> REL_10
#: func.xml:9292(literal)
msgid "12:34:56:00:00:00:00:00"
msgstr "12:34:56:00:00:00:00:00"

#. +> REL_10
#: func.xml:9296(indexterm)
msgid "<primary>macaddr8_set7bit</primary>"
msgstr "<primary>macaddr8_set7bit</primary>"

#. +> REL_10
#: func.xml:9299(function)
msgid "macaddr8_set7bit(<placeholder-1/>)"
msgstr "macaddr8_set7bit(<placeholder-1/>)"

#. +> REL_10
#: func.xml:9302(entry)
msgid ""
"set 7th bit to one, also known as modified EUI-64, for inclusion in an IPv6 "
"address"
msgstr ""
"устанавливает в 7 бите единицу, чтобы получить так называемый "
"модифицированный адрес EUI-64 (для включения в адрес IPv6)"

#. +> REL_10
#: func.xml:9303(literal)
msgid "macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')"
msgstr "macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')"

#. +> REL_10
#: func.xml:9304(literal)
msgid "02:34:56:ff:fe:ab:cd:ef"
msgstr "02:34:56:ff:fe:ab:cd:ef"

#. +> REL_10
#: func.xml:9310(para)
msgid ""
"The <type>macaddr8</type> type also supports the standard relational "
"operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for "
"ordering, and the bitwise arithmetic operators (<literal>~</literal>, "
"<literal>&amp;</literal> and <literal>|</literal>) for NOT, AND and OR."
msgstr ""
"Тип <type>macaddr8</type> также поддерживает стандартные реляционные "
"операторы лексической сортировки (<literal>&gt;</literal>, <literal>&lt;=</"
"literal> и т. д.) и операторы битовой арифметики (<literal>~</literal>, "
"<literal>&amp;</literal> и <literal>|</literal>), соответствующие операциям "
"NOT, AND и OR."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9321(title)
msgid "Text Search Functions and Operators"
msgstr "Функции и операторы текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9323(indexterm)
msgid ""
"<primary>full text search</primary> <secondary>functions and operators</"
"secondary>"
msgstr ""
"<primary>полнотекстовый поиск</primary> <secondary>функции и операторы</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9328(indexterm)
msgid ""
"<primary>text search</primary> <secondary>functions and operators</secondary>"
msgstr ""
"<primary>поиск текста</primary> <secondary>функции и операторы</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9333(para)
msgid ""
"<xref linkend=\"textsearch-operators-table\"/>, <xref linkend=\"textsearch-"
"functions-table\"/> and <xref linkend=\"textsearch-functions-debug-table\"/> "
"summarize the functions and operators that are provided for full text "
"searching. See <xref linkend=\"textsearch\"/> for a detailed explanation of "
"<productname>PostgreSQL</productname>'s text search facility."
msgstr ""
"В <xref remap=\"6\" linkend=\"textsearch-operators-table\"/>, <xref remap="
"\"6\" linkend=\"textsearch-functions-table\"/> и <xref remap=\"6\" linkend="
"\"textsearch-functions-debug-table\"/> собраны все существующие функции и "
"операторы, предназначенные для полнотекстового поиска. Во всех деталях "
"возможности полнотекстового поиска в <productname>PostgreSQL</productname> "
"описаны в <xref remap=\"6\" linkend=\"textsearch\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9344(title)
msgid "Text Search Operators"
msgstr "Операторы текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9359(entry)
msgid "<type>tsvector</type> matches <type>tsquery</type> ?"
msgstr "<type>tsvector</type> соответствует <type>tsquery</type> ?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9360(literal)
msgid "to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')"
msgstr "to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9364(literal)
msgid "@@@"
msgstr "@@@"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9366(entry)
msgid "deprecated synonym for <literal>@@</literal>"
msgstr "устаревший синоним для <literal>@@</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9367(literal)
msgid "to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')"
msgstr "to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9372(type) func.xml:9458(type) func.xml:9480(type)
#: func.xml:9541(type) func.xml:9543(type) func.xml:9554(type)
#: func.xml:9556(type) func.xml:9566(type) func.xml:9568(type)
#: func.xml:9592(type) func.xml:9601(type) func.xml:9614(type)
#: func.xml:9616(type) func.xml:9624(type) func.xml:9626(type)
#: func.xml:9636(type) func.xml:9638(type) func.xml:9669(type)
#: func.xml:9681(type) func.xml:9737(type) func.xml:9774(type)
msgid "tsvector"
msgstr "tsvector"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9373(entry)
msgid "concatenate <type>tsvector</type>s"
msgstr "объединяет два значения <type>tsvector</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9374(literal)
msgid "'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector"
msgstr "'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9375(literal)
msgid "'a':1 'b':2,5 'c':3 'd':4"
msgstr "'a':1 'b':2,5 'c':3 'd':4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9379(type) func.xml:9386(type) func.xml:9393(type)
#: func.xml:9400(type) func.xml:9492(type) func.xml:9506(type)
#: func.xml:9518(type) func.xml:9529(type) func.xml:9580(type)
#: func.xml:9648(type) func.xml:9657(type) func.xml:9669(type)
#: func.xml:9681(type) func.xml:9693(type) func.xml:9695(type)
#: func.xml:9702(type) func.xml:9703(type) func.xml:9713(type)
#: func.xml:9715(type) func.xml:9724(type) func.xml:9726(type)
msgid "tsquery"
msgstr "tsquery"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9380(entry)
msgid "AND <type>tsquery</type>s together"
msgstr "логическое И (AND) двух запросов <type>tsquery</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9381(literal)
msgid "'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery"
msgstr "'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9382(literal)
msgid "( 'fat' | 'rat' ) &amp; 'cat'"
msgstr "( 'fat' | 'rat' ) &amp; 'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9387(entry)
msgid "OR <type>tsquery</type>s together"
msgstr "логическое ИЛИ (OR) двух запросов <type>tsquery</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9388(literal)
msgid "'fat | rat'::tsquery || 'cat'::tsquery"
msgstr "'fat | rat'::tsquery || 'cat'::tsquery"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9389(literal)
msgid "( 'fat' | 'rat' ) | 'cat'"
msgstr "( 'fat' | 'rat' ) | 'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9394(entry)
msgid "negate a <type>tsquery</type>"
msgstr "отрицание запроса <type>tsquery</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9395(literal)
msgid "!! 'cat'::tsquery"
msgstr "!! 'cat'::tsquery"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9396(literal)
msgid "!'cat'"
msgstr "!'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9401(entry)
msgid "<type>tsquery</type> followed by <type>tsquery</type>"
msgstr "<type>tsquery</type> предшествует <type>tsquery</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9402(literal)
msgid "to_tsquery('fat') &lt;-&gt; to_tsquery('rat')"
msgstr "to_tsquery('fat') &lt;-&gt; to_tsquery('rat')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9403(literal) func.xml:9522(literal)
msgid "'fat' &lt;-&gt; 'rat'"
msgstr "'fat' &lt;-&gt; 'rat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9408(entry)
msgid "<type>tsquery</type> contains another ?"
msgstr "запрос <type>tsquery</type> включает другой?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9409(literal)
msgid "'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery"
msgstr "'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9410(literal) func.xml:12987(literal)
msgid "f"
msgstr "f"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9415(entry)
msgid "<type>tsquery</type> is contained in ?"
msgstr "запрос <type>tsquery</type> включён в другой?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9416(literal)
msgid "'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery"
msgstr "'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9424(para)
msgid ""
"The <type>tsquery</type> containment operators consider only the lexemes "
"listed in the two queries, ignoring the combining operators."
msgstr ""
"Операторы включения <type>tsquery</type> рассматривают только лексемы двух "
"запросов, игнорируя операторы их сочетания."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9430(para)
msgid ""
"In addition to the operators shown in the table, the ordinary B-tree "
"comparison operators (<literal>=</literal>, <literal>&lt;</literal>, etc) "
"are defined for types <type>tsvector</type> and <type>tsquery</type>. These "
"are not very useful for text searching but allow, for example, unique "
"indexes to be built on columns of these types."
msgstr ""
"В дополнение к операторам, перечисленным в этой таблице, для типов "
"<type>tsvector</type> и <type>tsquery</type> определены обычные операторы "
"сравнения для B-дерева (<literal>=</literal>, <literal>&lt;</literal> и т. "
"д.). Они не очень полезны для поиска, но позволяют, в частности, создавать "
"индексы для столбцов этих типов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9439(title)
msgid "Text Search Functions"
msgstr "Функции текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9453(indexterm)
msgid "<primary>array_to_tsvector</primary>"
msgstr "<primary>array_to_tsvector</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9456(function)
msgid "array_to_tsvector(<placeholder-1/>)"
msgstr "array_to_tsvector(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9459(entry)
msgid "convert array of lexemes to <type>tsvector</type>"
msgstr "преобразует массив лексем в <type>tsvector</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9460(literal)
msgid "array_to_tsvector('{fat,cat,rat}'::text[])"
msgstr "array_to_tsvector('{fat,cat,rat}'::text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9461(literal) func.xml:9571(literal)
msgid "'cat' 'fat' 'rat'"
msgstr "'cat' 'fat' 'rat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9465(indexterm)
msgid "<primary>get_current_ts_config</primary>"
msgstr "<primary>get_current_ts_config</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9468(function)
msgctxt "function"
msgid "get_current_ts_config()"
msgstr "get_current_ts_config()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9470(type) func.xml:9504(type) func.xml:9516(type)
#: func.xml:9578(type) func.xml:9590(type) func.xml:9599(type)
#: func.xml:9648(type) func.xml:9657(type) func.xml:9820(type)
msgid "regconfig"
msgstr "regconfig"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9471(entry)
msgid "get default text search configuration"
msgstr "получает конфигурацию текстового поиска по умолчанию"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9472(literal)
msgctxt "literal"
msgid "get_current_ts_config()"
msgstr "get_current_ts_config()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9473(literal)
msgid "english"
msgstr "english"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9483(entry)
msgid "number of lexemes in <type>tsvector</type>"
msgstr "число лексем в значении <type>tsvector</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9484(literal)
msgid "length('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "length('fat:2,4 cat:3 rat:5A'::tsvector)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9489(indexterm)
msgid "<primary>numnode</primary>"
msgstr "<primary>numnode</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9492(function)
msgid "numnode(<placeholder-1/>)"
msgstr "numnode(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9495(entry)
msgid "number of lexemes plus operators in <type>tsquery</type>"
msgstr "число лексем и операторов в запросе <type>tsquery</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9496(literal)
msgid "numnode('(fat &amp; rat) | cat'::tsquery)"
msgstr "numnode('(fat &amp; rat) | cat'::tsquery)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9501(indexterm)
msgid "<primary>plainto_tsquery</primary>"
msgstr "<primary>plainto_tsquery</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9504(replaceable) func.xml:9516(replaceable)
#: func.xml:9578(replaceable) func.xml:9590(replaceable)
#: func.xml:9599(replaceable) func.xml:9648(replaceable)
#: func.xml:9657(replaceable) func.xml:9820(replaceable)
msgid "config"
msgstr "конфигурация"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9504(optional) func.xml:9516(optional) func.xml:9578(optional)
#: func.xml:9590(optional) func.xml:9599(optional)
msgid "<placeholder-1/> <placeholder-2/> ,"
msgstr "<placeholder-1/> <placeholder-2/> ,"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9504(replaceable) func.xml:9516(replaceable)
#: func.xml:9529(replaceable) func.xml:9578(replaceable)
#: func.xml:9648(replaceable) func.xml:9657(replaceable)
#: func.xml:9669(replaceable) func.xml:9681(replaceable)
#: func.xml:9693(replaceable) func.xml:9702(replaceable)
msgid "query"
msgstr "запрос"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9504(function)
msgid "plainto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "plainto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9507(entry)
msgid "produce <type>tsquery</type> ignoring punctuation"
msgstr "выдаёт значение <type>tsquery</type>, игнорируя пунктуацию"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9508(literal)
msgid "plainto_tsquery('english', 'The Fat Rats')"
msgstr "plainto_tsquery('english', 'The Fat Rats')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9509(literal) func.xml:9583(literal)
msgid "'fat' &amp; 'rat'"
msgstr "'fat' &amp; 'rat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9513(indexterm)
msgid "<primary>phraseto_tsquery</primary>"
msgstr "<primary>phraseto_tsquery</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9516(function)
msgid "phraseto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "phraseto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9519(entry)
msgid ""
"produce <type>tsquery</type> that searches for a phrase, ignoring punctuation"
msgstr ""
"выдаёт значение <type>tsquery</type> для поиска фразы, игнорируя пунктуацию"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9521(literal)
msgid "phraseto_tsquery('english', 'The Fat Rats')"
msgstr "phraseto_tsquery('english', 'The Fat Rats')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9526(indexterm)
msgid "<primary>querytree</primary>"
msgstr "<primary>querytree</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9529(function)
msgid "querytree(<placeholder-1/> <placeholder-2/>)"
msgstr "querytree(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9532(entry)
msgid "get indexable part of a <type>tsquery</type>"
msgstr "получает индексируемую часть запроса <type>tsquery</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9533(literal)
msgid "querytree('foo &amp; ! bar'::tsquery)"
msgstr "querytree('foo &amp; ! bar'::tsquery)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9534(literal)
msgid "'foo'"
msgstr "'foo'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9538(indexterm)
msgid "<primary>setweight</primary>"
msgstr "<primary>setweight</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9541(replaceable) func.xml:9554(replaceable)
#: func.xml:9614(replaceable) func.xml:9624(replaceable)
#: func.xml:9636(replaceable) func.xml:9669(replaceable)
#: func.xml:9681(replaceable)
msgid "vector"
msgstr "вектор"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9541(replaceable) func.xml:9554(replaceable)
msgid "weight"
msgstr "вес"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9541(type) func.xml:9554(type)
msgid "\"char\""
msgstr "\"char\""

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9541(function)
msgid ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9544(entry)
msgid ""
"assign <replaceable class=\"parameter\">weight</replaceable> to each element "
"of <replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"назначает <replaceable class=\"parameter\">вес</replaceable> каждому "
"элементу <replaceable class=\"parameter\">вектора</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9545(literal)
msgid "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9546(literal)
msgid "'cat':3A 'fat':2A,4A 'rat':5A"
msgstr "'cat':3A 'fat':2A,4A 'rat':5A"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9550(indexterm)
msgid ""
"<primary>setweight</primary> <secondary>setweight for specific lexeme(s)</"
"secondary>"
msgstr ""
"<primary>setweight</primary> <secondary>назначение веса определённым "
"лексемам</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9554(replaceable) func.xml:9624(replaceable)
#: func.xml:9820(replaceable)
msgid "lexemes"
msgstr "лексемы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9554(function)
msgid ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9557(entry)
msgid ""
"assign <replaceable class=\"parameter\">weight</replaceable> to elements of "
"<replaceable class=\"parameter\">vector</replaceable> that are listed in "
"<replaceable class=\"parameter\">lexemes</replaceable>"
msgstr ""
"назначает <replaceable class=\"parameter\">вес</replaceable> элементам "
"<replaceable class=\"parameter\">вектора</replaceable>, перечисленным в "
"массиве <replaceable class=\"parameter\">лексемы</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9558(literal)
msgid "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9559(literal)
msgid "'cat':3A 'fat':2,4 'rat':5A"
msgstr "'cat':3A 'fat':2,4 'rat':5A"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9563(indexterm)
msgid "<primary>strip</primary>"
msgstr "<primary>strip</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9566(function)
msgid "strip(<placeholder-1/>)"
msgstr "strip(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9569(entry)
msgid "remove positions and weights from <type>tsvector</type>"
msgstr "убирает позиции и веса из значения <type>tsvector</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9570(literal)
msgid "strip('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "strip('fat:2,4 cat:3 rat:5A'::tsvector)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9575(indexterm)
msgid "<primary>to_tsquery</primary>"
msgstr "<primary>to_tsquery</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9578(function)
msgid "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9581(entry)
msgid "normalize words and convert to <type>tsquery</type>"
msgstr "нормализует слова и переводит их в <type>tsquery</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9582(literal)
msgid "to_tsquery('english', 'The &amp; Fat &amp; Rats')"
msgstr "to_tsquery('english', 'The &amp; Fat &amp; Rats')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9587(indexterm)
msgid "<primary>to_tsvector</primary>"
msgstr "<primary>to_tsvector</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9590(replaceable) func.xml:9599(replaceable)
#: func.xml:9648(replaceable) func.xml:9657(replaceable)
#: func.xml:9820(replaceable) func.xml:9844(replaceable)
#: func.xml:9852(replaceable)
msgid "document"
msgstr "документ"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9590(function) func.xml:9599(function)
msgid "to_tsvector(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_tsvector(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9593(entry)
msgid "reduce document text to <type>tsvector</type>"
msgstr "сокращает текст документа до значения <type>tsvector</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9594(literal)
msgid "to_tsvector('english', 'The Fat Rats')"
msgstr "to_tsvector('english', 'The Fat Rats')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9595(literal) func.xml:9607(literal)
msgid "'fat':2 'rat':3"
msgstr "'fat':2 'rat':3"

#. +> REL_10
#: func.xml:9599(type) func.xml:9657(type)
msgid "json(b)"
msgstr "json(b)"

#. +> REL_10
#: func.xml:9602(entry)
msgid ""
"reduce each string value in the document to a <type>tsvector</type>, and "
"then concatenate those in document order to produce a single <type>tsvector</"
"type>"
msgstr ""
"сокращает каждое строковое значение в документе до значения <type>tsvector</"
"type>, а затем складывает эти значения по порядку в документе и выдаёт один "
"<type>tsvector</type>"

#. +> REL_10
#: func.xml:9606(literal)
msgid "to_tsvector('english', '{\"a\": \"The Fat Rats\"}'::json)"
msgstr "to_tsvector('english', '{\"a\": \"The Fat Rats\"}'::json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9611(indexterm)
msgid "<primary>ts_delete</primary>"
msgstr "<primary>ts_delete</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9614(replaceable) func.xml:9774(replaceable)
msgid "lexeme"
msgstr "лексема"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9614(function) func.xml:9624(function)
msgid ""
"ts_delete(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_delete(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9617(entry)
msgid ""
"remove given <replaceable class=\"parameter\">lexeme</replaceable> from "
"<replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"удаляет заданную <replaceable class=\"parameter\">лексему</replaceable> из "
"<replaceable class=\"parameter\">вектора</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9618(literal)
msgid "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')"
msgstr "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9619(literal)
msgid "'cat':3 'rat':5A"
msgstr "'cat':3 'rat':5A"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9627(entry)
msgid ""
"remove any occurrence of lexemes in <replaceable class=\"parameter"
"\">lexemes</replaceable> from <replaceable class=\"parameter\">vector</"
"replaceable>"
msgstr ""
"удаляет все вхождения лексем, перечисленных в массиве <replaceable class="
"\"parameter\">лексемы</replaceable>, из <replaceable class=\"parameter"
"\">вектора</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9628(literal)
msgid "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])"
msgstr "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9629(literal)
msgid "'cat':3"
msgstr "'cat':3"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9633(indexterm)
msgid "<primary>ts_filter</primary>"
msgstr "<primary>ts_filter</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9636(replaceable) func.xml:9669(replaceable)
#: func.xml:9681(replaceable) func.xml:9774(replaceable)
#: func.xml:9882(replaceable)
msgid "weights"
msgstr "веса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9636(type)
msgid "\"char\"[]"
msgstr "\"char\"[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9636(function)
msgid ""
"ts_filter(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_filter(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9639(entry)
msgid ""
"select only elements with given <replaceable class=\"parameter\">weights</"
"replaceable> from <replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"выбирает из <replaceable class=\"parameter\">вектора</replaceable> только "
"элементы с заданным <replaceable class=\"parameter\">весом</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9640(literal)
msgid "ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')"
msgstr "ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9641(literal)
msgid "'cat':3B 'rat':5A"
msgstr "'cat':3B 'rat':5A"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9645(indexterm)
msgid "<primary>ts_headline</primary>"
msgstr "<primary>ts_headline</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9648(optional) func.xml:9657(optional) func.xml:9669(optional)
#: func.xml:9681(optional) func.xml:9820(optional) func.xml:9882(optional)
msgid "<placeholder-1/> <placeholder-2/>,"
msgstr "<placeholder-1/> <placeholder-2/>,"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9648(replaceable) func.xml:9657(replaceable)
msgctxt "replaceable"
msgid "options"
msgstr "параметры"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9648(function) func.xml:9657(function)
msgid ""
"ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9651(entry) func.xml:9660(entry)
msgid "display a query match"
msgstr "выводит фрагмент, соответствующий запросу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9652(literal)
msgid "ts_headline('x y z', 'z'::tsquery)"
msgstr "ts_headline('x y z', 'z'::tsquery)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9653(literal)
msgid "x y &lt;b&gt;z&lt;/b&gt;"
msgstr "x y &lt;b&gt;z&lt;/b&gt;"

#. +> REL_10
#: func.xml:9661(literal)
msgid "ts_headline('{\"a\":\"x y z\"}'::json, 'z'::tsquery)"
msgstr "ts_headline('{\"a\":\"x y z\"}'::json, 'z'::tsquery)"

#. +> REL_10
#: func.xml:9662(literal)
msgid "{\"a\":\"x y &lt;b&gt;z&lt;/b&gt;\"}"
msgstr "{\"a\":\"x y &lt;b&gt;z&lt;/b&gt;\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9666(indexterm)
msgid "<primary>ts_rank</primary>"
msgstr "<primary>ts_rank</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9669(type) func.xml:9681(type)
msgid "float4[]"
msgstr "float4[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9669(replaceable) func.xml:9681(replaceable)
msgid "normalization"
msgstr "нормализация"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9669(function)
msgid ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9671(type) func.xml:9683(type)
msgid "float4"
msgstr "float4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9672(entry)
msgid "rank document for query"
msgstr "вычисляет ранг документа по отношению к запросу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9673(literal)
msgid "ts_rank(textsearch, query)"
msgstr "ts_rank(textsearch, query)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9674(literal)
msgid "0.818"
msgstr "0.818"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9678(indexterm)
msgid "<primary>ts_rank_cd</primary>"
msgstr "<primary>ts_rank_cd</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9681(function)
msgid ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9684(entry)
msgid "rank document for query using cover density"
msgstr ""
"вычисляет ранг документа по отношению к запросу, используя плотность "
"покрытия (CDR)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9685(literal)
msgid "ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)"
msgstr "ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9686(literal)
msgid "2.01317"
msgstr "2.01317"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9690(indexterm)
msgid "<primary>ts_rewrite</primary>"
msgstr "<primary>ts_rewrite</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9693(replaceable) func.xml:10171(replaceable)
msgid "target"
msgstr "цель"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9693(replaceable)
msgid "substitute"
msgstr "замена"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9693(function)
msgid ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9696(entry)
msgid ""
"replace <replaceable>target</replaceable> with <replaceable>substitute</"
"replaceable> within query"
msgstr ""
"подставляет в запросе вместо <replaceable>цели</replaceable> "
"<replaceable>замену</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9698(literal)
msgid "ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)"
msgstr "ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9699(literal) func.xml:9706(literal)
msgid "'b' &amp; ( 'foo' | 'bar' )"
msgstr "'b' &amp; ( 'foo' | 'bar' )"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9702(replaceable)
msgid "select"
msgstr "выборка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9702(function)
msgid ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9704(entry)
msgid ""
"replace using targets and substitutes from a <command>SELECT</command> "
"command"
msgstr ""
"заменяет элементы запроса, выбирая цели и подстановки командой "
"<command>SELECT</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9705(literal)
msgid "SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')"
msgstr "SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9710(indexterm)
msgid "<primary>tsquery_phrase</primary>"
msgstr "<primary>tsquery_phrase</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9713(replaceable) func.xml:9724(replaceable)
msgid "query1"
msgstr "запрос1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9713(replaceable) func.xml:9724(replaceable)
msgid "query2"
msgstr "запрос2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9713(function)
msgid ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9716(entry)
msgid ""
"make query that searches for <replaceable>query1</replaceable> followed by "
"<replaceable>query2</replaceable> (same as <literal>&lt;-&gt;</literal> "
"operator)"
msgstr ""
"создаёт запрос, который ищет <replaceable>запрос1</replaceable>, за которым "
"идёт <replaceable>запрос2</replaceable> (как делает оператор <literal>&lt;-"
"&gt;</literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9719(literal)
msgid "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))"
msgstr "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9720(literal)
msgid "'fat' &lt;-&gt; 'cat'"
msgstr "'fat' &lt;-&gt; 'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9724(replaceable)
msgid "distance"
msgstr "расстояние"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9724(function)
msgid ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9727(entry)
msgid ""
"make query that searches for <replaceable>query1</replaceable> followed by "
"<replaceable>query2</replaceable> at distance <replaceable>distance</"
"replaceable>"
msgstr ""
"создаёт запрос, который ищет <replaceable>запрос1</replaceable>, за которым "
"идёт <replaceable>запрос2</replaceable> на заданном <replaceable>расстоянии</"
"replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9729(literal)
msgid "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)"
msgstr "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9730(literal)
msgid "'fat' &lt;10&gt; 'cat'"
msgstr "'fat' &lt;10&gt; 'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9734(indexterm)
msgid "<primary>tsvector_to_array</primary>"
msgstr "<primary>tsvector_to_array</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9737(function)
msgid "tsvector_to_array(<placeholder-1/>)"
msgstr "tsvector_to_array(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9740(entry)
msgid "convert <type>tsvector</type> to array of lexemes"
msgstr "преобразует <type>tsvector</type> в массив лексем"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9741(literal)
msgid "tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9742(literal)
msgid "{cat,fat,rat}"
msgstr "{cat,fat,rat}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9746(indexterm)
msgid "<primary>tsvector_update_trigger</primary>"
msgstr "<primary>tsvector_update_trigger</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9749(function)
msgid "tsvector_update_trigger()"
msgstr "tsvector_update_trigger()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9751(type) func.xml:9763(type)
msgid "trigger"
msgstr "trigger"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9752(entry) func.xml:9764(entry)
msgid "trigger function for automatic <type>tsvector</type> column update"
msgstr ""
"триггерная функция для автоматического изменения столбца типа "
"<type>tsvector</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9753(literal)
msgid ""
"CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', "
"title, body)"
msgstr ""
"CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.&zwsp;"
"swedish', title, body)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9758(indexterm)
msgid "<primary>tsvector_update_trigger_column</primary>"
msgstr "<primary>tsvector_update_trigger_column</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9761(function)
msgid "tsvector_update_trigger_column()"
msgstr "tsvector_update_trigger_column()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9765(literal)
msgid ""
"CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, "
"body)"
msgstr ""
"CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, "
"body)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9770(indexterm)
msgid "<primary>unnest</primary> <secondary>for tsvector</secondary>"
msgstr "<primary>unnest</primary> <secondary>для tsvector</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9774(replaceable)
msgid "positions"
msgstr "позиции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9774(type)
msgid "smallint[]"
msgstr "smallint[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9774(function)
msgid ""
"unnest(<placeholder-1/>, OUT <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>)"
msgstr ""
"unnest(<placeholder-1/>, OUT <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9776(type) func.xml:9822(type) func.xml:9846(type)
#: func.xml:9853(type) func.xml:9865(type) func.xml:9872(type)
#: func.xml:9884(type) func.xml:11716(type) func.xml:17022(type)
#: func.xml:17104(type) func.xml:18549(type) func.xml:19921(type)
#: func.xml:19932(type)
msgid "setof record"
msgstr "setof record"

#. +> REL_10
#: func.xml:9777(entry)
msgid "expand a <type>tsvector</type> to a set of rows"
msgstr "разворачивает <type>tsvector</type> в набор строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9778(literal)
msgid "unnest('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "unnest('fat:2,4 cat:3 rat:5A'::tsvector)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9779(literal)
msgid "(cat,{3},{D}) ..."
msgstr "(cat,{3},{D}) ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9786(para)
msgid ""
"All the text search functions that accept an optional <type>regconfig</type> "
"argument will use the configuration specified by <xref linkend=\"guc-default-"
"text-search-config\"/> when that argument is omitted."
msgstr ""
"Все функции текстового поиска, принимающие необязательный аргумент "
"<type>regconfig</type>, будут использовать конфигурацию, указанную в "
"параметре <xref linkend=\"guc-default-text-search-config\"/>, когда этот "
"аргумент опущен."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9794(para)
msgid ""
"The functions in <xref linkend=\"textsearch-functions-debug-table\"/> are "
"listed separately because they are not usually used in everyday text "
"searching operations. They are helpful for development and debugging of new "
"text search configurations."
msgstr ""
"Функции в <xref remap=\"6\" linkend=\"textsearch-functions-debug-table\"/> "
"перечислены отдельно, так как они не очень полезны в традиционных операциях "
"поиска. Они предназначены в основном для разработки и отладки новых "
"конфигураций текстового поиска."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9803(title)
msgid "Text Search Debugging Functions"
msgstr "Функции отладки текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9817(indexterm)
msgid "<primary>ts_debug</primary>"
msgstr "<primary>ts_debug</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(replaceable) func.xml:9863(replaceable)
#: func.xml:9871(replaceable)
msgid "alias"
msgstr "псевдоним"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(replaceable) func.xml:9863(replaceable)
#: func.xml:9871(replaceable)
msgid "description"
msgstr "описание"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(replaceable) func.xml:9832(replaceable)
#: func.xml:9844(replaceable) func.xml:9852(replaceable)
msgid "token"
msgstr "фрагмент"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(replaceable)
msgid "dictionaries"
msgstr "словари"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(type)
msgid "regdictionary[]"
msgstr "regdictionary[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(replaceable)
msgid "dictionary"
msgstr "словарь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(type) func.xml:9832(type)
msgid "regdictionary"
msgstr "regdictionary"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9820(function)
msgid ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>, OUT <placeholder-10/> <placeholder-11/"
">, OUT <placeholder-12/> <placeholder-13/>, OUT <placeholder-14/> "
"<placeholder-15/>)"
msgstr ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>, OUT <placeholder-10/> <placeholder-11/"
">, OUT <placeholder-12/> <placeholder-13/>, OUT <placeholder-14/> "
"<placeholder-15/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9823(entry)
msgid "test a configuration"
msgstr "проверяет конфигурацию"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9824(literal)
msgid "ts_debug('english', 'The Brightest supernovaes')"
msgstr "ts_debug('english', 'The Brightest supernovaes')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9825(literal)
msgid "(asciiword,\"Word, all ASCII\",The,{english_stem},english_stem,{}) ..."
msgstr ""
"(asciiword,\"Word, all ASCII\",The,{&zwsp;english_stem&zwsp;},&zwsp;"
"english_stem,{}) ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9829(indexterm)
msgid "<primary>ts_lexize</primary>"
msgstr "<primary>ts_lexize</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9832(replaceable)
msgid "dict"
msgstr "словарь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9832(function)
msgid ""
"ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9835(entry)
msgid "test a dictionary"
msgstr "проверяет словарь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9836(literal)
msgid "ts_lexize('english_stem', 'stars')"
msgstr "ts_lexize('english_stem', 'stars')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9837(literal)
msgid "{star}"
msgstr "{star}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9841(indexterm)
msgid "<primary>ts_parse</primary>"
msgstr "<primary>ts_parse</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9844(replaceable) func.xml:9863(replaceable)
msgid "parser_name"
msgstr "имя_анализатора"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9844(replaceable) func.xml:9852(replaceable)
#: func.xml:9863(replaceable) func.xml:9871(replaceable)
msgid "tokid"
msgstr "код_фрагмента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9844(function) func.xml:9852(function)
msgid ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> "
"<placeholder-8/>)"
msgstr ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> "
"<placeholder-8/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9847(entry) func.xml:9854(entry)
msgid "test a parser"
msgstr "проверяет анализатор"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9848(literal)
msgid "ts_parse('default', 'foo - bar')"
msgstr "ts_parse('default', 'foo - bar')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9849(literal) func.xml:9856(literal)
msgid "(1,foo) ..."
msgstr "(1,foo) ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9852(replaceable) func.xml:9871(replaceable)
msgctxt "replaceable"
msgid "parser_oid"
msgstr "oid_анализатора"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9852(type) func.xml:9871(type) func.xml:15846(type)
#: func.xml:15851(type) func.xml:17506(type) func.xml:17511(type)
#: func.xml:17998(type) func.xml:18018(type) func.xml:18033(type)
#: func.xml:19152(type) func.xml:19184(type) func.xml:19431(type)
#: func.xml:19513(type) func.xml:19680(type) func.xml:19696(type)
#: func.xml:19749(type)
msgid "oid"
msgstr "oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9855(literal)
msgid "ts_parse(3722, 'foo - bar')"
msgstr "ts_parse(3722, 'foo - bar')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9860(indexterm)
msgid "<primary>ts_token_type</primary>"
msgstr "<primary>ts_token_type</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9863(function) func.xml:9871(function)
msgid ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> "
"<placeholder-4/>, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/"
"> <placeholder-8/>)"
msgstr ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> "
"<placeholder-4/>, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/"
"> <placeholder-8/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9866(entry) func.xml:9873(entry)
msgid "get token types defined by parser"
msgstr "получает типы фрагментов, определённые анализатором"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9867(literal)
msgid "ts_token_type('default')"
msgstr "ts_token_type('default')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9868(literal) func.xml:9875(literal)
msgid "(1,asciiword,\"Word, all ASCII\") ..."
msgstr "(1,asciiword,\"Word, all ASCII\") ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9874(literal)
msgid "ts_token_type(3722)"
msgstr "ts_token_type(3722)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9879(indexterm)
msgid "<primary>ts_stat</primary>"
msgstr "<primary>ts_stat</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9882(replaceable)
msgid "sqlquery"
msgstr "sql_запрос"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9882(replaceable)
msgid "word"
msgstr "слово"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9882(replaceable)
msgid "ndoc"
msgstr "число_док"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9882(replaceable)
msgid "nentry"
msgstr "число_вхожд"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9882(function)
msgid ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>)"
msgstr ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9885(entry)
msgid "get statistics of a <type>tsvector</type> column"
msgstr "получает статистику столбца <type>tsvector</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9886(literal)
msgid "ts_stat('SELECT vector from apod')"
msgstr "ts_stat('SELECT vector from apod')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9887(literal)
msgid "(foo,10,15) ..."
msgstr "(foo,10,15) ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9897(title)
msgid "XML Functions"
msgstr "XML-функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9899(para)
msgid ""
"The functions and function-like expressions described in this section "
"operate on values of type <type>xml</type>. Check <xref linkend=\"datatype-"
"xml\"/> for information about the <type>xml</type> type. The function-like "
"expressions <function>xmlparse</function> and <function>xmlserialize</"
"function> for converting to and from type <type>xml</type> are not repeated "
"here. Use of most of these functions requires the installation to have been "
"built with <command>configure --with-libxml</command>."
msgstr ""
"Функции и подобные им выражения, описанные в этом разделе, работают со "
"значениями типа <type>xml</type>. Информацию о типе <type>xml</type> вы "
"можете найти в <xref remap=\"6\" linkend=\"datatype-xml\"/>. Выражения "
"<function>xmlparse</function> и <function>xmlserialize</function>, "
"преобразующие значения <type>xml</type> в текст и обратно, здесь повторно не "
"рассматриваются. Для использования большинства этих функций дистрибутив "
"должен быть собран с ключом <command>configure --with-libxml</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9911(title)
msgid "Producing XML Content"
msgstr "Создание XML-контента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9913(para)
msgid ""
"A set of functions and function-like expressions are available for producing "
"XML content from SQL data. As such, they are particularly suitable for "
"formatting query results into XML documents for processing in client "
"applications."
msgstr ""
"Для получения XML-контента из данных SQL существует целый набор функций и "
"функциональных выражений, особенно полезных для выдачи клиентским "
"приложениям результатов запроса в виде XML-документов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9921(literal)
msgctxt "literal"
msgid "xmlcomment"
msgstr "xmlcomment"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9923(indexterm)
msgid "<primary>xmlcomment</primary>"
msgstr "<primary>xmlcomment</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9928(function)
msgctxt "function"
msgid "xmlcomment"
msgstr "xmlcomment"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9928(replaceable) func.xml:10200(replaceable)
#: func.xml:10322(replaceable) func.xml:10372(replaceable)
#: func.xml:10373(replaceable) func.xml:10374(replaceable)
msgctxt "replaceable"
msgid "text"
msgstr "текст"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9927(synopsis) func.xml:10231(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>)"
msgstr "<placeholder-1/>(<placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9931(para)
msgid ""
"The function <function>xmlcomment</function> creates an XML value containing "
"an XML comment with the specified text as content. The text cannot contain "
"<quote><literal>--</literal></quote> or end with a <quote><literal>-</"
"literal></quote> so that the resulting construct is a valid XML comment. If "
"the argument is null, the result is null."
msgstr ""
"Функция <function>xmlcomment</function> создаёт XML-значение, содержащее XML-"
"комментарий с заданным текстом. Этот текст не должен содержать "
"<quote><literal>--</literal></quote> или заканчиваться знаком "
"<quote><literal>-</literal></quote>, чтобы результирующая конструкция была "
"допустимой в XML. Если аргумент этой функции NULL, результатом её тоже будет "
"NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9939(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlcomment('hello');\n"
"\n"
"  xmlcomment\n"
"--------------\n"
" <!--hello-->\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlcomment('hello');\n"
"\n"
"  xmlcomment\n"
"--------------\n"
" <!--hello-->\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9952(literal)
msgctxt "literal"
msgid "xmlconcat"
msgstr "xmlconcat"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9954(indexterm)
msgid "<primary>xmlconcat</primary>"
msgstr "<primary>xmlconcat</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9959(function)
msgctxt "function"
msgid "xmlconcat"
msgstr "xmlconcat"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9959(replaceable) func.xml:10200(replaceable)
#: func.xml:10232(replaceable) func.xml:10302(replaceable)
#: func.xml:10322(replaceable) func.xml:10454(replaceable)
#: func.xml:10519(replaceable)
msgctxt "replaceable"
msgid "xml"
msgstr "xml"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9959(optional) func.xml:10016(optional) func.xml:10114(optional)
#: func.xml:10558(optional) func.xml:10562(optional) func.xml:12335(optional)
#: func.xml:12400(optional) func.xml:12403(optional) func.xml:15173(optional)
#: func.xml:15204(optional)
msgid ", ..."
msgstr ", ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9958(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/><placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/><placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9962(para)
msgid ""
"The function <function>xmlconcat</function> concatenates a list of "
"individual XML values to create a single value containing an XML content "
"fragment. Null values are omitted; the result is only null if there are no "
"nonnull arguments."
msgstr ""
"Функция <function>xmlconcat</function> объединяет несколько XML-значений и "
"выдаёт в результате один фрагмент XML-контента. Значения NULL отбрасываются, "
"так что результат будет равен NULL, только если все аргументы равны NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9969(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlconcat('<abc/>', '<bar>foo</bar>');\n"
"\n"
"      xmlconcat\n"
"----------------------\n"
" <abc/><bar>foo</bar>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlconcat('<abc/>', '<bar>foo</bar>');\n"
"\n"
"      xmlconcat\n"
"----------------------\n"
" <abc/><bar>foo</bar>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9980(para)
msgid ""
"XML declarations, if present, are combined as follows. If all argument "
"values have the same XML version declaration, that version is used in the "
"result, else no version is used. If all argument values have the standalone "
"declaration value <quote>yes</quote>, then that value is used in the result. "
"If all argument values have a standalone declaration value and at least one "
"is <quote>no</quote>, then that is used in the result. Else the result will "
"have no standalone declaration. If the result is determined to require a "
"standalone declaration but no version declaration, a version declaration "
"with version 1.0 will be used because XML requires an XML declaration to "
"contain a version declaration. Encoding declarations are ignored and removed "
"in all cases."
msgstr ""
"XML-объявления, если они присутствуют, обрабатываются следующим образом. "
"Если во всех аргументах содержатся объявления одной версии XML, эта версия "
"будет выдана в результате; в противном случае версии не будет. Если во всех "
"аргументах определён атрибут standalone со значением <quote>yes</quote>, это "
"же значение будет выдано в результате. Если во всех аргументах есть "
"объявление standalone, но минимум в одном со значением <quote>no</quote>, в "
"результате будет это значение. В противном случае в результате не будет "
"объявления standalone. Если же окажется, что в результате должно "
"присутствовать объявление standalone, а версия не определена, тогда в "
"результате будет выведена версия 1.0, так как XML-объявление не будет "
"допустимым без указания версии. Указания кодировки игнорируются и будут "
"удалены в любых случаях."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:9996(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlconcat('<?xml version=\"1.1\"?><foo/>', '<?xml version=\"1.1\" "
"standalone=\"no\"?><bar/>');\n"
"\n"
"             xmlconcat\n"
"-----------------------------------\n"
" <?xml version=\"1.1\"?><foo/><bar/>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlconcat('<?xml version=\"1.1\"?><foo/>', '<?xml version=\"1.1\" "
"standalone=\"no\"?><bar/>');\n"
"\n"
"             xmlconcat\n"
"-----------------------------------\n"
" <?xml version=\"1.1\"?><foo/><bar/>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10009(literal)
msgctxt "literal"
msgid "xmlelement"
msgstr "xmlelement"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10011(indexterm)
msgid "<primary>xmlelement</primary>"
msgstr "<primary>xmlelement</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10016(function)
msgctxt "function"
msgid "xmlelement"
msgstr "xmlelement"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10016(replaceable) func.xml:10114(replaceable)
#: func.xml:10560(replaceable) func.xml:13467(replaceable)
#: func.xml:13484(replaceable)
msgctxt "replaceable"
msgid "name"
msgstr "имя"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10016(replaceable) func.xml:12335(replaceable)
#: func.xml:12400(replaceable) func.xml:12403(replaceable)
#: func.xml:13467(replaceable) func.xml:13484(replaceable)
#: func.xml:14590(replaceable) func.xml:14596(replaceable)
#: func.xml:14619(replaceable) func.xml:14625(replaceable)
#: func.xml:14647(replaceable) func.xml:14650(replaceable)
#: func.xml:14663(replaceable) func.xml:14666(replaceable)
#: func.xml:14680(replaceable) func.xml:14684(replaceable)
#: func.xml:15173(replaceable) func.xml:15204(replaceable)
msgctxt "replaceable"
msgid "value"
msgstr "значение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10016(replaceable)
msgid "attname"
msgstr "атрибут"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10016(optional) func.xml:10114(optional)
msgid "AS <placeholder-1/>"
msgstr "AS <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10016(optional)
msgid ", xmlattributes(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr ", xmlattributes(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10016(replaceable)
msgid ", content, ..."
msgstr ", содержимое, ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10015(synopsis)
#, no-wrap
msgid "<placeholder-1/>(name <placeholder-2/> <placeholder-3/> <optional><placeholder-4/></optional>)"
msgstr ""
"<placeholder-1/>(name <placeholder-2/> <placeholder-3/>\n"
"  <optional><placeholder-4/></optional>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10019(para)
msgid ""
"The <function>xmlelement</function> expression produces an XML element with "
"the given name, attributes, and content."
msgstr ""
"Выражение <function>xmlelement</function> создаёт XML-элемент с заданным "
"именем, атрибутами и содержимым."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10024(para)
msgid ""
"Examples: <screen><![CDATA[\n"
"SELECT xmlelement(name foo);\n"
"\n"
" xmlelement\n"
"------------\n"
" <foo/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar));\n"
"\n"
"    xmlelement\n"
"------------------\n"
" <foo bar=\"xyz\"/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', "
"'ent');\n"
"\n"
"             xmlelement\n"
"-------------------------------------\n"
" <foo bar=\"2007-01-26\">content</foo>\n"
"]]></screen>"
msgstr ""
"Примеры: <screen><![CDATA[\n"
"SELECT xmlelement(name foo);\n"
"\n"
" xmlelement\n"
"------------\n"
" <foo/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar));\n"
"\n"
"    xmlelement\n"
"------------------\n"
" <foo bar=\"xyz\"/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', "
"'ent');\n"
"\n"
"             xmlelement\n"
"-------------------------------------\n"
" <foo bar=\"2007-01-26\">content</foo>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10047(para)
msgid ""
"Element and attribute names that are not valid XML names are escaped by "
"replacing the offending characters by the sequence "
"<literal>_x<replaceable>HHHH</replaceable>_</literal>, where "
"<replaceable>HHHH</replaceable> is the character's Unicode codepoint in "
"hexadecimal notation. For example: <screen><![CDATA[\n"
"SELECT xmlelement(name \"foo$bar\", xmlattributes('xyz' as \"a&b\"));\n"
"\n"
"            xmlelement\n"
"----------------------------------\n"
" <foo_x0024_bar a_x0026_b=\"xyz\"/>\n"
"]]></screen>"
msgstr ""
"Если имена элементов и атрибутов содержат символы, недопустимые в XML, эти "
"символы заменяются последовательностями <literal>_x<replaceable>HHHH</"
"replaceable>_</literal>, где <replaceable>HHHH</replaceable> — "
"шестнадцатеричный код символа в Unicode. Например: <screen><![CDATA[\n"
"SELECT xmlelement(name \"foo$bar\", xmlattributes('xyz' as \"a&b\"));\n"
"\n"
"            xmlelement\n"
"----------------------------------\n"
" <foo_x0024_bar a_x0026_b=\"xyz\"/>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10062(para)
msgid ""
"An explicit attribute name need not be specified if the attribute value is a "
"column reference, in which case the column's name will be used as the "
"attribute name by default. In other cases, the attribute must be given an "
"explicit name. So this example is valid: <screen>\n"
"CREATE TABLE test (a xml, b xml);\n"
"SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;\n"
"</screen> But these are not: <screen>\n"
"SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;\n"
"SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;\n"
"</screen>"
msgstr ""
"Если в качестве значения атрибута используется столбец таблицы, имя атрибута "
"можно не указывать явно, этим именем станет имя столбца. Во всех остальных "
"случаях имя атрибута должно быть определено явно. Таким образом, это "
"выражение допустимо: <screen>\n"
"CREATE TABLE test (a xml, b xml);\n"
"SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;\n"
"</screen> А следующие варианты &mdash; нет: <screen>\n"
"SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;\n"
"SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10079(para)
msgid ""
"Element content, if specified, will be formatted according to its data type. "
"If the content is itself of type <type>xml</type>, complex XML documents can "
"be constructed. For example: <screen><![CDATA[\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar),\n"
"                            xmlelement(name abc),\n"
"                            xmlcomment('test'),\n"
"                            xmlelement(name xyz));\n"
"\n"
"                  xmlelement\n"
"----------------------------------------------\n"
" <foo bar=\"xyz\"><abc/><!--test--><xyz/></foo>\n"
"]]></screen> Content of other types will be formatted into valid XML "
"character data. This means in particular that the characters &lt;, &gt;, and "
"&amp; will be converted to entities. Binary data (data type <type>bytea</"
"type>) will be represented in base64 or hex encoding, depending on the "
"setting of the configuration parameter <xref linkend=\"guc-xmlbinary\"/>. "
"The particular behavior for individual data types is expected to evolve in "
"order to align the SQL and PostgreSQL data types with the XML Schema "
"specification, at which point a more precise description will appear."
msgstr ""
"Содержимое элемента, если оно задано, будет форматировано согласно его типу "
"данных. Когда оно само имеет тип <type>xml</type>, из него можно "
"конструировать сложные XML-документы. Например: <screen><![CDATA[\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar),\n"
"                            xmlelement(name abc),\n"
"                            xmlcomment('test'),\n"
"                            xmlelement(name xyz));\n"
"\n"
"                  xmlelement\n"
"----------------------------------------------\n"
" <foo bar=\"xyz\"><abc/><!--test--><xyz/></foo>\n"
"]]></screen> Содержимое других типов будет оформлено в виде блока символьных "
"данных XML. Это, в частности, означает, что символы &lt;, &gt; и &amp; будут "
"преобразованы в сущности XML. Двоичные данные (данные типа <type>bytea</"
"type>) представляются в кодировке base64 или в шестнадцатеричном виде, в "
"зависимости от значения параметра <xref linkend=\"guc-xmlbinary\"/>. Следует "
"ожидать, что конкретные представления отдельных типов данных могут быть "
"изменены для приведения типов SQL и PostgreSQL в соответствие со стандартом "
"XML Schema, когда появится его более полное описание."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10107(literal)
msgctxt "literal"
msgid "xmlforest"
msgstr "xmlforest"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10109(indexterm)
msgid "<primary>xmlforest</primary>"
msgstr "<primary>xmlforest</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10114(function)
msgctxt "function"
msgid "xmlforest"
msgstr "xmlforest"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10114(replaceable) func.xml:10171(replaceable)
msgctxt "replaceable"
msgid "content"
msgstr "содержимое"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10113(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/> <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10117(para)
msgid ""
"The <function>xmlforest</function> expression produces an XML forest "
"(sequence) of elements using the given names and content."
msgstr ""
"Выражение <function>xmlforest</function> создаёт последовательность XML-"
"элементов с заданными именами и содержимым."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10122(para)
msgid ""
"Examples: <screen><![CDATA[\n"
"SELECT xmlforest('abc' AS foo, 123 AS bar);\n"
"\n"
"          xmlforest\n"
"------------------------------\n"
" <foo>abc</foo><bar>123</bar>\n"
"\n"
"\n"
"SELECT xmlforest(table_name, column_name)\n"
"FROM information_schema.columns\n"
"WHERE table_schema = 'pg_catalog';\n"
"\n"
"                                         xmlforest\n"
"-------------------------------------------------------------------------------------------\n"
" <table_name>pg_authid</table_name><column_name>rolname</column_name>\n"
" <table_name>pg_authid</table_name><column_name>rolsuper</column_name>\n"
" ...\n"
"]]></screen> As seen in the second example, the element name can be omitted "
"if the content value is a column reference, in which case the column name is "
"used by default. Otherwise, a name must be specified."
msgstr ""
"Примеры: <screen><![CDATA[\n"
"SELECT xmlforest('abc' AS foo, 123 AS bar);\n"
"\n"
"          xmlforest\n"
"------------------------------\n"
" <foo>abc</foo><bar>123</bar>\n"
"\n"
"\n"
"SELECT xmlforest(table_name, column_name)\n"
"FROM information_schema.columns\n"
"WHERE table_schema = 'pg_catalog';\n"
"\n"
"                                         xmlforest\n"
"-------------------------------------------------------------------------------------------\n"
" <table_name>pg_authid</table_name><column_name>rolname</column_name>\n"
" <table_name>pg_authid</table_name><column_name>rolsuper</column_name>\n"
" ...\n"
"]]></screen> Как показано во втором примере, имя элемента можно опустить, "
"если источником содержимого служит столбец (в этом случае именем элемента по "
"умолчанию будет имя столбца). В противном случае это имя необходимо "
"указывать."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10148(para)
msgid ""
"Element names that are not valid XML names are escaped as shown for "
"<function>xmlelement</function> above. Similarly, content data is escaped to "
"make valid XML content, unless it is already of type <type>xml</type>."
msgstr ""
"Имена элементов с символами, недопустимыми для XML, преобразуются так же, "
"как и для <function>xmlelement</function>. Данные содержимого тоже "
"приводятся к виду, допустимому для XML (кроме данных, которые уже имеют тип "
"<type>xml</type>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10155(para)
msgid ""
"Note that XML forests are not valid XML documents if they consist of more "
"than one element, so it might be useful to wrap <function>xmlforest</"
"function> expressions in <function>xmlelement</function>."
msgstr ""
"Заметьте, что такие XML-последовательности не являются допустимыми XML-"
"документами, если они содержат больше одного элемента на верхнем уровне, "
"поэтому может иметь смысл вложить выражения <function>xmlforest</function> в "
"<function>xmlelement</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10164(literal)
msgctxt "literal"
msgid "xmlpi"
msgstr "xmlpi"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10166(indexterm)
msgid "<primary>xmlpi</primary>"
msgstr "<primary>xmlpi</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10171(function)
msgctxt "function"
msgid "xmlpi"
msgstr "xmlpi"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10170(synopsis)
#, no-wrap
msgid "<placeholder-1/>(name <placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/>(name <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10174(para)
msgid ""
"The <function>xmlpi</function> expression creates an XML processing "
"instruction. The content, if present, must not contain the character "
"sequence <literal>?&gt;</literal>."
msgstr ""
"Выражение <function>xmlpi</function> создаёт инструкцию обработки XML. "
"Содержимое, если оно задано, не должно содержать последовательность символов "
"<literal>?&gt;</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10180(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlpi(name php, 'echo \"hello world\";');\n"
"\n"
"            xmlpi\n"
"-----------------------------\n"
" <?php echo \"hello world\";?>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlpi(name php, 'echo \"hello world\";');\n"
"\n"
"            xmlpi\n"
"-----------------------------\n"
" <?php echo \"hello world\";?>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10193(literal)
msgctxt "literal"
msgid "xmlroot"
msgstr "xmlroot"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10195(indexterm)
msgid "<primary>xmlroot</primary>"
msgstr "<primary>xmlroot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10200(function)
msgctxt "function"
msgid "xmlroot"
msgstr "xmlroot"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10200(optional)
msgid ", standalone yes|no|no value"
msgstr ", standalone yes|no|нет значения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10199(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/>, version <placeholder-3/> | no value <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, version <placeholder-3/> | нет значения <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10203(para)
msgid ""
"The <function>xmlroot</function> expression alters the properties of the "
"root node of an XML value. If a version is specified, it replaces the value "
"in the root node's version declaration; if a standalone setting is "
"specified, it replaces the value in the root node's standalone declaration."
msgstr ""
"Выражение <function>xmlroot</function> изменяет свойства корневого узла XML-"
"значения. Если в нём указывается версия, она заменяет значение в объявлении "
"версии корневого узла; также в корневой узел переносится значение свойства "
"standalone."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10225(literal)
msgctxt "literal"
msgid "xmlagg"
msgstr "xmlagg"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10227(indexterm) func.xml:13577(indexterm)
msgid "<primary>xmlagg</primary>"
msgstr "<primary>xmlagg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10232(function)
msgctxt "function"
msgid "xmlagg"
msgstr "xmlagg"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10235(para)
msgid ""
"The function <function>xmlagg</function> is, unlike the other functions "
"described here, an aggregate function. It concatenates the input values to "
"the aggregate function call, much like <function>xmlconcat</function> does, "
"except that concatenation occurs across rows rather than across expressions "
"in a single row. See <xref linkend=\"functions-aggregate\"/> for additional "
"information about aggregate functions."
msgstr ""
"Функция <function>xmlagg</function>, в отличие от других описанных здесь "
"функций, является агрегатной. Она соединяет значения, поступающие на вход "
"агрегатной функции, подобно функции <function>xmlconcat</function>, но "
"делает это, обрабатывая множество строк, а не несколько выражений в одной "
"строке. Дополнительно агрегатные функции описаны в <xref remap=\"6\" linkend="
"\"functions-aggregate\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10245(para)
msgid ""
"Example: <screen><![CDATA[\n"
"CREATE TABLE test (y int, x xml);\n"
"INSERT INTO test VALUES (1, '<foo>abc</foo>');\n"
"INSERT INTO test VALUES (2, '<bar/>');\n"
"SELECT xmlagg(x) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <foo>abc</foo><bar/>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"CREATE TABLE test (y int, x xml);\n"
"INSERT INTO test VALUES (1, '<foo>abc</foo>');\n"
"INSERT INTO test VALUES (2, '<bar/>');\n"
"SELECT xmlagg(x) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <foo>abc</foo><bar/>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10258(para)
msgid ""
"To determine the order of the concatenation, an <literal>ORDER BY</literal> "
"clause may be added to the aggregate call as described in <xref linkend="
"\"syntax-aggregates\"/>. For example: <screen><![CDATA[\n"
"SELECT xmlagg(x ORDER BY y DESC) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"
msgstr ""
"Чтобы задать порядок сложения элементов, в агрегатный вызов можно добавить "
"предложение <literal>ORDER BY</literal>, описанное в <xref linkend=\"syntax-"
"aggregates\"/>. Например: <screen><![CDATA[\n"
"SELECT xmlagg(x ORDER BY y DESC) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10271(para)
msgid ""
"The following non-standard approach used to be recommended in previous "
"versions, and may still be useful in specific cases: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"
msgstr ""
"Следующий нестандартный подход рекомендовался в предыдущих версиях и может "
"быть по-прежнему полезен в некоторых случаях: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10287(title)
msgid "XML Predicates"
msgstr "Условия с XML"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10289(para)
msgid ""
"The expressions described in this section check properties of <type>xml</"
"type> values."
msgstr ""
"Описанные в этом разделе выражения проверяют свойства значений <type>xml</"
"type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10295(literal)
msgid "IS DOCUMENT"
msgstr "IS DOCUMENT"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10297(indexterm)
msgid "<primary>IS DOCUMENT</primary>"
msgstr "<primary>IS DOCUMENT</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10301(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS DOCUMENT"
msgstr "<placeholder-1/> IS DOCUMENT"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10305(para)
msgid ""
"The expression <literal>IS DOCUMENT</literal> returns true if the argument "
"XML value is a proper XML document, false if it is not (that is, it is a "
"content fragment), or null if the argument is null. See <xref linkend="
"\"datatype-xml\"/> about the difference between documents and content "
"fragments."
msgstr ""
"Выражение <literal>IS DOCUMENT</literal> возвращает true, если аргумент "
"представляет собой правильный XML-документ, false в противном случае (т. е. "
"если это фрагмент содержимого) и NULL, если его аргумент также NULL. Чем "
"документы отличаются от фрагментов содержимого, вы можете узнать в <xref "
"remap=\"6\" linkend=\"datatype-xml\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10315(literal)
msgctxt "literal"
msgid "XMLEXISTS"
msgstr "XMLEXISTS"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10317(indexterm)
msgid "<primary>XMLEXISTS</primary>"
msgstr "<primary>XMLEXISTS</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10322(function)
msgctxt "function"
msgid "XMLEXISTS"
msgstr "XMLEXISTS"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10322(optional) func.xml:10559(optional)
msgid "BY REF"
msgstr "BY REF"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10321(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> PASSING <placeholder-3/> <placeholder-4/> <placeholder-5/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>\n"
" PASSING <placeholder-3/> <placeholder-4/> <placeholder-5/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10325(para)
msgid ""
"The function <function>xmlexists</function> returns true if the XPath "
"expression in the first argument returns any nodes, and false otherwise. (If "
"either argument is null, the result is null.)"
msgstr ""
"Функция <function>xmlexists</function> возвращает true, если выражение XPath "
"в первом аргументе возвращает какие либо узлы, и false &mdash; в противном "
"случае. (Если один из аргументов равен NULL, результатом также будет NULL.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10332(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF "
"'<towns><town>Toronto</town><town>Ottawa</town></towns>');\n"
"\n"
" xmlexists\n"
"------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF "
"'<towns><town>Toronto</town><town>Ottawa</town></towns>');\n"
"\n"
" xmlexists\n"
"------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10344(para)
msgid ""
"The <literal>BY REF</literal> clauses have no effect in PostgreSQL, but are "
"allowed for SQL conformance and compatibility with other implementations. "
"Per SQL standard, the first <literal>BY REF</literal> is required, the "
"second is optional. Also note that the SQL standard specifies the "
"<function>xmlexists</function> construct to take an XQuery expression as "
"first argument, but PostgreSQL currently only supports XPath, which is a "
"subset of XQuery."
msgstr ""
"Указания <literal>BY REF</literal> не несут смысловой нагрузки в PostgreSQL, "
"но могут присутствовать для соответствия стандарту SQL и совместимости с "
"другими реализациями. По стандарту SQL первое указание <literal>BY REF</"
"literal> является обязательным, а второе &mdash; нет. Также заметьте, что, "
"согласно стандарту SQL, конструкция <function>xmlexists</function> должна "
"принимать в первом аргументе выражение XQuery, но PostgreSQL в настоящее "
"время поддерживает только XPath, подмножество XQuery."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10357(literal)
msgctxt "literal"
msgid "xml_is_well_formed"
msgstr "xml_is_well_formed"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10359(indexterm)
msgid "<primary>xml_is_well_formed</primary>"
msgstr "<primary>xml_is_well_formed</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10363(indexterm)
msgid "<primary>xml_is_well_formed_document</primary>"
msgstr "<primary>xml_is_well_formed_document</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10367(indexterm)
msgid "<primary>xml_is_well_formed_content</primary>"
msgstr "<primary>xml_is_well_formed_content</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10372(function)
msgctxt "function"
msgid "xml_is_well_formed"
msgstr "xml_is_well_formed"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10373(function)
msgid "xml_is_well_formed_document"
msgstr "xml_is_well_formed_document"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10374(function)
msgid "xml_is_well_formed_content"
msgstr "xml_is_well_formed_content"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10371(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/>(<placeholder-2/>)\n"
"<placeholder-3/>(<placeholder-4/>)\n"
"<placeholder-5/>(<placeholder-6/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>)\n"
"<placeholder-3/>(<placeholder-4/>)\n"
"<placeholder-5/>(<placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10377(para)
msgid ""
"These functions check whether a <type>text</type> string is well-formed XML, "
"returning a Boolean result. <function>xml_is_well_formed_document</function> "
"checks for a well-formed document, while "
"<function>xml_is_well_formed_content</function> checks for well-formed "
"content. <function>xml_is_well_formed</function> does the former if the "
"<xref linkend=\"guc-xmloption\"/> configuration parameter is set to "
"<literal>DOCUMENT</literal>, or the latter if it is set to <literal>CONTENT</"
"literal>. This means that <function>xml_is_well_formed</function> is useful "
"for seeing whether a simple cast to type <type>xml</type> will succeed, "
"whereas the other two functions are useful for seeing whether the "
"corresponding variants of <function>XMLPARSE</function> will succeed."
msgstr ""
"Эти функции проверяют, является ли <type>текст</type> правильно оформленным "
"XML, и возвращают соответствующее логическое значение. Функция "
"<function>xml_is_well_formed_document</function> проверяет аргумент как "
"правильно оформленный документ, а <function>xml_is_well_formed_content</"
"function> &mdash; правильно оформленное содержание. Функция "
"<function>xml_is_well_formed</function> может делать первое или второе, в "
"зависимости от значения параметра конфигурации <xref linkend=\"guc-xmloption"
"\"/> (<literal>DOCUMENT</literal> или <literal>CONTENT</literal>, "
"соответственно). Это значит, что <function>xml_is_well_formed</function> "
"помогает понять, будет ли успешным простое приведение к типу <type>xml</"
"type>, тогда как две другие функции проверяют, будут ли успешны "
"соответствующие варианты <function>XMLPARSE</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10392(para)
msgid ""
"Examples: <screen><![CDATA[\n"
"SET xmloption TO DOCUMENT;\n"
"SELECT xml_is_well_formed('<>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed('<abc/>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SET xmloption TO CONTENT;\n"
"SELECT xml_is_well_formed('abc');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</pg:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</my:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" f\n"
"(1 row)\n"
"]]></screen> The last example shows that the checks include whether "
"namespaces are correctly matched."
msgstr ""
"Примеры: <screen><![CDATA[\n"
"SET xmloption TO DOCUMENT;\n"
"SELECT xml_is_well_formed('<>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed('<abc/>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SET xmloption TO CONTENT;\n"
"SELECT xml_is_well_formed('abc');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</pg:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</my:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" f\n"
"(1 row)\n"
"]]></screen> Последний пример показывает, что при проверке также учитываются "
"сопоставления пространств имён."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10436(title)
msgid "Processing XML"
msgstr "Обработка XML"

#. +> REL_10
#: func.xml:10438(para)
msgid ""
"To process values of data type <type>xml</type>, PostgreSQL offers the "
"functions <function>xpath</function> and <function>xpath_exists</function>, "
"which evaluate XPath 1.0 expressions, and the <function>XMLTABLE</function> "
"table function."
msgstr ""
"Для обработки значений типа <type>xml</type> в PostgreSQL представлены "
"функции <function>xpath</function> и <function>xpath_exists</function>, "
"вычисляющие выражения XPath 1.0, а также табличная функция "
"<function>XMLTABLE</function>."

#. +> REL_10
#: func.xml:10447(literal)
msgctxt "literal"
msgid "xpath"
msgstr "xpath"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10449(indexterm)
msgid "<primary>XPath</primary>"
msgstr "<primary>XPath</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10454(function)
msgctxt "function"
msgid "xpath"
msgstr "xpath"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10454(replaceable) func.xml:10519(replaceable)
msgctxt "replaceable"
msgid "xpath"
msgstr "xpath"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10454(replaceable) func.xml:10519(replaceable)
msgid "nsarray"
msgstr "nsarray"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10453(synopsis) func.xml:10518(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10457(para)
msgid ""
"The function <function>xpath</function> evaluates the XPath expression "
"<replaceable>xpath</replaceable> (a <type>text</type> value) against the XML "
"value <replaceable>xml</replaceable>. It returns an array of XML values "
"corresponding to the node set produced by the XPath expression. If the XPath "
"expression returns a scalar value rather than a node set, a single-element "
"array is returned."
msgstr ""
"Функция <function>xpath</function> вычисляет выражение XPath (аргумент "
"<replaceable>xpath</replaceable> типа <type>text</type>) для заданного "
"<replaceable>xml</replaceable>. Она возвращает массив XML-значений с набором "
"узлов, полученных в результате выражения XPath. Если выражение XPath выдаёт "
"не набор узлов, а скалярное значение, возвращается массив из одного элемента."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10467(para)
msgid ""
"The second argument must be a well formed XML document. In particular, it "
"must have a single root node element."
msgstr ""
"Вторым аргументом должен быть правильно оформленный XML-документ. В "
"частности, в нём должен быть единственный корневой элемент."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10472(para)
msgid ""
"The optional third argument of the function is an array of namespace "
"mappings. This array should be a two-dimensional <type>text</type> array "
"with the length of the second axis being equal to 2 (i.e., it should be an "
"array of arrays, each of which consists of exactly 2 elements). The first "
"element of each array entry is the namespace name (alias), the second the "
"namespace URI. It is not required that aliases provided in this array be the "
"same as those being used in the XML document itself (in other words, both in "
"the XML document and in the <function>xpath</function> function context, "
"aliases are <emphasis>local</emphasis>)."
msgstr ""
"В необязательном третьем аргументе функции передаются сопоставления "
"пространств имён. Эти сопоставления должны определяться в двумерном массиве "
"типа <type>text</type>, во второй размерности которого 2 элемента (т. е. это "
"должен быть массив массивов, состоящих из 2 элементов). В первом элементе "
"каждого массива определяется псевдоним (префикс) пространства имён, а во "
"втором &mdash; его URI. Псевдонимы, определённые в этом массиве, не "
"обязательно должны совпадать с префиксами пространств имён в самом XML-"
"документе (другими словами, для XML-документа и функции <function>xpath</"
"function> псевдонимы имеют <emphasis>локальный</emphasis> характер)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10484(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xpath('/my:a/text()', '<my:a xmlns:my=\"http://example.com\">test</my:"
"a>',\n"
"             ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath  \n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xpath('/my:a/text()', '<my:a xmlns:my=\"http://example.com\">test</my:"
"a>',\n"
"             ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath  \n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10497(para)
msgid ""
"To deal with default (anonymous) namespaces, do something like this: "
"<screen><![CDATA[\n"
"SELECT xpath('//mydefns:b/text()', '<a xmlns=\"http://example.com\"><b>test</"
"b></a>',\n"
"             ARRAY[ARRAY['mydefns', 'http://example.com']]);\n"
"\n"
" xpath\n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Для пространства имён по умолчанию (анонимного) это выражение можно записать "
"так: <screen><![CDATA[\n"
"SELECT xpath('//mydefns:b/text()', '<a xmlns=\"http://example.com\"><b>test</"
"b></a>',\n"
"             ARRAY[ARRAY['mydefns', 'http://example.com']]);\n"
"\n"
" xpath\n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"

#. +> REL_10
#: func.xml:10512(literal)
msgctxt "literal"
msgid "xpath_exists"
msgstr "xpath_exists"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10514(indexterm)
msgid "<primary>xpath_exists</primary>"
msgstr "<primary>xpath_exists</primary>"

#. +> REL_10
#: func.xml:10519(function)
msgctxt "function"
msgid "xpath_exists"
msgstr "xpath_exists"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10522(para)
msgid ""
"The function <function>xpath_exists</function> is a specialized form of the "
"<function>xpath</function> function. Instead of returning the individual XML "
"values that satisfy the XPath, this function returns a Boolean indicating "
"whether the query was satisfied or not. This function is equivalent to the "
"standard <literal>XMLEXISTS</literal> predicate, except that it also offers "
"support for a namespace mapping argument."
msgstr ""
"Функция <function>xpath_exists</function> представляет собой "
"специализированную форму функции <function>xpath</function>. Она возвращает "
"не весь набор XML-узлов, удовлетворяющих выражению XPath, а только одно "
"логическое значение, показывающее, есть ли такие узлы. Эта функция "
"равнозначна стандартному условию <literal>XMLEXISTS</literal>, за "
"исключением того, что она также поддерживает сопоставления пространств имён."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10531(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my=\"http://example.com"
"\">test</my:a>',\n"
"                     ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath_exists  \n"
"--------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my=\"http://example.com"
"\">test</my:a>',\n"
"                     ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath_exists  \n"
"--------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"

#. +> REL_10
#: func.xml:10546(literal)
msgctxt "literal"
msgid "xmltable"
msgstr "xmltable"

#. +> REL_10
#: func.xml:10548(indexterm)
msgid "<primary>xmltable</primary>"
msgstr "<primary>xmltable</primary>"

#. +> REL_10
#: func.xml:10552(indexterm)
msgid "<primary>table function</primary> <secondary>XMLTABLE</secondary>"
msgstr "<primary>табличная функция</primary> <secondary>XMLTABLE</secondary>"

#. +> REL_10
#: func.xml:10558(function)
msgctxt "function"
msgid "xmltable"
msgstr "xmltable"

#. +> REL_10
#: func.xml:10558(replaceable)
msgid "namespace uri"
msgstr "URI пространства имён"

#. +> REL_10
#: func.xml:10558(replaceable)
msgid "namespace name"
msgstr "имя пространства имён"

#. +> REL_10
#: func.xml:10558(optional)
msgid "XMLNAMESPACES(<placeholder-1/> AS <placeholder-2/><placeholder-3/>),"
msgstr "XMLNAMESPACES(<placeholder-1/> AS <placeholder-2/><placeholder-3/>),"

#. +> REL_10
#: func.xml:10559(replaceable)
msgid "row_expression"
msgstr "выражение_строки"

#. +> REL_10
#: func.xml:10559(replaceable)
msgid "document_expression"
msgstr "выражение_документа"

#. +> REL_10
#: func.xml:10560(replaceable)
msgctxt "replaceable"
msgid "type"
msgstr "тип"

#. +> REL_10
#: func.xml:10560(replaceable)
msgid "column_expression"
msgstr "выражение_столбца"

#. +> REL_10
#: func.xml:10560(optional)
msgid "PATH <placeholder-1/>"
msgstr "PATH <placeholder-1/>"

#. +> REL_10
#: func.xml:10560(replaceable)
msgid "default_expression"
msgstr "выражение_по_умолчанию"

#. +> REL_10
#: func.xml:10560(optional)
msgid "DEFAULT <placeholder-1/>"
msgstr "DEFAULT <placeholder-1/>"

#. +> REL_10
#: func.xml:10560(optional)
msgid "NOT NULL | NULL"
msgstr "NOT NULL | NULL"

#. +> REL_10
#: func.xml:10557(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/>( <placeholder-2/>\n"
"          <placeholder-3/> PASSING <placeholder-4/> <placeholder-5/> <placeholder-6/>\n"
"          COLUMNS <placeholder-7/> { <placeholder-8/> <placeholder-9/> <placeholder-10/> <placeholder-11/>\n"
"                        | FOR ORDINALITY }\n"
"                   <placeholder-12/>\n"
")"
msgstr ""
"<placeholder-1/>( <placeholder-2/>\n"
"          <placeholder-3/> PASSING <placeholder-4/> <placeholder-5/> <placeholder-6/>\n"
"          COLUMNS <placeholder-7/> { <placeholder-8/> <placeholder-9/> <placeholder-10/> <placeholder-11/>\n"
"                        | FOR ORDINALITY }\n"
"                   <placeholder-12/>\n"
")"

#. +> REL_10
#: func.xml:10566(para)
msgid ""
"The <function>xmltable</function> function produces a table based on the "
"given XML value, an XPath filter to extract rows, and an optional set of "
"column definitions."
msgstr ""
"Функция <function>xmltable</function> строит таблицу из данного XML-значения "
"по фильтру XPath, извлекающему строки, с необязательным набором определений "
"столбцов."

#. +> REL_10
#: func.xml:10572(para)
msgid ""
"The optional <literal>XMLNAMESPACES</literal> clause is a comma-separated "
"list of namespaces. It specifies the XML namespaces used in the document and "
"their aliases. A default namespace specification is not currently supported."
msgstr ""
"Необязательное предложение <literal>XMLNAMESPACES</literal> задаёт "
"разделённый запятыми список пространств имён. В нём определяются "
"пространства имён XML и их псевдонимы. Определение пространства по умолчанию "
"в настоящее время не поддерживается."

#. +> REL_10
#: func.xml:10579(para)
msgid ""
"The required <replaceable>row_expression</replaceable> argument is an XPath "
"expression that is evaluated against the supplied XML document to obtain an "
"ordered sequence of XML nodes. This sequence is what <function>xmltable</"
"function> transforms into output rows."
msgstr ""
"Обязательный аргумент <replaceable>выражение_строки</replaceable> задаёт "
"выражение XPath, вычисляемое в данном XML-документе и выдающее упорядоченную "
"последовательность XML-узлов. Эту последовательность <function>xmltable</"
"function> преобразует в выходные строки."

#. +> REL_10
#: func.xml:10586(para)
msgid ""
"<replaceable>document_expression</replaceable> provides the XML document to "
"operate on. The <literal>BY REF</literal> clauses have no effect in "
"PostgreSQL, but are allowed for SQL conformance and compatibility with other "
"implementations. The argument must be a well-formed XML document; fragments/"
"forests are not accepted."
msgstr ""
"В аргументе <replaceable>выражение_документа</replaceable> передаётся XML-"
"документ для обработки. Предложения <literal>BY REF</literal> не действуют в "
"PostgreSQL, но допускаются для соответствия стандарту SQL и совместимости с "
"другими реализациями. Передаваемый XML-документ должен быть правильно "
"оформленным; фрагменты/леса не принимаются."

#. +> REL_10
#: func.xml:10596(para)
msgid ""
"The mandatory <literal>COLUMNS</literal> clause specifies the list of "
"columns in the output table. If the <literal>COLUMNS</literal> clause is "
"omitted, the rows in the result set contain a single column of type "
"<literal>xml</literal> containing the data matched by "
"<replaceable>row_expression</replaceable>. If <literal>COLUMNS</literal> is "
"specified, each entry describes a single column. See the syntax summary "
"above for the format. The column name and type are required; the path, "
"default and nullability clauses are optional."
msgstr ""
"В предложении <literal>COLUMNS</literal> задаётся список столбцов в выходной "
"таблице. Если предложение <literal>COLUMNS</literal> опускается, строки в "
"результирующем наборе содержат один столбец типа <literal>xml</literal> с "
"данными, которые отобрало <replaceable>выражение_строки</replaceable>. Если "
"<literal>COLUMNS</literal> присутствует, каждый его элемент описывает один "
"столбец. Формат этого предложения показан выше в примере синтаксиса. Имя "
"столбца и его тип должны задаваться обязательно: путь, значение по умолчанию "
"и признак допустимости NULL могут опускаться."

#. +> REL_10
#: func.xml:10609(para)
msgid ""
"A column marked <literal>FOR ORDINALITY</literal> will be populated with row "
"numbers matching the order in which the output rows appeared in the original "
"input XML document. At most one column may be marked <literal>FOR "
"ORDINALITY</literal>."
msgstr ""
"Столбец с признаком <literal>FOR ORDINALITY</literal> будет заполняться "
"номерами строк, соответствующими порядку, в котором строки находились в "
"исходном документе XML. Признак <literal>FOR ORDINALITY</literal> может быть "
"не больше чем у одного столбца."

#. +> REL_10
#: func.xml:10616(para)
msgid ""
"The <literal>column_expression</literal> for a column is an XPath expression "
"that is evaluated for each row, relative to the result of the "
"<replaceable>row_expression</replaceable>, to find the value of the column. "
"If no <literal>column_expression</literal> is given, then the column name is "
"used as an implicit path."
msgstr ""
"В указании <literal>выражение_столбца</literal> для столбца задаётся "
"выражение XPath, вычисляемое для каждой строки относительно результата "
"<replaceable>выражение_строки</replaceable> и выдающее значение столбца. "
"Если <literal>выражение_столбца</literal> отсутствует, в качестве неявного "
"пути используется имя столбца."

#. +> REL_10
#: func.xml:10624(para)
msgid ""
"If a column's XPath expression returns multiple elements, an error is "
"raised. If the expression matches an empty tag, the result is an empty "
"string (not <literal>NULL</literal>). Any <literal>xsi:nil</literal> "
"attributes are ignored."
msgstr ""
"Если выражение XPath для столбца выдаёт несколько элементов, происходит "
"ошибка. Если выражению соответствует пустой элемент, результатом будет "
"пустая строка (не <literal>NULL</literal>). Атрибуты <literal>xsi:nil</"
"literal> при поиске игнорируются."

#. +> REL_10
#: func.xml:10632(para)
msgid ""
"The text body of the XML matched by the <replaceable>column_expression</"
"replaceable> is used as the column value. Multiple <literal>text()</literal> "
"nodes within an element are concatenated in order. Any child elements, "
"processing instructions, and comments are ignored, but the text contents of "
"child elements are concatenated to the result. Note that the whitespace-only "
"<literal>text()</literal> node between two non-text elements is preserved, "
"and that leading whitespace on a <literal>text()</literal> node is not "
"flattened."
msgstr ""
"Значением столбца становится текстовое содержимое XML-узла, отобранного "
"<replaceable>выражением_столбца</replaceable>. Несколько узлов "
"<literal>text()</literal> внутри целевого элемента складываются вместе по "
"порядку. Все дочерние элементы, инструкции обработки и комментарии "
"игнорируются, но текстовое содержимое дочерних элементов добавляется к "
"результату. Заметьте, что исключительно пробельные узлы <literal>text()</"
"literal> между двумя не текстовыми элементами сохраняются, как не убираются "
"и ведущие пробелы в узле <literal>text()</literal>."

#. +> REL_10
#: func.xml:10643(para)
msgid ""
"If the path expression does not match for a given row but "
"<replaceable>default_expression</replaceable> is specified, the value "
"resulting from evaluating that expression is used. If no <literal>DEFAULT</"
"literal> clause is given for the column, the field will be set to "
"<literal>NULL</literal>. It is possible for a "
"<replaceable>default_expression</replaceable> to reference the value of "
"output columns that appear prior to it in the column list, so the default of "
"one column may be based on the value of another column."
msgstr ""
"Если выражение пути не находит элемент строки, но задано "
"<replaceable>выражение_по_умолчанию</replaceable>, значением поля становится "
"результат вычисления этого выражения. Если предложение <literal>DEFAULT</"
"literal> для этого столбца отсутствует, в это поле записывается "
"<literal>NULL</literal>. В <replaceable>выражении_по_умолчанию</replaceable> "
"можно обращаться к значениям выходных столбцов, описанных ранее в списке "
"столбцов, так что значение по умолчанию одного столбца можно получить из "
"значения другого."

#. +> REL_10
#: func.xml:10655(para)
msgid ""
"Columns may be marked <literal>NOT NULL</literal>. If the "
"<replaceable>column_expression</replaceable> for a <literal>NOT NULL</"
"literal> column does not match anything and there is no <literal>DEFAULT</"
"literal> or the <replaceable>default_expression</replaceable> also evaluates "
"to null, an error is reported."
msgstr ""
"Столбцы могут иметь признак <literal>NOT NULL</literal>. Если "
"<replaceable>выражение_столбца</replaceable> для столбца с признаком "
"<literal>NOT NULL</literal> не соответствует ничему и при этом отсутствует "
"указание <literal>DEFAULT</literal> или <replaceable>выражение_по_умолчанию</"
"replaceable> также выдаёт NULL, происходит ошибка."

#. +> REL_10
#: func.xml:10663(para)
msgid ""
"Unlike regular PostgreSQL functions, <replaceable>column_expression</"
"replaceable> and <replaceable>default_expression</replaceable> are not "
"evaluated to a simple value before calling the function. "
"<replaceable>column_expression</replaceable> is normally evaluated exactly "
"once per input row, and <replaceable>default_expression</replaceable> is "
"evaluated each time a default is needed for a field. If the expression "
"qualifies as stable or immutable the repeat evaluation may be skipped. "
"Effectively <function>xmltable</function> behaves more like a subquery than "
"a function call. This means that you can usefully use volatile functions "
"like <function>nextval</function> in <replaceable>default_expression</"
"replaceable>, and <replaceable>column_expression</replaceable> may depend on "
"other parts of the XML document."
msgstr ""
"В отличие от обычных функций PostgreSQL, <replaceable>выражение_столбца</"
"replaceable> и <replaceable>выражение_по_умолчанию</replaceable> не сводятся "
"к единственному простому значению перед вызовом функции. Так, "
"<replaceable>выражение_столбца</replaceable> обычно вычисляется ровно один "
"раз для каждой входной строки, а <replaceable>выражение_по_умолчанию</"
"replaceable> вычисляется каждый раз, когда для поля требуется значение по "
"умолчанию. Если выражение оказывается стабильным или постоянным, повторное "
"вычисление может не выполняться. По сути <function>xmltable</function> "
"действует больше как подзапрос, а не как вызов функции. Это значит, что вы "
"можете с пользой применять изменчивые функции, такие как <function>nextval</"
"function> в <replaceable>выражении_по_умолчанию</replaceable>, а "
"<replaceable>выражение_столбца</replaceable> может зависеть от других частей "
"XML-документа."

#. +> REL_10
#: func.xml:10680(para)
msgid ""
"Examples: <screen><![CDATA[\n"
"CREATE TABLE xmldata AS SELECT\n"
"xml $$\n"
"<ROWS>\n"
"  <ROW id=\"1\">\n"
"    <COUNTRY_ID>AU</COUNTRY_ID>\n"
"    <COUNTRY_NAME>Australia</COUNTRY_NAME>\n"
"  </ROW>\n"
"  <ROW id=\"5\">\n"
"    <COUNTRY_ID>JP</COUNTRY_ID>\n"
"    <COUNTRY_NAME>Japan</COUNTRY_NAME>\n"
"    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>\n"
"    <SIZE unit=\"sq_mi\">145935</SIZE>\n"
"  </ROW>\n"
"  <ROW id=\"6\">\n"
"    <COUNTRY_ID>SG</COUNTRY_ID>\n"
"    <COUNTRY_NAME>Singapore</COUNTRY_NAME>\n"
"    <SIZE unit=\"sq_km\">697</SIZE>\n"
"  </ROW>\n"
"</ROWS>\n"
"$$ AS data;\n"
"\n"
"SELECT xmltable.*\n"
"  FROM xmldata,\n"
"       XMLTABLE('//ROWS/ROW'\n"
"                PASSING data\n"
"                COLUMNS id int PATH '@id',\n"
"                        ordinality FOR ORDINALITY,\n"
"                        \"COUNTRY_NAME\" text,\n"
"                        country_id text PATH 'COUNTRY_ID',\n"
"                        size_sq_km float PATH 'SIZE[@unit = \"sq_km\"]',\n"
"                        size_other text PATH\n"
"                             'concat(SIZE[@unit!=\"sq_km\"], \" \", "
"SIZE[@unit!=\"sq_km\"]/@unit)',\n"
"                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not "
"specified') ;\n"
"\n"
" id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | "
"premier_name  \n"
"----+------------+--------------+------------+------------+--------------"
"+---------------\n"
"  1 |          1 | Australia    | AU         |            |              | "
"not specified\n"
"  5 |          2 | Japan        | JP         |            | 145935 sq_mi | "
"Shinzo Abe\n"
"  6 |          3 | Singapore    | SG         |        697 |              | "
"not specified\n"
"]]></screen> The following example shows concatenation of multiple text() "
"nodes, usage of the column name as XPath filter, and the treatment of "
"whitespace, XML comments and processing instructions: <screen><![CDATA[\n"
"CREATE TABLE xmlelements AS SELECT\n"
"xml $$\n"
"  <root>\n"
"   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </"
"element>\n"
"  </root>\n"
"$$ AS data;\n"
"\n"
"SELECT xmltable.*\n"
"  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);\n"
"       element        \n"
"----------------------\n"
"   Hello2a2   bbbCC  \n"
"]]></screen>"
msgstr ""
"Примеры: <screen><![CDATA[\n"
"CREATE TABLE xmldata AS SELECT\n"
"xml $$\n"
"<ROWS>\n"
"  <ROW id=\"1\">\n"
"    <COUNTRY_ID>AU</COUNTRY_ID>\n"
"    <COUNTRY_NAME>Australia</COUNTRY_NAME>\n"
"  </ROW>\n"
"  <ROW id=\"5\">\n"
"    <COUNTRY_ID>JP</COUNTRY_ID>\n"
"    <COUNTRY_NAME>Japan</COUNTRY_NAME>\n"
"    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>\n"
"    <SIZE unit=\"sq_mi\">145935</SIZE>\n"
"  </ROW>\n"
"  <ROW id=\"6\">\n"
"    <COUNTRY_ID>SG</COUNTRY_ID>\n"
"    <COUNTRY_NAME>Singapore</COUNTRY_NAME>\n"
"    <SIZE unit=\"sq_km\">697</SIZE>\n"
"  </ROW>\n"
"</ROWS>\n"
"$$ AS data;\n"
"\n"
"SELECT xmltable.*\n"
"  FROM xmldata,\n"
"       XMLTABLE('//ROWS/ROW'\n"
"                PASSING data\n"
"                COLUMNS id int PATH '@id',\n"
"                        ordinality FOR ORDINALITY,\n"
"                        \"COUNTRY_NAME\" text,\n"
"                        country_id text PATH 'COUNTRY_ID',\n"
"                        size_sq_km float PATH 'SIZE[@unit = \"sq_km\"]',\n"
"                        size_other text PATH\n"
"                             'concat(SIZE[@unit!=\"sq_km\"], \" \", "
"SIZE[@unit!=\"sq_km\"]/@unit)',\n"
"                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not "
"specified') ;\n"
"\n"
" id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | "
"premier_name  \n"
"----+------------+--------------+------------+------------+--------------"
"+---------------\n"
"  1 |          1 | Australia    | AU         |            |              | "
"not specified\n"
"  5 |          2 | Japan        | JP         |            | 145935 sq_mi | "
"Shinzo Abe\n"
"  6 |          3 | Singapore    | SG         |        697 |              | "
"not specified\n"
"]]></screen> Следующий пример иллюстрирует сложение нескольких узлов text(), "
"использование имени столбца в качестве фильтра XPath и обработку пробельных "
"символов, XML-комментариев и инструкций обработки: <screen><![CDATA[\n"
"CREATE TABLE xmlelements AS SELECT\n"
"xml $$\n"
"  <root>\n"
"   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </"
"element>\n"
"  </root>\n"
"$$ AS data;\n"
"\n"
"SELECT xmltable.*\n"
"  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);\n"
"       element        \n"
"----------------------\n"
"   Hello2a2   bbbCC  \n"
"]]></screen>"

#. +> REL_10
#: func.xml:10744(para)
msgid ""
"The following example illustrates how the <literal>XMLNAMESPACES</literal> "
"clause can be used to specify the default namespace, and a list of "
"additional namespaces used in the XML document as well as in the XPath "
"expressions: <screen><![CDATA[\n"
"WITH xmldata(data) AS (VALUES ('\n"
"<example xmlns=\"http://example.com/myns\" xmlns:B=\"http://example.com/b"
"\">\n"
" <item foo=\"1\" B:bar=\"2\"/>\n"
" <item foo=\"3\" B:bar=\"4\"/>\n"
" <item foo=\"4\" B:bar=\"5\"/>\n"
"</example>'::xml)\n"
")\n"
"SELECT xmltable.*\n"
"  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,\n"
"                              'http://example.com/b' AS \"B\"),\n"
"             '/x:example/x:item'\n"
"                PASSING (SELECT data FROM xmldata)\n"
"                COLUMNS foo int PATH '@foo',\n"
"                  bar int PATH '@B:bar');\n"
" foo | bar\n"
"-----+-----\n"
"   1 |   2\n"
"   3 |   4\n"
"   4 |   5\n"
"(3 rows)\n"
"]]></screen>"
msgstr ""
"Следующий пример показывает, как с помощью предложения "
"<literal>XMLNAMESPACES</literal> можно задать пространство имён по "
"умолчанию, а также дополнительные пространства имён, используемые в XML-"
"документе и в выражениях XPath: <screen><![CDATA[\n"
"WITH xmldata(data) AS (VALUES ('\n"
"<example xmlns=\"http://example.com/myns\" xmlns:B=\"http://example.com/b"
"\">\n"
" <item foo=\"1\" B:bar=\"2\"/>\n"
" <item foo=\"3\" B:bar=\"4\"/>\n"
" <item foo=\"4\" B:bar=\"5\"/>\n"
"</example>'::xml)\n"
")\n"
"SELECT xmltable.*\n"
"  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,\n"
"                              'http://example.com/b' AS \"B\"),\n"
"             '/x:example/x:item'\n"
"                PASSING (SELECT data FROM xmldata)\n"
"                COLUMNS foo int PATH '@foo',\n"
"                  bar int PATH '@B:bar');\n"
" foo | bar\n"
"-----+-----\n"
"   1 |   2\n"
"   3 |   4\n"
"   4 |   5\n"
"(3 rows)\n"
"]]></screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10777(title)
msgid "Mapping Tables to XML"
msgstr "Отображение таблиц в XML"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10779(indexterm)
msgid "<primary>XML export</primary>"
msgstr "<primary>экспорт в XML</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10783(para)
msgid ""
"The following functions map the contents of relational tables to XML values. "
"They can be thought of as XML export functionality: <synopsis>\n"
"table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns "
"text)\n"
"query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)\n"
"cursor_to_xml(cursor refcursor, count int, nulls boolean,\n"
"              tableforest boolean, targetns text)\n"
"</synopsis> The return type of each function is <type>xml</type>."
msgstr ""
"Следующие функции отображают содержимое реляционных таблиц в значения XML. "
"Их можно рассматривать как средства экспорта в XML: <synopsis>\n"
"table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns "
"text)\n"
"query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)\n"
"cursor_to_xml(cursor refcursor, count int, nulls boolean,\n"
"              tableforest boolean, targetns text)\n"
"</synopsis> Результат всех этих функций имеет тип <type>xml</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10795(para)
msgid ""
"<function>table_to_xml</function> maps the content of the named table, "
"passed as parameter <parameter>tbl</parameter>. The <type>regclass</type> "
"type accepts strings identifying tables using the usual notation, including "
"optional schema qualifications and double quotes. <function>query_to_xml</"
"function> executes the query whose text is passed as parameter "
"<parameter>query</parameter> and maps the result set. "
"<function>cursor_to_xml</function> fetches the indicated number of rows from "
"the cursor specified by the parameter <parameter>cursor</parameter>. This "
"variant is recommended if large tables have to be mapped, because the result "
"value is built up in memory by each function."
msgstr ""
"<function>table_to_xml</function> отображает в xml содержимое таблицы, имя "
"которой задаётся в параметре <parameter>tbl</parameter>. Тип <type>regclass</"
"type> принимает идентификаторы строк в обычной записи, которые могут "
"содержать указание схемы и кавычки. Функция <function>query_to_xml</"
"function> выполняет запрос, текст которого передаётся в параметре "
"<parameter>query</parameter>, и отображает в xml результирующий набор. "
"Последняя функция, <function>cursor_to_xml</function> выбирает указанное "
"число строк из курсора, переданного в параметре <parameter>cursor</"
"parameter>. Этот вариант рекомендуется использовать с большими таблицами, "
"так как все эти функции создают результирующий xml в памяти."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10810(para)
msgid ""
"If <parameter>tableforest</parameter> is false, then the resulting XML "
"document looks like this: <screen><![CDATA[\n"
"<tablename>\n"
"  <row>\n"
"    <columnname1>data</columnname1>\n"
"    <columnname2>data</columnname2>\n"
"  </row>\n"
"\n"
"  <row>\n"
"    ...\n"
"  </row>\n"
"\n"
"  ...\n"
"</tablename>\n"
"]]></screen> If <parameter>tableforest</parameter> is true, the result is an "
"XML content fragment that looks like this: <screen><![CDATA[\n"
"<tablename>\n"
"  <columnname1>data</columnname1>\n"
"  <columnname2>data</columnname2>\n"
"</tablename>\n"
"\n"
"<tablename>\n"
"  ...\n"
"</tablename>\n"
"\n"
"...\n"
"]]></screen> If no table name is available, that is, when mapping a query or "
"a cursor, the string <literal>table</literal> is used in the first format, "
"<literal>row</literal> in the second format."
msgstr ""
"Если параметр <parameter>tableforest</parameter> имеет значение false, "
"результирующий XML-документ выглядит так: <screen><![CDATA[\n"
"<имя_таблицы>\n"
"  <row>\n"
"    <имя_столбца1> данные </имя_столбца1>\n"
"    <имя_столбца2> данные </имя_столбца2>\n"
"  </row>\n"
"\n"
"  <row>\n"
"    ...\n"
"  </row>\n"
"\n"
"  ...\n"
"</имя_таблицы>\n"
"]]></screen> А если <parameter>tableforest</parameter> равен true, в "
"результате будет выведен следующий фрагмент XML: <screen><![CDATA[\n"
"<имя_таблицы>\n"
"  <имя_столбца1> данные </имя_столбца1>\n"
"  <имя_столбца2> данные </имя_столбца2>\n"
"</имя_таблицы>\n"
"\n"
"<имя_таблицы>\n"
"  ...\n"
"</имя_таблицы>\n"
"\n"
"...\n"
"]]></screen> Если имя таблицы неизвестно, например, при отображении "
"результатов запроса или курсора, вместо него в первом случае вставляется "
"<literal>table</literal>, а во втором — <literal>row</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10848(para)
msgid ""
"The choice between these formats is up to the user. The first format is a "
"proper XML document, which will be important in many applications. The "
"second format tends to be more useful in the <function>cursor_to_xml</"
"function> function if the result values are to be reassembled into one "
"document later on. The functions for producing XML content discussed above, "
"in particular <function>xmlelement</function>, can be used to alter the "
"results to taste."
msgstr ""
"Выбор между этими форматами остаётся за пользователем. Первый вариант "
"позволяет создать готовый XML-документ, что может быть полезно для многих "
"приложений, а второй удобно применять с функцией <function>cursor_to_xml</"
"function>, если её результаты будут собираться в документ позже. Полученный "
"результат можно изменить по вкусу с помощью рассмотренных выше функций "
"создания XML-содержимого, в частности <function>xmlelement</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10859(para)
msgid ""
"The data values are mapped in the same way as described for the function "
"<function>xmlelement</function> above."
msgstr ""
"Значения данных эти функции отображают так же, как и ранее описанная функция "
"<function>xmlelement</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10864(para)
msgid ""
"The parameter <parameter>nulls</parameter> determines whether null values "
"should be included in the output. If true, null values in columns are "
"represented as: <screen><![CDATA[\n"
"<columnname xsi:nil=\"true\"/>\n"
"]]></screen> where <literal>xsi</literal> is the XML namespace prefix for "
"XML Schema Instance. An appropriate namespace declaration will be added to "
"the result value. If false, columns containing null values are simply "
"omitted from the output."
msgstr ""
"Параметр <parameter>nulls</parameter> определяет, нужно ли включать в "
"результат значения NULL. Если он установлен, значения NULL в столбцах "
"представляются так: <screen><![CDATA[\n"
"<имя_столбца xsi:nil=\"true\"/>\n"
"]]></screen> Здесь <literal>xsi</literal> &mdash; префикс пространства имён "
"XML Schema Instance. При этом в результирующий XML будет добавлено "
"соответствующее объявление пространства имён. Если же данный параметр равен "
"false, столбцы со значениями NULL просто не будут выводиться."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10877(para)
msgid ""
"The parameter <parameter>targetns</parameter> specifies the desired XML "
"namespace of the result. If no particular namespace is wanted, an empty "
"string should be passed."
msgstr ""
"Параметр <parameter>targetns</parameter> определяет целевое пространство "
"имён для результирующего XML. Если пространство имён не нужно, значением "
"этого параметра должна быть пустая строка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10883(para)
msgid ""
"The following functions return XML Schema documents describing the mappings "
"performed by the corresponding functions above: <synopsis>\n"
"table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, "
"targetns text)\n"
"query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns "
"text)\n"
"cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, "
"targetns text)\n"
"</synopsis> It is essential that the same parameters are passed in order to "
"obtain matching XML data mappings and XML Schema documents."
msgstr ""
"Следующие функции выдают документы XML Schema, которые содержат схемы "
"отображений, выполняемых соответствующими ранее рассмотренными функциями: "
"<synopsis>\n"
"table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"query_to_xmlschema(query text, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"</synopsis> Чтобы результаты отображения данных в XML соответствовали XML-"
"схемам, важно, чтобы паре функций передавались одинаковые параметры."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10895(para)
msgid ""
"The following functions produce XML data mappings and the corresponding XML "
"Schema in one document (or forest), linked together. They can be useful "
"where self-contained and self-describing results are wanted: <synopsis>\n"
"table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, "
"targetns text)\n"
"query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, "
"targetns text)\n"
"</synopsis>"
msgstr ""
"Следующие функции выдают отображение данных в XML и соответствующую XML-"
"схему в одном документе (или фрагменте), объединяя их вместе. Это может быть "
"полезно там, где желательно получить самодостаточные результаты с описанием: "
"<synopsis>\n"
"table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest "
"boolean,\n"
"  targetns text)\n"
"query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10906(para)
msgid ""
"In addition, the following functions are available to produce analogous "
"mappings of entire schemas or the entire current database: <synopsis>\n"
"schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns "
"text)\n"
"schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, "
"targetns text)\n"
"schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, "
"targetns text)\n"
"\n"
"database_to_xml(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns "
"text)\n"
"</synopsis> Note that these potentially produce a lot of data, which needs "
"to be built up in memory. When requesting content mappings of large schemas "
"or databases, it might be worthwhile to consider mapping the tables "
"separately instead, possibly even through a cursor."
msgstr ""
"В дополнение к ним есть следующие функции, способные выдать аналогичные "
"представления для целых схем в базе данных или даже всей текущей базы "
"данных: <synopsis>\n"
"schema_to_xml(schema name, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"schema_to_xmlschema(schema name, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest "
"boolean,\n"
"  targetns text)\n"
"\n"
"database_to_xml(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xml_and_xmlschema(nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"</synopsis> Заметьте, что объём таких данных может быть очень большим, а XML "
"будет создаваться в памяти. Поэтому, вместо того, чтобы пытаться отобразить "
"в XML сразу всё содержимое больших схем или баз данных, лучше делать это по "
"таблицам, возможно даже используя курсор."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10926(para)
msgid ""
"The result of a schema content mapping looks like this: <screen><![CDATA[\n"
"<schemaname>\n"
"\n"
"table1-mapping\n"
"\n"
"table2-mapping\n"
"\n"
"...\n"
"\n"
"</schemaname>]]></screen> where the format of a table mapping depends on the "
"<parameter>tableforest</parameter> parameter as explained above."
msgstr ""
"Результат отображения содержимого схемы будет выглядеть так: <screen><!"
"[CDATA[\n"
"<имя_схемы>\n"
"\n"
"отображение-таблицы1\n"
"\n"
"отображение-таблицы2\n"
"\n"
"...\n"
"\n"
"</имя_схемы>]]></screen> Формат отображения таблицы определяется параметром "
"<parameter>tableforest</parameter>, описанным выше."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10944(para)
msgid ""
"The result of a database content mapping looks like this: <screen><![CDATA[\n"
"<dbname>\n"
"\n"
"<schema1name>\n"
"  ...\n"
"</schema1name>\n"
"\n"
"<schema2name>\n"
"  ...\n"
"</schema2name>\n"
"\n"
"...\n"
"\n"
"</dbname>]]></screen> where the schema mapping is as above."
msgstr ""
"Результат отображения содержимого базы данных будет таким: <screen><!"
"[CDATA[\n"
"<имя_схемы>\n"
"\n"
"<имя_схемы1>\n"
"  ...\n"
"</имя_схемы1>\n"
"\n"
"<имя_схемы2>\n"
"  ...\n"
"</имя_схемы2>\n"
"\n"
"...\n"
"\n"
"</имя_схемы>]]></screen> Здесь отображение схемы имеет вид, показанный выше."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10965(para)
msgid ""
"As an example of using the output produced by these functions, <xref linkend="
"\"xslt-xml-html\"/> shows an XSLT stylesheet that converts the output of "
"<function>table_to_xml_and_xmlschema</function> to an HTML document "
"containing a tabular rendition of the table data. In a similar manner, the "
"results from these functions can be converted into other XML-based formats."
msgstr ""
"В качестве примера, иллюстрирующего использование результата этих функций, "
"на <xref remap=\"6\" linkend=\"xslt-xml-html\"/> показано XSLT-"
"преобразование, которое переводит результат функции "
"<function>table_to_xml_and_xmlschema</function> в HTML-документ, содержащий "
"таблицу с данными. Подобным образом результаты этих функций можно "
"преобразовать и в другие форматы на базе XML."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:10976(title)
msgid "XSLT Stylesheet for Converting SQL/XML Output to HTML"
msgstr "XSLT-преобразование, переводящее результат SQL/XML в формат HTML"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11028(title)
msgid "JSON Functions and Operators"
msgstr "Функции и операторы JSON"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11030(indexterm)
msgid "<primary>JSON</primary> <secondary>functions and operators</secondary>"
msgstr "<primary>JSON</primary> <secondary>функции и операторы</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11035(para)
msgid ""
"<xref linkend=\"functions-json-op-table\"/> shows the operators that are "
"available for use with the two JSON data types (see <xref linkend=\"datatype-"
"json\"/>)."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-op-table\"/> перечислены "
"функции, позволяющие создавать данные в формате JSON (см. <xref remap=\"4\" "
"linkend=\"datatype-json\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11042(title)
msgid "<type>json</type> and <type>jsonb</type> Operators"
msgstr "Операторы для типов <type>json</type> и <type>jsonb</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11047(entry) func.xml:11140(entry)
msgid "Right Operand Type"
msgstr "Тип правого операнда"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11055(literal) func.xml:11063(literal)
msgid "-&gt;"
msgstr "-&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11057(entry)
msgid ""
"Get JSON array element (indexed from zero, negative integers count from the "
"end)"
msgstr ""
"Выдаёт элемент массива JSON (по номеру от 0, отрицательные числа задают "
"позиции с конца)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11059(literal)
msgid "'[{\"a\":\"foo\"},{\"b\":\"bar\"},{\"c\":\"baz\"}]'::json-&gt;2"
msgstr "'[{\"a\":\"foo\"},{\"b\":\"bar\"},{\"c\":\"baz\"}]'::json-&gt;2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11060(literal)
msgid "{\"c\":\"baz\"}"
msgstr "{\"c\":\"baz\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11065(entry)
msgid "Get JSON object field by key"
msgstr "Выдаёт поле объекта JSON по ключу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11066(literal)
msgid "'{\"a\": {\"b\":\"foo\"}}'::json-&gt;'a'"
msgstr "'{\"a\": {\"b\":\"foo\"}}'::json-&gt;'a'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11067(literal)
msgid "{\"b\":\"foo\"}"
msgstr "{\"b\":\"foo\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11070(literal) func.xml:11077(literal)
msgid "-&gt;&gt;"
msgstr "-&gt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11072(entry)
msgid "Get JSON array element as <type>text</type>"
msgstr "Выдаёт элемент массива JSON в типе <type>text</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11073(literal)
msgid "'[1,2,3]'::json-&gt;&gt;2"
msgstr "'[1,2,3]'::json-&gt;&gt;2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11079(entry)
msgid "Get JSON object field as <type>text</type>"
msgstr "Выдаёт поле объекта JSON в типе <type>text</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11080(literal)
msgid "'{\"a\":1,\"b\":2}'::json-&gt;&gt;'b'"
msgstr "'{\"a\":1,\"b\":2}'::json-&gt;&gt;'b'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11084(literal)
msgid "#&gt;"
msgstr "#&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11086(entry)
msgid "Get JSON object at specified path"
msgstr "Выдаёт объект JSON по заданному пути"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11087(literal)
msgid "'{\"a\": {\"b\":{\"c\": \"foo\"}}}'::json#&gt;'{a,b}'"
msgstr "'{\"a\": {\"b\":{\"c\": \"foo\"}}}'::json#&gt;'{a,b}'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11088(literal)
msgid "{\"c\": \"foo\"}"
msgstr "{\"c\": \"foo\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11091(literal)
msgid "#&gt;&gt;"
msgstr "#&gt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11093(entry)
msgid "Get JSON object at specified path as <type>text</type>"
msgstr "Выдаёт объект JSON по заданному пути в типе <type>text</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11094(literal)
msgid "'{\"a\":[1,2,3],\"b\":[4,5,6]}'::json#&gt;&gt;'{a,2}'"
msgstr "'{\"a\":[1,2,3],\"b\":[4,5,6]}'::json#&gt;&gt;'{a,2}'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11102(para)
msgid ""
"There are parallel variants of these operators for both the <type>json</"
"type> and <type>jsonb</type> types. The field/element/path extraction "
"operators return the same type as their left-hand input (either <type>json</"
"type> or <type>jsonb</type>), except for those specified as returning "
"<type>text</type>, which coerce the value to text. The field/element/path "
"extraction operators return NULL, rather than failing, if the JSON input "
"does not have the right structure to match the request; for example if no "
"such element exists. The field/element/path extraction operators that accept "
"integer JSON array subscripts all support negative subscripting from the end "
"of arrays."
msgstr ""
"Эти операторы существуют в двух вариациях для типов <type>json</type> и "
"<type>jsonb</type>. Операторы извлечения поля/элемента/пути возвращают тот "
"же тип, что у операнда слева (<type>json</type> или <type>jsonb</type>), за "
"исключением тех, что возвращают тип <type>text</type> (они возвращают "
"значение как текстовое). Если входные данные JSON не содержат структуры, "
"удовлетворяющей запросу, например в них нет искомого элемента, то операторы "
"извлечения поля/элемента/пути не выдают ошибку, а возвращают NULL. Все "
"операторы извлечения поля/элемента/пути, принимающие целочисленные позиции в "
"массивах JSON, поддерживают и отсчёт от конца массива по отрицательной "
"позиции."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11117(para)
msgid ""
"The standard comparison operators shown in <xref linkend=\"functions-"
"comparison-op-table\"/> are available for <type>jsonb</type>, but not for "
"<type>json</type>. They follow the ordering rules for B-tree operations "
"outlined at <xref linkend=\"json-indexing\"/>."
msgstr ""
"Стандартные операторы сравнения, приведённые в <xref remap=\"6\" linkend="
"\"functions-comparison-op-table\"/>, есть для типа <type>jsonb</type>, но не "
"для <type>json</type>. Они следуют правилам сортировки для операций B-"
"дерева, описанным в <xref remap=\"6\" linkend=\"json-indexing\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11124(para)
msgid ""
"Some further operators also exist only for <type>jsonb</type>, as shown in "
"<xref linkend=\"functions-jsonb-op-table\"/>. Many of these operators can be "
"indexed by <type>jsonb</type> operator classes. For a full description of "
"<type>jsonb</type> containment and existence semantics, see <xref linkend="
"\"json-containment\"/>. <xref linkend=\"json-indexing\"/> describes how "
"these operators can be used to effectively index <type>jsonb</type> data."
msgstr ""
"Некоторые из следующих операторов существуют только для <type>jsonb</type>, "
"как показано в <xref remap=\"6\" linkend=\"functions-jsonb-op-table\"/>. "
"Многие из этих операторов могут быть проиндексированы с помощью классов "
"операторов <type>jsonb</type>. Полное описание проверок на вхождение и "
"существование для <type>jsonb</type> приведено в <xref remap=\"6\" linkend="
"\"json-containment\"/>. Как эти операторы могут использоваться для "
"эффективного индексирования данных <type>jsonb</type>, описано в <xref remap="
"\"6\" linkend=\"json-indexing\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11135(title)
msgid "Additional <type>jsonb</type> Operators"
msgstr "Дополнительные операторы <type>jsonb</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11148(type) func.xml:11155(type) func.xml:11183(type)
#: func.xml:11559(type) func.xml:11737(type) func.xml:11749(type)
#: func.xml:11775(type) func.xml:13456(type) func.xml:13490(type)
msgid "jsonb"
msgstr "jsonb"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11149(entry)
msgid ""
"Does the left JSON value contain the right JSON path/value entries at the "
"top level?"
msgstr ""
"Левое значение JSON содержит на верхнем уровне путь/значение JSON справа?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11151(literal)
msgid "'{\"a\":1, \"b\":2}'::jsonb @&gt; '{\"b\":2}'::jsonb"
msgstr "'{\"a\":1, \"b\":2}'::jsonb @&gt; '{\"b\":2}'::jsonb"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11156(entry)
msgid ""
"Are the left JSON path/value entries contained at the top level within the "
"right JSON value?"
msgstr ""
"Путь/значение JSON слева содержится на верхнем уровне в правом значении JSON?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11158(literal)
msgid "'{\"b\":2}'::jsonb &lt;@ '{\"a\":1, \"b\":2}'::jsonb"
msgstr "'{\"b\":2}'::jsonb &lt;@ '{\"a\":1, \"b\":2}'::jsonb"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11163(entry)
msgid ""
"Does the <emphasis>string</emphasis> exist as a top-level key within the "
"JSON value?"
msgstr ""
"Присутствует ли <emphasis>строка</emphasis> в качестве ключа верхнего уровня "
"в значении JSON?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11165(literal)
msgid "'{\"a\":1, \"b\":2}'::jsonb ? 'b'"
msgstr "'{\"a\":1, \"b\":2}'::jsonb ? 'b'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11170(entry)
msgid ""
"Do any of these array <emphasis>strings</emphasis> exist as top-level keys?"
msgstr ""
"Какие-либо <emphasis>строки</emphasis> массива присутствуют в качестве "
"ключей верхнего уровня?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11172(literal)
msgid "'{\"a\":1, \"b\":2, \"c\":3}'::jsonb ?| array['b', 'c']"
msgstr "'{\"a\":1, \"b\":2, \"c\":3}'::jsonb ?| array['b', 'c']"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11175(literal)
msgid "?&amp;"
msgstr "?&amp;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11177(entry)
msgid ""
"Do all of these array <emphasis>strings</emphasis> exist as top-level keys?"
msgstr ""
"Все <emphasis>строки</emphasis> массива присутствуют в качестве ключей "
"верхнего уровня?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11179(literal)
msgid "'[\"a\", \"b\"]'::jsonb ?&amp; array['a', 'b']"
msgstr "'[\"a\", \"b\"]'::jsonb ?&amp; array['a', 'b']"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11184(entry)
msgid ""
"Concatenate two <type>jsonb</type> values into a new <type>jsonb</type> value"
msgstr ""
"Соединяет два значения <type>jsonb</type> в новое значение <type>jsonb</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11185(literal)
msgid "'[\"a\", \"b\"]'::jsonb || '[\"c\", \"d\"]'::jsonb"
msgstr "'[\"a\", \"b\"]'::jsonb || '[\"c\", \"d\"]'::jsonb"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11190(entry)
msgid ""
"Delete key/value pair or <emphasis>string</emphasis> element from left "
"operand. Key/value pairs are matched based on their key value."
msgstr ""
"Удаляет пару ключ/значение или элемент-<emphasis>строку</emphasis> из левого "
"операнда. Пары ключ/значение выбираются по значению ключа."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11193(literal)
msgid "'{\"a\": \"b\"}'::jsonb - 'a'"
msgstr "'{\"a\": \"b\"}'::jsonb - 'a'"

#. +> REL_10
#: func.xml:11198(entry)
msgid ""
"Delete multiple key/value pairs or <emphasis>string</emphasis> elements from "
"left operand. Key/value pairs are matched based on their key value."
msgstr ""
"Удаляет множество пар ключ/значение или элементы-<emphasis>строки</emphasis> "
"из левого операнда. Пары ключ/значение выбираются по значению ключа."

#. +> REL_10
#: func.xml:11201(literal)
msgid "'{\"a\": \"b\", \"c\": \"d\"}'::jsonb - '{a,c}'::text[]"
msgstr "'{\"a\": \"b\", \"c\": \"d\"}'::jsonb - '{a,c}'::text[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11206(entry)
msgid ""
"Delete the array element with specified index (Negative integers count from "
"the end). Throws an error if top level container is not an array."
msgstr ""
"Удаляет из массива элемент в заданной позиции (отрицательные номера позиций "
"отсчитываются от конца). Выдаёт ошибку, если контейнер верхнего уровня — не "
"массив."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11209(literal)
msgid "'[\"a\", \"b\"]'::jsonb - 1"
msgstr "'[\"a\", \"b\"]'::jsonb - 1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11212(literal)
msgid "#-"
msgstr "#-"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11214(entry)
msgid ""
"Delete the field or element with specified path (for JSON arrays, negative "
"integers count from the end)"
msgstr ""
"Удаляет поле или элемент с заданным путём (для массивов JSON отрицательные "
"номера позиций отсчитываются от конца)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11216(literal)
msgid "'[\"a\", {\"b\":1}]'::jsonb #- '{1,b}'"
msgstr "'[\"a\", {\"b\":1}]'::jsonb #- '{1,b}'"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11223(para)
msgid ""
"The <literal>||</literal> operator concatenates the elements at the top "
"level of each of its operands. It does not operate recursively. For example, "
"if both operands are objects with a common key field name, the value of the "
"field in the result will just be the value from the right hand operand."
msgstr ""
"Оператор <literal>||</literal> соединяет элементы верхнего уровня обоих "
"операндов. Вложенность при этом не учитывается. Например, если оба операнда "
"содержат поле с одноимённым ключом, значением поля в результате будет "
"значение, взятое из правого операнда."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11231(para)
msgid ""
"<xref linkend=\"functions-json-creation-table\"/> shows the functions that "
"are available for creating <type>json</type> and <type>jsonb</type> values. "
"(There are no equivalent functions for <type>jsonb</type>, of the "
"<literal>row_to_json</literal> and <literal>array_to_json</literal> "
"functions. However, the <literal>to_jsonb</literal> function supplies much "
"the same functionality as these functions would.)"
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-creation-table\"/> показаны "
"функции, позволяющие создавать значения типов <type>json</type> и "
"<type>jsonb</type>. (Для типа <type>jsonb</type> нет аналогов функций "
"<literal>row_to_json</literal> и <literal>array_to_json</literal>, но "
"практически тот же результат можно получить с помощью <literal>to_jsonb</"
"literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11239(indexterm)
msgid "<primary>to_json</primary>"
msgstr "<primary>to_json</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11242(indexterm)
msgid "<primary>array_to_json</primary>"
msgstr "<primary>array_to_json</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11245(indexterm)
msgid "<primary>row_to_json</primary>"
msgstr "<primary>row_to_json</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11248(indexterm)
msgid "<primary>json_build_array</primary>"
msgstr "<primary>json_build_array</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11251(indexterm)
msgid "<primary>json_build_object</primary>"
msgstr "<primary>json_build_object</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11254(indexterm)
msgid "<primary>json_object</primary>"
msgstr "<primary>json_object</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11257(indexterm)
msgid "<primary>to_jsonb</primary>"
msgstr "<primary>to_jsonb</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11260(indexterm)
msgid "<primary>jsonb_build_array</primary>"
msgstr "<primary>jsonb_build_array</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11263(indexterm)
msgid "<primary>jsonb_build_object</primary>"
msgstr "<primary>jsonb_build_object</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11266(indexterm)
msgid "<primary>jsonb_object</primary>"
msgstr "<primary>jsonb_object</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11271(title)
msgid "JSON Creation Functions"
msgstr "Функции для создания JSON"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11283(literal)
msgid "to_json(anyelement)"
msgstr "to_json(anyelement)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11284(literal)
msgid "to_jsonb(anyelement)"
msgstr "to_jsonb(anyelement)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11286(entry)
msgid ""
"Returns the value as <type>json</type> or <type>jsonb</type>. Arrays and "
"composites are converted (recursively) to arrays and objects; otherwise, if "
"there is a cast from the type to <type>json</type>, the cast function will "
"be used to perform the conversion; otherwise, a scalar value is produced. "
"For any scalar type other than a number, a Boolean, or a null value, the "
"text representation will be used, in such a fashion that it is a valid "
"<type>json</type> or <type>jsonb</type> value."
msgstr ""
"Возвращает значение в виде <type>json</type> или <type>jsonb</type>. Массивы "
"и составные структуры преобразуются (рекурсивно) в массивы и объекты; для "
"других типов, для которых определено приведение к <type>json</type>, "
"применяется эта функция приведения, а для всех остальных выдаётся скалярное "
"значение. Значения всех скалярных типов, кроме числового, логического и "
"NULL, представляются в текстовом виде, в стиле, допустимом для значений "
"<type>json</type> или <type>jsonb</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11296(literal)
msgid "to_json('Fred said \"Hi.\"'::text)"
msgstr "to_json('Fred said \"Hi.\"'::text)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11297(literal)
msgid "\"Fred said \\\"Hi.\\\"\""
msgstr "\"Fred said \\\"Hi.\\\"\""

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11301(literal)
msgid "array_to_json(anyarray [, pretty_bool])"
msgstr "array_to_json(anyarray [, pretty_bool])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11303(entry)
msgid ""
"Returns the array as a JSON array. A PostgreSQL multidimensional array "
"becomes a JSON array of arrays. Line feeds will be added between dimension-1 "
"elements if <parameter>pretty_bool</parameter> is true."
msgstr ""
"Возвращает массив в виде массива JSON. Многомерный массив PostgreSQL "
"становится массивом массивов JSON. Если параметр <parameter>pretty_bool</"
"parameter> равен true, между элементами 1-ой размерности вставляются разрывы "
"строк."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11308(literal)
msgid "array_to_json('{{1,5},{99,100}}'::int[])"
msgstr "array_to_json('{{1,5},{99,100}}'::int[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11309(literal)
msgid "[[1,5],[99,100]]"
msgstr "[[1,5],[99,100]]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11313(literal)
msgid "row_to_json(record [, pretty_bool])"
msgstr "row_to_json(record [, pretty_bool])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11315(entry)
msgid ""
"Returns the row as a JSON object. Line feeds will be added between level-1 "
"elements if <parameter>pretty_bool</parameter> is true."
msgstr ""
"Возвращает кортеж в виде объекта JSON. Если параметр <parameter>pretty_bool</"
"parameter> равен true, между элементами 1-ой размерности вставляются разрывы "
"строк."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11319(literal)
msgid "row_to_json(row(1,'foo'))"
msgstr "row_to_json(row(1,'foo'))"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11320(literal)
msgid "{\"f1\":1,\"f2\":\"foo\"}"
msgstr "{\"f1\":1,\"f2\":\"foo\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11323(literal)
msgid "json_build_array(VARIADIC \"any\")"
msgstr "json_build_array(VARIADIC \"any\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11324(literal)
msgid "jsonb_build_array(VARIADIC \"any\")"
msgstr "jsonb_build_array(VARIADIC \"any\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11326(entry)
msgid ""
"Builds a possibly-heterogeneously-typed JSON array out of a variadic "
"argument list."
msgstr ""
"Формирует массив JSON (возможно, разнородный) из переменного списка "
"аргументов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11330(literal)
msgid "json_build_array(1,2,'3',4,5)"
msgstr "json_build_array(1,2,'3',4,5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11331(literal)
msgid "[1, 2, \"3\", 4, 5]"
msgstr "[1, 2, \"3\", 4, 5]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11334(literal)
msgid "json_build_object(VARIADIC \"any\")"
msgstr "json_build_object(VARIADIC \"any\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11335(literal)
msgid "jsonb_build_object(VARIADIC \"any\")"
msgstr "jsonb_build_object(VARIADIC \"any\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11337(entry)
msgid ""
"Builds a JSON object out of a variadic argument list. By convention, the "
"argument list consists of alternating keys and values."
msgstr ""
"Формирует объект JSON из переменного списка аргументов. По соглашению в этом "
"списке перечисляются по очереди ключи и значения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11342(literal)
msgid "json_build_object('foo',1,'bar',2)"
msgstr "json_build_object('foo',1,'bar',2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11343(literal)
msgid "{\"foo\": 1, \"bar\": 2}"
msgstr "{\"foo\": 1, \"bar\": 2}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11346(literal)
msgid "json_object(text[])"
msgstr "json_object(text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11347(literal)
msgid "jsonb_object(text[])"
msgstr "jsonb_object(text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11349(entry)
msgid ""
"Builds a JSON object out of a text array. The array must have either exactly "
"one dimension with an even number of members, in which case they are taken "
"as alternating key/value pairs, or two dimensions such that each inner array "
"has exactly two elements, which are taken as a key/value pair."
msgstr ""
"Формирует объект JSON из текстового массива. Этот массив должен иметь либо "
"одну размерность с чётным числом элементов (в этом случае они воспринимаются "
"как чередующиеся ключи/значения), либо две размерности и при этом каждый "
"внутренний массив содержит ровно два элемента, которые воспринимаются как "
"пара ключ/значение."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11356(literal)
msgid "json_object('{a, 1, b, \"def\", c, 3.5}')"
msgstr "json_object('{a, 1, b, \"def\", c, 3.5}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11357(literal)
msgid "json_object('{{a, 1},{b, \"def\"},{c, 3.5}}')"
msgstr "json_object('{{a, 1},{b, \"def\"},{c, 3.5}}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11358(literal)
msgid "{\"a\": \"1\", \"b\": \"def\", \"c\": \"3.5\"}"
msgstr "{\"a\": \"1\", \"b\": \"def\", \"c\": \"3.5\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11361(literal)
msgid "json_object(keys text[], values text[])"
msgstr "json_object(keys text[], values text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11362(literal)
msgid "jsonb_object(keys text[], values text[])"
msgstr "jsonb_object(keys text[], values text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11364(entry)
msgid ""
"This form of <function>json_object</function> takes keys and values pairwise "
"from two separate arrays. In all other respects it is identical to the one-"
"argument form."
msgstr ""
"Эта форма <function>json_object</function> принимает ключи и значения по "
"парам из двух отдельных массивов. Во всех остальных отношениях она не "
"отличается от формы с одним аргументом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11368(literal)
msgid "json_object('{a, b}', '{1,2}')"
msgstr "json_object('{a, b}', '{1,2}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11369(literal)
msgid "{\"a\": \"1\", \"b\": \"2\"}"
msgstr "{\"a\": \"1\", \"b\": \"2\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11376(para)
msgid ""
"<function>array_to_json</function> and <function>row_to_json</function> have "
"the same behavior as <function>to_json</function> except for offering a "
"pretty-printing option. The behavior described for <function>to_json</"
"function> likewise applies to each individual value converted by the other "
"JSON creation functions."
msgstr ""
"Функции <function>array_to_json</function> и <function>row_to_json</"
"function> подобны <function>to_json</function>, но предлагают возможность "
"улучшенного вывода. Действие <function>to_json</function>, описанное выше, "
"распространяется на каждое отдельное значение, преобразуемое этими функциями."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11385(para)
msgid ""
"The <xref linkend=\"hstore\"/> extension has a cast from <type>hstore</type> "
"to <type>json</type>, so that <type>hstore</type> values converted via the "
"JSON creation functions will be represented as JSON objects, not as "
"primitive string values."
msgstr ""
"В расширении <xref linkend=\"hstore\"/> определено преобразование из "
"<type>hstore</type> в <type>json</type>, так что значения <type>hstore</"
"type>, преобразуемые функциями создания JSON, будут представлены в виде "
"объектов JSON, а не как примитивные строковые значения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11393(para)
msgid ""
"<xref linkend=\"functions-json-processing-table\"/> shows the functions that "
"are available for processing <type>json</type> and <type>jsonb</type> values."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-processing-table\"/> показаны "
"функции, предназначенные для работы со значениями <type>json</type> и "
"<type>jsonb</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11398(indexterm)
msgid "<primary>json_array_length</primary>"
msgstr "<primary>json_array_length</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11401(indexterm)
msgid "<primary>jsonb_array_length</primary>"
msgstr "<primary>jsonb_array_length</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11404(indexterm)
msgid "<primary>json_each</primary>"
msgstr "<primary>json_each</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11407(indexterm)
msgid "<primary>jsonb_each</primary>"
msgstr "<primary>jsonb_each</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11410(indexterm)
msgid "<primary>json_each_text</primary>"
msgstr "<primary>json_each_text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11413(indexterm)
msgid "<primary>jsonb_each_text</primary>"
msgstr "<primary>jsonb_each_text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11416(indexterm)
msgid "<primary>json_extract_path</primary>"
msgstr "<primary>json_extract_path</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11419(indexterm)
msgid "<primary>jsonb_extract_path</primary>"
msgstr "<primary>jsonb_extract_path</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11422(indexterm)
msgid "<primary>json_extract_path_text</primary>"
msgstr "<primary>json_extract_path_text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11425(indexterm)
msgid "<primary>jsonb_extract_path_text</primary>"
msgstr "<primary>jsonb_extract_path_text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11428(indexterm)
msgid "<primary>json_object_keys</primary>"
msgstr "<primary>json_object_keys</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11431(indexterm)
msgid "<primary>jsonb_object_keys</primary>"
msgstr "<primary>jsonb_object_keys</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11434(indexterm)
msgid "<primary>json_populate_record</primary>"
msgstr "<primary>json_populate_record</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11437(indexterm)
msgid "<primary>jsonb_populate_record</primary>"
msgstr "<primary>jsonb_populate_record</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11440(indexterm)
msgid "<primary>json_populate_recordset</primary>"
msgstr "<primary>json_populate_recordset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11443(indexterm)
msgid "<primary>jsonb_populate_recordset</primary>"
msgstr "<primary>jsonb_populate_recordset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11446(indexterm)
msgid "<primary>json_array_elements</primary>"
msgstr "<primary>json_array_elements</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11449(indexterm)
msgid "<primary>jsonb_array_elements</primary>"
msgstr "<primary>jsonb_array_elements</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11452(indexterm)
msgid "<primary>json_array_elements_text</primary>"
msgstr "<primary>json_array_elements_text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11455(indexterm)
msgid "<primary>jsonb_array_elements_text</primary>"
msgstr "<primary>jsonb_array_elements_text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11458(indexterm)
msgid "<primary>json_typeof</primary>"
msgstr "<primary>json_typeof</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11461(indexterm)
msgid "<primary>jsonb_typeof</primary>"
msgstr "<primary>jsonb_typeof</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11464(indexterm)
msgid "<primary>json_to_record</primary>"
msgstr "<primary>json_to_record</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11467(indexterm)
msgid "<primary>jsonb_to_record</primary>"
msgstr "<primary>jsonb_to_record</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11470(indexterm)
msgid "<primary>json_to_recordset</primary>"
msgstr "<primary>json_to_recordset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11473(indexterm)
msgid "<primary>jsonb_to_recordset</primary>"
msgstr "<primary>jsonb_to_recordset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11476(indexterm)
msgid "<primary>json_strip_nulls</primary>"
msgstr "<primary>json_strip_nulls</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11479(indexterm)
msgid "<primary>jsonb_strip_nulls</primary>"
msgstr "<primary>jsonb_strip_nulls</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11482(indexterm)
msgid "<primary>jsonb_set</primary>"
msgstr "<primary>jsonb_set</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11485(indexterm)
msgid "<primary>jsonb_insert</primary>"
msgstr "<primary>jsonb_insert</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11488(indexterm)
msgid "<primary>jsonb_pretty</primary>"
msgstr "<primary>jsonb_pretty</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11493(title)
msgid "JSON Processing Functions"
msgstr "Функции для обработки JSON"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11506(literal)
msgid "json_array_length(json)"
msgstr "json_array_length(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11507(literal)
msgid "jsonb_array_length(jsonb)"
msgstr "jsonb_array_length(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11510(entry)
msgid "Returns the number of elements in the outermost JSON array."
msgstr "Возвращает число элементов во внешнем массиве JSON."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11513(literal)
msgid "json_array_length('[1,2,3,{\"f1\":1,\"f2\":[5,6]},4]')"
msgstr "json_array_length('[1,2,3,{\"f1\":1,\"f2\":[5,6]},4]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11517(literal)
msgid "json_each(json)"
msgstr "json_each(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11518(literal)
msgid "jsonb_each(jsonb)"
msgstr "jsonb_each(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11520(literal)
msgid "setof key text, value json"
msgstr "setof key text, value json"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11521(literal)
msgid "setof key text, value jsonb"
msgstr "setof key text, value jsonb"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11523(entry)
msgid "Expands the outermost JSON object into a set of key/value pairs."
msgstr ""
"Разворачивает внешний объект JSON в набор пар ключ/значение (key/value)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11526(literal)
msgid "select * from json_each('{\"a\":\"foo\", \"b\":\"bar\"}')"
msgstr "select * from json_each('{\"a\":\"foo\", \"b\":\"bar\"}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11528(programlisting)
#, no-wrap
msgid ""
" key | value\n"
"-----+-------\n"
" a   | \"foo\"\n"
" b   | \"bar\""
msgstr ""
" key | value\n"
"-----+-------\n"
" a   | \"foo\"\n"
" b   | \"bar\""

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11537(literal)
msgid "json_each_text(json)"
msgstr "json_each_text(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11538(literal)
msgid "jsonb_each_text(jsonb)"
msgstr "jsonb_each_text(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11540(type)
msgid "setof key text, value text"
msgstr "setof key text, value text"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11541(entry)
msgid ""
"Expands the outermost JSON object into a set of key/value pairs. The "
"returned values will be of type <type>text</type>."
msgstr ""
"Разворачивает внешний объект JSON в набор пар ключ/значение (key/value). "
"Возвращаемые значения будут иметь тип <type>text</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11545(literal)
msgid "select * from json_each_text('{\"a\":\"foo\", \"b\":\"bar\"}')"
msgstr "select * from json_each_text('{\"a\":\"foo\", \"b\":\"bar\"}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11547(programlisting)
#, no-wrap
msgid ""
" key | value\n"
"-----+-------\n"
" a   | foo\n"
" b   | bar"
msgstr ""
" key | value\n"
"-----+-------\n"
" a   | foo\n"
" b   | bar"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11556(literal)
msgid "json_extract_path(from_json json, VARIADIC path_elems text[])"
msgstr "json_extract_path(from_json json, VARIADIC path_elems text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11557(literal)
msgid "jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])"
msgstr "jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11559(type) func.xml:11737(type) func.xml:13439(type)
#: func.xml:13473(type)
msgid "json"
msgstr "json"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11561(entry)
msgid ""
"Returns JSON value pointed to by <replaceable>path_elems</replaceable> "
"(equivalent to <literal>#&gt;</literal> operator)."
msgstr ""
"Возвращает значение JSON по пути, заданному элементами пути "
"(<replaceable>path_elems</replaceable>) (равнозначно оператору <literal>#&gt;"
"</literal> operator)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11565(literal)
msgid ""
"json_extract_path('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4')"
msgstr ""
"json_extract_path('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11566(literal)
msgid "{\"f5\":99,\"f6\":\"foo\"}"
msgstr "{\"f5\":99,\"f6\":\"foo\"}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11569(literal)
msgid "json_extract_path_text(from_json json, VARIADIC path_elems text[])"
msgstr "json_extract_path_text(from_json json, VARIADIC path_elems text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11570(literal)
msgid "jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])"
msgstr "jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11573(entry)
msgid ""
"Returns JSON value pointed to by <replaceable>path_elems</replaceable> as "
"<type>text</type> (equivalent to <literal>#&gt;&gt;</literal> operator)."
msgstr ""
"Возвращает значение JSON по пути, заданному элементами пути "
"<replaceable>path_elems</replaceable>, как <type>text</type> (равнозначно "
"оператору <literal>#&gt;&gt;</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11578(literal)
msgid ""
"json_extract_path_text('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4', 'f6')"
msgstr ""
"json_extract_path_text('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4', 'f6')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11579(literal)
msgid "foo"
msgstr "foo"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11582(literal)
msgid "json_object_keys(json)"
msgstr "json_object_keys(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11583(literal)
msgid "jsonb_object_keys(jsonb)"
msgstr "jsonb_object_keys(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11586(entry)
msgid "Returns set of keys in the outermost JSON object."
msgstr "Возвращает набор ключей во внешнем объекте JSON."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11589(literal)
msgid ""
"json_object_keys('{\"f1\":\"abc\",\"f2\":{\"f3\":\"a\", \"f4\":\"b\"}}')"
msgstr ""
"json_object_keys('{\"f1\":\"abc\",\"f2\":{\"f3\":\"a\", \"f4\":\"b\"}}')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11591(programlisting)
#, no-wrap
msgid ""
" json_object_keys\n"
"------------------\n"
" f1\n"
" f2"
msgstr ""
" json_object_keys\n"
"-----------------\n"
" f1\n"
" f2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11600(literal)
msgid "json_populate_record(base anyelement, from_json json)"
msgstr "json_populate_record(base anyelement, from_json json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11601(literal)
msgid "jsonb_populate_record(base anyelement, from_json jsonb)"
msgstr "jsonb_populate_record(base anyelement, from_json jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11604(entry)
msgid ""
"Expands the object in <replaceable>from_json</replaceable> to a row whose "
"columns match the record type defined by <replaceable>base</replaceable> "
"(see note below)."
msgstr ""
"Разворачивает объект из <replaceable>from_json</replaceable> в табличную "
"строку, в которой столбцы соответствуют типу строки, заданному параметром "
"<replaceable>base</replaceable> (см. примечания ниже)."

#. +> REL_10
#: func.xml:11609(literal)
msgid ""
"select * from json_populate_record(null::myrowtype, '{\"a\": 1, \"b\": "
"[\"2\", \"a b\"], \"c\": {\"d\": 4, \"e\": \"a b c\"}}')"
msgstr ""
"select * from json_populate_record(null::myrowtype, '{\"a\": 1, \"b\": "
"[\"2\", \"a b\"], \"c\": {\"d\": 4, \"e\": \"a b c\"}}')"

#. +> REL_10
#: func.xml:11611(programlisting)
#, no-wrap
msgid ""
" a |   b       |      c\n"
"---+-----------+-------------\n"
" 1 | {2,\"a b\"} | (4,\"a b c\")"
msgstr ""
" a |   b       |      c\n"
"---+-----------+-------------\n"
" 1 | {2,\"a b\"} | (4,\"a b c\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11619(literal)
msgid "json_populate_recordset(base anyelement, from_json json)"
msgstr "json_populate_recordset(base anyelement, from_json json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11620(literal)
msgid "jsonb_populate_recordset(base anyelement, from_json jsonb)"
msgstr "jsonb_populate_recordset(base anyelement, from_json jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11622(type) func.xml:12820(type)
msgid "setof anyelement"
msgstr "setof anyelement"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11623(entry)
msgid ""
"Expands the outermost array of objects in <replaceable>from_json</"
"replaceable> to a set of rows whose columns match the record type defined by "
"<replaceable>base</replaceable> (see note below)."
msgstr ""
"Разворачивает внешний массив объектов из <replaceable>from_json</"
"replaceable> в набор табличных строк, в котором столбцы соответствуют типу "
"строки, заданному параметром <replaceable>base</replaceable> (см. примечания "
"ниже)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11629(literal)
msgid ""
"select * from json_populate_recordset(null::myrowtype, '[{\"a\":1,\"b\":2},"
"{\"a\":3,\"b\":4}]')"
msgstr ""
"select * from json_populate_recordset(null::myrowtype, '[{\"a\":1,\"b\":2},"
"{\"a\":3,\"b\":4}]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11631(programlisting)
#, no-wrap
msgid ""
" a | b\n"
"---+---\n"
" 1 | 2\n"
" 3 | 4"
msgstr ""
" a | b\n"
"---+---\n"
" 1 | 2\n"
" 3 | 4"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11640(literal)
msgid "json_array_elements(json)"
msgstr "json_array_elements(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11641(literal)
msgid "jsonb_array_elements(jsonb)"
msgstr "jsonb_array_elements(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11643(type)
msgid "setof json"
msgstr "setof json"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11644(type)
msgid "setof jsonb"
msgstr "setof jsonb"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11646(entry)
msgid "Expands a JSON array to a set of JSON values."
msgstr "Разворачивает массив JSON в набор значений JSON."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11649(literal)
msgid "select * from json_array_elements('[1,true, [2,false]]')"
msgstr "select * from json_array_elements('[1,true, [2,false]]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11651(programlisting)
#, no-wrap
msgid ""
"   value\n"
"-----------\n"
" 1\n"
" true\n"
" [2,false]"
msgstr ""
"   value\n"
"-----------\n"
" 1\n"
" true\n"
" [2,false]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11661(literal)
msgid "json_array_elements_text(json)"
msgstr "json_array_elements_text(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11662(literal)
msgid "jsonb_array_elements_text(jsonb)"
msgstr "jsonb_array_elements_text(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11665(entry)
msgid "Expands a JSON array to a set of <type>text</type> values."
msgstr "Разворачивает массив JSON в набор значений <type>text</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11668(literal)
msgid "select * from json_array_elements_text('[\"foo\", \"bar\"]')"
msgstr "select * from json_array_elements_text('[\"foo\", \"bar\"]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11670(programlisting)
#, no-wrap
msgid ""
"   value\n"
"-----------\n"
" foo\n"
" bar"
msgstr ""
"   value\n"
"-----------\n"
" foo\n"
" bar"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11679(literal)
msgid "json_typeof(json)"
msgstr "json_typeof(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11680(literal)
msgid "jsonb_typeof(jsonb)"
msgstr "jsonb_typeof(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11683(entry)
msgid ""
"Returns the type of the outermost JSON value as a text string. Possible "
"types are <literal>object</literal>, <literal>array</literal>, "
"<literal>string</literal>, <literal>number</literal>, <literal>boolean</"
"literal>, and <literal>null</literal>."
msgstr ""
"Возвращает тип внешнего значения JSON в виде текстовой строки. Возможные "
"типы: <literal>object</literal>, <literal>array</literal>, <literal>string</"
"literal>, <literal>number</literal>, <literal>boolean</literal> и "
"<literal>null</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11689(literal)
msgid "json_typeof('-123.4')"
msgstr "json_typeof('-123.4')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11690(literal)
msgctxt "literal"
msgid "number"
msgstr "number"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11693(literal)
msgid "json_to_record(json)"
msgstr "json_to_record(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11694(literal)
msgid "jsonb_to_record(jsonb)"
msgstr "jsonb_to_record(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11696(type) func.xml:17896(type) func.xml:17907(type)
#: func.xml:17918(type) func.xml:17929(type) func.xml:19961(type)
msgctxt "type"
msgid "record"
msgstr "record"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11697(entry)
msgid ""
"Builds an arbitrary record from a JSON object (see note below). As with all "
"functions returning <type>record</type>, the caller must explicitly define "
"the structure of the record with an <literal>AS</literal> clause."
msgstr ""
"Формирует обычную запись из объекта JSON (см. примечания ниже). Как и со "
"всеми функциями, возвращающими <type>record</type>, при вызове необходимо "
"явно определить структуру записи с помощью предложения <literal>AS</literal>."

#. +> REL_10
#: func.xml:11703(literal)
msgid ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":[1,2,3],\"e\":"
"\"bar\",\"r\": {\"a\": 123, \"b\": \"a b c\"}}') as x(a int, b text, c "
"int[], d text, r myrowtype)"
msgstr ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":[1,2,3],\"e\":"
"\"bar\",\"r\": {\"a\": 123, \"b\": \"a b c\"}}') as x(a int, b text, c "
"int[], d text, r myrowtype)"

#. +> REL_10
#: func.xml:11705(programlisting)
#, no-wrap
msgid ""
" a |    b    |    c    | d |       r\n"
"---+---------+---------+---+---------------\n"
" 1 | [1,2,3] | {1,2,3} |   | (123,\"a b c\")"
msgstr ""
" a |    b    |    c    | d |       r\n"
"---+---------+---------+---+---------------\n"
" 1 | [1,2,3] | {1,2,3} |   | (123,\"a b c\")"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11713(literal)
msgid "json_to_recordset(json)"
msgstr "json_to_recordset(json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11714(literal)
msgid "jsonb_to_recordset(jsonb)"
msgstr "jsonb_to_recordset(jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11717(entry)
msgid ""
"Builds an arbitrary set of records from a JSON array of objects (see note "
"below). As with all functions returning <type>record</type>, the caller must "
"explicitly define the structure of the record with an <literal>AS</literal> "
"clause."
msgstr ""
"Формирует обычный набор записей из массива объекта JSON (см. примечания "
"ниже). Как и со всеми функциями, возвращающими <type>record</type>, при "
"вызове необходимо явно определить структуру записи с помощью предложения "
"<literal>AS</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11723(literal)
msgid ""
"select * from json_to_recordset('[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":"
"\"bar\"}]') as x(a int, b text);"
msgstr ""
"select * from json_to_recordset('[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":"
"\"bar\"}]') as x(a int, b text);"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11725(programlisting)
#, no-wrap
msgid ""
" a |  b\n"
"---+-----\n"
" 1 | foo\n"
" 2 |"
msgstr ""
" a |  b\n"
"---+-----\n"
" 1 | foo\n"
" 2 |"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11734(literal)
msgid "json_strip_nulls(from_json json)"
msgstr "json_strip_nulls(from_json json)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11735(literal)
msgid "jsonb_strip_nulls(from_json jsonb)"
msgstr "jsonb_strip_nulls(from_json jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11738(entry)
msgid ""
"Returns <replaceable>from_json</replaceable> with all object fields that "
"have null values omitted. Other null values are untouched."
msgstr ""
"Возвращает значение <replaceable>from_json</replaceable>, из которого "
"исключаются все поля объекта, содержащие значения NULL. Другие значения NULL "
"остаются нетронутыми."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11743(literal)
msgid "json_strip_nulls('[{\"f1\":1,\"f2\":null},2,null,3]')"
msgstr "json_strip_nulls('[{\"f1\":1,\"f2\":null},2,null,3]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11744(literal)
msgid "[{\"f1\":1},2,null,3]"
msgstr "[{\"f1\":1},2,null,3]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11747(parameter)
msgid "create_missing"
msgstr "create_missing"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11747(literal)
msgid "jsonb_set(target jsonb, path text[], new_value jsonb<placeholder-1/>)"
msgstr "jsonb_set(target jsonb, path text[], new_value jsonb<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11750(entry)
msgid ""
"Returns <replaceable>target</replaceable> with the section designated by "
"<replaceable>path</replaceable> replaced by <replaceable>new_value</"
"replaceable>, or with <replaceable>new_value</replaceable> added if "
"<replaceable>create_missing</replaceable> is true ( default is "
"<literal>true</literal>) and the item designated by <replaceable>path</"
"replaceable> does not exist. As with the path orientated operators, negative "
"integers that appear in <replaceable>path</replaceable> count from the end "
"of JSON arrays."
msgstr ""
"Возвращает значение <replaceable>target</replaceable>, в котором раздел с "
"заданным путём (<replaceable>path</replaceable>) заменяется новым значением "
"(<replaceable>new_value</replaceable>), либо в него добавляется значение "
"<replaceable>new_value</replaceable>, если аргумент "
"<replaceable>create_missing</replaceable> равен <literal>true</literal> (это "
"значение по умолчанию) и элемент, на который ссылается <replaceable>path</"
"replaceable>, не существует. Как и с операторами, рассчитанными на пути, "
"отрицательные числа в пути (<replaceable>path</replaceable>) обозначают "
"отсчёт от конца массивов JSON."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11762(literal)
msgid ""
"jsonb_set('[{\"f1\":1,\"f2\":null},2,null,3]', '{0,f1}','[2,3,4]', false)"
msgstr ""
"jsonb_set('[{\"f1\":1,\"f2\":null},2,null,3]', '{0,f1}','[2,3,4]', false)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11763(literal)
msgid "jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]')"
msgstr "jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11765(literal)
msgid "[{\"f1\":[2,3,4],\"f2\":null},2,null,3]"
msgstr "[{\"f1\":[2,3,4],\"f2\":null},2,null,3]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11766(literal)
msgid "[{\"f1\": 1, \"f2\": null, \"f3\": [2, 3, 4]}, 2]"
msgstr "[{\"f1\": 1, \"f2\": null, \"f3\": [2, 3, 4]}, 2]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11772(parameter)
msgid "insert_after"
msgstr "insert_after"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11771(literal)
msgid ""
"jsonb_insert(target jsonb, path text[], new_value jsonb, "
"<optional><placeholder-1/> <placeholder-2/></optional>)"
msgstr ""
"jsonb_insert(target jsonb, path text[], new_value jsonb, "
"<optional><placeholder-1/> <placeholder-2/></optional>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11776(entry)
msgid ""
"Returns <replaceable>target</replaceable> with <replaceable>new_value</"
"replaceable> inserted. If <replaceable>target</replaceable> section "
"designated by <replaceable>path</replaceable> is in a JSONB array, "
"<replaceable>new_value</replaceable> will be inserted before target or after "
"if <replaceable>insert_after</replaceable> is true (default is "
"<literal>false</literal>). If <replaceable>target</replaceable> section "
"designated by <replaceable>path</replaceable> is in JSONB object, "
"<replaceable>new_value</replaceable> will be inserted only if "
"<replaceable>target</replaceable> does not exist. As with the path "
"orientated operators, negative integers that appear in <replaceable>path</"
"replaceable> count from the end of JSON arrays."
msgstr ""
"Возвращает значение <replaceable>target</replaceable> с вставленным в него "
"новым значением <replaceable>new_value</replaceable>. Если место в "
"<replaceable>target</replaceable>, выбранное путём <replaceable>path</"
"replaceable>, оказывается в массиве JSONB, <replaceable>new_value</"
"replaceable> будет вставлен до (по умолчанию) или после (если параметр "
"<replaceable>insert_after</replaceable> равен true) выбранной позиции. Если "
"место в <replaceable>target</replaceable>, выбранное путём "
"<replaceable>path</replaceable>, оказывается в объекте JSONB, значение "
"<replaceable>new_value</replaceable> будет вставлено в него, только если "
"заданный путь <replaceable>path</replaceable> не существует. Как и с "
"операторами, рассчитанными на пути, отрицательные числа в пути "
"(<replaceable>path</replaceable>) обозначают отсчёт от конца массивов JSON."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11791(literal)
msgid "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"')"
msgstr "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11794(literal)
msgid "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"', true)"
msgstr "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"', true)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11798(literal)
msgid "{\"a\": [0, \"new_value\", 1, 2]}"
msgstr "{\"a\": [0, \"new_value\", 1, 2]}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11799(literal)
msgid "{\"a\": [0, 1, \"new_value\", 2]}"
msgstr "{\"a\": [0, 1, \"new_value\", 2]}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11803(literal)
msgid "jsonb_pretty(from_json jsonb)"
msgstr "jsonb_pretty(from_json jsonb)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11806(entry)
msgid "Returns <replaceable>from_json</replaceable> as indented JSON text."
msgstr ""
"Возвращает значение <replaceable>from_json</replaceable> в виде текста JSON "
"с отступами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11810(literal)
msgid "jsonb_pretty('[{\"f1\":1,\"f2\":null},2,null,3]')"
msgstr "jsonb_pretty('[{\"f1\":1,\"f2\":null},2,null,3]')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11812(programlisting)
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        \"f1\": 1,\n"
"        \"f2\": null\n"
"    },\n"
"    2,\n"
"    null,\n"
"    3\n"
"]"
msgstr ""
"[\n"
"    {\n"
"        \"f1\": 1,\n"
"        \"f2\": null\n"
"    },\n"
"    2,\n"
"    null,\n"
"    3\n"
"]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11830(para)
msgid ""
"Many of these functions and operators will convert Unicode escapes in JSON "
"strings to the appropriate single character. This is a non-issue if the "
"input is type <type>jsonb</type>, because the conversion was already done; "
"but for <type>json</type> input, this may result in throwing an error, as "
"noted in <xref linkend=\"datatype-json\"/>."
msgstr ""
"Многие из этих функций и операторов преобразуют спецпоследовательности "
"Unicode в JSON-строках в соответствующие одиночные символы. Для входных "
"данных типа <type>jsonb</type> это ничем не грозит, так как преобразование "
"уже выполнено; однако для типа <type>json</type> в результате может "
"произойти ошибка, как отмечено в <xref remap=\"6\" linkend=\"datatype-json\"/"
">."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11840(para)
msgid ""
"In <function>json_populate_record</function>, "
"<function>json_populate_recordset</function>, <function>json_to_record</"
"function> and <function>json_to_recordset</function>, type coercion from the "
"JSON is <quote>best effort</quote> and may not result in desired values for "
"some types. JSON keys are matched to identical column names in the target "
"row type. JSON fields that do not appear in the target row type will be "
"omitted from the output, and target columns that do not match any JSON field "
"will simply be NULL."
msgstr ""
"В <function>json_populate_record</function>, "
"<function>json_populate_recordset</function>, <function>json_to_record</"
"function> и <function>json_to_recordset</function> приведение типов из JSON "
"выполняется <quote>насколько это возможно</quote> и его результаты могут "
"быть не вполне ожидаемыми для некоторых типов. Ключи JSON сопоставляются с "
"идентичными именами столбцов в целевом типе записей. Поля JSON, "
"отсутствующие в целевом типе, в выходные данные не попадают, а целевые "
"столбцы, для которых нет соответствующих полей JSON, будут просто содержать "
"NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11852(para)
msgid ""
"All the items of the <literal>path</literal> parameter of "
"<literal>jsonb_set</literal> as well as <literal>jsonb_insert</literal> "
"except the last item must be present in the <literal>target</literal>. If "
"<literal>create_missing</literal> is false, all items of the <literal>path</"
"literal> parameter of <literal>jsonb_set</literal> must be present. If these "
"conditions are not met the <literal>target</literal> is returned unchanged."
msgstr ""
"В <literal>target</literal> должны присутствовать все элементы пути, "
"заданного параметром <literal>path</literal> функций <literal>jsonb_set</"
"literal> и <literal>jsonb_insert</literal>, за исключением последнего. Если "
"<literal>create_missing</literal> равен false, должны присутствовать "
"абсолютно все элементы пути <literal>path</literal>, переданного функции "
"<literal>jsonb_set</literal>. Если это условие не выполняется, значение "
"<literal>target</literal> возвращается неизменённым."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11860(para)
msgid ""
"If the last path item is an object key, it will be created if it is absent "
"and given the new value. If the last path item is an array index, if it is "
"positive the item to set is found by counting from the left, and if negative "
"by counting from the right - <literal>-1</literal> designates the rightmost "
"element, and so on. If the item is out of the range -array_length .. "
"array_length -1, and create_missing is true, the new value is added at the "
"beginning of the array if the item is negative, and at the end of the array "
"if it is positive."
msgstr ""
"Если последним элементом пути оказывается ключ объекта, он будет создан в "
"случае отсутствия и получит новое значение. Если последний элемент пути — "
"позиция в массиве, то когда она положительна, целевой элемент отсчитывается "
"слева, а когда отрицательна — справа, то есть <literal>-1</literal> "
"указывает на самый правый элемент и т. д. Если позиция лежит вне диапазона -"
"длина_массива .. длина_массива -1, и параметр create_missing равен true, "
"новое значение добавляется в начало массива, если позиция отрицательна, и в "
"конец, если положительна."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11874(para)
msgid ""
"The <literal>json_typeof</literal> function's <literal>null</literal> return "
"value should not be confused with a SQL NULL. While calling "
"<literal>json_typeof('null'::json)</literal> will return <literal>null</"
"literal>, calling <literal>json_typeof(NULL::json)</literal> will return a "
"SQL NULL."
msgstr ""
"Значение <literal>null</literal>, возвращаемое функцией "
"<literal>json_typeof</literal>, не следует путать с SQL NULL. Тогда как при "
"вызове <literal>json_typeof('null'::json)</literal> возвращается "
"<literal>null</literal>, при вызове <literal>json_typeof(NULL::json)</"
"literal> будет возвращено значение SQL NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11884(para)
msgid ""
"If the argument to <literal>json_strip_nulls</literal> contains duplicate "
"field names in any object, the result could be semantically somewhat "
"different, depending on the order in which they occur. This is not an issue "
"for <literal>jsonb_strip_nulls</literal> since <type>jsonb</type> values "
"never have duplicate object field names."
msgstr ""
"Если аргумент функции <literal>json_strip_nulls</literal> содержит "
"повторяющиеся имена полей в любом объекте, в результате могут проявиться "
"семантические различия, в зависимости от порядка этих полей. Это не проблема "
"для функции <literal>jsonb_strip_nulls</literal>, так как в значениях "
"<type>jsonb</type> имена полей не могут дублироваться."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11893(para)
msgid ""
"See also <xref linkend=\"functions-aggregate\"/> for the aggregate function "
"<function>json_agg</function> which aggregates record values as JSON, and "
"the aggregate function <function>json_object_agg</function> which aggregates "
"pairs of values into a JSON object, and their <type>jsonb</type> "
"equivalents, <function>jsonb_agg</function> and <function>jsonb_object_agg</"
"function>."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-aggregate\"/> вы также можете узнать "
"об агрегатной функции <function>json_agg</function>, которая агрегирует "
"значения записи в виде JSON, и агрегатной функции <function>json_object_agg</"
"function>, агрегирующей пары значений в объект JSON, а также их аналогах для "
"<type>jsonb</type>, функциях <function>jsonb_agg</function> и "
"<function>jsonb_object_agg</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11905(title)
msgid "Sequence Manipulation Functions"
msgstr "Функции для работы с последовательностями"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11907(indexterm)
msgid "<primary>sequence</primary>"
msgstr "<primary>последовательность</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11910(indexterm)
msgid "<primary>nextval</primary>"
msgstr "<primary>nextval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11913(indexterm)
msgid "<primary>currval</primary>"
msgstr "<primary>currval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11916(indexterm)
msgid "<primary>lastval</primary>"
msgstr "<primary>lastval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11919(indexterm)
msgid "<primary>setval</primary>"
msgstr "<primary>setval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11923(para)
msgid ""
"This section describes functions for operating on <firstterm>sequence "
"objects</firstterm>, also called sequence generators or just sequences. "
"Sequence objects are special single-row tables created with <xref linkend="
"\"sql-createsequence\"/>. Sequence objects are commonly used to generate "
"unique identifiers for rows of a table. The sequence functions, listed in "
"<xref linkend=\"functions-sequence-table\"/>, provide simple, multiuser-safe "
"methods for obtaining successive sequence values from sequence objects."
msgstr ""
"В этом разделе описаны функции для работы с объектами, представляющими "
"<firstterm>последовательности</firstterm>. Такие объекты (также называемыми "
"генераторами последовательностей или просто последовательностями) являются "
"специальными таблицами из одной строки и создаются командой <xref linkend="
"\"sql-createsequence\"/>. Используются они обычно для получения уникальных "
"идентификаторов строк таблицы. Функции, перечисленные в <xref remap=\"6\" "
"linkend=\"functions-sequence-table\"/>, предоставляют простые и безопасные "
"для параллельного использования методы получения очередных значений таких "
"последовательностей."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11936(title)
msgid "Sequence Functions"
msgstr "Функции для работы с последовательностями"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11944(type) func.xml:11956(type) func.xml:11961(type)
#: func.xml:11966(type) func.xml:17129(type) func.xml:19445(type)
#: func.xml:19454(type) func.xml:19465(type) func.xml:19503(type)
#: func.xml:19527(type) func.xml:19678(type) func.xml:19687(type)
#: func.xml:19698(type) func.xml:19831(type) func.xml:19838(type)
#: func.xml:19845(type) func.xml:19852(type)
msgid "regclass"
msgstr "regclass"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11944(function)
msgid "currval(<placeholder-1/>)"
msgstr "currval(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11946(entry)
msgid ""
"Return value most recently obtained with <function>nextval</function> for "
"specified sequence"
msgstr ""
"Выдаёт значение заданной последовательности, которое было возвращено при "
"последнем вызове функции <function>nextval</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11950(function)
msgid "lastval()"
msgstr "lastval()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11952(entry)
msgid ""
"Return value most recently obtained with <function>nextval</function> for "
"any sequence"
msgstr ""
"Выдаёт значение любой последовательности, которое было возвращено при "
"последнем вызове функции <function>nextval</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11956(function)
msgid "nextval(<placeholder-1/>)"
msgstr "nextval(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11958(entry)
msgid "Advance sequence and return new value"
msgstr "Продвигает последовательность к следующему значению и возвращает его"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11961(function)
msgid "setval(<placeholder-1/>, <placeholder-2/>)"
msgstr "setval(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11963(entry)
msgid "Set sequence's current value"
msgstr "Устанавливает текущее значение последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11966(function)
msgid "setval(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "setval(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11968(entry)
msgid "Set sequence's current value and <literal>is_called</literal> flag"
msgstr ""
"Устанавливает текущее значение последовательности и флаг <literal>is_called</"
"literal>, указывающий на то, что это значение использовалось"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11984(programlisting)
#, no-wrap
msgid ""
"nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>\n"
"nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>\n"
"nextval('\"Foo\"')    <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>"
msgstr ""
"nextval('foo')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>\n"
"nextval('FOO')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>\n"
"nextval('\"Foo\"')    <lineannotation>обращается к последовательности <literal>Foo</literal></lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11990(programlisting)
#, no-wrap
msgid ""
"nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>\n"
"nextval('\"myschema\".foo')   <lineannotation>same as above</lineannotation>\n"
"nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>"
msgstr ""
"nextval('myschema.foo')     <lineannotation>обращается к <literal>myschema.foo</literal></lineannotation>\n"
"nextval('\"myschema\".foo')   <lineannotation>то же самое</lineannotation>\n"
"nextval('foo')              <lineannotation>ищет <literal>foo</literal> в пути поиска</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:11974(para)
msgid ""
"The sequence to be operated on by a sequence function is specified by a "
"<type>regclass</type> argument, which is simply the OID of the sequence in "
"the <structname>pg_class</structname> system catalog. You do not have to "
"look up the OID by hand, however, since the <type>regclass</type> data "
"type's input converter will do the work for you. Just write the sequence "
"name enclosed in single quotes so that it looks like a literal constant. For "
"compatibility with the handling of ordinary <acronym>SQL</acronym> names, "
"the string will be converted to lower case unless it contains double quotes "
"around the sequence name. Thus: <placeholder-1/> The sequence name can be "
"schema-qualified if necessary: <placeholder-2/> See <xref linkend=\"datatype-"
"oid\"/> for more information about <type>regclass</type>."
msgstr ""
"Последовательность, к которой будет обращаться одна из этих функций, "
"определяется аргументом <type>regclass</type>, задающим просто OID "
"последовательности в системном каталоге <structname>pg_class</structname>. "
"Вычислять этот OID вручную не нужно, так как процедура ввода данных "
"<type>regclass</type> автоматически выполнит эту работу за вас. Просто "
"запишите имя последовательности в апострофах, чтобы оно выглядело как "
"строковая константа. Для совместимости с обычными именами <acronym>SQL</"
"acronym> эта строка будет переведена в нижний регистр, если только она не "
"заключена в кавычки. Например: <placeholder-1/> При необходимости имя "
"последовательности можно дополнить именем схемы: <placeholder-2/> Подробнее "
"тип <type>regclass</type> описан в <xref remap=\"6\" linkend=\"datatype-oid"
"\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12000(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.1, the arguments of the "
"sequence functions were of type <type>text</type>, not <type>regclass</"
"type>, and the above-described conversion from a text string to an OID value "
"would happen at run time during each call. For backward compatibility, this "
"facility still exists, but internally it is now handled as an implicit "
"coercion from <type>text</type> to <type>regclass</type> before the function "
"is invoked."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 8.1 аргументы этих функций "
"имели тип <type>text</type>, а не <type>regclass</type>, и поэтому описанное "
"выше преобразование текстовой строки в OID имело место при каждом вызове "
"функции. Это поведение сохраняется и сейчас для обратной совместимости, но "
"сейчас оно реализовано как неявное приведение типа <type>text</type> к типу "
"<type>regclass</type> перед вызовом функции."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12020(programlisting)
#, no-wrap
msgid "nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>"
msgstr "nextval('foo'::text)      <lineannotation><literal>foo</literal> распознаётся во время выполнения</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12010(para)
msgid ""
"When you write the argument of a sequence function as an unadorned literal "
"string, it becomes a constant of type <type>regclass</type>. Since this is "
"really just an OID, it will track the originally identified sequence despite "
"later renaming, schema reassignment, etc. This <quote>early binding</quote> "
"behavior is usually desirable for sequence references in column defaults and "
"views. But sometimes you might want <quote>late binding</quote> where the "
"sequence reference is resolved at run time. To get late-binding behavior, "
"force the constant to be stored as a <type>text</type> constant instead of "
"<type>regclass</type>: <placeholder-1/> Note that late binding was the only "
"behavior supported in <productname>PostgreSQL</productname> releases before "
"8.1, so you might need to do this to preserve the semantics of old "
"applications."
msgstr ""
"Когда вы записываете аргумент функции, работающей с последовательностью, как "
"текстовую строку в чистом виде, она становится константой типа "
"<type>regclass</type>. Так как фактически это будет просто значение OID, оно "
"будет привязано к изначально идентифицированной последовательности, несмотря "
"на то, что она может быть переименована, перенесена в другую схему и т. д. "
"Такое <quote>раннее связывание</quote> обычно желательно для ссылок на "
"последовательности в значениях столбцов по умолчанию и представлениях. Но "
"иногда возникает необходимость в <quote>позднем связывании</quote>, когда "
"ссылки на последовательности распознаются в процессе выполнения. Чтобы "
"получить такое поведение, нужно принудительно изменить тип константы с "
"<type>regclass</type> на <type>text</type>: <placeholder-1/> Заметьте, что "
"версии <productname>PostgreSQL</productname> до 8.1 поддерживали только "
"позднее связывание, так что это может быть полезно и для совместимости со "
"старыми приложениями."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12028(para)
msgid ""
"Of course, the argument of a sequence function can be an expression as well "
"as a constant. If it is a text expression then the implicit coercion will "
"result in a run-time lookup."
msgstr ""
"Конечно же, аргументом таких функций может быть не только константа, но и "
"выражение. Если это выражение текстового типа, неявное приведение типов "
"повлечёт разрешение имени во время выполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12040(function)
msgid "nextval"
msgstr "nextval"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12042(para)
msgid ""
"Advance the sequence object to its next value and return that value. This is "
"done atomically: even if multiple sessions execute <function>nextval</"
"function> concurrently, each will safely receive a distinct sequence value."
msgstr ""
"Продвигает последовательность к следующему значению и возвращает его. Это "
"атомарная операция: если <function>nextval</function> вызывается "
"одновременно в нескольких сеансах, в результате каждого вызова будут "
"гарантированно получены разные значения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12049(para)
msgid ""
"If a sequence object has been created with default parameters, successive "
"<function>nextval</function> calls will return successive values beginning "
"with 1. Other behaviors can be obtained by using special parameters in the "
"<xref linkend=\"sql-createsequence\"/> command; see its command reference "
"page for more information."
msgstr ""
"Если последовательность создаётся с параметрами по умолчанию, успешные "
"вызовы <function>nextval</function> получают очередные значения по "
"возрастанию, начиная с 1. Другое поведение можно получить с помощью "
"специальных параметров в команде <xref linkend=\"sql-createsequence\"/>; "
"подробнее это описано на странице описания команды."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12058(para)
msgid ""
"To avoid blocking concurrent transactions that obtain numbers from the same "
"sequence, a <function>nextval</function> operation is never rolled back; "
"that is, once a value has been fetched it is considered used and will not be "
"returned again. This is true even if the surrounding transaction later "
"aborts, or if the calling query ends up not using the value. For example an "
"<command>INSERT</command> with an <literal>ON CONFLICT</literal> clause will "
"compute the to-be-inserted tuple, including doing any required "
"<function>nextval</function> calls, before detecting any conflict that would "
"cause it to follow the <literal>ON CONFLICT</literal> rule instead. Such "
"cases will leave unused <quote>holes</quote> in the sequence of assigned "
"values. Thus, <productname>PostgreSQL</productname> sequence objects "
"<emphasis>cannot be used to obtain <quote>gapless</quote> sequences</"
"emphasis>."
msgstr ""
"Во избежание блокирования параллельных транзакций, пытающихся получить "
"значения одной последовательности, операция <function>nextval</function> "
"никогда не откатывается; то есть, как только значение было выбрано, оно "
"считается использованным и не будет возвращено снова. Это утверждение верно, "
"даже когда окружающая транзакция впоследствии прерывается или вызывающий "
"запрос никак не использует это значение. Например, команда <command>INSERT</"
"command> с предложением <literal>ON CONFLICT</literal> вычислит кортеж, "
"претендующий на добавление, произведя все требуемые вызовы "
"<function>nextval</function>, прежде чем выявит конфликты, которые могут "
"привести к отработке правил <literal>ON CONFLICT</literal> вместо "
"добавления. В таких ситуациях в последовательности задействованных значений "
"могут образовываться <quote>дыры</quote>. Таким образом, объекты "
"последовательностей <productname>PostgreSQL</productname> <emphasis>не "
"годятся для получения непрерывных последовательностей</emphasis>."

#. +> REL_10
#: func.xml:12075(para)
msgid ""
"This function requires <literal>USAGE</literal> or <literal>UPDATE</literal> "
"privilege on the sequence."
msgstr ""
"Этой функции требуется право <literal>USAGE</literal> или <literal>UPDATE</"
"literal> для последовательности."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12083(function)
msgid "currval"
msgstr "currval"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12085(para)
msgid ""
"Return the value most recently obtained by <function>nextval</function> for "
"this sequence in the current session. (An error is reported if "
"<function>nextval</function> has never been called for this sequence in this "
"session.) Because this is returning a session-local value, it gives a "
"predictable answer whether or not other sessions have executed "
"<function>nextval</function> since the current session did."
msgstr ""
"Возвращает значение, выданное при последнем вызове <function>nextval</"
"function> для этой последовательности в текущем сеансе. (Если в данном "
"сеансе <function>nextval</function> ни разу не вызывалась для данной "
"последовательности, возвращается ошибка.) Так как это значение ограничено "
"рамками сеанса, эта функция выдаёт предсказуемый результат вне зависимости "
"от того, вызвалась ли впоследствии <function>nextval</function> в других "
"сеансах или нет."

#. +> REL_10
#: func.xml:12095(para)
msgid ""
"This function requires <literal>USAGE</literal> or <literal>SELECT</literal> "
"privilege on the sequence."
msgstr ""
"Этой функции требуется право <literal>USAGE</literal> или <literal>SELECT</"
"literal> для последовательности."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12103(function)
msgid "lastval"
msgstr "lastval"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12105(para)
msgid ""
"Return the value most recently returned by <function>nextval</function> in "
"the current session. This function is identical to <function>currval</"
"function>, except that instead of taking the sequence name as an argument it "
"refers to whichever sequence <function>nextval</function> was most recently "
"applied to in the current session. It is an error to call <function>lastval</"
"function> if <function>nextval</function> has not yet been called in the "
"current session."
msgstr ""
"Возвращает значение, выданное при последнем вызове <function>nextval</"
"function> в текущем сеансе. Эта функция подобна <function>currval</"
"function>, но она не принимает в параметрах имя последовательности, а "
"обращается к той последовательности, для которой вызывалась "
"<function>nextval</function> в последний раз в текущем сеансе. Если в "
"текущем сеансе функция <function>nextval</function> ещё не вызывалась, при "
"вызове <function>lastval</function> произойдёт ошибка."

#. +> REL_10
#: func.xml:12116(para)
msgid ""
"This function requires <literal>USAGE</literal> or <literal>SELECT</literal> "
"privilege on the last used sequence."
msgstr ""
"Этой функции требуется право <literal>USAGE</literal> или <literal>SELECT</"
"literal> для последней использованной последовательности."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12124(function)
msgid "setval"
msgstr "setval"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12126(para)
msgid ""
"Reset the sequence object's counter value. The two-parameter form sets the "
"sequence's <literal>last_value</literal> field to the specified value and "
"sets its <literal>is_called</literal> field to <literal>true</literal>, "
"meaning that the next <function>nextval</function> will advance the sequence "
"before returning a value. The value reported by <function>currval</function> "
"is also set to the specified value. In the three-parameter form, "
"<literal>is_called</literal> can be set to either <literal>true</literal> or "
"<literal>false</literal>. <literal>true</literal> has the same effect as the "
"two-parameter form. If it is set to <literal>false</literal>, the next "
"<function>nextval</function> will return exactly the specified value, and "
"sequence advancement commences with the following <function>nextval</"
"function>. Furthermore, the value reported by <function>currval</function> "
"is not changed in this case. For example, <screen>\n"
"SELECT setval('foo', 42);           <lineannotation>Next <function>nextval</"
"function> will return 43</lineannotation>\n"
"SELECT setval('foo', 42, true);     <lineannotation>Same as above</"
"lineannotation>\n"
"SELECT setval('foo', 42, false);    <lineannotation>Next <function>nextval</"
"function> will return 42</lineannotation>\n"
"</screen> The result returned by <function>setval</function> is just the "
"value of its second argument."
msgstr ""
"Сбрасывает счётчик последовательности. В форме с двумя параметрами "
"устанавливает для последовательности заданное значение поля "
"<literal>last_value</literal> и значение <literal>true</literal> для флага "
"<literal>is_called</literal>, показывающего, что при следующем вызове "
"<function>nextval</function> последовательность должна сначала продвинуться "
"к очередному значению, которое будет возвращено. При этом <function>currval</"
"function> также возвратит заданное значение. В форме с тремя параметрами "
"флагу <literal>is_called</literal> можно присвоить <literal>true</literal> "
"или <literal>false</literal>. Со значением <literal>true</literal> она "
"действует так же, как и форма с двумя параметрами. Если же присвоить этому "
"флагу значение <literal>false</literal>, первый вызов <function>nextval</"
"function> после этого вернёт именно заданное значение, а продвижение "
"последовательности произойдёт при последующем вызове <function>nextval</"
"function>. Кроме того, значение, возвращаемое <function>currval</function> в "
"этом случае, не меняется. Например, <screen>\n"
"SELECT setval('foo', 42);           <lineannotation>Следующий вызов "
"<function>nextval</function> вернёт 43</lineannotation>\n"
"SELECT setval('foo', 42, true);     <lineannotation>То же самое</"
"lineannotation>\n"
"SELECT setval('foo', 42, false);    <lineannotation>Следующий вызов "
"<function>nextval</function> вернёт 42</lineannotation>\n"
"</screen> Результатом самой функции <function>setval</function> будет просто "
"значение её второго аргумента."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12152(para)
msgid ""
"Because sequences are non-transactional, changes made by <function>setval</"
"function> are not undone if the transaction rolls back."
msgstr ""
"Так как значения последовательностей изменяются вне транзакций, действие "
"функции <function>setval</function> не отменяется при откате транзакции."

#. +> REL_10
#: func.xml:12159(para)
msgid ""
"This function requires <literal>UPDATE</literal> privilege on the sequence."
msgstr ""
"Этой функции требуется право <literal>UPDATE</literal> для "
"последовательности."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12035(para)
msgid "The available sequence functions are: <placeholder-1/>"
msgstr ""
"Ниже описаны все функции, предназначенные для работы с последовательностями: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12172(title)
msgid "Conditional Expressions"
msgstr "Условные выражения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12174(indexterm)
msgid "<primary>CASE</primary>"
msgstr "<primary>CASE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12178(indexterm)
msgid "<primary>conditional expression</primary>"
msgstr "<primary>условное выражение</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12182(para)
msgid ""
"This section describes the <acronym>SQL</acronym>-compliant conditional "
"expressions available in <productname>PostgreSQL</productname>."
msgstr ""
"В этом разделе описаны <acronym>SQL</acronym>-совместимые условные "
"выражения, которые поддерживаются в <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12188(para)
msgid ""
"If your needs go beyond the capabilities of these conditional expressions, "
"you might want to consider writing a stored procedure in a more expressive "
"programming language."
msgstr ""
"Если возможностей этих условных выражений оказывается недостаточно, "
"вероятно, имеет смысл перейти к написанию хранимых процедур на более мощном "
"языке программирования."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12196(literal)
msgid "CASE"
msgstr "CASE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12198(para)
msgid ""
"The <acronym>SQL</acronym> <token>CASE</token> expression is a generic "
"conditional expression, similar to if/else statements in other programming "
"languages: <synopsis>\n"
"CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</"
"replaceable>\n"
"     <optional>WHEN ...</optional>\n"
"     <optional>ELSE <replaceable>result</replaceable></optional>\n"
"END\n"
"</synopsis> <token>CASE</token> clauses can be used wherever an expression "
"is valid. Each <replaceable>condition</replaceable> is an expression that "
"returns a <type>boolean</type> result. If the condition's result is true, "
"the value of the <token>CASE</token> expression is the <replaceable>result</"
"replaceable> that follows the condition, and the remainder of the "
"<token>CASE</token> expression is not processed. If the condition's result "
"is not true, any subsequent <token>WHEN</token> clauses are examined in the "
"same manner. If no <token>WHEN</token> <replaceable>condition</replaceable> "
"yields true, the value of the <token>CASE</token> expression is the "
"<replaceable>result</replaceable> of the <token>ELSE</token> clause. If the "
"<token>ELSE</token> clause is omitted and no condition is true, the result "
"is null."
msgstr ""
"Выражение <token>CASE</token> в <acronym>SQL</acronym> представляет собой "
"общее условное выражение, напоминающее операторы if/else в других языках "
"программирования: <synopsis>\n"
"CASE WHEN <replaceable>условие</replaceable> THEN <replaceable>результат</"
"replaceable>\n"
"     <optional>WHEN ...</optional>\n"
"     <optional>ELSE <replaceable>результат</replaceable></optional>\n"
"END\n"
"</synopsis>Предложения <token>CASE</token> можно использовать везде, где "
"допускаются выражения. Каждое <replaceable>условие</replaceable> в нём "
"представляет собой выражение, возвращающее результат типа <type>boolean</"
"type>. Если результатом выражения оказывается true, значением выражения "
"<token>CASE</token> становится <replaceable>результат</replaceable>, "
"следующий за условием, а остальная часть выражения <token>CASE</token> не "
"вычисляется. Если же условие не выполняется, за ним таким же образом "
"проверяются все последующие предложения <token>WHEN</token>. Если не "
"выполняется ни одно из <replaceable>условий</replaceable> <token>WHEN</"
"token>, значением <token>CASE</token> становится <replaceable>результат</"
"replaceable>, записанный в предложении <token>ELSE</token>. Если при этом "
"предложение <token>ELSE</token> отсутствует, результатом выражения будет "
"NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12224(para)
msgid ""
"An example: <screen>\n"
"SELECT * FROM test;\n"
"\n"
" a\n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"\n"
"SELECT a,\n"
"       CASE WHEN a=1 THEN 'one'\n"
"            WHEN a=2 THEN 'two'\n"
"            ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"
msgstr ""
"Пример: <screen>\n"
"SELECT * FROM test;\n"
"\n"
" a\n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"\n"
"SELECT a,\n"
"       CASE WHEN a=1 THEN 'one'\n"
"            WHEN a=2 THEN 'two'\n"
"            ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12251(para)
msgid ""
"The data types of all the <replaceable>result</replaceable> expressions must "
"be convertible to a single output type. See <xref linkend=\"typeconv-union-"
"case\"/> for more details."
msgstr ""
"Типы данных всех выражений <replaceable>результатов</replaceable> должны "
"приводиться к одному выходному типу. Подробнее это описано в <xref remap="
"\"6\" linkend=\"typeconv-union-case\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12257(para)
msgid ""
"There is a <quote>simple</quote> form of <token>CASE</token> expression that "
"is a variant of the general form above: <synopsis>\n"
"CASE <replaceable>expression</replaceable>\n"
"    WHEN <replaceable>value</replaceable> THEN <replaceable>result</"
"replaceable>\n"
"    <optional>WHEN ...</optional>\n"
"    <optional>ELSE <replaceable>result</replaceable></optional>\n"
"END\n"
"</synopsis> The first <replaceable>expression</replaceable> is computed, "
"then compared to each of the <replaceable>value</replaceable> expressions in "
"the <token>WHEN</token> clauses until one is found that is equal to it. If "
"no match is found, the <replaceable>result</replaceable> of the <token>ELSE</"
"token> clause (or a null value) is returned. This is similar to the "
"<function>switch</function> statement in C."
msgstr ""
"Существует также <quote>простая</quote> форма выражения <token>CASE</token>, "
"разновидность вышеприведённой общей формы: <synopsis>\n"
"CASE <replaceable>выражение</replaceable>\n"
"    WHEN <replaceable>значение</replaceable> THEN <replaceable>результат</"
"replaceable>\n"
"    <optional>WHEN ...</optional>\n"
"    <optional>ELSE <replaceable>результат</replaceable></optional>\n"
"END\n"
"</synopsis> В такой форме сначала вычисляется первое <replaceable>выражение</"
"replaceable>, а затем его результат сравнивается с выражениями "
"<replaceable>значений</replaceable> в предложениях <token>WHEN</token>, пока "
"не будет найдено равное ему. Если такого не значения не находится, "
"возвращается <replaceable>результат</replaceable> предложения <token>ELSE</"
"token> (или NULL). Эта форма больше похожа на оператор <function>switch</"
"function>, существующий в языке C."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12278(para)
msgid ""
"The example above can be written using the simple <token>CASE</token> "
"syntax: <screen>\n"
"SELECT a,\n"
"       CASE a WHEN 1 THEN 'one'\n"
"              WHEN 2 THEN 'two'\n"
"              ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"
msgstr ""
"Показанный ранее пример можно записать по-другому, используя простую форму "
"<token>CASE</token>: <screen>\n"
"SELECT a,\n"
"       CASE a WHEN 1 THEN 'one'\n"
"              WHEN 2 THEN 'two'\n"
"              ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12301(programlisting)
#, no-wrap
msgid "SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;"
msgstr "SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12297(para)
msgid ""
"A <token>CASE</token> expression does not evaluate any subexpressions that "
"are not needed to determine the result. For example, this is a possible way "
"of avoiding a division-by-zero failure: <placeholder-1/>"
msgstr ""
"В выражении <token>CASE</token> вычисляются только те подвыражения, которые "
"необходимы для получения результата. Например, так можно избежать ошибки "
"деления на ноль: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12307(para)
msgid ""
"As described in <xref linkend=\"syntax-express-eval\"/>, there are various "
"situations in which subexpressions of an expression are evaluated at "
"different times, so that the principle that <quote><token>CASE</token> "
"evaluates only necessary subexpressions</quote> is not ironclad. For example "
"a constant <literal>1/0</literal> subexpression will usually result in a "
"division-by-zero failure at planning time, even if it's within a "
"<token>CASE</token> arm that would never be entered at run time."
msgstr ""
"Как было описано в <xref remap=\"6\" linkend=\"syntax-express-eval\"/>, всё "
"же возможны ситуации, когда подвыражения вычисляются на разных этапах, так "
"что железной гарантии, что в <quote><token>CASE</token> вычисляются только "
"необходимые подвыражения</quote>, в принципе нет. Например, константное "
"подвыражение <literal>1/0</literal> обычно вызывает ошибку деления на ноль "
"на этапе планирования, хотя эта ветвь <token>CASE</token> может вовсе не "
"вычисляться во время выполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12320(literal)
msgctxt "literal"
msgid "COALESCE"
msgstr "COALESCE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12322(indexterm)
msgid "<primary>COALESCE</primary>"
msgstr "<primary>COALESCE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12326(indexterm)
msgid "<primary>NVL</primary>"
msgstr "<primary>NVL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12330(indexterm)
msgid "<primary>IFNULL</primary>"
msgstr "<primary>IFNULL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12335(function)
msgctxt "function"
msgid "COALESCE"
msgstr "COALESCE"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12334(synopsis) func.xml:12399(synopsis) func.xml:12402(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12343(programlisting)
#, no-wrap
msgid "SELECT COALESCE(description, short_description, '(none)') ..."
msgstr "SELECT COALESCE(description, short_description, '(none)') ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12338(para)
msgid ""
"The <function>COALESCE</function> function returns the first of its "
"arguments that is not null. Null is returned only if all arguments are null. "
"It is often used to substitute a default value for null values when data is "
"retrieved for display, for example: <placeholder-1/> This returns "
"<varname>description</varname> if it is not null, otherwise "
"<varname>short_description</varname> if it is not null, otherwise "
"<literal>(none)</literal>."
msgstr ""
"Функция <function>COALESCE</function> возвращает первый попавшийся аргумент, "
"отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет "
"NULL. Это часто используется при отображении данных для подстановки "
"некоторого значения по умолчанию вместо значений NULL: <placeholder-1/> Этот "
"запрос вернёт значение <varname>description</varname>, если оно не равно "
"NULL, либо <varname>short_description</varname>, если оно не NULL, и строку "
"<literal>(none)</literal>, если оба эти значения равны NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12350(para)
msgid ""
"Like a <token>CASE</token> expression, <function>COALESCE</function> only "
"evaluates the arguments that are needed to determine the result; that is, "
"arguments to the right of the first non-null argument are not evaluated. "
"This SQL-standard function provides capabilities similar to <function>NVL</"
"function> and <function>IFNULL</function>, which are used in some other "
"database systems."
msgstr ""
"Как и выражение <token>CASE</token>, <function>COALESCE</function> вычисляет "
"только те аргументы, которые необходимы для получения результата; то есть, "
"аргументы правее первого отличного от NULL аргумента не вычисляются. Эта "
"функция соответствует стандарту SQL, а в некоторых других СУБД её аналоги "
"называются <function>NVL</function> и <function>IFNULL</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12361(literal)
msgctxt "literal"
msgid "NULLIF"
msgstr "NULLIF"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12363(indexterm)
msgid "<primary>NULLIF</primary>"
msgstr "<primary>NULLIF</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12368(function)
msgctxt "function"
msgid "NULLIF"
msgstr "NULLIF"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12368(replaceable)
msgid "value1"
msgstr "значение1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12368(replaceable)
msgid "value2"
msgstr "значение2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12367(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12377(programlisting)
#, no-wrap
msgid "SELECT NULLIF(value, '(none)') ..."
msgstr "SELECT NULLIF(value, '(none)') ..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12371(para)
msgid ""
"The <function>NULLIF</function> function returns a null value if "
"<replaceable>value1</replaceable> equals <replaceable>value2</replaceable>; "
"otherwise it returns <replaceable>value1</replaceable>. This can be used to "
"perform the inverse operation of the <function>COALESCE</function> example "
"given above: <placeholder-1/>"
msgstr ""
"Функция <function>NULLIF</function> возвращает значение NULL, если "
"<replaceable>значение1</replaceable> равно <replaceable>значение2</"
"replaceable>; в противном случае она возвращает <replaceable>значение1</"
"replaceable>. Это может быть полезно для реализации обратной операции к "
"<function>COALESCE</function>. В частности, для примера, показанного выше: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12381(para)
msgid ""
"In this example, if <literal>value</literal> is <literal>(none)</literal>, "
"null is returned, otherwise the value of <literal>value</literal> is "
"returned."
msgstr ""
"Если аргумент <literal>value</literal> равен <literal>(none)</literal>, "
"результатом выражения будет NULL, а в противном случае &mdash; значение "
"аргумента <literal>value</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12390(title)
msgid "<literal>GREATEST</literal> and <literal>LEAST</literal>"
msgstr "<literal>GREATEST</literal> и <literal>LEAST</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12392(indexterm)
msgid "<primary>GREATEST</primary>"
msgstr "<primary>GREATEST</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12395(indexterm)
msgid "<primary>LEAST</primary>"
msgstr "<primary>LEAST</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12400(function)
msgid "GREATEST"
msgstr "GREATEST"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12403(function)
msgid "LEAST"
msgstr "LEAST"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12406(para)
msgid ""
"The <function>GREATEST</function> and <function>LEAST</function> functions "
"select the largest or smallest value from a list of any number of "
"expressions. The expressions must all be convertible to a common data type, "
"which will be the type of the result (see <xref linkend=\"typeconv-union-case"
"\"/> for details). NULL values in the list are ignored. The result will be "
"NULL only if all the expressions evaluate to NULL."
msgstr ""
"Функции <function>GREATEST</function> и <function>LEAST</function> выбирают "
"наибольшее или наименьшее значение из списка выражений. Все эти выражения "
"должны приводиться к общему типу данных, который станет типом результата "
"(подробнее об этом в <xref remap=\"6\" linkend=\"typeconv-union-case\"/>). "
"Значения NULL в этом списке игнорируются, так что результат выражения будет "
"равен NULL, только если все его аргументы равны NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12416(para)
msgid ""
"Note that <function>GREATEST</function> and <function>LEAST</function> are "
"not in the SQL standard, but are a common extension. Some other databases "
"make them return NULL if any argument is NULL, rather than only when all are "
"NULL."
msgstr ""
"Заметьте, что функции <function>GREATEST</function> и <function>LEAST</"
"function> не описаны в стандарте SQL, но часто реализуются в СУБД как "
"расширения. В некоторых других СУБД они могут возвращать NULL, когда не все, "
"а любой из аргументов равен NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12426(title)
msgid "Array Functions and Operators"
msgstr "Функции и операторы для работы с массивами"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12428(para)
msgid ""
"<xref linkend=\"array-operators-table\"/> shows the operators available for "
"array types."
msgstr ""
"В <xref remap=\"6\" linkend=\"array-operators-table\"/> показаны операторы, "
"предназначенные для работы с массивами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12434(title)
msgid "Array Operators"
msgstr "Операторы для работы с массивами"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12448(literal)
msgid "ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]"
msgstr "ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12455(literal)
msgid "ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]"
msgstr "ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12462(literal)
msgid "ARRAY[1,2,3] &lt; ARRAY[1,2,4]"
msgstr "ARRAY[1,2,3] &lt; ARRAY[1,2,4]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12469(literal)
msgid "ARRAY[1,4,3] &gt; ARRAY[1,2,4]"
msgstr "ARRAY[1,4,3] &gt; ARRAY[1,2,4]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12475(entry) func.xml:12950(entry)
msgid "less than or equal"
msgstr "меньше или равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12476(literal)
msgid "ARRAY[1,2,3] &lt;= ARRAY[1,2,3]"
msgstr "ARRAY[1,2,3] &lt;= ARRAY[1,2,3]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12482(entry) func.xml:12957(entry)
msgid "greater than or equal"
msgstr "больше или равно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12483(literal)
msgid "ARRAY[1,4,3] &gt;= ARRAY[1,4,3]"
msgstr "ARRAY[1,4,3] &gt;= ARRAY[1,4,3]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12490(literal)
msgid "ARRAY[1,4,3] @&gt; ARRAY[3,1]"
msgstr "ARRAY[1,4,3] @&gt; ARRAY[3,1]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12497(literal)
msgid "ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]"
msgstr "ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12503(entry)
msgid "overlap (have elements in common)"
msgstr "пересечение (есть общие элементы)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12504(literal)
msgid "ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]"
msgstr "ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12510(entry) func.xml:12517(entry)
msgid "array-to-array concatenation"
msgstr "соединение массива с массивом"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12511(literal)
msgid "ARRAY[1,2,3] || ARRAY[4,5,6]"
msgstr "ARRAY[1,2,3] || ARRAY[4,5,6]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12512(literal)
msgid "{1,2,3,4,5,6}"
msgstr "{1,2,3,4,5,6}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12518(literal)
msgid "ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]"
msgstr "ARRAY[1,2,3] || ARRAY[[4,5,6], [7,8,9]]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12519(literal)
msgid "{{1,2,3},{4,5,6},{7,8,9}}"
msgstr "{{1,2,3},{4,5,6},{7,8,9}}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12524(entry)
msgid "element-to-array concatenation"
msgstr "соединение элемента с массивом"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12525(literal)
msgid "3 || ARRAY[4,5,6]"
msgstr "3 || ARRAY[4,5,6]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12526(literal)
msgid "{3,4,5,6}"
msgstr "{3,4,5,6}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12531(entry)
msgid "array-to-element concatenation"
msgstr "соединение массива с элементом"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12532(literal)
msgid "ARRAY[4,5,6] || 7"
msgstr "ARRAY[4,5,6] || 7"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12533(literal)
msgid "{4,5,6,7}"
msgstr "{4,5,6,7}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12539(para)
msgid ""
"Array comparisons compare the array contents element-by-element, using the "
"default B-tree comparison function for the element data type. In "
"multidimensional arrays the elements are visited in row-major order (last "
"subscript varies most rapidly). If the contents of two arrays are equal but "
"the dimensionality is different, the first difference in the dimensionality "
"information determines the sort order. (This is a change from versions of "
"<productname>PostgreSQL</productname> prior to 8.2: older versions would "
"claim that two arrays with the same contents were equal, even if the number "
"of dimensions or subscript ranges were different.)"
msgstr ""
"Операторы сравнения массивов сравнивают содержимое массивов по элементам, "
"используя при этом функцию сравнения для B-дерева, определённую для типа "
"данного элемента по умолчанию. В многомерных массивах элементы "
"просматриваются по строкам (индекс последней размерности меняется в первую "
"очередь). Если содержимое двух массивов совпадает, а размерности "
"различаются, результат их сравнения будет определяться первым отличием в "
"размерностях. (В <productname>PostgreSQL</productname> до версии 8.2 "
"поведение было другим: два массива с одинаковым содержимом считались "
"одинаковыми, даже если число их размерностей и границы индексов различались.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12552(para)
msgid ""
"See <xref linkend=\"arrays\"/> for more details about array operator "
"behavior. See <xref linkend=\"indexes-types\"/> for more details about which "
"operators support indexed operations."
msgstr ""
"Подробнее поведение операторов с массивами описано в <xref remap=\"6\" "
"linkend=\"arrays\"/>. За дополнительными сведениями об операторах, "
"поддерживающих индексы, обратитесь к <xref remap=\"3\" linkend=\"indexes-"
"types\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12558(para)
msgid ""
"<xref linkend=\"array-functions-table\"/> shows the functions available for "
"use with array types. See <xref linkend=\"arrays\"/> for more information "
"and examples of the use of these functions."
msgstr ""
"В <xref remap=\"6\" linkend=\"array-functions-table\"/> перечислены функции, "
"предназначенные для работы с массивами. Дополнительная информация о них и "
"примеры использования приведены в <xref remap=\"6\" linkend=\"arrays\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12564(indexterm)
msgid "<primary>array_append</primary>"
msgstr "<primary>array_append</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12567(indexterm)
msgid "<primary>array_cat</primary>"
msgstr "<primary>array_cat</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12570(indexterm)
msgid "<primary>array_ndims</primary>"
msgstr "<primary>array_ndims</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12573(indexterm)
msgid "<primary>array_dims</primary>"
msgstr "<primary>array_dims</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12576(indexterm)
msgid "<primary>array_fill</primary>"
msgstr "<primary>array_fill</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12579(indexterm)
msgid "<primary>array_length</primary>"
msgstr "<primary>array_length</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12582(indexterm)
msgid "<primary>array_lower</primary>"
msgstr "<primary>array_lower</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12585(indexterm)
msgid "<primary>array_position</primary>"
msgstr "<primary>array_position</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12588(indexterm)
msgid "<primary>array_positions</primary>"
msgstr "<primary>array_positions</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12591(indexterm)
msgid "<primary>array_prepend</primary>"
msgstr "<primary>array_prepend</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12594(indexterm)
msgid "<primary>array_remove</primary>"
msgstr "<primary>array_remove</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12597(indexterm)
msgid "<primary>array_replace</primary>"
msgstr "<primary>array_replace</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12600(indexterm)
msgid "<primary>array_to_string</primary>"
msgstr "<primary>array_to_string</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12603(indexterm)
msgid "<primary>array_upper</primary>"
msgstr "<primary>array_upper</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12606(indexterm)
msgid "<primary>cardinality</primary>"
msgstr "<primary>cardinality</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12609(indexterm)
msgid "<primary>string_to_array</primary>"
msgstr "<primary>string_to_array</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12612(indexterm)
msgid "<primary>unnest</primary>"
msgstr "<primary>unnest</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12617(title)
msgid "Array Functions"
msgstr "Функции для работы с массивами"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12632(function)
msgid "array_append"
msgstr "array_append"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12636(entry)
msgid "append an element to the end of an array"
msgstr "добавляет элемент в конец массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12637(literal)
msgid "array_append(ARRAY[1,2], 3)"
msgstr "array_append(ARRAY[1,2], 3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12638(literal) func.xml:12743(literal)
msgid "{1,2,3}"
msgstr "{1,2,3}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12643(function)
msgid "array_cat"
msgstr "array_cat"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12647(entry)
msgid "concatenate two arrays"
msgstr "соединяет два массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12648(literal)
msgid "array_cat(ARRAY[1,2,3], ARRAY[4,5])"
msgstr "array_cat(ARRAY[1,2,3], ARRAY[4,5])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12649(literal)
msgid "{1,2,3,4,5}"
msgstr "{1,2,3,4,5}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12654(function)
msgid "array_ndims"
msgstr "array_ndims"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12653(literal) func.xml:12664(literal) func.xml:12793(literal)
#: func.xml:12816(literal) func.xml:13120(literal) func.xml:13131(literal)
#: func.xml:13142(literal) func.xml:13153(literal) func.xml:13164(literal)
#: func.xml:13175(literal) func.xml:13186(literal) func.xml:16417(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>)"
msgstr "<placeholder-1/>(<placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12658(entry)
msgid "returns the number of dimensions of the array"
msgstr "возвращает число размерностей массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12659(literal)
msgid "array_ndims(ARRAY[[1,2,3], [4,5,6]])"
msgstr "array_ndims(ARRAY[[1,2,3], [4,5,6]])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12665(function)
msgid "array_dims"
msgstr "array_dims"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12669(entry)
msgid "returns a text representation of array's dimensions"
msgstr "возвращает текстовое представление размерностей массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12670(literal)
msgid "array_dims(ARRAY[[1,2,3], [4,5,6]])"
msgstr "array_dims(ARRAY[[1,2,3], [4,5,6]])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12671(literal)
msgid "[1:2][1:3]"
msgstr "[1:2][1:3]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12676(function)
msgid "array_fill"
msgstr "array_fill"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12676(type) func.xml:12677(type) func.xml:12727(type)
#: func.xml:15827(type) func.xml:15876(type)
msgid "int[]"
msgstr "int[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12675(literal) func.xml:12759(literal) func.xml:16220(literal)
#: func.xml:16244(literal) func.xml:16252(literal) func.xml:16267(literal)
#: func.xml:16282(literal) func.xml:16297(literal) func.xml:16312(literal)
#: func.xml:16327(literal) func.xml:16342(literal) func.xml:16357(literal)
#: func.xml:16372(literal) func.xml:16387(literal) func.xml:16402(literal)
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12681(entry)
msgid ""
"returns an array initialized with supplied value and dimensions, optionally "
"with lower bounds other than 1"
msgstr ""
"возвращает массив, заполненный заданным значением и имеющий указанные "
"размерности, в которых нижняя граница может быть отлична от 1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12683(literal)
msgid "array_fill(7, ARRAY[3], ARRAY[2])"
msgstr "array_fill(7, ARRAY[3], ARRAY[2])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12684(literal)
msgid "[2:4]={7,7,7}"
msgstr "[2:4]={7,7,7}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12689(function)
msgid "array_length"
msgstr "array_length"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12693(entry)
msgid "returns the length of the requested array dimension"
msgstr "возвращает длину указанной размерности массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12694(literal)
msgid "array_length(array[1,2,3], 1)"
msgstr "array_length(array[1,2,3], 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12700(function)
msgid "array_lower"
msgstr "array_lower"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12704(entry)
msgid "returns lower bound of the requested array dimension"
msgstr "возвращает нижнюю границу указанной размерности массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12705(literal)
msgid "array_lower('[0:2]={1,2,3}'::int[], 1)"
msgstr "array_lower('[0:2]=&zwsp;{1,2,3}'::int[], 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12711(function)
msgid "array_position"
msgstr "array_position"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12710(literal) func.xml:12770(literal) func.xml:12804(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12715(entry)
msgid ""
"returns the subscript of the first occurrence of the second argument in the "
"array, starting at the element indicated by the third argument or at the "
"first element (array must be one-dimensional)"
msgstr ""
"возвращает позицию первого вхождения второго аргумента в массиве, начиная с "
"элемента, выбираемого третьим аргументом, либо с первого элемента (массив "
"должен быть одномерным)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12718(literal)
msgid "array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')"
msgstr ""
"array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12724(function)
msgid "array_positions"
msgstr "array_positions"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12728(entry)
msgid ""
"returns an array of subscripts of all occurrences of the second argument in "
"the array given as first argument (array must be one-dimensional)"
msgstr ""
"возвращает массив с позициями всех вхождений второго аргумента в массиве, "
"задаваемым первым аргументом (массив должен быть одномерным)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12731(literal)
msgid "array_positions(ARRAY['A','A','B','A'], 'A')"
msgstr "array_positions(ARRAY['A','A','B','A'], 'A')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12732(literal)
msgid "{1,2,4}"
msgstr "{1,2,4}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12737(function)
msgid "array_prepend"
msgstr "array_prepend"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12741(entry)
msgid "append an element to the beginning of an array"
msgstr "вставляет элемент в начало массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12742(literal)
msgid "array_prepend(1, ARRAY[2,3])"
msgstr "array_prepend(1, ARRAY[2,3])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12748(function)
msgid "array_remove"
msgstr "array_remove"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12752(entry)
msgid ""
"remove all elements equal to the given value from the array (array must be "
"one-dimensional)"
msgstr ""
"удаляет из массива все элементы, равные заданному значению (массив должен "
"быть одномерным)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12754(literal)
msgid "array_remove(ARRAY[1,2,3,2], 2)"
msgstr "array_remove(ARRAY[1,2,3,2], 2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12755(literal)
msgid "{1,3}"
msgstr "{1,3}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12760(function)
msgid "array_replace"
msgstr "array_replace"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12764(entry)
msgid "replace each array element equal to the given value with a new value"
msgstr ""
"заменяет в массиве все элементы, равные заданному значению, другим значением"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12765(literal)
msgid "array_replace(ARRAY[1,2,5,4], 5, 3)"
msgstr "array_replace(ARRAY[1,2,5,4], 5, 3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12766(literal)
msgid "{1,2,3,4}"
msgstr "{1,2,3,4}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12771(function)
msgid "array_to_string"
msgstr "array_to_string"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12775(entry)
msgid ""
"concatenates array elements using supplied delimiter and optional null string"
msgstr ""
"выводит элементы массива через заданный разделитель и позволяет определить "
"замену для значения NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12777(literal)
msgid "array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')"
msgstr "array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12778(literal)
msgid "1,2,3,*,5"
msgstr "1,2,3,*,5"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12783(function)
msgid "array_upper"
msgstr "array_upper"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12787(entry)
msgid "returns upper bound of the requested array dimension"
msgstr "возвращает верхнюю границу указанной размерности массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12788(literal)
msgid "array_upper(ARRAY[1,8,3,7], 1)"
msgstr "array_upper(ARRAY[1,8,3,7], 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12794(function)
msgid "cardinality"
msgstr "cardinality"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12798(entry)
msgid ""
"returns the total number of elements in the array, or 0 if the array is empty"
msgstr "возвращает общее число элементов в массиве, либо 0, если массив пуст"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12799(literal)
msgid "cardinality(ARRAY[[1,2],[3,4]])"
msgstr "cardinality(ARRAY[[1,2],[3,4]])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12805(function)
msgid "string_to_array"
msgstr "string_to_array"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12809(entry)
msgid ""
"splits string into array elements using supplied delimiter and optional null "
"string"
msgstr ""
"разбивает строку на элементы массива, используя заданный разделитель и, "
"возможно, замену для значений NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12811(literal)
msgid "string_to_array('xx~^~yy~^~zz', '~^~', 'yy')"
msgstr "string_to_array('xx~^~yy~&zwsp;^~zz', '~^~', 'yy')"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12812(literal)
msgid "{xx,NULL,zz}"
msgstr "{xx,NULL,zz}"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12817(function) func.xml:12829(function)
msgid "unnest"
msgstr "unnest"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12821(entry)
msgid "expand an array to a set of rows"
msgstr "разворачивает массив в набор строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12822(literal)
msgid "unnest(ARRAY[1,2])"
msgstr "unnest(ARRAY[1,2])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12823(entry)
msgid ""
"<literallayout class=\"monospaced\">1\n"
"2</literallayout>(2 rows)"
msgstr ""
"<literallayout class=\"monospaced\">1\n"
"2</literallayout>(2 строки)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12828(literal)
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> [, ...])"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> [, ...])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12832(type)
msgid "setof anyelement, anyelement [, ...]"
msgstr "setof anyelement, anyelement [, ...]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12833(entry)
msgid ""
"expand multiple arrays (possibly of different types) to a set of rows. This "
"is only allowed in the FROM clause; see <xref linkend=\"queries-"
"tablefunctions\"/>"
msgstr ""
"разворачивает массивы (возможно разных типов) в набор строк. Это допускается "
"только в предложении FROM; см. <xref remap=\"4\" linkend=\"queries-"
"tablefunctions\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12836(literal)
msgid "unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])"
msgstr "unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12837(entry)
msgid ""
"<literallayout class=\"monospaced\">1    foo\n"
"2    bar\n"
"NULL baz</literallayout>(3 rows)"
msgstr ""
"<literallayout class=\"monospaced\">1    foo\n"
"2    bar\n"
"NULL baz</literallayout>(3 строки)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12845(para)
msgid ""
"In <function>array_position</function> and <function>array_positions</"
"function>, each array element is compared to the searched value using "
"<literal>IS NOT DISTINCT FROM</literal> semantics."
msgstr ""
"В функциях <function>array_position</function> и <function>array_positions</"
"function> каждый элемент массива сравнивается с искомым значением по "
"принципу <literal>IS NOT DISTINCT FROM</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12851(para)
msgid ""
"In <function>array_position</function>, <literal>NULL</literal> is returned "
"if the value is not found."
msgstr ""
"Функция <function>array_position</function> возвращает <literal>NULL</"
"literal>, если искомое значение не находится."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12856(para)
msgid ""
"In <function>array_positions</function>, <literal>NULL</literal> is returned "
"only if the array is <literal>NULL</literal>; if the value is not found in "
"the array, an empty array is returned instead."
msgstr ""
"Функция <function>array_positions</function> возвращает <literal>NULL</"
"literal>, только если в качестве массива передаётся <literal>NULL</literal>; "
"если же в массиве не находится значение, она возвращает пустой массив."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12862(para)
msgid ""
"In <function>string_to_array</function>, if the delimiter parameter is NULL, "
"each character in the input string will become a separate element in the "
"resulting array. If the delimiter is an empty string, then the entire input "
"string is returned as a one-element array. Otherwise the input string is "
"split at each occurrence of the delimiter string."
msgstr ""
"Если для функции <function>string_to_array</function> в качестве разделителя "
"задан NULL, каждый символ входной строки станет отдельным элементов в "
"полученном массиве. Если разделитель пустая строка, строка будет возвращена "
"целиком в массиве из одного элемента. В противном случае входная строка "
"разбивается по вхождениям подстроки, указанной в качестве разделителя."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12870(para)
msgid ""
"In <function>string_to_array</function>, if the null-string parameter is "
"omitted or NULL, none of the substrings of the input will be replaced by "
"NULL. In <function>array_to_string</function>, if the null-string parameter "
"is omitted or NULL, any null elements in the array are simply skipped and "
"not represented in the output string."
msgstr ""
"Если для функции <function>string_to_array</function> параметр замены "
"значения NULL опущен или равен NULL, никакие подстроки во входных данных не "
"будут заменяться на NULL. Если же параметр замены NULL опущен или равен NULL "
"для функции <function>array_to_string</function>, все значения NULL просто "
"пропускаются и никак не представляются в выходной строке."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12880(para)
msgid ""
"There are two differences in the behavior of <function>string_to_array</"
"function> from pre-9.1 versions of <productname>PostgreSQL</productname>. "
"First, it will return an empty (zero-element) array rather than NULL when "
"the input string is of zero length. Second, if the delimiter string is NULL, "
"the function splits the input into individual characters, rather than "
"returning NULL as before."
msgstr ""
"В поведении <function>string_to_array</function> по сравнению с "
"<productname>PostgreSQL</productname> версий до 9.1 произошли два изменения. "
"Во-первых, эта функция возвращает пустой массив (содержащий 0 элементов), а "
"не NULL, когда входная строка имеет нулевую длину. Во-вторых, если в "
"качестве разделителя задан NULL, эта функция разбивает строку по символам, а "
"не просто возвращает NULL, как было раньше."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12890(para)
msgid ""
"See also <xref linkend=\"functions-aggregate\"/> about the aggregate "
"function <function>array_agg</function> for use with arrays."
msgstr ""
"Вы также можете узнать об агрегатной функции, работающей с массивами, "
"<function>array_agg</function> в <xref remap=\"6\" linkend=\"functions-"
"aggregate\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12897(title)
msgid "Range Functions and Operators"
msgstr "Диапазонные функции и операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12899(para)
msgid "See <xref linkend=\"rangetypes\"/> for an overview of range types."
msgstr ""
"Диапазонные типы данных рассматриваются в <xref remap=\"6\" linkend="
"\"rangetypes\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12903(para)
msgid ""
"<xref linkend=\"range-operators-table\"/> shows the operators available for "
"range types."
msgstr ""
"В <xref remap=\"6\" linkend=\"range-operators-table\"/> показаны операторы, "
"предназначенные для работы с диапазонами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12909(title)
msgid "Range Operators"
msgstr "Диапазонные операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12923(literal)
msgid "int4range(1,5) = '[1,4]'::int4range"
msgstr "int4range(1,5) = '[1,4]'::int4range"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12930(literal)
msgid "numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)"
msgstr "numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12937(literal)
msgid "int4range(1,10) &lt; int4range(2,3)"
msgstr "int4range(1,10) &lt; int4range(2,3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12944(literal)
msgid "int4range(1,10) &gt; int4range(1,5)"
msgstr "int4range(1,10) &gt; int4range(1,5)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12951(literal)
msgid "numrange(1.1,2.2) &lt;= numrange(1.1,2.2)"
msgstr "numrange(1.1,2.2) &lt;= numrange(1.1,2.2)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12958(literal)
msgid "numrange(1.1,2.2) &gt;= numrange(1.1,2.0)"
msgstr "numrange(1.1,2.2) &gt;= numrange(1.1,2.0)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12964(entry)
msgid "contains range"
msgstr "содержит диапазон"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12965(literal)
msgid "int4range(2,4) @&gt; int4range(2,3)"
msgstr "int4range(2,4) @&gt; int4range(2,3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12971(entry)
msgid "contains element"
msgstr "содержит элемент"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12972(literal)
msgid "'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp"
msgstr "'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12978(entry)
msgid "range is contained by"
msgstr "диапазон содержится в"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12979(literal)
msgid "int4range(2,4) &lt;@ int4range(1,7)"
msgstr "int4range(2,4) &lt;@ int4range(1,7)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12985(entry)
msgid "element is contained by"
msgstr "элемент содержится в"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12986(literal)
msgid "42 &lt;@ int4range(1,7)"
msgstr "42 &lt;@ int4range(1,7)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12992(entry)
msgid "overlap (have points in common)"
msgstr "пересекает (есть общие точки)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12993(literal)
msgid "int8range(3,7) &amp;&amp; int8range(4,12)"
msgstr "int8range(3,7) &amp;&amp; int8range(4,12)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:12999(entry)
msgid "strictly left of"
msgstr "строго слева от"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13000(literal)
msgid "int8range(1,10) &lt;&lt; int8range(100,110)"
msgstr "int8range(1,10) &lt;&lt; int8range(100,110)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13006(entry)
msgid "strictly right of"
msgstr "строго справа от"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13007(literal)
msgid "int8range(50,60) &gt;&gt; int8range(20,30)"
msgstr "int8range(50,60) &gt;&gt; int8range(20,30)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13013(entry)
msgid "does not extend to the right of"
msgstr "не простирается правее"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13014(literal)
msgid "int8range(1,20) &amp;&lt; int8range(18,20)"
msgstr "int8range(1,20) &amp;&lt; int8range(18,20)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13020(entry)
msgid "does not extend to the left of"
msgstr "не простирается левее"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13021(literal)
msgid "int8range(7,20) &amp;&gt; int8range(5,10)"
msgstr "int8range(7,20) &amp;&gt; int8range(5,10)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13026(literal)
msgid "-|-"
msgstr "-|-"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13027(entry)
msgid "is adjacent to"
msgstr "примыкает к"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13028(literal)
msgid "numrange(1.1,2.2) -|- numrange(2.2,3.3)"
msgstr "numrange(1.1,2.2) -|- numrange(2.2,3.3)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13034(entry)
msgid "union"
msgstr "union"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13035(literal)
msgid "numrange(5,15) + numrange(10,20)"
msgstr "numrange(5,15) + numrange(10,20)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13036(literal)
msgid "[5,20)"
msgstr "[5,20)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13041(entry)
msgid "intersection"
msgstr "пересечение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13042(literal)
msgid "int8range(5,15) * int8range(10,20)"
msgstr "int8range(5,15) * int8range(10,20)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13043(literal)
msgid "[10,15)"
msgstr "[10,15)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13048(entry)
msgid "difference"
msgstr "вычитание"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13049(literal)
msgid "int8range(5,15) - int8range(10,20)"
msgstr "int8range(5,15) - int8range(10,20)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13050(literal)
msgid "[5,10)"
msgstr "[5,10)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13057(para)
msgid ""
"The simple comparison operators <literal>&lt;</literal>, <literal>&gt;</"
"literal>, <literal>&lt;=</literal>, and <literal>&gt;=</literal> compare the "
"lower bounds first, and only if those are equal, compare the upper bounds. "
"These comparisons are not usually very useful for ranges, but are provided "
"to allow B-tree indexes to be constructed on ranges."
msgstr ""
"Простые операторы сравнения <literal>&lt;</literal>, <literal>&gt;</"
"literal>, <literal>&lt;=</literal> и <literal>&gt;=</literal> сначала "
"сравнивают нижние границы, и только если они равны, сравнивают верхние. Эти "
"операторы сравнения обычно не очень полезны для диапазонов; основное их "
"предназначение &mdash; сделать возможным построение индексов-B-деревьев по "
"диапазонам."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13066(para)
msgid ""
"The left-of/right-of/adjacent operators always return false when an empty "
"range is involved; that is, an empty range is not considered to be either "
"before or after any other range."
msgstr ""
"Операторы слева/справа/примыкает всегда возвращают false, если один из "
"диапазонов пуст; то есть, считается, что пустой диапазон находится не слева "
"и не справа от какого-либо другого диапазона."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13072(para)
msgid ""
"The union and difference operators will fail if the resulting range would "
"need to contain two disjoint sub-ranges, as such a range cannot be "
"represented."
msgstr ""
"Операторы сложения и вычитания вызывают ошибку, если получающийся в "
"результате диапазон оказывается состоящим из двух разделённых поддиапазонов, "
"так как его нельзя представить в этом типе данных."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13078(para)
msgid ""
"<xref linkend=\"range-functions-table\"/> shows the functions available for "
"use with range types."
msgstr ""
"В <xref remap=\"6\" linkend=\"range-functions-table\"/> перечислены функции, "
"предназначенные для работы с диапазонными типами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13089(indexterm)
msgid "<primary>isempty</primary>"
msgstr "<primary>isempty</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13092(indexterm)
msgid "<primary>lower_inc</primary>"
msgstr "<primary>lower_inc</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13095(indexterm)
msgid "<primary>upper_inc</primary>"
msgstr "<primary>upper_inc</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13098(indexterm)
msgid "<primary>lower_inf</primary>"
msgstr "<primary>lower_inf</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13101(indexterm)
msgid "<primary>upper_inf</primary>"
msgstr "<primary>upper_inf</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13106(title)
msgid "Range Functions"
msgstr "Диапазонные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13121(function)
msgid "lower"
msgstr "lower"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13121(type) func.xml:13132(type) func.xml:13143(type)
#: func.xml:13154(type) func.xml:13165(type) func.xml:13176(type)
#: func.xml:13187(type) func.xml:13198(type) func.xml:13201(type)
msgid "anyrange"
msgstr "anyrange"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13124(entry) func.xml:13135(entry)
msgid "range's element type"
msgstr "тип элемента диапазона"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13125(entry)
msgid "lower bound of range"
msgstr "нижняя граница диапазона"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13126(literal)
msgid "lower(numrange(1.1,2.2))"
msgstr "lower(numrange(1.1, 2.2))"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13127(literal)
msgid "1.1"
msgstr "1.1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13132(function)
msgid "upper"
msgstr "upper"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13136(entry)
msgid "upper bound of range"
msgstr "верхняя граница диапазона"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13137(literal)
msgid "upper(numrange(1.1,2.2))"
msgstr "upper(numrange(1.1, 2.2))"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13138(literal)
msgid "2.2"
msgstr "2.2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13143(function)
msgid "isempty"
msgstr "isempty"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13147(entry)
msgid "is the range empty?"
msgstr "диапазон пуст?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13148(literal)
msgid "isempty(numrange(1.1,2.2))"
msgstr "isempty(numrange(1.1,2.2))"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13154(function)
msgid "lower_inc"
msgstr "lower_inc"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13158(entry)
msgid "is the lower bound inclusive?"
msgstr "нижняя граница включается?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13159(literal)
msgid "lower_inc(numrange(1.1,2.2))"
msgstr "lower_inc(numrange(1.1, 2.2))"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13165(function)
msgid "upper_inc"
msgstr "upper_inc"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13169(entry)
msgid "is the upper bound inclusive?"
msgstr "верхняя граница включается?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13170(literal)
msgid "upper_inc(numrange(1.1,2.2))"
msgstr "upper_inc(numrange(1.1, 2.2))"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13176(function)
msgid "lower_inf"
msgstr "lower_inf"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13180(entry)
msgid "is the lower bound infinite?"
msgstr "нижняя граница равна бесконечности?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13181(literal)
msgid "lower_inf('(,)'::daterange)"
msgstr "lower_inf('(,)'::daterange)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13187(function)
msgid "upper_inf"
msgstr "upper_inf"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13191(entry)
msgid "is the upper bound infinite?"
msgstr "верхняя граница равна бесконечности?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13192(literal)
msgid "upper_inf('(,)'::daterange)"
msgstr "upper_inf('(,)'::daterange)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13198(function)
msgid "range_merge"
msgstr "range_merge"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13202(entry)
msgid "the smallest range which includes both of the given ranges"
msgstr "наименьший диапазон, включающий оба заданных диапазона"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13203(literal)
msgid "range_merge('[1,2)'::int4range, '[3,4)'::int4range)"
msgstr "range_merge('[1,2)'::int4range, '[3,4)'::int4range)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13204(literal)
msgid "[1,4)"
msgstr "[1,4)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13210(para)
msgid ""
"The <function>lower</function> and <function>upper</function> functions "
"return null if the range is empty or the requested bound is infinite. The "
"<function>lower_inc</function>, <function>upper_inc</function>, "
"<function>lower_inf</function>, and <function>upper_inf</function> functions "
"all return false for an empty range."
msgstr ""
"Функции <function>lower</function> и <function>upper</function> возвращают "
"NULL, если диапазон пуст или указанная граница равна бесконечности. Если же "
"пустой диапазон передаётся функциям <function>lower_inc</function>, "
"<function>upper_inc</function>, <function>lower_inf</function> и "
"<function>upper_inf</function>, все они возвращают false."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13220(title)
msgid "Aggregate Functions"
msgstr "Агрегатные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13222(indexterm)
msgid "<primary>aggregate function</primary> <secondary>built-in</secondary>"
msgstr ""
"<primary>агрегатные функции</primary> <secondary>встроенные</secondary>"

#. +> REL_10
#: func.xml:13227(para)
msgid ""
"<firstterm>Aggregate functions</firstterm> compute a single result from a "
"set of input values. The built-in general-purpose aggregate functions are "
"listed in <xref linkend=\"functions-aggregate-table\"/> and statistical "
"aggregates in <xref linkend=\"functions-aggregate-statistics-table\"/>. The "
"built-in within-group ordered-set aggregate functions are listed in <xref "
"linkend=\"functions-orderedset-table\"/> while the built-in within-group "
"hypothetical-set ones are in <xref linkend=\"functions-hypothetical-table\"/"
">. Grouping operations, which are closely related to aggregate functions, "
"are listed in <xref linkend=\"functions-grouping-table\"/>. The special "
"syntax considerations for aggregate functions are explained in <xref linkend="
"\"syntax-aggregates\"/>. Consult <xref linkend=\"tutorial-agg\"/> for "
"additional introductory information."
msgstr ""
"<firstterm>Агрегатные функции</firstterm> получают единственный результат из "
"набора входных значений. Встроенные агрегатные функции общего назначения "
"перечислены в <xref remap=\"6\" linkend=\"functions-aggregate-table\"/>, а "
"статистические агрегатные функции — в <xref remap=\"6\" linkend=\"functions-"
"aggregate-statistics-table\"/>. Встроенные внутригрупповые сортирующие "
"агрегатные функции перечислены в <xref remap=\"6\" linkend=\"functions-"
"orderedset-table\"/>, встроенные внутригрупповые гипотезирующие — в <xref "
"remap=\"6\" linkend=\"functions-hypothetical-table\"/>. Группирующие "
"операторы, тесно связанные с агрегатными функциями, перечислены в <xref "
"remap=\"6\" linkend=\"functions-grouping-table\"/>. Особенности синтаксиса "
"агрегатных функцией разъясняются в <xref remap=\"6\" linkend=\"syntax-"
"aggregates\"/>. За дополнительной вводной информацией обратитесь к <xref "
"remap=\"3\" linkend=\"tutorial-agg\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13246(title)
msgid "General-Purpose Aggregate Functions"
msgstr "Агрегатные функции общего назначения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13252(entry)
msgid "Argument Type(s)"
msgstr "Типы аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13254(entry) func.xml:13701(entry) func.xml:14118(entry)
#: func.xml:14277(entry)
msgid "Partial Mode"
msgstr "Частичный режим"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13262(indexterm)
msgid "<primary>array_agg</primary>"
msgstr "<primary>array_agg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13265(function) func.xml:13279(function)
msgid "array_agg(<placeholder-1/>)"
msgstr "array_agg(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13267(entry)
msgid "any non-array type"
msgstr "любой тип не массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13270(entry)
msgid "array of the argument type"
msgstr "массив элементов с типом аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13273(entry) func.xml:13287(entry) func.xml:13441(entry)
#: func.xml:13458(entry) func.xml:13475(entry) func.xml:13492(entry)
#: func.xml:13548(entry) func.xml:13588(entry) func.xml:14141(entry)
#: func.xml:14165(entry) func.xml:14186(entry) func.xml:14211(entry)
#: func.xml:14231(entry) func.xml:14301(entry) func.xml:14324(entry)
#: func.xml:14347(entry) func.xml:14370(entry)
msgid "No"
msgstr "Нет"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13274(entry)
msgid "input values, including nulls, concatenated into an array"
msgstr "входные значения, включая NULL, объединяются в массив"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13281(entry)
msgid "any array type"
msgstr "любой тип массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13284(entry) func.xml:13328(entry) func.xml:13346(entry)
msgid "same as argument data type"
msgstr "тот же, что и тип аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13288(entry)
msgid ""
"input arrays concatenated into array of one higher dimension (inputs must "
"all have same dimensionality, and cannot be empty or NULL)"
msgstr ""
"входные массивы собираются в массив большей размерности (они должны иметь "
"одну размерность и не могут быть пустыми или равны NULL)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13295(indexterm)
msgid "<primary>average</primary>"
msgstr "<primary>среднее</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13298(indexterm)
msgid "<primary>avg</primary>"
msgstr "<primary>avg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13301(function)
msgid "avg(<placeholder-1/>)"
msgstr "avg(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13303(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, or "
"<type>interval</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type> или "
"<type>interval</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13308(entry)
msgid ""
"<type>numeric</type> for any integer-type argument, <type>double precision</"
"type> for a floating-point argument, otherwise the same as the argument data "
"type"
msgstr ""
"<type>numeric</type> для любых целочисленных аргументов, <type>double "
"precision</type> для аргументов с плавающей точкой, в противном случае тип "
"данных аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13313(entry) func.xml:13331(entry) func.xml:13349(entry)
#: func.xml:13366(entry) func.xml:13383(entry) func.xml:13396(entry)
#: func.xml:13404(entry) func.xml:13424(entry) func.xml:13506(entry)
#: func.xml:13524(entry) func.xml:13571(entry) func.xml:13724(entry)
#: func.xml:13745(entry) func.xml:13766(entry) func.xml:13783(entry)
#: func.xml:13801(entry) func.xml:13819(entry) func.xml:13839(entry)
#: func.xml:13859(entry) func.xml:13879(entry) func.xml:13898(entry)
#: func.xml:13919(entry) func.xml:13943(entry) func.xml:13970(entry)
#: func.xml:13994(entry) func.xml:14018(entry) func.xml:14038(entry)
#: func.xml:14062(entry) func.xml:14086(entry)
msgid "Yes"
msgstr "Да"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13314(entry)
msgid "the average (arithmetic mean) of all input values"
msgstr "арифметическое среднее для всех входных значений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13319(indexterm)
msgid "<primary>bit_and</primary>"
msgstr "<primary>bit_and</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13322(function)
msgid "bit_and(<placeholder-1/>)"
msgstr "bit_and(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13324(entry) func.xml:13342(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, or <type>bit</"
"type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type> или <type>bit</"
"type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13332(entry)
msgid "the bitwise AND of all non-null input values, or null if none"
msgstr ""
"побитовое И для всех входных значений, не равных NULL, или NULL, если таких "
"нет"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13337(indexterm)
msgid "<primary>bit_or</primary>"
msgstr "<primary>bit_or</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13340(function)
msgid "bit_or(<placeholder-1/>)"
msgstr "bit_or(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13350(entry)
msgid "the bitwise OR of all non-null input values, or null if none"
msgstr ""
"побитовое ИЛИ для всех входных значений, не равных NULL, или NULL, если "
"таких нет"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13355(indexterm)
msgid "<primary>bool_and</primary>"
msgstr "<primary>bool_and</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13358(function)
msgid "bool_and(<placeholder-1/>)"
msgstr "bool_and(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13361(type) func.xml:13364(type) func.xml:13378(type)
#: func.xml:13381(type) func.xml:13419(type) func.xml:13422(type)
#: func.xml:18556(type) func.xml:18762(type) func.xml:18842(type)
#: func.xml:19234(type) func.xml:19246(type) func.xml:19318(type)
#: func.xml:19336(type) func.xml:19355(type) func.xml:20478(type)
#: func.xml:20539(type) func.xml:20544(type) func.xml:20552(type)
msgid "bool"
msgstr "bool"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13367(entry)
msgid "true if all input values are true, otherwise false"
msgstr "true, если все входные значения равны true, и false в противном случае"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13372(indexterm)
msgid "<primary>bool_or</primary>"
msgstr "<primary>bool_or</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13375(function)
msgid "bool_or(<placeholder-1/>)"
msgstr "bool_or(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13384(entry)
msgid "true if at least one input value is true, otherwise false"
msgstr ""
"true, если хотя бы одно входное значение равно true, и false в противном "
"случае"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13389(indexterm)
msgid "<primary>count</primary>"
msgstr "<primary>count</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13392(function)
msgid "count(*)"
msgstr "count(*)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13397(entry)
msgid "number of input rows"
msgstr "количество входных строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13401(function)
msgid "count(<placeholder-1/>)"
msgstr "count(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13402(entry)
msgctxt "entry"
msgid "any"
msgstr "any"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13405(entry)
msgid ""
"number of input rows for which the value of <replaceable class=\"parameter"
"\">expression</replaceable> is not null"
msgstr ""
"количество входных строк, для которых значение <replaceable class=\"parameter"
"\">выражения</replaceable> не равно NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13413(indexterm)
msgid "<primary>every</primary>"
msgstr "<primary>every</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13416(function)
msgid "every(<placeholder-1/>)"
msgstr "every(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13425(entry)
msgid "equivalent to <function>bool_and</function>"
msgstr "синоним <function>bool_and</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13430(indexterm)
msgid "<primary>json_agg</primary>"
msgstr "<primary>json_agg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13433(function)
msgid "json_agg(<placeholder-1/>)"
msgstr "json_agg(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13436(type) func.xml:13453(type) func.xml:14647(type)
#: func.xml:14663(type) func.xml:14680(type) func.xml:19425(type)
msgctxt "type"
msgid "any"
msgstr "any"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13442(entry) func.xml:13459(entry)
msgid "aggregates values as a JSON array"
msgstr "агрегирует значения в виде массива JSON"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13447(indexterm)
msgid "<primary>jsonb_agg</primary>"
msgstr "<primary>jsonb_agg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13450(function)
msgid "jsonb_agg(<placeholder-1/>)"
msgstr "jsonb_agg(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13464(indexterm)
msgid "<primary>json_object_agg</primary>"
msgstr "<primary>json_object_agg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13467(function)
msgid "json_object_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "json_object_agg(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13470(type) func.xml:13487(type)
msgid "(any, any)"
msgstr "(any, any)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13476(entry) func.xml:13493(entry)
msgid "aggregates name/value pairs as a JSON object"
msgstr "агрегирует пары имя/значение в виде объекта JSON"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13481(indexterm)
msgid "<primary>jsonb_object_agg</primary>"
msgstr "<primary>jsonb_object_agg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13484(function)
msgid "jsonb_object_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "jsonb_object_agg(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13498(indexterm)
msgid "<primary>max</primary>"
msgstr "<primary>max</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13501(function)
msgid "max(<placeholder-1/>)"
msgstr "max(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13503(entry) func.xml:13521(entry)
msgid ""
"any numeric, string, date/time, network, or enum type, or arrays of these "
"types"
msgstr ""
"любой числовой, строковый, сетевой тип или тип даты/времени, либо массив "
"этих типов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13505(entry) func.xml:13523(entry)
msgid "same as argument type"
msgstr "тот же, что и тип аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13507(entry)
msgid ""
"maximum value of <replaceable class=\"parameter\">expression</replaceable> "
"across all input values"
msgstr ""
"максимальное значение <replaceable class=\"parameter\">выражения</"
"replaceable> среди всех входных данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13516(indexterm)
msgid "<primary>min</primary>"
msgstr "<primary>min</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13519(function)
msgid "min(<placeholder-1/>)"
msgstr "min(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13525(entry)
msgid ""
"minimum value of <replaceable class=\"parameter\">expression</replaceable> "
"across all input values"
msgstr ""
"минимальное значение <replaceable class=\"parameter\">выражения</"
"replaceable> среди всех входных данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13534(indexterm)
msgid "<primary>string_agg</primary>"
msgstr "<primary>string_agg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13539(replaceable)
msgctxt "replaceable"
msgid "delimiter"
msgstr "разделитель"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13537(function)
msgid "string_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "string_agg(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13542(entry)
msgid ""
"(<type>text</type>, <type>text</type>) or (<type>bytea</type>, <type>bytea</"
"type>)"
msgstr ""
"(<type>text</type>, <type>text</type>) или (<type>bytea</type>, <type>bytea</"
"type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13545(entry)
msgid "same as argument types"
msgstr "тот же, что и типы аргументов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13549(entry)
msgid "input values concatenated into a string, separated by delimiter"
msgstr "входные данные складываются в строку через заданный разделитель"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13554(indexterm)
msgid "<primary>sum</primary>"
msgstr "<primary>sum</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13557(function)
msgid "sum(<placeholder-1/>)"
msgstr "sum(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13559(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, <type>interval</"
"type>, or <type>money</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, <type>interval</"
"type> или <type>money</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13565(entry)
msgid ""
"<type>bigint</type> for <type>smallint</type> or <type>int</type> arguments, "
"<type>numeric</type> for <type>bigint</type> arguments, otherwise the same "
"as the argument data type"
msgstr ""
"<type>bigint</type> для аргументов <type>smallint</type> или <type>int</"
"type>, <type>numeric</type> для аргументов <type>bigint</type>, и тип "
"аргумента в остальных случаях"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13572(entry)
msgid ""
"sum of <replaceable class=\"parameter\">expression</replaceable> across all "
"input values"
msgstr ""
"сумма значений <replaceable class=\"parameter\">выражения</replaceable> по "
"всем входным данным"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13580(function)
msgid "xmlagg(<placeholder-1/>)"
msgstr "xmlagg(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13583(type) func.xml:13586(type)
msgctxt "type"
msgid "xml"
msgstr "xml"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13589(entry)
msgid ""
"concatenation of XML values (see also <xref linkend=\"functions-xml-xmlagg\"/"
">)"
msgstr ""
"соединение XML-значений (см. также <xref remap=\"4\" linkend=\"functions-xml-"
"xmlagg\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13595(para)
msgid ""
"It should be noted that except for <function>count</function>, these "
"functions return a null value when no rows are selected. In particular, "
"<function>sum</function> of no rows returns null, not zero as one might "
"expect, and <function>array_agg</function> returns null rather than an empty "
"array when there are no input rows. The <function>coalesce</function> "
"function can be used to substitute zero or an empty array for null when "
"necessary."
msgstr ""
"Следует заметить, что за исключением <function>count</function>, все эти "
"функции возвращают NULL, если для них не была выбрана ни одна строка. В "
"частности, функция <function>sum</function>, не получив строк, возвращает "
"NULL, а не 0, как можно было бы ожидать, и <function>array_agg</function> в "
"этом случае возвращает NULL, а не пустой массив. Если необходимо, подставить "
"в результат 0 или пустой массив вместо NULL можно с помощью функции "
"<function>coalesce</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13605(para)
msgid ""
"Aggregate functions which support <firstterm>Partial Mode</firstterm> are "
"eligible to participate in various optimizations, such as parallel "
"aggregation."
msgstr ""
"Агрегатные функции, поддерживающие <firstterm>частичный режим</firstterm>, "
"являются кандидатами на участие в различных оптимизациях, например, в "
"параллельном агрегировании."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13612(indexterm) func.xml:14771(indexterm)
#: func.xml:15118(indexterm)
msgid "<primary>ANY</primary>"
msgstr "<primary>ANY</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13615(indexterm) func.xml:14779(indexterm)
#: func.xml:15126(indexterm)
msgid "<primary>SOME</primary>"
msgstr "<primary>SOME</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13625(programlisting)
#, no-wrap
msgid "SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;"
msgstr "SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13618(para)
msgid ""
"Boolean aggregates <function>bool_and</function> and <function>bool_or</"
"function> correspond to standard SQL aggregates <function>every</function> "
"and <function>any</function> or <function>some</function>. As for "
"<function>any</function> and <function>some</function>, it seems that there "
"is an ambiguity built into the standard syntax: <placeholder-1/> Here "
"<function>ANY</function> can be considered either as introducing a subquery, "
"or as being an aggregate function, if the subquery returns one row with a "
"Boolean value. Thus the standard name cannot be given to these aggregates."
msgstr ""
"Булевы агрегатные функции <function>bool_and</function> и <function>bool_or</"
"function> соответствуют стандартным SQL-агрегатам <function>every</function> "
"и <function>any</function> или <function>some</function>. Что касается "
"<function>any</function> и <function>some</function>, по стандарту их "
"синтаксис допускает некоторую неоднозначность: <placeholder-1/> Здесь "
"<function>ANY</function> можно рассматривать и как объявление подзапроса, и "
"как агрегатную функцию, если этот подзапрос возвращает одну строку с булевым "
"значением. Таким образом, этим агрегатным функциям нельзя было дать "
"стандартные имена."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13641(programlisting)
#, no-wrap
msgid "SELECT count(*) FROM sometable;"
msgstr "SELECT count(*) FROM sometable;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13636(para)
msgid ""
"Users accustomed to working with other SQL database management systems might "
"be disappointed by the performance of the <function>count</function> "
"aggregate when it is applied to the entire table. A query like: "
"<placeholder-1/> will require effort proportional to the size of the table: "
"<productname>PostgreSQL</productname> will need to scan either the entire "
"table or the entirety of an index which includes all rows in the table."
msgstr ""
"Пользователи с опытом использования других СУБД SQL могут быть недовольны "
"скоростью агрегатной функции <function>count</function>, когда она "
"применяется ко всей таблице. Подобный запрос: <placeholder-1/> потребует "
"затрат в количестве, пропорциональном размеру таблицы: "
"<productname>PostgreSQL</productname> придётся полностью просканировать либо "
"всю таблицу, либо один из индексов, включающий все её строки."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13651(para)
msgid ""
"The aggregate functions <function>array_agg</function>, <function>json_agg</"
"function>, <function>jsonb_agg</function>, <function>json_object_agg</"
"function>, <function>jsonb_object_agg</function>, <function>string_agg</"
"function>, and <function>xmlagg</function>, as well as similar user-defined "
"aggregate functions, produce meaningfully different result values depending "
"on the order of the input values. This ordering is unspecified by default, "
"but can be controlled by writing an <literal>ORDER BY</literal> clause "
"within the aggregate call, as shown in <xref linkend=\"syntax-aggregates\"/"
">. Alternatively, supplying the input values from a sorted subquery will "
"usually work. For example: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;\n"
"]]></screen> Beware that this approach can fail if the outer query level "
"contains additional processing, such as a join, because that might cause the "
"subquery's output to be reordered before the aggregate is computed."
msgstr ""
"Агрегатные функции <function>array_agg</function>, <function>json_agg</"
"function>, <function>jsonb_agg</function>, <function>json_object_agg</"
"function>, <function>jsonb_object_agg</function>, <function>string_agg</"
"function> и <function>xmlagg</function> так же, как и подобные "
"пользовательские агрегатные функции, выдают разные по содержанию результаты "
"в зависимости от порядка входных значений. По умолчанию порядок не "
"определён, но его можно задать, дополнив вызов агрегатной функции "
"предложением <literal>ORDER BY</literal>, как описано в <xref remap=\"6\" "
"linkend=\"syntax-aggregates\"/>. Обычно нужного результата также можно "
"добиться, передав для агрегирования результат подзапроса с сортировкой. "
"Например: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;\n"
"]]></screen> Но учтите, что этот подход может не работать, если на внешнем "
"уровне запроса выполняется дополнительная обработка, например, соединение, "
"так как при этом результат подзапроса может быть переупорядочен перед "
"вычислением агрегатной функции."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13674(para)
msgid ""
"<xref linkend=\"functions-aggregate-statistics-table\"/> shows aggregate "
"functions typically used in statistical analysis. (These are separated out "
"merely to avoid cluttering the listing of more-commonly-used aggregates.) "
"Where the description mentions <replaceable class=\"parameter\">N</"
"replaceable>, it means the number of input rows for which all the input "
"expressions are non-null. In all cases, null is returned if the computation "
"is meaningless, for example when <replaceable class=\"parameter\">N</"
"replaceable> is zero."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-aggregate-statistics-table\"/> "
"перечислены агрегатные функции, обычно применяемые в статистическом анализе. "
"(Они выделены просто для того, чтобы не загромождать список наиболее "
"популярных агрегатных функций.) В их описании под <replaceable class="
"\"parameter\">N</replaceable> подразумевается число входных строк, для "
"которых входные выражения не равны NULL. Все эти функции возвращают NULL во "
"всех случаях, когда вычисление бессмысленно, например, когда <replaceable "
"class=\"parameter\">N</replaceable> равно 0."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13685(indexterm)
msgid "<primary>statistics</primary>"
msgstr "<primary>статистика</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13688(indexterm)
msgid "<primary>linear regression</primary>"
msgstr "<primary>линейная регрессия</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13693(title)
msgid "Aggregate Functions for Statistics"
msgstr "Агрегатные функции для статистических вычислений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13699(entry) func.xml:15486(entry)
msgid "Argument Type"
msgstr "Тип аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13710(indexterm)
msgid "<primary>correlation</primary>"
msgstr "<primary>корреляция</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13713(indexterm)
msgid "<primary>corr</primary>"
msgstr "<primary>corr</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13716(replaceable) func.xml:13737(replaceable)
#: func.xml:13758(replaceable) func.xml:13775(replaceable)
#: func.xml:13793(replaceable) func.xml:13811(replaceable)
#: func.xml:13831(replaceable) func.xml:13851(replaceable)
#: func.xml:13871(replaceable) func.xml:13890(replaceable)
#: func.xml:13911(replaceable) func.xml:13935(replaceable)
msgctxt "replaceable"
msgid "Y"
msgstr "Y"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13716(function)
msgid "corr(<placeholder-1/>, <placeholder-2/>)"
msgstr "corr(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13725(entry)
msgid "correlation coefficient"
msgstr "коэффициент корреляции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13730(indexterm)
msgid "<primary>covariance</primary> <secondary>population</secondary>"
msgstr "<primary>ковариация</primary> <secondary>совокупности</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13734(indexterm)
msgid "<primary>covar_pop</primary>"
msgstr "<primary>covar_pop</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13737(function)
msgid "covar_pop(<placeholder-1/>, <placeholder-2/>)"
msgstr "covar_pop(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13746(entry)
msgid "population covariance"
msgstr "ковариация совокупности"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13751(indexterm)
msgid "<primary>covariance</primary> <secondary>sample</secondary>"
msgstr "<primary>ковариация</primary> <secondary>выборки</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13755(indexterm)
msgid "<primary>covar_samp</primary>"
msgstr "<primary>covar_samp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13758(function)
msgid "covar_samp(<placeholder-1/>, <placeholder-2/>)"
msgstr "covar_samp(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13767(entry)
msgid "sample covariance"
msgstr "ковариация выборки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13772(indexterm)
msgid "<primary>regr_avgx</primary>"
msgstr "<primary>regr_avgx</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13775(function)
msgid "regr_avgx(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_avgx(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13784(entry)
msgid ""
"average of the independent variable (<literal>sum(<replaceable class="
"\"parameter\">X</replaceable>)/<replaceable class=\"parameter\">N</"
"replaceable></literal>)"
msgstr ""
"среднее независимой переменной (<literal>sum(<replaceable class=\"parameter"
"\">X</replaceable>)/<replaceable class=\"parameter\">N</replaceable></"
"literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13790(indexterm)
msgid "<primary>regr_avgy</primary>"
msgstr "<primary>regr_avgy</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13793(function)
msgid "regr_avgy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_avgy(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13802(entry)
msgid ""
"average of the dependent variable (<literal>sum(<replaceable class="
"\"parameter\">Y</replaceable>)/<replaceable class=\"parameter\">N</"
"replaceable></literal>)"
msgstr ""
"среднее зависимой переменной (<literal>sum(<replaceable class=\"parameter"
"\">Y</replaceable>)/<replaceable class=\"parameter\">N</replaceable></"
"literal>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13808(indexterm)
msgid "<primary>regr_count</primary>"
msgstr "<primary>regr_count</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13811(function)
msgid "regr_count(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_count(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13820(entry)
msgid "number of input rows in which both expressions are nonnull"
msgstr "число входных строк, в которых оба выражения не NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13825(indexterm)
msgid "<primary>regression intercept</primary>"
msgstr "<primary>пересечение линии регрессии</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13828(indexterm)
msgid "<primary>regr_intercept</primary>"
msgstr "<primary>regr_intercept</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13831(function)
msgid "regr_intercept(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_intercept(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13840(entry)
msgid ""
"y-intercept of the least-squares-fit linear equation determined by the "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>) pairs"
msgstr ""
"пересечение с осью OY линии, полученной методом наименьших квадратов по "
"данным (<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13848(indexterm)
msgid "<primary>regr_r2</primary>"
msgstr "<primary>regr_r2</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13851(function)
msgid "regr_r2(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_r2(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13860(entry)
msgid "square of the correlation coefficient"
msgstr "квадрат коэффициента корреляции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13865(indexterm)
msgid "<primary>regression slope</primary>"
msgstr "<primary>наклон линии регрессии</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13868(indexterm)
msgid "<primary>regr_slope</primary>"
msgstr "<primary>regr_slope</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13871(function)
msgid "regr_slope(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_slope(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13880(entry)
msgid ""
"slope of the least-squares-fit linear equation determined by the "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>) pairs"
msgstr ""
"наклон линии, полученной методом наименьших квадратов по данным "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13887(indexterm)
msgid "<primary>regr_sxx</primary>"
msgstr "<primary>regr_sxx</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13890(function)
msgid "regr_sxx(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_sxx(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13899(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">X</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>sum of squares</quote> of "
"the independent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">X</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>сумма квадратов</quote> "
"независимой переменной)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13908(indexterm)
msgid "<primary>regr_sxy</primary>"
msgstr "<primary>regr_sxy</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13911(function)
msgid "regr_sxy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_sxy(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13920(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>*<replaceable "
"class=\"parameter\">Y</replaceable>) - sum(<replaceable class=\"parameter"
"\">X</replaceable>) * sum(<replaceable class=\"parameter\">Y</replaceable>)/"
"<replaceable class=\"parameter\">N</replaceable></literal> (<quote>sum of "
"products</quote> of independent times dependent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>*<replaceable "
"class=\"parameter\">Y</replaceable>) - sum(<replaceable class=\"parameter"
"\">X</replaceable>) * sum(<replaceable class=\"parameter\">Y</replaceable>)/"
"<replaceable class=\"parameter\">N</replaceable></literal> (<quote>сумма "
"произведений</quote> независимых и зависимых переменных)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13932(indexterm)
msgid "<primary>regr_syy</primary>"
msgstr "<primary>regr_syy</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13935(function)
msgid "regr_syy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_syy(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13944(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">Y</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">Y</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>sum of squares</quote> of "
"the dependent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">Y</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">Y</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>сумма квадратов</quote> "
"зависимой переменной)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13953(indexterm)
msgid "<primary>standard deviation</primary>"
msgstr "<primary>стандартное отклонение</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13956(indexterm)
msgid "<primary>stddev</primary>"
msgstr "<primary>stddev</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13959(function)
msgid "stddev(<placeholder-1/>)"
msgstr "stddev(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13961(entry) func.xml:13985(entry) func.xml:14009(entry)
#: func.xml:14029(entry) func.xml:14053(entry) func.xml:14077(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, or <type>numeric</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type> или <type>numeric</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13966(entry) func.xml:13990(entry) func.xml:14014(entry)
#: func.xml:14034(entry) func.xml:14058(entry) func.xml:14082(entry)
msgid ""
"<type>double precision</type> for floating-point arguments, otherwise "
"<type>numeric</type>"
msgstr ""
"<type>double precision</type> для аргументов с плавающей точкой, "
"<type>numeric</type> для остальных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13971(entry)
msgid "historical alias for <function>stddev_samp</function>"
msgstr "сохранившийся синоним <function>stddev_samp</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13976(indexterm)
msgid "<primary>standard deviation</primary> <secondary>population</secondary>"
msgstr ""
"<primary>стандартное отклонение</primary> <secondary>по совокупности</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13980(indexterm)
msgid "<primary>stddev_pop</primary>"
msgstr "<primary>stddev_pop</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13983(function)
msgid "stddev_pop(<placeholder-1/>)"
msgstr "stddev_pop(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:13995(entry)
msgid "population standard deviation of the input values"
msgstr "стандартное отклонение по генеральной совокупности входных значений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14000(indexterm)
msgid "<primary>standard deviation</primary> <secondary>sample</secondary>"
msgstr ""
"<primary>стандартное отклонение</primary> <secondary>по выборке</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14004(indexterm)
msgid "<primary>stddev_samp</primary>"
msgstr "<primary>stddev_samp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14007(function)
msgid "stddev_samp(<placeholder-1/>)"
msgstr "stddev_samp(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14019(entry)
msgid "sample standard deviation of the input values"
msgstr "стандартное отклонение по выборке входных значений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14024(indexterm)
msgid "<primary>variance</primary>"
msgstr "<primary>дисперсия</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14023(entry)
msgid ""
"<placeholder-1/> <function>variance</function>(<replaceable class=\"parameter"
"\">expression</replaceable>)"
msgstr ""
"<placeholder-1/> <function>variance</function>(<replaceable class=\"parameter"
"\">выражение</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14039(entry)
msgid "historical alias for <function>var_samp</function>"
msgstr "сохранившийся синоним <function>var_samp</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14044(indexterm)
msgid "<primary>variance</primary> <secondary>population</secondary>"
msgstr "<primary>дисперсия</primary> <secondary>для совокупности</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14048(indexterm)
msgid "<primary>var_pop</primary>"
msgstr "<primary>var_pop</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14043(entry)
msgid ""
"<placeholder-1/> <placeholder-2/> <function>var_pop</function>(<replaceable "
"class=\"parameter\">expression</replaceable>)"
msgstr ""
"<placeholder-1/> <placeholder-2/> <function>var_pop</function>(<replaceable "
"class=\"parameter\">выражение</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14063(entry)
msgid ""
"population variance of the input values (square of the population standard "
"deviation)"
msgstr ""
"дисперсия для генеральной совокупности входных значений (квадрат "
"стандартного отклонения)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14068(indexterm)
msgid "<primary>variance</primary> <secondary>sample</secondary>"
msgstr "<primary>дисперсия</primary> <secondary>по выборке</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14072(indexterm)
msgid "<primary>var_samp</primary>"
msgstr "<primary>var_samp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14067(entry)
msgid ""
"<placeholder-1/> <placeholder-2/> <function>var_samp</function>(<replaceable "
"class=\"parameter\">expression</replaceable>)"
msgstr ""
"<placeholder-1/> <placeholder-2/> <function>var_samp</function>(<replaceable "
"class=\"parameter\">выражение</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14087(entry)
msgid ""
"sample variance of the input values (square of the sample standard deviation)"
msgstr ""
"дисперсия по выборке для входных значений (квадрат отклонения по выборке)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14093(para)
msgid ""
"<xref linkend=\"functions-orderedset-table\"/> shows some aggregate "
"functions that use the <firstterm>ordered-set aggregate</firstterm> syntax. "
"These functions are sometimes referred to as <quote>inverse distribution</"
"quote> functions."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-orderedset-table\"/> показаны "
"некоторые агрегатные функции, использующие синтаксис <firstterm>сортирующих "
"агрегатных функций</firstterm>. Иногда такие функции функциями называют "
"функциями <quote>обратного распределения</quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14100(indexterm)
msgid ""
"<primary>ordered-set aggregate</primary> <secondary>built-in</secondary>"
msgstr ""
"<primary>сортирующие агрегатные функции</primary> <secondary>встроенные</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14104(indexterm)
msgid "<primary>inverse distribution</primary>"
msgstr "<primary>обратное распределение</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14109(title)
msgid "Ordered-Set Aggregate Functions"
msgstr "Сортирующие агрегатные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14115(entry) func.xml:14274(entry)
msgid "Direct Argument Type(s)"
msgstr "Тип непосредственного аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14116(entry) func.xml:14275(entry)
msgid "Aggregated Argument Type(s)"
msgstr "Тип агрегированного аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14127(indexterm)
msgid "<primary>mode</primary> <secondary>statistical</secondary>"
msgstr "<primary>мода</primary> <secondary>статистическая функция</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14131(replaceable) func.xml:14154(replaceable)
#: func.xml:14175(replaceable) func.xml:14200(replaceable)
#: func.xml:14220(replaceable)
msgid "sort_expression"
msgstr "выражение_сортировки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14131(function)
msgid "mode() WITHIN GROUP (ORDER BY <placeholder-1/>)"
msgstr "mode() WITHIN GROUP (ORDER BY <placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14135(entry) func.xml:14205(entry) func.xml:14225(entry)
msgid "any sortable type"
msgstr "любой сортируемый тип"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14138(entry) func.xml:14162(entry) func.xml:14208(entry)
msgid "same as sort expression"
msgstr "тот же, что у выражения сортировки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14142(entry)
msgid ""
"returns the most frequent input value (arbitrarily choosing the first one if "
"there are multiple equally-frequent results)"
msgstr ""
"возвращает значение, наиболее часто встречающееся во входных данных (если "
"одинаково часто встречаются несколько значений, произвольно выбирается "
"первое из них)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14150(indexterm)
msgid "<primary>percentile</primary> <secondary>continuous</secondary>"
msgstr "<primary>процентиль</primary> <secondary>непрерывный</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14154(replaceable) func.xml:14200(replaceable)
msgid "fraction"
msgstr "дробь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14154(function) func.xml:14175(function)
msgid ""
"percentile_cont(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percentile_cont(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14159(entry) func.xml:14180(entry)
msgid "<type>double precision</type> or <type>interval</type>"
msgstr "<type>double precision</type> или <type>interval</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14166(entry)
msgid ""
"continuous percentile: returns a value corresponding to the specified "
"fraction in the ordering, interpolating between adjacent input items if "
"needed"
msgstr ""
"непрерывный процентиль: возвращает значение, соответствующее заданной дроби "
"по порядку, интерполируя соседние входные значения, если необходимо"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14175(replaceable) func.xml:14220(replaceable)
msgid "fractions"
msgstr "дроби"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14178(type) func.xml:14223(type)
msgid "double precision[]"
msgstr "double precision[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14183(entry) func.xml:14228(entry)
msgid "array of sort expression's type"
msgstr "массив типа выражения сортировки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14187(entry)
msgid ""
"multiple continuous percentile: returns an array of results matching the "
"shape of the <replaceable>fractions</replaceable> parameter, with each non-"
"null element replaced by the value corresponding to that percentile"
msgstr ""
"множественный непрерывный процентиль: возвращает массив результатов, "
"соответствующих форме параметра <replaceable>дроби</replaceable> (для "
"каждого элемента не NULL подставляется значение, соответствующее данному "
"процентилю)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14196(indexterm)
msgid "<primary>percentile</primary> <secondary>discrete</secondary>"
msgstr "<primary>процентиль</primary> <secondary>дискретный</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14200(function) func.xml:14220(function)
msgid ""
"percentile_disc(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percentile_disc(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14212(entry)
msgid ""
"discrete percentile: returns the first input value whose position in the "
"ordering equals or exceeds the specified fraction"
msgstr ""
"дискретный процентиль: возвращает первое значение из входных данных, позиция "
"которого по порядку равна или превосходит указанную дробь"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14232(entry)
msgid ""
"multiple discrete percentile: returns an array of results matching the shape "
"of the <replaceable>fractions</replaceable> parameter, with each non-null "
"element replaced by the input value corresponding to that percentile"
msgstr ""
"множественный дискретный процентиль: возвращает массив результатов, "
"соответствующих форме параметра <replaceable>дроби</replaceable> (для "
"каждого элемента не NULL подставляется входное значение, соответствующее "
"данному процентилю)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14243(para)
msgid ""
"All the aggregates listed in <xref linkend=\"functions-orderedset-table\"/> "
"ignore null values in their sorted input. For those that take a "
"<replaceable>fraction</replaceable> parameter, the fraction value must be "
"between 0 and 1; an error is thrown if not. However, a null fraction value "
"simply produces a null result."
msgstr ""
"Все агрегатные функции, перечисленные в <xref remap=\"6\" linkend="
"\"functions-orderedset-table\"/>, игнорируют значения NULL при сортировке "
"данных. Для функций, принимающих параметр <replaceable>дробь</replaceable>, "
"значение этого параметра должно быть от 0 до 1; в противном случае возникает "
"ошибка. Однако, если в этом параметре передаётся NULL, эти функции просто "
"выдают NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14251(indexterm)
msgid ""
"<primary>hypothetical-set aggregate</primary> <secondary>built-in</secondary>"
msgstr ""
"<primary>гипотезирующие агрегатные функции</primary> <secondary>встроенные</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14256(para)
msgid ""
"Each of the aggregates listed in <xref linkend=\"functions-hypothetical-table"
"\"/> is associated with a window function of the same name defined in <xref "
"linkend=\"functions-window\"/>. In each case, the aggregate result is the "
"value that the associated window function would have returned for the "
"<quote>hypothetical</quote> row constructed from <replaceable>args</"
"replaceable>, if such a row had been added to the sorted group of rows "
"computed from the <replaceable>sorted_args</replaceable>."
msgstr ""
"Все агрегатные функции, перечисленные в <xref remap=\"6\" linkend="
"\"functions-hypothetical-table\"/>, связаны с одноимёнными оконными "
"функциями, определёнными в <xref remap=\"6\" linkend=\"functions-window\"/>. "
"В каждом случае их результат &mdash; значение, которое вернула бы связанная "
"оконная функция для <quote>гипотетической</quote> строки, полученной из "
"<replaceable>аргументов</replaceable>, если бы такая строка была добавлена в "
"сортированную группу строк, которую образуют "
"<replaceable>сортированные_аргументы</replaceable>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14268(title)
msgid "Hypothetical-Set Aggregate Functions"
msgstr "Гипотезирующие агрегатные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14286(indexterm)
msgid "<primary>rank</primary> <secondary>hypothetical</secondary>"
msgstr "<primary>rank</primary> <secondary>гипотезирующая функция</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14290(replaceable) func.xml:14313(replaceable)
#: func.xml:14336(replaceable) func.xml:14359(replaceable)
msgctxt "replaceable"
msgid "args"
msgstr "аргументы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14290(replaceable) func.xml:14313(replaceable)
#: func.xml:14336(replaceable) func.xml:14359(replaceable)
msgid "sorted_args"
msgstr "сортированные_аргументы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14290(function)
msgid "rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14293(literal) func.xml:14296(literal) func.xml:14316(literal)
#: func.xml:14319(literal) func.xml:14339(literal) func.xml:14342(literal)
#: func.xml:14362(literal) func.xml:14365(literal)
msgid "VARIADIC"
msgstr "VARIADIC"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14302(entry)
msgid "rank of the hypothetical row, with gaps for duplicate rows"
msgstr "ранг гипотетической строки, с пропусками повторяющихся строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14309(indexterm)
msgid "<primary>dense_rank</primary> <secondary>hypothetical</secondary>"
msgstr ""
"<primary>dense_rank</primary> <secondary>гипотезирующая функция</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14313(function)
msgid "dense_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "dense_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14325(entry)
msgid "rank of the hypothetical row, without gaps"
msgstr "ранг гипотетической строки, без пропусков"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14332(indexterm)
msgid "<primary>percent_rank</primary> <secondary>hypothetical</secondary>"
msgstr ""
"<primary>percent_rank</primary> <secondary>гипотезирующая функция</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14336(function)
msgid "percent_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percent_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14348(entry)
msgid "relative rank of the hypothetical row, ranging from 0 to 1"
msgstr "относительный ранг гипотетической строки, от 0 до 1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14355(indexterm)
msgid "<primary>cume_dist</primary> <secondary>hypothetical</secondary>"
msgstr ""
"<primary>cume_dist</primary> <secondary>гипотезирующая функция</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14359(function)
msgid "cume_dist(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "cume_dist(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14371(entry)
msgid ""
"relative rank of the hypothetical row, ranging from 1/<replaceable>N</"
"replaceable> to 1"
msgstr ""
"относительный ранг гипотетической строки, от 1/<replaceable>N</replaceable> "
"до 1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14381(para)
msgid ""
"For each of these hypothetical-set aggregates, the list of direct arguments "
"given in <replaceable>args</replaceable> must match the number and types of "
"the aggregated arguments given in <replaceable>sorted_args</replaceable>. "
"Unlike most built-in aggregates, these aggregates are not strict, that is "
"they do not drop input rows containing nulls. Null values sort according to "
"the rule specified in the <literal>ORDER BY</literal> clause."
msgstr ""
"Для всех этих гипотезирующих агрегатных функций непосредственные "
"<replaceable>аргументы</replaceable> должны соответствовать (по количеству и "
"типу) <replaceable>сортированным_аргументам</replaceable>. В отличие от "
"встроенных агрегатных функций, они не являются строгими, то есть не "
"отбрасывают входные строки, содержащие NULL. Значения NULL сортируются "
"согласно правилу, указанному в предложении <literal>ORDER BY</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14391(title)
msgid "Grouping Operations"
msgstr "Операции группировки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14406(indexterm)
msgid "<primary>GROUPING</primary>"
msgstr "<primary>GROUPING</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14409(replaceable)
msgid "args..."
msgstr "аргументы..."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14409(function)
msgid "GROUPING(<placeholder-1/>)"
msgstr "GROUPING(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14414(entry)
msgid ""
"Integer bit mask indicating which arguments are not being included in the "
"current grouping set"
msgstr ""
"Целочисленная битовая маска, показывающая, какие аргументы не вошли в "
"текущий набор группирования"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14423(para)
msgid ""
"Grouping operations are used in conjunction with grouping sets (see <xref "
"linkend=\"queries-grouping-sets\"/>) to distinguish result rows. The "
"arguments to the <literal>GROUPING</literal> operation are not actually "
"evaluated, but they must match exactly expressions given in the "
"<literal>GROUP BY</literal> clause of the associated query level. Bits are "
"assigned with the rightmost argument being the least-significant bit; each "
"bit is 0 if the corresponding expression is included in the grouping "
"criteria of the grouping set generating the result row, and 1 if it is not. "
"For example: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>\n"
" make  | model | sales\n"
"-------+-------+-------\n"
" Foo   | GT    |  10\n"
" Foo   | Tour  |  20\n"
" Bar   | City  |  15\n"
" Bar   | Sport |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), "
"sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>\n"
" make  | model | grouping | sum\n"
"-------+-------+----------+-----\n"
" Foo   | GT    |        0 | 10\n"
" Foo   | Tour  |        0 | 20\n"
" Bar   | City  |        0 | 15\n"
" Bar   | Sport |        0 | 5\n"
" Foo   |       |        1 | 30\n"
" Bar   |       |        1 | 20\n"
"       |       |        3 | 50\n"
"(7 rows)\n"
"</screen>"
msgstr ""
"Операции группировки применяются в сочетании с наборами группирования (см. "
"<xref remap=\"4\" linkend=\"queries-grouping-sets\"/>) для различения "
"результирующих строк. Аргументы операции <literal>GROUPING</literal> на "
"самом деле не вычисляются, но они должны в точности соответствовать "
"выражениям, заданным в предложении <literal>GROUP BY</literal> на их уровне "
"запроса. Биты назначаются справа налево (правый аргумент отражается в "
"младшем бите); бит равен 0, если соответствующее выражение вошло в критерий "
"группировки набора группирования, для которого сформирована строка "
"результата, или 1 в противном случае. Например: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>\n"
" make  | model | sales\n"
"-------+-------+-------\n"
" Foo   | GT    |  10\n"
" Foo   | Tour  |  20\n"
" Bar   | City  |  15\n"
" Bar   | Sport |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), "
"sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>\n"
" make  | model | grouping | sum\n"
"-------+-------+----------+-----\n"
" Foo   | GT    |        0 | 10\n"
" Foo   | Tour  |        0 | 20\n"
" Bar   | City  |        0 | 15\n"
" Bar   | Sport |        0 | 5\n"
" Foo   |       |        1 | 30\n"
" Bar   |       |        1 | 20\n"
"       |       |        3 | 50\n"
"(7 rows)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14459(title)
msgid "Window Functions"
msgstr "Оконные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14461(indexterm)
msgid "<primary>window function</primary> <secondary>built-in</secondary>"
msgstr "<primary>оконные функции</primary> <secondary>встроенные</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14466(para)
msgid ""
"<firstterm>Window functions</firstterm> provide the ability to perform "
"calculations across sets of rows that are related to the current query row. "
"See <xref linkend=\"tutorial-window\"/> for an introduction to this feature, "
"and <xref linkend=\"syntax-window-functions\"/> for syntax details."
msgstr ""
"<firstterm>Оконные функции</firstterm> дают возможность выполнять вычисления "
"с набором строк, каким-либо образом связанным с текущей строкой запроса. "
"Вводную информацию об этом можно получить в <xref remap=\"6\" linkend="
"\"tutorial-window\"/>, а подробнее узнать о синтаксисе можно в <xref remap="
"\"6\" linkend=\"syntax-window-functions\"/>."

#. +> REL_10
#: func.xml:14474(para)
msgid ""
"The built-in window functions are listed in <xref linkend=\"functions-window-"
"table\"/>. Note that these functions <emphasis>must</emphasis> be invoked "
"using window function syntax, i.e., an <literal>OVER</literal> clause is "
"required."
msgstr ""
"Встроенные оконные функции перечислены в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>. Заметьте, что эти функции <emphasis>должны</"
"emphasis> вызываться именно как оконные, т. е. при вызове необходимо "
"использовать предложение <literal>OVER</literal>."

#. +> REL_10
#: func.xml:14481(para)
msgid ""
"In addition to these functions, any built-in or user-defined general-purpose "
"or statistical aggregate (i.e., not ordered-set or hypothetical-set "
"aggregates) can be used as a window function; see <xref linkend=\"functions-"
"aggregate\"/> for a list of the built-in aggregates. Aggregate functions act "
"as window functions only when an <literal>OVER</literal> clause follows the "
"call; otherwise they act as non-window aggregates and return a single row "
"for the entire set."
msgstr ""
"В дополнение к этим функциям в качестве оконных можно использовать любые "
"встроенные или пользовательские универсальные или статистические агрегатные "
"функции (но не сортирующие и не гипотезирующие); список встроенных "
"агрегатных функций приведён в <xref remap=\"6\" linkend=\"functions-aggregate"
"\"/>. Агрегатные функции работают как оконные, только когда за их вызовом "
"следует предложение <literal>OVER</literal>; в противном случае они работают "
"как обычные, не оконные функции и выдают для всего набора единственную "
"строку."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14493(title)
msgid "General-Purpose Window Functions"
msgstr "Оконные функции общего назначения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14507(indexterm)
msgid "<primary>row_number</primary>"
msgstr "<primary>row_number</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14510(function)
msgid "row_number()"
msgstr "row_number()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14515(entry)
msgid "number of the current row within its partition, counting from 1"
msgstr "номер текущей строки в её разделе, начиная с 1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14520(indexterm)
msgid "<primary>rank</primary>"
msgstr "<primary>rank</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14523(function)
msgid "rank()"
msgstr "rank()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14528(entry)
msgid ""
"rank of the current row with gaps; same as <function>row_number</function> "
"of its first peer"
msgstr ""
"ранг текущей строки с пропусками; то же, что и <function>row_number</"
"function> для первой родственной ей строки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14533(indexterm)
msgid "<primary>dense_rank</primary>"
msgstr "<primary>dense_rank</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14536(function)
msgid "dense_rank()"
msgstr "dense_rank()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14541(entry)
msgid "rank of the current row without gaps; this function counts peer groups"
msgstr ""
"ранг текущей строки без пропусков; эта функция считает группы родственных "
"строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14546(indexterm)
msgid "<primary>percent_rank</primary>"
msgstr "<primary>percent_rank</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14549(function)
msgid "percent_rank()"
msgstr "percent_rank()"

#. +> REL_10
#: func.xml:14554(entry)
msgid ""
"relative rank of the current row: (<function>rank</function> - 1) / (total "
"partition rows - 1)"
msgstr ""
"относительный ранг текущей строки: (<function>rank</function> - 1) / (общее "
"число строк раздела - 1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14559(indexterm)
msgid "<primary>cume_dist</primary>"
msgstr "<primary>cume_dist</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14562(function)
msgid "cume_dist()"
msgstr "cume_dist()"

#. +> REL_10
#: func.xml:14567(entry)
msgid ""
"cumulative distribution: (number of partition rows preceding or peer with "
"current row) / total partition rows"
msgstr ""
"кумулятивное распределение: (число строк раздела, предшествующих или "
"родственных текущей строке) / общее число строк раздела"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14572(indexterm)
msgid "<primary>ntile</primary>"
msgstr "<primary>ntile</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14575(replaceable)
msgid "num_buckets"
msgstr "число_групп"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14575(function)
msgid "ntile(<placeholder-1/> <placeholder-2/>)"
msgstr "ntile(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14580(entry)
msgid ""
"integer ranging from 1 to the argument value, dividing the partition as "
"equally as possible"
msgstr ""
"ранжирование по целым числам от 1 до значения аргумента так, чтобы размеры "
"групп были максимально близки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14586(indexterm)
msgid "<primary>lag</primary>"
msgstr "<primary>lag</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14591(replaceable) func.xml:14620(replaceable)
msgctxt "replaceable"
msgid "offset"
msgstr "смещение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14592(replaceable) func.xml:14621(replaceable)
msgid "default"
msgstr "по_умолчанию"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14589(function)
msgid ""
"lag(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"
msgstr ""
"lag(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"

# skip-rule: modified-nontranslatable
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14596(type) func.xml:14625(type) func.xml:14650(type)
#: func.xml:14666(type) func.xml:14684(type)
msgid "same type as <placeholder-1/>"
msgstr "тип аргумента <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14598(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is <replaceable class=\"parameter\">offset</replaceable> rows "
"before the current row within the partition; if there is no such row, "
"instead return <replaceable class=\"parameter\">default</replaceable> (which "
"must be of the same type as <replaceable class=\"parameter\">value</"
"replaceable>). Both <replaceable class=\"parameter\">offset</replaceable> "
"and <replaceable class=\"parameter\">default</replaceable> are evaluated "
"with respect to the current row. If omitted, <replaceable class=\"parameter"
"\">offset</replaceable> defaults to 1 and <replaceable class=\"parameter"
"\">default</replaceable> to null"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable> для "
"строки, положение которой задаётся <replaceable class=\"parameter"
"\">смещением</replaceable> от текущей строки к началу раздела; если такой "
"строки нет, возвращается значение <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и "
"<replaceable class=\"parameter\">значение</replaceable>). Оба параметра "
"<replaceable class=\"parameter\">смещение</replaceable> и <replaceable class="
"\"parameter\">по_умолчанию</replaceable> вычисляются для текущей строки. "
"Если они не указываются, то <replaceable class=\"parameter\">смещение</"
"replaceable> считается равным 1, а <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> &mdash; NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14615(indexterm)
msgid "<primary>lead</primary>"
msgstr "<primary>lead</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14618(function)
msgid ""
"lead(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"
msgstr ""
"lead(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14627(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is <replaceable class=\"parameter\">offset</replaceable> rows "
"after the current row within the partition; if there is no such row, instead "
"return <replaceable class=\"parameter\">default</replaceable> (which must be "
"of the same type as <replaceable class=\"parameter\">value</replaceable>). "
"Both <replaceable class=\"parameter\">offset</replaceable> and <replaceable "
"class=\"parameter\">default</replaceable> are evaluated with respect to the "
"current row. If omitted, <replaceable class=\"parameter\">offset</"
"replaceable> defaults to 1 and <replaceable class=\"parameter\">default</"
"replaceable> to null"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable> для "
"строки, положение которой задаётся <replaceable class=\"parameter"
"\">смещением</replaceable> от текущей строки к концу раздела; если такой "
"строки нет, возвращается значение <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и "
"<replaceable class=\"parameter\">значение</replaceable>). Оба параметра "
"<replaceable class=\"parameter\">смещение</replaceable> и <replaceable class="
"\"parameter\">по_умолчанию</replaceable> вычисляются для текущей строки. "
"Если они не указываются, то <replaceable class=\"parameter\">смещение</"
"replaceable> считается равным 1, а <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> &mdash; NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14644(indexterm)
msgid "<primary>first_value</primary>"
msgstr "<primary>first_value</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14647(function)
msgid "first_value(<placeholder-1/> <placeholder-2/>)"
msgstr "first_value(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14652(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the first row of the window frame"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное для первой строки в рамке окна"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14660(indexterm)
msgid "<primary>last_value</primary>"
msgstr "<primary>last_value</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14663(function)
msgid "last_value(<placeholder-1/> <placeholder-2/>)"
msgstr "last_value(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14668(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the last row of the window frame"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное для последней строки в рамке окна"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14676(indexterm)
msgid "<primary>nth_value</primary>"
msgstr "<primary>nth_value</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14680(replaceable)
msgid "nth"
msgstr "n"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14679(function)
msgid ""
"nth_value(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"nth_value(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14686(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the <replaceable class=\"parameter\">nth</replaceable> row "
"of the window frame (counting from 1); null if no such row"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное в <replaceable class=\"parameter\">н-ой</replaceable> строке в "
"рамке окна (считая с 1), или NULL, если такой строки нет"

#. +> REL_10
#: func.xml:14696(para)
msgid ""
"All of the functions listed in <xref linkend=\"functions-window-table\"/> "
"depend on the sort ordering specified by the <literal>ORDER BY</literal> "
"clause of the associated window definition. Rows that are not distinct when "
"considering only the <literal>ORDER BY</literal> columns are said to be "
"<firstterm>peers</firstterm>. The four ranking functions (including "
"<function>cume_dist</function>) are defined so that they give the same "
"answer for all peer rows."
msgstr ""
"Результат всех функций, перечисленных в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>, зависит от порядка сортировки, заданного "
"предложением <literal>ORDER BY</literal> в определении соответствующего "
"окна. Строки, которые являются одинаковыми при рассмотрении только столбцов "
"<literal>ORDER BY</literal>, считаются <firstterm>родственными</firstterm>. "
"Четыре функции, вычисляющие ранг (включая <function>cume_dist</function>), "
"реализованы так, что их результат будет одинаковым для всех родственных "
"строк."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14706(para)
msgid ""
"Note that <function>first_value</function>, <function>last_value</function>, "
"and <function>nth_value</function> consider only the rows within the "
"<quote>window frame</quote>, which by default contains the rows from the "
"start of the partition through the last peer of the current row. This is "
"likely to give unhelpful results for <function>last_value</function> and "
"sometimes also <function>nth_value</function>. You can redefine the frame by "
"adding a suitable frame specification (<literal>RANGE</literal> or "
"<literal>ROWS</literal>) to the <literal>OVER</literal> clause. See <xref "
"linkend=\"syntax-window-functions\"/> for more information about frame "
"specifications."
msgstr ""
"Заметьте, что функции <function>first_value</function>, "
"<function>last_value</function> и <function>nth_value</function> "
"рассматривают только строки в <quote>рамке окна</quote>, которая по "
"умолчанию содержит строки от начала раздела до последней родственной строки "
"для текущей. Поэтому результаты <function>last_value</function> и иногда "
"<function>nth_value</function> могут быть не очень полезны. В таких случаях "
"можно переопределить рамку, добавив в предложение <literal>OVER</literal> "
"подходящее указание (<literal>RANGE</literal> или <literal>ROWS</literal>). "
"Подробнее эти указания описаны в <xref remap=\"6\" linkend=\"syntax-window-"
"functions\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14719(para)
msgid ""
"When an aggregate function is used as a window function, it aggregates over "
"the rows within the current row's window frame. An aggregate used with "
"<literal>ORDER BY</literal> and the default window frame definition produces "
"a <quote>running sum</quote> type of behavior, which may or may not be "
"what's wanted. To obtain aggregation over the whole partition, omit "
"<literal>ORDER BY</literal> or use <literal>ROWS BETWEEN UNBOUNDED PRECEDING "
"AND UNBOUNDED FOLLOWING</literal>. Other frame specifications can be used to "
"obtain other effects."
msgstr ""
"Когда в качестве оконной функции используется агрегатная, она обрабатывает "
"строки в рамке текущей строки. Агрегатная функция с <literal>ORDER BY</"
"literal> и определением рамки окна по умолчанию будет вычисляться как "
"<quote>бегущая сумма</quote>, что может не соответствовать желаемому "
"результату. Чтобы агрегатная функция работала со всем разделом, следует "
"опустить <literal>ORDER BY</literal> или использовать <literal>ROWS BETWEEN "
"UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>. Используя другие "
"указания в определении рамки, можно получить и другие эффекты."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14731(para)
msgid ""
"The SQL standard defines a <literal>RESPECT NULLS</literal> or "
"<literal>IGNORE NULLS</literal> option for <function>lead</function>, "
"<function>lag</function>, <function>first_value</function>, "
"<function>last_value</function>, and <function>nth_value</function>. This is "
"not implemented in <productname>PostgreSQL</productname>: the behavior is "
"always the same as the standard's default, namely <literal>RESPECT NULLS</"
"literal>. Likewise, the standard's <literal>FROM FIRST</literal> or "
"<literal>FROM LAST</literal> option for <function>nth_value</function> is "
"not implemented: only the default <literal>FROM FIRST</literal> behavior is "
"supported. (You can achieve the result of <literal>FROM LAST</literal> by "
"reversing the <literal>ORDER BY</literal> ordering.)"
msgstr ""
"В стандарте SQL определены параметры <literal>RESPECT NULLS</literal> или "
"<literal>IGNORE NULLS</literal> для функций <function>lead</function>, "
"<function>lag</function>, <function>first_value</function>, "
"<function>last_value</function> и <function>nth_value</function>. В "
"<productname>PostgreSQL</productname> такие параметры не реализованы: эти "
"функции ведут себя так, как положено в стандарте по умолчанию (или с "
"подразумеваемым параметром <literal>RESPECT NULLS</literal>). Также функция "
"<function>nth_value</function> не поддерживает предусмотренные стандартом "
"параметры <literal>FROM FIRST</literal> и <literal>FROM LAST</literal>: "
"реализовано только поведение по умолчанию (с подразумеваемым параметром "
"<literal>FROM FIRST</literal>). (Получить эффект параметра <literal>FROM "
"LAST</literal> можно, изменив порядок <literal>ORDER BY</literal> на "
"обратный.)"

#. +> REL_10
#: func.xml:14746(para)
msgid ""
"<function>cume_dist</function> computes the fraction of partition rows that "
"are less than or equal to the current row and its peers, while "
"<function>percent_rank</function> computes the fraction of partition rows "
"that are less than the current row, assuming the current row does not exist "
"in the partition."
msgstr ""
"Функция <function>cume_dist</function> вычисляет процент строк раздела, "
"которые меньше или равны текущей строке или родственным ей строкам, тогда "
"как <function>percent_rank</function> вычисляет процент строк раздела, "
"которые меньше текущей строки, в предположении, что текущая строка не "
"относится к разделу."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14757(title)
msgid "Subquery Expressions"
msgstr "Выражения подзапросов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14759(indexterm)
msgid "<primary>EXISTS</primary>"
msgstr "<primary>EXISTS</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14763(indexterm) func.xml:15110(indexterm)
msgid "<primary>IN</primary>"
msgstr "<primary>IN</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14767(indexterm) func.xml:15114(indexterm)
msgid "<primary>NOT IN</primary>"
msgstr "<primary>NOT IN</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14775(indexterm) func.xml:15122(indexterm)
msgid "<primary>ALL</primary>"
msgstr "<primary>ALL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14783(indexterm)
msgid "<primary>subquery</primary>"
msgstr "<primary>подзапрос</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14787(para)
msgid ""
"This section describes the <acronym>SQL</acronym>-compliant subquery "
"expressions available in <productname>PostgreSQL</productname>. All of the "
"expression forms documented in this section return Boolean (true/false) "
"results."
msgstr ""
"В этом разделе описаны выражения подзапросов, которые реализованы в "
"<productname>PostgreSQL</productname> в соответствии со стандартом "
"<acronym>SQL</acronym>. Все рассмотренные здесь формы выражений возвращает "
"булевы значения (true/false)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14795(literal)
msgid "EXISTS"
msgstr "EXISTS"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14798(replaceable) func.xml:14848(replaceable)
#: func.xml:14874(replaceable) func.xml:14904(replaceable)
#: func.xml:14930(replaceable) func.xml:14960(replaceable)
#: func.xml:14961(replaceable) func.xml:14994(replaceable)
#: func.xml:14995(replaceable) func.xml:15025(replaceable)
#: func.xml:15051(replaceable) func.xml:15086(replaceable)
msgid "subquery"
msgstr "подзапрос"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14797(synopsis)
#, no-wrap
msgid "EXISTS (<placeholder-1/>)"
msgstr "EXISTS (<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14801(para)
msgid ""
"The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</"
"command> statement, or <firstterm>subquery</firstterm>. The subquery is "
"evaluated to determine whether it returns any rows. If it returns at least "
"one row, the result of <token>EXISTS</token> is <quote>true</quote>; if the "
"subquery returns no rows, the result of <token>EXISTS</token> is "
"<quote>false</quote>."
msgstr ""
"Аргументом <token>EXISTS</token> является обычный оператор <command>SELECT</"
"command>, т. е. <firstterm>подзапрос</firstterm>. Выполнив запрос, система "
"проверяет, возвращает ли он строки в результате. Если он возвращает минимум "
"одну строку, результатом <token>EXISTS</token> будет <quote>true</quote>, а "
"если не возвращает ни одной &mdash; <quote>false</quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14810(para)
msgid ""
"The subquery can refer to variables from the surrounding query, which will "
"act as constants during any one evaluation of the subquery."
msgstr ""
"Подзапрос может обращаться к переменным внешнего запроса, которые в рамках "
"одного вычисления подзапроса считаются константами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14815(para)
msgid ""
"The subquery will generally only be executed long enough to determine "
"whether at least one row is returned, not all the way to completion. It is "
"unwise to write a subquery that has side effects (such as calling sequence "
"functions); whether the side effects occur might be unpredictable."
msgstr ""
"Вообще говоря, подзапрос может выполняться не полностью, а завершаться, как "
"только будет возвращена хотя бы одна строка. Поэтому в подзапросах следует "
"избегать побочных эффектов (например, обращений к генераторам "
"последовательностей); проявление побочного эффекта может быть "
"непредсказуемым."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14823(para)
msgid ""
"Since the result depends only on whether any rows are returned, and not on "
"the contents of those rows, the output list of the subquery is normally "
"unimportant. A common coding convention is to write all <literal>EXISTS</"
"literal> tests in the form <literal>EXISTS(SELECT 1 WHERE ...)</literal>. "
"There are exceptions to this rule however, such as subqueries that use "
"<token>INTERSECT</token>."
msgstr ""
"Так как результат этого выражения зависит только от того, возвращаются "
"строки или нет, но не от их содержимого, список выходных значений подзапроса "
"обычно не имеет значения. Как следствие, широко распространена практика, "
"когда проверки <literal>EXISTS</literal> записываются в форме "
"<literal>EXISTS(SELECT 1 WHERE ...)</literal>. Однако из этого правила есть "
"и исключения, например с подзапросами с предложением <token>INTERSECT</"
"token>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14832(para)
msgid ""
"This simple example is like an inner join on <literal>col2</literal>, but it "
"produces at most one output row for each <literal>tab1</literal> row, even "
"if there are several matching <literal>tab2</literal> rows: <screen>\n"
"SELECT col1\n"
"FROM tab1\n"
"WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);\n"
"</screen>"
msgstr ""
"Этот простой пример похож на внутреннее соединение по столбцу <literal>col2</"
"literal>, но он выдаёт максимум одну строку для каждой строки в "
"<literal>tab1</literal>, даже если в <literal>tab2</literal> ей "
"соответствуют несколько строк: <screen>\n"
"SELECT col1\n"
"FROM tab1\n"
"WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14845(literal) func.xml:15170(literal)
msgid "IN"
msgstr "IN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14847(synopsis) func.xml:14873(synopsis)
#, no-wrap
msgid "<placeholder-1/> IN (<placeholder-2/>)"
msgstr "<placeholder-1/> IN (<placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14851(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result. The result of <token>IN</token> is <quote>true</"
"quote> if any equal subquery row is found. The result is <quote>false</"
"quote> if no equal row is found (including the case where the subquery "
"returns no rows)."
msgstr ""
"В правой стороне этого выражения в скобках задаётся подзапрос, который "
"должен возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значениями во всех строках, возвращённых подзапросом. "
"Результатом всего выражения <token>IN</token> будет <quote>true</quote>, "
"если строка с таким значением находится, и <quote>false</quote> в противном "
"случае (в том числе, когда подзапрос вообще не возвращает строк)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14860(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand row yields null, the result of "
"the <token>IN</token> construct will be null, not false. This is in "
"accordance with SQL's normal rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует "
"принятым в SQL правилам сравнения переменных со значениями NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14868(para) func.xml:14924(para) func.xml:14988(para)
#: func.xml:15045(para)
msgid ""
"As with <token>EXISTS</token>, it's unwise to assume that the subquery will "
"be evaluated completely."
msgstr ""
"Так же, как и с <token>EXISTS</token>, здесь не следует рассчитывать на то, "
"что подзапрос будет всегда выполняться полностью."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14874(replaceable) func.xml:14930(replaceable)
#: func.xml:14994(replaceable) func.xml:14995(replaceable)
#: func.xml:15051(replaceable) func.xml:15086(replaceable)
#: func.xml:15314(replaceable) func.xml:15374(replaceable)
#: func.xml:15386(replaceable)
msgid "row_constructor"
msgstr "конструктор_строки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14877(para)
msgid ""
"The left-hand side of this form of <token>IN</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result. The result of <token>IN</token> is <quote>true</quote> if any equal "
"subquery row is found. The result is <quote>false</quote> if no equal row is "
"found (including the case where the subquery returns no rows)."
msgstr ""
"В левой части этой формы <token>IN</token> записывается конструктор строки "
"(подробнее они рассматриваются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"вернуть ровно столько столбцов, сколько содержит строка в выражении слева. "
"Вычисленные значения левого выражения сравниваются построчно со значениями "
"во всех строках, возвращённых подзапросом. Результатом всего выражения "
"<token>IN</token> будет <quote>true</quote>, если строка с такими значениями "
"находится, и <quote>false</quote> в противном случае (в том числе, когда "
"подзапрос вообще не возвращает строк)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14889(para)
msgid ""
"As usual, null values in the rows are combined per the normal rules of SQL "
"Boolean expressions. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of that "
"row comparison is unknown (null). If all the per-row results are either "
"unequal or null, with at least one null, then the result of <token>IN</"
"token> is null."
msgstr ""
"Как обычно, значения NULL в строках обрабатываются при этом по принятым в "
"SQL правилам сравнения. Две строки считаются равными, если все их "
"соответствующие элементы не равны NULL, но равны между собой; неравными они "
"считаются, когда в них находятся элементы, не равные NULL, и не равные друг "
"другу; в противном случае результат сравнения строк не определён (равен "
"NULL). Если в результатах сравнения строк нет ни одного положительного, но "
"есть хотя бы один NULL, результатом <token>IN</token> будет NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14901(literal) func.xml:15201(literal)
msgid "NOT IN"
msgstr "NOT IN"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14903(synopsis) func.xml:14929(synopsis)
#, no-wrap
msgid "<placeholder-1/> NOT IN (<placeholder-2/>)"
msgstr "<placeholder-1/> NOT IN (<placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14907(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result. The result of <token>NOT IN</token> is <quote>true</"
"quote> if only unequal subquery rows are found (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any equal "
"row is found."
msgstr ""
"Справа в скобках записывается подзапрос, который должен возвращать ровно "
"один столбец. Вычисленное значение левого выражения сравнивается со "
"значением во всех строках, возвращённых подзапросом. Результатом всего "
"выражения <token>NOT IN</token> будет <quote>true</quote>, если находятся "
"только несовпадающие строки (в том числе, когда подзапрос вообще не "
"возвращает строк). Если же находится хотя бы одна подходящая строка, "
"результатом будет <quote>false</quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14916(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand row yields null, the result of "
"the <token>NOT IN</token> construct will be null, not true. This is in "
"accordance with SQL's normal rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>NOT IN</token> возвращает NULL, а не true. Это "
"соответствует принятым в SQL правилам сравнения переменных со значениями "
"NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14933(para)
msgid ""
"The left-hand side of this form of <token>NOT IN</token> is a row "
"constructor, as described in <xref linkend=\"sql-syntax-row-constructors\"/"
">. The right-hand side is a parenthesized subquery, which must return "
"exactly as many columns as there are expressions in the left-hand row. The "
"left-hand expressions are evaluated and compared row-wise to each row of the "
"subquery result. The result of <token>NOT IN</token> is <quote>true</quote> "
"if only unequal subquery rows are found (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any equal "
"row is found."
msgstr ""
"В левой части этой формы <token>NOT IN</token> записывается конструктор "
"строки (подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-"
"row-constructors\"/>). Справа в скобках записывается подзапрос, который "
"должен вернуть ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом. Результатом всего "
"выражения <token>NOT IN</token> будет <quote>true</quote>, если равных строк "
"не найдётся (в том числе, и когда подзапрос не возвращает строк), и "
"<quote>false</quote>, если такие строки есть."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14945(para)
msgid ""
"As usual, null values in the rows are combined per the normal rules of SQL "
"Boolean expressions. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of that "
"row comparison is unknown (null). If all the per-row results are either "
"unequal or null, with at least one null, then the result of <token>NOT IN</"
"token> is null."
msgstr ""
"Как обычно, значения NULL в строках обрабатываются при этом по принятым в "
"SQL правилам сравнения. Две строки считаются равными, если все их "
"соответствующие элементы не равны NULL, но равны между собой; неравными они "
"считаются, когда в них находятся элементы, не равные NULL, и не равные друг "
"другу; в противном случае результат сравнения строк не определён (равен "
"NULL). Если в результатах сравнения строк нет ни одного положительного, но "
"есть хотя бы один NULL, результатом <token>NOT IN</token> будет NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14957(title)
msgid "<literal>ANY</literal>/<literal>SOME</literal>"
msgstr "<literal>ANY</literal>/<literal>SOME</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14960(replaceable) func.xml:14961(replaceable)
#: func.xml:14994(replaceable) func.xml:14995(replaceable)
#: func.xml:15025(replaceable) func.xml:15051(replaceable)
#: func.xml:15086(replaceable) func.xml:15245(replaceable)
#: func.xml:15246(replaceable) func.xml:15282(replaceable)
#: func.xml:15314(replaceable) func.xml:15403(replaceable)
msgid "operator"
msgstr "оператор"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14959(synopsis) func.xml:14993(synopsis) func.xml:15244(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> <placeholder-2/> ANY (<placeholder-3/>)\n"
"<placeholder-4/> <placeholder-5/> SOME (<placeholder-6/>)"
msgstr ""
"<placeholder-1/> <placeholder-2/> ANY (<placeholder-3/>)\n"
"<placeholder-4/> <placeholder-5/> SOME (<placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14964(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result using the given <replaceable>operator</replaceable>, "
"which must yield a Boolean result. The result of <token>ANY</token> is "
"<quote>true</quote> if any true result is obtained. The result is "
"<quote>false</quote> if no true result is found (including the case where "
"the subquery returns no rows)."
msgstr ""
"В правой части конструкции в скобках записывается подзапрос, который должен "
"возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значением в каждой строке результата подзапроса с помощью "
"заданного <replaceable>оператора</replaceable> условия, который должен "
"выдавать логическое значение. Результатом <token>ANY</token> будет "
"<quote>true</quote>, если хотя бы для одной строки условие истинно, и "
"<quote>false</quote> в противном случае (в том числе, и когда подзапрос не "
"возвращает строк)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14975(para)
msgid ""
"<token>SOME</token> is a synonym for <token>ANY</token>. <token>IN</token> "
"is equivalent to <literal>= ANY</literal>."
msgstr ""
"Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>. "
"Конструкцию <token>IN</token> можно записать также записать как <literal>= "
"ANY</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14980(para)
msgid ""
"Note that if there are no successes and at least one right-hand row yields "
"null for the operator's result, the result of the <token>ANY</token> "
"construct will be null, not false. This is in accordance with SQL's normal "
"rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если условие не выполняется ни для одной из строк, а хотя бы "
"для одной строки условный оператор выдаёт NULL, конструкция <token>ANY</"
"token> возвращает NULL, а не false. Это соответствует принятым в SQL "
"правилам сравнения переменных со значениями NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:14998(para)
msgid ""
"The left-hand side of this form of <token>ANY</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result, using the given <replaceable>operator</replaceable>. The result of "
"<token>ANY</token> is <quote>true</quote> if the comparison returns true for "
"any subquery row. The result is <quote>false</quote> if the comparison "
"returns false for every subquery row (including the case where the subquery "
"returns no rows). The result is NULL if the comparison does not return true "
"for any row, and it returns NULL for at least one row."
msgstr ""
"В левой части этой формы <token>ANY</token> записывается конструктор строки "
"(подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"возвращать ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом, с применением "
"заданного <replaceable>оператора</replaceable>. Результатом всего выражения "
"<token>ANY</token> будет <quote>true</quote>, если для какой-либо из строк "
"результатом сравнения будет true, и <quote>false</quote>, если для всех "
"строк результатом сравнения оказывается false (в том числе, и когда "
"подзапрос не возвращает строк). Результат будет равен NULL, если сравнение "
"не возвращает true ни для одной из строк, но как минимум для одной результат "
"сравнения NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15015(para) func.xml:15071(para) func.xml:15099(para)
msgid ""
"See <xref linkend=\"row-wise-comparison\"/> for details about the meaning of "
"a row constructor comparison."
msgstr ""
"Подробнее логика сравнения конструкторов строк описана в <xref remap=\"6\" "
"linkend=\"row-wise-comparison\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15022(literal)
msgid "ALL"
msgstr "ALL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15024(synopsis) func.xml:15050(synopsis) func.xml:15281(synopsis)
#, no-wrap
msgid "<placeholder-1/> <placeholder-2/> ALL (<placeholder-3/>)"
msgstr "<placeholder-1/> <placeholder-2/> ALL (<placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15028(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result using the given <replaceable>operator</replaceable>, "
"which must yield a Boolean result. The result of <token>ALL</token> is "
"<quote>true</quote> if all rows yield true (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any false "
"result is found. The result is NULL if the comparison does not return false "
"for any row, and it returns NULL for at least one row."
msgstr ""
"В правой части конструкции в скобках записывается подзапрос, который должен "
"возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значением в каждой строке результата подзапроса с помощью "
"заданного <replaceable>оператора</replaceable> условия, который должен "
"выдавать логическое значение. Результатом <token>ALL</token> будет "
"<quote>true</quote>, если условие истинно для всех строк (и когда подзапрос "
"не возвращает строк), и <quote>false</quote>, если находятся строки, для "
"которых оно ложно. Результат будет равен NULL, если сравнение не возвращает "
"false ни для одной из строк, но как минимум для одной результат сравнения "
"NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15041(para)
msgid "<token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>."
msgstr ""
"Конструкция <token>NOT IN</token> равнозначна <literal>&lt;&gt; ALL</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15054(para)
msgid ""
"The left-hand side of this form of <token>ALL</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result, using the given <replaceable>operator</replaceable>. The result of "
"<token>ALL</token> is <quote>true</quote> if the comparison returns true for "
"all subquery rows (including the case where the subquery returns no rows). "
"The result is <quote>false</quote> if the comparison returns false for any "
"subquery row. The result is NULL if the comparison does not return false for "
"any subquery row, and it returns NULL for at least one row."
msgstr ""
"В левой части этой формы <token>ALL</token> записывается конструктор строки "
"(подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"возвращать ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом, с применением "
"заданного <replaceable>оператора</replaceable>. Результатом всего выражения "
"<token>ALL</token> будет <quote>true</quote>, если для всех строк подзапроса "
"результатом сравнения будет true (или если подзапрос не возвращает строк), и "
"<quote>false</quote>, если результат сравнения равен false для любой из "
"строк подзапроса. Результат будет равен NULL, если сравнение не возвращает "
"false ни для одной из строк, но как минимум для одной результат сравнения "
"NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15078(title)
msgid "Single-row Comparison"
msgstr "Сравнение единичных строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15080(indexterm)
msgid ""
"<primary>comparison</primary> <secondary>subquery result row</secondary>"
msgstr ""
"<primary>сравнение</primary> <secondary>со строкой-результатом подзапроса</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15085(synopsis)
#, no-wrap
msgid "<placeholder-1/> <placeholder-2/> (<placeholder-3/>)"
msgstr "<placeholder-1/> <placeholder-2/> (<placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15089(para)
msgid ""
"The left-hand side is a row constructor, as described in <xref linkend=\"sql-"
"syntax-row-constructors\"/>. The right-hand side is a parenthesized "
"subquery, which must return exactly as many columns as there are expressions "
"in the left-hand row. Furthermore, the subquery cannot return more than one "
"row. (If it returns zero rows, the result is taken to be null.) The left-"
"hand side is evaluated and compared row-wise to the single subquery result "
"row."
msgstr ""
"В левой части конструкции записывается конструктор строки (подробнее они "
"описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-constructors\"/>). "
"Справа в скобках записывается подзапрос, который должен возвращать ровно "
"столько столбцов, сколько содержит строка в выражении слева. Более того, "
"подзапрос может вернуть максимум одну строку. (Если он не вернёт строк, "
"результатом будет NULL.) Конструкция возвращает результат сравнения строки "
"слева с этой одной строкой результата подзапроса."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15108(title)
msgid "Row and Array Comparisons"
msgstr "Сравнение табличных строк и массивов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15130(indexterm)
msgid "<primary>composite type</primary> <secondary>comparison</secondary>"
msgstr "<primary>составной тип</primary> <secondary>сравнение</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15135(indexterm)
msgid "<primary>row-wise comparison</primary>"
msgstr "<primary>сравнение табличных строк</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15139(indexterm)
msgid "<primary>comparison</primary> <secondary>composite type</secondary>"
msgstr "<primary>сравнение</primary> <secondary>составных типов</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15144(indexterm)
msgid "<primary>comparison</primary> <secondary>row constructor</secondary>"
msgstr ""
"<primary>сравнение</primary> <secondary>конструкторов строк</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15157(para)
msgid ""
"This section describes several specialized constructs for making multiple "
"comparisons between groups of values. These forms are syntactically related "
"to the subquery forms of the previous section, but do not involve "
"subqueries. The forms involving array subexpressions are "
"<productname>PostgreSQL</productname> extensions; the rest are <acronym>SQL</"
"acronym>-compliant. All of the expression forms documented in this section "
"return Boolean (true/false) results."
msgstr ""
"В этом разделе описываются несколько специальных конструкций, позволяющих "
"сравнивать группы значений. Синтаксис этих конструкций связан с формами "
"выражений с подзапросами, описанными в предыдущем разделе, а отличаются они "
"отсутствием подзапросов. Конструкции, в которых в качестве подвыражений "
"используются массивы, являются расширениями <productname>PostgreSQL</"
"productname>; все остальные формы соответствуют стандарту <acronym>SQL</"
"acronym>. Все описанные здесь выражения возвращают логические значения (true/"
"false)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15172(synopsis)
#, no-wrap
msgid "<placeholder-1/> IN (<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/> IN (<placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15176(para)
msgid ""
"The right-hand side is a parenthesized list of scalar expressions. The "
"result is <quote>true</quote> if the left-hand expression's result is equal "
"to any of the right-hand expressions. This is a shorthand notation for "
"<synopsis>\n"
"<replaceable>expression</replaceable> = <replaceable>value1</replaceable>\n"
"OR\n"
"<replaceable>expression</replaceable> = <replaceable>value2</replaceable>\n"
"OR\n"
"...\n"
"</synopsis>"
msgstr ""
"Справа в скобках записывается список скалярных выражений. Результатом будет "
"<quote>true</quote>, если значение левого выражения равняется одному из "
"значений выражений в правой части. Эту конструкцию можно считать краткой "
"записью условия <synopsis>\n"
"<replaceable>выражение</replaceable> = <replaceable>значение1</replaceable>\n"
"OR\n"
"<replaceable>выражение</replaceable> = <replaceable>значение2</replaceable>\n"
"OR\n"
"...\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15191(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand expression yields null, the "
"result of the <token>IN</token> construct will be null, not false. This is "
"in accordance with SQL's normal rules for Boolean combinations of null "
"values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует "
"принятым в SQL правилам сравнения переменных со значениями NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15203(synopsis)
#, no-wrap
msgid "<placeholder-1/> NOT IN (<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/> NOT IN (<placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15207(para)
msgid ""
"The right-hand side is a parenthesized list of scalar expressions. The "
"result is <quote>true</quote> if the left-hand expression's result is "
"unequal to all of the right-hand expressions. This is a shorthand notation "
"for <synopsis>\n"
"<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</"
"replaceable>\n"
"AND\n"
"<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</"
"replaceable>\n"
"AND\n"
"...\n"
"</synopsis>"
msgstr ""
"Справа в скобках записывается список скалярных выражений. Результатом будет "
"<quote>true</quote>, если значение левого выражения не равно ни одному из "
"значений выражений в правой части. Эту конструкцию можно считать краткой "
"записью условия <synopsis>\n"
"<replaceable>выражение</replaceable> &lt;&gt; <replaceable>значение1</"
"replaceable>\n"
"AND\n"
"<replaceable>выражение</replaceable> &lt;&gt; <replaceable>значение2</"
"replaceable>\n"
"AND\n"
"...\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15222(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand expression yields null, the "
"result of the <token>NOT IN</token> construct will be null, not true as one "
"might naively expect. This is in accordance with SQL's normal rules for "
"Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>NOT IN</token> возвращает NULL, а не true, как можно было "
"бы наивно полагать. Это соответствует принятым в SQL правилам сравнения "
"переменных со значениями NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15232(para)
msgid ""
"<literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</"
"literal> in all cases. However, null values are much more likely to trip up "
"the novice when working with <token>NOT IN</token> than when working with "
"<token>IN</token>. It is best to express your condition positively if "
"possible."
msgstr ""
"Выражения <literal>x NOT IN y</literal> и <literal>NOT (x IN y)</literal> "
"полностью равнозначны. Учитывая, что значения NULL могут ввести в "
"заблуждение начинающих скорее в конструкции <token>NOT IN</token>, чем в "
"<token>IN</token>, лучше формулировать условия так, чтобы в них было как "
"можно меньше отрицаний."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15242(title)
msgid "<literal>ANY</literal>/<literal>SOME</literal> (array)"
msgstr "<literal>ANY</literal>/<literal>SOME</literal> (с массивом)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15245(replaceable) func.xml:15246(replaceable)
#: func.xml:15282(replaceable)
msgid "array expression"
msgstr "выражение массива"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15249(para)
msgid ""
"The right-hand side is a parenthesized expression, which must yield an array "
"value. The left-hand expression is evaluated and compared to each element of "
"the array using the given <replaceable>operator</replaceable>, which must "
"yield a Boolean result. The result of <token>ANY</token> is <quote>true</"
"quote> if any true result is obtained. The result is <quote>false</quote> if "
"no true result is found (including the case where the array has zero "
"elements)."
msgstr ""
"Справа в скобках записывается выражение, результатом которого является "
"массив. Вычисленное значение левого выражения сравнивается с каждым "
"элементом этого массива с применением заданного <replaceable>оператора</"
"replaceable> условия, который должен выдавать логическое значение. "
"Результатом <token>ANY</token> будет <quote>true</quote>, если для какого-"
"либо элемента условие истинно, и <quote>false</quote> в противном случае (в "
"том числе, и когда массив оказывается пустым)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15261(para)
msgid ""
"If the array expression yields a null array, the result of <token>ANY</"
"token> will be null. If the left-hand expression yields null, the result of "
"<token>ANY</token> is ordinarily null (though a non-strict comparison "
"operator could possibly yield a different result). Also, if the right-hand "
"array contains any null elements and no true comparison result is obtained, "
"the result of <token>ANY</token> will be null, not false (again, assuming a "
"strict comparison operator). This is in accordance with SQL's normal rules "
"for Boolean combinations of null values."
msgstr ""
"Если значением массива оказывается NULL, результатом <token>ANY</token> "
"также будет NULL. Если NULL получен в левой части, результатом <token>ANY</"
"token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может "
"выдать другой результат). Кроме того, если массив в правой части содержит "
"элементы NULL и ни c одним из элементов условие не выполняется, результатом "
"<token>ANY</token> будет NULL, а не false (опять же, если используется "
"оператор строгого сравнения). Это соответствует принятым в SQL правилам "
"сравнения переменных со значениями NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15273(para)
msgid "<token>SOME</token> is a synonym for <token>ANY</token>."
msgstr ""
"Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15279(title)
msgid "<literal>ALL</literal> (array)"
msgstr "<literal>ALL</literal> (с массивом)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15285(para)
msgid ""
"The right-hand side is a parenthesized expression, which must yield an array "
"value. The left-hand expression is evaluated and compared to each element of "
"the array using the given <replaceable>operator</replaceable>, which must "
"yield a Boolean result. The result of <token>ALL</token> is <quote>true</"
"quote> if all comparisons yield true (including the case where the array has "
"zero elements). The result is <quote>false</quote> if any false result is "
"found."
msgstr ""
"Справа в скобках записывается выражение, результатом которого является "
"массив. Вычисленное значение левого выражения сравнивается с каждым "
"элементом этого массива с применением заданного <replaceable>оператора</"
"replaceable> условия, который должен выдавать логическое значение. "
"Результатом <token>ALL</token> будет <quote>true</quote>, если для всех "
"элементов условие истинно (или массив не содержит элементов), и "
"<quote>false</quote>, если находятся строки, для которых оно ложно."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15297(para)
msgid ""
"If the array expression yields a null array, the result of <token>ALL</"
"token> will be null. If the left-hand expression yields null, the result of "
"<token>ALL</token> is ordinarily null (though a non-strict comparison "
"operator could possibly yield a different result). Also, if the right-hand "
"array contains any null elements and no false comparison result is obtained, "
"the result of <token>ALL</token> will be null, not true (again, assuming a "
"strict comparison operator). This is in accordance with SQL's normal rules "
"for Boolean combinations of null values."
msgstr ""
"Если значением массива оказывается NULL, результатом <token>ALL</token> "
"также будет NULL. Если NULL получен в левой части, результатом <token>ALL</"
"token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может "
"выдать другой результат). Кроме того, если массив в правой части содержит "
"элементы NULL и при этом нет элементов, с которыми условие не выполняется, "
"результатом <token>ALL</token> будет NULL, а не true (опять же, если "
"используется оператор строгого сравнения). Это соответствует принятым в SQL "
"правилам сравнения переменных со значениями NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15311(title)
msgid "Row Constructor Comparison"
msgstr "Сравнение конструкторов строк"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15317(para)
msgid ""
"Each side is a row constructor, as described in <xref linkend=\"sql-syntax-"
"row-constructors\"/>. The two row values must have the same number of "
"fields. Each side is evaluated and they are compared row-wise. Row "
"constructor comparisons are allowed when the <replaceable>operator</"
"replaceable> is <literal>=</literal>, <literal>&lt;&gt;</literal>, "
"<literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> "
"or <literal>&gt;=</literal>. Every row element must be of a type which has a "
"default B-tree operator class or the attempted comparison may generate an "
"error."
msgstr ""
"С обеих сторон представлены конструкторы строк (они описываются в <xref "
"remap=\"6\" linkend=\"sql-syntax-row-constructors\"/>). При этом данные "
"строки должны содержать одинаковое число полей. После вычисления каждой "
"стороны они сравниваются по строкам. Сравнения конструкторов строк возможны "
"с <replaceable>оператором</replaceable> <literal>=</literal>, <literal>&lt;"
"&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;=</literal>, "
"<literal>&gt;</literal> или <literal>&gt;=</literal>. Каждый элемент строки "
"должен иметь тип, для которого определён класс операторов B-дерева; в "
"противном случае при попытке сравнения может возникнуть ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15334(para)
msgid ""
"Errors related to the number or types of elements might not occur if the "
"comparison is resolved using earlier columns."
msgstr ""
"Ошибок, связанных с числом или типов элементов, не должно быть, если "
"сравнение выполняется с ранее полученными столбцами."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15340(para)
msgid ""
"The <literal>=</literal> and <literal>&lt;&gt;</literal> cases work slightly "
"differently from the others. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of the "
"row comparison is unknown (null)."
msgstr ""
"Сравнения <literal>=</literal> и <literal>&lt;&gt;</literal> несколько "
"отличаются от других. С этими операторами две строки считаются равными, если "
"все их соответствующие поля не равны NULL и равны между собой, и неравными, "
"если какие-либо соответствующие их поля не NULL и не равны между собой. В "
"противном случае результатом сравнения будет неопределённость (NULL)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15348(para)
msgid ""
"For the <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</"
"literal> and <literal>&gt;=</literal> cases, the row elements are compared "
"left-to-right, stopping as soon as an unequal or null pair of elements is "
"found. If either of this pair of elements is null, the result of the row "
"comparison is unknown (null); otherwise comparison of this pair of elements "
"determines the result. For example, <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</"
"literal> yields true, not null, because the third pair of elements are not "
"considered."
msgstr ""
"С операторами <literal>&lt;</literal>, <literal>&lt;=</literal>, "
"<literal>&gt;</literal> и <literal>&gt;=</literal> элементы строк "
"сравниваются слева направо до тех пор, пока не будет найдена пара неравных "
"элементов или значений NULL. Если любым из элементов пары оказывается NULL, "
"результатом сравнения будет неопределённость (NULL), в противном случае "
"результат всего выражения определяется результатом сравнения этих двух "
"элементов. Например, результатом <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</"
"literal> будет true, а не NULL, так как третья пара элементов не принимается "
"в рассмотрение."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15361(para)
msgid ""
"Prior to <productname>PostgreSQL</productname> 8.2, the <literal>&lt;</"
"literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and <literal>&gt;"
"=</literal> cases were not handled per SQL specification. A comparison like "
"<literal>ROW(a,b) &lt; ROW(c,d)</literal> was implemented as <literal>a &lt; "
"c AND b &lt; d</literal> whereas the correct behavior is equivalent to "
"<literal>a &lt; c OR (a = c AND b &lt; d)</literal>."
msgstr ""
"До версии 8.2 <productname>PostgreSQL</productname> обрабатывал условия "
"<literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> и "
"<literal>&gt;=</literal> не так, как это описано в стандарте SQL. Сравнение "
"<literal>ROW(a,b) &lt; ROW(c,d)</literal> выполнялось как <literal>a &lt; c "
"AND b &lt; d</literal>, тогда как по стандарту должно быть <literal>a &lt; c "
"OR (a = c AND b &lt; d)</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15373(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS DISTINCT FROM <placeholder-2/>"
msgstr "<placeholder-1/> IS DISTINCT FROM <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15377(para)
msgid ""
"This construct is similar to a <literal>&lt;&gt;</literal> row comparison, "
"but it does not yield null for null inputs. Instead, any null value is "
"considered unequal to (distinct from) any non-null value, and any two nulls "
"are considered equal (not distinct). Thus the result will either be true or "
"false, never null."
msgstr ""
"Эта конструкция похожа на сравнение строк с оператором <literal>&lt;&gt;</"
"literal>, но со значениями NULL она выдаёт не NULL. Любое значение NULL для "
"неё считается неравным (отличным от) любому значению не NULL, а два NULL "
"считаются равными (не различными). Таким образом, результатом такого "
"выражения будет true или false, но не NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15385(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS NOT DISTINCT FROM <placeholder-2/>"
msgstr "<placeholder-1/> IS NOT DISTINCT FROM <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15389(para)
msgid ""
"This construct is similar to a <literal>=</literal> row comparison, but it "
"does not yield null for null inputs. Instead, any null value is considered "
"unequal to (distinct from) any non-null value, and any two nulls are "
"considered equal (not distinct). Thus the result will always be either true "
"or false, never null."
msgstr ""
"Эта конструкция похожа на сравнение строк с оператором <literal>=</literal>, "
"но со значениями NULL она выдаёт не NULL. Любое значение NULL для неё "
"считается неравным (отличным от) любому значению не NULL, а два NULL "
"считаются равными (не различными). Таким образом, результатом такого "
"выражения всегда будет true или false, но не NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15400(title)
msgid "Composite Type Comparison"
msgstr "Сравнение составных типов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15403(replaceable)
msgctxt "replaceable"
msgid "record"
msgstr "запись"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15406(para)
msgid ""
"The SQL specification requires row-wise comparison to return NULL if the "
"result depends on comparing two NULL values or a NULL and a non-NULL. "
"<productname>PostgreSQL</productname> does this only when comparing the "
"results of two row constructors (as in <xref linkend=\"row-wise-comparison\"/"
">) or comparing a row constructor to the output of a subquery (as in <xref "
"linkend=\"functions-subquery\"/>). In other contexts where two composite-"
"type values are compared, two NULL field values are considered equal, and a "
"NULL is considered larger than a non-NULL. This is necessary in order to "
"have consistent sorting and indexing behavior for composite types."
msgstr ""
"Стандарт SQL требует, чтобы при сравнении строк возвращался NULL, если "
"результат зависит от сравнения двух значений NULL или значения NULL и не "
"NULL. <productname>PostgreSQL</productname> выполняет это требование только "
"при сравнении строк, созданных конструкторами (как описано в <xref remap="
"\"6\" linkend=\"row-wise-comparison\"/>), или строки, созданной "
"конструктором, со строкой результата подзапроса (как было описано в <xref "
"remap=\"6\" linkend=\"functions-subquery\"/>). В других контекстах при "
"сравнении полей составных типов два значения NULL считаются равными, а любое "
"значение не NULL полагается меньшим NULL. Это отклонение от правила "
"необходимо для полноценной реализации сортировки и индексирования составных "
"типов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15419(para)
msgid ""
"Each side is evaluated and they are compared row-wise. Composite type "
"comparisons are allowed when the <replaceable>operator</replaceable> is "
"<literal>=</literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, "
"<literal>&lt;=</literal>, <literal>&gt;</literal> or <literal>&gt;=</"
"literal>, or has semantics similar to one of these. (To be specific, an "
"operator can be a row comparison operator if it is a member of a B-tree "
"operator class, or is the negator of the <literal>=</literal> member of a B-"
"tree operator class.) The default behavior of the above operators is the "
"same as for <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors "
"(see <xref linkend=\"row-wise-comparison\"/>)."
msgstr ""
"После вычисления каждой стороны они сравниваются по строкам. Сравнения "
"составных типов возможны с <replaceable>оператором</replaceable> <literal>=</"
"literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;"
"=</literal>, <literal>&gt;</literal> или <literal>&gt;=</literal>, либо "
"другим подобным. (Точнее, оператором сравнения строк может быть любой "
"оператор, входящий в класс операторов B-дерева, либо обратный к оператору "
"<literal>=</literal>, входящему в класс операторов B-дерева.) По умолчанию "
"вышеперечисленные операторы действуют так же, как выражение <literal>IS "
"[ NOT ] DISTINCT FROM</literal> для конструкторов строк (см. <xref remap="
"\"4\" linkend=\"row-wise-comparison\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15436(para)
msgid ""
"To support matching of rows which include elements without a default B-tree "
"operator class, the following operators are defined for composite type "
"comparison: <literal>*=</literal>, <literal>*&lt;&gt;</literal>, "
"<literal>*&lt;</literal>, <literal>*&lt;=</literal>, <literal>*&gt;</"
"literal>, and <literal>*&gt;=</literal>. These operators compare the "
"internal binary representation of the two rows. Two rows might have a "
"different binary representation even though comparisons of the two rows with "
"the equality operator is true. The ordering of rows under these comparison "
"operators is deterministic but not otherwise meaningful. These operators are "
"used internally for materialized views and might be useful for other "
"specialized purposes such as replication but are not intended to be "
"generally useful for writing queries."
msgstr ""
"Для поддержки сравнения строк с элементами, для которых не определён класс "
"операторов B-дерева по умолчанию, введены следующие операторы: <literal>*=</"
"literal>, <literal>*&lt;&gt;</literal>, <literal>*&lt;</literal>, "
"<literal>*&lt;=</literal>, <literal>*&gt;</literal> и <literal>*&gt;=</"
"literal>. Эти операторы сравнивают внутреннее двоичное представление двух "
"строк. Учтите, что две строки могут иметь различное двоичное представление, "
"даже когда при сравнении оператором равенства считаются равными. Порядок "
"строк с такими операторами детерминирован, но не несёт смысловой нагрузки. "
"Данные операторы применяются внутри системы для материализованных "
"представлений и могут быть полезны для других специальных целей (например, "
"репликации), но, вообще говоря, не предназначены для использования в обычных "
"запросах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15459(title)
msgid "Set Returning Functions"
msgstr "Функции, возвращающие множества"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15461(indexterm)
msgid ""
"<primary>set returning functions</primary> <secondary>functions</secondary>"
msgstr ""
"<primary>функции, возвращающие множества</primary> <secondary>функции</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15466(indexterm)
msgid "<primary>generate_series</primary>"
msgstr "<primary>generate_series</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15470(para)
msgid ""
"This section describes functions that possibly return more than one row. The "
"most widely used functions in this class are series generating functions, as "
"detailed in <xref linkend=\"functions-srf-series\"/> and <xref linkend="
"\"functions-srf-subscripts\"/>. Other, more specialized set-returning "
"functions are described elsewhere in this manual. See <xref linkend="
"\"queries-tablefunctions\"/> for ways to combine multiple set-returning "
"functions."
msgstr ""
"В этом разделе описаны функции, которые могут возвращать не одну, а "
"множество строк. Чаще всего из их числа используются функции, генерирующие "
"ряды значений, которые перечислены в <xref remap=\"6\" linkend=\"functions-"
"srf-series\"/> и <xref remap=\"6\" linkend=\"functions-srf-subscripts\"/>. "
"Другие, более специализированные функции множеств описаны в других разделах "
"этой документации. Варианты комбинирования нескольких функций, возвращающих "
"множества строк, описаны в <xref remap=\"6\" linkend=\"queries-tablefunctions"
"\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15481(title)
msgid "Series Generating Functions"
msgstr "Функции, генерирующие ряды значений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15494(parameter) func.xml:15504(parameter)
#: func.xml:15514(parameter)
msgid "start"
msgstr "start"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15494(parameter) func.xml:15504(parameter)
#: func.xml:15514(parameter)
msgid "stop"
msgstr "stop"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15494(function)
msgid "generate_series(<placeholder-1/>, <placeholder-2/>)"
msgstr "generate_series(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15495(entry) func.xml:15505(entry)
msgid "<type>int</type>, <type>bigint</type> or <type>numeric</type>"
msgstr "<type>int</type>, <type>bigint</type> или <type>numeric</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15496(entry)
msgid ""
"<type>setof int</type>, <type>setof bigint</type>, or <type>setof numeric</"
"type> (same as argument type)"
msgstr ""
"<type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</"
"type> (определяется типом аргумента)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15497(entry)
msgid ""
"Generate a series of values, from <parameter>start</parameter> to "
"<parameter>stop</parameter> with a step size of one"
msgstr ""
"Выдаёт ряд целых чисел от <parameter>start</parameter> до <parameter>stop</"
"parameter> с шагом 1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15504(parameter) func.xml:15514(parameter)
msgid "step"
msgstr "step"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15504(function)
msgid "generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15506(entry)
msgid ""
"<type>setof int</type>, <type>setof bigint</type> or <type>setof numeric</"
"type> (same as argument type)"
msgstr ""
"<type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</"
"type> (определяется типом аргумента)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15507(entry) func.xml:15517(entry)
msgid ""
"Generate a series of values, from <parameter>start</parameter> to "
"<parameter>stop</parameter> with a step size of <parameter>step</parameter>"
msgstr ""
"Выдаёт ряд значений от <parameter>start</parameter> до <parameter>stop</"
"parameter> с заданным шагом (<parameter>step</parameter>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15514(function)
msgid ""
"generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15515(entry)
msgid "<type>timestamp</type> or <type>timestamp with time zone</type>"
msgstr "<type>timestamp</type> или <type>timestamp with time zone</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15516(entry)
msgid ""
"<type>setof timestamp</type> or <type>setof timestamp with time zone</type> "
"(same as argument type)"
msgstr ""
"<type>setof timestamp</type> или <type>setof timestamp with time zone</type> "
"(определяется типом аргумента)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15534(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM generate_series(2,4);\n"
" generate_series\n"
"-----------------\n"
"               2\n"
"               3\n"
"               4\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(5,1,-2);\n"
" generate_series\n"
"-----------------\n"
"               5\n"
"               3\n"
"               1\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(4,3);\n"
" generate_series\n"
"-----------------\n"
"(0 rows)\n"
"\n"
"SELECT generate_series(1.1, 4, 1.3);\n"
" generate_series \n"
"-----------------\n"
"             1.1\n"
"             2.4\n"
"             3.7\n"
"(3 rows)\n"
"\n"
"-- this example relies on the date-plus-integer operator\n"
"SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);\n"
"   dates\n"
"------------\n"
" 2004-02-05\n"
" 2004-02-12\n"
" 2004-02-19\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,\n"
"                              '2008-03-04 12:00', '10 hours');\n"
"   generate_series   \n"
"---------------------\n"
" 2008-03-01 00:00:00\n"
" 2008-03-01 10:00:00\n"
" 2008-03-01 20:00:00\n"
" 2008-03-02 06:00:00\n"
" 2008-03-02 16:00:00\n"
" 2008-03-03 02:00:00\n"
" 2008-03-03 12:00:00\n"
" 2008-03-03 22:00:00\n"
" 2008-03-04 08:00:00\n"
"(9 rows)"
msgstr ""
"SELECT * FROM generate_series(2,4);\n"
" generate_series\n"
"-----------------\n"
"               2\n"
"               3\n"
"               4\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(5,1,-2);\n"
" generate_series\n"
"-----------------\n"
"               5\n"
"               3\n"
"               1\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(4,3);\n"
" generate_series\n"
"-----------------\n"
"(0 rows)\n"
"\n"
"SELECT generate_series(1.1, 4, 1.3);\n"
" generate_series \n"
"-----------------\n"
"             1.1\n"
"             2.4\n"
"             3.7\n"
"(3 rows)\n"
"\n"
"-- этот пример задействует оператор прибавления к дате целого числа\n"
"SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);\n"
"   dates\n"
"------------\n"
" 2004-02-05\n"
" 2004-02-12\n"
" 2004-02-19\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,\n"
"                              '2008-03-04 12:00', '10 hours');\n"
"   generate_series   \n"
"---------------------\n"
" 2008-03-01 00:00:00\n"
" 2008-03-01 10:00:00\n"
" 2008-03-01 20:00:00\n"
" 2008-03-02 06:00:00\n"
" 2008-03-02 16:00:00\n"
" 2008-03-03 02:00:00\n"
" 2008-03-03 12:00:00\n"
" 2008-03-03 22:00:00\n"
" 2008-03-04 08:00:00\n"
"(9 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15527(para)
msgid ""
"When <parameter>step</parameter> is positive, zero rows are returned if "
"<parameter>start</parameter> is greater than <parameter>stop</parameter>. "
"Conversely, when <parameter>step</parameter> is negative, zero rows are "
"returned if <parameter>start</parameter> is less than <parameter>stop</"
"parameter>. Zero rows are also returned for <literal>NULL</literal> inputs. "
"It is an error for <parameter>step</parameter> to be zero. Some examples "
"follow: <placeholder-1/>"
msgstr ""
"Если заданный шаг (<parameter>step</parameter>) положительный, а "
"<parameter>start</parameter> оказывается больше <parameter>stop</parameter>, "
"эти функции возвращают 0 строк. Тот же результат будет, если "
"<parameter>step</parameter> меньше 0, а <parameter>start</parameter> меньше "
"<parameter>stop</parameter>, или если какой-либо аргумент равен "
"<literal>NULL</literal>. Если же <parameter>step</parameter> будет равен 0, "
"произойдёт ошибка. Несколько примеров: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15591(title)
msgid "Subscript Generating Functions"
msgstr "Функции, генерирующие индексы массивов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15603(parameter) func.xml:15611(parameter)
msgid "array anyarray"
msgstr "array anyarray"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15603(parameter) func.xml:15611(parameter)
msgid "dim int"
msgstr "dim int"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15603(function)
msgid "generate_subscripts(<placeholder-1/>, <placeholder-2/>)"
msgstr "generate_subscripts(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15604(type) func.xml:15612(type)
msgid "setof int"
msgstr "setof int"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15605(entry)
msgid "Generate a series comprising the given array's subscripts."
msgstr ""
"Выдаёт ряд значений для использования в качестве индекса данного массива."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15611(parameter)
msgid "reverse boolean"
msgstr "reverse boolean"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15611(function)
msgid ""
"generate_subscripts(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""
"generate_subscripts(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15613(entry)
msgid ""
"Generate a series comprising the given array's subscripts. When "
"<parameter>reverse</parameter> is true, the series is returned in reverse "
"order."
msgstr ""
"Выдаёт ряд значений для использования в качестве индекса данного массива. "
"Если параметр <parameter>reverse</parameter> равен true, значения выдаются "
"от большего к меньшему."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15624(indexterm)
msgid "<primary>generate_subscripts</primary>"
msgstr "<primary>generate_subscripts</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15635(programlisting)
#, no-wrap
msgid ""
"-- basic usage\n"
"SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;\n"
" s \n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"(4 rows)\n"
"\n"
"-- presenting an array, the subscript and the subscripted\n"
"-- value requires a subquery\n"
"SELECT * FROM arrays;\n"
"         a          \n"
"--------------------\n"
" {-1,-2}\n"
" {100,200,300}\n"
"(2 rows)\n"
"\n"
"SELECT a AS array, s AS subscript, a[s] AS value\n"
"FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;\n"
"     array     | subscript | value\n"
"---------------+-----------+-------\n"
" {-1,-2}       |         1 |    -1\n"
" {-1,-2}       |         2 |    -2\n"
" {100,200,300} |         1 |   100\n"
" {100,200,300} |         2 |   200\n"
" {100,200,300} |         3 |   300\n"
"(5 rows)\n"
"\n"
"-- unnest a 2D array\n"
"CREATE OR REPLACE FUNCTION unnest2(anyarray)\n"
"RETURNS SETOF anyelement AS $$\n"
"select $1[i][j]\n"
"   from generate_subscripts($1,1) g1(i),\n"
"        generate_subscripts($1,2) g2(j);\n"
"$$ LANGUAGE sql IMMUTABLE;\n"
"CREATE FUNCTION\n"
"SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);\n"
" unnest2 \n"
"---------\n"
"       1\n"
"       2\n"
"       3\n"
"       4\n"
"(4 rows)"
msgstr ""
"-- простой пример использования\n"
"SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;\n"
" s \n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"(4 rows)\n"
"\n"
"-- для показанного массива получение индекса и обращение\n"
"-- к элементу по индексу выполняется с помощью подзапроса\n"
"SELECT * FROM arrays;\n"
"         a          \n"
"--------------------\n"
" {-1,-2}\n"
" {100,200,300}\n"
"(2 rows)\n"
"\n"
"SELECT a AS array, s AS subscript, a[s] AS value\n"
"FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;\n"
"     array     | subscript | value\n"
"---------------+-----------+-------\n"
" {-1,-2}       |         1 |    -1\n"
" {-1,-2}       |         2 |    -2\n"
" {100,200,300} |         1 |   100\n"
" {100,200,300} |         2 |   200\n"
" {100,200,300} |         3 |   300\n"
"(5 rows)\n"
"\n"
"-- разворачивание двумерного массива\n"
"CREATE OR REPLACE FUNCTION unnest2(anyarray)\n"
"RETURNS SETOF anyelement AS $$\n"
"select $1[i][j]\n"
"   from generate_subscripts($1,1) g1(i),\n"
"        generate_subscripts($1,2) g2(j);\n"
"$$ LANGUAGE sql IMMUTABLE;\n"
"CREATE FUNCTION\n"
"SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);\n"
" unnest2 \n"
"---------\n"
"       1\n"
"       2\n"
"       3\n"
"       4\n"
"(4 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15628(para)
msgid ""
"<function>generate_subscripts</function> is a convenience function that "
"generates the set of valid subscripts for the specified dimension of the "
"given array. Zero rows are returned for arrays that do not have the "
"requested dimension, or for NULL arrays (but valid subscripts are returned "
"for NULL array elements). Some examples follow: <placeholder-1/>"
msgstr ""
"Функция <function>generate_subscripts</function> позволяет упростить "
"получение всего набора индексов для указанной размерности заданного массива. "
"Она выдаёт 0 строк, если в массиве нет указанной размерности или сам массив "
"равен NULL (хотя для элементов, равных NULL, индексы будут выданы, как и для "
"любых других). Взгляните на следующие примеры: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15685(indexterm)
msgid "<primary>ordinality</primary>"
msgstr "<primary>ordinality</primary>"

#. +> REL_10
#: func.xml:15696(programlisting)
#, no-wrap
msgid ""
"-- set returning function WITH ORDINALITY\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_xact         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_wal          | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 rows)"
msgstr ""
"-- функция, возвращающая множество, с нумерацией\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_xact         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_wal          | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 строк)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15689(para)
msgid ""
"When a function in the <literal>FROM</literal> clause is suffixed by "
"<literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is appended "
"to the output which starts from 1 and increments by 1 for each row of the "
"function's output. This is most useful in the case of set returning "
"functions such as <function>unnest()</function>. <placeholder-1/>"
msgstr ""
"Когда после функции в предложении <literal>FROM</literal> добавляется "
"<literal>WITH ORDINALITY</literal>, в выходные данные добавляется столбец "
"типа <type>bigint</type>, числа в котором начинаются с 1 и увеличиваются на "
"1 для каждой строки, выданной функцией. В первую очередь это полезно для "
"функций, возвращающих множества, например, <function>unnest()</function>. "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15727(title)
msgid "System Information Functions"
msgstr "Системные информационные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15729(para)
msgid ""
"<xref linkend=\"functions-info-session-table\"/> shows several functions "
"that extract session and system information."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-session-table\"/> перечислен "
"ряд функций, предназначенных для получения информации о текущем сеансе и "
"системе."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15734(para)
msgid ""
"In addition to the functions listed in this section, there are a number of "
"functions related to the statistics system that also provide system "
"information. See <xref linkend=\"monitoring-stats-views\"/> for more "
"information."
msgstr ""
"В дополнение к перечисленным здесь функциям существуют также функции, "
"связанные с подсистемой статистики, которые тоже предоставляют системную "
"информацию. Подробнее они рассматриваются в <xref remap=\"6\" linkend="
"\"monitoring-stats-views\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15742(title)
msgid "Session Information Functions"
msgstr "Функции получения информации о сеансе"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15745(entry) func.xml:16215(entry) func.xml:16673(entry)
#: func.xml:16957(entry) func.xml:17273(entry) func.xml:17332(entry)
#: func.xml:17363(entry) func.xml:17496(entry) func.xml:17605(entry)
#: func.xml:17703(entry) func.xml:17767(entry) func.xml:17847(entry)
#: func.xml:17887(entry) func.xml:18245(entry) func.xml:18363(entry)
#: func.xml:18498(entry) func.xml:18753(entry) func.xml:18833(entry)
#: func.xml:18924(entry) func.xml:19419(entry) func.xml:19671(entry)
#: func.xml:19742(entry) func.xml:19825(entry) func.xml:19903(entry)
#: func.xml:20070(entry) func.xml:20428(entry) func.xml:20515(entry)
#: func.xml:20652(entry)
msgid "Name"
msgstr "Имя"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15750(function)
msgid "current_catalog"
msgstr "current_catalog"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15752(entry)
msgid ""
"name of current database (called <quote>catalog</quote> in the SQL standard)"
msgstr ""
"имя текущей базы данных (в стандарте SQL она называется <quote>каталогом</"
"quote>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15756(function)
msgid "current_database()"
msgstr "current_database()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15758(entry)
msgid "name of current database"
msgstr "имя текущей базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15762(function)
msgid "current_query()"
msgstr "current_query()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15764(entry)
msgid ""
"text of the currently executing query, as submitted by the client (might "
"contain more than one statement)"
msgstr ""
"текст запроса, выполняемого в данный момент, в том виде, в каком его передал "
"клиент (может состоять из нескольких операторов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15769(function)
msgid "current_role"
msgstr "current_role"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15771(entry) func.xml:15896(entry)
msgid "equivalent to <function>current_user</function>"
msgstr "синоним <function>current_user</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15775(function)
msgid "current_schema"
msgstr "current_schema"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15775(literal)
msgid "<placeholder-1/>[()]"
msgstr "<placeholder-1/>[()]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15777(entry)
msgid "name of current schema"
msgstr "имя текущей схемы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15781(function)
msgid "current_schemas(<placeholder-1/>)"
msgstr "current_schemas(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15782(type)
msgid "name[]"
msgstr "name[]"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15783(entry)
msgid "names of schemas in search path, optionally including implicit schemas"
msgstr ""
"имена схем в пути поиска, возможно включая схемы, добавляемые в него неявно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15787(function)
msgid "current_user"
msgstr "current_user"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15789(entry)
msgid "user name of current execution context"
msgstr "имя пользователя в текущем контексте выполнения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15793(function)
msgid "inet_client_addr()"
msgstr "inet_client_addr()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15795(entry)
msgid "address of the remote connection"
msgstr "адрес удалённой стороны соединения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15799(function)
msgid "inet_client_port()"
msgstr "inet_client_port()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15801(entry)
msgid "port of the remote connection"
msgstr "порт удалённой стороны соединения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15805(function)
msgid "inet_server_addr()"
msgstr "inet_server_addr()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15807(entry)
msgid "address of the local connection"
msgstr "адрес локальной стороны соединения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15811(function)
msgid "inet_server_port()"
msgstr "inet_server_port()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15813(entry)
msgid "port of the local connection"
msgstr "порт локальной стороны соединения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15818(function)
msgid "pg_backend_pid()"
msgstr "pg_backend_pid()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15820(entry)
msgid "Process ID of the server process attached to the current session"
msgstr "код серверного процесса, обслуживающего текущий сеанс"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15826(function)
msgid "pg_blocking_pids(<placeholder-1/>)"
msgstr "pg_blocking_pids(<placeholder-1/>)"

#. +> REL_10
#: func.xml:15828(entry)
msgid ""
"Process ID(s) that are blocking specified server process ID from acquiring a "
"lock"
msgstr ""
"идентификаторы процессов, не дающих серверному процессу с определённым ID "
"получить блокировку"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15832(function)
msgid "pg_conf_load_time()"
msgstr "pg_conf_load_time()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15834(entry)
msgid "configuration load time"
msgstr "время загрузки конфигурации"

#. +> REL_10
#: func.xml:15838(function)
msgid "pg_current_logfile(<optional><placeholder-1/></optional>)"
msgstr "pg_current_logfile(<optional><placeholder-1/></optional>)"

#. +> REL_10
#: func.xml:15840(entry)
msgid ""
"Primary log file name, or log in the requested format, currently in use by "
"the logging collector"
msgstr ""
"имя файла главного журнала или журнала в заданном формате, который в "
"настоящее время используется сборщиком сообщений"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15845(function)
msgid "pg_my_temp_schema()"
msgstr "pg_my_temp_schema()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15847(entry)
msgid "OID of session's temporary schema, or 0 if none"
msgstr "OID временной схемы этого сеанса или 0, если её нет"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15851(function)
msgid "pg_is_other_temp_schema(<placeholder-1/>)"
msgstr "pg_is_other_temp_schema(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15853(entry)
msgid "is schema another session's temporary schema?"
msgstr "является ли заданная схема временной в другом сеансе?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15857(function)
msgid "pg_listening_channels()"
msgstr "pg_listening_channels()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15859(entry)
msgid "channel names that the session is currently listening on"
msgstr "имена каналов, по которым текущий сеанс принимает сигналы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15863(function)
msgid "pg_notification_queue_usage()"
msgstr "pg_notification_queue_usage()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15864(type)
msgid "double"
msgstr "double"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15865(entry)
msgid ""
"fraction of the asynchronous notification queue currently occupied (0-1)"
msgstr "занятая доля очереди асинхронных уведомлений (0-1)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15869(function)
msgid "pg_postmaster_start_time()"
msgstr "pg_postmaster_start_time()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15871(entry)
msgid "server start time"
msgstr "время запуска сервера"

#. +> REL_10
#: func.xml:15875(function)
msgid "pg_safe_snapshot_blocking_pids(<placeholder-1/>)"
msgstr "pg_safe_snapshot_blocking_pids(<placeholder-1/>)"

#. +> REL_10
#: func.xml:15877(entry)
msgid ""
"Process ID(s) that are blocking specified server process ID from acquiring a "
"safe snapshot"
msgstr ""
"Идентификаторы процессов, не дающих серверному процессу с определённым ID "
"получить безопасный снимок"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15881(function)
msgid "pg_trigger_depth()"
msgstr "pg_trigger_depth()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15883(entry)
msgid ""
"current nesting level of <productname>PostgreSQL</productname> triggers (0 "
"if not called, directly or indirectly, from inside a trigger)"
msgstr ""
"текущий уровень вложенности в триггерах <productname>PostgreSQL</"
"productname> (0, если эта функция вызывается (прямо или косвенно) не из тела "
"триггера)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15888(function)
msgid "session_user"
msgstr "session_user"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15890(entry)
msgid "session user name"
msgstr "имя пользователя сеанса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15894(function)
msgctxt "function"
msgid "user"
msgstr "user"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15900(function)
msgid "version()"
msgstr "version()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15902(entry)
msgid ""
"<productname>PostgreSQL</productname> version information. See also <xref "
"linkend=\"guc-server-version-num\"/> for a machine-readable version."
msgstr ""
"информация о версии <productname>PostgreSQL</productname>. Также можно "
"прочитать версию в машинно-ориентированном виде, обратившись к переменной "
"<xref linkend=\"guc-server-version-num\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15909(para)
msgid ""
"<function>current_catalog</function>, <function>current_role</function>, "
"<function>current_schema</function>, <function>current_user</function>, "
"<function>session_user</function>, and <function>user</function> have "
"special syntactic status in <acronym>SQL</acronym>: they must be called "
"without trailing parentheses. (In PostgreSQL, parentheses can optionally be "
"used with <function>current_schema</function>, but not with the others.)"
msgstr ""
"Функции <function>current_catalog</function>, <function>current_role</"
"function>, <function>current_schema</function>, <function>current_user</"
"function>, <function>session_user</function> и <function>user</function> "
"имеют особый синтаксический статус в <acronym>SQL</acronym>: они должны "
"вызываться без скобок после имени. (PostgreSQL позволяет добавить скобки в "
"вызове <function>current_schema</function>, но не других функций.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15922(indexterm)
msgid "<primary>current_catalog</primary>"
msgstr "<primary>current_catalog</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15926(indexterm)
msgid "<primary>current_database</primary>"
msgstr "<primary>current_database</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15930(indexterm)
msgid "<primary>current_query</primary>"
msgstr "<primary>current_query</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15934(indexterm)
msgid "<primary>current_role</primary>"
msgstr "<primary>current_role</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15938(indexterm)
msgid "<primary>current_schema</primary>"
msgstr "<primary>current_schema</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15942(indexterm)
msgid "<primary>current_schemas</primary>"
msgstr "<primary>current_schemas</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15946(indexterm)
msgid "<primary>current_user</primary>"
msgstr "<primary>current_user</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15950(indexterm)
msgid "<primary>pg_backend_pid</primary>"
msgstr "<primary>pg_backend_pid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15954(indexterm)
msgid "<primary>schema</primary> <secondary>current</secondary>"
msgstr "<primary>схема</primary> <secondary>текущая</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15959(indexterm)
msgid "<primary>search path</primary> <secondary>current</secondary>"
msgstr "<primary>путь поиска</primary> <secondary>текущий</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15964(indexterm)
msgid "<primary>session_user</primary>"
msgstr "<primary>session_user</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15968(indexterm)
msgid "<primary>user</primary> <secondary>current</secondary>"
msgstr "<primary>пользователь</primary> <secondary>текущий</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15973(indexterm)
msgid "<primary>user</primary>"
msgstr "<primary>пользователь</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15977(para)
msgid ""
"The <function>session_user</function> is normally the user who initiated the "
"current database connection; but superusers can change this setting with "
"<xref linkend=\"sql-set-session-authorization\"/>. The "
"<function>current_user</function> is the user identifier that is applicable "
"for permission checking. Normally it is equal to the session user, but it "
"can be changed with <xref linkend=\"sql-set-role\"/>. It also changes during "
"the execution of functions with the attribute <literal>SECURITY DEFINER</"
"literal>. In Unix parlance, the session user is the <quote>real user</quote> "
"and the current user is the <quote>effective user</quote>. "
"<function>current_role</function> and <function>user</function> are synonyms "
"for <function>current_user</function>. (The SQL standard draws a distinction "
"between <function>current_role</function> and <function>current_user</"
"function>, but <productname>PostgreSQL</productname> does not, since it "
"unifies users and roles into a single kind of entity.)"
msgstr ""
"Функция <function>session_user</function> обычно возвращает имя "
"пользователя, установившего текущее соединение с базой данных, но "
"суперпользователи могут изменить это имя, выполнив команду <xref linkend="
"\"sql-set-session-authorization\"/>. Функция <function>current_user</"
"function> возвращает идентификатор пользователя, по которому будут "
"проверяться его права. Обычно это тот же пользователь, что и пользователь "
"сеанса, но его можно сменить с помощью <xref linkend=\"sql-set-role\"/>. "
"Этот идентификатор также меняется при выполнении функций с атрибутом "
"<literal>SECURITY DEFINER</literal>. На языке Unix пользователь сеанса "
"называется <quote>реальным</quote>, а текущий — <quote>эффективным</quote>. "
"Имена <function>current_role</function> и <function>user</function> являются "
"синонимами <function>current_user</function>. (В стандарте SQL "
"<function>current_role</function> и <function>current_user</function> имеют "
"разное значение, но в <productname>PostgreSQL</productname> они не "
"различаются, так как пользователи и роли объединены в единую сущность.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:15996(para)
msgid ""
"<function>current_schema</function> returns the name of the schema that is "
"first in the search path (or a null value if the search path is empty). This "
"is the schema that will be used for any tables or other named objects that "
"are created without specifying a target schema. "
"<function>current_schemas(boolean)</function> returns an array of the names "
"of all schemas presently in the search path. The Boolean option determines "
"whether or not implicitly included system schemas such as "
"<literal>pg_catalog</literal> are included in the returned search path."
msgstr ""
"Функция <function>current_schema</function> возвращает имя схемы, которая "
"стоит первой в пути поиска (или NULL, если путь поиска пуст). Эта схема "
"будет задействована при создании таблиц или других именованных объектов, "
"если целевая схема не указана явно. Функция "
"<function>current_schemas(boolean)</function> возвращает массив имён всех "
"схем, находящихся в пути поиска. Её логический параметр определяет, будут ли "
"включаться в результат неявно добавляемые в путь поиска системные схемы, "
"такие как <literal>pg_catalog</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16010(programlisting)
#, no-wrap
msgid "SET search_path TO <replaceable>schema</replaceable> <optional>, <replaceable>schema</replaceable>, ...</optional>"
msgstr "SET search_path TO <replaceable>схема</replaceable> <optional>, <replaceable>схема</replaceable>, ...</optional>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16008(para)
msgid ""
"The search path can be altered at run time. The command is: <placeholder-1/>"
msgstr ""
"Путь поиска можно изменить во время выполнения следующей командой: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16016(indexterm)
msgid "<primary>inet_client_addr</primary>"
msgstr "<primary>inet_client_addr</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16020(indexterm)
msgid "<primary>inet_client_port</primary>"
msgstr "<primary>inet_client_port</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16024(indexterm)
msgid "<primary>inet_server_addr</primary>"
msgstr "<primary>inet_server_addr</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16028(indexterm)
msgid "<primary>inet_server_port</primary>"
msgstr "<primary>inet_server_port</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16032(para)
msgid ""
"<function>inet_client_addr</function> returns the IP address of the current "
"client, and <function>inet_client_port</function> returns the port number. "
"<function>inet_server_addr</function> returns the IP address on which the "
"server accepted the current connection, and <function>inet_server_port</"
"function> returns the port number. All these functions return NULL if the "
"current connection is via a Unix-domain socket."
msgstr ""
"Функция <function>inet_client_addr</function> возвращает IP-адрес текущего "
"клиента, <function>inet_client_port</function> &mdash; номер его порта, "
"<function>inet_server_addr</function> &mdash; IP-адрес сервера, по которому "
"он принял подключение клиента, а <function>inet_server_port</function> "
"&mdash; соответствующий номер порта. Все эти функции возвращают NULL, если "
"текущее соединение устанавливается через доменный сокет Unix."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16043(indexterm)
msgid "<primary>pg_blocking_pids</primary>"
msgstr "<primary>pg_blocking_pids</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16047(para)
msgid ""
"<function>pg_blocking_pids</function> returns an array of the process IDs of "
"the sessions that are blocking the server process with the specified process "
"ID, or an empty array if there is no such server process or it is not "
"blocked. One server process blocks another if it either holds a lock that "
"conflicts with the blocked process's lock request (hard block), or is "
"waiting for a lock that would conflict with the blocked process's lock "
"request and is ahead of it in the wait queue (soft block). When using "
"parallel queries the result always lists client-visible process IDs (that "
"is, <function>pg_backend_pid</function> results) even if the actual lock is "
"held or awaited by a child worker process. As a result of that, there may be "
"duplicated PIDs in the result. Also note that when a prepared transaction "
"holds a conflicting lock, it will be represented by a zero process ID in the "
"result of this function. Frequent calls to this function could have some "
"impact on database performance, because it needs exclusive access to the "
"lock manager's shared state for a short time."
msgstr ""
"Функция <function>pg_blocking_pids</function> возвращает массив "
"идентификаторов процессов сеансов, которые блокирует серверный процесс с "
"указанным идентификатором, либо пустой массив, если такой серверный процесс "
"не найден или не заблокирован. Один серверный процесс блокирует другой, если "
"он либо удерживает блокировку, конфликтующую с блокировкой, запрашиваемой "
"серверным процессом (жёсткая блокировка), либо ждёт блокировки, которая "
"вызвала бы конфликт с запросом блокировки заблокированного процесса и "
"находится перед ней в очереди ожидания (мягкая блокировка). При "
"распараллеливании запросов эта функция всегда выдаёт видимые клиентом "
"идентификаторы процессов (то есть, результаты <function>pg_backend_pid</"
"function>), даже если фактическая блокировка удерживается или ожидается "
"дочерним рабочим процессом. Вследствие этого, в результатах могут оказаться "
"дублирующиеся PID. Также заметьте, что когда конфликтующую блокировку "
"удерживает подготовленная транзакция, в выводе этой функции она будет "
"представлена нулевым ID процесса. Частые вызовы этой функции могут "
"отразиться на производительности базы данных, так как ей нужен монопольный "
"доступ к общему состоянию менеджера блокировок, хоть и на короткое время."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16066(indexterm)
msgid "<primary>pg_conf_load_time</primary>"
msgstr "<primary>pg_conf_load_time</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16070(para)
msgid ""
"<function>pg_conf_load_time</function> returns the <type>timestamp with time "
"zone</type> when the server configuration files were last loaded. (If the "
"current session was alive at the time, this will be the time when the "
"session itself re-read the configuration files, so the reading will vary a "
"little in different sessions. Otherwise it is the time when the postmaster "
"process re-read the configuration files.)"
msgstr ""
"Функция <function>pg_conf_load_time</function> возвращает время "
"(<type>timestamp with time zone</type>), когда в последний раз сервер "
"загружал файлы конфигурации. (Если текущий сеанс начался раньше, она "
"возвращает время, когда эти файлы были перезагружены для данного сеанса, так "
"что в разных сеансах это значение может немного различаться. В противном "
"случае это будет время, когда файлы конфигурации считал главный процесс.)"

#. +> REL_10
#: func.xml:16080(indexterm)
msgid "<primary>pg_current_logfile</primary>"
msgstr "<primary>pg_current_logfile</primary>"

#. +> REL_10
#: func.xml:16084(indexterm)
msgid ""
"<primary>Logging</primary> <secondary>pg_current_logfile function</secondary>"
msgstr ""
"<primary>Ведение журнала</primary> <secondary>функция pg_current_logfile</"
"secondary>"

#. +> REL_10
#: func.xml:16089(indexterm)
msgid ""
"<primary>current_logfiles</primary> <secondary>and the pg_current_logfile "
"function</secondary>"
msgstr ""
"<primary>current_logfiles</primary> <secondary>и функция pg_current_logfile</"
"secondary>"

#. +> REL_10
#: func.xml:16094(indexterm)
msgid ""
"<primary>Logging</primary> <secondary>current_logfiles file and the "
"pg_current_logfile function</secondary>"
msgstr ""
"<primary>Ведение журнала</primary> <secondary>файл current_logfiles и "
"функция pg_current_logfile</secondary>"

#. +> REL_10
#: func.xml:16100(para)
msgid ""
"<function>pg_current_logfile</function> returns, as <type>text</type>, the "
"path of the log file(s) currently in use by the logging collector. The path "
"includes the <xref linkend=\"guc-log-directory\"/> directory and the log "
"file name. Log collection must be enabled or the return value is "
"<literal>NULL</literal>. When multiple log files exist, each in a different "
"format, <function>pg_current_logfile</function> called without arguments "
"returns the path of the file having the first format found in the ordered "
"list: <systemitem>stderr</systemitem>, <systemitem>csvlog</systemitem>. "
"<literal>NULL</literal> is returned when no log file has any of these "
"formats. To request a specific file format supply, as <type>text</type>, "
"either <systemitem>csvlog</systemitem> or <systemitem>stderr</systemitem> as "
"the value of the optional parameter. The return value is <literal>NULL</"
"literal> when the log format requested is not a configured <xref linkend="
"\"guc-log-destination\"/>. The <function>pg_current_logfiles</function> "
"reflects the contents of the <filename>current_logfiles</filename> file."
msgstr ""
"Функция <function>pg_current_logfile</function> возвращает в значении "
"<type>text</type> путь к файлам журналов, в настоящее время используемым "
"сборщиком сообщений. Этот путь состоит из каталога <xref linkend=\"guc-log-"
"directory\"/> и имени файла журнала. Если сборщик сообщений отключён, "
"возвращается значение <literal>NULL</literal>. Если ведутся несколько "
"журналов в разных форматах, при вызове функции <function>pg_current_logfile</"
"function> без аргументов возвращается путь файла, имеющего первый формат по "
"порядку из следующего списка: <systemitem>stderr</systemitem>, "
"<systemitem>csvlog</systemitem>. Если файл журнала имеет какой-то иной "
"формат, возвращается <literal>NULL</literal>. Чтобы запросить файл в "
"определённом формате, передайте либо <systemitem>csvlog</systemitem>, либо "
"<systemitem>stderr</systemitem> в качестве значения необязательного "
"параметра типа <type>text</type>. Если запрошенный формат не включён в <xref "
"linkend=\"guc-log-destination\"/>, будет возвращено значение <literal>NULL</"
"literal>. Функция <function>pg_current_logfiles</function> отражает "
"содержимое файла <filename>current_logfiles</filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16119(indexterm)
msgid "<primary>pg_my_temp_schema</primary>"
msgstr "<primary>pg_my_temp_schema</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16123(indexterm)
msgid "<primary>pg_is_other_temp_schema</primary>"
msgstr "<primary>pg_is_other_temp_schema</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16127(para)
msgid ""
"<function>pg_my_temp_schema</function> returns the OID of the current "
"session's temporary schema, or zero if it has none (because it has not "
"created any temporary tables). <function>pg_is_other_temp_schema</function> "
"returns true if the given OID is the OID of another session's temporary "
"schema. (This can be useful, for example, to exclude other sessions' "
"temporary tables from a catalog display.)"
msgstr ""
"<function>pg_my_temp_schema</function> возвращает OID временной схемы "
"текущего сеанса или 0, если такой нет (в рамках сеанса не создавались "
"временные таблицы). <function>pg_is_other_temp_schema</function> возвращает "
"true, если заданный OID относится к временной схеме другого сеанса. (Это "
"может быть полезно, например для исключения временных таблиц других сеансов "
"из общего списка при просмотре таблиц базы данных.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16137(indexterm)
msgid "<primary>pg_listening_channels</primary>"
msgstr "<primary>pg_listening_channels</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16141(indexterm)
msgid "<primary>pg_notification_queue_usage</primary>"
msgstr "<primary>pg_notification_queue_usage</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16145(para)
msgid ""
"<function>pg_listening_channels</function> returns a set of names of "
"asynchronous notification channels that the current session is listening to. "
"<function>pg_notification_queue_usage</function> returns the fraction of the "
"total available space for notifications currently occupied by notifications "
"that are waiting to be processed, as a <type>double</type> in the range 0-1. "
"See <xref linkend=\"sql-listen\"/> and <xref linkend=\"sql-notify\"/> for "
"more information."
msgstr ""
"Функция <function>pg_listening_channels</function> возвращает набор имён "
"каналов асинхронных уведомлений, на которые подписан текущий сеанс. Функция "
"<function>pg_notification_queue_usage</function> возвращает долю от всего "
"свободного пространства для уведомлений, в настоящее время занятую "
"уведомлениями, ожидающими обработки, в виде значения <type>double</type> в "
"диапазоне 0..1. За дополнительными сведениями обратитесь к <xref remap=\"3\" "
"linkend=\"sql-listen\"/> и <xref remap=\"3\" linkend=\"sql-notify\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16156(indexterm)
msgid "<primary>pg_postmaster_start_time</primary>"
msgstr "<primary>pg_postmaster_start_time</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16160(para)
msgid ""
"<function>pg_postmaster_start_time</function> returns the <type>timestamp "
"with time zone</type> when the server started."
msgstr ""
"<function>pg_postmaster_start_time</function> возвращает время "
"(<type>timestamp with time zone</type>), когда был запущен сервер."

#. +> REL_10
#: func.xml:16166(indexterm)
msgid "<primary>pg_safe_snapshot_blocking_pids</primary>"
msgstr "<primary>pg_safe_snapshot_blocking_pids</primary>"

#. +> REL_10
#: func.xml:16170(para)
msgid ""
"<function>pg_safe_snapshot_blocking_pids</function> returns an array of the "
"process IDs of the sessions that are blocking the server process with the "
"specified process ID from acquiring a safe snapshot, or an empty array if "
"there is no such server process or it is not blocked. A session running a "
"<literal>SERIALIZABLE</literal> transaction blocks a <literal>SERIALIZABLE "
"READ ONLY DEFERRABLE</literal> transaction from acquiring a snapshot until "
"the latter determines that it is safe to avoid taking any predicate locks. "
"See <xref linkend=\"xact-serializable\"/> for more information about "
"serializable and deferrable transactions. Frequent calls to this function "
"could have some impact on database performance, because it needs access to "
"the predicate lock manager's shared state for a short time."
msgstr ""
"Функция <function>pg_safe_snapshot_blocking_pids</function> возвращает "
"массив идентификаторов процессов сеансов, которые блокируют серверный "
"процесс с указанным идентификатором (не дают получить ему безопасный "
"снимок), либо пустой массив, если такой серверный процесс не найден или не "
"заблокирован. Сеанс, выполняющий транзакцию уровня <literal>SERIALIZABLE</"
"literal>, блокирует транзакцию <literal>SERIALIZABLE READ ONLY DEFERRABLE</"
"literal>, не давая ей получить снимок, пока она не определит, что можно "
"безопасно избежать установления предикатных блокировок. За дополнительными "
"сведениями о сериализуемых и откладываемых транзакциях обратитесь к <xref "
"remap=\"3\" linkend=\"xact-serializable\"/>. Частые вызовы этой функции "
"могут отразиться на производительности базы данных, так как ей нужен доступ "
"к общему состоянию менеджера предикатных блокировок, хоть и на короткое "
"время."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16185(indexterm)
msgid "<primary>version</primary>"
msgstr "<primary>версия</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16189(para)
msgid ""
"<function>version</function> returns a string describing the "
"<productname>PostgreSQL</productname> server's version. You can also get "
"this information from <xref linkend=\"guc-server-version\"/> or for a "
"machine-readable version, <xref linkend=\"guc-server-version-num\"/>. "
"Software developers should use <literal>server_version_num</literal> "
"(available since 8.2) or <xref linkend=\"libpq-pqserverversion\"/> instead "
"of parsing the text version."
msgstr ""
"Функция <function>version</function> возвращает строку, описывающую версию "
"сервера <productname>PostgreSQL</productname>. Эту информацию также можно "
"получить из переменной <xref linkend=\"guc-server-version\"/> или, в более "
"машинно-ориентированном формате, из переменной <xref linkend=\"guc-server-"
"version-num\"/>. При разработке программ следует использовать "
"<literal>server_version_num</literal> (она появилась в версии 8.2) либо "
"<xref linkend=\"libpq-pqserverversion\"/>, а не разбирать текстовую версию."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16199(indexterm)
msgid "<primary>privilege</primary> <secondary>querying</secondary>"
msgstr "<primary>права</primary> <secondary>проверка</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16204(para)
msgid ""
"<xref linkend=\"functions-info-access-table\"/> lists functions that allow "
"the user to query object access privileges programmatically. See <xref "
"linkend=\"ddl-priv\"/> for more information about privileges."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-access-table\"/> перечислены "
"функции, позволяющую пользователю программно проверить свои права доступа к "
"объектам. Подробнее о правах можно узнать в <xref remap=\"6\" linkend=\"ddl-"
"priv\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16212(title)
msgid "Access Privilege Inquiry Functions"
msgstr "Функции для проверки прав доступа"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16220(function) func.xml:16228(function)
msgid "has_any_column_privilege"
msgstr "has_any_column_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16220(parameter) func.xml:16235(parameter)
#: func.xml:16252(parameter) func.xml:16267(parameter)
#: func.xml:16282(parameter) func.xml:16297(parameter)
#: func.xml:16312(parameter) func.xml:16327(parameter)
#: func.xml:16342(parameter) func.xml:16357(parameter)
#: func.xml:16372(parameter) func.xml:16387(parameter)
#: func.xml:16402(parameter)
msgctxt "parameter"
msgid "user"
msgstr "user"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16221(parameter) func.xml:16228(parameter)
#: func.xml:16236(parameter) func.xml:16244(parameter)
#: func.xml:16358(parameter) func.xml:16365(parameter)
#: func.xml:16417(parameter)
msgid "table"
msgstr "table"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16222(parameter) func.xml:16229(parameter)
#: func.xml:16238(parameter) func.xml:16246(parameter)
#: func.xml:16254(parameter) func.xml:16261(parameter)
#: func.xml:16269(parameter) func.xml:16276(parameter)
#: func.xml:16284(parameter) func.xml:16291(parameter)
#: func.xml:16299(parameter) func.xml:16306(parameter)
#: func.xml:16314(parameter) func.xml:16321(parameter)
#: func.xml:16329(parameter) func.xml:16336(parameter)
#: func.xml:16344(parameter) func.xml:16351(parameter)
#: func.xml:16359(parameter) func.xml:16366(parameter)
#: func.xml:16374(parameter) func.xml:16381(parameter)
#: func.xml:16389(parameter) func.xml:16396(parameter)
#: func.xml:16404(parameter) func.xml:16411(parameter)
msgid "privilege"
msgstr "privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16225(entry)
msgid "does user have privilege for any column of table"
msgstr "имеет ли пользователь указанное право для какого-либо столбца таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16232(entry)
msgid "does current user have privilege for any column of table"
msgstr ""
"имеет ли текущий пользователь указанное право для какого-либо столбца таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16235(function) func.xml:16244(function)
msgid "has_column_privilege"
msgstr "has_column_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16237(parameter) func.xml:16245(parameter)
msgid "column"
msgstr "column"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16235(literal)
msgid ""
"<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>, "
"<placeholder-5/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>, "
"<placeholder-5/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16241(entry)
msgid "does user have privilege for column"
msgstr "имеет ли пользователь указанное право для столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16249(entry)
msgid "does current user have privilege for column"
msgstr "имеет ли текущий пользователь указанное право для столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16252(function) func.xml:16260(function)
msgid "has_database_privilege"
msgstr "has_database_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16253(parameter) func.xml:16260(parameter)
msgid "database"
msgstr "database"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16257(entry)
msgid "does user have privilege for database"
msgstr "имеет ли пользователь указанное право для базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16264(entry)
msgid "does current user have privilege for database"
msgstr "имеет ли текущий пользователь указанное право для базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16267(function) func.xml:16275(function)
msgid "has_foreign_data_wrapper_privilege"
msgstr "has_foreign_data_wrapper_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16268(parameter) func.xml:16275(parameter)
msgid "fdw"
msgstr "fdw"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16272(entry)
msgid "does user have privilege for foreign-data wrapper"
msgstr "имеет ли пользователь указанное право для обёртки сторонних данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16279(entry)
msgid "does current user have privilege for foreign-data wrapper"
msgstr ""
"имеет ли текущий пользователь указанное право для обёртки сторонних данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16282(function) func.xml:16290(function)
msgid "has_function_privilege"
msgstr "has_function_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16283(parameter) func.xml:16290(parameter)
msgid "function"
msgstr "function"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16287(entry)
msgid "does user have privilege for function"
msgstr "имеет ли пользователь указанное право для функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16294(entry)
msgid "does current user have privilege for function"
msgstr "имеет ли текущий пользователь указанное право для функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16297(function) func.xml:16305(function)
msgid "has_language_privilege"
msgstr "has_language_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16298(parameter) func.xml:16305(parameter)
msgid "language"
msgstr "language"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16302(entry)
msgid "does user have privilege for language"
msgstr "имеет ли пользователь указанное право для языка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16309(entry)
msgid "does current user have privilege for language"
msgstr "имеет ли текущий пользователь указанное право для языка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16312(function) func.xml:16320(function)
msgid "has_schema_privilege"
msgstr "has_schema_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16313(parameter) func.xml:16320(parameter)
#: func.xml:19757(parameter)
msgid "schema"
msgstr "schema"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16317(entry)
msgid "does user have privilege for schema"
msgstr "имеет ли пользователь указанное право для схемы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16324(entry)
msgid "does current user have privilege for schema"
msgstr "имеет ли текущий пользователь указанное право для схемы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16327(function) func.xml:16335(function)
msgid "has_sequence_privilege"
msgstr "has_sequence_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16328(parameter) func.xml:16335(parameter)
msgid "sequence"
msgstr "sequence"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16332(entry)
msgid "does user have privilege for sequence"
msgstr "имеет ли пользователь указанное право для последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16339(entry)
msgid "does current user have privilege for sequence"
msgstr "имеет ли текущий пользователь указанное право для последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16342(function) func.xml:16350(function)
msgid "has_server_privilege"
msgstr "has_server_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16343(parameter) func.xml:16350(parameter)
msgid "server"
msgstr "server"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16347(entry)
msgid "does user have privilege for foreign server"
msgstr "имеет ли пользователь указанное право для стороннего сервера"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16354(entry)
msgid "does current user have privilege for foreign server"
msgstr "имеет ли текущий пользователь указанное право для стороннего сервера"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16357(function) func.xml:16365(function)
msgid "has_table_privilege"
msgstr "has_table_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16362(entry)
msgid "does user have privilege for table"
msgstr "имеет ли пользователь указанное право для таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16369(entry)
msgid "does current user have privilege for table"
msgstr "имеет ли текущий пользователь указанное право для таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16372(function) func.xml:16380(function)
msgid "has_tablespace_privilege"
msgstr "has_tablespace_privilege"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16373(parameter) func.xml:16380(parameter)
#: func.xml:19696(parameter)
msgid "tablespace"
msgstr "tablespace"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16377(entry)
msgid "does user have privilege for tablespace"
msgstr "имеет ли пользователь указанное право для табличного пространства"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16384(entry)
msgid "does current user have privilege for tablespace"
msgstr ""
"имеет ли текущий пользователь указанное право для табличного пространства"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16387(function) func.xml:16395(function)
msgid "has_type_privilege"
msgstr "has_type_privilege"

#. +> REL_10
#: func.xml:16388(parameter) func.xml:16395(parameter)
#: func.xml:17516(parameter)
msgctxt "parameter"
msgid "type"
msgstr "type"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16392(entry)
msgid "does user have privilege for type"
msgstr "имеет ли пользователь указанное право для типа"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16399(entry)
msgid "does current user have privilege for type"
msgstr "имеет ли текущий пользователь указанное право для типа"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16402(function) func.xml:16410(function)
msgid "pg_has_role"
msgstr "pg_has_role"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16403(parameter) func.xml:16410(parameter)
msgid "role"
msgstr "role"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16407(entry)
msgid "does user have privilege for role"
msgstr "имеет ли пользователь указанное право для роли"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16414(entry)
msgid "does current user have privilege for role"
msgstr "имеет ли текущий пользователь указанное право для роли"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16417(function)
msgid "row_security_active"
msgstr "row_security_active"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16420(entry)
msgid "does current user have row level security active for table"
msgstr ""
"включена ли для текущего пользователя защита на уровне строк для таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16426(indexterm)
msgid "<primary>has_any_column_privilege</primary>"
msgstr "<primary>has_any_column_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16429(indexterm)
msgid "<primary>has_column_privilege</primary>"
msgstr "<primary>has_column_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16432(indexterm)
msgid "<primary>has_database_privilege</primary>"
msgstr "<primary>has_database_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16435(indexterm)
msgid "<primary>has_function_privilege</primary>"
msgstr "<primary>has_function_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16438(indexterm)
msgid "<primary>has_foreign_data_wrapper_privilege</primary>"
msgstr "<primary>has_foreign_data_wrapper_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16441(indexterm)
msgid "<primary>has_language_privilege</primary>"
msgstr "<primary>has_language_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16444(indexterm)
msgid "<primary>has_schema_privilege</primary>"
msgstr "<primary>has_schema_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16447(indexterm)
msgid "<primary>has_server_privilege</primary>"
msgstr "<primary>has_server_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16450(indexterm)
msgid "<primary>has_sequence_privilege</primary>"
msgstr "<primary>has_sequence_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16453(indexterm)
msgid "<primary>has_table_privilege</primary>"
msgstr "<primary>has_table_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16456(indexterm)
msgid "<primary>has_tablespace_privilege</primary>"
msgstr "<primary>has_tablespace_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16459(indexterm)
msgid "<primary>has_type_privilege</primary>"
msgstr "<primary>has_type_privilege</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16462(indexterm)
msgid "<primary>pg_has_role</primary>"
msgstr "<primary>pg_has_role</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16465(indexterm)
msgid "<primary>row_security_active</primary>"
msgstr "<primary>row_security_active</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16492(programlisting)
#, no-wrap
msgid ""
"SELECT has_table_privilege('myschema.mytable', 'select');\n"
"SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');"
msgstr ""
"SELECT has_table_privilege('myschema.mytable', 'select');\n"
"SELECT has_table_privilege('joe', 'mytable',\n"
"  'INSERT, SELECT WITH GRANT OPTION');"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16469(para)
msgid ""
"<function>has_table_privilege</function> checks whether a user can access a "
"table in a particular way. The user can be specified by name, by OID "
"(<literal>pg_authid.oid</literal>), <literal>public</literal> to indicate "
"the PUBLIC pseudo-role, or if the argument is omitted "
"<function>current_user</function> is assumed. The table can be specified by "
"name or by OID. (Thus, there are actually six variants of "
"<function>has_table_privilege</function>, which can be distinguished by the "
"number and types of their arguments.) When specifying by name, the name can "
"be schema-qualified if necessary. The desired access privilege type is "
"specified by a text string, which must evaluate to one of the values "
"<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, "
"<literal>REFERENCES</literal>, or <literal>TRIGGER</literal>. Optionally, "
"<literal>WITH GRANT OPTION</literal> can be added to a privilege type to "
"test whether the privilege is held with grant option. Also, multiple "
"privilege types can be listed separated by commas, in which case the result "
"will be <literal>true</literal> if any of the listed privileges is held. "
"(Case of the privilege string is not significant, and extra whitespace is "
"allowed between but not within privilege names.) Some examples: "
"<placeholder-1/>"
msgstr ""
"<function>has_table_privilege</function> проверяет, может ли пользователь "
"выполнять с таблицей заданные действия. В качестве идентификатора "
"пользователя можно задать его имя, OID (<literal>pg_authid.oid</literal>) "
"или <literal>public</literal> (это будет указывать на псевдороль PUBLIC). "
"Если этот аргумент опущен, подразумевается текущий пользователь "
"(<function>current_user</function>). Таблицу можно указать по имени или по "
"OID. (Таким образом, фактически есть шесть вариантов функции "
"<function>has_table_privilege</function>, различающихся по числу и типу "
"аргументов.) Когда указывается имя объекта, его можно дополнить именем "
"схемы, если это необходимо. Интересующее право доступа записывается в виде "
"текста и может быть одним из следующих: <literal>SELECT</literal>, "
"<literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</"
"literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal> и "
"<literal>TRIGGER</literal>. Дополнительно к названию права можно добавить "
"<literal>WITH GRANT OPTION</literal> и проверить, разрешено ли пользователю "
"передавать это право другим. Кроме того, в одном параметре можно перечислить "
"несколько названий прав через запятую, и тогда функция возвратит "
"<literal>true</literal>, если пользователь имеет одно из этих прав. (Регистр "
"в названии прав не имеет значения, а между ними (но не внутри) разрешены "
"пробельные символы.) Пара примеров: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16498(para)
msgid ""
"<function>has_sequence_privilege</function> checks whether a user can access "
"a sequence in a particular way. The possibilities for its arguments are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to one of <literal>USAGE</literal>, "
"<literal>SELECT</literal>, or <literal>UPDATE</literal>."
msgstr ""
"<function>has_sequence_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия с последовательностью. В определении аргументов "
"эта функция аналогична <function>has_table_privilege</function>. Допустимые "
"для неё права складываются из <literal>USAGE</literal>, <literal>SELECT</"
"literal> и <literal>UPDATE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16508(para)
msgid ""
"<function>has_any_column_privilege</function> checks whether a user can "
"access any column of a table in a particular way. Its argument possibilities "
"are analogous to <function>has_table_privilege</function>, except that the "
"desired access privilege type must evaluate to some combination of "
"<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, or <literal>REFERENCES</literal>. Note that having any of these "
"privileges at the table level implicitly grants it for each column of the "
"table, so <function>has_any_column_privilege</function> will always return "
"<literal>true</literal> if <function>has_table_privilege</function> does for "
"the same arguments. But <function>has_any_column_privilege</function> also "
"succeeds if there is a column-level grant of the privilege for at least one "
"column."
msgstr ""
"<function>has_any_column_privilege</function> проверяет, может ли "
"пользователь выполнять заданные действия с каким-либо столбцом таблицы. В "
"определении аргументов эта функция аналогична <function>has_table_privilege</"
"function>, а допустимые права складываются из <literal>SELECT</literal>, "
"<literal>INSERT</literal>, <literal>UPDATE</literal> и <literal>REFERENCES</"
"literal>. Заметьте, что любое из этих прав, назначенное на уровне таблицы, "
"автоматически распространяется на все её столбцы, так что "
"<function>has_any_column_privilege</function> всегда возвращает "
"<literal>true</literal>, если <function>has_table_privilege</function> даёт "
"положительный ответ для тех же аргументов. Но "
"<function>has_any_column_privilege</function> возвращает <literal>true</"
"literal> ещё и тогда, когда право назначено только для некоторых столбцов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16526(para)
msgid ""
"<function>has_column_privilege</function> checks whether a user can access a "
"column in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>, with the addition that the column "
"can be specified either by name or attribute number. The desired access "
"privilege type must evaluate to some combination of <literal>SELECT</"
"literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, or "
"<literal>REFERENCES</literal>. Note that having any of these privileges at "
"the table level implicitly grants it for each column of the table."
msgstr ""
"<function>has_column_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия со столбцом таблицы. В определении аргументов "
"эта функция аналогична <function>has_table_privilege</function>, с небольшим "
"дополнением: столбец можно задать по имени или номеру атрибута. Для неё "
"допустимые права складываются из <literal>SELECT</literal>, <literal>INSERT</"
"literal>, <literal>UPDATE</literal> и <literal>REFERENCES</literal>. "
"Заметьте, что любое из этих прав, назначенное на уровне таблицы, "
"автоматически распространяется на все столбцы таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16541(para)
msgid ""
"<function>has_database_privilege</function> checks whether a user can access "
"a database in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. The desired access privilege type "
"must evaluate to some combination of <literal>CREATE</literal>, "
"<literal>CONNECT</literal>, <literal>TEMPORARY</literal>, or <literal>TEMP</"
"literal> (which is equivalent to <literal>TEMPORARY</literal>)."
msgstr ""
"<function>has_database_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия с базой данных. В определении аргументов эта "
"функция аналогична <function>has_table_privilege</function>. Для неё "
"допустимые права складываются из <literal>CREATE</literal>, "
"<literal>CONNECT</literal> и <literal>TEMPORARY</literal> (или "
"<literal>TEMP</literal>, что равносильно <literal>TEMPORARY</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16565(programlisting)
#, no-wrap
msgid "SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');"
msgstr "SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16554(para)
msgid ""
"<function>has_function_privilege</function> checks whether a user can access "
"a function in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. When specifying a function by a "
"text string rather than by OID, the allowed input is the same as for the "
"<type>regprocedure</type> data type (see <xref linkend=\"datatype-oid\"/>). "
"The desired access privilege type must evaluate to <literal>EXECUTE</"
"literal>. An example is: <placeholder-1/>"
msgstr ""
"<function>has_function_privilege</function> проверяет, может ли пользователь "
"обратиться к заданной функции. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Когда функция "
"определяется не своим OID, а текстовой строкой, эта строка должна быть "
"допустимой для вводимого значения типа <type>regprocedure</type> (см. <xref "
"remap=\"4\" linkend=\"datatype-oid\"/>). Для этой функции допустимо только "
"право <literal>EXECUTE</literal>. Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16570(para)
msgid ""
"<function>has_foreign_data_wrapper_privilege</function> checks whether a "
"user can access a foreign-data wrapper in a particular way. Its argument "
"possibilities are analogous to <function>has_table_privilege</function>. The "
"desired access privilege type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_foreign_data_wrapper_privilege</function> проверяет, может ли "
"пользователь обращаться к обёртке сторонних данных. В определении аргументов "
"она аналогична <function>has_table_privilege</function>. Для неё допустимо "
"только право <literal>USAGE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16579(para)
msgid ""
"<function>has_language_privilege</function> checks whether a user can access "
"a procedural language in a particular way. Its argument possibilities are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_language_privilege</function> проверяет, может ли пользователь "
"обращаться к процедурному языку. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Для неё допустимо "
"только право <literal>USAGE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16588(para)
msgid ""
"<function>has_schema_privilege</function> checks whether a user can access a "
"schema in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. The desired access privilege type "
"must evaluate to some combination of <literal>CREATE</literal> or "
"<literal>USAGE</literal>."
msgstr ""
"<function>has_schema_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия со схемой. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Для неё допустимые "
"права складываются из <literal>CREATE</literal> и <literal>USAGE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16598(para)
msgid ""
"<function>has_server_privilege</function> checks whether a user can access a "
"foreign server in a particular way. Its argument possibilities are analogous "
"to <function>has_table_privilege</function>. The desired access privilege "
"type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_server_privilege</function> проверяет, может ли пользователь "
"обращаться к стороннему серверу. В определении аргументов она аналогична "
"<function>has_table_privilege</function>. Для неё допустимо только право "
"<literal>USAGE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16607(para)
msgid ""
"<function>has_tablespace_privilege</function> checks whether a user can "
"access a tablespace in a particular way. Its argument possibilities are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to <literal>CREATE</literal>."
msgstr ""
"<function>has_tablespace_privilege</function> проверяет, может ли "
"пользователь выполнять заданное действие в табличном пространстве. В "
"определении аргументов эта функция аналогична <function>has_table_privilege</"
"function>. Для неё допустимо только право <literal>CREATE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16616(para)
msgid ""
"<function>has_type_privilege</function> checks whether a user can access a "
"type in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. When specifying a type by a text "
"string rather than by OID, the allowed input is the same as for the "
"<type>regtype</type> data type (see <xref linkend=\"datatype-oid\"/>). The "
"desired access privilege type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_type_privilege</function> проверяет, может ли пользователь "
"обратиться к типу определённым образом. Возможные аргументы аналогичны "
"<function>has_table_privilege</function>. При указании типа текстовой "
"строкой, а не по OID, допускаются те же входные значения, что и для типа "
"данных <type>regtype</type> (см. <xref remap=\"4\" linkend=\"datatype-oid\"/"
">). Для неё допустимо только право <literal>USAGE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16628(para)
msgid ""
"<function>pg_has_role</function> checks whether a user can access a role in "
"a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>, except that <literal>public</"
"literal> is not allowed as a user name. The desired access privilege type "
"must evaluate to some combination of <literal>MEMBER</literal> or "
"<literal>USAGE</literal>. <literal>MEMBER</literal> denotes direct or "
"indirect membership in the role (that is, the right to do <command>SET ROLE</"
"command>), while <literal>USAGE</literal> denotes whether the privileges of "
"the role are immediately available without doing <command>SET ROLE</command>."
msgstr ""
"<function>pg_has_role</function> проверяет, может ли пользователь выполнять "
"заданные действия с ролью. В определении аргументов эта функция аналогична "
"<function>has_table_privilege</function>, за исключением того, что именем "
"пользователя не может быть <literal>public</literal>. Для неё допустимые "
"права складываются из <literal>MEMBER</literal> и <literal>USAGE</literal>. "
"<literal>MEMBER</literal> обозначает прямое или косвенное членство в данной "
"роли (то есть наличие права выполнить команду <command>SET ROLE</command>), "
"тогда как <literal>USAGE</literal> показывает, что пользователь получает все "
"права роли сразу, без <command>SET ROLE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16643(para)
msgid ""
"<function>row_security_active</function> checks whether row level security "
"is active for the specified table in the context of the "
"<function>current_user</function> and environment. The table can be "
"specified by name or by OID."
msgstr ""
"<function>row_security_active</function> проверяет, включена ли защита на "
"уровне строк для указанной таблицы в контексте и окружении текущего "
"пользователя (<function>current_user</function>). Таблицу можно задать по "
"имени или OID."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16659(programlisting)
#, no-wrap
msgid "SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);"
msgstr "SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16650(para)
msgid ""
"<xref linkend=\"functions-info-schema-table\"/> shows functions that "
"determine whether a certain object is <firstterm>visible</firstterm> in the "
"current schema search path. For example, a table is said to be visible if "
"its containing schema is in the search path and no table of the same name "
"appears earlier in the search path. This is equivalent to the statement that "
"the table can be referenced by name without explicit schema qualification. "
"To list the names of all visible tables: <placeholder-1/>"
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-schema-table\"/> перечислены "
"функции, определяющие <firstterm>видимость</firstterm> объекта с текущим "
"путём поиска схем. К примеру, таблица считается видимой, если содержащая её "
"схема включена в путь поиска и нет другой таблицы с тем же именем, которая "
"была бы найдена по пути поиска раньше. Другими словами, к этой таблице можно "
"будет обратиться просто по её имени, без явного указания схемы. Просмотреть "
"список всех видимых таблиц можно так: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16664(indexterm)
msgid "<primary>search path</primary> <secondary>object visibility</secondary>"
msgstr ""
"<primary>путь поиска</primary> <secondary>видимость объектов</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16670(title)
msgid "Schema Visibility Inquiry Functions"
msgstr "Функции для определения видимости"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16678(parameter)
msgid "collation_oid"
msgstr "collation_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16678(function)
msgid "pg_collation_is_visible(<placeholder-1/>)"
msgstr "pg_collation_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16681(entry)
msgid "is collation visible in search path"
msgstr "видимо ли правило сортировки"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16684(parameter)
msgid "conversion_oid"
msgstr "conversion_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16684(function)
msgid "pg_conversion_is_visible(<placeholder-1/>)"
msgstr "pg_conversion_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16687(entry)
msgid "is conversion visible in search path"
msgstr "видимо ли преобразование"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16690(parameter)
msgid "function_oid"
msgstr "function_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16690(function)
msgid "pg_function_is_visible(<placeholder-1/>)"
msgstr "pg_function_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16693(entry)
msgid "is function visible in search path"
msgstr "видима ли функция"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16696(parameter) func.xml:16708(parameter)
msgid "opclass_oid"
msgstr "opclass_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16696(function)
msgid "pg_opclass_is_visible(<placeholder-1/>)"
msgstr "pg_opclass_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16699(entry)
msgid "is operator class visible in search path"
msgstr "видим ли класс операторов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16702(parameter)
msgid "operator_oid"
msgstr "operator_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16702(function)
msgid "pg_operator_is_visible(<placeholder-1/>)"
msgstr "pg_operator_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16705(entry)
msgid "is operator visible in search path"
msgstr "видим ли оператор"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16708(function)
msgid "pg_opfamily_is_visible(<placeholder-1/>)"
msgstr "pg_opfamily_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16711(entry)
msgid "is operator family visible in search path"
msgstr "видимо ли семейство операторов"

#. +> REL_10
#: func.xml:16714(parameter)
msgid "stat_oid"
msgstr "stat_oid"

#. +> REL_10
#: func.xml:16714(function)
msgid "pg_statistics_obj_is_visible(<placeholder-1/>)"
msgstr "pg_statistics_obj_is_visible(<placeholder-1/>)"

#. +> REL_10
#: func.xml:16717(entry)
msgid "is statistics object visible in search path"
msgstr "видим ли объект статистики в пути поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16720(parameter) func.xml:17610(parameter)
msgid "table_oid"
msgstr "table_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16720(function)
msgid "pg_table_is_visible(<placeholder-1/>)"
msgstr "pg_table_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16723(entry)
msgid "is table visible in search path"
msgstr "видима ли таблица"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16726(parameter)
msgid "config_oid"
msgstr "config_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16726(function)
msgid "pg_ts_config_is_visible(<placeholder-1/>)"
msgstr "pg_ts_config_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16729(entry)
msgid "is text search configuration visible in search path"
msgstr "видима ли конфигурация текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16732(parameter)
msgid "dict_oid"
msgstr "dict_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16732(function)
msgid "pg_ts_dict_is_visible(<placeholder-1/>)"
msgstr "pg_ts_dict_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16735(entry)
msgid "is text search dictionary visible in search path"
msgstr "видим ли словарь текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16738(parameter)
msgctxt "parameter"
msgid "parser_oid"
msgstr "parser_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16738(function)
msgid "pg_ts_parser_is_visible(<placeholder-1/>)"
msgstr "pg_ts_parser_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16741(entry)
msgid "is text search parser visible in search path"
msgstr "видим ли анализатор текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16744(parameter)
msgid "template_oid"
msgstr "template_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16744(function)
msgid "pg_ts_template_is_visible(<placeholder-1/>)"
msgstr "pg_ts_template_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16747(entry)
msgid "is text search template visible in search path"
msgstr "видим ли шаблон текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16750(parameter) func.xml:16962(parameter)
msgid "type_oid"
msgstr "type_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16750(function)
msgid "pg_type_is_visible(<placeholder-1/>)"
msgstr "pg_type_is_visible(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16753(entry)
msgid "is type (or domain) visible in search path"
msgstr "видим ли тип (или домен)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16759(indexterm)
msgid "<primary>pg_collation_is_visible</primary>"
msgstr "<primary>pg_collation_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16762(indexterm)
msgid "<primary>pg_conversion_is_visible</primary>"
msgstr "<primary>pg_conversion_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16765(indexterm)
msgid "<primary>pg_function_is_visible</primary>"
msgstr "<primary>pg_function_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16768(indexterm)
msgid "<primary>pg_opclass_is_visible</primary>"
msgstr "<primary>pg_opclass_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16771(indexterm)
msgid "<primary>pg_operator_is_visible</primary>"
msgstr "<primary>pg_operator_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16774(indexterm)
msgid "<primary>pg_opfamily_is_visible</primary>"
msgstr "<primary>pg_opfamily_is_visible</primary>"

#. +> REL_10
#: func.xml:16777(indexterm)
msgid "<primary>pg_statistics_obj_is_visible</primary>"
msgstr "<primary>pg_statistics_obj_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16780(indexterm)
msgid "<primary>pg_table_is_visible</primary>"
msgstr "<primary>pg_table_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16783(indexterm)
msgid "<primary>pg_ts_config_is_visible</primary>"
msgstr "<primary>pg_ts_config_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16786(indexterm)
msgid "<primary>pg_ts_dict_is_visible</primary>"
msgstr "<primary>pg_ts_dict_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16789(indexterm)
msgid "<primary>pg_ts_parser_is_visible</primary>"
msgstr "<primary>pg_ts_parser_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16792(indexterm)
msgid "<primary>pg_ts_template_is_visible</primary>"
msgstr "<primary>pg_ts_template_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16795(indexterm)
msgid "<primary>pg_type_is_visible</primary>"
msgstr "<primary>pg_type_is_visible</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16799(para)
msgid ""
"Each function performs the visibility check for one type of database object. "
"Note that <function>pg_table_is_visible</function> can also be used with "
"views, materialized views, indexes, sequences and foreign tables; "
"<function>pg_type_is_visible</function> can also be used with domains. For "
"functions and operators, an object in the search path is visible if there is "
"no object of the same name <emphasis>and argument data type(s)</emphasis> "
"earlier in the path. For operator classes, both name and associated index "
"access method are considered."
msgstr ""
"Каждая из этих функций проверяет видимость объектов определённого типа. "
"Заметьте, что <function>pg_table_is_visible</function> можно также "
"использовать для представлений, материализованных представлений, индексов, "
"последовательностей и сторонних таблиц; <function>pg_type_is_visible</"
"function> можно также использовать и для доменов. Для функций и операторов "
"объект считается видимым в пути поиска, если при просмотре пути не находится "
"предшествующий ему другой объект с тем же именем <emphasis>и типами "
"аргументов</emphasis>. Для классов операторов во внимание принимается и имя "
"оператора, и связанный с ним метод доступа к индексу."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16817(programlisting)
#, no-wrap
msgid "SELECT pg_type_is_visible('myschema.widget'::regtype);"
msgstr "SELECT pg_type_is_visible('myschema.widget'::regtype);"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16810(para)
msgid ""
"All these functions require object OIDs to identify the object to be "
"checked. If you want to test an object by name, it is convenient to use the "
"OID alias types (<type>regclass</type>, <type>regtype</type>, "
"<type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>, "
"or <type>regdictionary</type>), for example: <placeholder-1/> Note that it "
"would not make much sense to test a non-schema-qualified type name in this "
"way &mdash; if the name can be recognized at all, it must be visible."
msgstr ""
"Всем этим функциям должен передаваться OID проверяемого объекта. Если вы "
"хотите проверить объект по имени, удобнее использовать типы-псевдонимы OID "
"(<type>regclass</type>, <type>regtype</type>, <type>regprocedure</type>, "
"<type>regoperator</type>, <type>regconfig</type> или <type>regdictionary</"
"type>), например: <placeholder-1/> Заметьте, что проверять таким способом "
"имена без указания схемы не имеет большого смысла &mdash; если имя удастся "
"распознать, значит и объект будет видимым."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16824(indexterm)
msgid "<primary>format_type</primary>"
msgstr "<primary>format_type</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16828(indexterm)
msgid "<primary>pg_get_constraintdef</primary>"
msgstr "<primary>pg_get_constraintdef</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16832(indexterm)
msgid "<primary>pg_get_expr</primary>"
msgstr "<primary>pg_get_expr</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16836(indexterm)
msgid "<primary>pg_get_functiondef</primary>"
msgstr "<primary>pg_get_functiondef</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16840(indexterm)
msgid "<primary>pg_get_function_arguments</primary>"
msgstr "<primary>pg_get_function_arguments</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16844(indexterm)
msgid "<primary>pg_get_function_identity_arguments</primary>"
msgstr "<primary>pg_get_function_identity_arguments</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16848(indexterm)
msgid "<primary>pg_get_function_result</primary>"
msgstr "<primary>pg_get_function_result</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16852(indexterm)
msgid "<primary>pg_get_indexdef</primary>"
msgstr "<primary>pg_get_indexdef</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16856(indexterm)
msgid "<primary>pg_get_keywords</primary>"
msgstr "<primary>pg_get_keywords</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16860(indexterm)
msgid "<primary>pg_get_ruledef</primary>"
msgstr "<primary>pg_get_ruledef</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16864(indexterm)
msgid "<primary>pg_get_serial_sequence</primary>"
msgstr "<primary>pg_get_serial_sequence</primary>"

#. +> REL_10
#: func.xml:16868(indexterm)
msgid "<primary>pg_get_statisticsobjdef</primary>"
msgstr "<primary>pg_get_statisticsobjdef</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16872(indexterm)
msgid "<primary>pg_get_triggerdef</primary>"
msgstr "<primary>pg_get_triggerdef</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16876(indexterm)
msgid "<primary>pg_get_userbyid</primary>"
msgstr "<primary>pg_get_userbyid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16880(indexterm)
msgid "<primary>pg_get_viewdef</primary>"
msgstr "<primary>pg_get_viewdef</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16884(indexterm)
msgid "<primary>pg_index_column_has_property</primary>"
msgstr "<primary>pg_index_column_has_property</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16888(indexterm)
msgid "<primary>pg_index_has_property</primary>"
msgstr "<primary>pg_index_has_property</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16892(indexterm)
msgid "<primary>pg_indexam_has_property</primary>"
msgstr "<primary>pg_indexam_has_property</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16896(indexterm)
msgid "<primary>pg_options_to_table</primary>"
msgstr "<primary>pg_options_to_table</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16900(indexterm)
msgid "<primary>pg_tablespace_databases</primary>"
msgstr "<primary>pg_tablespace_databases</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16904(indexterm)
msgid "<primary>pg_tablespace_location</primary>"
msgstr "<primary>pg_tablespace_location</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16908(indexterm)
msgid "<primary>pg_typeof</primary>"
msgstr "<primary>pg_typeof</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16912(indexterm)
msgid "<primary>collation for</primary>"
msgstr "<primary>collation for</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16916(indexterm)
msgid "<primary>to_regclass</primary>"
msgstr "<primary>to_regclass</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16920(indexterm)
msgid "<primary>to_regproc</primary>"
msgstr "<primary>to_regproc</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16924(indexterm)
msgid "<primary>to_regprocedure</primary>"
msgstr "<primary>to_regprocedure</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16928(indexterm)
msgid "<primary>to_regoper</primary>"
msgstr "<primary>to_regoper</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16932(indexterm)
msgid "<primary>to_regoperator</primary>"
msgstr "<primary>to_regoperator</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16936(indexterm)
msgid "<primary>to_regtype</primary>"
msgstr "<primary>to_regtype</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16940(indexterm)
msgid "<primary>to_regnamespace</primary>"
msgstr "<primary>to_regnamespace</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16944(indexterm)
msgid "<primary>to_regrole</primary>"
msgstr "<primary>to_regrole</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16948(para)
msgid ""
"<xref linkend=\"functions-info-catalog-table\"/> lists functions that "
"extract information from the system catalogs."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-catalog-table\"/> перечислены "
"функции, извлекающие информацию из системных каталогов."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16954(title)
msgid "System Catalog Information Functions"
msgstr "Функции для обращения к системным каталогам"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16962(parameter)
msgid "typemod"
msgstr "typemod"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16962(function)
msgid "format_type(<placeholder-1/>, <placeholder-2/>)"
msgstr "format_type(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16964(entry)
msgid "get SQL name of a data type"
msgstr "получает имя типа данных в формате SQL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16967(parameter) func.xml:16972(parameter)
msgid "constraint_oid"
msgstr "constraint_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16967(function)
msgid "pg_get_constraintdef(<placeholder-1/>)"
msgstr "pg_get_constraintdef(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16969(entry) func.xml:16974(entry)
msgid "get definition of a constraint"
msgstr "получает определение ограничения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16972(parameter) func.xml:16983(parameter)
#: func.xml:17014(parameter) func.xml:17031(parameter)
#: func.xml:17066(parameter) func.xml:17076(parameter)
msgid "pretty_bool"
msgstr "pretty_bool"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16972(function)
msgid "pg_get_constraintdef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_constraintdef(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16977(parameter) func.xml:16983(parameter)
msgid "pg_node_tree"
msgstr "pg_node_tree"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16977(parameter) func.xml:16983(parameter)
msgid "relation_oid"
msgstr "relation_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16977(function)
msgid "pg_get_expr(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_expr(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16979(entry) func.xml:16985(entry)
msgid ""
"decompile internal form of an expression, assuming that any Vars in it refer "
"to the relation indicated by the second parameter"
msgstr ""
"декомпилирует внутреннюю форму выражения, в предположении, что все "
"переменные в нём ссылаются на таблицу или отношение, указанное вторым "
"параметром"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16983(function)
msgid "pg_get_expr(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "pg_get_expr(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16989(parameter) func.xml:16994(parameter)
#: func.xml:16999(parameter) func.xml:17004(parameter)
msgid "func_oid"
msgstr "func_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16989(function)
msgid "pg_get_functiondef(<placeholder-1/>)"
msgstr "pg_get_functiondef(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16991(entry)
msgid "get definition of a function"
msgstr "получает определение функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16994(function)
msgid "pg_get_function_arguments(<placeholder-1/>)"
msgstr "pg_get_function_arguments(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16996(entry)
msgid "get argument list of function's definition (with default values)"
msgstr ""
"получает список аргументов из определения функции (со значениями по "
"умолчанию)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:16999(function)
msgid "pg_get_function_identity_arguments(<placeholder-1/>)"
msgstr "pg_get_function_identity_arguments(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17001(entry)
msgid "get argument list to identify a function (without default values)"
msgstr ""
"получает список аргументов, идентифицирующий функцию (без значений по "
"умолчанию)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17004(function)
msgid "pg_get_function_result(<placeholder-1/>)"
msgstr "pg_get_function_result(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17006(entry)
msgid "get <literal>RETURNS</literal> clause for function"
msgstr "получает предложение <literal>RETURNS</literal> для функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17009(parameter) func.xml:17014(parameter)
#: func.xml:17088(parameter) func.xml:17093(parameter)
msgid "index_oid"
msgstr "index_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17009(function)
msgid "pg_get_indexdef(<placeholder-1/>)"
msgstr "pg_get_indexdef(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17011(entry)
msgid "get <command>CREATE INDEX</command> command for index"
msgstr "получает команду <command>CREATE INDEX</command> для индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17014(parameter) func.xml:17088(parameter)
msgid "column_no"
msgstr "column_no"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17014(function)
msgid "pg_get_indexdef(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "pg_get_indexdef(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17016(entry)
msgid ""
"get <command>CREATE INDEX</command> command for index, or definition of just "
"one index column when <parameter>column_no</parameter> is not zero"
msgstr ""
"получает команду <command>CREATE INDEX</command> для индекса или определение "
"одного индексированного столбца, когда <parameter>column_no</parameter> не "
"равен 0"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17021(function)
msgid "pg_get_keywords()"
msgstr "pg_get_keywords()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17023(entry)
msgid "get list of SQL keywords and their categories"
msgstr "получает список ключевых слов SQL по категориям"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17026(parameter) func.xml:17031(parameter)
msgid "rule_oid"
msgstr "rule_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17026(function)
msgid "pg_get_ruledef(<placeholder-1/>)"
msgstr "pg_get_ruledef(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17028(entry) func.xml:17033(entry)
msgid "get <command>CREATE RULE</command> command for rule"
msgstr "получает команду <command>CREATE RULE</command> для правила"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17031(function)
msgid "pg_get_ruledef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_ruledef(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17036(parameter)
msgid "table_name"
msgstr "table_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17036(parameter)
msgid "column_name"
msgstr "column_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17036(function)
msgid "pg_get_serial_sequence(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_serial_sequence(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10
#: func.xml:17038(entry)
msgid "get name of the sequence that a serial or identity column uses"
msgstr ""
"получает имя последовательности, используемой столбцом идентификации или "
"столбцом serial"

#. +> REL_10
#: func.xml:17041(parameter)
msgid "statobj_oid"
msgstr "statobj_oid"

#. +> REL_10
#: func.xml:17041(function)
msgid "pg_get_statisticsobjdef(<placeholder-1/>)"
msgstr "pg_get_statisticsobjdef(<placeholder-1/>)"

#. +> REL_10
#: func.xml:17043(entry)
msgid ""
"get <command>CREATE STATISTICS</command> command for extended statistics "
"object"
msgstr ""
"получает команду <command>CREATE STATISTICS</command> для объекта "
"расширенной статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17046(entry)
msgid ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)"
msgstr ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17048(entry) func.xml:17053(entry)
msgid ""
"get <command>CREATE [ CONSTRAINT ] TRIGGER</command> command for trigger"
msgstr ""
"получает команду <command>CREATE [ CONSTRAINT ] TRIGGER</command> для "
"триггера"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17051(entry)
msgid ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, "
"<parameter>pretty_bool</parameter>)"
msgstr ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, "
"<parameter>pretty_bool</parameter>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17056(parameter)
msgid "role_oid"
msgstr "role_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17056(function)
msgid "pg_get_userbyid(<placeholder-1/>)"
msgstr "pg_get_userbyid(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17058(entry)
msgid "get role name with given OID"
msgstr "получает имя роли по заданному OID"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17061(parameter) func.xml:17066(parameter)
msgid "view_name"
msgstr "view_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17061(function) func.xml:17071(function)
msgid "pg_get_viewdef(<placeholder-1/>)"
msgstr "pg_get_viewdef(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17063(entry) func.xml:17068(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view (<emphasis>deprecated</emphasis>)"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление (<emphasis>устаревшая</emphasis> функция)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17066(function) func.xml:17076(function) func.xml:17081(function)
msgid "pg_get_viewdef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_viewdef(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17071(parameter) func.xml:17076(parameter)
#: func.xml:17081(parameter)
msgid "view_oid"
msgstr "view_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17073(entry) func.xml:17078(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17081(parameter)
msgid "wrap_column_int"
msgstr "wrap_column_int"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17083(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view; lines with fields are wrapped to specified number of columns, pretty-"
"printing is implied"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление; при необходимости разбивает строки с "
"полями, выходящие за wrap_int символов, подразумевая форматированный вывод"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17088(parameter) func.xml:17093(parameter)
#: func.xml:17098(parameter)
msgid "prop_name"
msgstr "prop_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17088(function)
msgid ""
"pg_index_column_has_property(<placeholder-1/>, <placeholder-2/>, "
"<placeholder-3/>)"
msgstr ""
"pg_index_column_has_property(<placeholder-1/>, <placeholder-2/>, "
"<placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17090(entry)
msgid "test whether an index column has a specified property"
msgstr "проверяет, имеет ли столбец индекса заданное свойство"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17093(function)
msgid "pg_index_has_property(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_index_has_property(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17095(entry)
msgid "test whether an index has a specified property"
msgstr "проверяет, имеет ли индекс заданное свойство"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17098(parameter)
msgid "am_oid"
msgstr "am_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17098(function)
msgid "pg_indexam_has_property(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_indexam_has_property(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17100(entry)
msgid "test whether an index access method has a specified property"
msgstr "проверяет, имеет ли метод доступа индекса заданное свойство"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17103(parameter)
msgid "reloptions"
msgstr "reloptions"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17103(function)
msgid "pg_options_to_table(<placeholder-1/>)"
msgstr "pg_options_to_table(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17105(entry)
msgid "get the set of storage option name/value pairs"
msgstr "получает набор параметров хранилища в виде имя/значение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17108(parameter) func.xml:17113(parameter)
msgid "tablespace_oid"
msgstr "tablespace_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17108(function)
msgid "pg_tablespace_databases(<placeholder-1/>)"
msgstr "pg_tablespace_databases(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17109(type)
msgid "setof oid"
msgstr "setof oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17110(entry)
msgid "get the set of database OIDs that have objects in the tablespace"
msgstr ""
"получает или устанавливает OID баз данных, объекты которых содержатся в "
"заданном табличном пространстве"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17113(function)
msgid "pg_tablespace_location(<placeholder-1/>)"
msgstr "pg_tablespace_location(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17115(entry)
msgid "get the path in the file system that this tablespace is located in"
msgstr ""
"получает путь в файловой системе к местоположению заданного табличного "
"пространства"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17118(parameter) func.xml:17123(parameter)
msgctxt "parameter"
msgid "any"
msgstr "any"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17118(function)
msgid "pg_typeof(<placeholder-1/>)"
msgstr "pg_typeof(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17119(type) func.xml:17154(type)
msgid "regtype"
msgstr "regtype"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17120(entry)
msgid "get the data type of any value"
msgstr "получает тип данных любого значения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17123(function)
msgid "collation for (<placeholder-1/>)"
msgstr "collation for (<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17125(entry)
msgid "get the collation of the argument"
msgstr "получает правило сортировки для аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17128(parameter)
msgid "rel_name"
msgstr "rel_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17128(function)
msgid "to_regclass(<placeholder-1/>)"
msgstr "to_regclass(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17130(entry)
msgid "get the OID of the named relation"
msgstr "получает OID указанного отношения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17133(parameter) func.xml:17138(parameter)
msgid "func_name"
msgstr "func_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17133(function)
msgid "to_regproc(<placeholder-1/>)"
msgstr "to_regproc(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17134(type)
msgid "regproc"
msgstr "regproc"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17135(entry) func.xml:17140(entry)
msgid "get the OID of the named function"
msgstr "получает OID указанной функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17138(function)
msgid "to_regprocedure(<placeholder-1/>)"
msgstr "to_regprocedure(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17139(type)
msgid "regprocedure"
msgstr "regprocedure"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17143(parameter) func.xml:17148(parameter)
msgid "operator_name"
msgstr "имя_оператора"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17143(function)
msgid "to_regoper(<placeholder-1/>)"
msgstr "to_regoper(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17144(type)
msgid "regoper"
msgstr "regoper"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17145(entry) func.xml:17150(entry)
msgid "get the OID of the named operator"
msgstr "получает OID указанного оператора"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17148(function)
msgid "to_regoperator(<placeholder-1/>)"
msgstr "to_regoperator(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17149(type)
msgid "regoperator"
msgstr "regoperator"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17153(parameter)
msgid "type_name"
msgstr "type_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17153(function)
msgid "to_regtype(<placeholder-1/>)"
msgstr "to_regtype(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17155(entry)
msgid "get the OID of the named type"
msgstr "получает OID указанного типа"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17158(parameter)
msgctxt "parameter"
msgid "schema_name"
msgstr "schema_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17158(function)
msgid "to_regnamespace(<placeholder-1/>)"
msgstr "to_regnamespace(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17159(type) func.xml:19757(type)
msgid "regnamespace"
msgstr "regnamespace"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17160(entry)
msgid "get the OID of the named schema"
msgstr "получает OID указанной схемы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17163(parameter)
msgid "role_name"
msgstr "role_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17163(function)
msgid "to_regrole(<placeholder-1/>)"
msgstr "to_regrole(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17164(type)
msgid "regrole"
msgstr "regrole"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17165(entry)
msgid "get the OID of the named role"
msgstr "получает OID указанной роли"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17171(para)
msgid ""
"<function>format_type</function> returns the SQL name of a data type that is "
"identified by its type OID and possibly a type modifier. Pass NULL for the "
"type modifier if no specific modifier is known."
msgstr ""
"<function>format_type</function> возвращает в формате SQL имя типа данных, "
"определяемого по OID и, возможно, модификатору типа. Если модификатор "
"неизвестен, вместо него можно передать NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17177(para)
msgid ""
"<function>pg_get_keywords</function> returns a set of records describing the "
"SQL keywords recognized by the server. The <structfield>word</structfield> "
"column contains the keyword. The <structfield>catcode</structfield> column "
"contains a category code: <literal>U</literal> for unreserved, <literal>C</"
"literal> for column name, <literal>T</literal> for type or function name, or "
"<literal>R</literal> for reserved. The <structfield>catdesc</structfield> "
"column contains a possibly-localized string describing the category."
msgstr ""
"<function>pg_get_keywords</function> возвращает таблицу с ключевыми словами "
"SQL, которые воспринимает сервер. Столбец <structfield>word</structfield> "
"содержит ключевое слово, а <structfield>catcode</structfield> &mdash; код "
"категории: <literal>U</literal> &mdash; не зарезервировано, <literal>C</"
"literal> &mdash; имя столбца, <literal>T</literal> &mdash; имя типа или "
"функции, <literal>R</literal> &mdash; зарезервировано. Столбец "
"<structfield>catdesc</structfield> содержит возможно локализованное описание "
"категории."

#. +> REL_10
#: func.xml:17187(para)
msgid ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function>, "
"<function>pg_get_statisticsobjdef</function>, and "
"<function>pg_get_triggerdef</function>, respectively reconstruct the "
"creating command for a constraint, index, rule, extended statistics object, "
"or trigger. (Note that this is a decompiled reconstruction, not the original "
"text of the command.) <function>pg_get_expr</function> decompiles the "
"internal form of an individual expression, such as the default value for a "
"column. It can be useful when examining the contents of system catalogs. If "
"the expression might contain Vars, specify the OID of the relation they "
"refer to as the second parameter; if no Vars are expected, zero is "
"sufficient. <function>pg_get_viewdef</function> reconstructs the "
"<command>SELECT</command> query that defines a view. Most of these functions "
"come in two variants, one of which can optionally <quote>pretty-print</"
"quote> the result. The pretty-printed format is more readable, but the "
"default format is more likely to be interpreted the same way by future "
"versions of <productname>PostgreSQL</productname>; avoid using pretty-"
"printed output for dump purposes. Passing <literal>false</literal> for the "
"pretty-print parameter yields the same result as the variant that does not "
"have the parameter at all."
msgstr ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function>, "
"<function>pg_get_statisticsobjdef</function> и <function>pg_get_triggerdef</"
"function> восстанавливают команду, создававшую заданное ограничение, индекс, "
"правило, объект статистики или триггер, соответственно. (Учтите, что они "
"возвращают не изначальный текст команды, а результат декомпиляции.) "
"<function>pg_get_expr</function> декомпилирует внутреннюю форму отдельного "
"выражения, например значения по умолчанию для столбца. Это может быть "
"полезно для изучения содержимого системных каталогов. Если выражение может "
"содержать переменные, укажите во втором параметре OID отношения, на который "
"они ссылаются; если таких переменных нет, вместо OID можно передать 0. "
"<function>pg_get_viewdef</function> восстанавливает запрос <command>SELECT</"
"command>, определяющий представление. Многие из этих функций имеют две "
"версии, одна из которых позволяет получить форматированный вывод (с "
"параметром pretty_bool). Форматированный текст легче читается, но нет "
"гарантии, что он будет всегда восприниматься одинаково будущими версиями "
"<productname>PostgreSQL</productname>; поэтому не следует применять "
"форматирование при выгрузке метаданных. Если в параметре pretty_bool "
"передаётся <literal>false</literal>, эта версия функции выдаёт тот же "
"результат, что и версия без параметров."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17209(para)
msgid ""
"<function>pg_get_functiondef</function> returns a complete <command>CREATE "
"OR REPLACE FUNCTION</command> statement for a function. "
"<function>pg_get_function_arguments</function> returns the argument list of "
"a function, in the form it would need to appear in within <command>CREATE "
"FUNCTION</command>. <function>pg_get_function_result</function> similarly "
"returns the appropriate <literal>RETURNS</literal> clause for the function. "
"<function>pg_get_function_identity_arguments</function> returns the argument "
"list necessary to identify a function, in the form it would need to appear "
"in within <command>ALTER FUNCTION</command>, for instance. This form omits "
"default values."
msgstr ""
"<function>pg_get_functiondef</function> возвращает полный оператор "
"<command>CREATE OR REPLACE FUNCTION</command> для заданной функции. "
"<function>pg_get_function_arguments</function> возвращает список аргументов "
"функции, в виде достаточном для включения в команду <command>CREATE "
"FUNCTION</command>. <function>pg_get_function_result</function> в дополнение "
"возвращает готовое предложение <literal>RETURNS</literal> для функции. "
"<function>pg_get_function_identity_arguments</function> возвращает список "
"аргументов, достаточный для однозначной идентификации функции, в форме, "
"допустимой, например для команды <command>ALTER FUNCTION</command>. Значения "
"по умолчанию в этой форме опускаются."

#. +> REL_10
#: func.xml:17244(programlisting)
#, no-wrap
msgid "SELECT currval(pg_get_serial_sequence('sometable', 'id'));"
msgstr "SELECT currval(pg_get_serial_sequence('sometable', 'id'));"

#. +> REL_10
#: func.xml:17223(para)
msgid ""
"<function>pg_get_serial_sequence</function> returns the name of the sequence "
"associated with a column, or NULL if no sequence is associated with the "
"column. If the column is an identity column, the associated sequence is the "
"sequence internally created for the identity column. For columns created "
"using one of the serial types (<type>serial</type>, <type>smallserial</"
"type>, <type>bigserial</type>), it is the sequence created for that serial "
"column definition. In the latter case, this association can be modified or "
"removed with <command>ALTER SEQUENCE OWNED BY</command>. (The function "
"probably should have been called <function>pg_get_owned_sequence</function>; "
"its current name reflects the fact that it has typically been used with "
"<type>serial</type> or <type>bigserial</type> columns.) The first input "
"parameter is a table name with optional schema, and the second parameter is "
"a column name. Because the first parameter is potentially a schema and "
"table, it is not treated as a double-quoted identifier, meaning it is lower "
"cased by default, while the second parameter, being just a column name, is "
"treated as double-quoted and has its case preserved. The function returns a "
"value suitably formatted for passing to sequence functions (see <xref "
"linkend=\"functions-sequence\"/>). A typical use is in reading the current "
"value of a sequence for an identity or serial column, for example: "
"<placeholder-1/>"
msgstr ""
"<function>pg_get_serial_sequence</function> возвращает имя "
"последовательности, связанной со столбцом, либо NULL, если такой "
"последовательности нет. Для столбца идентификации это будет "
"последовательность, связанная с ним внутренним образом. Для столбцов, "
"имеющих один из последовательных типов (<type>serial</type>, "
"<type>smallserial</type>, <type>bigserial</type>), это последовательность, "
"созданная объявлением данного столбца. В последнем случае эту связь можно "
"изменить или разорвать, воспользовавшись командой <command>ALTER SEQUENCE "
"OWNED BY</command>. (Возможно, эту функцию стоило назвать "
"<function>pg_get_owned_sequence</function>; её существующее имя отражает тот "
"факт, что она обычно используется со столбцами <type>serial</type> или "
"<type>bigserial</type>.) В первом параметре функции указывается имя таблицы, "
"возможно дополненное схемой, а во втором имя столбца. Так как первый "
"параметр может содержать имя схемы и таблицы, он воспринимается не как "
"идентификатор в кавычках и поэтому по умолчанию приводится к нижнему "
"регистру, тогда как имя столбца во втором параметре воспринимается как "
"заключённое в кавычки и в нём регистр символов сохраняется. Эта функция "
"возвращает имя в виде, пригодном для передачи функциям, работающим с "
"последовательностями (см. <xref remap=\"4\" linkend=\"functions-sequence\"/"
">). Обычно она применяется для получения текущего значения "
"последовательности для столбца идентификации или последовательного столбца, "
"например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17249(para)
msgid ""
"<function>pg_get_userbyid</function> extracts a role's name given its OID."
msgstr "<function>pg_get_userbyid</function> получает имя роли по её OID."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17254(para)
msgid ""
"<function>pg_index_column_has_property</function>, "
"<function>pg_index_has_property</function>, and "
"<function>pg_indexam_has_property</function> return whether the specified "
"index column, index, or index access method possesses the named property. "
"<literal>NULL</literal> is returned if the property name is not known or "
"does not apply to the particular object, or if the OID or column number does "
"not identify a valid object. Refer to <xref linkend=\"functions-info-index-"
"column-props\"/> for column properties, <xref linkend=\"functions-info-index-"
"props\"/> for index properties, and <xref linkend=\"functions-info-indexam-"
"props\"/> for access method properties. (Note that extension access methods "
"can define additional property names for their indexes.)"
msgstr ""
"Функции <function>pg_index_column_has_property</function>, "
"<function>pg_index_has_property</function> и "
"<function>pg_indexam_has_property</function> показывают, обладает ли "
"указанный столбец индекса, индекс или метод доступа индекса заданным "
"свойством. Они возвращают <literal>NULL</literal>, если имя свойства "
"неизвестно или неприменимо к конкретному объекту, либо если OID или номер "
"столбца не указывают на действительный объект. Описание свойств столбцов вы "
"можете найти в <xref remap=\"6\" linkend=\"functions-info-index-column-props"
"\"/>, свойства индексов описаны в <xref remap=\"6\" linkend=\"functions-info-"
"index-props\"/>, а свойства методов доступа — в <xref linkend=\"functions-"
"info-indexam-props\"/>. (Заметьте, что методы доступа, реализуемые "
"расширениями, могут определять для своих индексов дополнительные имена "
"свойств.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17270(title)
msgid "Index Column Properties"
msgstr "Свойства столбца индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17277(literal)
msgid "asc"
msgstr "asc"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17278(entry)
msgid "Does the column sort in ascending order on a forward scan?"
msgstr "Сортируется ли столбец по возрастанию при сканировании вперёд?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17282(literal)
msgid "desc"
msgstr "desc"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17283(entry)
msgid "Does the column sort in descending order on a forward scan?"
msgstr "Сортируется ли столбец по убыванию при сканировании вперёд?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17287(literal)
msgid "nulls_first"
msgstr "nulls_first"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17288(entry)
msgid "Does the column sort with nulls first on a forward scan?"
msgstr "Выдаются ли NULL в начале при сканирования вперёд?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17292(literal)
msgid "nulls_last"
msgstr "nulls_last"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17293(entry)
msgid "Does the column sort with nulls last on a forward scan?"
msgstr "Выдаются ли NULL в конце при сканировании вперёд?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17297(literal)
msgid "orderable"
msgstr "orderable"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17298(entry)
msgid "Does the column possess any defined sort ordering?"
msgstr "Связан ли со столбцом некоторый порядок сортировки?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17302(literal)
msgid "distance_orderable"
msgstr "distance_orderable"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17303(entry)
msgid ""
"Can the column be scanned in order by a <quote>distance</quote> operator, "
"for example <literal>ORDER BY col &lt;-&gt; constant</literal> ?"
msgstr ""
"Может ли столбец сканироваться по порядку оператором <quote>расстояния</"
"quote>, например, <literal>ORDER BY столбец &lt;-&gt; константа</literal> ?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17308(literal)
msgid "returnable"
msgstr "returnable"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17309(entry)
msgid "Can the column value be returned by an index-only scan?"
msgstr ""
"Может ли значение столбца быть получено при сканировании только индекса?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17313(literal)
msgid "search_array"
msgstr "search_array"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17314(entry)
msgid ""
"Does the column natively support <literal>col = ANY(array)</literal> "
"searches?"
msgstr ""
"Поддерживает ли столбец внутренними средствами поиск <literal>столбец = "
"ANY(массив)</literal>?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17319(literal)
msgid "search_nulls"
msgstr "search_nulls"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17320(entry)
msgid ""
"Does the column support <literal>IS NULL</literal> and <literal>IS NOT NULL</"
"literal> searches?"
msgstr ""
"Поддерживает ли столбец поиск <literal>IS NULL</literal> и <literal>IS NOT "
"NULL</literal>?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17329(title)
msgid "Index Properties"
msgstr "Свойства индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17336(literal)
msgid "clusterable"
msgstr "clusterable"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17337(entry)
msgid "Can the index be used in a <literal>CLUSTER</literal> command?"
msgstr "Может ли индекс использоваться в команде <literal>CLUSTER</literal>?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17341(literal)
msgid "index_scan"
msgstr "index_scan"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17342(entry)
msgid "Does the index support plain (non-bitmap) scans?"
msgstr "Поддерживает ли индекс простое сканирование (не по битовой карте)?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17346(literal)
msgid "bitmap_scan"
msgstr "bitmap_scan"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17347(entry)
msgid "Does the index support bitmap scans?"
msgstr "Поддерживает ли индекс сканирование по битовой карте?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17351(literal)
msgid "backward_scan"
msgstr "backward_scan"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17352(entry)
msgid "Can the index be scanned backwards?"
msgstr "Может ли индекс сканироваться в обратном направлении?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17360(title)
msgid "Index Access Method Properties"
msgstr "Свойства метода доступа индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17367(literal)
msgid "can_order"
msgstr "can_order"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17368(entry)
msgid ""
"Does the access method support <literal>ASC</literal>, <literal>DESC</"
"literal> and related keywords in <literal>CREATE INDEX</literal>?"
msgstr ""
"Поддерживает ли метод доступа <literal>ASC</literal>, <literal>DESC</"
"literal> и связанные ключевые слова в <literal>CREATE INDEX</literal>?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17374(literal)
msgid "can_unique"
msgstr "can_unique"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17375(entry)
msgid "Does the access method support unique indexes?"
msgstr "Поддерживает ли метод доступа уникальные индексы?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17379(literal)
msgid "can_multi_col"
msgstr "can_multi_col"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17380(entry)
msgid "Does the access method support indexes with multiple columns?"
msgstr "Поддерживает ли метод доступа индексы по нескольким столбцам?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17384(literal)
msgid "can_exclude"
msgstr "can_exclude"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17385(entry)
msgid "Does the access method support exclusion constraints?"
msgstr "Поддерживает ли метод доступа ограничения-исключения?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17392(para)
msgid ""
"<function>pg_options_to_table</function> returns the set of storage option "
"name/value pairs (<replaceable>option_name</replaceable>/"
"<replaceable>option_value</replaceable>) when passed <structname>pg_class</"
"structname>.<structfield>reloptions</structfield> or "
"<structname>pg_attribute</structname>.<structfield>attoptions</structfield>."
msgstr ""
"<function>pg_options_to_table</function> возвращает набор параметров "
"хранилища в виде пар (<replaceable>имя_параметра</replaceable>/"
"<replaceable>значение_параметра</replaceable>), когда ей передаётся "
"<structname>pg_class</structname>.<structfield>reloptions</structfield> или "
"<structname>pg_attribute</structname>.<structfield>attoptions</structfield>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17400(para)
msgid ""
"<function>pg_tablespace_databases</function> allows a tablespace to be "
"examined. It returns the set of OIDs of databases that have objects stored "
"in the tablespace. If this function returns any rows, the tablespace is not "
"empty and cannot be dropped. To display the specific objects populating the "
"tablespace, you will need to connect to the databases identified by "
"<function>pg_tablespace_databases</function> and query their "
"<structname>pg_class</structname> catalogs."
msgstr ""
"<function>pg_tablespace_databases</function> позволяет изучить содержимое "
"табличного пространства. Она возвращает набор OID баз данных, объекты "
"которых размещены в этом табличном пространстве. Если эта функция возвращает "
"строки, это означает, что табличное пространство не пустое и удалить его "
"нельзя. Какие именно объекты находятся в табличном пространстве, можно "
"узнать, подключаясь к базам данных, OID которых сообщила "
"<function>pg_tablespace_databases</function>, и анализируя их каталоги "
"<structname>pg_class</structname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17417(programlisting)
#, no-wrap
msgid ""
"SELECT pg_typeof(33);\n"
"\n"
" pg_typeof \n"
"-----------\n"
" integer\n"
"(1 row)\n"
"\n"
"SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);\n"
" typlen \n"
"--------\n"
"      4\n"
"(1 row)"
msgstr ""
"SELECT pg_typeof(33);\n"
"\n"
" pg_typeof \n"
"-----------\n"
" integer\n"
"(1 row)\n"
"\n"
"SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);\n"
" typlen \n"
"--------\n"
"      4\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17410(para)
msgid ""
"<function>pg_typeof</function> returns the OID of the data type of the value "
"that is passed to it. This can be helpful for troubleshooting or dynamically "
"constructing SQL queries. The function is declared as returning "
"<type>regtype</type>, which is an OID alias type (see <xref linkend="
"\"datatype-oid\"/>); this means that it is the same as an OID for comparison "
"purposes but displays as a type name. For example: <placeholder-1/>"
msgstr ""
"<function>pg_typeof</function> возвращает OID типа данных для переданного "
"значения. Это может быть полезно для разрешения проблем или динамического "
"создания SQL-запросов. Эта функция объявлена как возвращающая тип "
"<type>regtype</type>, который является псевдонимом типа OID (см. <xref remap="
"\"4\" linkend=\"datatype-oid\"/>); это означает, что значение этого типа "
"можно сравнивать как OID, но выводится оно как название типа. Например: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17436(programlisting)
#, no-wrap
msgid ""
"SELECT collation for (description) FROM pg_description LIMIT 1;\n"
" pg_collation_for \n"
"------------------\n"
" \"default\"\n"
"(1 row)\n"
"\n"
"SELECT collation for ('foo' COLLATE \"de_DE\");\n"
" pg_collation_for \n"
"------------------\n"
" \"de_DE\"\n"
"(1 row)"
msgstr ""
"SELECT collation for (description) FROM pg_description LIMIT 1;\n"
" pg_collation_for \n"
"------------------\n"
" \"default\"\n"
"(1 row)\n"
"\n"
"SELECT collation for ('foo' COLLATE \"de_DE\");\n"
" pg_collation_for \n"
"------------------\n"
" \"de_DE\"\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17433(para)
msgid ""
"The expression <literal>collation for</literal> returns the collation of the "
"value that is passed to it. Example: <placeholder-1/> The value might be "
"quoted and schema-qualified. If no collation is derived for the argument "
"expression, then a null value is returned. If the argument is not of a "
"collatable data type, then an error is raised."
msgstr ""
"Выражение <literal>collation for</literal> возвращает правило сортировки для "
"переданного значения. Например: <placeholder-1/> Это значение может быть "
"заключено в кавычки и дополнено схемой. Если для выражения аргумента нет "
"правила сортировки, возвращается значение NULL. Если же правила сортировки "
"не применимы для типа аргумента, происходит ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17454(para)
msgid ""
"The <function>to_regclass</function>, <function>to_regproc</function>, "
"<function>to_regprocedure</function>, <function>to_regoper</function>, "
"<function>to_regoperator</function>, <function>to_regtype</function>, "
"<function>to_regnamespace</function>, and <function>to_regrole</function> "
"functions translate relation, function, operator, type, schema, and role "
"names (given as <type>text</type>) to objects of type <type>regclass</type>, "
"<type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, "
"<type>regoperator</type>, <type>regtype</type>, <type>regnamespace</type>, "
"and <type>regrole</type> respectively. These functions differ from a cast "
"from text in that they don't accept a numeric OID, and that they return null "
"rather than throwing an error if the name is not found (or, for "
"<function>to_regproc</function> and <function>to_regoper</function>, if the "
"given name matches multiple objects)."
msgstr ""
"Функции <function>to_regclass</function>, <function>to_regproc</function>, "
"<function>to_regprocedure</function>, <function>to_regoper</function>, "
"<function>to_regoperator</function>, <function>to_regtype</function>, "
"<function>to_regnamespace</function> и <function>to_regrole</function> "
"преобразуют имена отношений, функций, операторов, типов, схем и ролей "
"(заданных значением <type>text</type>) в объекты типа <type>regclass</type>, "
"<type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, "
"<type>regoperator</type>, <type>regtype</type>, <type>regnamespace</type> и "
"<type>regrole</type>, соответственно. Перечисленные функции отличаются от "
"явных приведений к этим типам тем, что они не принимают числовые OID и "
"возвращают NULL вместо ошибки, если имя не найдено (или, в случае с "
"<function>to_regproc</function> и <function>to_regoper</function>, если "
"данному имени соответствуют несколько объектов)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17471(indexterm)
msgid "<primary>pg_describe_object</primary>"
msgstr "<primary>pg_describe_object</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17475(indexterm)
msgid "<primary>pg_identify_object</primary>"
msgstr "<primary>pg_identify_object</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17479(indexterm)
msgid "<primary>pg_identify_object_as_address</primary>"
msgstr "<primary>pg_identify_object_as_address</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17483(indexterm)
msgid "<primary>pg_get_object_address</primary>"
msgstr "<primary>pg_get_object_address</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17487(para)
msgid ""
"<xref linkend=\"functions-info-object-table\"/> lists functions related to "
"database object identification and addressing."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-object-table\"/> перечислены "
"функции, связанные с идентификацией и адресацией объектов баз данных."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17493(title)
msgid "Object Information and Addressing Functions"
msgstr "Функции получения информации и адресации объектов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17501(parameter) func.xml:17506(parameter)
#: func.xml:17511(parameter)
msgid "catalog_id"
msgstr "catalog_id"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17501(parameter) func.xml:17506(parameter)
#: func.xml:17511(parameter)
msgid "object_id"
msgstr "object_id"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17501(parameter) func.xml:17506(parameter)
#: func.xml:17511(parameter)
msgid "object_sub_id"
msgstr "object_sub_id"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17501(function)
msgid ""
"pg_describe_object(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""
"pg_describe_object(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17503(entry)
msgid "get description of a database object"
msgstr "получает описание объекта базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17506(function)
msgid ""
"pg_identify_object(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_identify_object(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17507(entry)
msgid ""
"<parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> "
"<type>text</type>, <parameter>name</parameter> <type>text</type>, "
"<parameter>identity</parameter> <type>text</type>"
msgstr ""
"<parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> "
"<type>text</type>, <parameter>name</parameter> <type>text</type>, "
"<parameter>identity</parameter> <type>text</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17508(entry)
msgid "get identity of a database object"
msgstr "получает идентификатор объекта базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17511(function)
msgid ""
"pg_identify_object_as_address(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_identify_object_as_address(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17512(entry)
msgid ""
"<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> "
"<type>text[]</type>, <parameter>args</parameter> <type>text[]</type>"
msgstr ""
"<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> "
"<type>text[]</type>, <parameter>args</parameter> <type>text[]</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17513(entry)
msgid "get external representation of a database object's address"
msgstr "получает внешнее представление адреса объекта базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17516(parameter) func.xml:18505(parameter)
msgctxt "parameter"
msgid "name"
msgstr "name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17516(parameter)
msgctxt "parameter"
msgid "args"
msgstr "аргументы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17516(function)
msgid ""
"pg_get_object_address(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_get_object_address(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17517(entry)
msgid ""
"<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</"
"parameter> <type>oid</type>, <parameter>object_sub_id</parameter> "
"<type>int32</type>"
msgstr ""
"<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</"
"parameter> <type>oid</type>, <parameter>object_sub_id</parameter> "
"<type>int32</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17518(entry)
msgid "get address of a database object, from its external representation"
msgstr "получает адрес объекта базы данных из его внешнего представления"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17524(para)
msgid ""
"<function>pg_describe_object</function> returns a textual description of a "
"database object specified by catalog OID, object OID and a (possibly zero) "
"sub-object ID. This description is intended to be human-readable, and might "
"be translated, depending on server configuration. This is useful to "
"determine the identity of an object as stored in the <structname>pg_depend</"
"structname> catalog."
msgstr ""
"<function>pg_describe_object</function> возвращает текстовое описание "
"объекта БД, идентифицируемого по OID каталога, OID объекта и ID подобъекта "
"(может быть нулевым). Это описание предназначено для человека и может "
"переводиться, в зависимости от конфигурации сервера. С помощью этой функции, "
"например, можно узнать, что за объект хранится в каталоге "
"<structname>pg_depend</structname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17533(para)
msgid ""
"<function>pg_identify_object</function> returns a row containing enough "
"information to uniquely identify the database object specified by catalog "
"OID, object OID and a (possibly zero) sub-object ID. This information is "
"intended to be machine-readable, and is never translated. <parameter>type</"
"parameter> identifies the type of database object; <parameter>schema</"
"parameter> is the schema name that the object belongs in, or <literal>NULL</"
"literal> for object types that do not belong to schemas; <parameter>name</"
"parameter> is the name of the object, quoted if necessary, only present if "
"it can be used (alongside schema name, if pertinent) as a unique identifier "
"of the object, otherwise <literal>NULL</literal>; <parameter>identity</"
"parameter> is the complete object identity, with the precise format "
"depending on object type, and each part within the format being schema-"
"qualified and quoted as necessary."
msgstr ""
"<function>pg_identify_object</function> возвращает запись, содержащую "
"достаточно информации для однозначной идентификации объекта БД по OID "
"каталога, OID объекта и ID подобъекта (может быть нулевым). Эта информация "
"предназначена для машины и поэтому никогда не переводится. Столбец "
"<parameter>type</parameter> содержит тип объекта БД; <parameter>schema</"
"parameter> &mdash; имя схемы, к которой относится объект (либо "
"<literal>NULL</literal> для объектов, не относящихся к схемам); "
"<parameter>name</parameter> &mdash; имя объекта, при необходимости в "
"кавычках, которое присутствует только если оно (возможно, вместе со схемой) "
"однозначно идентифицирует объект (в противном случае <literal>NULL</"
"literal>); <parameter>identity</parameter> &mdash; полный идентификатор "
"объекта, точный формат которого зависит от типа объекта, а каждая его часть "
"дополняется схемой и заключается в кавычки, если требуется."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17549(para)
msgid ""
"<function>pg_identify_object_as_address</function> returns a row containing "
"enough information to uniquely identify the database object specified by "
"catalog OID, object OID and a (possibly zero) sub-object ID. The returned "
"information is independent of the current server, that is, it could be used "
"to identify an identically named object in another server. <parameter>type</"
"parameter> identifies the type of database object; <parameter>name</"
"parameter> and <parameter>args</parameter> are text arrays that together "
"form a reference to the object. These three columns can be passed to "
"<function>pg_get_object_address</function> to obtain the internal address of "
"the object. This function is the inverse of <function>pg_get_object_address</"
"function>."
msgstr ""
"<function>pg_identify_object_as_address</function> возвращает строку, "
"содержащую достаточно информации для однозначной идентификации объекта БД по "
"OID каталога, OID объекта и ID подобъекта (может быть нулевым). Выдаваемая "
"информация не зависит от текущего сервера, то есть по ней можно "
"идентифицировать одноимённый объект на другом сервере. Столбец "
"<parameter>type</parameter> содержит тип объекта БД, а <parameter>name</"
"parameter> и <parameter>args</parameter> — текстовые массивы, в совокупности "
"формирующие ссылку на объект. Эти три столбца можно передать функции "
"<function>pg_get_object_address</function>, чтобы получить внутренний адрес "
"объекта. Данная функция является обратной к <function>pg_get_object_address</"
"function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17563(para)
msgid ""
"<function>pg_get_object_address</function> returns a row containing enough "
"information to uniquely identify the database object specified by its type "
"and object name and argument arrays. The returned values are the ones that "
"would be used in system catalogs such as <structname>pg_depend</structname> "
"and can be passed to other system functions such as "
"<function>pg_identify_object</function> or <function>pg_describe_object</"
"function>. <parameter>catalog_id</parameter> is the OID of the system "
"catalog containing the object; <parameter>object_id</parameter> is the OID "
"of the object itself, and <parameter>object_sub_id</parameter> is the object "
"sub-ID, or zero if none. This function is the inverse of "
"<function>pg_identify_object_as_address</function>."
msgstr ""
"<function>pg_get_object_address</function> возвращает запись, содержащую "
"достаточно информации для уникальной идентификации объекта БД по его типу и "
"массивам имён и аргументов. В ней возвращаются значения, которые "
"используются в системных каталогах, например <structname>pg_depend</"
"structname>, и могут передаваться в другие системные функции, например "
"<function>pg_identify_object</function> или <function>pg_describe_object</"
"function>. Столбец <parameter>catalog_id</parameter> содержит OID системного "
"каталога, к которому относится объект; <parameter>object_id</parameter> — "
"OID самого объекта, а <parameter>object_sub_id</parameter> — идентификатор "
"подобъекта, или 0 в случае его отсутствия. Эта функция является обратной к "
"<function>pg_identify_object_as_address</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17577(indexterm)
msgid "<primary>col_description</primary>"
msgstr "<primary>col_description</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17581(indexterm)
msgid "<primary>obj_description</primary>"
msgstr "<primary>obj_description</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17585(indexterm)
msgid "<primary>shobj_description</primary>"
msgstr "<primary>shobj_description</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17589(indexterm)
msgid ""
"<primary>comment</primary> <secondary sortas=\"database objects\">about "
"database objects</secondary>"
msgstr ""
"<primary>комментарии</primary> <secondary sortas=\"database objects\">к "
"объектам баз данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17594(para)
msgid ""
"The functions shown in <xref linkend=\"functions-info-comment-table\"/> "
"extract comments previously stored with the <xref linkend=\"sql-comment\"/> "
"command. A null value is returned if no comment could be found for the "
"specified parameters."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-info-comment-"
"table\"/>, извлекают комментарии, заданные для объектов с помощью команды "
"<xref linkend=\"sql-comment\"/>. Если найти комментарий для заданных "
"параметров не удаётся, они возвращают NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17602(title)
msgid "Comment Information Functions"
msgstr "Функции получения комментариев"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17610(parameter)
msgid "column_number"
msgstr "column_number"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17610(function)
msgid "col_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "col_description(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17612(entry)
msgid "get comment for a table column"
msgstr "получает комментарий для столбца таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17615(parameter) func.xml:17620(parameter)
#: func.xml:17625(parameter)
msgid "object_oid"
msgstr "object_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17615(parameter) func.xml:17625(parameter)
msgid "catalog_name"
msgstr "catalog_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17615(function)
msgid "obj_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "obj_description(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17617(entry)
msgid "get comment for a database object"
msgstr "получает комментарий для объекта базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17620(function)
msgid "obj_description(<placeholder-1/>)"
msgstr "obj_description(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17622(entry)
msgid "get comment for a database object (<emphasis>deprecated</emphasis>)"
msgstr ""
"получает комментарий для объекта базы данных (<emphasis>устаревшая</"
"emphasis> форма)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17625(function)
msgid "shobj_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "shobj_description(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17627(entry)
msgid "get comment for a shared database object"
msgstr "получает комментарий для разделяемого объекта баз данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17633(para)
msgid ""
"<function>col_description</function> returns the comment for a table column, "
"which is specified by the OID of its table and its column number. "
"(<function>obj_description</function> cannot be used for table columns since "
"columns do not have OIDs of their own.)"
msgstr ""
"<function>col_description</function> возвращает комментарий для столбца с "
"заданным номером в таблице с указанным OID. (<function>obj_description</"
"function> нельзя использовать для столбцов таблицы, так столбцы не имеют "
"собственных OID.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17640(para)
msgid ""
"The two-parameter form of <function>obj_description</function> returns the "
"comment for a database object specified by its OID and the name of the "
"containing system catalog. For example, "
"<literal>obj_description(123456,'pg_class')</literal> would retrieve the "
"comment for the table with OID 123456. The one-parameter form of "
"<function>obj_description</function> requires only the object OID. It is "
"deprecated since there is no guarantee that OIDs are unique across different "
"system catalogs; therefore, the wrong comment might be returned."
msgstr ""
"Функция <function>obj_description</function> с двумя параметрами возвращает "
"комментарий для объекта, имеющего заданный OID и находящегося в указанном "
"системном каталоге. Например, <literal>obj_description(123456,'pg_class')</"
"literal> вернёт комментарий для таблицы с OID 123456. Форма "
"<function>obj_description</function> с одним параметром принимает только "
"OID. Она является устаревшей, так как значения OID могут повторяться в "
"разных системных каталогах, и поэтому она может возвращать комментарий для "
"другого объекта."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17652(para)
msgid ""
"<function>shobj_description</function> is used just like "
"<function>obj_description</function> except it is used for retrieving "
"comments on shared objects. Some system catalogs are global to all databases "
"within each cluster, and the descriptions for objects in them are stored "
"globally as well."
msgstr ""
"<function>shobj_description</function> работает подобно "
"<function>obj_description</function>, но она получает комментарии для "
"разделяемых объектов. Некоторые системные каталоги являются глобальными для "
"всех баз данных в кластере и описания объектов в них также хранятся "
"глобально."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17660(indexterm)
msgid "<primary>txid_current</primary>"
msgstr "<primary>txid_current</primary>"

#. +> REL_10
#: func.xml:17664(indexterm)
msgid "<primary>txid_current_if_assigned</primary>"
msgstr "<primary>txid_current_if_assigned</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17668(indexterm)
msgid "<primary>txid_current_snapshot</primary>"
msgstr "<primary>txid_current_snapshot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17672(indexterm)
msgid "<primary>txid_snapshot_xip</primary>"
msgstr "<primary>txid_snapshot_xip</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17676(indexterm)
msgid "<primary>txid_snapshot_xmax</primary>"
msgstr "<primary>txid_snapshot_xmax</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17680(indexterm)
msgid "<primary>txid_snapshot_xmin</primary>"
msgstr "<primary>txid_snapshot_xmin</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17684(indexterm)
msgid "<primary>txid_visible_in_snapshot</primary>"
msgstr "<primary>txid_visible_in_snapshot</primary>"

#. +> REL_10
#: func.xml:17688(indexterm)
msgid "<primary>txid_status</primary>"
msgstr "<primary>txid_status</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17692(para)
msgid ""
"The functions shown in <xref linkend=\"functions-txid-snapshot\"/> provide "
"server transaction information in an exportable form. The main use of these "
"functions is to determine which transactions were committed between two "
"snapshots."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-txid-snapshot"
"\"/>, выдают информацию о транзакциях сервера в форме во внешнем "
"представлении. В основном эти функции используются, чтобы определить, какие "
"транзакции были зафиксированы между двумя снимками состояния."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17700(title)
msgid "Transaction IDs and Snapshots"
msgstr "Идентификаторы транзакций и снимков состояния"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17708(function)
msgid "txid_current()"
msgstr "txid_current()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17710(entry)
msgid ""
"get current transaction ID, assigning a new one if the current transaction "
"does not have one"
msgstr ""
"получает идентификатор текущей транзакции и присваивает новый, если текущая "
"транзакция его не имеет"

#. +> REL_10
#: func.xml:17713(function)
msgid "txid_current_if_assigned()"
msgstr "txid_current_if_assigned()"

#. +> REL_10
#: func.xml:17715(entry)
msgid ""
"same as <function>txid_current()</function> but returns null instead of "
"assigning a new transaction ID if none is already assigned"
msgstr ""
"работает аналогично <function>txid_current()</function>, но возвращает NULL, "
"не присваивая новый идентификатор транзакции, если он ещё не присвоен"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17718(function)
msgid "txid_current_snapshot()"
msgstr "txid_current_snapshot()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17719(type)
msgctxt "type"
msgid "txid_snapshot"
msgstr "txid_snapshot"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17720(entry)
msgid "get current snapshot"
msgstr "получает код текущего снимка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17723(parameter) func.xml:17728(parameter)
#: func.xml:17733(parameter) func.xml:17738(parameter)
msgctxt "parameter"
msgid "txid_snapshot"
msgstr "txid_snapshot"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17723(function)
msgid "txid_snapshot_xip(<placeholder-1/>)"
msgstr "txid_snapshot_xip(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17724(type)
msgid "setof bigint"
msgstr "setof bigint"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17725(entry)
msgid "get in-progress transaction IDs in snapshot"
msgstr "возвращает идентификаторы выполняющихся транзакций в снимке"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17728(function)
msgid "txid_snapshot_xmax(<placeholder-1/>)"
msgstr "txid_snapshot_xmax(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17730(entry)
msgid "get <literal>xmax</literal> of snapshot"
msgstr "возвращает значение <literal>xmax</literal> для заданного снимка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17733(function)
msgid "txid_snapshot_xmin(<placeholder-1/>)"
msgstr "txid_snapshot_xmin(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17735(entry)
msgid "get <literal>xmin</literal> of snapshot"
msgstr "возвращает значение <literal>xmin</literal> для заданного снимка"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17738(parameter) func.xml:17743(parameter)
msgctxt "parameter"
msgid "bigint"
msgstr "bigint"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17738(function)
msgid "txid_visible_in_snapshot(<placeholder-1/>, <placeholder-2/>)"
msgstr "txid_visible_in_snapshot(<placeholder-1/>, <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17740(entry)
msgid ""
"is transaction ID visible in snapshot? (do not use with subtransaction ids)"
msgstr ""
"видима ли транзакция с указанным идентификатором в данном снимке? (коды "
"подтранзакций не поддерживаются)"

#. +> REL_10
#: func.xml:17743(function)
msgid "txid_status(<placeholder-1/>)"
msgstr "txid_status(<placeholder-1/>)"

#. +> REL_10
#: func.xml:17744(type)
msgid "txid_status"
msgstr "txid_status"

#. +> REL_10
#: func.xml:17745(entry)
msgid ""
"report the status of the given transaction: <literal>committed</literal>, "
"<literal>aborted</literal>, <literal>in progress</literal>, or null if the "
"transaction ID is too old"
msgstr ""
"возвращает состояние заданной транзакции — <literal>committed</literal> "
"(зафиксирована), <literal>aborted</literal> (прервана), <literal>in "
"progress</literal> (выполняется) или NULL, если идентификатор транзакции "
"слишком старый"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17751(para)
msgid ""
"The internal transaction ID type (<type>xid</type>) is 32 bits wide and "
"wraps around every 4 billion transactions. However, these functions export a "
"64-bit format that is extended with an <quote>epoch</quote> counter so it "
"will not wrap around during the life of an installation. The data type used "
"by these functions, <type>txid_snapshot</type>, stores information about "
"transaction ID visibility at a particular moment in time. Its components are "
"described in <xref linkend=\"functions-txid-snapshot-parts\"/>."
msgstr ""
"Внутренний тип идентификаторов транзакций (<type>xid</type>) имеет размер 32 "
"бита, поэтому они повторяются через 4 миллиарда транзакций. Однако эти "
"функции выдают 64-битные значения, дополненные счётчиком <quote>эпохи</"
"quote>, так что эти значения останутся уникальными на протяжении всей жизни "
"сервера. Используемый этими функциями тип данных <type>txid_snapshot</type> "
"сохраняет информацию о видимости транзакций в определённый момент времени. "
"Его состав описан в <xref remap=\"6\" linkend=\"functions-txid-snapshot-parts"
"\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17763(title)
msgid "Snapshot Components"
msgstr "Состав информации о снимке"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17775(type)
msgid "xmin"
msgstr "xmin"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17776(entry)
msgid ""
"Earliest transaction ID (txid) that is still active. All earlier "
"transactions will either be committed and visible, or rolled back and dead."
msgstr ""
"Идентификатор самой ранней транзакции (txid) из активных. Все предыдущие "
"транзакции либо зафиксированы и видимы, либо отменены и мертвы."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17784(type)
msgid "xmax"
msgstr "xmax"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17785(entry)
msgid ""
"First as-yet-unassigned txid. All txids greater than or equal to this are "
"not yet started as of the time of the snapshot, and thus invisible."
msgstr ""
"Первый txid из ещё не назначенных. На момент снимка не было запущенных (а "
"значит и видимых) транзакций с идентификатором, большим или равным данному."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17792(type)
msgid "xip_list"
msgstr "xip_list"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17793(entry)
msgid ""
"Active txids at the time of the snapshot. The list includes only those "
"active txids between <literal>xmin</literal> and <literal>xmax</literal>; "
"there might be active txids higher than <literal>xmax</literal>. A txid that "
"is <literal>xmin &lt;= txid &lt; xmax</literal> and not in this list was "
"already completed at the time of the snapshot, and thus either visible or "
"dead according to its commit status. The list does not include txids of "
"subtransactions."
msgstr ""
"Список идентификаторов транзакций, активных в момент снимка. Он включает "
"только идентификаторы с номерами от <literal>xmin</literal> до "
"<literal>xmax</literal>; хотя уже могут быть транзакции с идентификаторами "
"больше <literal>xmax</literal>. Если в этом списке не оказывается "
"идентификатора транзакции <literal>xmin &lt;= txid &lt; xmax</literal>, это "
"означает, что она уже не выполнялась к моменту снимка и, таким образом, "
"видима или мертва, в зависимости от типа завершения. Идентификаторы "
"подтранзакций в этот список не включаются."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17809(para)
msgid ""
"<type>txid_snapshot</type>'s textual representation is "
"<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:"
"<replaceable>xip_list</replaceable></literal>. For example "
"<literal>10:20:10,14,15</literal> means <literal>xmin=10, xmax=20, "
"xip_list=10, 14, 15</literal>."
msgstr ""
"В текстовом виде <type>txid_snapshot</type> представляется как "
"<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:"
"<replaceable>xip_list</replaceable></literal>. Например, "
"<literal>10:20:10,14,15</literal> означает <literal>xmin=10, xmax=20, "
"xip_list=10, 14, 15</literal>."

#. +> REL_10
#: func.xml:17816(para)
msgid ""
"<function>txid_status(bigint)</function> reports the commit status of a "
"recent transaction. Applications may use it to determine whether a "
"transaction committed or aborted when the application and database server "
"become disconnected while a <literal>COMMIT</literal> is in progress. The "
"status of a transaction will be reported as either <literal>in progress</"
"literal>, <literal>committed</literal>, or <literal>aborted</literal>, "
"provided that the transaction is recent enough that the system retains the "
"commit status of that transaction. If is old enough that no references to "
"that transaction survive in the system and the commit status information has "
"been discarded, this function will return NULL. Note that prepared "
"transactions are reported as <literal>in progress</literal>; applications "
"must check <link linkend=\"view-pg-prepared-xacts"
"\"><literal>pg_prepared_xacts</literal></link> if they need to determine "
"whether the txid is a prepared transaction."
msgstr ""
"Функция <function>txid_status(bigint)</function> выдаёт состояние фиксации "
"последней транзакции. Проверяя его, приложения могут определить, была ли "
"транзакция зафиксирована или прервана, когда приложение отключается от "
"сервера баз данных в процессе выполнения <literal>COMMIT</literal>. "
"Состояние транзакции может быть следующим: <literal>in progress</literal> "
"(выполняется), <literal>committed</literal> (зафиксирована) и "
"<literal>aborted</literal> (прервана), если только транзакция не настолько "
"стара, чтобы система удалила информация о её состоянии фиксирования. Если же "
"она так стара, что упоминаний о ней в системе не осталось и информация о "
"фиксации потеряна, эта функция возвращает NULL. Заметьте, что для "
"подготовленных транзакций возвращается состояние <literal>in progress</"
"literal>; приложения должны проверять <link linkend=\"view-pg-prepared-xacts"
"\"><literal>pg_prepared_xacts</literal></link>, если им нужно определить, "
"является ли транзакция «txid» подготовленной."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17834(para)
msgid ""
"The functions shown in <xref linkend=\"functions-commit-timestamp\"/> "
"provide information about transactions that have been already committed. "
"These functions mainly provide information about when the transactions were "
"committed. They only provide useful data when <xref linkend=\"guc-track-"
"commit-timestamp\"/> configuration option is enabled and only for "
"transactions that were committed after it was enabled."
msgstr ""
"Функции, показанные в <xref remap=\"6\" linkend=\"functions-commit-timestamp"
"\"/>, выдают информацию об уже зафиксированных транзакциях. Они возвращают "
"полезные данные, только когда включён параметр конфигурации <xref linkend="
"\"guc-track-commit-timestamp\"/> и только для транзакций, зафиксированных "
"после его включения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17844(title)
msgid "Committed transaction information"
msgstr "Информация о фиксации транзакций"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17853(indexterm)
msgid "<primary>pg_xact_commit_timestamp</primary>"
msgstr "<primary>pg_xact_commit_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17854(parameter)
msgctxt "parameter"
msgid "xid"
msgstr "xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17854(function)
msgid "pg_xact_commit_timestamp(<placeholder-1/>)"
msgstr "pg_xact_commit_timestamp(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17857(entry)
msgid "get commit timestamp of a transaction"
msgstr "выдаёт время фиксации транзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17862(indexterm)
msgid "<primary>pg_last_committed_xact</primary>"
msgstr "<primary>pg_last_committed_xact</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17863(function)
msgid "pg_last_committed_xact()"
msgstr "pg_last_committed_xact()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17865(entry)
msgid ""
"<parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</"
"parameter> <type>timestamp with time zone</type>"
msgstr ""
"<parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</"
"parameter> <type>timestamp with time zone</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17866(entry)
msgid "get transaction ID and commit timestamp of latest committed transaction"
msgstr ""
"выдаёт идентификатор и время фиксации транзакции, зафиксированной последней"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17872(para)
msgid ""
"The functions shown in <xref linkend=\"functions-controldata\"/> print "
"information initialized during <command>initdb</command>, such as the "
"catalog version. They also show information about write-ahead logging and "
"checkpoint processing. This information is cluster-wide, and not specific to "
"any one database. They provide most of the same information, from the same "
"source, as <xref linkend=\"app-pgcontroldata\"/>, although in a form better "
"suited to <acronym>SQL</acronym> functions."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-controldata\"/"
">, выводят свойства, установленные командой <command>initdb</command>, "
"например, версию каталога. Они также выводят сведения о работе журнала "
"предзаписи и контрольных точках. Эта информация относится ко всему кластеру, "
"а не к отдельной базе данных. Данные функции выдают практически всю ту же "
"информацию, и из того же источника, что и <xref linkend=\"app-pgcontroldata"
"\"/>, но в форме, более подходящей для функций <acronym>SQL</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17884(title)
msgid "Control Data Functions"
msgstr "Функции управления данными"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17893(indexterm)
msgid "<primary>pg_control_checkpoint</primary>"
msgstr "<primary>pg_control_checkpoint</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:17893(indexterm)
msgid "<primary>pg_xlogfile_name_offset</primary>"
msgstr "<primary>pg_xlogfile_name_offset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17894(function)
msgid "pg_control_checkpoint()"
msgstr "pg_control_checkpoint()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17897(entry)
msgid "Returns information about current checkpoint state."
msgstr "Возвращает информацию о состоянии текущей контрольной точки."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17904(indexterm)
msgid "<primary>pg_control_system</primary>"
msgstr "<primary>pg_control_system</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17905(function)
msgid "pg_control_system()"
msgstr "pg_control_system()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17908(entry)
msgid "Returns information about current control file state."
msgstr "Возвращает информацию о текущем состоянии управляющего файла."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17915(indexterm)
msgid "<primary>pg_control_init</primary>"
msgstr "<primary>pg_control_init</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17916(function)
msgid "pg_control_init()"
msgstr "pg_control_init()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17919(entry)
msgid "Returns information about cluster initialization state."
msgstr "Возвращает информацию о состоянии инициализации кластера."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17926(indexterm)
msgid "<primary>pg_control_recovery</primary>"
msgstr "<primary>pg_control_recovery</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17927(function)
msgid "pg_control_recovery()"
msgstr "pg_control_recovery()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17930(entry)
msgid "Returns information about recovery state."
msgstr "Возвращает информацию о состоянии восстановления."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17939(para)
msgid ""
"<function>pg_control_checkpoint</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-checkpoint\"/>"
msgstr ""
"Функция <function>pg_control_checkpoint</function> возвращает запись, "
"показанную в <xref remap=\"6\" linkend=\"functions-pg-control-checkpoint\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17945(title)
msgid "<function>pg_control_checkpoint</function> Columns"
msgstr "Столбцы результата <function>pg_control_checkpoint</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17949(entry) func.xml:18065(entry) func.xml:18106(entry)
#: func.xml:18187(entry)
msgid "Column Name"
msgstr "Имя столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17950(entry) func.xml:18066(entry) func.xml:18107(entry)
#: func.xml:18188(entry)
msgid "Data Type"
msgstr "Тип данных"

#. +> REL_10
#: func.xml:17957(literal)
msgid "checkpoint_lsn"
msgstr "checkpoint_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17958(type) func.xml:17963(type) func.xml:17968(type)
#: func.xml:18196(type) func.xml:18206(type) func.xml:18211(type)
#: func.xml:18507(type) func.xml:18514(type) func.xml:18521(type)
#: func.xml:18528(type) func.xml:18535(type) func.xml:18542(type)
#: func.xml:18570(type) func.xml:18575(type) func.xml:18582(type)
#: func.xml:18589(type) func.xml:18770(type) func.xml:18784(type)
#: func.xml:19070(type) func.xml:19095(type) func.xml:19113(type)
#: func.xml:19130(type) func.xml:19249(type) func.xml:19264(type)
#: func.xml:19299(type) func.xml:19321(type) func.xml:19339(type)
#: func.xml:19358(type)
msgid "pg_lsn"
msgstr "pg_lsn"

#. +> REL_10
#: func.xml:17962(literal)
msgid "prior_lsn"
msgstr "prior_lsn"

#. +> REL_10
#: func.xml:17967(literal)
msgid "redo_lsn"
msgstr "redo_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17972(literal)
msgid "redo_wal_file"
msgstr "redo_wal_file"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17977(literal)
msgid "timeline_id"
msgstr "timeline_id"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17982(literal)
msgid "prev_timeline_id"
msgstr "prev_timeline_id"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17987(literal)
msgid "full_page_writes"
msgstr "full_page_writes"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17992(literal)
msgid "next_xid"
msgstr "next_xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:17997(literal)
msgid "next_oid"
msgstr "next_oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18002(literal)
msgid "next_multixact_id"
msgstr "next_multixact_id"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18003(type) func.xml:18008(type) func.xml:18013(type)
#: func.xml:18023(type) func.xml:18028(type) func.xml:18038(type)
#: func.xml:18043(type)
msgctxt "type"
msgid "xid"
msgstr "xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18007(literal)
msgid "next_multi_offset"
msgstr "next_multi_offset"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18012(literal)
msgid "oldest_xid"
msgstr "oldest_xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18017(literal)
msgid "oldest_xid_dbid"
msgstr "oldest_xid_dbid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18022(literal)
msgid "oldest_active_xid"
msgstr "oldest_active_xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18027(literal)
msgid "oldest_multi_xid"
msgstr "oldest_multi_xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18032(literal)
msgid "oldest_multi_dbid"
msgstr "oldest_multi_dbid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18037(literal)
msgid "oldest_commit_ts_xid"
msgstr "oldest_commit_ts_xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18042(literal)
msgid "newest_commit_ts_xid"
msgstr "newest_commit_ts_xid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18047(literal)
msgid "checkpoint_time"
msgstr "checkpoint_time"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18055(para)
msgid ""
"<function>pg_control_system</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-system\"/>"
msgstr ""
"Функция <function>pg_control_system</function> возвращает запись, показанную "
"в <xref remap=\"6\" linkend=\"functions-pg-control-system\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18061(title)
msgid "<function>pg_control_system</function> Columns"
msgstr "Столбцы результата <function>pg_control_system</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18073(literal)
msgid "pg_control_version"
msgstr "pg_control_version"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18078(literal)
msgid "catalog_version_no"
msgstr "catalog_version_no"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18083(literal)
msgid "system_identifier"
msgstr "system_identifier"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18088(literal)
msgid "pg_control_last_modified"
msgstr "pg_control_last_modified"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18096(para)
msgid ""
"<function>pg_control_init</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-init\"/>"
msgstr ""
"Функция <function>pg_control_init</function> возвращает запись, показанную в "
"<xref remap=\"6\" linkend=\"functions-pg-control-init\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18102(title)
msgid "<function>pg_control_init</function> Columns"
msgstr "Столбцы результата <function>pg_control_init</function>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18114(literal)
msgid "max_data_alignment"
msgstr "max_data_alignment"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18119(literal)
msgid "database_block_size"
msgstr "database_block_size"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18124(literal)
msgid "blocks_per_segment"
msgstr "blocks_per_segment"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18129(literal)
msgid "wal_block_size"
msgstr "wal_block_size"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18134(literal)
msgid "bytes_per_wal_segment"
msgstr "bytes_per_wal_segment"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18139(literal)
msgid "max_identifier_length"
msgstr "max_identifier_length"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18144(literal)
msgid "max_index_columns"
msgstr "max_index_columns"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18149(literal)
msgid "max_toast_chunk_size"
msgstr "max_toast_chunk_size"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18154(literal)
msgid "large_object_chunk_size"
msgstr "large_object_chunk_size"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18159(literal)
msgid "float4_pass_by_value"
msgstr "float4_pass_by_value"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18164(literal)
msgid "float8_pass_by_value"
msgstr "float8_pass_by_value"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18169(literal)
msgid "data_page_checksum_version"
msgstr "data_page_checksum_version"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18177(para)
msgid ""
"<function>pg_control_recovery</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-recovery\"/>"
msgstr ""
"Функция <function>pg_control_recovery</function> возвращает запись, "
"показанную в <xref remap=\"6\" linkend=\"functions-pg-control-recovery\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18183(title)
msgid "<function>pg_control_recovery</function> Columns"
msgstr "Столбцы результата <function>pg_control_recovery</function>"

#. +> REL_10
#: func.xml:18195(literal)
msgid "min_recovery_end_lsn"
msgstr "min_recovery_end_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18200(literal)
msgid "min_recovery_end_timeline"
msgstr "min_recovery_end_timeline"

#. +> REL_10
#: func.xml:18205(literal)
msgid "backup_start_lsn"
msgstr "backup_start_lsn"

#. +> REL_10
#: func.xml:18210(literal)
msgid "backup_end_lsn"
msgstr "backup_end_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18215(literal)
msgid "end_of_backup_record_required"
msgstr "end_of_backup_record_required"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18226(title)
msgid "System Administration Functions"
msgstr "Функции для системного администрирования"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18228(para)
msgid ""
"The functions described in this section are used to control and monitor a "
"<productname>PostgreSQL</productname> installation."
msgstr ""
"Функции, описанные в этом разделе, предназначены для контроля и управления "
"сервером <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18234(title) func.xml:18242(title)
msgid "Configuration Settings Functions"
msgstr "Функции для управления конфигурацией"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18236(para)
msgid ""
"<xref linkend=\"functions-admin-set-table\"/> shows the functions available "
"to query and alter run-time configuration parameters."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-admin-set-table\"/> показаны "
"функции, позволяющие получить и изменить значения параметров конфигурации "
"выполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18251(indexterm)
msgid "<primary>current_setting</primary>"
msgstr "<primary>current_setting</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18254(parameter) func.xml:18264(parameter)
msgid "setting_name"
msgstr "setting_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18254(parameter) func.xml:19910(parameter)
#: func.xml:19941(parameter) func.xml:19950(parameter)
#: func.xml:19959(parameter)
msgid "missing_ok"
msgstr "missing_ok"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18254(function)
msgid "current_setting(<placeholder-1/> [, <placeholder-2/> ])"
msgstr "current_setting(<placeholder-1/> [, <placeholder-2/> ])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18257(entry)
msgid "get current value of setting"
msgstr "получает текущее значение параметра"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18261(indexterm)
msgid "<primary>set_config</primary>"
msgstr "<primary>set_config</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18265(parameter)
msgid "new_value"
msgstr "new_value"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18266(parameter)
msgid "is_local"
msgstr "is_local"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18264(function)
msgid "set_config(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_config(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18269(entry)
msgid "set parameter and return new value"
msgstr "устанавливает новое значение параметра и возвращает его"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18275(indexterm)
msgid "<primary>SET</primary>"
msgstr "<primary>SET</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18279(indexterm)
msgid "<primary>SHOW</primary>"
msgstr "<primary>SHOW</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18283(indexterm)
msgid ""
"<primary>configuration</primary> <secondary sortas=\"server\">of the server</"
"secondary> <tertiary>functions</tertiary>"
msgstr ""
"<primary>конфигурация</primary> <secondary sortas=\"сервера\">сервера</"
"secondary> <tertiary>функции</tertiary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18294(programlisting)
#, no-wrap
msgid ""
"SELECT current_setting('datestyle');\n"
"\n"
" current_setting\n"
"-----------------\n"
" ISO, MDY\n"
"(1 row)"
msgstr ""
"SELECT current_setting('datestyle');\n"
"\n"
" current_setting\n"
"-----------------\n"
" ISO, MDY\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18289(para)
msgid ""
"The function <function>current_setting</function> yields the current value "
"of the setting <parameter>setting_name</parameter>. It corresponds to the "
"<acronym>SQL</acronym> command <command>SHOW</command>. An example: "
"<placeholder-1/> If there is no setting named <parameter>setting_name</"
"parameter>, <function>current_setting</function> throws an error unless "
"<parameter>missing_ok</parameter> is supplied and is <literal>true</literal>."
msgstr ""
"Функция <function>current_setting</function> выдаёт текущее значение "
"параметра <parameter>setting_name</parameter>. Она соответствует стандартной "
"<acronym>SQL</acronym>-команде <command>SHOW</command>. Пример "
"использования: <placeholder-1/> Если параметра с именем "
"<parameter>setting_name</parameter> нет, функция <function>current_setting</"
"function> выдаёт ошибку, если только дополнительно не передан параметр "
"<parameter>missing_ok</parameter> со значением <literal>true</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18318(programlisting)
#, no-wrap
msgid ""
"SELECT set_config('log_statement_stats', 'off', false);\n"
"\n"
" set_config\n"
"------------\n"
" off\n"
"(1 row)"
msgstr ""
"SELECT set_config('log_statement_stats', 'off', false);\n"
"\n"
" set_config\n"
"------------\n"
" off\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18309(para)
msgid ""
"<function>set_config</function> sets the parameter <parameter>setting_name</"
"parameter> to <parameter>new_value</parameter>. If <parameter>is_local</"
"parameter> is <literal>true</literal>, the new value will only apply to the "
"current transaction. If you want the new value to apply for the current "
"session, use <literal>false</literal> instead. The function corresponds to "
"the SQL command <command>SET</command>. An example: <placeholder-1/>"
msgstr ""
"<function>set_config</function> устанавливает для параметра "
"<parameter>setting_name</parameter> значение <parameter>new_value</"
"parameter>. Если параметр <parameter>is_local</parameter> равен "
"<literal>true</literal>, новое значение будет действовать только в рамках "
"текущей транзакции. Чтобы это значение действовало на протяжении текущего "
"сеанса, ему нужно присвоить <literal>false</literal>. Эта функция "
"соответствует SQL-команде <command>SET</command>. Пример использования: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18331(title) func.xml:18360(title)
msgid "Server Signaling Functions"
msgstr "Функции для передачи сигналов серверу"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18333(indexterm)
msgid "<primary>pg_cancel_backend</primary>"
msgstr "<primary>pg_cancel_backend</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18336(indexterm)
msgid "<primary>pg_reload_conf</primary>"
msgstr "<primary>pg_reload_conf</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18339(indexterm)
msgid "<primary>pg_rotate_logfile</primary>"
msgstr "<primary>pg_rotate_logfile</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18342(indexterm)
msgid "<primary>pg_terminate_backend</primary>"
msgstr "<primary>pg_terminate_backend</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18346(indexterm)
msgid ""
"<primary>signal</primary> <secondary sortas=\"backend\">backend processes</"
"secondary>"
msgstr ""
"<primary>сигнал</primary> <secondary sortas=\"сервер\">серверные процессы</"
"secondary>"

#. +> REL_10
#: func.xml:18351(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-signal-table\"/> send "
"control signals to other server processes. Use of these functions is "
"restricted to superusers by default but access may be granted to others "
"using <command>GRANT</command>, with noted exceptions."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-signal-"
"table\"/>, позволяют передавать управляющие сигналы другим серверным "
"процессам. Вызывать эти функции по умолчанию разрешено только "
"суперпользователям, но доступ к ним можно дать и другим пользователям "
"командой <command>GRANT</command>, кроме явно отмеченных исключений."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18370(parameter) func.xml:18395(parameter)
msgid "pid"
msgstr "pid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18370(function)
msgid "pg_cancel_backend(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_cancel_backend(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18373(entry)
msgid ""
"Cancel a backend's current query. This is also allowed if the calling role "
"is a member of the role whose backend is being canceled or the calling role "
"has been granted <literal>pg_signal_backend</literal>, however only "
"superusers can cancel superuser backends."
msgstr ""
"Отменяет текущий запрос в обслуживающем процессе. Это действие разрешается и "
"ролям, являющимся членами роли, обслуживающий процесс которой затрагивается, "
"и ролям, которым дано право <literal>pg_signal_backend</literal>; однако "
"только суперпользователям разрешено воздействовать на обслуживающие процессы "
"других суперпользователей."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18381(function)
msgid "pg_reload_conf()"
msgstr "pg_reload_conf()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18384(entry)
msgid "Cause server processes to reload their configuration files"
msgstr "Даёт команду серверным процессам перегрузить конфигурацию"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18388(function)
msgid "pg_rotate_logfile()"
msgstr "pg_rotate_logfile()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18391(entry)
msgid "Rotate server's log file"
msgstr "Прокручивает журнал сообщений сервера"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18395(function)
msgid "pg_terminate_backend(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_terminate_backend(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18398(entry)
msgid ""
"Terminate a backend. This is also allowed if the calling role is a member of "
"the role whose backend is being terminated or the calling role has been "
"granted <literal>pg_signal_backend</literal>, however only superusers can "
"terminate superuser backends."
msgstr ""
"Завершает обслуживающий процесс. Это действие разрешается и ролям, "
"являющимся членами роли, обслуживающий процесс которой прерывается, и ролям, "
"которым дано право <literal>pg_signal_backend</literal>; однако только "
"суперпользователям разрешено прерывать обслуживающие процессы других "
"суперпользователей."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18408(para)
msgid ""
"Each of these functions returns <literal>true</literal> if successful and "
"<literal>false</literal> otherwise."
msgstr ""
"Каждая из этих функций возвращает <literal>true</literal> при успешном "
"завершении и <literal>false</literal> в противном случае."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18413(para)
msgid ""
"<function>pg_cancel_backend</function> and <function>pg_terminate_backend</"
"function> send signals (<systemitem>SIGINT</systemitem> or "
"<systemitem>SIGTERM</systemitem> respectively) to backend processes "
"identified by process ID. The process ID of an active backend can be found "
"from the <structfield>pid</structfield> column of the "
"<structname>pg_stat_activity</structname> view, or by listing the "
"<command>postgres</command> processes on the server (using <application>ps</"
"application> on Unix or the <application>Task Manager</application> on "
"<productname>Windows</productname>). The role of an active backend can be "
"found from the <structfield>usename</structfield> column of the "
"<structname>pg_stat_activity</structname> view."
msgstr ""
"<function>pg_cancel_backend</function> и <function>pg_terminate_backend</"
"function> передают сигналы (<systemitem>SIGINT</systemitem> и "
"<systemitem>SIGTERM</systemitem>, соответственно) серверному процессу с "
"заданным кодом PID. Код активного процесса можно получить из столбца "
"<structfield>pid</structfield> представления <structname>pg_stat_activity</"
"structname> или просмотрев на сервере процессы с именем <command>postgres</"
"command> (используя <application>ps</application> в Unix или "
"<application>Диспетчер задач</application> в <productname>Windows</"
"productname>). Роль пользователя активного процесса можно узнать в столбце "
"<structfield>usename</structfield> представления "
"<structname>pg_stat_activity</structname>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18428(para)
msgid ""
"<function>pg_reload_conf</function> sends a <systemitem>SIGHUP</systemitem> "
"signal to the server, causing configuration files to be reloaded by all "
"server processes."
msgstr ""
"<function>pg_reload_conf</function> отправляет сигнал <systemitem>SIGHUP</"
"systemitem> главному серверному процессу, который командует всем подчинённым "
"процессам перезагрузить файлы конфигурации."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18434(para)
msgid ""
"<function>pg_rotate_logfile</function> signals the log-file manager to "
"switch to a new output file immediately. This works only when the built-in "
"log collector is running, since otherwise there is no log-file manager "
"subprocess."
msgstr ""
"<function>pg_rotate_logfile</function> указывает менеджеру журнала сообщений "
"немедленно переключиться на новый файл. Это имеет смысл, только когда "
"работает встроенный сборщик сообщений, так как без него подпроцесс менеджера "
"журнала не запускается."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18444(title) func.xml:18495(title)
msgid "Backup Control Functions"
msgstr "Функции управления резервным копированием"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18446(indexterm)
msgid "<primary>backup</primary>"
msgstr "<primary>резервная копия</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18449(indexterm)
msgid "<primary>pg_create_restore_point</primary>"
msgstr "<primary>pg_create_restore_point</primary>"

#. +> REL_10
#: func.xml:18452(indexterm)
msgid "<primary>pg_current_wal_flush_lsn</primary>"
msgstr "<primary>pg_current_wal_flush_lsn</primary>"

#. +> REL_10
#: func.xml:18455(indexterm)
msgid "<primary>pg_current_wal_insert_lsn</primary>"
msgstr "<primary>pg_current_wal_insert_lsn</primary>"

#. +> REL_10
#: func.xml:18458(indexterm)
msgid "<primary>pg_current_wal_lsn</primary>"
msgstr "<primary>pg_current_wal_lsn</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18461(indexterm)
msgid "<primary>pg_start_backup</primary>"
msgstr "<primary>pg_start_backup</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18464(indexterm)
msgid "<primary>pg_stop_backup</primary>"
msgstr "<primary>pg_stop_backup</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18467(indexterm)
msgid "<primary>pg_is_in_backup</primary>"
msgstr "<primary>pg_is_in_backup</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18470(indexterm)
msgid "<primary>pg_backup_start_time</primary>"
msgstr "<primary>pg_backup_start_time</primary>"

#. +> REL_10
#: func.xml:18473(indexterm)
msgid "<primary>pg_switch_wal</primary>"
msgstr "<primary>pg_switch_wal</primary>"

#. +> REL_10
#: func.xml:18476(indexterm)
msgid "<primary>pg_walfile_name</primary>"
msgstr "<primary>pg_walfile_name</primary>"

#. +> REL_10
#: func.xml:18479(indexterm)
msgid "<primary>pg_walfile_name_offset</primary>"
msgstr "<primary>pg_walfile_name_offset</primary>"

#. +> REL_10
#: func.xml:18482(indexterm)
msgid "<primary>pg_wal_lsn_diff</primary>"
msgstr "<primary>pg_wal_lsn_diff</primary>"

#. +> REL_10
#: func.xml:18486(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-backup-table\"/> "
"assist in making on-line backups. These functions cannot be executed during "
"recovery (except <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> and <function>pg_wal_lsn_diff</"
"function>)."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-backup-"
"table\"/>, предназначены для выполнения резервного копирования &laquo;на "
"ходу&raquo;. Эти функции нельзя выполнять во время восстановления (за "
"исключением <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> и <function>pg_wal_lsn_diff</"
"function>)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18505(function)
msgid "pg_create_restore_point(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_create_restore_point(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18508(entry)
msgid ""
"Create a named point for performing restore (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Создаёт именованную точку для восстановления (по умолчанию разрешено только "
"суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим "
"пользователям)"

#. +> REL9_6_3 REL9_6
#: func.xml:18508(entry) func.xml:18525(entry)
msgid ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"
msgstr ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"

#. +> REL_10
#: func.xml:18512(function)
msgid "pg_current_wal_flush_lsn()"
msgstr "pg_current_wal_flush_lsn()"

#. +> REL_10
#: func.xml:18515(entry)
msgid "Get current write-ahead log flush location"
msgstr "Получает текущую позицию сброса данных в журнале предзаписи"

#. +> REL_10
#: func.xml:18519(function)
msgid "pg_current_wal_insert_lsn()"
msgstr "pg_current_wal_insert_lsn()"

#. +> REL_10
#: func.xml:18522(entry)
msgid "Get current write-ahead log insert location"
msgstr "Получает текущую позицию добавления в журнале предзаписи"

#. +> REL_10
#: func.xml:18526(function)
msgid "pg_current_wal_lsn()"
msgstr "pg_current_wal_lsn()"

#. +> REL_10
#: func.xml:18529(entry)
msgid "Get current write-ahead log write location"
msgstr "Получает текущую позицию записи в журнале предзаписи"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18533(parameter)
msgid "label"
msgstr "label"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18533(parameter)
msgid "fast"
msgstr "fast"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18533(parameter) func.xml:18547(parameter)
msgid "exclusive"
msgstr "exclusive"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18533(optional)
msgid ", <placeholder-1/> <placeholder-2/> <placeholder-3/>"
msgstr ", <placeholder-1/> <placeholder-2/> <placeholder-3/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18533(function)
msgid "pg_start_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "pg_start_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18536(entry)
msgid ""
"Prepare for performing on-line backup (restricted to superusers by default, "
"but other users can be granted EXECUTE to run the function)"
msgstr ""
"Подготавливает сервер к резервному копированию (по умолчанию разрешено "
"только суперпользователям, но право на её выполнение (EXECUTE) можно дать и "
"другим пользователям)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18540(function)
msgid "pg_stop_backup()"
msgstr "pg_stop_backup()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18543(entry)
msgid ""
"Finish performing exclusive on-line backup (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Завершает монопольное резервное копирование (по умолчанию разрешено только "
"суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим "
"пользователям)"

#. +> REL_10
#: func.xml:18547(parameter)
msgid "wait_for_archive"
msgstr "wait_for_archive"

#. +> REL_10
#: func.xml:18547(function)
msgid "pg_stop_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "pg_stop_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18550(entry)
msgid ""
"Finish performing exclusive or non-exclusive on-line backup (restricted to "
"superusers by default, but other users can be granted EXECUTE to run the "
"function)"
msgstr ""
"Завершает монопольное или немонопольное резервное копирование (по умолчанию "
"разрешено только суперпользователям, но право на её выполнение (EXECUTE) "
"можно дать и другим пользователям)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18554(function)
msgid "pg_is_in_backup()"
msgstr "pg_is_in_backup()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18557(entry)
msgid "True if an on-line exclusive backup is still in progress."
msgstr "Возвращает true в процессе исключительного резервного копирования"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18561(function)
msgid "pg_backup_start_time()"
msgstr "pg_backup_start_time()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18564(entry)
msgid "Get start time of an on-line exclusive backup in progress."
msgstr ""
"Получает время запуска выполняющегося исключительного резервного копирования"

#. +> REL_10
#: func.xml:18568(function)
msgid "pg_switch_wal()"
msgstr "pg_switch_wal()"

#. +> REL_10
#: func.xml:18571(entry)
msgid ""
"Force switch to a new write-ahead log file (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Инициирует переключение на новый файл журнала предзаписи (по умолчанию "
"разрешено только суперпользователям, но право на её выполнение (EXECUTE) "
"можно дать и другим пользователям)"

#. +> REL_10
#: func.xml:18575(parameter) func.xml:18582(parameter)
#: func.xml:18589(parameter) func.xml:19299(parameter)
msgid "lsn"
msgstr "lsn"

#. +> REL_10
#: func.xml:18575(function)
msgid "pg_walfile_name(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_walfile_name(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10
#: func.xml:18578(entry)
msgid "Convert write-ahead log location to file name"
msgstr "Получает из позиции в журнале предзаписи имя соответствующего файла"

#. +> REL_10
#: func.xml:18582(function)
msgid "pg_walfile_name_offset(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_walfile_name_offset(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18584(entry)
msgid "<type>text</type>, <type>integer</type>"
msgstr "<type>text</type>, <type>integer</type>"

#. +> REL_10
#: func.xml:18585(entry)
msgid ""
"Convert write-ahead log location to file name and decimal byte offset within "
"file"
msgstr ""
"Получает из позиции в журнале предзаписи имя соответствующего файла и "
"десятичное смещение в нём"

#. +> REL_10
#: func.xml:18589(function)
msgid ""
"pg_wal_lsn_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_wal_lsn_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10
#: func.xml:18592(entry)
msgid "Calculate the difference between two write-ahead log locations"
msgstr "Вычисляет разницу между двумя позициями в журнале предзаписи"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18612(programlisting)
#, no-wrap
msgid ""
"postgres=# select pg_start_backup('label_goes_here');\n"
" pg_start_backup\n"
"-----------------\n"
" 0/D4445B8\n"
"(1 row)"
msgstr ""
"postgres=# select pg_start_backup('label_goes_here');\n"
" pg_start_backup\n"
"-----------------\n"
" 0/D4445B8\n"
"(1 row)"

#. +> REL_10
#: func.xml:18598(para)
msgid ""
"<function>pg_start_backup</function> accepts an arbitrary user-defined label "
"for the backup. (Typically this would be the name under which the backup "
"dump file will be stored.) When used in exclusive mode, the function writes "
"a backup label file (<filename>backup_label</filename>) and, if there are "
"any links in the <filename>pg_tblspc/</filename> directory, a tablespace map "
"file (<filename>tablespace_map</filename>) into the database cluster's data "
"directory, performs a checkpoint, and then returns the backup's starting "
"write-ahead log location as text. The user can ignore this result value, but "
"it is provided in case it is useful. When used in non-exclusive mode, the "
"contents of these files are instead returned by the "
"<function>pg_stop_backup</function> function, and should be written to the "
"backup by the caller. <placeholder-1/> There is an optional second parameter "
"of type <type>boolean</type>. If <literal>true</literal>, it specifies "
"executing <function>pg_start_backup</function> as quickly as possible. This "
"forces an immediate checkpoint which will cause a spike in I/O operations, "
"slowing any concurrently executing queries."
msgstr ""
"<function>pg_start_backup</function> принимает произвольную заданную "
"пользователем метку резервной копии. (Обычно это имя файла, в котором будет "
"сохранена резервная копия.) При копировании в монопольном режиме эта функция "
"записывает файл метки (<filename>backup_label</filename>) и, если есть "
"ссылки в каталоге <filename>pg_tblspc/</filename>, файл карты табличных "
"пространств (<filename>tablespace_map</filename>) в каталог данных кластера "
"БД, выполняет процедуру контрольной точки, а затем возвращает в текстовом "
"виде начальную позицию в журнале предзаписи для данной резервной копии. "
"Результат этой функции может быть полезен, но если он не нужен, его можно "
"просто игнорировать. При копировании в немонопольном режиме содержимое этих "
"файлов выдаётся функцией <function>pg_stop_backup</function> и должно быть "
"записано в архивную копию вызывающим субъектом. <placeholder-1/> У этой "
"функции есть также второй, необязательный параметр типа <type>boolean</"
"type>. Если он равен <literal>true</literal>, <function>pg_start_backup</"
"function> начнёт работу максимально быстро. При этом будет немедленно "
"выполнена процедура контрольной точки, что может повлечь массу операций "
"ввода/вывода и затормозить параллельные запросы."

#. +> REL_10
#: func.xml:18625(para)
msgid ""
"In an exclusive backup, <function>pg_stop_backup</function> removes the "
"label file and, if it exists, the <filename>tablespace_map</filename> file "
"created by <function>pg_start_backup</function>. In a non-exclusive backup, "
"the contents of the <filename>backup_label</filename> and "
"<filename>tablespace_map</filename> are returned in the result of the "
"function, and should be written to files in the backup (and not in the data "
"directory). There is an optional second parameter of type <type>boolean</"
"type>. If false, the <function>pg_stop_backup</function> will return "
"immediately after the backup is completed without waiting for WAL to be "
"archived. This behavior is only useful for backup software which "
"independently monitors WAL archiving. Otherwise, WAL required to make the "
"backup consistent might be missing and make the backup useless. When this "
"parameter is set to true, <function>pg_stop_backup</function> will wait for "
"WAL to be archived when archiving is enabled; on the standby, this means "
"that it will wait only when <varname>archive_mode = always</varname>. If "
"write activity on the primary is low, it may be useful to run "
"<function>pg_switch_wal</function> on the primary in order to trigger an "
"immediate segment switch."
msgstr ""
"При монопольном копировании функция <function>pg_stop_backup</function> "
"удаляет файл метки (и, если существует, файл <filename>tablespace_map</"
"filename>), созданный функцией <function>pg_start_backup</function>. При "
"немонопольном копировании содержимое <filename>backup_label</filename> и "
"<filename>tablespace_map</filename> возвращается в результате функции и "
"должно быть записано в файлы в архиве (а не в каталоге данных). Также есть "
"необязательный второй параметр типа <type>boolean</type>. Если он равен "
"false, <function>pg_stop_backup</function> завершится сразу после окончания "
"резервного копирования, не дожидаясь архивации WAL. Это поведение полезно "
"только для программ резервного копирования, которые независимо осуществляют "
"архивацию WAL. Если же WAL не заархивируется, резервная копия может "
"оказаться неполной, а значит, бесполезной. Когда он равен true, "
"<function>pg_stop_backup</function> будет ждать выполнения архивации WAL, "
"если архивирование включено; для резервного сервера это означает, что "
"ожидание возможно только при условии <varname>archive_mode = always</"
"varname>. Если активность записи на ведущем сервере невысока, может иметь "
"смысл выполнить на нём <function>pg_switch_wal</function> для немедленного "
"переключения сегмента."

#. +> REL_10
#: func.xml:18645(para)
msgid ""
"When executed on a primary, the function also creates a backup history file "
"in the write-ahead log archive area. The history file includes the label "
"given to <function>pg_start_backup</function>, the starting and ending write-"
"ahead log locations for the backup, and the starting and ending times of the "
"backup. The return value is the backup's ending write-ahead log location "
"(which again can be ignored). After recording the ending location, the "
"current write-ahead log insertion point is automatically advanced to the "
"next write-ahead log file, so that the ending write-ahead log file can be "
"archived immediately to complete the backup."
msgstr ""
"При выполнении на ведущем эта функция также создаёт файл истории резервного "
"копирования в области архива журнала предзаписи. В этом файле для данной "
"резервной копии сохраняется метка, заданная при вызове "
"<function>pg_start_backup</function>, начальная и конечная позиция в журнале "
"предзаписи, а также время начала и окончания. Возвращает данная функция "
"позицию окончания резервной копии в журнале предзаписи (которую тоже можно "
"игнорировать). После записи конечной позиции текущая позиция автоматически "
"перемещается к следующему файлу журнала предзаписи, чтобы файл конечной "
"позиции можно было немедленно архивировать для завершения резервного "
"копирования."

#. +> REL_10
#: func.xml:18658(para)
msgid ""
"<function>pg_switch_wal</function> moves to the next write-ahead log file, "
"allowing the current file to be archived (assuming you are using continuous "
"archiving). The return value is the ending write-ahead log location + 1 "
"within the just-completed write-ahead log file. If there has been no write-"
"ahead log activity since the last write-ahead log switch, "
"<function>pg_switch_wal</function> does nothing and returns the start "
"location of the write-ahead log file currently in use."
msgstr ""
"<function>pg_switch_wal</function> производит переключение на следующий файл "
"журнала предзаписи, что позволяет архивировать текущий (в предположении, что "
"архивация выполняется непрерывно). Эта функция возвращает конечную позицию в "
"журнале предзаписи (в только что законченном файле журнала) + 1. Если с "
"момента последнего переключения файлов не было активности, отражающейся в "
"журнале предзаписи, <function>pg_switch_wal</function> не делает ничего и "
"возвращает начальную позицию в файле журнала предзаписи, используемом в "
"данный момент."

#. +> REL_10
#: func.xml:18667(para)
msgid ""
"<function>pg_create_restore_point</function> creates a named write-ahead log "
"record that can be used as recovery target, and returns the corresponding "
"write-ahead log location. The given name can then be used with <xref linkend="
"\"recovery-target-name\"/> to specify the point up to which recovery will "
"proceed. Avoid creating multiple restore points with the same name, since "
"recovery will stop at the first one whose name matches the recovery target."
msgstr ""
"<function>pg_create_restore_point</function> создаёт именованную запись в "
"журнале предзаписи, которую можно использовать как цель при восстановлении, "
"и возвращает соответствующую позицию в журнале предзаписи. Затем полученное "
"имя можно присвоить параметру <xref linkend=\"recovery-target-name\"/>, "
"указав тем самым точку, до которой будет выполняться восстановление. Учтите, "
"что если вы создадите несколько точек восстановления с одним именем, "
"восстановление будет остановлено на первой точке с этим именем."

#. +> REL_10
#: func.xml:18677(para)
msgid ""
"<function>pg_current_wal_lsn</function> displays the current write-ahead log "
"write location in the same format used by the above functions. Similarly, "
"<function>pg_current_wal_insert_lsn</function> displays the current write-"
"ahead log insertion location and <function>pg_current_wal_flush_lsn</"
"function> displays the current write-ahead log flush location. The insertion "
"location is the <quote>logical</quote> end of the write-ahead log at any "
"instant, while the write location is the end of what has actually been "
"written out from the server's internal buffers and flush location is the "
"location guaranteed to be written to durable storage. The write location is "
"the end of what can be examined from outside the server, and is usually what "
"you want if you are interested in archiving partially-complete write-ahead "
"log files. The insertion and flush locations are made available primarily "
"for server debugging purposes. These are both read-only operations and do "
"not require superuser permissions."
msgstr ""
"<function>pg_current_wal_lsn</function> выводит текущую позицию записи в "
"журнале предзаписи в том же формате, что и вышеописанные функции. "
"<function>pg_current_wal_insert_lsn</function> подобным образом выводит "
"текущую позицию добавления, а <function>pg_current_wal_flush_lsn</function> "
"— позицию сброса данных журнала. Позицией добавления называется "
"<quote>логический</quote> конец журнала предзаписи в любой момент времени, "
"тогда как позиция записи указывает на конец данных, фактически вынесённых из "
"внутренних буферов сервера, а позиция сброса показывает, до какого места "
"данные гарантированно сохранены в надёжном хранилище. Позиция записи "
"отмечает конец данных, которые может видеть снаружи внешний процесс, и "
"именно она представляет интерес при копировании частично заполненных файлов "
"журнала. Позиция добавления и позиция сброса выводятся в основном для "
"отладки серверной части. Все эти операции выполняются в режиме &laquo;только "
"чтение&raquo; и не требуют прав суперпользователя."

#. +> REL_10
#: func.xml:18697(programlisting)
#, no-wrap
msgid ""
"postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"
msgstr ""
"postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"

#. +> REL_10
#: func.xml:18693(para)
msgid ""
"You can use <function>pg_walfile_name_offset</function> to extract the "
"corresponding write-ahead log file name and byte offset from the results of "
"any of the above functions. For example: <placeholder-1/> Similarly, "
"<function>pg_walfile_name</function> extracts just the write-ahead log file "
"name. When the given write-ahead log location is exactly at a write-ahead "
"log file boundary, both these functions return the name of the preceding "
"write-ahead log file. This is usually the desired behavior for managing "
"write-ahead log archiving behavior, since the preceding file is the last one "
"that currently needs to be archived."
msgstr ""
"Из результатов всех описанных выше функций можно получить имя файла журнала "
"предзаписи и смещение в нём, используя функцию "
"<function>pg_walfile_name_offset</function>. Например: <placeholder-1/> "
"Подобным образом, <function>pg_walfile_name</function> извлекает только имя "
"файла журнала предзаписи. Когда заданная позиция в журнале предзаписи "
"находится ровно на границе файлов, обе эти функции возвращают имя "
"предыдущего файла. Обычно это поведение предпочтительно при архивировании "
"журнала предзаписи, так как именно предыдущий файл является последним "
"подлежащим архивации."

#. +> REL_10
#: func.xml:18712(para)
msgid ""
"<function>pg_wal_lsn_diff</function> calculates the difference in bytes "
"between two write-ahead log locations. It can be used with "
"<structname>pg_stat_replication</structname> or some functions shown in "
"<xref linkend=\"functions-admin-backup-table\"/> to get the replication lag."
msgstr ""
"<function>pg_wal_lsn_diff</function> вычисляет разницу в байтах между двумя "
"позициями в журнале предзаписи. Полученный результат можно использовать с "
"<structname>pg_stat_replication</structname> или другими функциями, "
"перечисленными в <xref remap=\"6\" linkend=\"functions-admin-backup-table\"/"
">, для определения задержки репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18719(para)
msgid ""
"For details about proper usage of these functions, see <xref linkend="
"\"continuous-archiving\"/>."
msgstr ""
"Подробнее практическое применение этих функций описывается в <xref remap="
"\"6\" linkend=\"continuous-archiving\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18727(title) func.xml:18830(title)
msgid "Recovery Control Functions"
msgstr "Функции управления восстановлением"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18729(indexterm)
msgid "<primary>pg_is_in_recovery</primary>"
msgstr "<primary>pg_is_in_recovery</primary>"

#. +> REL_10
#: func.xml:18732(indexterm)
msgid "<primary>pg_last_wal_receive_lsn</primary>"
msgstr "<primary>pg_last_wal_receive_lsn</primary>"

#. +> REL_10
#: func.xml:18735(indexterm)
msgid "<primary>pg_last_wal_replay_lsn</primary>"
msgstr "<primary>pg_last_wal_replay_lsn</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18738(indexterm)
msgid "<primary>pg_last_xact_replay_timestamp</primary>"
msgstr "<primary>pg_last_xact_replay_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18742(para)
msgid ""
"The functions shown in <xref linkend=\"functions-recovery-info-table\"/> "
"provide information about the current status of the standby. These functions "
"may be executed both during recovery and in normal running."
msgstr ""
"Функции, приведённые в <xref remap=\"6\" linkend=\"functions-recovery-info-"
"table\"/>, предоставляют сведения о текущем состоянии ведомого сервера. Эти "
"функции могут выполняться, как во время восстановления, так и в обычном "
"режиме работы."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18750(title)
msgid "Recovery Information Functions"
msgstr "Функции для получения информации о восстановлении"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18760(function)
msgid "pg_is_in_recovery()"
msgstr "pg_is_in_recovery()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18763(entry)
msgid "True if recovery is still in progress."
msgstr "Возвращает true в процессе восстановления."

#. +> REL_10
#: func.xml:18768(function)
msgid "pg_last_wal_receive_lsn()"
msgstr "pg_last_wal_receive_lsn()"

#. +> REL_10
#: func.xml:18771(entry)
msgid ""
"Get last write-ahead log location received and synced to disk by streaming "
"replication. While streaming replication is in progress this will increase "
"monotonically. If recovery has completed this will remain static at the "
"value of the last WAL record received and synced to disk during recovery. If "
"streaming replication is disabled, or if it has not yet started, the "
"function returns NULL."
msgstr ""
"Получает позицию последней записи журнала предзаписи, полученной и "
"записанной на диск в процессе потоковой репликации. Пока выполняется "
"потоковая репликация, эта позиция постоянно увеличивается. По окончании "
"восстановления она останавливается на записи WAL, полученной и записанной на "
"диск последней. Если потоковая репликация отключена или ещё не запускалась, "
"функция возвращает NULL."

#. +> REL_10
#: func.xml:18782(function)
msgid "pg_last_wal_replay_lsn()"
msgstr "pg_last_wal_replay_lsn()"

#. +> REL_10
#: func.xml:18785(entry)
msgid ""
"Get last write-ahead log location replayed during recovery. If recovery is "
"still in progress this will increase monotonically. If recovery has "
"completed then this value will remain static at the value of the last WAL "
"record applied during that recovery. When the server has been started "
"normally without recovery the function returns NULL."
msgstr ""
"Получает позицию последней записи журнала предзаписи, воспроизведённой при "
"восстановлении. В процессе восстановления эта позиция постоянно "
"увеличивается. По окончании восстановления она останавливается на записи "
"WAL, которая была восстановлена последней. Если сервер был запущен не в "
"режиме восстановления, эта функция возвращает NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18795(function)
msgid "pg_last_xact_replay_timestamp()"
msgstr "pg_last_xact_replay_timestamp()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18798(entry)
msgid ""
"Get time stamp of last transaction replayed during recovery. This is the "
"time at which the commit or abort WAL record for that transaction was "
"generated on the primary. If no transactions have been replayed during "
"recovery, this function returns NULL. Otherwise, if recovery is still in "
"progress this will increase monotonically. If recovery has completed then "
"this value will remain static at the value of the last transaction applied "
"during that recovery. When the server has been started normally without "
"recovery the function returns NULL."
msgstr ""
"Получает отметку времени последней транзакции, воспроизведённой при "
"восстановлении. Это время, когда на главном сервере произошла фиксация или "
"откат записи WAL для этой транзакции. Если в процессе восстановления не была "
"воспроизведена ни одна транзакция, эта функция возвращает NULL. В противном "
"случае это значение постоянно увеличивается в процессе восстановления. По "
"окончании восстановления оно останавливается на транзакции, которая была "
"восстановлена последней. Если сервер был запущен не в режиме восстановления, "
"эта функция возвращает NULL."

#. +> REL_10
#: func.xml:18813(indexterm)
msgid "<primary>pg_is_wal_replay_paused</primary>"
msgstr "<primary>pg_is_wal_replay_paused</primary>"

#. +> REL_10
#: func.xml:18816(indexterm)
msgid "<primary>pg_wal_replay_pause</primary>"
msgstr "<primary>pg_wal_replay_pause</primary>"

#. +> REL_10
#: func.xml:18819(indexterm)
msgid "<primary>pg_wal_replay_resume</primary>"
msgstr "<primary>pg_wal_replay_resume</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18823(para)
msgid ""
"The functions shown in <xref linkend=\"functions-recovery-control-table\"/> "
"control the progress of recovery. These functions may be executed only "
"during recovery."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-recovery-"
"control-table\"/> управляют процессом восстановления. Вызывать их в другое "
"время нельзя."

#. +> REL_10
#: func.xml:18840(function)
msgid "pg_is_wal_replay_paused()"
msgstr "pg_is_wal_replay_paused()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18843(entry)
msgid "True if recovery is paused."
msgstr "Возвращает true, если восстановление приостановлено."

#. +> REL_10
#: func.xml:18848(function)
msgid "pg_wal_replay_pause()"
msgstr "pg_wal_replay_pause()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18851(entry)
msgid ""
"Pauses recovery immediately (restricted to superusers by default, but other "
"users can be granted EXECUTE to run the function)."
msgstr ""
"Немедленно приостанавливает восстановление (по умолчанию разрешено только "
"суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим "
"пользователям)."

#. +> REL_10
#: func.xml:18856(function)
msgid "pg_wal_replay_resume()"
msgstr "pg_wal_replay_resume()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18859(entry)
msgid ""
"Restarts recovery if it was paused (restricted to superusers by default, but "
"other users can be granted EXECUTE to run the function)."
msgstr ""
"Перезапускает восстановление, если оно было приостановлено (по умолчанию "
"разрешено только суперпользователям, но право на её выполнение (EXECUTE) "
"можно дать и другим пользователям)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18866(para)
msgid ""
"While recovery is paused no further database changes are applied. If in hot "
"standby, all new queries will see the same consistent snapshot of the "
"database, and no further query conflicts will be generated until recovery is "
"resumed."
msgstr ""
"Когда восстановление приостановлено, запись изменений в базу не "
"производится. Если она находится в &laquo;горячем резерве&raquo;, все "
"последующие запросы будут видеть один согласованный снимок базы данных и до "
"продолжения восстановления конфликты запросов исключаются."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18873(para)
msgid ""
"If streaming replication is disabled, the paused state may continue "
"indefinitely without problem. While streaming replication is in progress WAL "
"records will continue to be received, which will eventually fill available "
"disk space, depending upon the duration of the pause, the rate of WAL "
"generation and available disk space."
msgstr ""
"Когда потоковая репликация выключена, пауза при восстановлении может длиться "
"сколь угодно долго без каких-либо проблем. Если же запущена потоковая "
"репликация, новые записи WAL продолжат поступать и заполнят весь диск рано "
"или поздно, в зависимости от длительности паузы, интенсивности записи в WAL "
"и объёма свободного пространства."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18884(title) func.xml:18921(title)
msgid "Snapshot Synchronization Functions"
msgstr "Функции синхронизации снимков"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18886(indexterm)
msgid "<primary>pg_export_snapshot</primary>"
msgstr "<primary>pg_export_snapshot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18890(para)
msgid ""
"<productname>PostgreSQL</productname> allows database sessions to "
"synchronize their snapshots. A <firstterm>snapshot</firstterm> determines "
"which data is visible to the transaction that is using the snapshot. "
"Synchronized snapshots are necessary when two or more sessions need to see "
"identical content in the database. If two sessions just start their "
"transactions independently, there is always a possibility that some third "
"transaction commits between the executions of the two <command>START "
"TRANSACTION</command> commands, so that one session sees the effects of that "
"transaction and the other does not."
msgstr ""
"<productname>PostgreSQL</productname> позволяет синхронизировать снимки "
"состояния между сеансами баз данных. <firstterm>Снимок состояния</firstterm> "
"определяет, какие данные видны транзакции, работающей с этим снимком. "
"Синхронизация снимков необходима, когда в двух или более сеансах нужно "
"видеть одно и то же содержимое базы данных. Если в двух сеансах транзакции "
"запускаются независимо, всегда есть вероятность, что некая третья транзакция "
"будет зафиксирована между командами <command>START TRANSACTION</command> для "
"первых двух, и в результате в одном сеансе будет виден результат третьей, а "
"в другом &mdash; нет."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18902(para)
msgid ""
"To solve this problem, <productname>PostgreSQL</productname> allows a "
"transaction to <firstterm>export</firstterm> the snapshot it is using. As "
"long as the exporting transaction remains open, other transactions can "
"<firstterm>import</firstterm> its snapshot, and thereby be guaranteed that "
"they see exactly the same view of the database that the first transaction "
"sees. But note that any database changes made by any one of these "
"transactions remain invisible to the other transactions, as is usual for "
"changes made by uncommitted transactions. So the transactions are "
"synchronized with respect to pre-existing data, but act normally for changes "
"they make themselves."
msgstr ""
"Для решения этой проблемы <productname>PostgreSQL</productname> позволяет "
"транзакции <firstterm>экспортировать</firstterm> снимок состояния, с которым "
"она работает. Пока экспортирующая этот снимок транзакция выполняется, другие "
"транзакции могут <firstterm>импортировать</firstterm> его и, таким образом, "
"увидеть абсолютно то же состояние базы данных, что видит первая транзакция. "
"Но учтите, что любые изменения, произведённые этими транзакциями, будут не "
"видны для других, как это и должно быть с изменениями в незафиксированных "
"транзакциях. Таким образом, транзакции синхронизируют только начальное "
"состояние данных, а последующие производимые в них изменения изолируются как "
"обычно."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18914(para)
msgid ""
"Snapshots are exported with the <function>pg_export_snapshot</function> "
"function, shown in <xref linkend=\"functions-snapshot-synchronization-table"
"\"/>, and imported with the <xref linkend=\"sql-set-transaction\"/> command."
msgstr ""
"Снимки состояния экспортируются с помощью функции "
"<function>pg_export_snapshot</function>, показанной в <xref remap=\"6\" "
"linkend=\"functions-snapshot-synchronization-table\"/>, и импортируются "
"командой <xref linkend=\"sql-set-transaction\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18931(function)
msgid "pg_export_snapshot()"
msgstr "pg_export_snapshot()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18934(entry)
msgid "Save the current snapshot and return its identifier"
msgstr "Сохраняет снимок текущего состояния и возвращает его идентификатор"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18940(para)
msgid ""
"The function <function>pg_export_snapshot</function> saves the current "
"snapshot and returns a <type>text</type> string identifying the snapshot. "
"This string must be passed (outside the database) to clients that want to "
"import the snapshot. The snapshot is available for import only until the end "
"of the transaction that exported it. A transaction can export more than one "
"snapshot, if needed. Note that doing so is only useful in <literal>READ "
"COMMITTED</literal> transactions, since in <literal>REPEATABLE READ</"
"literal> and higher isolation levels, transactions use the same snapshot "
"throughout their lifetime. Once a transaction has exported any snapshots, it "
"cannot be prepared with <xref linkend=\"sql-prepare-transaction\"/>."
msgstr ""
"Функция <function>pg_export_snapshot</function> создаёт снимок текущего "
"состояния и возвращает его идентификатор в строке типа <type>text</type>. "
"Данная строка должна передаваться (за рамками базы данных) клиентам, которые "
"будут импортировать этот снимок. При этом импортировать его нужно раньше, "
"чем завершится транзакция, которая его экспортировала. Если необходимо, "
"транзакция может экспортировать несколько снимков. Заметьте, что это имеет "
"смысл только для транзакций уровня <literal>READ COMMITTED</literal>, так "
"как транзакции <literal>REPEATABLE READ</literal> и более высоких уровней "
"изоляции работают с одним снимком состояния. После того, как транзакция "
"экспортировала снимок, её нельзя подготовить с помощью <xref linkend=\"sql-"
"prepare-transaction\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18953(para)
msgid ""
"See <xref linkend=\"sql-set-transaction\"/> for details of how to use an "
"exported snapshot."
msgstr ""
"Подробнее использование экспортированных снимков рассматривается в описании "
"<xref linkend=\"sql-set-transaction\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18960(title)
msgid "Replication Functions"
msgstr "Функции репликации"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18962(para)
msgid ""
"The functions shown in <xref linkend=\"functions-replication-table\"/> are "
"for controlling and interacting with replication features. See <xref linkend="
"\"streaming-replication\"/>, <xref linkend=\"streaming-replication-slots\"/"
">, and <xref linkend=\"replication-origins\"/> for information about the "
"underlying features. Use of these functions is restricted to superusers."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-replication-table\"/> перечислены "
"функции, предназначенные для управления и взаимодействия с механизмом "
"репликации. Чтобы изучить этот механизм детальнее, обратитесь к <xref remap="
"\"3\" linkend=\"streaming-replication\"/>, <xref remap=\"3\" linkend="
"\"streaming-replication-slots\"/> и <xref remap=\"3\" linkend=\"replication-"
"origins\"/>. Использовать эти функции разрешено только суперпользователям."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18973(para)
msgid ""
"Many of these functions have equivalent commands in the replication "
"protocol; see <xref linkend=\"protocol-replication\"/>."
msgstr ""
"Многие из этих функций соответствуют командам в протоколе репликации; см. "
"<xref remap=\"4\" linkend=\"protocol-replication\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18978(para)
msgid ""
"The functions described in <xref linkend=\"functions-admin-backup\"/>, <xref "
"linkend=\"functions-recovery-control\"/>, and <xref linkend=\"functions-"
"snapshot-synchronization\"/> are also relevant for replication."
msgstr ""
"Функции, описанные в <xref remap=\"6\" linkend=\"functions-admin-backup\"/>, "
"<xref linkend=\"functions-recovery-control\"/> и <xref remap=\"6\" linkend="
"\"functions-snapshot-synchronization\"/> также имеют отношение к репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18987(title)
msgid "Replication <acronym>SQL</acronym> Functions"
msgstr "Функции репликации <acronym>SQL</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:18999(indexterm)
msgid "<primary>pg_create_physical_replication_slot</primary>"
msgstr "<primary>pg_create_physical_replication_slot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19002(parameter) func.xml:19029(parameter)
#: func.xml:19047(parameter) func.xml:19070(parameter)
#: func.xml:19095(parameter) func.xml:19113(parameter)
#: func.xml:19130(parameter)
msgid "slot_name"
msgstr "slot_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19002(parameter)
msgid "immediately_reserve"
msgstr "immediately_reserve"

#. +> REL_10
#: func.xml:19002(parameter) func.xml:19047(parameter)
msgid "temporary"
msgstr "temporary"

#. +> REL_10
#: func.xml:19002(optional)
msgid ", <placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>"
msgstr ", <placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19002(function)
msgid ""
"pg_create_physical_replication_slot(<placeholder-1/> <placeholder-2/> "
"<placeholder-3/>)"
msgstr ""
"pg_create_physical_replication_slot(<placeholder-1/> <placeholder-2/> "
"<placeholder-3/>)"

#. +> REL_10
#: func.xml:19004(entry) func.xml:19049(entry)
msgid ""
"(<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</"
"parameter> <type>pg_lsn</type>)"
msgstr ""
"(<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</"
"parameter> <type>pg_lsn</type>)"

#. +> REL_10
#: func.xml:19007(entry)
msgid ""
"Creates a new physical replication slot named <parameter>slot_name</"
"parameter>. The optional second parameter, when <literal>true</literal>, "
"specifies that the <acronym>LSN</acronym> for this replication slot be "
"reserved immediately; otherwise the <acronym>LSN</acronym> is reserved on "
"first connection from a streaming replication client. Streaming changes from "
"a physical slot is only possible with the streaming-replication protocol "
"&mdash; see <xref linkend=\"protocol-replication\"/>. The optional third "
"parameter, <parameter>temporary</parameter>, when set to true, specifies "
"that the slot should not be permanently stored to disk and is only meant for "
"use by current session. Temporary slots are also released upon any error. "
"This function corresponds to the replication protocol command "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."
msgstr ""
"Создаёт новый физический слот репликации с именем <parameter>slot_name</"
"parameter>. Необязательный второй параметр, когда он равен <literal>true</"
"literal>, указывает, что <acronym>LSN</acronym> для этого слота репликации "
"должен быть зарезервирован немедленно; в противном случае <acronym>LSN</"
"acronym> резервируется при первом подключении клиента потоковой репликации. "
"Передача изменений из физического слота возможна только по протоколу "
"потоковой репликации &mdash; см. <xref remap=\"4\" linkend=\"protocol-"
"replication\"/>. Необязательный третий параметр, <parameter>temporary</"
"parameter>, когда он равен true, указывает, что этот слот не должен "
"постоянно храниться на диске, так как он предназначен только для текущего "
"сеанса. Временные слоты также освобождаются при любой ошибке. Эта функция "
"соответствует команде протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19026(indexterm)
msgid "<primary>pg_drop_replication_slot</primary>"
msgstr "<primary>pg_drop_replication_slot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19029(function)
msgid "pg_drop_replication_slot(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_drop_replication_slot(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10
#: func.xml:19034(entry)
msgid ""
"Drops the physical or logical replication slot named <parameter>slot_name</"
"parameter>. Same as replication protocol command "
"<literal>DROP_REPLICATION_SLOT</literal>. For logical slots, this must be "
"called when connected to the same database the slot was created on."
msgstr ""
"Удаляет физический или логический слот репликации с именем "
"<parameter>slot_name</parameter>. Соответствует команде протокола репликации "
"<literal>DROP_REPLICATION_SLOT</literal>. Для логических слотов эта функция "
"должна вызываться через подключение к той же базе данных, в которой был "
"создан слот."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19044(indexterm)
msgid "<primary>pg_create_logical_replication_slot</primary>"
msgstr "<primary>pg_create_logical_replication_slot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19047(parameter)
msgid "plugin"
msgstr "plugin"

#. +> REL_10
#: func.xml:19047(function)
msgid ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/> <placeholder-5/>)"
msgstr ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/> <placeholder-5/>)"

#. +> REL_10
#: func.xml:19052(entry)
msgid ""
"Creates a new logical (decoding) replication slot named "
"<parameter>slot_name</parameter> using the output plugin <parameter>plugin</"
"parameter>. The optional third parameter, <parameter>temporary</parameter>, "
"when set to true, specifies that the slot should not be permanently stored "
"to disk and is only meant for use by current session. Temporary slots are "
"also released upon any error. A call to this function has the same effect as "
"the replication protocol command <literal>CREATE_REPLICATION_SLOT ... "
"LOGICAL</literal>."
msgstr ""
"Создаёт новый логический (декодирующий) слот репликации с именем "
"<parameter>slot_name</parameter>, используя модуль вывода <parameter>plugin</"
"parameter>. Необязательный третий параметр, <parameter>temporary</"
"parameter>, когда равен true, указывает, что этот слот не должен постоянно "
"храниться на диске, так как он предназначен только для текущего сеанса. "
"Временные слоты также освобождаются при любой ошибке. Вызов этой функции "
"равнозначен выполнению команды протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19067(indexterm)
msgid "<primary>pg_logical_slot_get_changes</primary>"
msgstr "<primary>pg_logical_slot_get_changes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19070(parameter) func.xml:19095(parameter)
#: func.xml:19113(parameter) func.xml:19130(parameter)
msgid "upto_lsn"
msgstr "upto_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19070(parameter) func.xml:19095(parameter)
#: func.xml:19113(parameter) func.xml:19130(parameter)
msgid "upto_nchanges"
msgstr "upto_nchanges"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19070(parameter) func.xml:19095(parameter)
#: func.xml:19113(parameter) func.xml:19130(parameter)
msgctxt "parameter"
msgid "options"
msgstr "options"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19070(function)
msgid ""
"pg_logical_slot_get_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_get_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#. +> REL_10
#: func.xml:19072(entry) func.xml:19097(entry)
msgid ""
"(<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> "
"<type>xid</type>, <parameter>data</parameter> <type>text</type>)"
msgstr ""
"(<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> "
"<type>xid</type>, <parameter>data</parameter> <type>text</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19075(entry)
msgid ""
"Returns changes in the slot <parameter>slot_name</parameter>, starting from "
"the point at which since changes have been consumed last. If "
"<parameter>upto_lsn</parameter> and <parameter>upto_nchanges</parameter> are "
"NULL, logical decoding will continue until end of WAL. If "
"<parameter>upto_lsn</parameter> is non-NULL, decoding will include only "
"those transactions which commit prior to the specified LSN. If "
"<parameter>upto_nchanges</parameter> is non-NULL, decoding will stop when "
"the number of rows produced by decoding exceeds the specified value. Note, "
"however, that the actual number of rows returned may be larger, since this "
"limit is only checked after adding the rows produced when decoding each new "
"transaction commit."
msgstr ""
"Возвращает изменения в слоте <parameter>slot_name</parameter> с позиции, до "
"которой ранее были получены изменения. Если параметры <parameter>upto_lsn</"
"parameter> и <parameter>upto_nchanges</parameter> равны NULL, логическое "
"декодирование продолжится до конца журнала транзакций. Если "
"<parameter>upto_lsn</parameter> не NULL, декодироваться будут только "
"транзакции, зафиксированные до заданного LSN. Если <parameter>upto_nchanges</"
"parameter> не NULL, декодирование остановится, когда число строк, полученных "
"при декодировании, превысит заданное значение. Заметьте, однако, что "
"фактическое число возвращённых строк может быть больше, так как это "
"ограничение проверяется только после добавления строк, декодированных для "
"очередной транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19092(indexterm)
msgid "<primary>pg_logical_slot_peek_changes</primary>"
msgstr "<primary>pg_logical_slot_peek_changes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19095(function)
msgid ""
"pg_logical_slot_peek_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_peek_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19100(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are not consumed; that is, they will be "
"returned again on future calls."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но не забирает изменения; то есть, они будут получены снова при "
"следующих вызовах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19110(indexterm)
msgid "<primary>pg_logical_slot_get_binary_changes</primary>"
msgstr "<primary>pg_logical_slot_get_binary_changes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19113(function)
msgid ""
"pg_logical_slot_get_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_get_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#. +> REL_10
#: func.xml:19115(entry) func.xml:19132(entry)
msgid ""
"(<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> "
"<type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"
msgstr ""
"(<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> "
"<type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19118(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are returned as <type>bytea</type>."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но выдаёт изменения в типе <type>bytea</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19127(indexterm)
msgid "<primary>pg_logical_slot_peek_binary_changes</primary>"
msgstr "<primary>pg_logical_slot_peek_binary_changes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19130(function)
msgid ""
"pg_logical_slot_peek_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_peek_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19135(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are returned as <type>bytea</type> and that "
"changes are not consumed; that is, they will be returned again on future "
"calls."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но выдаёт изменения в типе <type>bytea</type> и не забирает их; "
"то есть, они будут получены снова при следующих вызовах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19146(indexterm)
msgid "<primary>pg_replication_origin_create</primary>"
msgstr "<primary>pg_replication_origin_create</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19149(parameter) func.xml:19165(parameter)
#: func.xml:19181(parameter) func.xml:19197(parameter)
#: func.xml:19299(parameter) func.xml:19318(parameter)
msgid "node_name"
msgstr "node_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19149(function)
msgid "pg_replication_origin_create(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_create(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19154(entry)
msgid ""
"Create a replication origin with the given external name, and return the "
"internal id assigned to it."
msgstr ""
"Создаёт источник репликации с заданным внешним именем и возвращает "
"назначенный ему внутренний идентификатор."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19162(indexterm)
msgid "<primary>pg_replication_origin_drop</primary>"
msgstr "<primary>pg_replication_origin_drop</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19165(function)
msgid "pg_replication_origin_drop(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_drop(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19170(entry)
msgid ""
"Delete a previously created replication origin, including any associated "
"replay progress."
msgstr ""
"Удаляет ранее созданный источник репликации, в том числе связанную "
"информацию о воспроизведении."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19178(indexterm)
msgid "<primary>pg_replication_origin_oid</primary>"
msgstr "<primary>pg_replication_origin_oid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19181(function)
msgid "pg_replication_origin_oid(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_oid(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19186(entry)
msgid ""
"Lookup a replication origin by name and return the internal id. If no "
"corresponding replication origin is found an error is thrown."
msgstr ""
"Ищет источник репликации по имени и возвращает внутренний идентификатор. "
"Если такой источник не находится, выдаётся ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19194(indexterm)
msgid "<primary>pg_replication_origin_session_setup</primary>"
msgstr "<primary>pg_replication_origin_session_setup</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19197(function)
msgid "pg_replication_origin_session_setup(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_session_setup(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19202(entry)
msgid ""
"Mark the current session as replaying from the given origin, allowing replay "
"progress to be tracked. Use <function>pg_replication_origin_session_reset</"
"function> to revert. Can only be used if no previous origin is configured."
msgstr ""
"Помечает текущий сеанс, как воспроизводящий журнал из указанного источника, "
"что позволяет отслеживать положение воспроизведения. Чтобы отменить это "
"действие, вызовите <function>pg_replication_origin_session_reset</function>. "
"Может использоваться, только если не был настроен предыдущий источник."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19212(indexterm)
msgid "<primary>pg_replication_origin_session_reset</primary>"
msgstr "<primary>pg_replication_origin_session_reset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19215(function)
msgid "pg_replication_origin_session_reset()"
msgstr "pg_replication_origin_session_reset()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19220(entry)
msgid ""
"Cancel the effects of <function>pg_replication_origin_session_setup()</"
"function>."
msgstr ""
"Отменяет действие <function>pg_replication_origin_session_setup()</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19228(indexterm)
msgid "<primary>pg_replication_origin_session_is_setup</primary>"
msgstr "<primary>pg_replication_origin_session_is_setup</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19231(function)
msgid "pg_replication_origin_session_is_setup()"
msgstr "pg_replication_origin_session_is_setup()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19236(entry)
msgid "Has a replication origin been configured in the current session?"
msgstr "В текущем сеансе настроен источник репликации?"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19243(indexterm)
msgid "<primary>pg_replication_origin_session_progress</primary>"
msgstr "<primary>pg_replication_origin_session_progress</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19246(parameter) func.xml:19318(parameter)
msgid "flush"
msgstr "flush"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19246(function)
msgid ""
"pg_replication_origin_session_progress(<placeholder-1/> <placeholder-2/>)"
msgstr ""
"pg_replication_origin_session_progress(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10
#: func.xml:19251(entry)
msgid ""
"Return the replay location for the replication origin configured in the "
"current session. The parameter <parameter>flush</parameter> determines "
"whether the corresponding local transaction will be guaranteed to have been "
"flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для источника репликации, настроенного в "
"текущем сеансе. Параметр <parameter>flush</parameter> определяет, будет ли "
"гарантироваться сохранение локальной транзакции на диске."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19261(indexterm)
msgid "<primary>pg_replication_origin_xact_setup</primary>"
msgstr "<primary>pg_replication_origin_xact_setup</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19264(parameter)
msgid "origin_lsn"
msgstr "origin_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19264(parameter)
msgid "origin_timestamp"
msgstr "origin_timestamp"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19264(type)
msgid "timestamptz"
msgstr "timestamptz"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19264(function)
msgid ""
"pg_replication_origin_xact_setup(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_replication_origin_xact_setup(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19269(entry)
msgid ""
"Mark the current transaction as replaying a transaction that has committed "
"at the given <acronym>LSN</acronym> and timestamp. Can only be called when a "
"replication origin has previously been configured using "
"<function>pg_replication_origin_session_setup()</function>."
msgstr ""
"Помечает текущую транзакцию как воспроизводящую транзакцию, зафиксированную "
"с указанным <acronym>LSN</acronym> и временем. Может вызываться только после "
"того, как был настроен источник репликации в результате вызова "
"<function>pg_replication_origin_session_setup()</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19280(indexterm)
msgid "<primary>pg_replication_origin_xact_reset</primary>"
msgstr "<primary>pg_replication_origin_xact_reset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19283(function)
msgid "pg_replication_origin_xact_reset()"
msgstr "pg_replication_origin_xact_reset()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19288(entry)
msgid ""
"Cancel the effects of <function>pg_replication_origin_xact_setup()</"
"function>."
msgstr ""
"Отменяет действие <function>pg_replication_origin_xact_setup()</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19296(indexterm)
msgid "<primary>pg_replication_origin_advance</primary>"
msgstr "<primary>pg_replication_origin_advance</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19299(function)
msgid "(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19299(literal)
msgid "pg_replication_origin_advance<placeholder-1/>"
msgstr "pg_replication_origin_advance<placeholder-1/>"

#. +> REL_10
#: func.xml:19304(entry)
msgid ""
"Set replication progress for the given node to the given location. This "
"primarily is useful for setting up the initial location or a new location "
"after configuration changes and similar. Be aware that careless use of this "
"function can lead to inconsistently replicated data."
msgstr ""
"Устанавливает положение репликации для заданного узла в указанную позицию. "
"Это в основном полезно для установки начальной позиции или новой позиции "
"после изменения конфигурации и подобных действий. Но учтите, что "
"неосторожное использование этой функции может привести к несогласованности "
"реплицированных данных."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19315(indexterm)
msgid "<primary>pg_replication_origin_progress</primary>"
msgstr "<primary>pg_replication_origin_progress</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19318(function)
msgid ""
"pg_replication_origin_progress(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_replication_origin_progress(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#. +> REL_10
#: func.xml:19323(entry)
msgid ""
"Return the replay location for the given replication origin. The parameter "
"<parameter>flush</parameter> determines whether the corresponding local "
"transaction will be guaranteed to have been flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для заданного источника репликации. "
"Параметр <parameter>flush</parameter> определяет, будет ли гарантироваться "
"сохранение локальной транзакции на диске."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19333(indexterm)
msgid "<primary>pg_logical_emit_message</primary>"
msgstr "<primary>pg_logical_emit_message</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19336(parameter) func.xml:19355(parameter)
msgid "transactional"
msgstr "transactional"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19336(parameter) func.xml:19355(parameter)
msgid "prefix"
msgstr "prefix"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19336(parameter) func.xml:19355(parameter)
msgctxt "parameter"
msgid "content"
msgstr "content"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19336(function) func.xml:19355(function)
msgid ""
"pg_logical_emit_message(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_logical_emit_message(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19341(entry)
msgid ""
"Emit text logical decoding message. This can be used to pass generic "
"messages to logical decoding plugins through WAL. The parameter "
"<parameter>transactional</parameter> specifies if the message should be part "
"of current transaction or if it should be written immediately and decoded as "
"soon as the logical decoding reads the record. The <parameter>prefix</"
"parameter> is textual prefix used by the logical decoding plugins to easily "
"recognize interesting messages for them. The <parameter>content</parameter> "
"is the text of the message."
msgstr ""
"Выдаёт текстовое сообщение логического декодирования. Её можно использовать "
"для передачи произвольных сообщений через WAL модулям логического "
"декодирования. Параметр <parameter>transactional</parameter> устанавливает, "
"должно ли сообщение быть частью текущей транзакции или оно должно "
"записываться немедленно и декодироваться сразу, как только эта запись будет "
"прочитана при логическом декодировании. Параметр <parameter>prefix</"
"parameter> задаёт текстовый префикс, по которому модули логического "
"декодирования могут легко распознать интересующие их сообщения. В параметре "
"<parameter>content</parameter> передаётся текст сообщения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19360(entry)
msgid ""
"Emit binary logical decoding message. This can be used to pass generic "
"messages to logical decoding plugins through WAL. The parameter "
"<parameter>transactional</parameter> specifies if the message should be part "
"of current transaction or if it should be written immediately and decoded as "
"soon as the logical decoding reads the record. The <parameter>prefix</"
"parameter> is textual prefix used by the logical decoding plugins to easily "
"recognize interesting messages for them. The <parameter>content</parameter> "
"is the binary content of the message."
msgstr ""
"Выдаёт двоичное сообщение логического декодирования. Её можно использовать "
"для передачи произвольных сообщений через WAL модулям логического "
"декодирования. Параметр <parameter>transactional</parameter> устанавливает, "
"должно ли сообщение быть частью текущей транзакции или оно должно "
"записываться немедленно и декодироваться сразу, как только эта запись будет "
"прочитана при логическом декодировании. Параметр <parameter>prefix</"
"parameter> задаёт текстовый префикс, по которому модули логического "
"декодирования могут легко распознать интересующие их сообщения. В параметре "
"<parameter>content</parameter> передаётся двоичное содержание сообщения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19380(title)
msgid "Database Object Management Functions"
msgstr "Функции управления объектами баз данных"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19382(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-dbsize\"/> calculate "
"the disk space usage of database objects."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-dbsize"
"\"/>, вычисляют объём, который занимают на диске различные объекты баз "
"данных."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19387(indexterm)
msgid "<primary>pg_column_size</primary>"
msgstr "<primary>pg_column_size</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19390(indexterm)
msgid "<primary>pg_database_size</primary>"
msgstr "<primary>pg_database_size</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19393(indexterm)
msgid "<primary>pg_indexes_size</primary>"
msgstr "<primary>pg_indexes_size</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19396(indexterm)
msgid "<primary>pg_relation_size</primary>"
msgstr "<primary>pg_relation_size</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19399(indexterm)
msgid "<primary>pg_size_bytes</primary>"
msgstr "<primary>pg_size_bytes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19402(indexterm)
msgid "<primary>pg_size_pretty</primary>"
msgstr "<primary>pg_size_pretty</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19405(indexterm)
msgid "<primary>pg_table_size</primary>"
msgstr "<primary>pg_table_size</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19408(indexterm)
msgid "<primary>pg_tablespace_size</primary>"
msgstr "<primary>pg_tablespace_size</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19411(indexterm)
msgid "<primary>pg_total_relation_size</primary>"
msgstr "<primary>pg_total_relation_size</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19416(title)
msgid "Database Object Size Functions"
msgstr "Функции получения размера объектов БД"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19425(function)
msgid "pg_column_size(<placeholder-1/>)"
msgstr "pg_column_size(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19427(entry)
msgid "Number of bytes used to store a particular value (possibly compressed)"
msgstr ""
"Число байт, необходимых для хранения заданного значения (возможно, в сжатом "
"виде)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19431(function) func.xml:19438(function)
msgid "pg_database_size(<placeholder-1/>)"
msgstr "pg_database_size(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19434(entry)
msgid "Disk space used by the database with the specified OID"
msgstr "Объём, который занимает на диске база данных с заданным OID"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19441(entry)
msgid "Disk space used by the database with the specified name"
msgstr "Объём, который занимает на диске база данных с заданным именем"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19445(function)
msgid "pg_indexes_size(<placeholder-1/>)"
msgstr "pg_indexes_size(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19448(entry)
msgid "Total disk space used by indexes attached to the specified table"
msgstr "Общий объём индексов, связанных с указанной таблицей"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19454(parameter) func.xml:19465(parameter)
#: func.xml:19678(parameter) func.xml:19687(parameter)
msgid "relation"
msgstr "relation"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19454(parameter)
msgid "fork"
msgstr "fork"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19454(function)
msgid ""
"pg_relation_size(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_relation_size(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19457(entry)
msgid ""
"Disk space used by the specified fork (<literal>'main'</literal>, "
"<literal>'fsm'</literal>, <literal>'vm'</literal>, or <literal>'init'</"
"literal>) of the specified table or index"
msgstr ""
"Объём, который занимает на диске указанный слой (<literal>'main'</literal>, "
"<literal>'fsm'</literal>, <literal>'vm'</literal> или <literal>'init'</"
"literal>) заданной таблицы или индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19465(function)
msgid "pg_relation_size(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_size(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19468(entry)
msgid "Shorthand for <literal>pg_relation_size(..., 'main')</literal>"
msgstr "Краткая форма <literal>pg_relation_size(..., 'main')</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19474(function)
msgid "pg_size_bytes(<placeholder-1/>)"
msgstr "pg_size_bytes(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19477(entry)
msgid "Converts a size in human-readable format with size units into bytes"
msgstr ""
"Преобразует размер в понятном человеку формате с единицами измерения в число "
"байт"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19483(function) func.xml:19493(function)
msgid "pg_size_pretty(<placeholder-1/>)"
msgstr "pg_size_pretty(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19486(entry)
msgid ""
"Converts a size in bytes expressed as a 64-bit integer into a human-readable "
"format with size units"
msgstr ""
"Преобразует размер в байтах, представленный в 64-битном целом, в понятный "
"человеку формат с единицами измерения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19496(entry)
msgid ""
"Converts a size in bytes expressed as a numeric value into a human-readable "
"format with size units"
msgstr ""
"Преобразует размер в байтах, представленный в значении числового типа, в "
"понятный человеку формат с единицами измерения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19503(function)
msgid "pg_table_size(<placeholder-1/>)"
msgstr "pg_table_size(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19506(entry)
msgid ""
"Disk space used by the specified table, excluding indexes (but including "
"TOAST, free space map, and visibility map)"
msgstr ""
"Объём, который занимает на диске данная таблица, за исключением индексов (но "
"включая TOAST, карту свободного места и карту видимости)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19513(function) func.xml:19520(function)
msgid "pg_tablespace_size(<placeholder-1/>)"
msgstr "pg_tablespace_size(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19516(entry)
msgid "Disk space used by the tablespace with the specified OID"
msgstr ""
"Объём, который занимает на диске табличное пространство с указанным OID"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19523(entry)
msgid "Disk space used by the tablespace with the specified name"
msgstr ""
"Объём, который занимает на диске табличное пространство с заданным именем"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19527(function)
msgid "pg_total_relation_size(<placeholder-1/>)"
msgstr "pg_total_relation_size(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19530(entry)
msgid ""
"Total disk space used by the specified table, including all indexes and "
"<acronym>TOAST</acronym> data"
msgstr ""
"Общий объём, который занимает на диске заданная таблица, включая все индексы "
"и данные <acronym>TOAST</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19539(para)
msgid ""
"<function>pg_column_size</function> shows the space used to store any "
"individual data value."
msgstr ""
"<function>pg_column_size</function> показывает, какой объём требуется для "
"хранения данного значения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19544(para)
msgid ""
"<function>pg_total_relation_size</function> accepts the OID or name of a "
"table or toast table, and returns the total on-disk space used for that "
"table, including all associated indexes. This function is equivalent to "
"<function>pg_table_size</function> <literal>+</literal> "
"<function>pg_indexes_size</function>."
msgstr ""
"<function>pg_total_relation_size</function> принимает OID или имя таблицы "
"или данных TOAST и возвращает общий объём, который занимает на диске эта "
"таблица, включая все связанные с ней индексы. Результат этой функции "
"равняется <function>pg_table_size</function> <literal>+</literal> "
"<function>pg_indexes_size</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19552(para)
msgid ""
"<function>pg_table_size</function> accepts the OID or name of a table and "
"returns the disk space needed for that table, exclusive of indexes. (TOAST "
"space, free space map, and visibility map are included.)"
msgstr ""
"<function>pg_table_size</function> принимает OID или имя таблицы и "
"возвращает объём, который занимает на диске эта таблица без индексов. (При "
"этом учитывается размер TOAST, карты свободного места и карты видимости.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19558(para)
msgid ""
"<function>pg_indexes_size</function> accepts the OID or name of a table and "
"returns the total disk space used by all the indexes attached to that table."
msgstr ""
"<function>pg_indexes_size</function> принимает OID или имя таблицы и "
"возвращает общий объём, который занимают все индексы таблицы."

#. +> REL_10
#: func.xml:19564(para)
msgid ""
"<function>pg_database_size</function> and <function>pg_tablespace_size</"
"function> accept the OID or name of a database or tablespace, and return the "
"total disk space used therein. To use <function>pg_database_size</function>, "
"you must have <literal>CONNECT</literal> permission on the specified "
"database (which is granted by default), or be a member of the "
"<literal>pg_read_all_stats</literal> role. To use "
"<function>pg_tablespace_size</function>, you must have <literal>CREATE</"
"literal> permission on the specified tablespace, or be a member of the "
"<literal>pg_read_all_stats</literal> role unless it is the default "
"tablespace for the current database."
msgstr ""
"<function>pg_database_size</function> и <function>pg_tablespace_size</"
"function> принимают OID или имя базы данных либо табличного пространства и "
"возвращают общий объём, который они занимают на диске. Для использования "
"<function>pg_database_size</function> требуется иметь право "
"<literal>CONNECT</literal> для указанной базы данных (оно предоставляется по "
"умолчанию) или быть членом роли <literal>pg_read_all_stats</literal>. Для "
"использования <function>pg_tablespace_size</function> необходимо иметь право "
"<literal>CREATE</literal> для указанного табличного пространства или быть "
"членом роли <literal>pg_read_all_stats</literal>, если только это не "
"табличное пространство по умолчанию для текущей базы данных."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19587(para)
msgid ""
"<literal>'main'</literal> returns the size of the main data fork of the "
"relation."
msgstr ""
"<literal>'main'</literal> возвращает размер основного слоя данных заданного "
"отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19593(para)
msgid ""
"<literal>'fsm'</literal> returns the size of the Free Space Map (see <xref "
"linkend=\"storage-fsm\"/>) associated with the relation."
msgstr ""
"<literal>'fsm'</literal> возвращает размер карты свободного места (см. <xref "
"remap=\"4\" linkend=\"storage-fsm\"/>), связанной с заданным отношением."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19599(para)
msgid ""
"<literal>'vm'</literal> returns the size of the Visibility Map (see <xref "
"linkend=\"storage-vm\"/>) associated with the relation."
msgstr ""
"<literal>'vm'</literal> возвращает размер карты видимости (см. <xref remap="
"\"4\" linkend=\"storage-vm\"/>), связанной с заданным отношением."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19605(para)
msgid ""
"<literal>'init'</literal> returns the size of the initialization fork, if "
"any, associated with the relation."
msgstr ""
"<literal>'init'</literal> возвращает размер слоя инициализации для заданного "
"отношения, если он имеется."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19576(para)
msgid ""
"<function>pg_relation_size</function> accepts the OID or name of a table, "
"index or toast table, and returns the on-disk size in bytes of one fork of "
"that relation. (Note that for most purposes it is more convenient to use the "
"higher-level functions <function>pg_total_relation_size</function> or "
"<function>pg_table_size</function>, which sum the sizes of all forks.) With "
"one argument, it returns the size of the main data fork of the relation. The "
"second argument can be provided to specify which fork to examine: "
"<placeholder-1/>"
msgstr ""
"<function>pg_relation_size</function> принимает OID или имя таблицы, индекса "
"или TOAST-таблицы и возвращает размер одного слоя этого отношения (в "
"байтах). (Заметьте, что в большинстве случаев удобнее использовать более "
"высокоуровневые функции <function>pg_total_relation_size</function> и "
"<function>pg_table_size</function>, которые суммируют размер всех слоёв.) С "
"одним аргументом она возвращает размер основного слоя для данных заданного "
"отношения. Название другого интересующего слоя можно передать во втором "
"аргументе: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19613(para)
msgid ""
"<function>pg_size_pretty</function> can be used to format the result of one "
"of the other functions in a human-readable way, using bytes, kB, MB, GB or "
"TB as appropriate."
msgstr ""
"<function>pg_size_pretty</function> можно использовать для форматирования "
"результатов других функций в виде, более понятном человеку, с единицами "
"измерения bytes, kB, MB, GB и TB."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19619(para)
msgid ""
"<function>pg_size_bytes</function> can be used to get the size in bytes from "
"a string in human-readable format. The input may have units of bytes, kB, "
"MB, GB or TB, and is parsed case-insensitively. If no units are specified, "
"bytes are assumed."
msgstr ""
"<function>pg_size_bytes</function> можно использовать для получения размера "
"в байтах из строки в формате, понятном человеку. Входная строка может "
"содержать единицы bytes, kB, MB, GB и TB, и разбирается без учёта регистра. "
"Если единицы не указываются, подразумеваются байты."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19627(para)
msgid ""
"The units kB, MB, GB and TB used by the functions <function>pg_size_pretty</"
"function> and <function>pg_size_bytes</function> are defined using powers of "
"2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024<superscript>2</"
"superscript> = 1048576 bytes, and so on."
msgstr ""
"Единицы kB, MB, GB и TB, фигурирующие в функциях <function>pg_size_pretty</"
"function> и <function>pg_size_bytes</function>, определяются как степени 2, "
"а не 10, так что 1kB равен 1024 байтам, 1MB равен 1024<superscript>2</"
"superscript> = 1048576 байтов и т. д."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19635(para)
msgid ""
"The functions above that operate on tables or indexes accept a "
"<type>regclass</type> argument, which is simply the OID of the table or "
"index in the <structname>pg_class</structname> system catalog. You do not "
"have to look up the OID by hand, however, since the <type>regclass</type> "
"data type's input converter will do the work for you. Just write the table "
"name enclosed in single quotes so that it looks like a literal constant. For "
"compatibility with the handling of ordinary <acronym>SQL</acronym> names, "
"the string will be converted to lower case unless it contains double quotes "
"around the table name."
msgstr ""
"Вышеописанные функции, работающие с таблицами или индексами, принимают "
"аргумент типа <type>regclass</type>, который представляет собой просто OID "
"таблицы или индекса в системном каталоге <structname>pg_class</structname>. "
"Однако вам не нужно вручную вычислять OID, так как процедура ввода значения "
"<type>regclass</type> может сделать это за вас. Для этого достаточно "
"записать имя таблицы в апострофах, как обычную текстовую константу. В "
"соответствии с правилами обработки обычных имён <acronym>SQL</acronym>, если "
"имя таблицы не заключено в кавычки, эта строка будет переведена в нижний "
"регистр."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19647(para)
msgid ""
"If an OID that does not represent an existing object is passed as argument "
"to one of the above functions, NULL is returned."
msgstr ""
"Если переданному значению OID не соответствуют существующий объект, эти "
"функции возвращают NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19652(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-dblocation\"/> assist "
"in identifying the specific disk files associated with database objects."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-"
"dblocation\"/>, помогают определить, в каких файлах на диске хранятся "
"объекты базы данных."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19657(indexterm)
msgid "<primary>pg_relation_filenode</primary>"
msgstr "<primary>pg_relation_filenode</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19660(indexterm)
msgid "<primary>pg_relation_filepath</primary>"
msgstr "<primary>pg_relation_filepath</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19663(indexterm)
msgid "<primary>pg_filenode_relation</primary>"
msgstr "<primary>pg_filenode_relation</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19668(title)
msgid "Database Object Location Functions"
msgstr "Функции определения расположения объектов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19678(function)
msgid "pg_relation_filenode(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_filenode(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19681(entry)
msgid "Filenode number of the specified relation"
msgstr "Номер файлового узла для указанного отношения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19687(function)
msgid "pg_relation_filepath(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_filepath(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19690(entry)
msgid "File path name of the specified relation"
msgstr "Путь к файлу, в котором хранится указанное отношение"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19696(parameter)
msgid "filenode"
msgstr "filenode"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19696(function)
msgid ""
"pg_filenode_relation(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_filenode_relation(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19699(entry)
msgid "Find the relation associated with a given tablespace and filenode"
msgstr ""
"Находит отношение, связанное с данным табличным пространством и файловым "
"узлом"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19707(para)
msgid ""
"<function>pg_relation_filenode</function> accepts the OID or name of a "
"table, index, sequence, or toast table, and returns the <quote>filenode</"
"quote> number currently assigned to it. The filenode is the base component "
"of the file name(s) used for the relation (see <xref linkend=\"storage-file-"
"layout\"/> for more information). For most tables the result is the same as "
"<structname>pg_class</structname>.<structfield>relfilenode</structfield>, "
"but for certain system catalogs <structfield>relfilenode</structfield> is "
"zero and this function must be used to get the correct value. The function "
"returns NULL if passed a relation that does not have storage, such as a view."
msgstr ""
"<function>pg_relation_filenode</function> принимает OID или имя таблицы, "
"индекса, последовательности или таблицы TOAST и возвращает номер "
"<quote>файлового узла</quote>, связанным с этим объектом. Файловым узлом "
"называется основной компонент имени файла, используемого для хранения данных "
"(подробнее это описано в <xref remap=\"6\" linkend=\"storage-file-layout\"/"
">). Для большинства таблиц этот номер совпадает со значением "
"<structname>pg_class</structname>.<structfield>relfilenode</structfield>, но "
"для некоторых системных каталогов <structfield>relfilenode</structfield> "
"равен 0, и нужно использовать эту функцию, чтобы узнать действительное "
"значение. Если указанное отношение не хранится на диске, как например "
"представление, данная функция возвращает NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19719(para)
msgid ""
"<function>pg_relation_filepath</function> is similar to "
"<function>pg_relation_filenode</function>, but it returns the entire file "
"path name (relative to the database cluster's data directory "
"<varname>PGDATA</varname>) of the relation."
msgstr ""
"<function>pg_relation_filepath</function> подобна "
"<function>pg_relation_filenode</function>, но возвращает полный путь к файлу "
"(относительно каталога данных <varname>PGDATA</varname>) отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19726(para)
msgid ""
"<function>pg_filenode_relation</function> is the reverse of "
"<function>pg_relation_filenode</function>. Given a <quote>tablespace</quote> "
"OID and a <quote>filenode</quote>, it returns the associated relation's OID. "
"For a table in the database's default tablespace, the tablespace can be "
"specified as 0."
msgstr ""
"Функция <function>pg_filenode_relation</function> является обратной к "
"<function>pg_relation_filenode</function>. Она возвращает OID отношения по "
"заданному OID <quote>табличного пространства</quote> и <quote>файловому "
"узлу</quote>. Для таблицы в табличном пространстве по умолчанию в первом "
"параметре можно передать 0."

#. +> REL_10
#: func.xml:19733(para)
msgid ""
"<xref linkend=\"functions-admin-collation\"/> lists functions used to manage "
"collations."
msgstr ""
"В <xref linkend=\"functions-admin-collation\"/> перечислены функции, "
"предназначенные для управления правилами сортировки."

#. +> REL_10
#: func.xml:19739(title)
msgid "Collation Management Functions"
msgstr "Функции управления правилами сортировки"

#. +> REL_10
#: func.xml:19748(indexterm)
msgid "<primary>pg_collation_actual_version</primary>"
msgstr "<primary>pg_collation_actual_version</primary>"

#. +> REL_10
#: func.xml:19749(function)
msgid "pg_collation_actual_version(<placeholder-1/>)"
msgstr "pg_collation_actual_version(<placeholder-1/>)"

#. +> REL_10
#: func.xml:19752(entry)
msgid "Return actual version of collation from operating system"
msgstr "выдаёт действующую версию правила сортировки из операционной системы"

#. +> REL_10
#: func.xml:19756(indexterm)
msgid "<primary>pg_import_system_collations</primary>"
msgstr "<primary>pg_import_system_collations</primary>"

#. +> REL_10
#: func.xml:19757(function)
msgid "pg_import_system_collations(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_import_system_collations(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10
#: func.xml:19760(entry)
msgid "Import operating system collations"
msgstr "импортирует правила сортировки из операционной системы"

#. +> REL_10
#: func.xml:19766(para)
msgid ""
"<function>pg_collation_actual_version</function> returns the actual version "
"of the collation object as it is currently installed in the operating "
"system. If this is different from the value in <literal>pg_collation."
"collversion</literal>, then objects depending on the collation might need to "
"be rebuilt. See also <xref linkend=\"sql-altercollation\"/>."
msgstr ""
"Функция <function>pg_collation_actual_version</function> возвращает "
"действующую версию объекта правила сортировки, которая в настоящее время "
"установлена в операционной системе. Если она отличается от значения в "
"<literal>pg_collation.collversion</literal>, может потребоваться перестроить "
"объекты, зависящие от данного правила сортировки. См. также <xref remap="
"\"4\" linkend=\"sql-altercollation\"/>."

#. +> REL_10
#: func.xml:19775(para)
msgid ""
"<function>pg_import_system_collations</function> adds collations to the "
"system catalog <literal>pg_collation</literal> based on all the locales it "
"finds in the operating system. This is what <command>initdb</command> uses; "
"see <xref linkend=\"collation-managing\"/> for more details. If additional "
"locales are installed into the operating system later on, this function can "
"be run again to add collations for the new locales. Locales that match "
"existing entries in <literal>pg_collation</literal> will be skipped. (But "
"collation objects based on locales that are no longer present in the "
"operating system are not removed by this function.) The <parameter>schema</"
"parameter> parameter would typically be <literal>pg_catalog</literal>, but "
"that is not a requirement; the collations could be installed into some other "
"schema as well. The function returns the number of new collation objects it "
"created."
msgstr ""
"Функция <function>pg_import_system_collations</function> добавляет правила "
"сортировки в системный каталог <literal>pg_collation</literal>, анализируя "
"все локали, которые она находит в операционной системе. Эту информацию "
"использует <command>initdb</command>; за подробностями обратитесь к <xref "
"remap=\"3\" linkend=\"collation-managing\"/>. Если позднее в систему "
"устанавливаются дополнительные локали, эту функцию можно запустить снова, "
"чтобы добавились правила сортировки для новых локалей. Локали, для которых "
"обнаруживаются существующие записи в <literal>pg_collation</literal>, будут "
"пропущены. (Объекты правил сортировки для локалей, которые перестают "
"существовать в операционной системе, никогда не удаляются этой функцией.) В "
"параметре <parameter>schema</parameter> обычно передаётся "
"<literal>pg_catalog</literal>, но это не обязательно; правила сортировки "
"могут быть установлены и в другую схему. Эта функция возвращает число "
"созданных ей объектов правил сортировки."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19795(title) func.xml:19822(title)
msgid "Index Maintenance Functions"
msgstr "Функции обслуживания индексов"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19797(indexterm)
msgid "<primary>brin_summarize_new_values</primary>"
msgstr "<primary>brin_summarize_new_values</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19801(indexterm)
msgid "<primary>gin_clean_pending_list</primary>"
msgstr "<primary>gin_clean_pending_list</primary>"

#. +> REL_10
#: func.xml:19805(indexterm)
msgid "<primary>brin_summarize_range</primary>"
msgstr "<primary>brin_summarize_range</primary>"

#. +> REL_10
#: func.xml:19809(indexterm)
msgid "<primary>brin_desummarize_range</primary>"
msgstr "<primary>brin_desummarize_range</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19813(para)
msgid ""
"<xref linkend=\"functions-admin-index-table\"/> shows the functions "
"available for index maintenance tasks. These functions cannot be executed "
"during recovery. Use of these functions is restricted to superusers and the "
"owner of the given index."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-admin-index-table\"/> перечислены "
"функции, предназначенные для обслуживания индексов. Эти функции нельзя "
"вызывать в процессе восстановления. Использовать эти функции разрешено "
"только суперпользователям и владельцу определённого индекса."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19831(parameter) func.xml:19838(parameter)
#: func.xml:19845(parameter) func.xml:19852(parameter)
msgid "index"
msgstr "index"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19831(function)
msgid "brin_summarize_new_values(<placeholder-1/> <placeholder-2/>)"
msgstr "brin_summarize_new_values(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19834(entry)
msgid "summarize page ranges not already summarized"
msgstr "обобщает ещё не обобщённые зоны страниц"

#. +> REL_10
#: func.xml:19838(parameter) func.xml:19845(parameter)
msgid "blockNumber"
msgstr "blockNumber"

#. +> REL_10
#: func.xml:19838(function)
msgid ""
"brin_summarize_range(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"brin_summarize_range(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10
#: func.xml:19841(entry)
msgid ""
"summarize the page range covering the given block, if not already summarized"
msgstr ""
"обобщает зону страниц, охватывающую данный блок (если она ещё не обобщена)"

#. +> REL_10
#: func.xml:19845(function)
msgid ""
"brin_desummarize_range(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"brin_desummarize_range(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10
#: func.xml:19848(entry)
msgid "de-summarize the page range covering the given block, if summarized"
msgstr ""
"сброс обобщения зоны страниц, охватывающей данный блок (если она была "
"обобщена)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19852(function)
msgid "gin_clean_pending_list(<placeholder-1/> <placeholder-2/>)"
msgstr "gin_clean_pending_list(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19855(entry)
msgid "move GIN pending list entries into main index structure"
msgstr ""
"перемещает элементы из списка записей GIN, ожидающих обработки, в основную "
"структуру индекса"

#. +> REL_10
#: func.xml:19861(para)
msgid ""
"<function>brin_summarize_new_values</function> accepts the OID or name of a "
"BRIN index and inspects the index to find page ranges in the base table that "
"are not currently summarized by the index; for any such range it creates a "
"new summary index tuple by scanning the table pages. It returns the number "
"of new page range summaries that were inserted into the index. "
"<function>brin_summarize_range</function> does the same, except it only "
"summarizes the range that covers the given block number."
msgstr ""
"Функция <function>brin_summarize_new_values</function> принимает OID или имя "
"индекса BRIN и просматривает индекс в поисках зон страниц в базовой таблице, "
"ещё не обобщённых в индексе; для каждой такой зоны в результате сканирования "
"страниц таблицы создаётся новый обобщающий кортеж в индексе. Возвращает эта "
"функция число вставленных в индекс обобщающих записей о зонах страниц. "
"Функция <function>brin_summarize_range</function> делает то же самое, но "
"затрагивает только зону, охватывающую блок с заданным номером."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19871(para)
msgid ""
"<function>gin_clean_pending_list</function> accepts the OID or name of a GIN "
"index and cleans up the pending list of the specified index by moving "
"entries in it to the main GIN data structure in bulk. It returns the number "
"of pages removed from the pending list. Note that if the argument is a GIN "
"index built with the <literal>fastupdate</literal> option disabled, no "
"cleanup happens and the return value is 0, because the index doesn't have a "
"pending list. Please see <xref linkend=\"gin-fast-update\"/> and <xref "
"linkend=\"gin-tips\"/> for details of the pending list and "
"<literal>fastupdate</literal> option."
msgstr ""
"Функция <function>gin_clean_pending_list</function> принимает OID или имя "
"индекса GIN и очищает очередь указанного индекса, массово перемещая элементы "
"из неё в основную структуру данных GIN. Возвращает она число страниц, "
"убранных из очереди. Заметьте, что если для обработки ей передаётся индекс "
"GIN, построенный с отключённым параметром <literal>fastupdate</literal>, "
"очистка не производится и возвращается значение 0, так как у такого индекса "
"нет очереди записей. Подробнее об очереди записей и параметре "
"<literal>fastupdate</literal> рассказывается в <xref remap=\"6\" linkend="
"\"gin-fast-update\"/> и <xref remap=\"6\" linkend=\"gin-tips\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19886(title) func.xml:19900(title)
msgid "Generic File Access Functions"
msgstr "Функции для работы с обычными файлами"

#. +> REL_10
#: func.xml:19888(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-genfile-table\"/> "
"provide native access to files on the machine hosting the server. Only files "
"within the database cluster directory and the <varname>log_directory</"
"varname> can be accessed. Use a relative path for files in the cluster "
"directory, and a path matching the <varname>log_directory</varname> "
"configuration setting for log files. Use of these functions is restricted to "
"superusers except where stated otherwise."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-genfile-"
"table\"/>, предоставляют прямой доступ к файлам, находящимся на сервере. Они "
"позволяют обращаться только к файлам в каталоге кластера баз данных (по "
"относительному пути) или в каталоге <varname>log_directory</varname> (по "
"пути, заданному в параметре конфигурации <varname>log_directory</varname>). "
"Использовать эти функции могут только суперпользователи, если явно не "
"отмечено иное."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19910(parameter)
msgid "dirname"
msgstr "dirname"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19910(parameter)
msgid "include_dot_dirs"
msgstr "include_dot_dirs"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19910(function)
msgid ""
"pg_ls_dir(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"pg_ls_dir(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19913(entry)
msgid "List the contents of a directory."
msgstr "Возвращает список содержимого каталога."

#. +> REL_10
#: func.xml:19919(function)
msgid "pg_ls_logdir()"
msgstr "pg_ls_logdir()"

#. +> REL_10
#: func.xml:19922(entry)
msgid ""
"List the name, size, and last modification time of files in the log "
"directory. Access is granted to members of the <literal>pg_monitor</literal> "
"role and may be granted to other non-superuser roles."
msgstr ""
"Выводит имя, размер и время последнего изменения файлов в каталоге журнала "
"сообщений. Доступ к этой функции имеют члены роли <literal>pg_monitor</"
"literal>, также его можно разрешить и другим ролям обычных пользователей."

#. +> REL_10
#: func.xml:19930(function)
msgid "pg_ls_waldir()"
msgstr "pg_ls_waldir()"

#. +> REL_10
#: func.xml:19933(entry)
msgid ""
"List the name, size, and last modification time of files in the WAL "
"directory. Access is granted to members of the <literal>pg_monitor</literal> "
"role and may be granted to other non-superuser roles."
msgstr ""
"Выводит имя, размер и время последнего изменения файлов в каталоге WAL. "
"Доступ к этой функции имеют члены роли <literal>pg_monitor</literal>, также "
"его можно разрешить и другим ролям обычных пользователей."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19941(parameter) func.xml:19950(parameter)
#: func.xml:19959(parameter)
msgid "filename"
msgstr "filename"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19941(function)
msgid ""
"pg_read_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"
msgstr ""
"pg_read_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19944(entry)
msgid "Return the contents of a text file."
msgstr "Возвращает содержимое текстового файла."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19950(function)
msgid ""
"pg_read_binary_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"
msgstr ""
"pg_read_binary_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19953(entry)
msgid "Return the contents of a file."
msgstr "Возвращает содержимое файла."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19959(function)
msgid ""
"pg_stat_file(<placeholder-1/> <placeholder-2/>[, <placeholder-3/> "
"<placeholder-4/>])"
msgstr ""
"pg_stat_file(<placeholder-1/> <placeholder-2/>[, <placeholder-3/> "
"<placeholder-4/>])"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19962(entry)
msgid "Return information about a file."
msgstr "Возвращает информацию о файле."

#. +> REL_10
#: func.xml:19970(para)
msgid ""
"Some of these functions take an optional <parameter>missing_ok</parameter> "
"parameter, which specifies the behavior when the file or directory does not "
"exist. If <literal>true</literal>, the function returns NULL (except "
"<function>pg_ls_dir</function>, which returns an empty result set). If "
"<literal>false</literal>, an error is raised. The default is <literal>false</"
"literal>."
msgstr ""
"Некоторые из этих функций принимают необязательный параметр "
"<parameter>missing_ok</parameter>, который определяет их поведение в случае "
"отсутствия файла или каталога. Если он равен <literal>true</literal>, "
"функция возвращает NULL (за исключением <function>pg_ls_dir</function>, "
"которая возвращает пустое множество). Если он равен <literal>false</"
"literal>, возникает ошибка. Значение по умолчанию — <literal>false</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19978(indexterm)
msgid "<primary>pg_ls_dir</primary>"
msgstr "<primary>pg_ls_dir</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:19981(para)
msgid ""
"<function>pg_ls_dir</function> returns the names of all files (and "
"directories and other special files) in the specified directory. The "
"<parameter> include_dot_dirs</parameter> indicates whether <quote>.</quote> "
"and <quote>..</quote> are included in the result set. The default is to "
"exclude them (<literal>false</literal>), but including them can be useful "
"when <parameter>missing_ok</parameter> is <literal>true</literal>, to "
"distinguish an empty directory from an non-existent directory."
msgstr ""
"<function>pg_ls_dir</function> возвращает имена всех файлов (а также "
"каталогов и других специальных файлов) в заданном каталоге. Параметр "
"<parameter>include_dot_dirs</parameter> определяет, будут ли в "
"результирующий набор включаться каталоги <quote>.</quote> и <quote>..</"
"quote>. По умолчанию они не включаются (<literal>false</literal>), но их "
"можно включить, чтобы с параметром <parameter>missing_ok</parameter> равным "
"<literal>true</literal>, пустой каталог можно было отличить от "
"несуществующего."

#. +> REL_10
#: func.xml:19991(indexterm)
msgid "<primary>pg_ls_logdir</primary>"
msgstr "<primary>pg_ls_logdir</primary>"

#. +> REL_10
#: func.xml:19994(para)
msgid ""
"<function>pg_ls_logdir</function> returns the name, size, and last modified "
"time (mtime) of each file in the log directory. By default, only superusers "
"and members of the <literal>pg_monitor</literal> role can use this function. "
"Access may be granted to others using <command>GRANT</command>."
msgstr ""
"<function>pg_ls_logdir</function> возвращает имя, размер и время последнего "
"изменения (mtime) всех файлов в каталоге журналов сообщений. По умолчанию "
"использовать её разрешено только суперпользователям и членам роли "
"<literal>pg_monitor</literal>. Другим пользователям доступ к ней можно дать, "
"используя <command>GRANT</command>."

#. +> REL_10
#: func.xml:20001(indexterm)
msgid "<primary>pg_ls_waldir</primary>"
msgstr "<primary>pg_ls_waldir</primary>"

#. +> REL_10
#: func.xml:20004(para)
msgid ""
"<function>pg_ls_waldir</function> returns the name, size, and last modified "
"time (mtime) of each file in the write ahead log (WAL) directory. By default "
"only superusers and members of the <literal>pg_monitor</literal> role can "
"use this function. Access may be granted to others using <command>GRANT</"
"command>."
msgstr ""
"<function>pg_ls_waldir</function> возвращает имя, размер и время последнего "
"изменения (mtime) всех файлов в каталоге журнала предзаписи (WAL). По "
"умолчанию использовать её разрешено только суперпользователям и членам роли "
"<literal>pg_monitor</literal>. Другим пользователям доступ к ней можно дать, "
"используя <command>GRANT</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20012(indexterm)
msgid "<primary>pg_read_file</primary>"
msgstr "<primary>pg_read_file</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20015(para)
msgid ""
"<function>pg_read_file</function> returns part of a text file, starting at "
"the given <parameter>offset</parameter>, returning at most "
"<parameter>length</parameter> bytes (less if the end of file is reached "
"first). If <parameter>offset</parameter> is negative, it is relative to the "
"end of the file. If <parameter>offset</parameter> and <parameter>length</"
"parameter> are omitted, the entire file is returned. The bytes read from the "
"file are interpreted as a string in the server encoding; an error is thrown "
"if they are not valid in that encoding."
msgstr ""
"<function>pg_read_file</function> возвращает фрагмент текстового файла с "
"заданного смещения (<parameter>offset</parameter>), размером не больше "
"<parameter>length</parameter> байт (размер может быть меньше, если файл "
"кончится раньше). Если смещение <parameter>offset</parameter> отрицательно, "
"оно отсчитывается от конца файла. Если параметры <parameter>offset</"
"parameter> и <parameter>length</parameter> опущены, возвращается всё "
"содержимое файла. Прочитанные из файла байты обрабатываются как символы в "
"серверной кодировке; если они оказываются недопустимыми для этой кодировки, "
"возникает ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20026(indexterm)
msgid "<primary>pg_read_binary_file</primary>"
msgstr "<primary>pg_read_binary_file</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20035(programlisting)
#, no-wrap
msgid "SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');"
msgstr "SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20029(para)
msgid ""
"<function>pg_read_binary_file</function> is similar to "
"<function>pg_read_file</function>, except that the result is a <type>bytea</"
"type> value; accordingly, no encoding checks are performed. In combination "
"with the <function>convert_from</function> function, this function can be "
"used to read a file in a specified encoding: <placeholder-1/>"
msgstr ""
"<function>pg_read_binary_file</function> подобна <function>pg_read_file</"
"function>, но её результат имеет тип <type>bytea</type>; как следствие, "
"никакие проверки кодировки не выполняются. В сочетании с "
"<function>convert_from</function> эту функцию можно применять для чтения "
"файлов в произвольной кодировке: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20040(indexterm)
msgid "<primary>pg_stat_file</primary>"
msgstr "<primary>pg_stat_file</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20049(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM pg_stat_file('filename');\n"
"SELECT (pg_stat_file('filename')).modification;"
msgstr ""
"SELECT * FROM pg_stat_file('filename');\n"
"SELECT (pg_stat_file('filename')).modification;"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20043(para)
msgid ""
"<function>pg_stat_file</function> returns a record containing the file size, "
"last accessed time stamp, last modified time stamp, last file status change "
"time stamp (Unix platforms only), file creation time stamp (Windows only), "
"and a <type>boolean</type> indicating if it is a directory. Typical usages "
"include: <placeholder-1/>"
msgstr ""
"<function>pg_stat_file</function> возвращает запись, содержащую размер "
"файла, время последнего обращения и последнего изменения, а также время "
"последнего изменения состояния (только в Unix-системах), время создания "
"(только в Windows) и признак типа <type>boolean</type>, показывающий, что "
"это каталог. Примеры использования: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20058(title) func.xml:20067(title)
msgid "Advisory Lock Functions"
msgstr "Функции управления рекомендательными блокировками"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20060(para)
msgid ""
"The functions shown in <xref linkend=\"functions-advisory-locks-table\"/> "
"manage advisory locks. For details about proper use of these functions, see "
"<xref linkend=\"advisory-locks\"/>."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-advisory-"
"locks-table\"/>, предназначены для управления рекомендательными "
"блокировками. Подробнее об их использовании можно узнать в <xref remap=\"6\" "
"linkend=\"advisory-locks\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20077(parameter) func.xml:20091(parameter)
#: func.xml:20105(parameter) func.xml:20126(parameter)
#: func.xml:20140(parameter) func.xml:20154(parameter)
#: func.xml:20168(parameter) func.xml:20182(parameter)
#: func.xml:20196(parameter) func.xml:20210(parameter)
msgid "key"
msgstr "key"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20077(function)
msgid "pg_advisory_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_lock(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20080(entry) func.xml:20087(entry)
msgid "Obtain exclusive session level advisory lock"
msgstr "Получает исключительную блокировку на уровне сеанса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20084(parameter) func.xml:20098(parameter)
#: func.xml:20112(parameter) func.xml:20133(parameter)
#: func.xml:20147(parameter) func.xml:20161(parameter)
#: func.xml:20175(parameter) func.xml:20189(parameter)
#: func.xml:20203(parameter) func.xml:20217(parameter)
msgid "key1"
msgstr "key1"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20084(parameter) func.xml:20098(parameter)
#: func.xml:20112(parameter) func.xml:20133(parameter)
#: func.xml:20147(parameter) func.xml:20161(parameter)
#: func.xml:20175(parameter) func.xml:20189(parameter)
#: func.xml:20203(parameter) func.xml:20217(parameter)
msgid "key2"
msgstr "key2"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20084(function)
msgid ""
"pg_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20091(function)
msgid "pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20094(entry) func.xml:20101(entry)
msgid "Obtain shared session level advisory lock"
msgstr "Получает разделяемую блокировку на уровне сеанса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20098(function)
msgid ""
"pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20105(function)
msgid "pg_advisory_unlock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_unlock(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20108(entry) func.xml:20115(entry)
msgid "Release an exclusive session level advisory lock"
msgstr "Освобождает исключительную блокировку на уровне сеанса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20112(function)
msgid ""
"pg_advisory_unlock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_unlock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20119(function)
msgid "pg_advisory_unlock_all()"
msgstr "pg_advisory_unlock_all()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20122(entry)
msgid "Release all session level advisory locks held by the current session"
msgstr ""
"Освобождает все блокировки на уровне сеанса, удерживаемые в данном сеансе"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20126(function)
msgid "pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20129(entry) func.xml:20136(entry)
msgid "Release a shared session level advisory lock"
msgstr "Освобождает разделяемую блокировку на уровне сеанса"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20133(function)
msgid ""
"pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"
msgstr ""
"pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20140(function)
msgid "pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20143(entry) func.xml:20150(entry)
msgid "Obtain exclusive transaction level advisory lock"
msgstr "Получает исключительную блокировку на уровне транзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20147(function)
msgid ""
"pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20154(function)
msgid "pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20157(entry) func.xml:20164(entry)
msgid "Obtain shared transaction level advisory lock"
msgstr "Получает разделяемую блокировку на уровне транзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20161(function)
msgid ""
"pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20168(function)
msgid "pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20171(entry) func.xml:20178(entry)
msgid "Obtain exclusive session level advisory lock if available"
msgstr "Получает исключительную блокировку на уровне сеанса, если это возможно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20175(function)
msgid ""
"pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20182(function)
msgid "pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20185(entry) func.xml:20192(entry)
msgid "Obtain shared session level advisory lock if available"
msgstr "Получает разделяемую блокировку на уровне сеанса, если это возможно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20189(function)
msgid ""
"pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20196(function)
msgid "pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20199(entry) func.xml:20206(entry)
msgid "Obtain exclusive transaction level advisory lock if available"
msgstr ""
"Получает исключительную блокировку на уровне транзакции, если это возможно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20203(function)
msgid ""
"pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20210(function)
msgid "pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20213(entry) func.xml:20220(entry)
msgid "Obtain shared transaction level advisory lock if available"
msgstr ""
"Получает разделяемую блокировку на уровне транзакции, если это возможно"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20217(function)
msgid ""
"pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20226(indexterm)
msgid "<primary>pg_advisory_lock</primary>"
msgstr "<primary>pg_advisory_lock</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20229(para)
msgid ""
"<function>pg_advisory_lock</function> locks an application-defined resource, "
"which can be identified either by a single 64-bit key value or two 32-bit "
"key values (note that these two key spaces do not overlap). If another "
"session already holds a lock on the same resource identifier, this function "
"will wait until the resource becomes available. The lock is exclusive. "
"Multiple lock requests stack, so that if the same resource is locked three "
"times it must then be unlocked three times to be released for other "
"sessions' use."
msgstr ""
"<function>pg_advisory_lock</function> блокирует определённый приложением "
"ресурс, задаваемый одним 64-битным или двумя 32-битными ключами (заметьте, "
"что их значения не пересекаются). Если идентификатор этого ресурса "
"удерживает другой сеанс, эта функция не завершится, пока ресурс не станет "
"доступным. Данная функция устанавливает блокировку в исключительном режиме. "
"Если поступает сразу несколько запросов на блокировку, они накапливаются, "
"так что если один ресурс был заблокирован три раза, его необходимо три раза "
"разблокировать, чтобы он был доступен в других сеансах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20240(indexterm)
msgid "<primary>pg_advisory_lock_shared</primary>"
msgstr "<primary>pg_advisory_lock_shared</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20243(para)
msgid ""
"<function>pg_advisory_lock_shared</function> works the same as "
"<function>pg_advisory_lock</function>, except the lock can be shared with "
"other sessions requesting shared locks. Only would-be exclusive lockers are "
"locked out."
msgstr ""
"<function>pg_advisory_lock_shared</function> работает подобно "
"<function>pg_advisory_lock</function>, но позволяет разделять блокировку с "
"другими сеансами, запрашивающими её как разделяемую. Выполнение может быть "
"приостановлено, только если другой сеанс запросил её в исключительном режиме."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20250(indexterm)
msgid "<primary>pg_try_advisory_lock</primary>"
msgstr "<primary>pg_try_advisory_lock</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20253(para)
msgid ""
"<function>pg_try_advisory_lock</function> is similar to "
"<function>pg_advisory_lock</function>, except the function will not wait for "
"the lock to become available. It will either obtain the lock immediately and "
"return <literal>true</literal>, or return <literal>false</literal> if the "
"lock cannot be acquired immediately."
msgstr ""
"<function>pg_try_advisory_lock</function> работает подобно "
"<function>pg_advisory_lock</function>, но не ждёт освобождения ресурса. Эта "
"функция либо немедленно получает блокировку и возвращает <literal>true</"
"literal>, либо сразу возвращает <literal>false</literal>, если получить её "
"не удаётся."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20261(indexterm)
msgid "<primary>pg_try_advisory_lock_shared</primary>"
msgstr "<primary>pg_try_advisory_lock_shared</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20264(para)
msgid ""
"<function>pg_try_advisory_lock_shared</function> works the same as "
"<function>pg_try_advisory_lock</function>, except it attempts to acquire a "
"shared rather than an exclusive lock."
msgstr ""
"<function>pg_try_advisory_lock_shared</function> работает как "
"<function>pg_try_advisory_lock</function>, но пытается получить разделяемую, "
"а не исключительную блокировку."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20270(indexterm)
msgid "<primary>pg_advisory_unlock</primary>"
msgstr "<primary>pg_advisory_unlock</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20273(para)
msgid ""
"<function>pg_advisory_unlock</function> will release a previously-acquired "
"exclusive session level advisory lock. It returns <literal>true</literal> if "
"the lock is successfully released. If the lock was not held, it will return "
"<literal>false</literal>, and in addition, an SQL warning will be reported "
"by the server."
msgstr ""
"<function>pg_advisory_unlock</function> освобождает ранее полученную "
"исключительную блокировку на уровне сеанса. Если блокировка освобождена "
"успешна, эта функция возвращает <literal>true</literal>, а если она не была "
"занята &mdash; <literal>false</literal>, при этом сервер выдаёт "
"предупреждение SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20281(indexterm)
msgid "<primary>pg_advisory_unlock_shared</primary>"
msgstr "<primary>pg_advisory_unlock_shared</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20284(para)
msgid ""
"<function>pg_advisory_unlock_shared</function> works the same as "
"<function>pg_advisory_unlock</function>, except it releases a shared session "
"level advisory lock."
msgstr ""
"<function>pg_advisory_unlock_shared</function> работает подобно "
"<function>pg_advisory_unlock</function>, но освобождает разделяемую "
"блокировку на уровне сеанса."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20290(indexterm)
msgid "<primary>pg_advisory_unlock_all</primary>"
msgstr "<primary>pg_advisory_unlock_all</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20293(para)
msgid ""
"<function>pg_advisory_unlock_all</function> will release all session level "
"advisory locks held by the current session. (This function is implicitly "
"invoked at session end, even if the client disconnects ungracefully.)"
msgstr ""
"<function>pg_advisory_unlock_all</function> освобождает все блокировки на "
"уровне сеанса, закреплённые за текущим сеансом. (Эта функция неявно "
"вызывается в конце любого сеанса, даже при нештатном отключении клиента.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20299(indexterm)
msgid "<primary>pg_advisory_xact_lock</primary>"
msgstr "<primary>pg_advisory_xact_lock</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20302(para)
msgid ""
"<function>pg_advisory_xact_lock</function> works the same as "
"<function>pg_advisory_lock</function>, except the lock is automatically "
"released at the end of the current transaction and cannot be released "
"explicitly."
msgstr ""
"<function>pg_advisory_xact_lock</function> работает подобно "
"<function>pg_advisory_lock</function>, но её блокировка автоматически "
"освобождается в конце текущей транзакции и не может быть освобождена явным "
"образом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20308(indexterm)
msgid "<primary>pg_advisory_xact_lock_shared</primary>"
msgstr "<primary>pg_advisory_xact_lock_shared</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20311(para)
msgid ""
"<function>pg_advisory_xact_lock_shared</function> works the same as "
"<function>pg_advisory_lock_shared</function>, except the lock is "
"automatically released at the end of the current transaction and cannot be "
"released explicitly."
msgstr ""
"<function>pg_advisory_xact_lock_shared</function> подобна функции "
"<function>pg_advisory_lock_shared</function>, но её блокировка автоматически "
"освобождается в конце текущей транзакции и не может быть освобождена явным "
"образом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20317(indexterm)
msgid "<primary>pg_try_advisory_xact_lock</primary>"
msgstr "<primary>pg_try_advisory_xact_lock</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20320(para)
msgid ""
"<function>pg_try_advisory_xact_lock</function> works the same as "
"<function>pg_try_advisory_lock</function>, except the lock, if acquired, is "
"automatically released at the end of the current transaction and cannot be "
"released explicitly."
msgstr ""
"<function>pg_try_advisory_xact_lock</function> работает подобно "
"<function>pg_try_advisory_lock</function>, но её блокировка (если она была "
"получена) автоматически освобождается в конце текущей транзакции и не может "
"быть освобождена явным образом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20327(indexterm)
msgid "<primary>pg_try_advisory_xact_lock_shared</primary>"
msgstr "<primary>pg_try_advisory_xact_lock_shared</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20330(para)
msgid ""
"<function>pg_try_advisory_xact_lock_shared</function> works the same as "
"<function>pg_try_advisory_lock_shared</function>, except the lock, if "
"acquired, is automatically released at the end of the current transaction "
"and cannot be released explicitly."
msgstr ""
"<function>pg_try_advisory_xact_lock_shared</function> работает подобно "
"<function>pg_try_advisory_lock_shared</function>, но её блокировка (если она "
"была получена) автоматически освобождается в конце текущей транзакции и не "
"может быть освобождена явным образом."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20342(title)
msgid "Trigger Functions"
msgstr "Триггерные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20344(indexterm)
msgid "<primary>suppress_redundant_updates_trigger</primary>"
msgstr "<primary>suppress_redundant_updates_trigger</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20348(para)
msgid ""
"Currently <productname>PostgreSQL</productname> provides one built in "
"trigger function, <function>suppress_redundant_updates_trigger</function>, "
"which will prevent any update that does not actually change the data in the "
"row from taking place, in contrast to the normal behavior which always "
"performs the update regardless of whether or not the data has changed. (This "
"normal behavior makes updates run faster, since no checking is required, and "
"is also useful in certain cases.)"
msgstr ""
"В настоящее время в <productname>PostgreSQL</productname> есть единственная "
"встроенная триггерная функция, <function>suppress_redundant_updates_trigger</"
"function>, которая предотвращает изменения, фактически не влияющие на данные "
"в строке, тогда как обычно изменения выполняются вне зависимости от того, "
"были ли изменены данные. (Обычное поведение не предполагает сравнения "
"данных, поэтому изменения выполняются быстрее, и в ряде случаев именно это "
"поведение желательно.)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20359(para)
msgid ""
"Ideally, you should normally avoid running updates that don't actually "
"change the data in the record. Redundant updates can cost considerable "
"unnecessary time, especially if there are lots of indexes to alter, and "
"space in dead rows that will eventually have to be vacuumed. However, "
"detecting such situations in client code is not always easy, or even "
"possible, and writing expressions to detect them can be error-prone. An "
"alternative is to use <function>suppress_redundant_updates_trigger</"
"function>, which will skip updates that don't change the data. You should "
"use this with care, however. The trigger takes a small but non-trivial time "
"for each record, so if most of the records affected by an update are "
"actually changed, use of this trigger will actually make the update run "
"slower."
msgstr ""
"В идеале, следует избегать операций изменения, которые фактически не меняют "
"данные в записях. Подобные ненужные изменения могут обходиться дорого, "
"особенно когда требуется обновлять множество индексов, к тому же "
"впоследствии базу данных придётся очищать от &laquo;мёртвых&raquo; строк. "
"Однако выявить такие изменения в клиентском коде бывает сложно, если вообще "
"возможно, а при составлении соответствующих проверочных выражений легко "
"допустить ошибку. В качестве альтернативного решения можно использовать "
"функцию <function>suppress_redundant_updates_trigger</function>, которая "
"опускает изменения, не меняющие данные. Однако использовать её следует с "
"осторожностью. Данный триггер выполняется не большое, но значительное время "
"для каждой записи, так что если большинство записей всё-таки фактически "
"изменяются, этот триггер скорее замедлит операцию изменения."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20377(programlisting)
#, no-wrap
msgid ""
"CREATE TRIGGER z_min_update\n"
"BEFORE UPDATE ON tablename\n"
"FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();"
msgstr ""
"CREATE TRIGGER z_min_update\n"
"BEFORE UPDATE ON tablename\n"
"FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20374(para)
msgid ""
"The <function>suppress_redundant_updates_trigger</function> function can be "
"added to a table like this: <placeholder-1/> In most cases, you would want "
"to fire this trigger last for each row. Bearing in mind that triggers fire "
"in name order, you would then choose a trigger name that comes after the "
"name of any other trigger you might have on the table."
msgstr ""
"Функцию <function>suppress_redundant_updates_trigger</function> можно "
"привязать к таблице так: <placeholder-1/> В большинстве случаев этот триггер "
"должен вызываться для каждой строки последним. А так как триггеры вызываются "
"по порядку сортировки их имён, имя для него нужно выбирать таким, чтобы оно "
"было последним среди имён всех триггеров, которые могут быть в таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20387(para)
msgid ""
"For more information about creating triggers, see <xref linkend=\"sql-"
"createtrigger\"/>."
msgstr ""
"Подробнее о создании триггеров можно узнать в описании <xref linkend=\"sql-"
"createtrigger\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20394(title)
msgid "Event Trigger Functions"
msgstr "Функции событийных триггеров"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20396(para)
msgid ""
"<productname>PostgreSQL</productname> provides these helper functions to "
"retrieve information from event triggers."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет следующие "
"вспомогательные функции для получения информации в событийных триггерах."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20401(para)
msgid ""
"For more information about event triggers, see <xref linkend=\"event-triggers"
"\"/>."
msgstr ""
"Подробнее о событийных триггерах можно узнать в <xref remap=\"6\" linkend="
"\"event-triggers\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20407(title)
msgid "Capturing Changes at Command End"
msgstr "Получение изменений в конце команды"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20409(indexterm)
msgid "<primary>pg_event_trigger_ddl_commands</primary>"
msgstr "<primary>pg_event_trigger_ddl_commands</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20429(entry) func.xml:20516(entry)
msgid "Type"
msgstr "Тип"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20436(literal) func.xml:20523(literal)
msgid "classid"
msgstr "classid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20437(type) func.xml:20442(type) func.xml:20524(type)
#: func.xml:20529(type) func.xml:20661(type)
msgid "Oid"
msgstr "Oid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20438(entry)
msgid "OID of catalog the object belongs in"
msgstr "OID каталога, к которому относится объект"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20441(literal) func.xml:20528(literal)
msgid "objid"
msgstr "objid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20443(entry)
msgid "OID of the object in the catalog"
msgstr "OID объекта в каталоге"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20446(literal) func.xml:20533(literal)
msgid "objsubid"
msgstr "objsubid"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20448(entry) func.xml:20535(entry)
msgid "Object sub-id (e.g. attribute number for columns)"
msgstr "Идентификатор подобъекта (например, номер для столбцов)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20451(literal)
msgid "command_tag"
msgstr "command_tag"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20453(entry)
msgid "command tag"
msgstr "Тег команды"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20456(literal) func.xml:20558(literal)
msgid "object_type"
msgstr "object_type"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20458(entry) func.xml:20560(entry)
msgid "Type of the object"
msgstr "Тип объекта"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20461(literal) func.xml:20563(literal)
msgctxt "literal"
msgid "schema_name"
msgstr "schema_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20463(entry)
msgid ""
"Name of the schema the object belongs in, if any; otherwise <literal>NULL</"
"literal>. No quoting is applied."
msgstr ""
"Имя схемы, к которой относится объект; если объект не относится ни к какой "
"схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20469(literal) func.xml:20580(literal)
msgid "object_identity"
msgstr "object_identity"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20471(entry) func.xml:20582(entry)
msgid ""
"Text rendering of the object identity, schema-qualified. Each and every "
"identifier present in the identity is quoted if necessary."
msgstr ""
"Текстовое представление идентификатора объекта, дополненного схемой. "
"Компоненты этого идентификаторы могут заключаться в кавычки, если требуется."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20477(literal)
msgid "in_extension"
msgstr "in_extension"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20479(entry)
msgid "whether the command is part of an extension script"
msgstr "является ли команда частью скрипта расширения"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20482(literal)
msgid "command"
msgstr "command"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20483(type)
msgid "pg_ddl_command"
msgstr "pg_ddl_command"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20484(entry)
msgid ""
"A complete representation of the command, in internal format. This cannot be "
"output directly, but it can be passed to other functions to obtain different "
"pieces of information about the command."
msgstr ""
"Полное представление команды, во внутреннем формате. Его нельзя вывести "
"непосредственно, но можно передать другим функциям, чтобы получить различные "
"сведения о команде."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20413(para)
msgid ""
"<function>pg_event_trigger_ddl_commands</function> returns a list of "
"<acronym>DDL</acronym> commands executed by each user action, when invoked "
"in a function attached to a <literal>ddl_command_end</literal> event "
"trigger. If called in any other context, an error is raised. "
"<function>pg_event_trigger_ddl_commands</function> returns one row for each "
"base command executed; some commands that are a single SQL sentence may "
"return more than one row. This function returns the following columns: "
"<placeholder-1/>"
msgstr ""
"Функция <function>pg_event_trigger_ddl_commands</function> возвращает список "
"команд <acronym>DDL</acronym>, выполняемых в результате действия "
"пользователя. Вызывать её можно только в функции, реализующей событийный "
"триггер <literal>ddl_command_end</literal>. При попытке вызвать её в любом "
"другом контексте возникнет ошибка. Функция "
"<function>pg_event_trigger_ddl_commands</function> возвращает одну строку "
"для каждой базовой команды; для некоторых команд, записываемых в виде одного "
"предложения SQL, может возвращаться несколько строк. Эта функция возвращает "
"следующие столбцы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20498(title)
msgid "Processing Objects Dropped by a DDL Command"
msgstr "Обработка объектов, удалённых командой DDL"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20500(indexterm)
msgid "<primary>pg_event_trigger_dropped_objects</primary>"
msgstr "<primary>pg_event_trigger_dropped_objects</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20525(entry)
msgid "OID of catalog the object belonged in"
msgstr "OID каталога, к которому относился объект"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20530(entry)
msgid "OID the object had within the catalog"
msgstr "OID, который имел объект в каталоге"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20534(type)
msgid "int32"
msgstr "int32"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20538(literal)
msgid "original"
msgstr "original"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20540(entry)
msgid "Flag used to identify the root object(s) of the deletion"
msgstr "Флаг, обозначающий исходный удаляемый объект(ы)"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20543(literal)
msgid "normal"
msgstr "normal"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20545(entry)
msgid ""
"Flag indicating that there's a normal dependency relationship in the "
"dependency graph leading to this object"
msgstr ""
"Флаг, обозначающий, что к этому объекту в графе зависимостей привело "
"отношение обычной зависимости"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20551(literal)
msgid "is_temporary"
msgstr "is_temporary"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20553(entry)
msgid "Flag indicating that the object was a temporary object."
msgstr "Флаг, обозначающий, что объект был временным."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20565(entry)
msgid ""
"Name of the schema the object belonged in, if any; otherwise <literal>NULL</"
"literal>. No quoting is applied."
msgstr ""
"Имя схемы, к которой относился объект; если объект не относился ни к какой "
"схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20571(literal)
msgid "object_name"
msgstr "object_name"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20573(entry)
msgid ""
"Name of the object, if the combination of schema and name can be used as a "
"unique identifier for the object; otherwise <literal>NULL</literal>. No "
"quoting is applied, and name is never schema-qualified."
msgstr ""
"Имя объекта, если сочетание схемы и имени позволяет уникально "
"идентифицировать объект; в противном случае &mdash; <literal>NULL</literal>. "
"Имя не заключается в кавычки и не дополняется именем схемы."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20588(literal)
msgid "address_names"
msgstr "address_names"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20590(entry)
msgid ""
"An array that, together with <literal>object_type</literal> and "
"<literal>address_args</literal>, can be used by the "
"<function>pg_get_object_address()</function> to recreate the object address "
"in a remote server containing an identically named object of the same kind."
msgstr ""
"Массив, который в сочетании с <literal>object_type</literal> и массивом "
"<literal>address_args</literal> можно передать функции "
"<function>pg_get_object_address()</function> и воссоздать адрес объекта на "
"удалённом сервере, содержащем одноимённый объект того же рода."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20599(literal)
msgid "address_args"
msgstr "address_args"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20601(entry)
msgid "Complement for <literal>address_names</literal> above."
msgstr "Дополнение предшествующего массива <literal>address_names</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20504(para)
msgid ""
"<function>pg_event_trigger_dropped_objects</function> returns a list of all "
"objects dropped by the command in whose <literal>sql_drop</literal> event it "
"is called. If called in any other context, "
"<function>pg_event_trigger_dropped_objects</function> raises an error. "
"<function>pg_event_trigger_dropped_objects</function> returns the following "
"columns: <placeholder-1/>"
msgstr ""
"Функция <function>pg_event_trigger_dropped_objects</function> возвращает "
"список всех объектов, удалённых командой, вызвавшей событие "
"<literal>sql_drop</literal>. При вызове в другом контексте "
"<function>pg_event_trigger_dropped_objects</function> выдаёт ошибку. "
"<function>pg_event_trigger_dropped_objects</function> возвращает следующие "
"столбцы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20613(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test_event_trigger_for_drops()\n"
"        RETURNS event_trigger LANGUAGE plpgsql AS $$\n"
"DECLARE\n"
"    obj record;\n"
"BEGIN\n"
"    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n"
"    LOOP\n"
"        RAISE NOTICE '% dropped object: % %.% %',\n"
"                     tg_tag,\n"
"                     obj.object_type,\n"
"                     obj.schema_name,\n"
"                     obj.object_name,\n"
"                     obj.object_identity;\n"
"    END LOOP;\n"
"END\n"
"$$;\n"
"CREATE EVENT TRIGGER test_event_trigger_for_drops\n"
"   ON sql_drop\n"
"   EXECUTE PROCEDURE test_event_trigger_for_drops();"
msgstr ""
"CREATE FUNCTION test_event_trigger_for_drops()\n"
"        RETURNS event_trigger LANGUAGE plpgsql AS $$\n"
"DECLARE\n"
"    obj record;\n"
"BEGIN\n"
"    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n"
"    LOOP\n"
"        RAISE NOTICE '% dropped object: % %.% %',\n"
"                     tg_tag,\n"
"                     obj.object_type,\n"
"                     obj.schema_name,\n"
"                     obj.object_name,\n"
"                     obj.object_identity;\n"
"    END LOOP;\n"
"END\n"
"$$;\n"
"CREATE EVENT TRIGGER test_event_trigger_for_drops\n"
"   ON sql_drop\n"
"   EXECUTE PROCEDURE test_event_trigger_for_drops();"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20610(para)
msgid ""
"The <function>pg_event_trigger_dropped_objects</function> function can be "
"used in an event trigger like this: <placeholder-1/>"
msgstr ""
"Функцию <function>pg_event_trigger_dropped_objects</function> можно "
"использовать в событийном триггере так: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20638(title)
msgid "Handling a Table Rewrite Event"
msgstr "Обработка события перезаписи таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20640(para)
msgid ""
"The functions shown in <xref linkend=\"functions-event-trigger-table-rewrite"
"\"/> provide information about a table for which a <literal>table_rewrite</"
"literal> event has just been called. If called in any other context, an "
"error is raised."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-event-trigger-table-rewrite\"/> "
"показаны функции, выдающие информацию о таблице, для которой произошло "
"событие перезаписи таблицы (<literal>table_rewrite</literal>). При попытке "
"вызвать их в другом контексте возникнет ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20649(title)
msgid "Table Rewrite information"
msgstr "Информация о перезаписи таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20658(indexterm)
msgid "<primary>pg_event_trigger_table_rewrite_oid</primary>"
msgstr "<primary>pg_event_trigger_table_rewrite_oid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20659(function)
msgid "pg_event_trigger_table_rewrite_oid()"
msgstr "pg_event_trigger_table_rewrite_oid()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20662(entry)
msgid "The OID of the table about to be rewritten."
msgstr "OID таблицы, которая будет перезаписана."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20667(indexterm)
msgid "<primary>pg_event_trigger_table_rewrite_reason</primary>"
msgstr "<primary>pg_event_trigger_table_rewrite_reason</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20668(function)
msgid "pg_event_trigger_table_rewrite_reason()"
msgstr "pg_event_trigger_table_rewrite_reason()"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20671(entry)
msgid ""
"The reason code(s) explaining the reason for rewriting. The exact meaning of "
"the codes is release dependent."
msgstr ""
"Код причины, показывающий, чем вызвана перезапись. Точное значение кодов "
"зависит от выпуска (версии)."

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20683(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test_event_trigger_table_rewrite_oid()\n"
" RETURNS event_trigger\n"
" LANGUAGE plpgsql AS\n"
"$$\n"
"BEGIN\n"
"  RAISE NOTICE 'rewriting table % for reason %',\n"
"                pg_event_trigger_table_rewrite_oid()::regclass,\n"
"                pg_event_trigger_table_rewrite_reason();\n"
"END;\n"
"$$;\n"
"\n"
"CREATE EVENT TRIGGER test_table_rewrite_oid\n"
"                  ON table_rewrite\n"
"   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();"
msgstr ""
"CREATE FUNCTION test_event_trigger_table_rewrite_oid()\n"
" RETURNS event_trigger\n"
" LANGUAGE plpgsql AS\n"
"$$\n"
"BEGIN\n"
"  RAISE NOTICE 'rewriting table % for reason %',\n"
"                pg_event_trigger_table_rewrite_oid()::regclass,\n"
"                pg_event_trigger_table_rewrite_reason();\n"
"END;\n"
"$$;\n"
"\n"
"CREATE EVENT TRIGGER test_table_rewrite_oid\n"
"                  ON table_rewrite\n"
"   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();"

#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:20680(para)
msgid ""
"The <function>pg_event_trigger_table_rewrite_oid</function> function can be "
"used in an event trigger like this: <placeholder-1/>"
msgstr ""
"Функцию <function>pg_event_trigger_table_rewrite_oid</function> можно "
"использовать в событийном триггере так: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: func.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: func.xml:4276(para)
msgid ""
"The <function>regexp_matches</function> function returns a text array of all "
"of the captured substrings resulting from matching a POSIX regular "
"expression pattern. It has the syntax <function>regexp_matches</"
"function>(<replaceable>string</replaceable>, <replaceable>pattern</"
"replaceable> <optional>, <replaceable>flags</replaceable></optional>). The "
"function can return no rows, one row, or multiple rows (see the <literal>g</"
"literal> flag below). If the <replaceable>pattern</replaceable> does not "
"match, the function returns no rows. If the pattern contains no "
"parenthesized subexpressions, then each row returned is a single-element "
"text array containing the substring matching the whole pattern. If the "
"pattern contains parenthesized subexpressions, the function returns a text "
"array whose <replaceable>n</replaceable>'th element is the substring "
"matching the <replaceable>n</replaceable>'th parenthesized subexpression of "
"the pattern (not counting <quote>non-capturing</quote> parentheses; see "
"below for details). The <replaceable>flags</replaceable> parameter is an "
"optional text string containing zero or more single-letter flags that change "
"the function's behavior. Flag <literal>g</literal> causes the function to "
"find each match in the string, not only the first one, and return a row for "
"each such match. Supported flags (though not <literal>g</literal>) are "
"described in <xref linkend=\"posix-embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_matches</function> возвращает текстовый массив из "
"всех подходящих подстрок, полученных в результате применения регулярного "
"выражения POSIX. Она имеет синтаксис <function>regexp_matches</"
"function>(<replaceable>строка</replaceable>, <replaceable>шаблон</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Эта "
"функция может вовсе не вернуть строк или вернуть одну или несколько строк "
"(см. описание флага <literal>g</literal> ниже). Если <replaceable>шаблон</"
"replaceable> не находится в строке, функция не возвращает строк. Если шаблон "
"не содержит подвыражений в скобках, тогда для каждой строки возвращается "
"массив с одним элементом, содержащим подстроку, соответствующую всему "
"шаблону. Если же шаблон содержит подвыражения в скобках, функция возвращает "
"массив элементов, в котором <replaceable>n</replaceable>-эй элемент "
"соответствует <replaceable>n</replaceable>-ому подвыражению в скобках (не "
"считая скобки <quote>без захвата</quote>; подробнее об этом ниже). В "
"необязательном параметре <replaceable>флаги</replaceable> передаётся "
"текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих "
"поведение функции. Флаг <literal>g</literal> указывает, что функция должна "
"находить в строке не только первое, а все соответствия шаблону, и возвращать "
"строку для каждого соответствия. Допустимые флаги (кроме <literal>g</"
"literal>) описаны в <xref remap=\"6\" linkend=\"posix-embedded-options-table"
"\"/>."

#. +> REL9_6_3 REL9_6
#: func.xml:4304(programlisting)
#, no-wrap
msgid ""
"SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebaz', 'barbeque');\n"
" regexp_matches \n"
"----------------\n"
" {barbeque}\n"
"(1 row)"
msgstr ""
"SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_matches(\n"
" 'foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebaz', 'barbeque');\n"
" regexp_matches \n"
"----------------\n"
" {barbeque}\n"
"(1 row)"

#. +> REL9_6_3 REL9_6
#: func.xml:4326(para)
msgid ""
"It is possible to force <function>regexp_matches()</function> to always "
"return one row by using a sub-select; this is particularly useful in a "
"<literal>SELECT</literal> target list when you want all rows returned, even "
"non-matching ones: <placeholder-1/>"
msgstr ""
"Добиться, чтобы функция <function>regexp_matches()</function> всегда "
"возвращала одну строку, можно с помощью вложенного подзапроса; это особенно "
"полезно в списке выборки <literal>SELECT</literal>, когда нужно получить все "
"строки, в том числе и не соответствующие шаблону: <placeholder-1/>"

#. +> REL9_6_3 REL9_6
#: func.xml:4408(para)
msgid ""
"As the last example demonstrates, the regexp split functions ignore zero-"
"length matches that occur at the start or end of the string or immediately "
"after a previous match. This is contrary to the strict definition of regexp "
"matching that is implemented by <function>regexp_matches</function>, but is "
"usually the most convenient behavior in practice. Other software systems "
"such as Perl use similar definitions."
msgstr ""
"Как показывает последний пример, функции разделения по регулярным выражениям "
"игнорируют вхождения нулевой длины, идущие в начале и в конце строки, а "
"также непосредственно за предыдущим вхождением. Это поведение противоречит "
"строгому определению поиска по регулярным выражениям, который реализует "
"<function>regexp_matches</function>, но обычно более удобно на практике. "
"Подобное поведение наблюдается и в других программных средах, например в "
"Perl."

#. +> REL9_6_3 REL9_6
#: func.xml:5980(entry)
msgid ""
"quarter (ignored by <function>to_date</function> and <function>to_timestamp</"
"function>)"
msgstr ""
"квартал (игнорируется функциями <function>to_date</function> и "
"<function>to_timestamp</function>)"

#. +> REL9_6_3 REL9_6
#: func.xml:6102(para)
msgid ""
"<function>to_timestamp</function> and <function>to_date</function> exist to "
"handle input formats that cannot be converted by simple casting. These "
"functions interpret input liberally, with minimal error checking. While they "
"produce valid output, the conversion can yield unexpected results. For "
"example, input to these functions is not restricted by normal ranges, thus "
"<literal>to_date('20096040','YYYYMMDD')</literal> returns "
"<literal>2014-01-17</literal> rather than causing an error. Casting does not "
"have this behavior."
msgstr ""
"<function>to_timestamp</function> и <function>to_date</function> "
"предназначены для обработки входных форматов, для которых недостаточно "
"простого приведения. Эти функции интерпретируют вводимые данные с "
"послаблениями, проверяя только грубые ошибки. Хотя они выдают корректные "
"данные, результат может отличаться от ожидаемого. В частности, входные "
"аргументы этих функций не ограничиваются обычными диапазонами, так что "
"<literal>to_date('20096040','YYYYMMDD')</literal> выдаёт "
"<literal>2014-01-17</literal>, а не ошибку. С приведением такого не "
"происходит."

#. +> REL9_6_3 REL9_6
#: func.xml:6139(para)
msgid ""
"If the year format specification is less than four digits, e.g. "
"<literal>YYY</literal>, and the supplied year is less than four digits, the "
"year will be adjusted to be nearest to the year 2020, e.g. <literal>95</"
"literal> becomes 1995."
msgstr ""
"Если формат года определяется менее, чем 4 цифрами, например, как "
"<literal>YYY</literal>, и в переданном значении года тоже меньше 4 цифр, год "
"пересчитывается в максимально близкий к году 2020, т. е. <literal>95</"
"literal> воспринимается как 1995."

#. +> REL9_6_3 REL9_6
#: func.xml:6148(para)
msgid ""
"The <literal>YYYY</literal> conversion from string to <type>timestamp</type> "
"or <type>date</type> has a restriction when processing years with more than "
"4 digits. You must use some non-digit character or template after "
"<literal>YYYY</literal>, otherwise the year is always interpreted as 4 "
"digits. For example (with the year 20000): <literal>to_date('200001131', "
"'YYYYMMDD')</literal> will be interpreted as a 4-digit year; instead use a "
"non-digit separator after the year, like <literal>to_date('20000-1131', "
"'YYYY-MMDD')</literal> or <literal>to_date('20000Nov31', 'YYYYMonDD')</"
"literal>."
msgstr ""
"С преобразованием <literal>YYYY</literal> из строки в тип <type>timestamp</"
"type> или <type>date</type> связано ограничение, когда обрабатываемый год "
"записывается более чем 4 цифрами. После <literal>YYYY</literal> необходимо "
"будет добавить не цифровой символ или соответствующий код, иначе год всегда "
"будет восприниматься как 4 цифры. Например, в <literal>to_date('200001131', "
"'YYYYMMDD')</literal> (с годом 20000) год будет интерпретирован как "
"состоящий из 4 цифр; чтобы исправить ситуацию, нужно добавить не цифровой "
"разделитель после года, как в <literal>to_date('20000-1131', 'YYYY-MMDD')</"
"literal>, или код как в <literal>to_date('20000Nov31', 'YYYYMonDD')</"
"literal>."

#. +> REL9_6_3 REL9_6
#: func.xml:6220(para)
msgid ""
"In a conversion from string to <type>timestamp</type>, millisecond "
"(<literal>MS</literal>) or microsecond (<literal>US</literal>) values are "
"used as the seconds digits after the decimal point. For example "
"<literal>to_timestamp('12:3', 'SS:MS')</literal> is not 3 milliseconds, but "
"300, because the conversion counts it as 12 + 0.3 seconds. This means for "
"the format <literal>SS:MS</literal>, the input values <literal>12:3</"
"literal>, <literal>12:30</literal>, and <literal>12:300</literal> specify "
"the same number of milliseconds. To get three milliseconds, one must use "
"<literal>12:003</literal>, which the conversion counts as 12 + 0.003 = "
"12.003 seconds."
msgstr ""
"При преобразовании из текстовой строки в <type>timestamp</type>, "
"миллисекунды (<literal>MS</literal>) или микросекунды (<literal>US</"
"literal>) воспринимаются как дробная часть числа секунд. Например, "
"<literal>to_timestamp('12:3', 'SS:MS')</literal> &mdash; это не 3 "
"миллисекунды, а 300, так как это значение воспринимается как 12 + 0.3 сек. "
"Это значит, что для формата <literal>SS:MS</literal> вводимые значения "
"<literal>12:3</literal>, <literal>12:30</literal> и <literal>12:300</"
"literal> задают одно и то же число миллисекунд. Чтобы получить три "
"миллисекунды, время нужно записать в виде <literal>12:003</literal>, тогда "
"это будет воспринято как 12 + 0.003 = 12.003 сек."

#. +> REL9_6_3 REL9_6
#: func.xml:6253(para)
msgid ""
"<function>to_char(interval)</function> formats <literal>HH</literal> and "
"<literal>HH12</literal> as shown on a 12-hour clock, i.e. zero hours and 36 "
"hours output as <literal>12</literal>, while <literal>HH24</literal> outputs "
"the full hour value, which can exceed 23 for intervals."
msgstr ""
"Функция <function>to_char(interval)</function> обрабатывает форматы "
"<literal>HH</literal> и <literal>HH12</literal> в рамках 12 часов, то есть 0 "
"и 36 часов будут выводиться как <literal>12</literal>, тогда как "
"<literal>HH24</literal> выводит значение полностью и для интервалов "
"выводимое значение может превышать 23."

#. +> REL9_6_3 REL9_6
#: func.xml:6281(entry)
msgid "value with the specified number of digits"
msgstr "значение с заданным количеством цифр"

#. +> REL9_6_3 REL9_6
#: func.xml:6285(entry)
msgid "value with leading zeros"
msgstr "значение с ведущими нулями"

#. +> REL9_6_3 REL9_6
#: func.xml:6293(entry)
msgid "group (thousand) separator"
msgstr "разделитель групп (тысяч)"

#. +> REL9_6_3 REL9_6
#: func.xml:6352(para)
msgid ""
"A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or "
"<literal>MI</literal> is not anchored to the number; for example, "
"<literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;"
"&nbsp;12'</literal> but <literal>to_char(-12, 'S9999')</literal> produces "
"<literal>'&nbsp;&nbsp;-12'</literal>. The Oracle implementation does not "
"allow the use of <literal>MI</literal> before <literal>9</literal>, but "
"rather requires that <literal>9</literal> precede <literal>MI</literal>."
msgstr ""
"Знак числа, полученный кодами <literal>SG</literal>, <literal>PL</literal> "
"или <literal>MI</literal>, не присоединяется к числу; например, "
"<literal>to_char(-12, 'MI9999')</literal> выдаёт <literal>'-&nbsp;&nbsp;12'</"
"literal>, тогда как <literal>to_char(-12, 'S9999')</literal> &mdash; "
"<literal>'&nbsp;&nbsp;-12'</literal>. В Oracle <literal>MI</literal> не "
"может идти перед <literal>9</literal>, наоборот <literal>9</literal> нужно "
"указать перед <literal>MI</literal>."

#. +> REL9_6_3 REL9_6
#: func.xml:6366(para)
msgid ""
"<literal>9</literal> results in a value with the same number of digits as "
"there are <literal>9</literal>s. If a digit is not available it outputs a "
"space."
msgstr ""
"<literal>9</literal> выводит значение с таким количеством цифр, какое было "
"бы, если бы оно состояло из девяток. Если цифры в данном месте не "
"оказывается, выводится пробел."

#. +> REL9_6_3 REL9_6
#: func.xml:6414(para)
msgid ""
"Certain modifiers can be applied to any template pattern to alter its "
"behavior. For example, <literal>FM9999</literal> is the <literal>9999</"
"literal> pattern with the <literal>FM</literal> modifier. <xref linkend="
"\"functions-formatting-numericmod-table\"/> shows the modifier patterns for "
"numeric formatting."
msgstr ""
"Для изменения поведения кодов к ним могут быть применены определённые "
"модификаторы. Например, <literal>FM9999</literal> обрабатывается как код "
"<literal>9999</literal> с модификатором <literal>FM</literal>. Все "
"модификаторы для форматирования чисел перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-numericmod-table\"/>."

#. +> REL9_6_3 REL9_6
#: func.xml:6437(literal)
msgid "FM9999"
msgstr "FM9999"

#. +> REL9_6_3 REL9_6
#: func.xml:7645(literal) func.xml:7831(literal)
msgid "quarter"
msgstr "quarter"

#. +> REL9_6_3 REL9_6
#: func.xml:9597(entry)
msgid "expand a tsvector to a set of rows"
msgstr "разворачивает tsvector в набор строк"

#. +> REL9_6_3 REL9_6
#: func.xml:10262(para)
msgid ""
"To process values of data type <type>xml</type>, PostgreSQL offers the "
"functions <function>xpath</function> and <function>xpath_exists</function>, "
"which evaluate XPath 1.0 expressions."
msgstr ""
"Для обработки значений типа <type>xml</type> с помощью выражений XPath 1.0 в "
"PostgreSQL представлены функции <function>xpath</function> и "
"<function>xpath_exists</function>."

#. +> REL9_6_3 REL9_6
#: func.xml:10331(function)
msgid "xpath_exists"
msgstr "xpath_exists"

#. +> REL9_6_3 REL9_6
#: func.xml:11182(literal)
msgid ""
"select * from json_populate_record(null::myrowtype, '{\"a\":1,\"b\":2}')"
msgstr ""
"select * from json_populate_record(null::myrowtype, '{\"a\":1,\"b\":2}')"

#. +> REL9_6_3 REL9_6
#: func.xml:11184(programlisting)
#, no-wrap
msgid ""
" a | b\n"
"---+---\n"
" 1 | 2"
msgstr ""
" a | b\n"
"---+---\n"
" 1 | 2"

#. +> REL9_6_3 REL9_6
#: func.xml:11276(literal)
msgid ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":\"bar\"}') as x(a "
"int, b text, d text)"
msgstr ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":\"bar\"}') as x(a "
"int, b text, d text)"

#. +> REL9_6_3 REL9_6
#: func.xml:11278(programlisting)
#, no-wrap
msgid ""
" a |    b    | d\n"
"---+---------+---\n"
" 1 | [1,2,3] |"
msgstr ""
" a |    b    | d\n"
"---+---------+---\n"
" 1 | [1,2,3] |"

#. +> REL9_6_3 REL9_6
#: func.xml:12781(para)
msgid ""
"<firstterm>Aggregate functions</firstterm> compute a single result from a "
"set of input values. The built-in normal aggregate functions are listed in "
"<xref linkend=\"functions-aggregate-table\"/> and <xref linkend=\"functions-"
"aggregate-statistics-table\"/>. The built-in ordered-set aggregate functions "
"are listed in <xref linkend=\"functions-orderedset-table\"/> and <xref "
"linkend=\"functions-hypothetical-table\"/>. Grouping operations, which are "
"closely related to aggregate functions, are listed in <xref linkend="
"\"functions-grouping-table\"/>. The special syntax considerations for "
"aggregate functions are explained in <xref linkend=\"syntax-aggregates\"/>. "
"Consult <xref linkend=\"tutorial-agg\"/> for additional introductory "
"information."
msgstr ""
"<firstterm>Агрегатные функции</firstterm> получают единственный результат из "
"набора входных значений. Встроенные обычные агрегатные функции перечислены в "
"<xref remap=\"6\" linkend=\"functions-aggregate-table\"/> и <xref remap="
"\"6\" linkend=\"functions-aggregate-statistics-table\"/>, а сортирующие "
"агрегатные функции &mdash; в <xref remap=\"6\" linkend=\"functions-"
"orderedset-table\"/> и <xref remap=\"6\" linkend=\"functions-hypothetical-"
"table\"/>. Операции группирования, тесно связанные с агрегатными функциями, "
"перечислены в <xref remap=\"6\" linkend=\"functions-grouping-table\"/>. "
"Особенности синтаксиса агрегатных функций разъясняются в <xref remap=\"6\" "
"linkend=\"syntax-aggregates\"/>. За дополнительной вводной информацией "
"обратитесь к <xref remap=\"3\" linkend=\"tutorial-agg\"/>."

#. +> REL9_6_3 REL9_6
#: func.xml:14027(para)
msgid ""
"The built-in window functions are listed in <xref linkend=\"functions-window-"
"table\"/>. Note that these functions <emphasis>must</emphasis> be invoked "
"using window function syntax; that is an <literal>OVER</literal> clause is "
"required."
msgstr ""
"Встроенные оконные функции перечислены в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>. Заметьте, что эти функции <emphasis>должны</"
"emphasis> вызываться именно как оконные, т. е. при вызове необходимо "
"использовать предложение <literal>OVER</literal>."

#. +> REL9_6_3 REL9_6
#: func.xml:14034(para)
msgid ""
"In addition to these functions, any built-in or user-defined normal "
"aggregate function (but not ordered-set or hypothetical-set aggregates) can "
"be used as a window function; see <xref linkend=\"functions-aggregate\"/> "
"for a list of the built-in aggregates. Aggregate functions act as window "
"functions only when an <literal>OVER</literal> clause follows the call; "
"otherwise they act as regular aggregates."
msgstr ""
"В дополнение к этим функциям в качестве оконных можно использовать любые "
"встроенные или пользовательские обычные (но не сортирующие и не "
"гипотезирующие) агрегатные функции (встроенные функции перечислены в <xref "
"remap=\"6\" linkend=\"functions-aggregate\"/>). Агрегатные функции работают "
"как оконные, только когда за их вызовом следует предложение <literal>OVER</"
"literal>; в противном случае они останутся обычными агрегатными."

#. +> REL9_6_3 REL9_6
#: func.xml:14105(entry)
msgid ""
"relative rank of the current row: (<function>rank</function> - 1) / (total "
"rows - 1)"
msgstr ""
"относительный ранг текущей строки: (<function>rank</function> - 1) / (общее "
"число строк - 1)"

#. +> REL9_6_3 REL9_6
#: func.xml:14118(entry)
msgid ""
"relative rank of the current row: (number of rows preceding or peer with "
"current row) / (total rows)"
msgstr ""
"относительный ранг текущей строки: (число строк, предшествующих или "
"родственных текущей) / (общее число строк)"

#. +> REL9_6_3 REL9_6
#: func.xml:14247(para)
msgid ""
"All of the functions listed in <xref linkend=\"functions-window-table\"/> "
"depend on the sort ordering specified by the <literal>ORDER BY</literal> "
"clause of the associated window definition. Rows that are not distinct in "
"the <literal>ORDER BY</literal> ordering are said to be <firstterm>peers</"
"firstterm>; the four ranking functions are defined so that they give the "
"same answer for any two peer rows."
msgstr ""
"Результат всех функций, перечисленных в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>, зависит от порядка сортировки, заданного "
"предложением <literal>ORDER BY</literal> в определении соответствующего "
"окна. Строки, которые являются одинаковыми с точки зрения сортировки "
"<literal>ORDER BY</literal>, считаются <firstterm>родственными</firstterm>; "
"четыре функции, вычисляющие ранг, реализованы так, что их результат будет "
"одинаковым для любых двух родственных строк."

#. +> REL9_6_3 REL9_6
#: func.xml:15238(programlisting)
#, no-wrap
msgid ""
"-- set returning function WITH ORDINALITY\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_clog         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_xlog         | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 rows)"
msgstr ""
"-- функция, возвращающая множество, с нумерацией\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_clog         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_xlog         | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 строк)"

#. +> REL9_6_3 REL9_6
#: func.xml:15370(entry)
msgid "Process ID(s) that are blocking specified server process ID"
msgstr ""
"идентификаторы процессов, блокирующих серверный процесс с определённым ID"

#. +> REL9_6_3 REL9_6
#: func.xml:15859(parameter) func.xml:15866(parameter)
#: func.xml:16961(parameter)
msgid "type"
msgstr "type"

#. +> REL9_6_3 REL9_6
#: func.xml:16496(entry)
msgid ""
"get name of the sequence that a <type>serial</type>, <type>smallserial</"
"type> or <type>bigserial</type> column uses"
msgstr ""
"получает имя последовательности, связанной со столбцом типа <type>serial</"
"type>, <type>smallserial</type> или <type>bigserial</type>"

#. +> REL9_6_3 REL9_6
#: func.xml:16641(para)
msgid ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function>, and "
"<function>pg_get_triggerdef</function>, respectively reconstruct the "
"creating command for a constraint, index, rule, or trigger. (Note that this "
"is a decompiled reconstruction, not the original text of the command.) "
"<function>pg_get_expr</function> decompiles the internal form of an "
"individual expression, such as the default value for a column. It can be "
"useful when examining the contents of system catalogs. If the expression "
"might contain Vars, specify the OID of the relation they refer to as the "
"second parameter; if no Vars are expected, zero is sufficient. "
"<function>pg_get_viewdef</function> reconstructs the <command>SELECT</"
"command> query that defines a view. Most of these functions come in two "
"variants, one of which can optionally <quote>pretty-print</quote> the "
"result. The pretty-printed format is more readable, but the default format "
"is more likely to be interpreted the same way by future versions of "
"<productname>PostgreSQL</productname>; avoid using pretty-printed output for "
"dump purposes. Passing <literal>false</literal> for the pretty-print "
"parameter yields the same result as the variant that does not have the "
"parameter at all."
msgstr ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function> и "
"<function>pg_get_triggerdef</function> восстанавливают команду, создававшую "
"заданное ограничение, индекс, правило или триггер, соответственно. (Учтите, "
"что они возвращают не изначальный текст команды, а результат декомпиляции.) "
"<function>pg_get_expr</function> декомпилирует внутреннюю форму отдельного "
"выражения, например значения по умолчанию для столбца. Это может быть "
"полезно для изучения содержимого системных каталогов. Если выражение может "
"содержать переменные, укажите во втором параметре OID отношения, на который "
"они ссылаются; если таких переменных нет, вместо OID можно передать 0. "
"<function>pg_get_viewdef</function> восстанавливает запрос <command>SELECT</"
"command>, определяющий представление. Многие из этих функций имеют две "
"версии, одна из которых позволяет получить форматированный вывод (параметр "
"pretty_bool). Форматированный текст легче читается, но нет гарантии, что он "
"будет всегда восприниматься одинаково будущими версиями "
"<productname>PostgreSQL</productname>, поэтому не следует применять "
"форматирование при выгрузке метаданных. Если параметр pretty_bool равен "
"<literal>false</literal>, эта версия функции выдаёт тот же результат, что и "
"версия без параметров."

#. +> REL9_6_3 REL9_6
#: func.xml:16676(para)
msgid ""
"<function>pg_get_serial_sequence</function> returns the name of the sequence "
"associated with a column, or NULL if no sequence is associated with the "
"column. The first input parameter is a table name with optional schema, and "
"the second parameter is a column name. Because the first parameter is "
"potentially a schema and table, it is not treated as a double-quoted "
"identifier, meaning it is lower cased by default, while the second "
"parameter, being just a column name, is treated as double-quoted and has its "
"case preserved. The function returns a value suitably formatted for passing "
"to sequence functions (see <xref linkend=\"functions-sequence\"/>). This "
"association can be modified or removed with <command>ALTER SEQUENCE OWNED "
"BY</command>. (The function probably should have been called "
"<function>pg_get_owned_sequence</function>; its current name reflects the "
"fact that it's typically used with <type>serial</type> or <type>bigserial</"
"type> columns.)"
msgstr ""
"<function>pg_get_serial_sequence</function> возвращает имя "
"последовательности, связанной со столбцом, и NULL, если такой "
"последовательности нет. В первом параметре функции указывается имя таблицы, "
"возможно дополненное схемой, а во втором имя столбца. Так как первый "
"параметр может содержать имя схемы и таблицы, он воспринимается не как "
"идентификатор в кавычках и поэтому по умолчанию приводится к нижнему "
"регистру, тогда как имя столбца воспринимается как заключённое в кавычки и в "
"нём регистр символов сохраняется. Эта функция возвращает имя в виде, "
"пригодном для передачи функциям, работающим с последовательностями (см. "
"<xref remap=\"4\" linkend=\"functions-sequence\"/>). Связь "
"последовательности со столбцом можно изменить или удалить с помощью команды "
"<command>ALTER SEQUENCE OWNED BY</command>. (Данную функцию можно было бы "
"назвать <function>pg_get_owned_sequence</function>; настоящее её имя "
"отражает то, что она обычно используется со столбцами <type>serial</type> и "
"<type>bigserial</type>.)"

#. +> REL9_6_3 REL9_6
#: func.xml:17366(literal)
msgid "checkpoint_location"
msgstr "checkpoint_location"

#. +> REL9_6_3 REL9_6
#: func.xml:17371(literal)
msgid "prior_location"
msgstr "prior_location"

#. +> REL9_6_3 REL9_6
#: func.xml:17376(literal)
msgid "redo_location"
msgstr "redo_location"

#. +> REL9_6_3 REL9_6
#: func.xml:17568(literal)
msgid "bigint_timestamps"
msgstr "bigint_timestamps"

#. +> REL9_6_3 REL9_6
#: func.xml:17609(literal)
msgid "min_recovery_end_location"
msgstr "min_recovery_end_location"

#. +> REL9_6_3 REL9_6
#: func.xml:17619(literal)
msgid "backup_start_location"
msgstr "backup_start_location"

#. +> REL9_6_3 REL9_6
#: func.xml:17624(literal)
msgid "backup_end_location"
msgstr "backup_end_location"

#. +> REL9_6_3 REL9_6
#: func.xml:17765(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-signal-table\"/> send "
"control signals to other server processes. Use of these functions is "
"restricted to superusers by default but access may be granted to others with "
"the <command>GRANT</command>, with noted exceptions."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-signal-"
"table\"/>, позволяют передавать управляющие сигналы другим серверным "
"процессам. Вызывать эти функции по умолчанию разрешено только "
"суперпользователям, но доступ к ним можно дать и другим пользователям "
"командой <command>GRANT</command>, кроме явно отмеченных исключений."

#. +> REL9_6_3 REL9_6
#: func.xml:17866(indexterm)
msgid "<primary>pg_current_xlog_flush_location</primary>"
msgstr "<primary>pg_current_xlog_flush_location</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:17869(indexterm)
msgid "<primary>pg_current_xlog_insert_location</primary>"
msgstr "<primary>pg_current_xlog_insert_location</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:17872(indexterm)
msgid "<primary>pg_current_xlog_location</primary>"
msgstr "<primary>pg_current_xlog_location</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:17887(indexterm)
msgid "<primary>pg_switch_xlog</primary>"
msgstr "<primary>pg_switch_xlog</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:17890(indexterm)
msgid "<primary>pg_xlogfile_name</primary>"
msgstr "<primary>pg_xlogfile_name</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:17896(indexterm)
msgid "<primary>pg_xlog_location_diff</primary>"
msgstr "<primary>pg_xlog_location_diff</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:17900(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-backup-table\"/> "
"assist in making on-line backups. These functions cannot be executed during "
"recovery (except <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> and "
"<function>pg_xlog_location_diff</function>)."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-backup-"
"table\"/>, предназначены для выполнения резервного копирования &laquo;на "
"ходу&raquo;. Эти функции нельзя выполнять во время восстановления (за "
"исключением <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> и <function>pg_xlog_location_diff</"
"function>)."

#. +> REL9_6_3 REL9_6
#: func.xml:17926(function)
msgid "pg_current_xlog_flush_location()"
msgstr "pg_current_xlog_flush_location()"

#. +> REL9_6_3 REL9_6
#: func.xml:17929(entry)
msgid "Get current transaction log flush location"
msgstr "Получает текущую позицию сброса данных в журнале транзакций"

#. +> REL9_6_3 REL9_6
#: func.xml:17933(function)
msgid "pg_current_xlog_insert_location()"
msgstr "pg_current_xlog_insert_location()"

#. +> REL9_6_3 REL9_6
#: func.xml:17936(entry)
msgid "Get current transaction log insert location"
msgstr "Получает текущую позицию добавления в журнале транзакций"

#. +> REL9_6_3 REL9_6
#: func.xml:17940(function)
msgid "pg_current_xlog_location()"
msgstr "pg_current_xlog_location()"

#. +> REL9_6_3 REL9_6
#: func.xml:17943(entry)
msgid "Get current transaction log write location"
msgstr "Получает текущую позицию записи в журнале транзакций"

#. +> REL9_6_3 REL9_6
#: func.xml:17961(function)
msgid "pg_stop_backup(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_stop_backup(<placeholder-1/> <placeholder-2/>)"

#. +> REL9_6_3 REL9_6
#: func.xml:17982(function)
msgid "pg_switch_xlog()"
msgstr "pg_switch_xlog()"

#. +> REL9_6_3 REL9_6
#: func.xml:17985(entry)
msgid ""
"Force switch to a new transaction log file (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Инициирует переключение на новый файл журнала транзакций (по умолчанию "
"разрешено только суперпользователям, но право на её выполнение (EXECUTE) "
"можно дать и другим пользователям)"

#. +> REL9_6_3 REL9_6
#: func.xml:17989(parameter) func.xml:17996(parameter)
#: func.xml:18003(parameter)
msgid "location"
msgstr "location"

#. +> REL9_6_3 REL9_6
#: func.xml:17989(function)
msgid "pg_xlogfile_name(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_xlogfile_name(<placeholder-1/> <placeholder-2/>)"

#. +> REL9_6_3 REL9_6
#: func.xml:17992(entry)
msgid "Convert transaction log location string to file name"
msgstr ""
"Получает из строки позиции в журнале транзакций имя соответствующего файла"

#. +> REL9_6_3 REL9_6
#: func.xml:17996(function)
msgid "pg_xlogfile_name_offset(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_xlogfile_name_offset(<placeholder-1/> <placeholder-2/>)"

#. +> REL9_6_3 REL9_6
#: func.xml:17999(entry)
msgid ""
"Convert transaction log location string to file name and decimal byte offset "
"within file"
msgstr ""
"Получает из строки позиции в журнале транзакций имя соответствующего файла и "
"десятичное смещение в нём"

#. +> REL9_6_3 REL9_6
#: func.xml:18003(function)
msgid ""
"pg_xlog_location_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_xlog_location_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#. +> REL9_6_3 REL9_6
#: func.xml:18006(entry)
msgid "Calculate the difference between two transaction log locations"
msgstr "Вычисляет разницу между двумя позициями в журнале транзакций"

#. +> REL9_6_3 REL9_6
#: func.xml:18012(para)
msgid ""
"<function>pg_start_backup</function> accepts an arbitrary user-defined label "
"for the backup. (Typically this would be the name under which the backup "
"dump file will be stored.) When used in exclusive mode, the function writes "
"a backup label file (<filename>backup_label</filename>) and, if there are "
"any links in the <filename>pg_tblspc/</filename> directory, a tablespace map "
"file (<filename>tablespace_map</filename>) into the database cluster's data "
"directory, performs a checkpoint, and then returns the backup's starting "
"transaction log location as text. The user can ignore this result value, but "
"it is provided in case it is useful. When used in non-exclusive mode, the "
"contents of these files are instead returned by the "
"<function>pg_stop_backup</function> function, and should be written to the "
"backup by the caller. <placeholder-1/> There is an optional second parameter "
"of type <type>boolean</type>. If <literal>true</literal>, it specifies "
"executing <function>pg_start_backup</function> as quickly as possible. This "
"forces an immediate checkpoint which will cause a spike in I/O operations, "
"slowing any concurrently executing queries."
msgstr ""
"<function>pg_start_backup</function> принимает произвольную заданную "
"пользователем метку резервной копии. (Обычно это имя файла, в котором будет "
"сохранена резервная копия.) При копировании в монопольном режиме эта функция "
"записывает файл метки (<filename>backup_label</filename>) и, если есть "
"ссылки в каталоге <filename>pg_tblspc/</filename>, файл карты табличных "
"пространств (<filename>tablespace_map</filename>) в каталог данных кластера "
"БД, выполняет процедуру контрольной точки, а затем возвращает в текстовом "
"виде начальную позицию в журнале транзакций для данной резервной копии. "
"Результат этой функции может быть полезен, но если он не нужен, его можно "
"просто игнорировать. При копировании в немонопольном режиме содержимое этих "
"файлов выдаётся функцией <function>pg_stop_backup</function> и должно быть "
"записано в архивную копию вызывающим субъектом. <placeholder-1/> У этой "
"функции есть также второй, необязательный параметр типа <type>boolean</"
"type>. Если он равен <literal>true</literal>, <function>pg_start_backup</"
"function> начнёт работу максимально быстро. При этом будет немедленно "
"выполнена процедура контрольной точки, что может повлечь массу операций "
"ввода/вывода и затормозить параллельные запросы."

#. +> REL9_6_3 REL9_6
#: func.xml:18039(para)
msgid ""
"In an exclusive backup, <function>pg_stop_backup</function> removes the "
"label file and, if it exists, the <filename>tablespace_map</filename> file "
"created by <function>pg_start_backup</function>. In a non-exclusive backup, "
"the contents of the <filename>backup_label</filename> and "
"<filename>tablespace_map</filename> are returned in the result of the "
"function, and should be written to files in the backup (and not in the data "
"directory)."
msgstr ""
"При монопольном копировании функция <function>pg_stop_backup</function> "
"удаляет файл метки (и, если существует, файл <filename>tablespace_map</"
"filename>), созданный функцией <function>pg_start_backup</function>. При "
"немонопольном копировании содержимое <filename>backup_label</filename> и "
"<filename>tablespace_map</filename> возвращается в результате функции, и "
"должно быть записано в файлы в архиве (а не в каталоге данных)."

#. +> REL9_6_3 REL9_6
#: func.xml:18048(para)
msgid ""
"The function also creates a backup history file in the transaction log "
"archive area. The history file includes the label given to "
"<function>pg_start_backup</function>, the starting and ending transaction "
"log locations for the backup, and the starting and ending times of the "
"backup. The return value is the backup's ending transaction log location "
"(which again can be ignored). After recording the ending location, the "
"current transaction log insertion point is automatically advanced to the "
"next transaction log file, so that the ending transaction log file can be "
"archived immediately to complete the backup."
msgstr ""
"Эта функция также создаёт файл истории резервного копирования в области "
"архива журнала транзакций. В этом файле для данной резервной копии "
"сохраняется метка, заданная при вызове <function>pg_start_backup</function>, "
"начальная и конечная позиция в журнале транзакций, а также время начала и "
"окончания. Возвращает данная функция позицию окончания резервной копии в "
"журнале транзакций (которую тоже можно игнорировать). После записи конечной "
"позиции текущая позиция записи автоматически перемещается к следующему файлу "
"журнала транзакций, чтобы файл конечной позиции можно было немедленно "
"архивировать для завершения резервного копирования."

#. +> REL9_6_3 REL9_6
#: func.xml:18060(para)
msgid ""
"<function>pg_switch_xlog</function> moves to the next transaction log file, "
"allowing the current file to be archived (assuming you are using continuous "
"archiving). The return value is the ending transaction log location + 1 "
"within the just-completed transaction log file. If there has been no "
"transaction log activity since the last transaction log switch, "
"<function>pg_switch_xlog</function> does nothing and returns the start "
"location of the transaction log file currently in use."
msgstr ""
"<function>pg_switch_xlog</function> производит переключение на следующий "
"файл журнала транзакций, что позволяет архивировать текущий (в ситуации, "
"когда архивация выполняется непрерывно). Эта функция возвращает конечную "
"позицию + 1 в только что законченном файле журнала транзакций. Если с "
"момента последнего переключения файлов не было активности, отражающейся в "
"журнале транзакций, <function>pg_switch_xlog</function> ничего не делает и "
"возвращает начальную позицию в файле журнала транзакций, используемом в "
"данный момент."

#. +> REL9_6_3 REL9_6
#: func.xml:18069(para)
msgid ""
"<function>pg_create_restore_point</function> creates a named transaction log "
"record that can be used as recovery target, and returns the corresponding "
"transaction log location. The given name can then be used with <xref linkend="
"\"recovery-target-name\"/> to specify the point up to which recovery will "
"proceed. Avoid creating multiple restore points with the same name, since "
"recovery will stop at the first one whose name matches the recovery target."
msgstr ""
"<function>pg_create_restore_point</function> создаёт именованную запись в "
"журнале транзакций, которую можно использовать как цель при восстановлении, "
"и возвращает соответствующую позицию в журнале транзакций. Затем полученное "
"имя можно присвоить параметру <xref linkend=\"recovery-target-name\"/>, "
"указав тем самым точку, до которой будет выполняться восстановление. Учтите, "
"что если вы создадите несколько точек восстановления с одним именем, "
"восстановление будет остановлено на первой точке с этим именем."

#. +> REL9_6_3 REL9_6
#: func.xml:18079(para)
msgid ""
"<function>pg_current_xlog_location</function> displays the current "
"transaction log write location in the same format used by the above "
"functions. Similarly, <function>pg_current_xlog_insert_location</function> "
"displays the current transaction log insertion point and "
"<function>pg_current_xlog_flush_location</function> displays the current "
"transaction log flush point. The insertion point is the <quote>logical</"
"quote> end of the transaction log at any instant, while the write location "
"is the end of what has actually been written out from the server's internal "
"buffers and flush location is the location guaranteed to be written to "
"durable storage. The write location is the end of what can be examined from "
"outside the server, and is usually what you want if you are interested in "
"archiving partially-complete transaction log files. The insertion and flush "
"points are made available primarily for server debugging purposes. These are "
"both read-only operations and do not require superuser permissions."
msgstr ""
"<function>pg_current_xlog_location</function> выводит текущую позицию записи "
"в журнале транзакций в том же формате, что и вышеописанные функции. "
"<function>pg_current_xlog_insert_location</function> подобным образом "
"выводит текущую позицию добавления, а "
"<function>pg_current_xlog_flush_location</function> — позицию сброса данных "
"журнала. Позицией добавления называется <quote>логический</quote> конец "
"журнала транзакций в любой момент времени, тогда как позиция записи "
"указывает на конец данных, фактически вынесённых из внутренних буферов "
"сервера, а позиция сброса показывает, до какого места данные гарантированно "
"сохранены в надёжном хранилище. Позиция записи отмечает конец данных, "
"которые может видеть снаружи внешний процесс, и именно она представляет "
"интерес при копировании частично заполненных файлов журнала транзакций. "
"Позиция добавления и позиция сброса выводятся в основном для отладки "
"серверной части. Все эти операции выполняются в режиме &laquo;только "
"чтение&raquo; и не требуют прав суперпользователя."

#. +> REL9_6_3 REL9_6
#: func.xml:18099(programlisting)
#, no-wrap
msgid ""
"postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"
msgstr ""
"postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"

#. +> REL9_6_3 REL9_6
#: func.xml:18095(para)
msgid ""
"You can use <function>pg_xlogfile_name_offset</function> to extract the "
"corresponding transaction log file name and byte offset from the results of "
"any of the above functions. For example: <placeholder-1/> Similarly, "
"<function>pg_xlogfile_name</function> extracts just the transaction log file "
"name. When the given transaction log location is exactly at a transaction "
"log file boundary, both these functions return the name of the preceding "
"transaction log file. This is usually the desired behavior for managing "
"transaction log archiving behavior, since the preceding file is the last one "
"that currently needs to be archived."
msgstr ""
"Из результатов всех описанных выше функций можно получить соответствующее "
"имя файла журнала транзакций и смещение в нём, используя функцию "
"<function>pg_xlogfile_name_offset</function>. Например: <placeholder-1/> "
"Подобная ей функция <function>pg_xlogfile_name</function> извлекает только "
"имя файла журнала транзакций. Когда позиция в журнале транзакций находится "
"ровно на границе файлов, обе эти функции возвращают имя предыдущего файла. "
"Обычно это поведение предпочтительно при архивировании журнала, так как "
"именно предыдущий файл является последним подлежащим архивации."

#. +> REL9_6_3 REL9_6
#: func.xml:18114(para)
msgid ""
"<function>pg_xlog_location_diff</function> calculates the difference in "
"bytes between two transaction log locations. It can be used with "
"<structname>pg_stat_replication</structname> or some functions shown in "
"<xref linkend=\"functions-admin-backup-table\"/> to get the replication lag."
msgstr ""
"<function>pg_xlog_location_diff</function> вычисляет разницу в байтах между "
"двумя позициями в журнале транзакций. Полученный результат можно "
"использовать с <structname>pg_stat_replication</structname> или другими "
"функциями, перечисленными в <xref remap=\"6\" linkend=\"functions-admin-"
"backup-table\"/>, для определения задержки репликации."

#. +> REL9_6_3 REL9_6
#: func.xml:18134(indexterm)
msgid "<primary>pg_last_xlog_receive_location</primary>"
msgstr "<primary>pg_last_xlog_receive_location</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:18137(indexterm)
msgid "<primary>pg_last_xlog_replay_location</primary>"
msgstr "<primary>pg_last_xlog_replay_location</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:18170(function)
msgid "pg_last_xlog_receive_location()"
msgstr "pg_last_xlog_receive_location()"

#. +> REL9_6_3 REL9_6
#: func.xml:18173(entry)
msgid ""
"Get last transaction log location received and synced to disk by streaming "
"replication. While streaming replication is in progress this will increase "
"monotonically. If recovery has completed this will remain static at the "
"value of the last WAL record received and synced to disk during recovery. If "
"streaming replication is disabled, or if it has not yet started, the "
"function returns NULL."
msgstr ""
"Получает позицию последней записи журнала транзакций, полученной и "
"записанной на диск в процессе потоковой репликации. Пока выполняется "
"потоковая репликация, эта позиция постоянно увеличивается. По окончании "
"восстановления она останавливается на записи WAL, полученной и записанной на "
"диск последней. Если потоковая репликация отключена или ещё не запускалась, "
"функция возвращает NULL."

#. +> REL9_6_3 REL9_6
#: func.xml:18184(function)
msgid "pg_last_xlog_replay_location()"
msgstr "pg_last_xlog_replay_location()"

#. +> REL9_6_3 REL9_6
#: func.xml:18187(entry)
msgid ""
"Get last transaction log location replayed during recovery. If recovery is "
"still in progress this will increase monotonically. If recovery has "
"completed then this value will remain static at the value of the last WAL "
"record applied during that recovery. When the server has been started "
"normally without recovery the function returns NULL."
msgstr ""
"Получает позицию последней записи журнала транзакций, воспроизведённой при "
"восстановлении. В процессе восстановления эта позиция постоянно "
"увеличивается. По окончании восстановления она останавливается на записи "
"WAL, которая была восстановлена последней. Если сервер был запущен не в "
"режиме восстановления, эта функция возвращает NULL."

#. +> REL9_6_3 REL9_6
#: func.xml:18215(indexterm)
msgid "<primary>pg_is_xlog_replay_paused</primary>"
msgstr "<primary>pg_is_xlog_replay_paused</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:18218(indexterm)
msgid "<primary>pg_xlog_replay_pause</primary>"
msgstr "<primary>pg_xlog_replay_pause</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:18221(indexterm)
msgid "<primary>pg_xlog_replay_resume</primary>"
msgstr "<primary>pg_xlog_replay_resume</primary>"

#. +> REL9_6_3 REL9_6
#: func.xml:18242(function)
msgid "pg_is_xlog_replay_paused()"
msgstr "pg_is_xlog_replay_paused()"

#. +> REL9_6_3 REL9_6
#: func.xml:18250(function)
msgid "pg_xlog_replay_pause()"
msgstr "pg_xlog_replay_pause()"

#. +> REL9_6_3 REL9_6
#: func.xml:18258(function)
msgid "pg_xlog_replay_resume()"
msgstr "pg_xlog_replay_resume()"

#. +> REL9_6_3 REL9_6
#: func.xml:18406(entry) func.xml:18446(entry)
msgid ""
"(<parameter>slot_name</parameter> <type>name</type>, "
"<parameter>xlog_position</parameter> <type>pg_lsn</type>)"
msgstr ""
"(<parameter>slot_name</parameter> <type>name</type>, "
"<parameter>xlog_position</parameter> <type>pg_lsn</type>)"

#. +> REL9_6_3 REL9_6
#: func.xml:18409(entry)
msgid ""
"Creates a new physical replication slot named <parameter>slot_name</"
"parameter>. The optional second parameter, when <literal>true</literal>, "
"specifies that the <acronym>LSN</acronym> for this replication slot be "
"reserved immediately; otherwise the <acronym>LSN</acronym> is reserved on "
"first connection from a streaming replication client. Streaming changes from "
"a physical slot is only possible with the streaming-replication protocol "
"&mdash; see <xref linkend=\"protocol-replication\"/>. This function "
"corresponds to the replication protocol command "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."
msgstr ""
"Создаёт новый физический слот репликации с именем <parameter>slot_name</"
"parameter>. Необязательный второй параметр, когда он равен <literal>true</"
"literal>, указывает, что <acronym>LSN</acronym> для этого слота репликации "
"должен быть зарезервирован немедленно; в противном случае <acronym>LSN</"
"acronym> резервируется при первом подключении клиента потоковой репликации. "
"Передача изменений из физического слота возможна только по протоколу "
"потоковой репликации &mdash; см. <xref remap=\"4\" linkend=\"protocol-"
"replication\"/>. Эта функция соответствует команде протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."

#. +> REL9_6_3 REL9_6
#: func.xml:18432(entry)
msgid ""
"Drops the physical or logical replication slot named <parameter>slot_name</"
"parameter>. Same as replication protocol command "
"<literal>DROP_REPLICATION_SLOT</literal>."
msgstr ""
"Удаляет физический или логический слот репликации с именем "
"<parameter>slot_name</parameter>. Соответствует команде протокола репликации "
"<literal>DROP_REPLICATION_SLOT</literal>."

#. +> REL9_6_3 REL9_6
#: func.xml:18444(function)
msgid ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#. +> REL9_6_3 REL9_6
#: func.xml:18449(entry)
msgid ""
"Creates a new logical (decoding) replication slot named "
"<parameter>slot_name</parameter> using the output plugin <parameter>plugin</"
"parameter>. A call to this function has the same effect as the replication "
"protocol command <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>."
msgstr ""
"Создаёт новый логический (декодирующий) слот репликации с именем "
"<parameter>slot_name</parameter>, используя модуль вывода <parameter>plugin</"
"parameter>. Эта функция работает так же, как и команда протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>."

#. +> REL9_6_3 REL9_6
#: func.xml:18465(entry)
msgid ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"
msgstr ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"

#. +> REL9_6_3 REL9_6
#: func.xml:18490(entry)
msgid ""
"(<parameter>location</parameter> <type>text</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"
msgstr ""
"(<parameter>location</parameter> <type>text</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"

#. +> REL9_6_3 REL9_6
#: func.xml:18644(entry)
msgid ""
"Return the replay position for the replication origin configured in the "
"current session. The parameter <parameter>flush</parameter> determines "
"whether the corresponding local transaction will be guaranteed to have been "
"flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для источника репликации, настроенного в "
"текущем сеансе. Параметр <parameter>flush</parameter> определяет, будет ли "
"гарантироваться сохранение локальной транзакции на диске."

#. +> REL9_6_3 REL9_6
#: func.xml:18692(parameter)
msgid "pos"
msgstr "pos"

#. +> REL9_6_3 REL9_6
#: func.xml:18697(entry)
msgid ""
"Set replication progress for the given node to the given position. This "
"primarily is useful for setting up the initial position or a new position "
"after configuration changes and similar. Be aware that careless use of this "
"function can lead to inconsistently replicated data."
msgstr ""
"Устанавливает положение репликации для заданного узла в указанную позицию. "
"Это в основном полезно для установки начальной позиции или новой позиции "
"после изменения конфигурации и подобных действий. Но учтите, что "
"неосторожное использование этой функции может привести к несогласованности "
"реплицированных данных."

#. +> REL9_6_3 REL9_6
#: func.xml:18716(entry)
msgid ""
"Return the replay position for the given replication origin. The parameter "
"<parameter>flush</parameter> determines whether the corresponding local "
"transaction will be guaranteed to have been flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для заданного источника репликации. "
"Параметр <parameter>flush</parameter> определяет, будет ли гарантироваться "
"сохранение локальной транзакции на диске."

#. +> REL9_6_3 REL9_6
#: func.xml:18957(para)
msgid ""
"<function>pg_database_size</function> and <function>pg_tablespace_size</"
"function> accept the OID or name of a database or tablespace, and return the "
"total disk space used therein. To use <function>pg_database_size</function>, "
"you must have <literal>CONNECT</literal> permission on the specified "
"database (which is granted by default). To use <function>pg_tablespace_size</"
"function>, you must have <literal>CREATE</literal> permission on the "
"specified tablespace, unless it is the default tablespace for the current "
"database."
msgstr ""
"<function>pg_database_size</function> и <function>pg_tablespace_size</"
"function> принимают OID или имя базы данных либо табличного пространства и "
"возвращают общий объём, который они занимают на диске. Для использования "
"<function>pg_database_size</function> требуется право <literal>CONNECT</"
"literal> для указанной базы данных (оно имеется по умолчанию). Для "
"использования <function>pg_tablespace_size</function> необходимо иметь право "
"<literal>CREATE</literal> в указанном табличном пространстве, если только "
"это не табличное пространство по умолчанию для текущей базы данных."

#. +> REL9_6_3 REL9_6
#: func.xml:19171(para)
msgid ""
"<function>brin_summarize_new_values</function> accepts the OID or name of a "
"BRIN index and inspects the index to find page ranges in the base table that "
"are not currently summarized by the index; for any such range it creates a "
"new summary index tuple by scanning the table pages. It returns the number "
"of new page range summaries that were inserted into the index."
msgstr ""
"Функция <function>brin_summarize_new_values</function> принимает OID или имя "
"индекса BRIN и просматривает индекс в поисках зон страниц в базовой таблице, "
"ещё не обобщённых в индексе; для каждой такой зоны в результате сканирования "
"страниц таблицы создаётся новый обобщающий кортеж в индексе. Возвращает эта "
"функция число вставленных в индекс обобщающих записей о зонах страниц."

#. +> REL9_6_3 REL9_6
#: func.xml:19197(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-genfile-table\"/> "
"provide native access to files on the machine hosting the server. Only files "
"within the database cluster directory and the <varname>log_directory</"
"varname> can be accessed. Use a relative path for files in the cluster "
"directory, and a path matching the <varname>log_directory</varname> "
"configuration setting for log files. Use of these functions is restricted to "
"superusers."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-genfile-"
"table\"/>, предоставляют прямой доступ к файлам, находящимся на сервере. Они "
"позволяют обращаться только к файлам в каталоге кластера баз данных (по "
"относительному пути) или в каталоге <varname>log_directory</varname> (по "
"пути, заданному в параметре конфигурации <varname>log_directory</varname>). "
"Использовать эти функции могут только суперпользователи."

#. +> REL9_6_3 REL9_6
#: func.xml:19256(para)
msgid ""
"All of these functions take an optional <parameter>missing_ok</parameter> "
"parameter, which specifies the behavior when the file or directory does not "
"exist. If <literal>true</literal>, the function returns NULL (except "
"<function>pg_ls_dir</function>, which returns an empty result set). If "
"<literal>false</literal>, an error is raised. The default is <literal>false</"
"literal>."
msgstr ""
"Все эти функции принимают необязательный параметр <parameter>missing_ok</"
"parameter>, который определяет их поведение в случае отсутствия файла или "
"каталога. Если он равен <literal>true</literal>, функция возвращает NULL (за "
"исключением <function>pg_ls_dir</function>, которая возвращает пустое "
"множество). Если он равен <literal>false</literal>, возникает ошибка. "
"Значение по умолчанию — <literal>false</literal>."

#~ msgid "if_not_exists"
#~ msgstr "if_not_exists"

#~ msgid ""
#~ "pg_import_system_collations(<placeholder-1/> <placeholder-2/>, "
#~ "<placeholder-3/> <placeholder-4/>)"
#~ msgstr ""
#~ "pg_import_system_collations(<placeholder-1/> <placeholder-2/>, "
#~ "<placeholder-3/> <placeholder-4/>)"

#~ msgid "upper case time-zone name"
#~ msgstr "название часового пояса в верхнем регистре"

#~ msgid "lower case time-zone name"
#~ msgstr "название часового пояса в нижнем регистре"

#~ msgid "time-zone offset"
#~ msgstr "смещение часового пояса"

#~ msgid ""
#~ "Remove the longest string containing only the <parameter>characters</"
#~ "parameter> (a space by default) from the start/end/both ends of the "
#~ "<parameter>string</parameter>"
#~ msgstr ""
#~ "Удаляет наибольшую подстроку, содержащую только символы "
#~ "<parameter>characters</parameter> (по умолчанию пробелы), с начала, с "
#~ "конца или с обеих сторон строки <parameter>string</parameter>"

#~ msgid ", characters"
#~ msgstr ", characters"

#~ msgid ""
#~ "trim(<placeholder-1/> <placeholder-2/> <placeholder-3/> "
#~ "<optional><placeholder-4/></optional> )"
#~ msgstr ""
#~ "trim(<placeholder-1/> <placeholder-2/> <placeholder-3/> "
#~ "<optional><placeholder-4/></optional> )"

#~ msgid ""
#~ "Remove the longest string consisting only of bytes in <parameter>bytes</"
#~ "parameter> from the start and end of <parameter>string</parameter>"
#~ msgstr ""
#~ "Удаляет наибольшую подстроку, состоящую только из байт <parameter>bytes</"
#~ "parameter>, с начала и с конца строки <parameter>string</parameter>"

#~ msgid "<primary>median</primary>"
#~ msgstr "<primary>медиана</primary>"

#~ msgctxt "entry"
#~ msgid "void"
#~ msgstr "void"

#~ msgid ""
#~ "trim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>\n"
#~ "        <optional><placeholder-4/></optional> )"
#~ msgstr ""
#~ "trim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>\n"
#~ "        <optional><placeholder-4/></optional> )"

#~ msgid ""
#~ "btrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"
#~ msgstr ""
#~ "btrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"

#~ msgid ""
#~ "ltrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"
#~ msgstr ""
#~ "ltrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"

#~ msgid ""
#~ "rtrim(<placeholder-1/> <placeholder-2/>\n"
#~ "         <placeholder-3/>)"
#~ msgstr ""
#~ "rtrim(<placeholder-1/> <placeholder-2/>\n"
#~ "         <placeholder-3/>)"

#~ msgid ""
#~ "trim(<placeholder-1/>\n"
#~ "        <placeholder-2/> from <placeholder-3/>)"
#~ msgstr ""
#~ "trim(<placeholder-1/>\n"
#~ "        <placeholder-2/> from <placeholder-3/>)"

#~ msgid ""
#~ "btrim(<placeholder-1/>\n"
#~ "        <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
#~ msgstr ""
#~ "btrim(<placeholder-1/>\n"
#~ "        <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#~ msgid "'fat' 'cat' 'rat'"
#~ msgstr "'fat' 'cat' 'rat'"

#~ msgid "replace target with substitute within query"
#~ msgstr "заменяет целевой подзапрос подстановкой"
