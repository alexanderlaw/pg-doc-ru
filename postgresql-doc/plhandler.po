# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: plhandler.xml:5(title)
msgid "Writing A Procedural Language Handler"
msgstr "Написание обработчика процедурного языка"

#: plhandler.xml:7(indexterm)
msgid ""
"<primary>procedural language</primary> <secondary>handler for</secondary>"
msgstr "<primary>процедурный язык</primary> <secondary>обработчик</secondary>"

#: plhandler.xml:12(para)
msgid ""
"All calls to functions that are written in a language other than the current "
"<quote>version 1</quote> interface for compiled languages (this includes "
"functions in user-defined procedural languages, functions written in SQL, "
"and functions using the version 0 compiled language interface) go through a "
"<firstterm>call handler</firstterm> function for the specific language. It "
"is the responsibility of the call handler to execute the function in a "
"meaningful way, such as by interpreting the supplied source text. This "
"chapter outlines how a new procedural language's call handler can be written."
msgstr ""
"Все функции, написанные на языке, вызываемом не через текущий интерфейс "
"<quote>версии 1</quote> для компилируемых языков (а именно, это функции на "
"процедурных языках, функции, написанные на SQL, и функции, использующие "
"интерфейс компилируемых языков версии 0) выполняются через "
"<firstterm>обработчик вызова</firstterm> для заданного языка. Задача такого "
"обработчика вызова — выполнить функцию должным образом, например, "
"интерпретируя для этого её исходный текст. В этой главе в общих чертах "
"рассказывается, как можно написать обработчик нового процедурного языка."

#: plhandler.xml:24(para)
msgid ""
"The call handler for a procedural language is a <quote>normal</quote> "
"function that must be written in a compiled language such as C, using the "
"version-1 interface, and registered with <productname>PostgreSQL</"
"productname> as taking no arguments and returning the type "
"<type>language_handler</type>. This special pseudotype identifies the "
"function as a call handler and prevents it from being called directly in SQL "
"commands. For more details on C language calling conventions and dynamic "
"loading, see <xref linkend=\"xfunc-c\"/>."
msgstr ""
"Обработчик вызова процедурного языка — это <quote>обычная </quote> функция, "
"которая разрабатывается на компилируемом языке, таком как C, вызывается "
"через интерфейс версии 1, и регистрируется в <productname>PostgreSQL</"
"productname> как не принимающая аргументы и возвращающая тип "
"<type>language_handler</type>. Этот специальный псевдотип помечает функцию "
"как обработчик вызова и препятствует её вызову непосредственно из команд "
"SQL. Более подробно соглашение о вызовах и динамическая загрузка кода на C "
"описывается в <xref remap=\"6\" linkend=\"xfunc-c\"/>."

#: plhandler.xml:36(para)
msgid ""
"The call handler is called in the same way as any other function: It "
"receives a pointer to a <structname>FunctionCallInfoData</structname> "
"<type>struct</type> containing argument values and information about the "
"called function, and it is expected to return a <type>Datum</type> result "
"(and possibly set the <structfield>isnull</structfield> field of the "
"<structname>FunctionCallInfoData</structname> structure, if it wishes to "
"return an SQL null result). The difference between a call handler and an "
"ordinary callee function is that the <structfield>flinfo-&gt;fn_oid</"
"structfield> field of the <structname>FunctionCallInfoData</structname> "
"structure will contain the OID of the actual function to be called, not of "
"the call handler itself. The call handler must use this field to determine "
"which function to execute. Also, the passed argument list has been set up "
"according to the declaration of the target function, not of the call handler."
msgstr ""
"Обработчик вызова вызывается так же, как и любая другая функция: он получает "
"указатель на переменную <type>struct</type> "
"<structname>FunctionCallInfoData</structname>, содержащую значения "
"аргументов и информацию о вызываемой функции, и должен вернуть результат "
"типа <type>Datum</type> (и, возможно, установить признак "
"<structfield>isnull</structfield> в структуре "
"<structname>FunctionCallInfoData</structname>, если нужно вернуть результат "
"SQL NULL). Отличие обработчика вызова от обычной вызываемой функцией состоит "
"в том, что поле <structfield>flinfo-&gt;fn_oid</structfield> структуры "
"<structname>FunctionCallInfoData</structname> для него будет содержать OID "
"вызываемой функции, а не самого обработчика. По этому OID обработчик вызова "
"должен понять, какую функцию вызывать. Кроме того, список передаваемых "
"аргументов для него формируется в соответствии с объявлением целевой "
"функции, а не обработчика вызова."

#: plhandler.xml:55(para)
msgid ""
"It's up to the call handler to fetch the entry of the function from the "
"<classname>pg_proc</classname> system catalog and to analyze the argument "
"and return types of the called function. The <literal>AS</literal> clause "
"from the <command>CREATE FUNCTION</command> command for the function will be "
"found in the <literal>prosrc</literal> column of the <classname>pg_proc</"
"classname> row. This is commonly source text in the procedural language, but "
"in theory it could be something else, such as a path name to a file, or "
"anything else that tells the call handler what to do in detail."
msgstr ""
"Обработчик вызова сам должен выбрать запись функции из системного каталога "
"<classname>pg_proc</classname> и проанализировать типы аргументов и "
"результата вызываемой функции. Содержимое предложения <literal>AS</literal> "
"команды <command>CREATE FUNCTION</command> для этой функции будет находиться "
"в столбце <literal>prosrc</literal> строки в <classname>pg_proc</classname>. "
"Обычно это исходный текст на процедурном языке, но в принципе это может быть "
"и что-то другое, например, путь к файлу или иные данные, говорящие "
"обработчику вызова, что именно делать."

#: plhandler.xml:67(para)
msgid ""
"Often, the same function is called many times per SQL statement. A call "
"handler can avoid repeated lookups of information about the called function "
"by using the <structfield>flinfo-&gt;fn_extra</structfield> field. This will "
"initially be <symbol>NULL</symbol>, but can be set by the call handler to "
"point at information about the called function. On subsequent calls, if "
"<structfield>flinfo-&gt;fn_extra</structfield> is already non-<symbol>NULL</"
"symbol> then it can be used and the information lookup step skipped. The "
"call handler must make sure that <structfield>flinfo-&gt;fn_extra</"
"structfield> is made to point at memory that will live at least until the "
"end of the current query, since an <structname>FmgrInfo</structname> data "
"structure could be kept that long. One way to do this is to allocate the "
"extra data in the memory context specified by <structfield>flinfo-&gt;"
"fn_mcxt</structfield>; such data will normally have the same lifespan as the "
"<structname>FmgrInfo</structname> itself. But the handler could also choose "
"to use a longer-lived memory context so that it can cache function "
"definition information across queries."
msgstr ""
"Часто функция многократно вызывается в одном SQL-операторе. Чтобы в таких "
"случаях избежать повторных обращений за информацией о вызываемой функции, "
"обработчик вызова может воспользоваться полем <structfield>flinfo-&gt;"
"fn_extra</structfield>. Изначально оно содержит <symbol>NULL</symbol>, но "
"обработчик вызова может поместить в него указатель на требуемую информацию. "
"При последующих вызовах, если поле <structfield>flinfo-&gt;fn_extra</"
"structfield> будет отлично от <symbol>NULL</symbol>, им можно "
"воспользоваться и пропустить шаг получения этой информации. Обработчик "
"вызова должен позаботиться о том, чтобы указатель в <structfield>flinfo-&gt;"
"fn_extra</structfield> указывал на блок памяти, который не будет освобождён "
"раньше, чем завершится запрос (именно столько может существовать структура "
"<structname>FmgrInfo</structname>). В качестве одного из вариантов, этого "
"можно добиться, разместив дополнительные данные в контексте памяти, заданном "
"в <structfield>flinfo-&gt;fn_mcxt</structfield>; срок жизни таких данных "
"обычно совпадает со сроком жизни самой структуры <structname>FmgrInfo</"
"structname>. С другой стороны, обработчик может выбрать и более долгоживущий "
"контекст памяти с тем, чтобы кешировать определения функций и между "
"запросами."

#: plhandler.xml:89(para)
msgid ""
"When a procedural-language function is invoked as a trigger, no arguments "
"are passed in the usual way, but the <structname>FunctionCallInfoData</"
"structname>'s <structfield>context</structfield> field points at a "
"<structname>TriggerData</structname> structure, rather than being "
"<symbol>NULL</symbol> as it is in a plain function call. A language handler "
"should provide mechanisms for procedural-language functions to get at the "
"trigger information."
msgstr ""
"Когда функция на процедурном языке вызывается как триггер, ей не передаются "
"аргументы обычным способом; вместо этого поле <structfield>context</"
"structfield> в <structname>FunctionCallInfoData</structname> указывает на "
"структуру <structname>TriggerData</structname>, тогда как при обычном вызове "
"функции оно содержит <symbol>NULL</symbol>. Обработчик языка, в свою "
"очередь, должен каким-либо образом предоставить эту информацию функциям на "
"этом процедурном языке."

#: plhandler.xml:102(programlisting)
#, no-wrap
msgid ""
"#include \"postgres.h\"\n"
"#include \"executor/spi.h\"\n"
"#include \"commands/trigger.h\"\n"
"#include \"fmgr.h\"\n"
"#include \"access/heapam.h\"\n"
"#include \"utils/syscache.h\"\n"
"#include \"catalog/pg_proc.h\"\n"
"#include \"catalog/pg_type.h\"\n"
"\n"
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif\n"
"\n"
"PG_FUNCTION_INFO_V1(plsample_call_handler);\n"
"\n"
"Datum\n"
"plsample_call_handler(PG_FUNCTION_ARGS)\n"
"{\n"
"    Datum          retval;\n"
"\n"
"    if (CALLED_AS_TRIGGER(fcinfo))\n"
"    {\n"
"        /*\n"
"         * Called as a trigger procedure\n"
"         */\n"
"        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;\n"
"\n"
"        retval = ...\n"
"    }\n"
"    else\n"
"    {\n"
"        /*\n"
"         * Called as a function\n"
"         */\n"
"\n"
"        retval = ...\n"
"    }\n"
"\n"
"    return retval;\n"
"}"
msgstr ""
"#include \"postgres.h\"\n"
"#include \"executor/spi.h\"\n"
"#include \"commands/trigger.h\"\n"
"#include \"fmgr.h\"\n"
"#include \"access/heapam.h\"\n"
"#include \"utils/syscache.h\"\n"
"#include \"catalog/pg_proc.h\"\n"
"#include \"catalog/pg_type.h\"\n"
"\n"
"#ifdef PG_MODULE_MAGIC\n"
"PG_MODULE_MAGIC;\n"
"#endif\n"
"\n"
"PG_FUNCTION_INFO_V1(plsample_call_handler);\n"
"\n"
"Datum\n"
"plsample_call_handler(PG_FUNCTION_ARGS)\n"
"{\n"
"    Datum          retval;\n"
"\n"
"    if (CALLED_AS_TRIGGER(fcinfo))\n"
"    {\n"
"        /*\n"
"         * Вызывается как триггерная процедура\n"
"         */\n"
"        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;\n"
"\n"
"        retval = ...\n"
"    }\n"
"    else\n"
"    {\n"
"        /*\n"
"         * Вызывается как функция\n"
"         */\n"
"\n"
"        retval = ...\n"
"    }\n"
"\n"
"    return retval;\n"
"}"

#: plhandler.xml:100(para)
msgid ""
"This is a template for a procedural-language handler written in C: "
"<placeholder-1/> Only a few thousand lines of code have to be added instead "
"of the dots to complete the call handler."
msgstr ""
"Шаблон обработчика процедурного языка, написанный на C, выглядит так: "
"<placeholder-1/> Чтобы завершить код обработчика, нужно добавить лишь "
"несколько тысяч строк вместо многоточий."

#: plhandler.xml:152(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION plsample_call_handler() RETURNS language_handler\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C;\n"
"CREATE LANGUAGE plsample\n"
"    HANDLER plsample_call_handler;"
msgstr ""
"CREATE FUNCTION plsample_call_handler() RETURNS language_handler\n"
"    AS '<replaceable>имя_файла</replaceable>'\n"
"    LANGUAGE C;\n"
"CREATE LANGUAGE plsample\n"
"    HANDLER plsample_call_handler;"

#: plhandler.xml:148(para)
msgid ""
"After having compiled the handler function into a loadable module (see <xref "
"linkend=\"dfunc\"/>), the following commands then register the sample "
"procedural language: <placeholder-1/>"
msgstr ""
"Скомпилировав функцию-обработчик языка в загружаемый модуль (см. <xref remap="
"\"4\" linkend=\"dfunc\"/>), этот язык (plsample) можно зарегистрировать "
"следующими командами: <placeholder-1/>"

#: plhandler.xml:161(para)
msgid ""
"Although providing a call handler is sufficient to create a minimal "
"procedural language, there are two other functions that can optionally be "
"provided to make the language more convenient to use. These are a "
"<firstterm>validator</firstterm> and an <firstterm>inline handler</"
"firstterm>. A validator can be provided to allow language-specific checking "
"to be done during <xref linkend=\"sql-createfunction\"/>. An inline handler "
"can be provided to allow the language to support anonymous code blocks "
"executed via the <xref linkend=\"sql-do\"/> command."
msgstr ""
"Хотя обработчика вызова достаточно для создания простейшего процедурного "
"языка, есть ещё две функции, которые можно реализовать дополнительно, чтобы "
"пользоваться языком было удобнее: функция <firstterm>проверки</firstterm> и "
"<firstterm>обработчик внедрённого кода</firstterm>. Функцию проверки можно "
"реализовать, чтобы производить проверку синтаксиса языка во время <xref "
"linkend=\"sql-createfunction\"/>. Если же реализован обработчик внедрённого "
"кода, этот язык будет поддерживать выполнение анонимных блоков кода командой "
"<xref linkend=\"sql-do\"/>."

#: plhandler.xml:173(para)
msgid ""
"If a validator is provided by a procedural language, it must be declared as "
"a function taking a single parameter of type <type>oid</type>. The "
"validator's result is ignored, so it is customarily declared to return "
"<type>void</type>. The validator will be called at the end of a "
"<command>CREATE FUNCTION</command> command that has created or updated a "
"function written in the procedural language. The passed-in OID is the OID of "
"the function's <classname>pg_proc</classname> row. The validator must fetch "
"this row in the usual way, and do whatever checking is appropriate. First, "
"call <function>CheckFunctionValidatorAccess()</function> to diagnose "
"explicit calls to the validator that the user could not achieve through "
"<command>CREATE FUNCTION</command>. Typical checks then include verifying "
"that the function's argument and result types are supported by the language, "
"and that the function's body is syntactically correct in the language. If "
"the validator finds the function to be okay, it should just return. If it "
"finds an error, it should report that via the normal <function>ereport()</"
"function> error reporting mechanism. Throwing an error will force a "
"transaction rollback and thus prevent the incorrect function definition from "
"being committed."
msgstr ""
"Если для процедурного языка предоставляется функция проверки, она должна "
"быть объявлена как функция, принимающая один параметр типа <type>oid</type>. "
"Результат функции проверки игнорируется, так что она обычно объявляется как "
"возвращающая тип <type>void</type>. Эта функция будет вызываться в конце "
"выполнения команды <command>CREATE FUNCTION</command>, создающей или "
"изменяющей функцию, написанную на процедурном языке. Переданный ей OID "
"указывает на строку в <classname>pg_proc</classname> для этой функции. "
"Функция проверки должна выбрать эту строку обычным образом и произвести все "
"необходимые проверки. Прежде всего нужно вызвать "
"<function>CheckFunctionValidatorAccess()</function>, чтобы отличить явные "
"вызовы этой функции от происходящих при выполнении команды <command>CREATE "
"FUNCTION</command>. Затем обычно проверяется, например, что типы аргументов "
"и результата функции поддерживаются языком и что тело функции синтаксически "
"правильно для данного языка. Если функция проверки заключает, что всё в "
"порядке, она должна просто завершиться. Если же она обнаруживает ошибку, она "
"должна сообщить о ней через обычный механизм <function>ereport()</function>. "
"Выданная таким образом ошибка приведёт к откату транзакции, так что "
"определение некорректной функции зафиксировано не будет."

#: plhandler.xml:195(para)
msgid ""
"Validator functions should typically honor the <xref linkend=\"guc-check-"
"function-bodies\"/> parameter: if it is turned off then any expensive or "
"context-sensitive checking should be skipped. If the language provides for "
"code execution at compilation time, the validator must suppress checks that "
"would induce such execution. In particular, this parameter is turned off by "
"<application>pg_dump</application> so that it can load procedural language "
"functions without worrying about side effects or dependencies of the "
"function bodies on other database objects. (Because of this requirement, the "
"call handler should avoid assuming that the validator has fully checked the "
"function. The point of having a validator is not to let the call handler "
"omit checks, but to notify the user immediately if there are obvious errors "
"in a <command>CREATE FUNCTION</command> command.) While the choice of "
"exactly what to check is mostly left to the discretion of the validator "
"function, note that the core <command>CREATE FUNCTION</command> code only "
"executes <literal>SET</literal> clauses attached to a function when "
"<varname>check_function_bodies</varname> is on. Therefore, checks whose "
"results might be affected by GUC parameters definitely should be skipped "
"when <varname>check_function_bodies</varname> is off, to avoid false "
"failures when reloading a dump."
msgstr ""
"Функции проверки обычно должны учитывать параметр <xref linkend=\"guc-check-"
"function-bodies\"/>: если он отключён, то дорогостоящие или зависящие от "
"контекста проверки содержимого функции выполнять не следует. Если язык "
"подразумевает выполнение кода в процессе компиляции, проверяющая функция "
"должна избегать проверок, которые влекут за собой такое выполнение. В "
"частности, указанный параметр отключает утилита <application>pg_dump</"
"application>, чтобы она могла загружать функции на процедурных языках, не "
"заботясь о побочных эффектах или зависимостях содержимого функций от других "
"объектов базы. (Вследствие этого требования, обработчик языка не должен "
"полагать, что функция прошла полную проверку. Смысл существования функции "
"проверки не в том, чтобы убрать эти проверки из обработчика вызова, а в том, "
"чтобы немедленно уведомить пользователя об очевидных ошибках при выполнении "
"<command>CREATE FUNCTION</command>.) Хотя выбор, что именно должно "
"проверяться, по большому счёту остаётся за функцией проверки, заметьте, что "
"основной код <command>CREATE FUNCTION</command> выполняет присваивания "
"<literal>SET</literal>, связанные с функцией, только когда "
"<varname>check_function_bodies</varname> включён. Таким образом, проверки, "
"результаты которых могут зависеть от параметров GUC, определённо должны "
"опускаться, когда <varname>check_function_bodies</varname> отключён, во "
"избежание ложных ошибок при восстановлении базы из копии."

#: plhandler.xml:218(para)
msgid ""
"If an inline handler is provided by a procedural language, it must be "
"declared as a function taking a single parameter of type <type>internal</"
"type>. The inline handler's result is ignored, so it is customarily declared "
"to return <type>void</type>. The inline handler will be called when a "
"<command>DO</command> statement is executed specifying the procedural "
"language. The parameter actually passed is a pointer to an "
"<structname>InlineCodeBlock</structname> struct, which contains information "
"about the <command>DO</command> statement's parameters, in particular the "
"text of the anonymous code block to be executed. The inline handler should "
"execute this code and return."
msgstr ""
"Если для процедурного языка предоставляется обработчик встроенного кода, он "
"должен объявляться в виде функции, принимающей один параметр типа "
"<type>internal</type>. Результат такого обработчика игнорируется, поэтому "
"обычно он объявляется как возвращающий тип <type>void</type>. Обработчик "
"встроенного кода будет вызываться при выполнении оператора <command>DO</"
"command> с данным процедурным языком. В качестве параметра ему на самом деле "
"передаётся указатель на структуру <structname>InlineCodeBlock</structname>, "
"содержащую информацию о параметрах <command>DO</command>, в частности, текст "
"выполняемого анонимного блока внедрённого кода."

#: plhandler.xml:231(para)
msgid ""
"It's recommended that you wrap all these function declarations, as well as "
"the <command>CREATE LANGUAGE</command> command itself, into an "
"<firstterm>extension</firstterm> so that a simple <command>CREATE EXTENSION</"
"command> command is sufficient to install the language. See <xref linkend="
"\"extend-extensions\"/> for information about writing extensions."
msgstr ""
"Все подобные объявления функций, а также саму команду <command>CREATE "
"LANGUAGE</command>, рекомендуется упаковывать в <firstterm>расширение</"
"firstterm> так, чтобы для установки языка было достаточно простой команды "
"<command>CREATE EXTENSION</command>. За информацией о разработке расширений "
"обратитесь к <xref remap=\"3\" linkend=\"extend-extensions\"/>."

#: plhandler.xml:240(para)
msgid ""
"The procedural languages included in the standard distribution are good "
"references when trying to write your own language handler. Look into the "
"<filename>src/pl</filename> subdirectory of the source tree. The <xref "
"linkend=\"sql-createlanguage\"/> reference page also has some useful details."
msgstr ""
"Реализация процедурных языков, включённых в стандартный дистрибутив, может "
"послужить хорошим примером при написании собственных обработчиков языков. Её "
"вы можете найти в подкаталоге <filename>src/pl</filename> дерева исходного "
"кода. Некоторые полезные детали также можно узнать на странице справки <xref "
"linkend=\"sql-createlanguage\"/>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: plhandler.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
