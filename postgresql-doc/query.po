# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:14+0300\n"
"PO-Revision-Date: 2017-09-19 14:11+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:5(title)
msgid "The <acronym>SQL</acronym> Language"
msgstr "Язык <acronym>SQL</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:8(title)
msgid "Introduction"
msgstr "Введение"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:10(para)
msgid ""
"This chapter provides an overview of how to use <acronym>SQL</acronym> to "
"perform simple operations. This tutorial is only intended to give you an "
"introduction and is in no way a complete tutorial on <acronym>SQL</acronym>. "
"Numerous books have been written on <acronym>SQL</acronym>, including <xref "
"linkend=\"melt93\"/> and <xref linkend=\"date97\"/>. You should be aware "
"that some <productname>PostgreSQL</productname> language features are "
"extensions to the standard."
msgstr ""
"В этой главе рассматривается использование <acronym>SQL</acronym> для "
"выполнения простых операций. Она призвана только познакомить вас с "
"<acronym>SQL</acronym>, но ни в коей мере не претендует на исчерпывающее "
"руководство. Про <acronym>SQL</acronym> написано множество книг, включая "
"<xref linkend=\"melt93\"/> и <xref linkend=\"date97\"/>. При этом следует "
"учитывать, что некоторые возможности языка <productname>PostgreSQL</"
"productname> являются расширениями стандарта."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:21(para)
msgid ""
"In the examples that follow, we assume that you have created a database "
"named <literal>mydb</literal>, as described in the previous chapter, and "
"have been able to start <application>psql</application>."
msgstr ""
"В следующих примерах мы предполагаем, что вы создали базу данных "
"<literal>mydb</literal>, как описано в предыдущей главе, и смогли запустить "
"<application>psql</application>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:27(para)
msgid ""
"Examples in this manual can also be found in the <productname>PostgreSQL</"
"productname> source distribution in the directory <filename>src/tutorial/</"
"filename>. (Binary distributions of <productname>PostgreSQL</productname> "
"might not compile these files.) To use those files, first change to that "
"directory and run <application>make</application>: <screen>\n"
"<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/src/"
"tutorial</userinput>\n"
"<prompt>$</prompt> <userinput>make</userinput>\n"
"</screen> This creates the scripts and compiles the C files containing user-"
"defined functions and types. Then, to start the tutorial, do the following: "
"<screen>\n"
"<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/tutorial</"
"userinput>\n"
"<prompt>$</prompt> <userinput>psql -s mydb</userinput>\n"
"<computeroutput>\n"
"...\n"
"</computeroutput>\n"
"\n"
"<prompt>mydb=&gt;</prompt> <userinput>\\i basics.sql</userinput>\n"
"</screen> The <literal>\\i</literal> command reads in commands from the "
"specified file. <command>psql</command>'s <literal>-s</literal> option puts "
"you in single step mode which pauses before sending each statement to the "
"server. The commands used in this section are in the file <filename>basics."
"sql</filename>."
msgstr ""
"Примеры этого руководства также можно найти в пакете исходного кода "
"<productname>PostgreSQL</productname> в каталоге <filename>src/tutorial/</"
"filename>. (Двоичные дистрибутивы <productname>PostgreSQL</productname> "
"могут не включать эти файлы.) Чтобы использовать эти файлы, перейдите в этот "
"каталог и запустите <application>make</application>: <screen>\n"
"<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/src/"
"tutorial</userinput>\n"
"<prompt>$</prompt> <userinput>make</userinput>\n"
"</screen> При этом будут созданы скрипты и скомпилированы модули C, "
"содержащие пользовательские функции и типы. Затем, чтобы начать работу с "
"учебным материалом, выполните следующее: <screen>\n"
"<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/tutorial</"
"userinput>\n"
"<prompt>$</prompt> <userinput>psql -s mydb</userinput>\n"
"<computeroutput>\n"
"...\n"
"</computeroutput>\n"
"\n"
"<prompt>mydb=&gt;</prompt> <userinput>\\i basics.sql</userinput>\n"
"</screen> Команда <literal>\\i</literal> считывает и выполняет команды из "
"заданного файла. Переданный <command>psql</command> параметр <literal>-s</"
"literal> переводит его в пошаговый режим, когда он делает паузу перед "
"отправкой каждого оператора серверу. Команды, используемые в этом разделе, "
"содержатся в файле <filename>basics.sql</filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:63(title)
msgid "Concepts"
msgstr "Основные понятия"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:66(indexterm)
msgid "<primary>relational database</primary>"
msgstr "<primary>реляционная база данных</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:67(indexterm)
msgid "<primary>hierarchical database</primary>"
msgstr "<primary>иерархическая база данных</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:68(indexterm)
msgid "<primary>object-oriented database</primary>"
msgstr "<primary>объектно-ориентированная база данных</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:69(indexterm)
msgid "<primary>relation</primary>"
msgstr "<primary>отношение</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:70(indexterm)
msgid "<primary>table</primary>"
msgstr "<primary>таблица</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:65(para)
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> "
"<placeholder-5/> <productname>PostgreSQL</productname> is a "
"<firstterm>relational database management system</firstterm> "
"(<acronym>RDBMS</acronym>). That means it is a system for managing data "
"stored in <firstterm>relations</firstterm>. Relation is essentially a "
"mathematical term for <firstterm>table</firstterm>. The notion of storing "
"data in tables is so commonplace today that it might seem inherently "
"obvious, but there are a number of other ways of organizing databases. Files "
"and directories on Unix-like operating systems form an example of a "
"hierarchical database. A more modern development is the object-oriented "
"database."
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> "
"<placeholder-5/> <productname>PostgreSQL</productname> &mdash; это "
"<firstterm>реляционная система управления базами данных </firstterm> "
"(<acronym>РСУБД</acronym>). Это означает, что это система управления "
"данными, представленными в виде <firstterm>отношений</firstterm> (relation). "
"Отношение &mdash; это математически точное обозначение <firstterm>таблицы</"
"firstterm>. Хранение данных в таблицах так распространено сегодня, что это "
"кажется самым очевидным вариантом, хотя есть множество других способов "
"организации баз данных. Например, файлы и каталоги в Unix-подобных "
"операционных системах образуют иерархическую базу данных, а сегодня активно "
"развиваются объектно-ориентированные базы данных."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:85(indexterm)
msgid "<primary>row</primary>"
msgstr "<primary>строка</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:86(indexterm)
msgid "<primary>column</primary>"
msgstr "<primary>столбец</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:84(para)
msgid ""
"<placeholder-1/> <placeholder-2/> Each table is a named collection of "
"<firstterm>rows</firstterm>. Each row of a given table has the same set of "
"named <firstterm>columns</firstterm>, and each column is of a specific data "
"type. Whereas columns have a fixed order in each row, it is important to "
"remember that SQL does not guarantee the order of the rows within the table "
"in any way (although they can be explicitly sorted for display)."
msgstr ""
"<placeholder-1/> <placeholder-2/> Любая таблица представляет собой "
"именованный набор <firstterm>строк</firstterm>. Все строки таблицы имеют "
"одинаковый набор именованных <firstterm>столбцов</firstterm>, при этом "
"каждому столбцу назначается определённый тип данных. Хотя порядок столбцов "
"во всех строках фиксирован, важно помнить, что SQL не гарантирует какой-либо "
"порядок строк в таблице (хотя их можно явно отсортировать при выводе)."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:98(indexterm)
msgid "<primary>database cluster</primary>"
msgstr "<primary>кластер баз данных</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:99(indexterm)
msgid ""
"<primary>cluster</primary><secondary>of databases</secondary><see>database "
"cluster</see>"
msgstr ""
"<primary>кластер</primary> <secondary>баз данных</secondary> <see>кластер "
"баз данных</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:97(para)
msgid ""
"<placeholder-1/> <placeholder-2/> Tables are grouped into databases, and a "
"collection of databases managed by a single <productname>PostgreSQL</"
"productname> server instance constitutes a database <firstterm>cluster</"
"firstterm>."
msgstr ""
"<placeholder-1/> <placeholder-2/> Таблицы объединяются в базы данных, а "
"набор баз данных, управляемый одним экземпляром сервера "
"<productname>PostgreSQL</productname>, образует <firstterm>кластер</"
"firstterm> баз данных."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:109(title)
msgid "Creating a New Table"
msgstr "Создание таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:111(indexterm)
msgid "<primary>CREATE TABLE</primary>"
msgstr "<primary>CREATE TABLE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:119(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE weather (\n"
"    city            varchar(80),\n"
"    temp_lo         int,           -- low temperature\n"
"    temp_hi         int,           -- high temperature\n"
"    prcp            real,          -- precipitation\n"
"    date            date\n"
");"
msgstr ""
"CREATE TABLE weather (\n"
"    city            varchar(80),\n"
"    temp_lo         int,           -- минимальная температура дня\n"
"    temp_hi         int,           -- максимальная температура дня\n"
"    prcp            real,          -- уровень осадков\n"
"    date            date\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:115(para)
msgid ""
"You can create a new table by specifying the table name, along with all "
"column names and their types: <placeholder-1/> You can enter this into "
"<command>psql</command> with the line breaks. <command>psql</command> will "
"recognize that the command is not terminated until the semicolon."
msgstr ""
"Вы можете создать таблицу, указав её имя и перечислив все имена столбцов и "
"их типы: <placeholder-1/> Весь этот текст можно ввести в <command>psql</"
"command> вместе с символами перевода строк. <command>psql</command> "
"понимает, что команда продолжается до точки с запятой."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:134(para)
msgid ""
"White space (i.e., spaces, tabs, and newlines) can be used freely in SQL "
"commands. That means you can type the command aligned differently than "
"above, or even all on one line. Two dashes (<quote><literal>--</literal></"
"quote>) introduce comments. Whatever follows them is ignored up to the end "
"of the line. SQL is case insensitive about key words and identifiers, except "
"when identifiers are double-quoted to preserve the case (not done above)."
msgstr ""
"В командах SQL можно свободно использовать пробельные символы (пробелы, "
"табуляции и переводы строк). Это значит, что вы можете ввести команду, "
"выровняв её по-другому или даже уместив в одной строке. Два минуса "
"(<quote><literal>--</literal></quote>) обозначают начало комментария. Всё, "
"что идёт за ними до конца строки, игнорируется. SQL не чувствителен к "
"регистру в ключевых словах и идентификаторах, за исключением "
"идентификаторов, взятых в кавычки (в данном случае это не так)."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:145(para)
msgid ""
"<type>varchar(80)</type> specifies a data type that can store arbitrary "
"character strings up to 80 characters in length. <type>int</type> is the "
"normal integer type. <type>real</type> is a type for storing single "
"precision floating-point numbers. <type>date</type> should be self-"
"explanatory. (Yes, the column of type <type>date</type> is also named "
"<structfield>date</structfield>. This might be convenient or confusing "
"&mdash; you choose.)"
msgstr ""
"<type>varchar(80)</type> определяет тип данных, допускающий хранение "
"произвольных символьных строк длиной до 80 символов. <type>int</type> "
"&mdash; обычный целочисленный тип. <type>real</type> &mdash; тип для "
"хранения чисел с плавающей точкой одинарной точности. <type>date</type> "
"&mdash; тип даты. (Да, столбец типа <type>date</type> также называется "
"<structfield>date</structfield>. Это может быть удобно или вводить в "
"заблуждение &mdash; как посмотреть.)"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:155(para)
msgid ""
"<productname>PostgreSQL</productname> supports the standard <acronym>SQL</"
"acronym> types <type>int</type>, <type>smallint</type>, <type>real</type>, "
"<type>double precision</type>, <type>char(<replaceable>N</replaceable>)</"
"type>, <type>varchar(<replaceable>N</replaceable>)</type>, <type>date</"
"type>, <type>time</type>, <type>timestamp</type>, and <type>interval</type>, "
"as well as other types of general utility and a rich set of geometric types. "
"<productname>PostgreSQL</productname> can be customized with an arbitrary "
"number of user-defined data types. Consequently, type names are not key "
"words in the syntax, except where required to support special cases in the "
"<acronym>SQL</acronym> standard."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает стандартные типы "
"<acronym>SQL</acronym>: <type>int</type>, <type>smallint</type>, <type>real</"
"type>, <type>double precision</type>, <type>char(<replaceable>N</"
"replaceable>)</type>, <type>varchar(<replaceable>N</replaceable>)</type>, "
"<type>date</type>, <type>time</type>, <type>timestamp</type> и "
"<type>interval</type>, а также другие универсальные типы и богатый набор "
"геометрических типов. Кроме того, <productname>PostgreSQL</productname> "
"можно расширять, создавая набор собственных типов данных. Как следствие, "
"имена типов не являются ключевыми словами в данной записи, кроме тех "
"случаев, когда это требуется для реализации особых конструкций стандарта "
"<acronym>SQL</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:173(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cities (\n"
"    name            varchar(80),\n"
"    location        point\n"
");"
msgstr ""
"CREATE TABLE cities (\n"
"    name            varchar(80),\n"
"    location        point\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:170(para)
msgid ""
"The second example will store cities and their associated geographical "
"location: <placeholder-1/> The <type>point</type> type is an example of a "
"<productname>PostgreSQL</productname>-specific data type."
msgstr ""
"Во втором примере мы сохраним в таблице города и их географическое "
"положение: <placeholder-1/> Здесь <type>point</type> &mdash; пример "
"специфического типа данных <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:184(indexterm)
msgid "<primary>DROP TABLE</primary>"
msgstr "<primary>DROP TABLE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:183(para)
msgid ""
"<placeholder-1/> Finally, it should be mentioned that if you don't need a "
"table any longer or want to recreate it differently you can remove it using "
"the following command: <synopsis>\n"
"DROP TABLE <replaceable>tablename</replaceable>;\n"
"</synopsis>"
msgstr ""
"<placeholder-1/> Наконец, следует сказать, что если вам больше не нужна "
"какая-либо таблица, или вы хотите пересоздать её по-другому, вы можете "
"удалить её, используя следующую команду: <synopsis>\n"
"DROP TABLE <replaceable>имя_таблицы</replaceable>;\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:199(title)
msgid "Populating a Table With Rows"
msgstr "Добавление строк в таблицу"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:201(indexterm)
msgid "<primary>INSERT</primary>"
msgstr "<primary>INSERT</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:209(programlisting)
#, no-wrap
msgid "INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');"
msgstr "INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:205(para)
msgid ""
"The <command>INSERT</command> statement is used to populate a table with "
"rows: <placeholder-1/> Note that all data types use rather obvious input "
"formats. Constants that are not simple numeric values usually must be "
"surrounded by single quotes (<literal>'</literal>), as in the example. The "
"<type>date</type> type is actually quite flexible in what it accepts, but "
"for this tutorial we will stick to the unambiguous format shown here."
msgstr ""
"Для добавления строк в таблицу используется оператор <command>INSERT</"
"command>: <placeholder-1/> Заметьте, что для всех типов данных применяются "
"довольно очевидные форматы. Константы, за исключением простых числовых "
"значений, обычно заключаются в апострофы (<literal>'</literal>), как в "
"данном примере. Тип <type>date</type> на самом деле очень гибок и принимает "
"разные форматы, но в данном введении мы будем придерживаться простого и "
"однозначного."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:225(programlisting)
#, no-wrap
msgid "INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');"
msgstr "INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:222(para)
msgid ""
"The <type>point</type> type requires a coordinate pair as input, as shown "
"here: <placeholder-1/>"
msgstr ""
"Тип <type>point</type> требует ввода пары координат, например таким образом: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:234(programlisting)
#, no-wrap
msgid ""
"INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\n"
"    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');"
msgstr ""
"INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\n"
"    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:240(programlisting)
#, no-wrap
msgid ""
"INSERT INTO weather (date, city, temp_hi, temp_lo)\n"
"    VALUES ('1994-11-29', 'Hayward', 54, 37);"
msgstr ""
"INSERT INTO weather (date, city, temp_hi, temp_lo)\n"
"    VALUES ('1994-11-29', 'Hayward', 54, 37);"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:230(para)
msgid ""
"The syntax used so far requires you to remember the order of the columns. An "
"alternative syntax allows you to list the columns explicitly: <placeholder-1/"
"> You can list the columns in a different order if you wish or even omit "
"some columns, e.g., if the precipitation is unknown: <placeholder-2/> Many "
"developers consider explicitly listing the columns better style than relying "
"on the order implicitly."
msgstr ""
"Показанный здесь синтаксис требует, чтобы вы запомнили порядок столбцов. "
"Можно также применить альтернативную запись, перечислив столбцы явно: "
"<placeholder-1/>Вы можете перечислить столбцы в другом порядке, если желаете "
"опустить некоторые из них, например, если уровень осадков (столбец prcp) "
"неизвестен: <placeholder-2/> Многие разработчики предпочитают явно "
"перечислять столбцы, а не полагаться на их порядок в таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:248(para)
msgid ""
"Please enter all the commands shown above so you have some data to work with "
"in the following sections."
msgstr ""
"Пожалуйста, введите все показанные выше команды, чтобы у вас были данные, с "
"которыми можно будет работать дальше."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:254(indexterm)
msgid "<primary>COPY</primary>"
msgstr "<primary>COPY</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:264(programlisting)
#, no-wrap
msgid "COPY weather FROM '/home/user/weather.txt';"
msgstr "COPY weather FROM '/home/user/weather.txt';"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:253(para)
msgid ""
"<placeholder-1/> You could also have used <command>COPY</command> to load "
"large amounts of data from flat-text files. This is usually faster because "
"the <command>COPY</command> command is optimized for this application while "
"allowing less flexibility than <command>INSERT</command>. An example would "
"be: <placeholder-2/> where the file name for the source file must be "
"available on the machine running the backend process, not the client, since "
"the backend process reads the file directly. You can read more about the "
"<command>COPY</command> command in <xref linkend=\"sql-copy\"/>."
msgstr ""
"<placeholder-1/> Вы также можете загрузить большой объём данных из обычных "
"текстовых файлов, применив команду <command>COPY</command>. Обычно это будет "
"быстрее, так как команда <command>COPY</command> оптимизирована для такого "
"применения, хотя и менее гибка, чем <command>INSERT</command>. Например, её "
"можно использовать так: <placeholder-2/> здесь подразумевается, что данный "
"файл доступен на компьютере, где работает серверный процесс, а не на "
"клиенте, так как указанный файл будет прочитан непосредственно на сервере. "
"Подробнее об этом вы можете узнать в описании команды <xref linkend=\"sql-"
"copy\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:277(title)
msgid "Querying a Table"
msgstr "Выполнение запроса"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:280(indexterm)
msgid "<primary>query</primary>"
msgstr "<primary>запрос</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:281(indexterm)
msgid "<primary>SELECT</primary>"
msgstr "<primary>SELECT</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:292(programlisting) query.xml:855(programlisting)
#, no-wrap
msgid "SELECT * FROM weather;"
msgstr "SELECT * FROM weather;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:297(para)
msgid ""
"While <literal>SELECT *</literal> is useful for off-the-cuff queries, it is "
"widely considered bad style in production code, since adding a column to the "
"table would change the results."
msgstr ""
"Хотя запросы <literal>SELECT *</literal> часто пишут экспромтом, это "
"считается плохим стилем в производственном коде, так как результат таких "
"запросов будет меняться при добавлении новых столбцов."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:304(programlisting)
#, no-wrap
msgid "SELECT city, temp_lo, temp_hi, prcp, date FROM weather;"
msgstr "SELECT city, temp_lo, temp_hi, prcp, date FROM weather;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:279(para)
msgid ""
"<placeholder-1/> <placeholder-2/> To retrieve data from a table, the table "
"is <firstterm>queried</firstterm>. An <acronym>SQL</acronym> "
"<command>SELECT</command> statement is used to do this. The statement is "
"divided into a select list (the part that lists the columns to be returned), "
"a table list (the part that lists the tables from which to retrieve the "
"data), and an optional qualification (the part that specifies any "
"restrictions). For example, to retrieve all the rows of table "
"<structname>weather</structname>, type: <placeholder-3/> Here <literal>*</"
"literal> is a shorthand for <quote>all columns</quote>. <placeholder-4/> So "
"the same result would be had with: <placeholder-5/> The output should be: "
"<screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
" San Francisco |      43 |      57 |    0 | 1994-11-29\n"
" Hayward       |      37 |      54 |      | 1994-11-29\n"
"(3 rows)\n"
"</screen>"
msgstr ""
"<placeholder-1/> <placeholder-2/> Чтобы получить данные из таблицы, нужно "
"выполнить <firstterm>запрос</firstterm>. Для этого предназначен "
"<acronym>SQL</acronym>-оператор <command>SELECT</command>. Он состоит из "
"нескольких частей: выборки (в которой перечисляются столбцы, которые должны "
"быть получены), списка таблиц (в нём перечисляются таблицы, из которых будут "
"получены данные) и необязательного условия (определяющего ограничения). "
"Например, чтобы получить все строки таблицы <structname>weather</"
"structname>, введите: <placeholder-3/> Здесь <literal>*</literal> &mdash; "
"это краткое обозначение <quote>всех столбцов</quote>. <placeholder-4/> Таким "
"образом, это равносильно записи: <placeholder-5/> В результате должно "
"получиться: <screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
" San Francisco |      43 |      57 |    0 | 1994-11-29\n"
" Hayward       |      37 |      54 |      | 1994-11-29\n"
"(3 rows)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:323(programlisting)
#, no-wrap
msgid "SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;"
msgstr "SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:320(para)
msgid ""
"You can write expressions, not just simple column references, in the select "
"list. For example, you can do: <placeholder-1/> This should give: <screen>\n"
"     city      | temp_avg |    date\n"
"---------------+----------+------------\n"
" San Francisco |       48 | 1994-11-27\n"
" San Francisco |       50 | 1994-11-29\n"
" Hayward       |       45 | 1994-11-29\n"
"(3 rows)\n"
"</screen> Notice how the <literal>AS</literal> clause is used to relabel the "
"output column. (The <literal>AS</literal> clause is optional.)"
msgstr ""
"В списке выборки вы можете писать не только ссылки на столбцы, но и "
"выражения. Например, вы можете написать: <placeholder-1/> И получить в "
"результате: <screen>\n"
"     city      | temp_avg |    date\n"
"---------------+----------+------------\n"
" San Francisco |       48 | 1994-11-27\n"
" San Francisco |       50 | 1994-11-29\n"
" Hayward       |       45 | 1994-11-29\n"
"(3 rows)\n"
"</screen> Обратите внимание, как предложение <literal>AS</literal> позволяет "
"переименовать выходной столбец. (Само слово <literal>AS</literal> можно "
"опускать.)"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:349(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM weather\n"
"    WHERE city = 'San Francisco' AND prcp &gt; 0.0;"
msgstr ""
"SELECT * FROM weather\n"
"    WHERE city = 'San Francisco' AND prcp &gt; 0.0;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:339(para)
msgid ""
"A query can be <quote>qualified</quote> by adding a <literal>WHERE</literal> "
"clause that specifies which rows are wanted. The <literal>WHERE</literal> "
"clause contains a Boolean (truth value) expression, and only rows for which "
"the Boolean expression is true are returned. The usual Boolean operators "
"(<literal>AND</literal>, <literal>OR</literal>, and <literal>NOT</literal>) "
"are allowed in the qualification. For example, the following retrieves the "
"weather of San Francisco on rainy days: <placeholder-1/> Result: <screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Запрос можно дополнить <quote>условием</quote>, добавив предложение "
"<literal>WHERE</literal>, ограничивающее множество возвращаемых строк. В "
"предложении <literal>WHERE</literal> указывается логическое выражение "
"(проверка истинности), которое служит фильтром строк: в результате "
"оказываются только те строки, для которых это выражение истинно. В этом "
"выражении могут присутствовать обычные логические операторы (<literal>AND</"
"literal>, <literal>OR</literal> и <literal>NOT</literal>). Например, "
"следующий запрос покажет, какая погода была в Сан-Франциско в дождливые дни: "
"<placeholder-1/> Результат: <screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
"(1 row)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:363(indexterm)
msgid "<primary>ORDER BY</primary>"
msgstr "<primary>ORDER BY</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:368(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM weather\n"
"    ORDER BY city;"
msgstr ""
"SELECT * FROM weather\n"
"    ORDER BY city;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:385(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM weather\n"
"    ORDER BY city, temp_lo;"
msgstr ""
"SELECT * FROM weather\n"
"    ORDER BY city, temp_lo;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:362(para)
msgid ""
"<placeholder-1/> You can request that the results of a query be returned in "
"sorted order: <placeholder-2/> <screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" Hayward       |      37 |      54 |      | 1994-11-29\n"
" San Francisco |      43 |      57 |    0 | 1994-11-29\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
"</screen> In this example, the sort order isn't fully specified, and so you "
"might get the San Francisco rows in either order. But you'd always get the "
"results shown above if you do: <placeholder-3/>"
msgstr ""
"<placeholder-1/> Вы можете получить результаты запроса в определённом "
"порядке: <placeholder-2/> <screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" Hayward       |      37 |      54 |      | 1994-11-29\n"
" San Francisco |      43 |      57 |    0 | 1994-11-29\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
"</screen> В этом примере порядок сортировки определён не полностью, поэтому "
"вы можете получить строки Сан-Франциско в любом порядке. Но вы всегда "
"получите результат, показанный выше, если напишете: <placeholder-3/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:392(indexterm)
msgid "<primary>DISTINCT</primary>"
msgstr "<primary>DISTINCT</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:393(indexterm)
msgid "<primary>duplicate</primary>"
msgstr "<primary>дублирование</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:398(programlisting)
#, no-wrap
msgid ""
"SELECT DISTINCT city\n"
"    FROM weather;"
msgstr ""
"SELECT DISTINCT city\n"
"    FROM weather;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:415(para)
msgid ""
"In some database systems, including older versions of "
"<productname>PostgreSQL</productname>, the implementation of "
"<literal>DISTINCT</literal> automatically orders the rows and so "
"<literal>ORDER BY</literal> is unnecessary. But this is not required by the "
"SQL standard, and current <productname>PostgreSQL</productname> does not "
"guarantee that <literal>DISTINCT</literal> causes the rows to be ordered."
msgstr ""
"В некоторых СУБД, включая старые версии <productname>PostgreSQL</"
"productname>, реализация предложения <literal>DISTINCT</literal> "
"автоматически упорядочивает строки, так что <literal>ORDER BY</literal> "
"добавлять не обязательно. Но стандарт SQL этого не требует и текущая версия "
"<productname>PostgreSQL</productname> не гарантирует определённого порядка "
"строк после <literal>DISTINCT</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:426(programlisting)
#, no-wrap
msgid ""
"SELECT DISTINCT city\n"
"    FROM weather\n"
"    ORDER BY city;"
msgstr ""
"SELECT DISTINCT city\n"
"    FROM weather\n"
"    ORDER BY city;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:391(para)
msgid ""
"<placeholder-1/> <placeholder-2/> You can request that duplicate rows be "
"removed from the result of a query: <placeholder-3/> <screen>\n"
"     city\n"
"---------------\n"
" Hayward\n"
" San Francisco\n"
"(2 rows)\n"
"</screen> Here again, the result row ordering might vary. You can ensure "
"consistent results by using <literal>DISTINCT</literal> and <literal>ORDER "
"BY</literal> together: <placeholder-4/> <placeholder-5/>"
msgstr ""
"<placeholder-1/> <placeholder-2/> Если требуется, вы можете убрать "
"дублирующиеся строки из результата запроса: <placeholder-3/> <screen>\n"
"     city\n"
"---------------\n"
" Hayward\n"
" San Francisco\n"
"(2 rows)\n"
"</screen> И здесь порядок строк также может варьироваться. Чтобы получать "
"неизменные результаты, соедините предложения <literal>DISTINCT</literal> и "
"<literal>ORDER BY</literal>: <placeholder-4/> <placeholder-5/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:436(title)
msgid "Joins Between Tables"
msgstr "Соединения таблиц"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:438(indexterm)
msgid "<primary>join</primary>"
msgstr "<primary>соединение</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:455(para)
msgid ""
"This is only a conceptual model. The join is usually performed in a more "
"efficient manner than actually comparing each possible pair of rows, but "
"this is invisible to the user."
msgstr ""
"Это не совсем точная модель. Обычно соединения выполняются эффективнее "
"(сравниваются не все возможные пары строк), но это скрыто от пользователя."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:463(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM weather, cities\n"
"    WHERE city = name;"
msgstr ""
"SELECT *\n"
"    FROM weather, cities\n"
"    WHERE city = name;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:442(para)
msgid ""
"Thus far, our queries have only accessed one table at a time. Queries can "
"access multiple tables at once, or access the same table in such a way that "
"multiple rows of the table are being processed at the same time. A query "
"that accesses multiple rows of the same or different tables at one time is "
"called a <firstterm>join</firstterm> query. As an example, say you wish to "
"list all the weather records together with the location of the associated "
"city. To do that, we need to compare the <structfield>city</structfield> "
"column of each row of the <structname>weather</structname> table with the "
"<structfield>name</structfield> column of all rows in the "
"<structname>cities</structname> table, and select the pairs of rows where "
"these values match. <placeholder-1/> This would be accomplished by the "
"following query: <placeholder-2/> <screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date    |     name      | "
"location\n"
"---------------+---------+---------+------+------------+---------------"
"+-----------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | "
"(-194,53)\n"
" San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | "
"(-194,53)\n"
"(2 rows)\n"
"</screen>"
msgstr ""
"До этого все наши запросы обращались только к одной таблице. Однако запросы "
"могут также обращаться сразу к нескольким таблицам или обращаться к той же "
"таблице так, что одновременно будут обрабатываться разные наборы её строк. "
"Запрос, обращающийся к разным наборам строк одной или нескольких таблиц, "
"называется <firstterm>соединением</firstterm> (JOIN). Например, мы захотели "
"перечислить все погодные события вместе с координатами соответствующих "
"городов. Для этого мы должны сравнить столбец <structfield>city</"
"structfield> каждой строки таблицы <structname>weather</structname> со "
"столбцом <structfield>name</structfield> всех строк таблицы "
"<structname>cities</structname> и выбрать пары строк, для которых эти "
"значения совпадают. <placeholder-1/> Это можно сделать с помощью следующего "
"запроса: <placeholder-2/> <screen>\n"
"     city     |temp_lo|temp_hi| prcp|    date   |     name     | location\n"
"--------------+-------+-------+-----+-----------+--------------+----------\n"
" San Francisco|     46|     50| 0.25| 1994-11-27| San Francisco| (-194,53)\n"
" San Francisco|     43|     57|    0| 1994-11-29| San Francisco| (-194,53)\n"
"(2 rows)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:483(para)
msgid ""
"There is no result row for the city of Hayward. This is because there is no "
"matching entry in the <structname>cities</structname> table for Hayward, so "
"the join ignores the unmatched rows in the <structname>weather</structname> "
"table. We will see shortly how this can be fixed."
msgstr ""
"В результате нет строки с городом Хейуорд (Hayward). Так получилось потому, "
"что в таблице <structname>cities</structname> нет строки для данного города, "
"а при соединении все строки таблицы <structname>weather</structname>, для "
"которых не нашлось соответствие, опускаются. Вскоре мы увидим, как это можно "
"исправить."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:501(programlisting)
#, no-wrap
msgid ""
"SELECT city, temp_lo, temp_hi, prcp, date, location\n"
"    FROM weather, cities\n"
"    WHERE city = name;"
msgstr ""
"SELECT city, temp_lo, temp_hi, prcp, date, location\n"
"    FROM weather, cities\n"
"    WHERE city = name;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:493(para)
msgid ""
"There are two columns containing the city name. This is correct because the "
"lists of columns from the <structname>weather</structname> and "
"<structname>cities</structname> tables are concatenated. In practice this is "
"undesirable, though, so you will probably want to list the output columns "
"explicitly rather than using <literal>*</literal>: <placeholder-1/>"
msgstr ""
"Название города оказалось в двух столбцах. Это правильно и объясняется тем, "
"что столбцы таблиц <structname>weather</structname> и <structname>cities</"
"structname> были объединены. Хотя на практике это нежелательно, поэтому "
"лучше перечислить нужные столбцы явно, а не использовать <literal>*</"
"literal>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:479(para)
msgid "Observe two things about the result set: <placeholder-1/>"
msgstr ""
"Обратите внимание на две особенности полученных данных: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:512(title) query.xml:587(title)
msgid "Exercise:"
msgstr "Упражнение:"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:514(para)
msgid ""
"Attempt to determine the semantics of this query when the <literal>WHERE</"
"literal> clause is omitted."
msgstr ""
"Попробуйте определить, что будет делать этот запрос без предложения "
"<literal>WHERE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:527(programlisting)
#, no-wrap
msgid ""
"SELECT weather.city, weather.temp_lo, weather.temp_hi,\n"
"       weather.prcp, weather.date, cities.location\n"
"    FROM weather, cities\n"
"    WHERE cities.name = weather.city;"
msgstr ""
"SELECT weather.city, weather.temp_lo, weather.temp_hi,\n"
"       weather.prcp, weather.date, cities.location\n"
"    FROM weather, cities\n"
"    WHERE cities.name = weather.city;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:520(para)
msgid ""
"Since the columns all had different names, the parser automatically found "
"which table they belong to. If there were duplicate column names in the two "
"tables you'd need to <firstterm>qualify</firstterm> the column names to show "
"which one you meant, as in: <placeholder-1/> It is widely considered good "
"style to qualify all column names in a join query, so that the query won't "
"fail if a duplicate column name is later added to one of the tables."
msgstr ""
"Так как все столбцы имеют разные имена, анализатор запроса автоматически "
"понимает, к какой таблице они относятся. Если бы имена столбцов в двух "
"таблицах повторялись, вам пришлось бы <firstterm>дополнить</firstterm> имена "
"столбцов, конкретизируя, что именно вы имели в виду: <placeholder-1/> Вообще "
"хорошим стилем считается указывать полные имена столбцов в запросе "
"соединения, чтобы запрос не поломался, если позже в таблицы будут добавлены "
"столбцы с повторяющимися именами."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:543(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM weather INNER JOIN cities ON (weather.city = cities.name);"
msgstr ""
"SELECT *\n"
"    FROM weather INNER JOIN cities ON (weather.city = cities.name);"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:539(para)
msgid ""
"Join queries of the kind seen thus far can also be written in this "
"alternative form: <placeholder-1/> This syntax is not as commonly used as "
"the one above, but we show it here to help you understand the following "
"topics."
msgstr ""
"Запросы соединения, которые вы видели до этого, можно также записать в "
"другом виде: <placeholder-1/> Эта запись не так распространена, как первый "
"вариант, но мы показываем её, чтобы вам было проще понять следующие темы."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:553(indexterm)
msgid "<primary>join</primary><secondary>outer</secondary>"
msgstr "<primary>соединение</primary> <secondary>внешнее</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:565(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);\n"
"\n"
"     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n"
"---------------+---------+---------+------+------------+---------------+-----------\n"
" Hayward       |      37 |      54 |      | 1994-11-29 |               |\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n"
" San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n"
"(3 rows)"
msgstr ""
"SELECT *\n"
"    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);\n"
"\n"
"     city     |temp_lo|temp_hi| prcp|    date   |     name     | location\n"
"--------------+-------+-------+-----+-----------+--------------+----------\n"
" Hayward      |     37|     54|     | 1994-11-29|              |\n"
" San Francisco|     46|     50| 0.25| 1994-11-27| San Francisco| (-194,53)\n"
" San Francisco|     43|     57|    0| 1994-11-29| San Francisco| (-194,53)\n"
"(3 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:552(para)
msgid ""
"<placeholder-1/> Now we will figure out how we can get the Hayward records "
"back in. What we want the query to do is to scan the <structname>weather</"
"structname> table and for each row to find the matching <structname>cities</"
"structname> row(s). If no matching row is found we want some <quote>empty "
"values</quote> to be substituted for the <structname>cities</structname> "
"table's columns. This kind of query is called an <firstterm>outer join</"
"firstterm>. (The joins we have seen so far are inner joins.) The command "
"looks like this: <placeholder-2/> This query is called a <firstterm>left "
"outer join</firstterm> because the table mentioned on the left of the join "
"operator will have each of its rows in the output at least once, whereas the "
"table on the right will only have those rows output that match some row of "
"the left table. When outputting a left-table row for which there is no right-"
"table match, empty (null) values are substituted for the right-table columns."
msgstr ""
"<placeholder-1/> Сейчас мы выясним, как вернуть записи о погоде в городе "
"Хейуорд. Мы хотим, чтобы запрос просканировал таблицу <structname>weather</"
"structname> и для каждой её строки нашёл соответствующую строку в таблице "
"<structname>cities</structname>. Если же такая строка не будет найдена, мы "
"хотим, чтобы вместо значений столбцов из таблицы <structname>cities</"
"structname> были подставлены <quote>пустые значения</quote>. Запросы такого "
"типа называются <firstterm>внешними соединениями</firstterm>. (Соединения, "
"которые мы видели до этого, называются внутренними.) Эта команда будет "
"выглядеть так: <placeholder-2/> Этот запрос называется <firstterm>левым "
"внешним соединением</firstterm>, потому что из таблицы в левой части "
"оператора будут выбраны все строки, а из таблицы справа только те, которые "
"удалось сопоставить каким-нибудь строкам из левой. При выводе строк левой "
"таблицы, для которых не удалось найти соответствия в правой, вместо столбцов "
"правой таблицы подставляются пустые значения (NULL)."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:589(para)
msgid ""
"There are also right outer joins and full outer joins. Try to find out what "
"those do."
msgstr ""
"Существуют также правые внешние соединения и полные внешние соединения. "
"Попробуйте выяснить, что они собой представляют."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:596(indexterm)
msgid "<primary>join</primary><secondary>self</secondary>"
msgstr "<primary>соединение</primary> <secondary>замкнутое</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:597(indexterm)
msgid "<primary>alias</primary><secondary>for table name in query</secondary>"
msgstr "<primary>псевдоним</primary> <secondary>таблицы в запросе</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:610(programlisting)
#, no-wrap
msgid ""
"SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,\n"
"    W2.city, W2.temp_lo AS low, W2.temp_hi AS high\n"
"    FROM weather W1, weather W2\n"
"    WHERE W1.temp_lo &lt; W2.temp_lo\n"
"    AND W1.temp_hi &gt; W2.temp_hi;\n"
"\n"
"     city      | low | high |     city      | low | high\n"
"---------------+-----+------+---------------+-----+------\n"
" San Francisco |  43 |   57 | San Francisco |  46 |   50\n"
" Hayward       |  37 |   54 | San Francisco |  46 |   50\n"
"(2 rows)"
msgstr ""
"SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,\n"
"    W2.city, W2.temp_lo AS low, W2.temp_hi AS high\n"
"    FROM weather W1, weather W2\n"
"    WHERE W1.temp_lo &lt; W2.temp_lo\n"
"    AND W1.temp_hi &gt; W2.temp_hi;\n"
"\n"
"     city      | low | high |     city      | low | high\n"
"---------------+-----+------+---------------+-----+------\n"
" San Francisco |  43 |   57 | San Francisco |  46 |   50\n"
" Hayward       |  37 |   54 | San Francisco |  46 |   50\n"
"(2 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:628(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM weather w, cities c\n"
"    WHERE w.city = c.name;"
msgstr ""
"SELECT *\n"
"    FROM weather w, cities c\n"
"    WHERE w.city = c.name;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:595(para)
msgid ""
"<placeholder-1/> <placeholder-2/> We can also join a table against itself. "
"This is called a <firstterm>self join</firstterm>. As an example, suppose we "
"wish to find all the weather records that are in the temperature range of "
"other weather records. So we need to compare the <structfield>temp_lo</"
"structfield> and <structfield>temp_hi</structfield> columns of each "
"<structname>weather</structname> row to the <structfield>temp_lo</"
"structfield> and <structfield>temp_hi</structfield> columns of all other "
"<structname>weather</structname> rows. We can do this with the following "
"query: <placeholder-3/> Here we have relabeled the weather table as "
"<literal>W1</literal> and <literal>W2</literal> to be able to distinguish "
"the left and right side of the join. You can also use these kinds of aliases "
"in other queries to save some typing, e.g.: <placeholder-4/> You will "
"encounter this style of abbreviating quite frequently."
msgstr ""
"<placeholder-1/> <placeholder-2/> В соединении мы также можем замкнуть "
"таблицу на себя. Это называется <firstterm>замкнутым соединением</"
"firstterm>. Например, представьте, что мы хотим найти все записи погоды, в "
"которых температура лежит в диапазоне температур других записей. Для этого "
"мы должны сравнить столбцы <structfield>temp_lo</structfield> и "
"<structfield>temp_hi</structfield> каждой строки таблицы "
"<structname>weather</structname> со столбцами <structfield>temp_lo</"
"structfield> и <structfield>temp_hi</structfield> другого набора строк "
"<structname>weather</structname>. Это можно сделать с помощью следующего "
"запроса: <placeholder-3/> Здесь мы ввели новые обозначения таблицы weather: "
"<literal>W1</literal> и <literal>W2</literal>, чтобы можно было различить "
"левую и правую стороны соединения. Вы можете использовать подобные "
"псевдонимы и в других запросах для сокращения: <placeholder-4/> Вы будете "
"встречать сокращения такого рода довольно часто."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:639(title)
msgid "Aggregate Functions"
msgstr "Агрегатные функции"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:641(indexterm)
msgid "<primary>aggregate function</primary>"
msgstr "<primary>агрегатная функция</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:645(para)
msgid ""
"Like most other relational database products, <productname>PostgreSQL</"
"productname> supports <firstterm>aggregate functions</firstterm>. An "
"aggregate function computes a single result from multiple input rows. For "
"example, there are aggregates to compute the <function>count</function>, "
"<function>sum</function>, <function>avg</function> (average), <function>max</"
"function> (maximum) and <function>min</function> (minimum) over a set of "
"rows."
msgstr ""
"Как большинство других серверов реляционных баз данных, "
"<productname>PostgreSQL</productname> поддерживает <firstterm>агрегатные "
"функции</firstterm>. Агрегатная функция вычисляет единственное значение, "
"обрабатывая множество строк. Например, есть агрегатные функции, вычисляющие: "
"<function>count</function> (количество), <function>sum</function> (сумму), "
"<function>avg</function> (среднее), <function>max</function> (максимум) и "
"<function>min</function> (минимум) для набора строк."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:660(programlisting)
#, no-wrap
msgid "SELECT max(temp_lo) FROM weather;"
msgstr "SELECT max(temp_lo) FROM weather;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:656(para)
msgid ""
"As an example, we can find the highest low-temperature reading anywhere "
"with: <placeholder-1/> <screen>\n"
" max\n"
"-----\n"
"  46\n"
"(1 row)\n"
"</screen>"
msgstr ""
"К примеру, мы можем найти самую высокую из всех минимальных дневных "
"температур: <placeholder-1/> <screen>\n"
" max\n"
"-----\n"
"  46\n"
"(1 row)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:673(indexterm)
msgid "<primary>subquery</primary>"
msgstr "<primary>подзапрос</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:678(programlisting)
#, no-wrap
msgid "SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>WRONG</lineannotation>"
msgstr "SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>НЕВЕРНО</lineannotation>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:692(programlisting)
#, no-wrap
msgid ""
"SELECT city FROM weather\n"
"    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);"
msgstr ""
"SELECT city FROM weather\n"
"    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:672(para)
msgid ""
"<placeholder-1/> If we wanted to know what city (or cities) that reading "
"occurred in, we might try: <placeholder-2/> but this will not work since the "
"aggregate <function>max</function> cannot be used in the <literal>WHERE</"
"literal> clause. (This restriction exists because the <literal>WHERE</"
"literal> clause determines which rows will be included in the aggregate "
"calculation; so obviously it has to be evaluated before aggregate functions "
"are computed.) However, as is often the case the query can be restated to "
"accomplish the desired result, here by using a <firstterm>subquery</"
"firstterm>: <placeholder-3/> <screen>\n"
"     city\n"
"---------------\n"
" San Francisco\n"
"(1 row)\n"
"</screen> This is OK because the subquery is an independent computation that "
"computes its own aggregate separately from what is happening in the outer "
"query."
msgstr ""
"<placeholder-1/> Если мы хотим узнать, в каком городе (или городах) "
"наблюдалась эта температура, можно попробовать: <placeholder-2/> но это не "
"будет работать, так как агрегатную функцию <function>max</function> нельзя "
"использовать в предложении <literal>WHERE</literal>. (Это ограничение "
"объясняется тем, что предложение <literal>WHERE</literal> должно определить, "
"для каких строк вычислять агрегатную функцию, так что оно, очевидно, должно "
"вычисляться до агрегатных функций.) Однако, как часто бывает, запрос можно "
"перезапустить и получить желаемый результат, применив <firstterm>подзапрос</"
"firstterm>: <placeholder-3/> <screen>\n"
"     city\n"
"---------------\n"
" San Francisco\n"
"(1 row)\n"
"</screen> Теперь всё в порядке &mdash; подзапрос выполняется отдельно и "
"результат агрегатной функции вычисляется вне зависимости от того, что "
"происходит во внешнем запросе."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:710(indexterm)
msgid "<primary>GROUP BY</primary>"
msgstr "<primary>GROUP BY</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:711(indexterm)
msgid "<primary>HAVING</primary>"
msgstr "<primary>HAVING</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:717(programlisting)
#, no-wrap
msgid ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    GROUP BY city;"
msgstr ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    GROUP BY city;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:736(programlisting)
#, no-wrap
msgid ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    GROUP BY city\n"
"    HAVING max(temp_lo) &lt; 40;"
msgstr ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    GROUP BY city\n"
"    HAVING max(temp_lo) &lt; 40;"

#. +> REL_10
#: query.xml:755(programlisting)
#, no-wrap
msgid ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    WHERE city LIKE 'S%'            -- <co id=\"co.tutorial-agg-like\"></co>\n"
"    GROUP BY city\n"
"    HAVING max(temp_lo) &lt; 40;"
msgstr ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    WHERE city LIKE 'S%'            -- <co id=\"co.tutorial-agg-like\"></co>\n"
"    GROUP BY city\n"
"    HAVING max(temp_lo) &lt; 40;"

#. +> REL9_6_3 REL9_6
#: query.xml:755(programlisting)
#, no-wrap
msgid ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    WHERE city LIKE 'S%'<co id=\"co.tutorial-agg-like\"></co>\n"
"    GROUP BY city\n"
"    HAVING max(temp_lo) &lt; 40;"
msgstr ""
"SELECT city, max(temp_lo)\n"
"    FROM weather\n"
"    WHERE city LIKE 'S%'<co id=\"co.tutorial-agg-like\"></co>\n"
"    GROUP BY city\n"
"    HAVING max(temp_lo) &lt; 40;"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:764(para)
msgid ""
"The <literal>LIKE</literal> operator does pattern matching and is explained "
"in <xref linkend=\"functions-matching\"/>."
msgstr ""
"Оператор <literal>LIKE</literal> (выполняющий сравнение по шаблону) "
"рассматривается в <xref remap=\"6\" linkend=\"functions-matching\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:709(para)
msgid ""
"<placeholder-1/> <placeholder-2/> Aggregates are also very useful in "
"combination with <literal>GROUP BY</literal> clauses. For example, we can "
"get the maximum low temperature observed in each city with: <placeholder-3/> "
"<screen>\n"
"     city      | max\n"
"---------------+-----\n"
" Hayward       |  37\n"
" San Francisco |  46\n"
"(2 rows)\n"
"</screen> which gives us one output row per city. Each aggregate result is "
"computed over the table rows matching that city. We can filter these grouped "
"rows using <literal>HAVING</literal>: <placeholder-4/> <screen>\n"
"  city   | max\n"
"---------+-----\n"
" Hayward |  37\n"
"(1 row)\n"
"</screen> which gives us the same results for only the cities that have all "
"<structfield>temp_lo</structfield> values below 40. Finally, if we only care "
"about cities whose names begin with <quote><literal>S</literal></quote>, we "
"might do: <placeholder-5/> <placeholder-6/>"
msgstr ""
"<placeholder-1/> <placeholder-2/> Агрегатные функции также очень полезны в "
"сочетании с предложением <literal>GROUP BY</literal>. Например, мы можем "
"получить максимум минимальной дневной температуры в разрезе городов: "
"<placeholder-3/> <screen>\n"
"     city      | max\n"
"---------------+-----\n"
" Hayward       |  37\n"
" San Francisco |  46\n"
"(2 rows)\n"
"</screen> Здесь мы получаем по одной строке для каждого города. Каждый "
"агрегатный результат вычисляется по строкам таблицы, соответствующим "
"отдельному городу. Мы можем отфильтровать сгруппированные строки с помощью "
"предложения <literal>HAVING</literal>: <placeholder-4/> <screen>\n"
"  city   | max\n"
"---------+-----\n"
" Hayward |  37\n"
"(1 row)\n"
"</screen> Мы получаем те же результаты, но только для тех городов, где все "
"значения <structfield>temp_lo</structfield> меньше 40. Наконец, если нас "
"интересуют только города, названия которых начинаются с <quote><literal>S</"
"literal></quote>, мы можем сделать: <placeholder-5/> <placeholder-6/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:772(para)
msgid ""
"It is important to understand the interaction between aggregates and "
"<acronym>SQL</acronym>'s <literal>WHERE</literal> and <literal>HAVING</"
"literal> clauses. The fundamental difference between <literal>WHERE</"
"literal> and <literal>HAVING</literal> is this: <literal>WHERE</literal> "
"selects input rows before groups and aggregates are computed (thus, it "
"controls which rows go into the aggregate computation), whereas "
"<literal>HAVING</literal> selects group rows after groups and aggregates are "
"computed. Thus, the <literal>WHERE</literal> clause must not contain "
"aggregate functions; it makes no sense to try to use an aggregate to "
"determine which rows will be inputs to the aggregates. On the other hand, "
"the <literal>HAVING</literal> clause always contains aggregate functions. "
"(Strictly speaking, you are allowed to write a <literal>HAVING</literal> "
"clause that doesn't use aggregates, but it's seldom useful. The same "
"condition could be used more efficiently at the <literal>WHERE</literal> "
"stage.)"
msgstr ""
"Важно понимать, как соотносятся агрегатные функции и <acronym>SQL</acronym>-"
"предложения <literal>WHERE</literal> и <literal>HAVING</literal>. Основное "
"отличие <literal>WHERE</literal> от <literal>HAVING</literal> заключается в "
"том, что <literal>WHERE</literal> сначала выбирает строки, а затем "
"группирует их и вычисляет агрегатные функции (таким образом, она отбирает "
"строки для вычисления агрегатов), тогда как <literal>HAVING</literal> "
"отбирает строки групп после группировки и вычисления агрегатных функций. Как "
"следствие, предложение <literal>WHERE</literal> не должно содержать "
"агрегатных функций; не имеет смысла использовать агрегатные функции для "
"определения строк для вычисления агрегатных функций. Предложение "
"<literal>HAVING</literal>, напротив, всегда содержит агрегатные функции. "
"(Строго говоря, вы можете написать предложение <literal>HAVING</literal>, не "
"используя агрегаты, но это редко бывает полезно. То же самое условие может "
"работать более эффективно на стадии <literal>WHERE</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:791(para)
msgid ""
"In the previous example, we can apply the city name restriction in "
"<literal>WHERE</literal>, since it needs no aggregate. This is more "
"efficient than adding the restriction to <literal>HAVING</literal>, because "
"we avoid doing the grouping and aggregate calculations for all rows that "
"fail the <literal>WHERE</literal> check."
msgstr ""
"В предыдущем примере мы смогли применить фильтр по названию города в "
"предложении <literal>WHERE</literal>, так как названия не нужно "
"агрегировать. Такой фильтр эффективнее, чем дополнительное ограничение "
"<literal>HAVING</literal>, потому что с ним не приходится группировать и "
"вычислять агрегаты для всех строк, не удовлетворяющих условию "
"<literal>WHERE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:802(title)
msgid "Updates"
msgstr "Изменение данных"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:804(indexterm)
msgid "<primary>UPDATE</primary>"
msgstr "<primary>UPDATE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:815(programlisting)
#, no-wrap
msgid ""
"UPDATE weather\n"
"    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2\n"
"    WHERE date &gt; '1994-11-28';"
msgstr ""
"UPDATE weather\n"
"    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2\n"
"    WHERE date &gt; '1994-11-28';"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:808(para)
msgid ""
"You can update existing rows using the <command>UPDATE</command> command. "
"Suppose you discover the temperature readings are all off by 2 degrees after "
"November 28. You can correct the data as follows: <placeholder-1/>"
msgstr ""
"Данные в существующих строках можно изменять, используя команду "
"<command>UPDATE</command>. Например, предположим, что вы обнаружили, что все "
"значения температуры после 28 ноября завышены на два градуса. Вы можете "
"поправить ваши данные следующим образом: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:824(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM weather;\n"
"\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
" San Francisco |      41 |      55 |    0 | 1994-11-29\n"
" Hayward       |      35 |      52 |      | 1994-11-29\n"
"(3 rows)"
msgstr ""
"SELECT * FROM weather;\n"
"\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
" San Francisco |      41 |      55 |    0 | 1994-11-29\n"
" Hayward       |      35 |      52 |      | 1994-11-29\n"
"(3 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:822(para)
msgid "Look at the new state of the data: <placeholder-1/>"
msgstr "Посмотрите на новое состояние данных: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:838(title)
msgid "Deletions"
msgstr "Удаление данных"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:840(indexterm)
msgid "<primary>DELETE</primary>"
msgstr "<primary>DELETE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:849(programlisting)
#, no-wrap
msgid "DELETE FROM weather WHERE city = 'Hayward';"
msgstr "DELETE FROM weather WHERE city = 'Hayward';"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:844(para)
msgid ""
"Rows can be removed from a table using the <command>DELETE</command> "
"command. Suppose you are no longer interested in the weather of Hayward. "
"Then you can do the following to delete those rows from the table: "
"<placeholder-1/> All weather records belonging to Hayward are removed. "
"<placeholder-2/> <screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
" San Francisco |      41 |      55 |    0 | 1994-11-29\n"
"(2 rows)\n"
"</screen>"
msgstr ""
"Строки также можно удалить из таблицы, используя команду <command>DELETE</"
"command>. Предположим, что вас больше не интересует погода в Хейуорде. В "
"этом случае вы можете удалить ненужные строки из таблицы: <placeholder-1/> "
"Записи всех наблюдений, относящиеся к Хейуорду, удалены. <placeholder-2/> "
"<screen>\n"
"     city      | temp_lo | temp_hi | prcp |    date\n"
"---------------+---------+---------+------+------------\n"
" San Francisco |      46 |      50 | 0.25 | 1994-11-27\n"
" San Francisco |      41 |      55 |    0 | 1994-11-29\n"
"(2 rows)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:868(para)
msgid ""
"One should be wary of statements of the form <synopsis>\n"
"DELETE FROM <replaceable>tablename</replaceable>;\n"
"</synopsis> Without a qualification, <command>DELETE</command> will remove "
"<emphasis>all</emphasis> rows from the given table, leaving it empty. The "
"system will not request confirmation before doing this!"
msgstr ""
"Остерегайтесь операторов вида <synopsis>\n"
"DELETE FROM <replaceable>имя_таблицы</replaceable>;\n"
"</synopsis> Без указания условия <command>DELETE</command> удалит "
"<emphasis>все</emphasis> строки данной таблицы, полностью очистит её. При "
"этом система не попросит вас подтвердить операцию!"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: query.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
