# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: xoper.xml:5(title)
msgid "User-defined Operators"
msgstr "Пользовательские операторы"

#: xoper.xml:7(indexterm)
msgid "<primary>operator</primary> <secondary>user-defined</secondary>"
msgstr "<primary>оператор</primary> <secondary>пользовательский</secondary>"

#: xoper.xml:12(para)
msgid ""
"Every operator is <quote>syntactic sugar</quote> for a call to an underlying "
"function that does the real work; so you must first create the underlying "
"function before you can create the operator. However, an operator is "
"<emphasis>not merely</emphasis> syntactic sugar, because it carries "
"additional information that helps the query planner optimize queries that "
"use the operator. The next section will be devoted to explaining that "
"additional information."
msgstr ""
"Любой оператор представляет собой <quote>синтаксический сахар</quote> для "
"вызова нижележащей функции, выполняющей реальную работу; поэтому прежде чем "
"вы сможете создать оператор, необходимо создать нижележащую функцию. Однако "
"оператор — <emphasis>не исключительно</emphasis> синтаксический сахар, так "
"как он несёт и дополнительную информацию, помогающую планировщику запросов "
"оптимизировать запросы с этим оператором. Рассмотрению этой дополнительной "
"информации будет посвящён следующий раздел."

#: xoper.xml:26(indexterm)
msgid "<primary>overloading</primary><secondary>operators</secondary>"
msgstr "<primary>перегрузка</primary> <secondary>операторов</secondary>"

#: xoper.xml:23(para)
msgid ""
"<productname>PostgreSQL</productname> supports left unary, right unary, and "
"binary operators. Operators can be overloaded;<placeholder-1/> that is, the "
"same operator name can be used for different operators that have different "
"numbers and types of operands. When a query is executed, the system "
"determines the operator to call from the number and types of the provided "
"operands."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает левые унарные, правые "
"унарные и бинарные операторы. Операторы могут быть перегружены;"
"<placeholder-1/> то есть одно имя оператора могут иметь различные операторы "
"с разным количеством и типами операндов. Когда выполняется запрос, система "
"определяет, какой оператор вызвать, по количеству и типам предоставленных "
"операндов."

#: xoper.xml:39(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION complex_add(complex, complex)\n"
"    RETURNS complex\n"
"    AS '<replaceable>filename</replaceable>', 'complex_add'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE OPERATOR + (\n"
"    leftarg = complex,\n"
"    rightarg = complex,\n"
"    procedure = complex_add,\n"
"    commutator = +\n"
");"
msgstr ""
"CREATE FUNCTION complex_add(complex, complex)\n"
"    RETURNS complex\n"
"    AS '<replaceable>имя_файла</replaceable>', 'complex_add'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE OPERATOR + (\n"
"    leftarg = complex,\n"
"    rightarg = complex,\n"
"    procedure = complex_add,\n"
"    commutator = +\n"
");"

#: xoper.xml:33(para)
msgid ""
"Here is an example of creating an operator for adding two complex numbers. "
"We assume we've already created the definition of type <type>complex</type> "
"(see <xref linkend=\"xtypes\"/>). First we need a function that does the "
"work, then we can define the operator: <placeholder-1/>"
msgstr ""
"В следующем примере создаётся оператор сложения двух комплексных чисел. "
"Предполагается, что мы уже создали определение типа <type>complex</type> "
"(см. <xref remap=\"4\" linkend=\"xtypes\"/>). Сначала нам нужна функция, "
"собственно выполняющая операцию, а затем мы сможем определить оператор: "
"<placeholder-1/>"

#: xoper.xml:54(para)
msgid ""
"Now we could execute a query like this: <screen>\n"
"SELECT (a + b) AS c FROM test_complex;\n"
"\n"
"        c\n"
"-----------------\n"
" (5.2,6.05)\n"
" (133.42,144.95)\n"
"</screen>"
msgstr ""
"Теперь мы можем выполнить такой запрос: <screen>\n"
"SELECT (a + b) AS c FROM test_complex;\n"
"\n"
"        c\n"
"-----------------\n"
" (5.2,6.05)\n"
" (133.42,144.95)\n"
"</screen>"

#: xoper.xml:67(para)
msgid ""
"We've shown how to create a binary operator here. To create unary operators, "
"just omit one of <literal>leftarg</literal> (for left unary) or "
"<literal>rightarg</literal> (for right unary). The <literal>procedure</"
"literal> clause and the argument clauses are the only required items in "
"<command>CREATE OPERATOR</command>. The <literal>commutator</literal> clause "
"shown in the example is an optional hint to the query optimizer. Further "
"details about <literal>commutator</literal> and other optimizer hints appear "
"in the next section."
msgstr ""
"Мы продемонстрировали создание бинарного оператора. Чтобы создать унарный "
"оператор, просто опустите <literal>leftarg</literal> (для левого унарного) "
"или <literal>rightarg</literal> (для правого унарного). Обязательными в "
"<command>CREATE OPERATOR</command> являются только предложение "
"<literal>procedure</literal> и объявления аргументов. Предложение "
"<literal>commutator</literal>, добавленное в данном примере, представляет "
"необязательную подсказку для оптимизатора запросов. Подробнее о "
"<literal>commutator</literal> и других подсказках для оптимизатора "
"рассказывается в следующем разделе."

#: xoper.xml:80(title)
msgid "Operator Optimization Information"
msgstr "Информация для оптимизации операторов"

#: xoper.xml:82(para)
msgid ""
"A <productname>PostgreSQL</productname> operator definition can include "
"several optional clauses that tell the system useful things about how the "
"operator behaves. These clauses should be provided whenever appropriate, "
"because they can make for considerable speedups in execution of queries that "
"use the operator. But if you provide them, you must be sure that they are "
"right! Incorrect use of an optimization clause can result in slow queries, "
"subtly wrong output, or other Bad Things. You can always leave out an "
"optimization clause if you are not sure about it; the only consequence is "
"that queries might run slower than they need to."
msgstr ""
"Определение оператора в <productname>PostgreSQL</productname> может включать "
"различные дополнительные предложения, которые сообщают системе полезные "
"сведения о поведении оператора. Старайтесь задавать эти предложения при "
"возможности, так как они могут значительно ускорить выполнение запросов, "
"использующих данный оператор. Но если вы задаёте их, убедитесь, что они "
"корректны! Неправильное применение предложений оптимизации может привести к "
"замедлению запросов, неочевидным ошибочным результатам и другим "
"неприятностям. Если вы не уверены в правильности предложения оптимизации, "
"лучше вовсе не использовать его; единственным последствием будет то, что "
"запросы будут работать медленнее, чем могли бы."

#: xoper.xml:95(para)
msgid ""
"Additional optimization clauses might be added in future versions of "
"<productname>PostgreSQL</productname>. The ones described here are all the "
"ones that release &version; understands."
msgstr ""
"В будущих версиях <productname>PostgreSQL</productname> могут быть добавлены "
"и другие предложения. Здесь описываются те, что поддерживаются версией "
"&version;."

#: xoper.xml:102(literal)
msgid "COMMUTATOR"
msgstr "COMMUTATOR"

#: xoper.xml:104(para)
msgid ""
"The <literal>COMMUTATOR</literal> clause, if provided, names an operator "
"that is the commutator of the operator being defined. We say that operator A "
"is the commutator of operator B if (x A y) equals (y B x) for all possible "
"input values x, y. Notice that B is also the commutator of A. For example, "
"operators <literal>&lt;</literal> and <literal>&gt;</literal> for a "
"particular data type are usually each others' commutators, and operator "
"<literal>+</literal> is usually commutative with itself. But operator "
"<literal>-</literal> is usually not commutative with anything."
msgstr ""
"Предложение <literal>COMMUTATOR</literal>, если представлено, задаёт "
"оператор, коммутирующий для определяемого. Оператор A является коммутирующим "
"для оператора B, если (x A y) равняется (y B x) для всех возможных значений "
"x, y. Заметьте, что B также будет коммутирующим для A. Например, операторы "
"<literal>&lt;</literal> и <literal>&gt;</literal> для конкретного типа "
"данных обычно являются коммутирующими друг для друга, а оператор <literal>+</"
"literal> — коммутирующий для себя. Но традиционный оператор <literal>-</"
"literal> коммутирующего не имеет."

#: xoper.xml:114(para)
msgid ""
"The left operand type of a commutable operator is the same as the right "
"operand type of its commutator, and vice versa. So the name of the "
"commutator operator is all that <productname>PostgreSQL</productname> needs "
"to be given to look up the commutator, and that's all that needs to be "
"provided in the <literal>COMMUTATOR</literal> clause."
msgstr ""
"Тип левого операнда оператора должен совпадать с типом правого операнда "
"коммутирующего для него оператора, и наоборот. Поэтому имя коммутирующего "
"оператора — это всё, что <productname>PostgreSQL</productname> должен знать, "
"чтобы найти коммутатор, и всё, что нужно указать в предложении "
"<literal>COMMUTATOR</literal>."

#: xoper.xml:122(para)
msgid ""
"It's critical to provide commutator information for operators that will be "
"used in indexes and join clauses, because this allows the query optimizer to "
"<quote>flip around</quote> such a clause to the forms needed for different "
"plan types. For example, consider a query with a WHERE clause like "
"<literal>tab1.x = tab2.y</literal>, where <literal>tab1.x</literal> and "
"<literal>tab2.y</literal> are of a user-defined type, and suppose that "
"<literal>tab2.y</literal> is indexed. The optimizer cannot generate an index "
"scan unless it can determine how to flip the clause around to <literal>tab2."
"y = tab1.x</literal>, because the index-scan machinery expects to see the "
"indexed column on the left of the operator it is given. "
"<productname>PostgreSQL</productname> will <emphasis>not</emphasis> simply "
"assume that this is a valid transformation &mdash; the creator of the "
"<literal>=</literal> operator must specify that it is valid, by marking the "
"operator with commutator information."
msgstr ""
"Информация о коммутирующих операторах крайне важна для операторов, которые "
"будут применяться в индексах и условиях соединения, так как, используя её, "
"оптимизатор запросов может <quote>переворачивать</quote> такие выражения и "
"получать формы, необходимые для разных типов планов. Например, рассмотрим "
"запрос с предложением WHERE <literal>tab1.x = tab2.y</literal>, где "
"<literal>tab1.x</literal> и <literal>tab2.y</literal> имеют пользовательский "
"тип, и предположим, что у нас есть индекс по столбцу <literal>tab2.y</"
"literal>. Оптимизатор сможет задействовать сканирование по индексу, только "
"если ему удастся перевернуть выражение <literal>tab2.y = tab1.x</literal>, "
"так как механизм сканирования по индексу ожидает, что индексируемый столбец "
"находится слева от оператора. <productname>PostgreSQL</productname> сам по "
"себе <emphasis>не</emphasis> будет полагать, что такое преобразование "
"возможно &mdash; это должен определить создатель оператора <literal>=</"
"literal>, добавив информацию о коммутирующем операторе."

#: xoper.xml:148(para)
msgid ""
"One way is to omit the <literal>COMMUTATOR</literal> clause in the first "
"operator that you define, and then provide one in the second operator's "
"definition. Since <productname>PostgreSQL</productname> knows that "
"commutative operators come in pairs, when it sees the second definition it "
"will automatically go back and fill in the missing <literal>COMMUTATOR</"
"literal> clause in the first definition."
msgstr ""
"Во-первых, можно опустить предложение <literal>COMMUTATOR</literal> для "
"первого оператора, который вы определяете, а затем добавить его в "
"определении второго. Так как <productname>PostgreSQL</productname> знает, "
"что коммутирующие операторы связаны парами, встречая второе определение, он "
"автоматически возвращается к первому и добавляет в него недостающее "
"предложение <literal>COMMUTATOR</literal>."

#: xoper.xml:159(para)
msgid ""
"The other, more straightforward way is just to include <literal>COMMUTATOR</"
"literal> clauses in both definitions. When <productname>PostgreSQL</"
"productname> processes the first definition and realizes that "
"<literal>COMMUTATOR</literal> refers to a nonexistent operator, the system "
"will make a dummy entry for that operator in the system catalog. This dummy "
"entry will have valid data only for the operator name, left and right "
"operand types, and result type, since that's all that "
"<productname>PostgreSQL</productname> can deduce at this point. The first "
"operator's catalog entry will link to this dummy entry. Later, when you "
"define the second operator, the system updates the dummy entry with the "
"additional information from the second definition. If you try to use the "
"dummy operator before it's been filled in, you'll just get an error message."
msgstr ""
"Во-вторых, можно добавить предложение <literal>COMMUTATOR</literal> в оба "
"определения. Когда <productname>PostgreSQL</productname> обрабатывает первое "
"определение и видит, что <literal>COMMUTATOR</literal> ссылается на "
"несуществующий оператор, в системном каталоге создаётся фиктивная запись для "
"этого оператора. В этой фиктивной записи актуальны будут только имя "
"оператора, типы левого и правого операндов, а также тип результата, так как "
"это всё, что <productname>PostgreSQL</productname> может определить в этот "
"момент. Запись первого оператора будет связана с этой фиктивной записью. "
"Затем, когда вы определите второй оператор, система внесёт в эту фиктивную "
"запись дополнительную информацию из второго определения. Если вы попытаетесь "
"применить фиктивный оператор, прежде чем он будет полностью определён, вы "
"просто получите сообщение об ошибке."

#: xoper.xml:139(para)
msgid ""
"When you are defining a self-commutative operator, you just do it. When you "
"are defining a pair of commutative operators, things are a little trickier: "
"how can the first one to be defined refer to the other one, which you "
"haven't defined yet? There are two solutions to this problem: <placeholder-1/"
">"
msgstr ""
"Когда вы определяете оператор, коммутирующий сам для себя, вы делаете именно "
"это. Если же вы определяете пару коммутирующих операторов, возникает "
"небольшое затруднение: как оператор, определяемый первым, может ссылаться на "
"другой, ещё не определённый? Есть два решения этой проблемы: <placeholder-1/>"

#: xoper.xml:179(literal)
msgid "NEGATOR"
msgstr "NEGATOR"

#: xoper.xml:181(para)
msgid ""
"The <literal>NEGATOR</literal> clause, if provided, names an operator that "
"is the negator of the operator being defined. We say that operator A is the "
"negator of operator B if both return Boolean results and (x A y) equals NOT "
"(x B y) for all possible inputs x, y. Notice that B is also the negator of "
"A. For example, <literal>&lt;</literal> and <literal>&gt;=</literal> are a "
"negator pair for most data types. An operator can never validly be its own "
"negator."
msgstr ""
"Предложение <literal>NEGATOR</literal>, если присутствует, задаёт оператор, "
"обратный к определяемому. Оператор A является обратным к оператору B, если "
"они оба возвращают булевский результат и (x A y) равняется NOT (x B y) для "
"всех возможных x, y. Заметьте, что B так же является обратным к A. Например, "
"операторы <literal>&lt;</literal> и <literal>&gt;=</literal> составляют пару "
"обратных друг к другу для большинства типов данных. Никакой оператор не "
"может быть обратным к себе же."

#: xoper.xml:191(para)
msgid ""
"Unlike commutators, a pair of unary operators could validly be marked as "
"each other's negators; that would mean (A x) equals NOT (B x) for all x, or "
"the equivalent for right unary operators."
msgstr ""
"В отличие от коммутирующих операторов, два унарных оператора вполне могут "
"быть обратными к друг другу; это будет означать, что (A x) равняется NOT (B "
"x) для всех x (и для правых унарных операторов аналогично)."

#: xoper.xml:197(para)
msgid ""
"An operator's negator must have the same left and/or right operand types as "
"the operator to be defined, so just as with <literal>COMMUTATOR</literal>, "
"only the operator name need be given in the <literal>NEGATOR</literal> "
"clause."
msgstr ""
"У оператора, обратного данному, типы левого и/или правого операнда должны "
"соответствовать типам данного оператора, так же как и с предложением "
"<literal>COMMUTATOR</literal>; отличие только в том, что имя оператора "
"задаётся в предложении <literal>NEGATOR</literal>."

#: xoper.xml:203(para)
msgid ""
"Providing a negator is very helpful to the query optimizer since it allows "
"expressions like <literal>NOT (x = y)</literal> to be simplified into "
"<literal>x &lt;&gt; y</literal>. This comes up more often than you might "
"think, because <literal>NOT</literal> operations can be inserted as a "
"consequence of other rearrangements."
msgstr ""
"Указание обратного оператора очень полезно для оптимизатора запросов, так "
"как это позволяет упростить выражение вида <literal>NOT (x = y)</literal> до "
"<literal>x &lt;&gt; y</literal>. Такие выражения не так редки, как может "
"показаться, так как операции <literal>NOT</literal> могут добавляться "
"автоматически в результате реорганизаций выражений."

#: xoper.xml:210(para)
msgid ""
"Pairs of negator operators can be defined using the same methods explained "
"above for commutator pairs."
msgstr ""
"Пару обратных операторов можно определить теми же способами, что были "
"описаны ранее для пары коммутирующих."

#: xoper.xml:218(literal)
msgid "RESTRICT"
msgstr "RESTRICT"

#: xoper.xml:227(programlisting)
#, no-wrap
msgid "column OP constant"
msgstr "column OP constant"

#: xoper.xml:220(para)
msgid ""
"The <literal>RESTRICT</literal> clause, if provided, names a restriction "
"selectivity estimation function for the operator. (Note that this is a "
"function name, not an operator name.) <literal>RESTRICT</literal> clauses "
"only make sense for binary operators that return <type>boolean</type>. The "
"idea behind a restriction selectivity estimator is to guess what fraction of "
"the rows in a table will satisfy a <literal>WHERE</literal>-clause condition "
"of the form: <placeholder-1/> for the current operator and a particular "
"constant value. This assists the optimizer by giving it some idea of how "
"many rows will be eliminated by <literal>WHERE</literal> clauses that have "
"this form. (What happens if the constant is on the left, you might be "
"wondering? Well, that's one of the things that <literal>COMMUTATOR</literal> "
"is for...)"
msgstr ""
"Предложение <literal>RESTRICT</literal>, если представлено, определяет "
"функцию оценки избирательности ограничения для оператора. (Заметьте, что в "
"нём задаётся имя функции, а не оператора.) Предложения <literal>RESTRICT</"
"literal> имеют смысл только для бинарных операторов, возвращающих "
"<type>boolean</type>. Идея оценки избирательности ограничения заключается в "
"том, чтобы определить, какой процент строк в таблице будет удовлетворять "
"условию <literal>WHERE</literal> вида: <placeholder-1/> для текущего "
"оператора и определённого значения константы. Это помогает оптимизатору "
"примерно определить, сколько строк будет исключено предложениями "
"<literal>WHERE</literal> такого вида. (ВЫ спросите, а что если константа "
"находится слева? Ну, собственно для таких случаев и задаётся "
"<literal>COMMUTATOR</literal>...)"

#: xoper.xml:244(function)
msgid "eqsel"
msgstr "eqsel"

#: xoper.xml:244(literal) xoper.xml:312(literal)
msgid "="
msgstr "="

#: xoper.xml:244(member) xoper.xml:245(member) xoper.xml:312(member)
#: xoper.xml:313(member)
msgid "<placeholder-1/> for <placeholder-2/>"
msgstr "<placeholder-1/> для <placeholder-2/>"

#: xoper.xml:245(function)
msgid "neqsel"
msgstr "neqsel"

#: xoper.xml:245(literal) xoper.xml:313(literal)
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#: xoper.xml:246(function)
msgid "scalarltsel"
msgstr "scalarltsel"

#: xoper.xml:246(literal) xoper.xml:314(literal)
msgid "&lt;"
msgstr "&lt;"

#: xoper.xml:246(literal) xoper.xml:314(literal)
msgid "&lt;="
msgstr "&lt;="

#: xoper.xml:246(member) xoper.xml:247(member) xoper.xml:314(member)
#: xoper.xml:315(member)
msgid "<placeholder-1/> for <placeholder-2/> or <placeholder-3/>"
msgstr "<placeholder-1/> для <placeholder-2/> или <placeholder-3/>"

#: xoper.xml:247(function)
msgid "scalargtsel"
msgstr "scalargtsel"

#: xoper.xml:247(literal) xoper.xml:315(literal)
msgid "&gt;"
msgstr "&gt;"

#: xoper.xml:247(literal) xoper.xml:315(literal)
msgid "&gt;="
msgstr "&gt;="

#: xoper.xml:238(para)
msgid ""
"Writing new restriction selectivity estimation functions is far beyond the "
"scope of this chapter, but fortunately you can usually just use one of the "
"system's standard estimators for many of your own operators. These are the "
"standard restriction estimators: <placeholder-1/> It might seem a little odd "
"that these are the categories, but they make sense if you think about it. "
"<literal>=</literal> will typically accept only a small fraction of the rows "
"in a table; <literal>&lt;&gt;</literal> will typically reject only a small "
"fraction. <literal>&lt;</literal> will accept a fraction that depends on "
"where the given constant falls in the range of values for that table column "
"(which, it just so happens, is information collected by <command>ANALYZE</"
"command> and made available to the selectivity estimator). <literal>&lt;=</"
"literal> will accept a slightly larger fraction than <literal>&lt;</literal> "
"for the same comparison constant, but they're close enough to not be worth "
"distinguishing, especially since we're not likely to do better than a rough "
"guess anyhow. Similar remarks apply to <literal>&gt;</literal> and "
"<literal>&gt;=</literal>."
msgstr ""
"Разработка новых функций оценки избирательности ограничения выходит за рамки "
"данной главы, но обычно можно использовать один из стандартных системных "
"оценщиков для большинства дополнительных операторов. Стандартные оценщики "
"ограничений следующие: <placeholder-1/> Может показаться немного странным, "
"что выбраны именно эти категории, но если подумать, это имеет смысл. "
"Оператор <literal>=</literal> обычно оставляет только небольшой процент "
"строк в таблице, а <literal>&lt;&gt;</literal> отбрасывает то же количество. "
"Оператор <literal>&lt;</literal> оставляет процент, зависящий от того, в "
"какой диапазон значений определённого столбца таблицы попадает заданная "
"константа (информация об этих диапазонах собирается командой "
"<command>ANALYZE</command> и предоставляется оценщику избирательности). "
"Оператор <literal>&lt;=</literal> оставляет чуть больший процент, чем "
"<literal>&lt;</literal>, при сравнении с той же константой, но они настолько "
"близки, что различать их не имеет смысла, так как это не даст лучшего "
"результата, чем просто угадывание. Подобные замечания применимы и к "
"операторам <literal>&gt;</literal> и <literal>&gt;=</literal>."

#: xoper.xml:262(para)
msgid ""
"You can frequently get away with using either <function>eqsel</function> or "
"<function>neqsel</function> for operators that have very high or very low "
"selectivity, even if they aren't really equality or inequality. For example, "
"the approximate-equality geometric operators use <function>eqsel</function> "
"on the assumption that they'll usually only match a small fraction of the "
"entries in a table."
msgstr ""
"Часто вы можете обойтись функциями <function>eqsel</function> и "
"<function>neqsel</function> для операторов с очень высокой или низкой "
"избирательностью, даже если это не операторы собственно равенства или "
"неравенства. Например, геометрические операторы приблизительного равенства "
"используют <function>eqsel</function> в предположении, что соответствующие "
"(равные) элементы будут составлять только небольшой процент от всех записей "
"таблицы."

#: xoper.xml:270(para)
msgid ""
"You can use <function>scalarltsel</function> and <function>scalargtsel</"
"function> for comparisons on data types that have some sensible means of "
"being converted into numeric scalars for range comparisons. If possible, add "
"the data type to those understood by the function "
"<function>convert_to_scalar()</function> in <filename>src/backend/utils/adt/"
"selfuncs.c</filename>. (Eventually, this function should be replaced by per-"
"data-type functions identified through a column of the <classname>pg_type</"
"classname> system catalog; but that hasn't happened yet.) If you do not do "
"this, things will still work, but the optimizer's estimates won't be as good "
"as they could be."
msgstr ""
"Функции <function>scalarltsel</function> и <function>scalargtsel</function> "
"можно использовать для сравнений с типами данных, которые могут быть каким-"
"либо осмысленным образом преобразованы в числовые скалярные значения для "
"сравнения диапазонов. Если возможно, добавьте свой тип данных в число тех, "
"что понимает функция <function>convert_to_scalar()</function> в "
"<filename>src/backend/utils/adt/selfuncs.c</filename>. (Когда-нибудь эта "
"функция должна быть заменена специализированными функциями, которые будут "
"устанавливаться для конкретных типов в определённом столбце системного "
"каталога <classname>pg_type</classname>; но сейчас это не так.) Если вы "
"этого не сделаете, всё будет работать, но оценки оптимизатора будут не так "
"хороши, как могли бы быть."

#: xoper.xml:281(para)
msgid ""
"There are additional selectivity estimation functions designed for geometric "
"operators in <filename>src/backend/utils/adt/geo_selfuncs.c</filename>: "
"<function>areasel</function>, <function>positionsel</function>, and "
"<function>contsel</function>. At this writing these are just stubs, but you "
"might want to use them (or even better, improve them) anyway."
msgstr ""
"Для геометрических операторов разработаны дополнительные функции оценки "
"избирательности в <filename>src/backend/utils/adt/geo_selfuncs.c</filename>: "
"<function>areasel</function>, <function>positionsel</function> и "
"<function>contsel</function>. На момент написания документации это просто "
"заглушки, но вы, тем не менее, вполне можете использовать (или ещё лучше, "
"доработать) их."

#: xoper.xml:290(literal)
msgid "JOIN"
msgstr "JOIN"

#: xoper.xml:299(programlisting)
#, no-wrap
msgid "table1.column1 OP table2.column2"
msgstr "table1.column1 OP table2.column2"

#: xoper.xml:292(para)
msgid ""
"The <literal>JOIN</literal> clause, if provided, names a join selectivity "
"estimation function for the operator. (Note that this is a function name, "
"not an operator name.) <literal>JOIN</literal> clauses only make sense for "
"binary operators that return <type>boolean</type>. The idea behind a join "
"selectivity estimator is to guess what fraction of the rows in a pair of "
"tables will satisfy a <literal>WHERE</literal>-clause condition of the form: "
"<placeholder-1/> for the current operator. As with the <literal>RESTRICT</"
"literal> clause, this helps the optimizer very substantially by letting it "
"figure out which of several possible join sequences is likely to take the "
"least work."
msgstr ""
"Предложение <literal>JOIN</literal>, если представлено, определяет функцию "
"оценки избирательности соединения для оператора. (Заметьте, что в нём "
"задаётся имя функции, а не оператора.) Предложения <literal>JOIN</literal> "
"имеют смысл только для бинарных операторов, возвращающих <type>boolean</"
"type>. Идея оценки избирательности соединения заключается в том, чтобы "
"угадать, какой процент строк в паре таблиц будет удовлетворять условию "
"<literal>WHERE</literal> следующего вида: <placeholder-1/> для текущего "
"оператора. Как и <literal>RESTRICT</literal>, это предложение очень помогает "
"оптимизатору, позволяя ему выяснить, какой из возможных вариантов соединения "
"скорее всего окажется выгоднее."

#: xoper.xml:312(function)
msgid "eqjoinsel"
msgstr "eqjoinsel"

#: xoper.xml:313(function)
msgid "neqjoinsel"
msgstr "neqjoinsel"

#: xoper.xml:314(function)
msgid "scalarltjoinsel"
msgstr "scalarltjoinsel"

#: xoper.xml:315(function)
msgid "scalargtjoinsel"
msgstr "scalargtjoinsel"

#: xoper.xml:316(function)
msgid "areajoinsel"
msgstr "areajoinsel"

#: xoper.xml:316(member)
msgid "<placeholder-1/> for 2D area-based comparisons"
msgstr "<placeholder-1/> для сравнений областей в плоскости"

#: xoper.xml:317(function)
msgid "positionjoinsel"
msgstr "positionjoinsel"

#: xoper.xml:317(member)
msgid "<placeholder-1/> for 2D position-based comparisons"
msgstr "<placeholder-1/> для сравнения положений в плоскости"

#: xoper.xml:318(function)
msgid "contjoinsel"
msgstr "contjoinsel"

#: xoper.xml:318(member)
msgid "<placeholder-1/> for 2D containment-based comparisons"
msgstr "<placeholder-1/> для проверки на включение в плоскости"

#: xoper.xml:307(para)
msgid ""
"As before, this chapter will make no attempt to explain how to write a join "
"selectivity estimator function, but will just suggest that you use one of "
"the standard estimators if one is applicable: <placeholder-1/>"
msgstr ""
"Как и ранее, в этой главе мы не будем пытаться рассказать, как написать "
"функцию оценивания избирательности соединения, а просто отметим, что вы "
"можете использовать один из подходящих стандартных оценщиков: <placeholder-1/"
">"

#: xoper.xml:324(literal)
msgid "HASHES"
msgstr "HASHES"

#: xoper.xml:326(para)
msgid ""
"The <literal>HASHES</literal> clause, if present, tells the system that it "
"is permissible to use the hash join method for a join based on this "
"operator. <literal>HASHES</literal> only makes sense for a binary operator "
"that returns <literal>boolean</literal>, and in practice the operator must "
"represent equality for some data type or pair of data types."
msgstr ""
"Предложение <literal>HASHES</literal>, если присутствует, говорит системе, "
"что для соединений с применением этого оператора допустимо использовать "
"метод соединения по хешу. <literal>HASHES</literal> имеет смысл только для "
"бинарного оператора, который возвращает <literal>boolean</literal>, и на "
"практике этот оператор должен выражать равенство значений некоторого типа "
"данных или пары типов данных."

#: xoper.xml:334(para)
msgid ""
"The assumption underlying hash join is that the join operator can only "
"return true for pairs of left and right values that hash to the same hash "
"code. If two values get put in different hash buckets, the join will never "
"compare them at all, implicitly assuming that the result of the join "
"operator must be false. So it never makes sense to specify <literal>HASHES</"
"literal> for operators that do not represent some form of equality. In most "
"cases it is only practical to support hashing for operators that take the "
"same data type on both sides. However, sometimes it is possible to design "
"compatible hash functions for two or more data types; that is, functions "
"that will generate the same hash codes for <quote>equal</quote> values, even "
"though the values have different representations. For example, it's fairly "
"simple to arrange this property when hashing integers of different widths."
msgstr ""
"Соединение по хешу базируется на том предположении, что оператор соединения "
"возвращает истину только для таких пар значений слева и справа, для которых "
"получается одинаковый хеш. Если два значения оказываются в разных ячейках "
"хеша, операция соединения никогда не будет сравнивать их, неявно "
"подразумевая, что результат оператора соединения в этом случае должен быть "
"ложным. Поэтому не имеет никакого смысла указывать <literal>HASHES</literal> "
"для операторов, которые не представляют какую-любо форму равенства. В "
"большинстве случаев практический смысл в поддержке хеширования есть только "
"для операторов, принимающих один тип данных с обеих сторон. Однако иногда "
"возможно разработать хеш-функции, совместимые сразу с несколькими типами "
"данных; то есть, функции, которые будут выдавать одинаковые хеш-коды для "
"<quote>равных</quote> значений, несмотря на то, что эти значения будут "
"представлены по-разному. Например, довольно легко функции с такой "
"особенностью реализуются для хеширования целых чисел различного размера."

#: xoper.xml:350(para)
msgid ""
"To be marked <literal>HASHES</literal>, the join operator must appear in a "
"hash index operator family. This is not enforced when you create the "
"operator, since of course the referencing operator family couldn't exist "
"yet. But attempts to use the operator in hash joins will fail at run time if "
"no such operator family exists. The system needs the operator family to find "
"the data-type-specific hash function(s) for the operator's input data "
"type(s). Of course, you must also create suitable hash functions before you "
"can create the operator family."
msgstr ""
"Чтобы оператор соединения имел характеристику <literal>HASHES</literal>, он "
"должен входить в семейство операторов индексирования по хешу. Это требование "
"откладывается, когда оператор только создаётся, ведь нужное семейство "
"операторов, разумеется, ещё не может существовать. Но при попытке "
"использовать такой оператор для соединения по хешу, возникнет ошибка во "
"время выполнения, если такого семейства не окажется. Системе необходимо "
"знать семейство операторов, чтобы найти функции для хеширования типа(ов) "
"входных данных оператора. Конечно, вы должны также определить подходящие "
"функции хеширования, прежде чем сможете создать семейство операторов."

#: xoper.xml:361(para)
msgid ""
"Care should be exercised when preparing a hash function, because there are "
"machine-dependent ways in which it might fail to do the right thing. For "
"example, if your data type is a structure in which there might be "
"uninteresting pad bits, you cannot simply pass the whole structure to "
"<function>hash_any</function>. (Unless you write your other operators and "
"functions to ensure that the unused bits are always zero, which is the "
"recommended strategy.) Another example is that on machines that meet the "
"<acronym>IEEE</acronym> floating-point standard, negative zero and positive "
"zero are different values (different bit patterns) but they are defined to "
"compare equal. If a float value might contain negative zero then extra steps "
"are needed to ensure it generates the same hash value as positive zero."
msgstr ""
"При подготовке функции хеширования обязательно позаботьтесь о том, чтобы она "
"всегда выдавала нужный результат, вне зависимости от особенностей машинной "
"архитектуры. Например, если ваш тип данных представлен в структуре, в "
"которой есть незначащие дополняющие биты, нельзя просто передать всю "
"структуру функции <function>hash_any</function>. (Это возможно, только если "
"все ваши операторы и функции гарантированно очищают незначащие биты, что "
"является рекомендуемой стратегией.) В качестве другого примера можно "
"привести типы с плавающей точкой в стандарте <acronym>IEEE</acronym>, в "
"которых отрицательный ноль и положительный ноль — различные значения "
"(отличаются на уровне битов), но при сравнении они считаются равными. Если "
"значение с плавающей точкой может содержать отрицательный ноль, требуются "
"дополнительные действия, чтобы для него выдавался тот же хеш, что и для "
"положительного нуля."

#: xoper.xml:376(para)
msgid ""
"A hash-joinable operator must have a commutator (itself if the two operand "
"data types are the same, or a related equality operator if they are "
"different) that appears in the same operator family. If this is not the "
"case, planner errors might occur when the operator is used. Also, it is a "
"good idea (but not strictly required) for a hash operator family that "
"supports multiple data types to provide equality operators for every "
"combination of the data types; this allows better optimization."
msgstr ""
"Оператор соединения по хешу должен иметь коммутирующий (это может быть тот "
"же оператор, если у него два операнда одного типа, либо связанный оператор "
"равенства, в противном случае), относящийся к тому же семейству операторов. "
"В случае его отсутствия, при попытке использования оператора возможны ошибки "
"планировщика. Также желательно (хотя это строго не требуется), чтобы в "
"семействе операторов хеширования, поддерживающем несколько типов данных, "
"определялись операторы равенства для всех комбинаций этих типов данных; это "
"способствует лучшей оптимизации."

#: xoper.xml:388(para)
msgid ""
"The function underlying a hash-joinable operator must be marked immutable or "
"stable. If it is volatile, the system will never attempt to use the operator "
"for a hash join."
msgstr ""
"Функция, реализующая оператор соединения по хешу, должна быть постоянной "
"(IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), "
"система никогда не будет применять этот оператор для соединения по хешу."

#: xoper.xml:396(para)
msgid ""
"If a hash-joinable operator has an underlying function that is marked "
"strict, the function must also be complete: that is, it should return true "
"or false, never null, for any two nonnull inputs. If this rule is not "
"followed, hash-optimization of <literal>IN</literal> operations might "
"generate wrong results. (Specifically, <literal>IN</literal> might return "
"false where the correct answer according to the standard would be null; or "
"it might yield an error complaining that it wasn't prepared for a null "
"result.)"
msgstr ""
"Если оператор соединения по хешу реализуется строгой функцией (STRICT), эта "
"функция также должна быть полной: то есть она должна возвращать true или "
"false, но не NULL, для любых двух аргументов, отличных от NULL. Если это "
"правило не соблюдается, оптимизация операций <literal>IN</literal> с хешем "
"может приводить к неверным результатам. (В частности, выражение <literal>IN</"
"literal> может вернуть false, когда правильным ответом, согласно стандарту, "
"должен быть NULL, либо выдать ошибку с сообщением о том, что оно не готов к "
"результату NULL.)"

#: xoper.xml:412(literal)
msgid "MERGES"
msgstr "MERGES"

#: xoper.xml:414(para)
msgid ""
"The <literal>MERGES</literal> clause, if present, tells the system that it "
"is permissible to use the merge-join method for a join based on this "
"operator. <literal>MERGES</literal> only makes sense for a binary operator "
"that returns <literal>boolean</literal>, and in practice the operator must "
"represent equality for some data type or pair of data types."
msgstr ""
"Предложение <literal>MERGES</literal>, если присутствует, говорит системе, "
"что для соединений с применением этого оператора допустимо использовать "
"метод соединения слиянием. <literal>MERGES</literal> имеет смысл только для "
"бинарного оператора, который возвращает <literal>boolean</literal>, и на "
"практике этот оператор должен выражать равенство значений некоторого типа "
"данных или пары типов данных."

#: xoper.xml:422(para)
msgid ""
"Merge join is based on the idea of sorting the left- and right-hand tables "
"into order and then scanning them in parallel. So, both data types must be "
"capable of being fully ordered, and the join operator must be one that can "
"only succeed for pairs of values that fall at the <quote>same place</quote> "
"in the sort order. In practice this means that the join operator must behave "
"like equality. But it is possible to merge-join two distinct data types so "
"long as they are logically compatible. For example, the <type>smallint</"
"type>-versus-<type>integer</type> equality operator is merge-joinable. We "
"only need sorting operators that will bring both data types into a logically "
"compatible sequence."
msgstr ""
"Идея объединения слиянием заключается в упорядочивании таблиц слева и справа "
"и затем параллельном сканировании их. Поэтому оба типа данных должны "
"поддерживать сортировку в полном объёме, а оператор соединения должен давать "
"положительный результат только для пар значений, оказавшихся в <quote>одном "
"месте</quote> при определённом порядке сортировки. На практике это означает, "
"что оператор соединения должен работать как проверка на равенство. Но при "
"этом возможно объединить слиянием два различных типа данных, если они "
"совместимы логически. Например, оператор проверки равенства <type>smallint</"
"type> и <type>integer</type> может применяться для соединений слиянием; "
"понадобятся только операторы сортировки, приводящие оба типа данных в "
"логически совместимые последовательности."

#: xoper.xml:437(para)
msgid ""
"To be marked <literal>MERGES</literal>, the join operator must appear as an "
"equality member of a <literal>btree</literal> index operator family. This is "
"not enforced when you create the operator, since of course the referencing "
"operator family couldn't exist yet. But the operator will not actually be "
"used for merge joins unless a matching operator family can be found. The "
"<literal>MERGES</literal> flag thus acts as a hint to the planner that it's "
"worth looking for a matching operator family."
msgstr ""
"Чтобы оператор соединения имел характеристику <literal>MERGES</literal>, он "
"должен являться членом семейства операторов индекса <literal>btree</"
"literal>, реализующим равенство. Это требование откладывается, когда "
"оператор только создаётся, ведь нужное семейство операторов, разумеется, ещё "
"не может существовать. Но этот оператор не будет фактически применяться для "
"соединений слиянием, пока не будет найдено соответствующее семейство "
"операторов. Таким образом, флаг <literal>MERGES</literal> только "
"подсказывает планировщику, что стоит обратиться к соответствующему семейству."

#: xoper.xml:448(para)
msgid ""
"A merge-joinable operator must have a commutator (itself if the two operand "
"data types are the same, or a related equality operator if they are "
"different) that appears in the same operator family. If this is not the "
"case, planner errors might occur when the operator is used. Also, it is a "
"good idea (but not strictly required) for a <literal>btree</literal> "
"operator family that supports multiple data types to provide equality "
"operators for every combination of the data types; this allows better "
"optimization."
msgstr ""
"Оператор соединения слиянием должен иметь коммутирующий (это может быть тот "
"же оператор, если у него два операнда одного типа, либо связанный оператор "
"равенства, в противном случае), относящийся к тому же семейству операторов. "
"В случае его отсутствия, при попытке использования оператора возможны ошибки "
"планировщика. Также желательно (хотя это строго не требуется), чтобы в "
"семействе операторов <literal>btree</literal>, поддерживающем несколько "
"типов данных, определялись операторы равенства для всех комбинаций этих "
"типов данных; это способствует лучшей оптимизации."

#: xoper.xml:460(para)
msgid ""
"The function underlying a merge-joinable operator must be marked immutable "
"or stable. If it is volatile, the system will never attempt to use the "
"operator for a merge join."
msgstr ""
"Функция, реализующая оператор соединения слиянием, должна быть постоянной "
"(IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), "
"система никогда не будет применять этот оператор для соединения слиянием."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xoper.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
