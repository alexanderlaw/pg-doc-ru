# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: tablefunc.xml:5(title)
msgid "tablefunc"
msgstr "tablefunc"

#: tablefunc.xml:7(indexterm)
msgid "<primary>tablefunc</primary>"
msgstr "<primary>tablefunc</primary>"

#: tablefunc.xml:11(para)
msgid ""
"The <filename>tablefunc</filename> module includes various functions that "
"return tables (that is, multiple rows). These functions are useful both in "
"their own right and as examples of how to write C functions that return "
"multiple rows."
msgstr ""
"Модуль <filename>tablefunc</filename> содержит ряд функций, возвращающих "
"таблицы (то есть, множества строк). Эти функции полезны и сами по себе, и "
"как примеры написания на C функций, возвращающих наборы строк."

#: tablefunc.xml:19(title)
msgid "Functions Provided"
msgstr "Предоставляемые функции"

#: tablefunc.xml:21(para)
msgid ""
"<xref linkend=\"tablefunc-functions\"/> shows the functions provided by the "
"<filename>tablefunc</filename> module."
msgstr ""
"Функции, предоставляемые модулем <filename>tablefunc</filename>, перечислены "
"в <xref remap=\"6\" linkend=\"tablefunc-functions\"/>."

#: tablefunc.xml:27(title)
msgid "<filename>tablefunc</filename> Functions"
msgstr "Функции <filename>tablefunc</filename>"

#: tablefunc.xml:31(entry)
msgid "Function"
msgstr "Функция"

#: tablefunc.xml:32(entry)
msgid "Returns"
msgstr "Возвращает"

#: tablefunc.xml:33(entry) tablefunc.xml:660(entry)
msgid "Description"
msgstr "Описание"

#: tablefunc.xml:38(function)
msgid "normal_rand(int numvals, float8 mean, float8 stddev)"
msgstr "normal_rand(int numvals, float8 mean, float8 stddev)"

#: tablefunc.xml:39(type)
msgid "setof float8"
msgstr "setof float8"

#: tablefunc.xml:40(entry)
msgid "Produces a set of normally distributed random values"
msgstr "Выдаёт набор случайных значений, имеющих нормальное распределение"

#: tablefunc.xml:45(function)
msgid "crosstab(text sql)"
msgstr "crosstab(text sql)"

#: tablefunc.xml:46(type) tablefunc.xml:67(type) tablefunc.xml:75(type)
#: tablefunc.xml:92(type)
msgid "setof record"
msgstr "setof record"

#: tablefunc.xml:47(entry)
msgid ""
"Produces a <quote>pivot table</quote> containing row names plus "
"<replaceable>N</replaceable> value columns, where <replaceable>N</"
"replaceable> is determined by the row type specified in the calling query"
msgstr ""
"Выдаёт <quote>повёрнутую таблицу</quote>, содержащую имена строк плюс "
"<replaceable>N</replaceable> столбцов значений, где <replaceable>N</"
"replaceable> определяется видом строк, заданным в вызывающем запросе"

#: tablefunc.xml:55(replaceable) tablefunc.xml:56(replaceable)
#: tablefunc.xml:308(replaceable) tablefunc.xml:315(replaceable)
msgid "N"
msgstr "N"

#: tablefunc.xml:55(function)
msgctxt "function"
msgid "crosstab<placeholder-1/>(text sql)"
msgstr "crosstab<placeholder-1/>(text sql)"

#: tablefunc.xml:56(type)
msgid "setof table_crosstab_<placeholder-1/>"
msgstr "setof table_crosstab_<placeholder-1/>"

#: tablefunc.xml:57(entry)
msgid ""
"Produces a <quote>pivot table</quote> containing row names plus "
"<replaceable>N</replaceable> value columns. <function>crosstab2</function>, "
"<function>crosstab3</function>, and <function>crosstab4</function> are "
"predefined, but you can create additional <function>crosstab<replaceable>N</"
"replaceable></function> functions as described below"
msgstr ""
"Выдаёт <quote>повёрнутую таблицу</quote>, содержащую имена строк плюс "
"<replaceable>N</replaceable> столбцов значений. Функции <function>crosstab2</"
"function>, <function>crosstab3</function> и <function>crosstab4</function> "
"предопределены, но вы можете создать дополнительные функции "
"<function>crosstab<replaceable>N</replaceable></function>, как описано ниже"

#: tablefunc.xml:66(function)
msgctxt "function"
msgid "crosstab(text source_sql, text category_sql)"
msgstr "crosstab(text source_sql, text category_sql)"

#: tablefunc.xml:68(entry)
msgid ""
"Produces a <quote>pivot table</quote> with the value columns specified by a "
"second query"
msgstr ""
"Выдаёт <quote>повёрнутую таблицу</quote> со столбцами значений, заданными "
"вторым запросом"

#: tablefunc.xml:74(function)
msgid "crosstab(text sql, int N)"
msgstr "crosstab(text sql, int N)"

#: tablefunc.xml:77(para)
msgid ""
"Obsolete version of <function>crosstab(text)</function>. The parameter "
"<replaceable>N</replaceable> is now ignored, since the number of value "
"columns is always determined by the calling query"
msgstr ""
"Устаревшая версия <function>crosstab(text)</function>. Параметр "
"<replaceable>N</replaceable> теперь игнорируется, так как число столбцов "
"значений всегда определяется вызывающим запросом"

#: tablefunc.xml:85(function)
msgid ""
"connectby(text relname, text keyid_fld, text parent_keyid_fld [, text "
"orderby_fld ], text start_with, int max_depth [, text branch_delim ])"
msgstr ""
"connectby(text relname, text keyid_fld, text parent_keyid_fld [, text "
"orderby_fld ], text start_with, int max_depth [, text branch_delim ])"

#: tablefunc.xml:90(indexterm) tablefunc.xml:631(indexterm)
msgid "<primary>connectby</primary>"
msgstr "<primary>connectby</primary>"

#: tablefunc.xml:93(entry)
msgid "Produces a representation of a hierarchical tree structure"
msgstr "Выдаёт представление иерархической древовидной структуры"

#: tablefunc.xml:102(function)
msgid "normal_rand"
msgstr "normal_rand"

#: tablefunc.xml:104(indexterm)
msgid "<primary>normal_rand</primary>"
msgstr "<primary>normal_rand</primary>"

#: tablefunc.xml:108(synopsis)
#, no-wrap
msgid "normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8"
msgstr "normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8"

#: tablefunc.xml:112(para)
msgid ""
"<function>normal_rand</function> produces a set of normally distributed "
"random values (Gaussian distribution)."
msgstr ""
"Функция <function>normal_rand</function> выдаёт набор случайных значений, "
"имеющих нормальное распределение (распределение Гаусса)."

#: tablefunc.xml:117(para)
msgid ""
"<parameter>numvals</parameter> is the number of values to be returned from "
"the function. <parameter>mean</parameter> is the mean of the normal "
"distribution of values and <parameter>stddev</parameter> is the standard "
"deviation of the normal distribution of values."
msgstr ""
"Параметр <parameter>numvals</parameter> задаёт количество значений, которое "
"выдаст эта функция. Параметр <parameter>mean</parameter> задаёт медиану "
"нормального распределения, а <parameter>stddev</parameter> — стандартное "
"отклонение."

#: tablefunc.xml:124(para)
msgid ""
"For example, this call requests 1000 values with a mean of 5 and a standard "
"deviation of 3:"
msgstr ""
"Например, этот вызов запрашивает 1000 значений с медианой 5 и стандартным "
"отклонением 3:"

#: tablefunc.xml:129(screen)
#, no-wrap
msgid ""
"test=# SELECT * FROM normal_rand(1000, 5, 3);\n"
"     normal_rand\n"
"----------------------\n"
"     1.56556322244898\n"
"     9.10040991424657\n"
"     5.36957140345079\n"
"   -0.369151492880995\n"
"    0.283600703686639\n"
"       .\n"
"       .\n"
"       .\n"
"     4.82992125404908\n"
"     9.71308014517282\n"
"     2.49639286969028\n"
"(1000 rows)"
msgstr ""
"test=# SELECT * FROM normal_rand(1000, 5, 3);\n"
"     normal_rand\n"
"----------------------\n"
"     1.56556322244898\n"
"     9.10040991424657\n"
"     5.36957140345079\n"
"   -0.369151492880995\n"
"    0.283600703686639\n"
"       .\n"
"       .\n"
"       .\n"
"     4.82992125404908\n"
"     9.71308014517282\n"
"     2.49639286969028\n"
"(1000 rows)"

#: tablefunc.xml:149(function)
msgid "crosstab(text)"
msgstr "crosstab(text)"

#: tablefunc.xml:151(indexterm) tablefunc.xml:310(indexterm)
#: tablefunc.xml:421(indexterm)
msgid "<primary>crosstab</primary>"
msgstr "<primary>crosstab</primary>"

#: tablefunc.xml:155(synopsis)
#, no-wrap
msgid ""
"crosstab(text sql)\n"
"crosstab(text sql, int N)"
msgstr ""
"crosstab(text sql)\n"
"crosstab(text sql, int N)"

#: tablefunc.xml:164(programlisting)
#, no-wrap
msgid ""
"row1    val11\n"
"row1    val12\n"
"row1    val13\n"
"...\n"
"row2    val21\n"
"row2    val22\n"
"row2    val23\n"
"..."
msgstr ""
"row1    val11\n"
"row1    val12\n"
"row1    val13\n"
"...\n"
"row2    val21\n"
"row2    val22\n"
"row2    val23\n"
"..."

#: tablefunc.xml:175(programlisting)
#, no-wrap
msgid ""
"row1    val11   val12   val13   ...\n"
"row2    val21   val22   val23   ...\n"
"..."
msgstr ""
"row1    val11   val12   val13   ...\n"
"row2    val21   val22   val23   ...\n"
"..."

#: tablefunc.xml:160(para)
msgid ""
"The <function>crosstab</function> function is used to produce <quote>pivot</"
"quote> displays, wherein data is listed across the page rather than down. "
"For example, we might have data like <placeholder-1/> which we wish to "
"display like <placeholder-2/> The <function>crosstab</function> function "
"takes a text parameter that is a SQL query producing raw data formatted in "
"the first way, and produces a table formatted in the second way."
msgstr ""
"Функция <function>crosstab</function> применяется для формирования "
"<quote>повёрнутых</quote> отображений, в которых данные идут вдоль строк, а "
"не сверху вниз. Например, мы можем иметь такие данные: <placeholder-1/> и "
"хотим видеть их так: <placeholder-2/> Функция <function>crosstab</function> "
"принимает в текстовом параметре SQL-запрос, выдающий исходные данные первым "
"способом, и выдаёт таблицу, отформатированную вторым способом."

#: tablefunc.xml:185(para)
msgid ""
"The <parameter>sql</parameter> parameter is a SQL statement that produces "
"the source set of data. This statement must return one "
"<structfield>row_name</structfield> column, one <structfield>category</"
"structfield> column, and one <structfield>value</structfield> column. "
"<parameter>N</parameter> is an obsolete parameter, ignored if supplied "
"(formerly this had to match the number of output value columns, but now that "
"is determined by the calling query)."
msgstr ""
"В параметре <parameter>sql</parameter> передаётся SQL-запрос, выдающий "
"исходный набор данных. Этот запрос должен возвращать один столбец "
"<structfield>row_name</structfield>, один столбец <structfield>category</"
"structfield> и один столбец <structfield>value</structfield>. Параметр "
"<parameter>N</parameter> является устаревшим и игнорируется, если передаётся "
"при вызове (раньше он должен был соответствовать количеству выходных "
"столбцов значений, но теперь это количество определяется вызывающим "
"запросом)."

#: tablefunc.xml:198(programlisting)
#, no-wrap
msgid ""
" row_name    cat    value\n"
"----------+-------+-------\n"
"  row1      cat1    val1\n"
"  row1      cat2    val2\n"
"  row1      cat3    val3\n"
"  row1      cat4    val4\n"
"  row2      cat1    val5\n"
"  row2      cat2    val6\n"
"  row2      cat3    val7\n"
"  row2      cat4    val8"
msgstr ""
" row_name    cat    value\n"
"----------+-------+-------\n"
"  row1      cat1    val1\n"
"  row1      cat2    val2\n"
"  row1      cat3    val3\n"
"  row1      cat4    val4\n"
"  row2      cat1    val5\n"
"  row2      cat2    val6\n"
"  row2      cat3    val7\n"
"  row2      cat4    val8"

#: tablefunc.xml:196(para)
msgid ""
"For example, the provided query might produce a set something like: "
"<placeholder-1/>"
msgstr ""
"Например, заданный запрос может выдавать такой результат: <placeholder-1/>"

#: tablefunc.xml:217(programlisting)
#, no-wrap
msgid "SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);"
msgstr "SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);"

#: tablefunc.xml:221(programlisting)
#, no-wrap
msgid ""
"           &lt;== value  columns  ==&gt;\n"
" row_name   category_1   category_2\n"
"----------+------------+------------\n"
"  row1        val1         val2\n"
"  row2        val5         val6"
msgstr ""
"           &lt;== столбцы значений ==&gt;\n"
" row_name   category_1   category_2\n"
"----------+------------+------------\n"
"  row1        val1         val2\n"
"  row2        val5         val6"

#: tablefunc.xml:212(para)
msgid ""
"The <function>crosstab</function> function is declared to return <type>setof "
"record</type>, so the actual names and types of the output columns must be "
"defined in the <literal>FROM</literal> clause of the calling "
"<command>SELECT</command> statement, for example: <placeholder-1/> This "
"example produces a set something like: <placeholder-2/>"
msgstr ""
"Функция <function>crosstab</function> объявлена как возвращающая <type>setof "
"record</type>, так что фактические имена и типы столбцов должны определяться "
"в предложении <literal>FROM</literal> вызывающего оператора <command>SELECT</"
"command>, например так: <placeholder-1/> Этот запрос выдаст примерно такой "
"результат: <placeholder-2/>"

#: tablefunc.xml:230(para)
msgid ""
"The <literal>FROM</literal> clause must define the output as one "
"<structfield>row_name</structfield> column (of the same data type as the "
"first result column of the SQL query) followed by N <structfield>value</"
"structfield> columns (all of the same data type as the third result column "
"of the SQL query). You can set up as many output value columns as you wish. "
"The names of the output columns are up to you."
msgstr ""
"Предложение <literal>FROM</literal> должно определять результат со столбцом "
"<structfield>row_name</structfield> (того же типа данных, что у первого "
"результирующего столбца SQL-запроса), за которым следуют N столбцов значений "
"(все того же типа данных, что и третий результирующий столбец SQL-запроса). "
"Количество выходных столбцов значений может быть произвольным и имена "
"выходных столбцов определяете вы сами."

#: tablefunc.xml:239(para)
msgid ""
"The <function>crosstab</function> function produces one output row for each "
"consecutive group of input rows with the same <structfield>row_name</"
"structfield> value. It fills the output <structfield>value</structfield> "
"columns, left to right, with the <structfield>value</structfield> fields "
"from these rows. If there are fewer rows in a group than there are output "
"<structfield>value</structfield> columns, the extra output columns are "
"filled with nulls; if there are more rows, the extra input rows are skipped."
msgstr ""
"Функция <function>crosstab</function> выдаёт одну выходную строку для каждой "
"последовательной группы с одним значением <structfield>row_name</"
"structfield>. Она заполняет столбцы значений слева направо полями "
"<structfield>value</structfield> из этих строк. Если в группе оказывается "
"меньше строк, чем выходных столбцов значений, дополнительные столбцы "
"принимают значения NULL; если же строк оказывается больше, лишние строки "
"игнорируются."

#: tablefunc.xml:250(para)
msgid ""
"In practice the SQL query should always specify <literal>ORDER BY 1,2</"
"literal> to ensure that the input rows are properly ordered, that is, values "
"with the same <structfield>row_name</structfield> are brought together and "
"correctly ordered within the row. Notice that <function>crosstab</function> "
"itself does not pay any attention to the second column of the query result; "
"it's just there to be ordered by, to control the order in which the third-"
"column values appear across the page."
msgstr ""
"На практике в SQL-запросе всегда должно указываться <literal>ORDER BY 1,2</"
"literal>, чтобы входные строки были отсортированы должным образом, то есть, "
"чтобы данные с одинаковым значением <structfield>row_name</structfield> "
"собирались вместе и корректно упорядочивались в строке. Заметьте, что сама "
"<function>crosstab</function> не учитывает второй столбец результата "
"запроса; он присутствует только для того, чтобы определять порядок, в "
"котором значения третьего столбца будут следовать в строке."

#: tablefunc.xml:262(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');\n"
"\n"
"SELECT *\n"
"FROM crosstab(\n"
"  'select rowid, attribute, value\n"
"   from ct\n"
"   where attribute = ''att2'' or attribute = ''att3''\n"
"   order by 1,2')\n"
"AS ct(row_name text, category_1 text, category_2 text, category_3 text);\n"
"\n"
" row_name | category_1 | category_2 | category_3\n"
"----------+------------+------------+------------\n"
" test1    | val2       | val3       |\n"
" test2    | val6       | val7       |\n"
"(2 rows)"
msgstr ""
"CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');\n"
"INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');\n"
"\n"
"SELECT *\n"
"FROM crosstab(\n"
"  'select rowid, attribute, value\n"
"   from ct\n"
"   where attribute = ''att2'' or attribute = ''att3''\n"
"   order by 1,2')\n"
"AS ct(row_name text, category_1 text, category_2 text, category_3 text);\n"
"\n"
" row_name | category_1 | category_2 | category_3\n"
"----------+------------+------------+------------\n"
" test1    | val2       | val3       |\n"
" test2    | val6       | val7       |\n"
"(2 rows)"

#: tablefunc.xml:260(para)
msgid "Here is a complete example: <placeholder-1/>"
msgstr "Полный пример: <placeholder-1/>"

#: tablefunc.xml:289(para)
msgid ""
"You can avoid always having to write out a <literal>FROM</literal> clause to "
"define the output columns, by setting up a custom crosstab function that has "
"the desired output row type wired into its definition. This is described in "
"the next section. Another possibility is to embed the required "
"<literal>FROM</literal> clause in a view definition."
msgstr ""
"Вы можете в любом случае обойтись без написания предложения <literal>FROM</"
"literal>, определяющего выходные столбцы, создав собственную функцию "
"crosstab, в определении которой будет зашит желательный тип выходной строки. "
"Это описывается в следующем разделе. Также имеется возможность включить "
"требуемое предложение <literal>FROM</literal> в определение представления."

#: tablefunc.xml:298(para)
msgid ""
"See also the <command><link linkend=\"app-psql-meta-commands-crosstabview\">"
"\\crosstabview</link></command> command in <application>psql</application>, "
"which provides functionality similar to <function>crosstab()</function>."
msgstr ""
"Также изучите команду <command><link linkend=\"app-psql-meta-commands-"
"crosstabview\">\\crosstabview</link></command> в <application>psql</"
"application>, реализующую функциональность, подобную <function>crosstab()</"
"function>."

#: tablefunc.xml:308(function)
msgid "crosstab<placeholder-1/>(text)"
msgstr "crosstab<placeholder-1/>(text)"

#: tablefunc.xml:314(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "crosstab<placeholder-1/>(text sql)"
msgstr "crosstab<placeholder-1/>(text sql)"

#: tablefunc.xml:318(para)
msgid ""
"The <function>crosstab<replaceable>N</replaceable></function> functions are "
"examples of how to set up custom wrappers for the general "
"<function>crosstab</function> function, so that you need not write out "
"column names and types in the calling <command>SELECT</command> query. The "
"<filename>tablefunc</filename> module includes <function>crosstab2</"
"function>, <function>crosstab3</function>, and <function>crosstab4</"
"function>, whose output row types are defined as"
msgstr ""
"Функции <function>crosstab<replaceable>N</replaceable></function> являются "
"примерами того, как можно создать собственные обёртки универсальной функции "
"<function>crosstab</function>, чтобы не приходилось выписывать имена и типы "
"столбцов в вызывающем запросе <command>SELECT</command>. Модуль "
"<filename>tablefunc</filename> включает функции <function>crosstab2</"
"function>, <function>crosstab3</function> и <function>crosstab4</function>, "
"определяющие типы выходных строк так:"

#: tablefunc.xml:327(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE tablefunc_crosstab_N AS (\n"
"    row_name TEXT,\n"
"    category_1 TEXT,\n"
"    category_2 TEXT,\n"
"        .\n"
"        .\n"
"        .\n"
"    category_N TEXT\n"
");"
msgstr ""
"CREATE TYPE tablefunc_crosstab_N AS (\n"
"    row_name TEXT,\n"
"    category_1 TEXT,\n"
"    category_2 TEXT,\n"
"        .\n"
"        .\n"
"        .\n"
"    category_N TEXT\n"
");"

#: tablefunc.xml:339(para)
msgid ""
"Thus, these functions can be used directly when the input query produces "
"<structfield>row_name</structfield> and <structfield>value</structfield> "
"columns of type <type>text</type>, and you want 2, 3, or 4 output values "
"columns. In all other ways they behave exactly as described above for the "
"general <function>crosstab</function> function."
msgstr ""
"Таким образом, эти функции могут применяться непосредственно, когда входной "
"запрос выдаёт столбцы <structfield>row_name</structfield> и "
"<structfield>value</structfield> типа <type>text</type> и вы хотите получить "
"на выходе 2, 3 или 4 столбца значений. В остальном эти функции ведут себя в "
"точности так же, как и универсальная функция <function>crosstab</function>."

#: tablefunc.xml:350(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"FROM crosstab3(\n"
"  'select rowid, attribute, value\n"
"   from ct\n"
"   where attribute = ''att2'' or attribute = ''att3''\n"
"   order by 1,2');"
msgstr ""
"SELECT *\n"
"FROM crosstab3(\n"
"  'select rowid, attribute, value\n"
"   from ct\n"
"   where attribute = ''att2'' or attribute = ''att3''\n"
"   order by 1,2');"

#: tablefunc.xml:347(para)
msgid ""
"For instance, the example given in the previous section would also work as "
"<placeholder-1/>"
msgstr ""
"Так, пример, приведённый в предыдущем разделе, можно переписать и в таком "
"виде: <placeholder-1/>"

#: tablefunc.xml:378(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE my_crosstab_float8_5_cols AS (\n"
"    my_row_name text,\n"
"    my_category_1 float8,\n"
"    my_category_2 float8,\n"
"    my_category_3 float8,\n"
"    my_category_4 float8,\n"
"    my_category_5 float8\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)\n"
"    RETURNS setof my_crosstab_float8_5_cols\n"
"    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;"
msgstr ""
"CREATE TYPE my_crosstab_float8_5_cols AS (\n"
"    my_row_name text,\n"
"    my_category_1 float8,\n"
"    my_category_2 float8,\n"
"    my_category_3 float8,\n"
"    my_category_4 float8,\n"
"    my_category_5 float8\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)\n"
"    RETURNS setof my_crosstab_float8_5_cols\n"
"    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;"

#: tablefunc.xml:368(para)
msgid ""
"Create a composite type describing the desired output columns, similar to "
"the examples in <filename>contrib/tablefunc/tablefunc--1.0.sql</filename>. "
"Then define a unique function name accepting one <type>text</type> parameter "
"and returning <type>setof your_type_name</type>, but linking to the same "
"underlying <function>crosstab</function> C function. For example, if your "
"source data produces row names that are <type>text</type>, and values that "
"are <type>float8</type>, and you want 5 value columns: <placeholder-1/>"
msgstr ""
"Создать составной тип, описывающий желаемые выходные столбцы, примерно как "
"это делается в примерах в <filename>contrib/tablefunc/tablefunc--1.0.sql</"
"filename>. Затем нужно выбрать уникальное имя для функции, принимающей один "
"параметр <type>text</type> и возвращающей <type>setof имя_вашего_типа</"
"type>, и связать его с той же нижележащей функцией <function>crosstab</"
"function> на C. Например, если ваш источник данных выдаёт имена строк типа "
"<type>text</type> и значения типа <type>float8</type>, и вы хотите получить "
"5 столбцов значений: <placeholder-1/>"

#: tablefunc.xml:399(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(\n"
"    IN text,\n"
"    OUT my_row_name text,\n"
"    OUT my_category_1 float8,\n"
"    OUT my_category_2 float8,\n"
"    OUT my_category_3 float8,\n"
"    OUT my_category_4 float8,\n"
"    OUT my_category_5 float8)\n"
"  RETURNS setof record\n"
"  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;"
msgstr ""
"CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(\n"
"    IN text,\n"
"    OUT my_row_name text,\n"
"    OUT my_category_1 float8,\n"
"    OUT my_category_2 float8,\n"
"    OUT my_category_3 float8,\n"
"    OUT my_category_4 float8,\n"
"    OUT my_category_5 float8)\n"
"  RETURNS setof record\n"
"  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;"

#: tablefunc.xml:396(para)
msgid ""
"Use <literal>OUT</literal> parameters to define the return type implicitly. "
"The same example could also be done this way: <placeholder-1/>"
msgstr ""
"Использовать выходные параметры (<literal>OUT</literal>), чтобы явно "
"определить возвращаемый тип. Тот же пример можно реализовать и таким "
"способом: <placeholder-1/>"

#: tablefunc.xml:360(para)
msgid ""
"These functions are provided mostly for illustration purposes. You can "
"create your own return types and functions based on the underlying "
"<function>crosstab()</function> function. There are two ways to do it: "
"<placeholder-1/>"
msgstr ""
"Эти функции представлены в основном в демонстрационных целях. Вы можете "
"создать собственные типы возвращаемых данных и реализовать функции на базе "
"нижележащей функции <function>crosstab()</function>. Это можно сделать двумя "
"способами: <placeholder-1/>"

#: tablefunc.xml:419(function)
msgid "crosstab(text, text)"
msgstr "crosstab(text, text)"

#: tablefunc.xml:425(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "crosstab(text source_sql, text category_sql)"
msgstr "crosstab(text source_sql, text category_sql)"

#: tablefunc.xml:429(para)
msgid ""
"The main limitation of the single-parameter form of <function>crosstab</"
"function> is that it treats all values in a group alike, inserting each "
"value into the first available column. If you want the value columns to "
"correspond to specific categories of data, and some groups might not have "
"data for some of the categories, that doesn't work well. The two-parameter "
"form of <function>crosstab</function> handles this case by providing an "
"explicit list of the categories corresponding to the output columns."
msgstr ""
"Основное ограничение формы <function>crosstab</function> с одним параметром "
"состоит в том, что она воспринимает все значения в группе одинаково и "
"вставляет очередное значение в первый свободный столбец. Если вы хотите, "
"чтобы столбцы значений соответствовали определённым категориям данных и "
"некоторые группы могли содержать данные не для всех категорий, этот подход "
"не будет работать. Форма <function>crosstab</function> с двумя параметрами "
"решает эту задачу, принимая явный список категорий, соответствующих выходным "
"столбцам."

#: tablefunc.xml:440(para)
msgid ""
"<parameter>source_sql</parameter> is a SQL statement that produces the "
"source set of data. This statement must return one <structfield>row_name</"
"structfield> column, one <structfield>category</structfield> column, and one "
"<structfield>value</structfield> column. It may also have one or more "
"<quote>extra</quote> columns. The <structfield>row_name</structfield> column "
"must be first. The <structfield>category</structfield> and "
"<structfield>value</structfield> columns must be the last two columns, in "
"that order. Any columns between <structfield>row_name</structfield> and "
"<structfield>category</structfield> are treated as <quote>extra</quote>. The "
"<quote>extra</quote> columns are expected to be the same for all rows with "
"the same <structfield>row_name</structfield> value."
msgstr ""
"В параметре <parameter>source_sql</parameter> передаётся SQL-оператор, "
"выдающий исходный набор данных. Этот оператор должен выдавать строки со "
"столбцом <structfield>row_name</structfield>, столбцом "
"<structfield>category</structfield> и столбцом <structfield>value</"
"structfield>. Также он может выдать один или несколько "
"<quote>дополнительных</quote> столбцов. Столбец <structfield>row_name</"
"structfield> должен быть первым, а столбцы <structfield>category</"
"structfield> и <structfield>value</structfield> — последними двумя, именно в "
"этом порядке. Все столбцы между <structfield>row_name</structfield> и "
"<structfield>category</structfield> воспринимаются как "
"<quote>дополнительные</quote>. Ожидается, что <quote>дополнительные</quote> "
"столбцы будут содержать одинаковые значения для всех строк с одним значением "
"<structfield>row_name</structfield>."

#: tablefunc.xml:459(programlisting)
#, no-wrap
msgid ""
"SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;\n"
"\n"
" row_name    extra_col   cat    value\n"
"----------+------------+-----+---------\n"
"  row1         extra1    cat1    val1\n"
"  row1         extra1    cat2    val2\n"
"  row1         extra1    cat4    val4\n"
"  row2         extra2    cat1    val5\n"
"  row2         extra2    cat2    val6\n"
"  row2         extra2    cat3    val7\n"
"  row2         extra2    cat4    val8"
msgstr ""
"SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;\n"
"\n"
" row_name    extra_col   cat    value\n"
"----------+------------+-----+---------\n"
"  row1         extra1    cat1    val1\n"
"  row1         extra1    cat2    val2\n"
"  row1         extra1    cat4    val4\n"
"  row2         extra2    cat1    val5\n"
"  row2         extra2    cat2    val6\n"
"  row2         extra2    cat3    val7\n"
"  row2         extra2    cat4    val8"

#: tablefunc.xml:456(para)
msgid ""
"For example, <parameter>source_sql</parameter> might produce a set something "
"like: <placeholder-1/>"
msgstr ""
"Например, <parameter>source_sql</parameter> может выдать такой набор данных: "
"<placeholder-1/>"

#: tablefunc.xml:481(programlisting)
#, no-wrap
msgid ""
"SELECT DISTINCT cat FROM foo ORDER BY 1;\n"
"    cat\n"
"  -------\n"
"    cat1\n"
"    cat2\n"
"    cat3\n"
"    cat4"
msgstr ""
"SELECT DISTINCT cat FROM foo ORDER BY 1;\n"
"    cat\n"
"  -------\n"
"    cat1\n"
"    cat2\n"
"    cat3\n"
"    cat4"

#: tablefunc.xml:474(para)
msgid ""
"<parameter>category_sql</parameter> is a SQL statement that produces the set "
"of categories. This statement must return only one column. It must produce "
"at least one row, or an error will be generated. Also, it must not produce "
"duplicate values, or an error will be generated. <parameter>category_sql</"
"parameter> might be something like: <placeholder-1/>"
msgstr ""
"В параметре <parameter>category_sql</parameter> передаётся оператор SQL, "
"выдающий набор категорий. Этот оператор должен возвращать всего один "
"столбец. Он должен выдать минимум одну строку; в противном случае произойдёт "
"ошибка. Кроме того, выдаваемые им значения не должны повторяться, иначе так "
"же произойдёт ошибка. В качестве <parameter>category_sql</parameter> можно "
"передать, например, такой запрос: <placeholder-1/>"

#: tablefunc.xml:498(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM crosstab('...', '...')\n"
"    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);"
msgstr ""
"SELECT * FROM crosstab('...', '...')\n"
"    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);"

#: tablefunc.xml:492(para)
msgid ""
"The <function>crosstab</function> function is declared to return <type>setof "
"record</type>, so the actual names and types of the output columns must be "
"defined in the <literal>FROM</literal> clause of the calling "
"<command>SELECT</command> statement, for example: <placeholder-1/>"
msgstr ""
"Функция <function>crosstab</function> объявлена как возвращающая тип "
"<type>setof record</type>, так что фактические имена и типы выходных "
"столбцов должны определяться в предложении <literal>FROM</literal> "
"вызывающего оператора <command>SELECT</command>, например так: "
"<placeholder-1/>"

#: tablefunc.xml:506(programlisting)
#, no-wrap
msgid ""
"                  &lt;==  value  columns   ==&gt;\n"
"row_name   extra   cat1   cat2   cat3   cat4\n"
"---------+-------+------+------+------+------\n"
"  row1     extra1  val1   val2          val4\n"
"  row2     extra2  val5   val6   val7   val8"
msgstr ""
"                  &lt;==  столбцы значений   ==&gt;\n"
"row_name   extra   cat1   cat2   cat3   cat4\n"
"---------+-------+------+------+------+------\n"
"  row1     extra1  val1   val2          val4\n"
"  row2     extra2  val5   val6   val7   val8"

#: tablefunc.xml:504(para)
msgid "This will produce a result something like: <placeholder-1/>"
msgstr "При этом будет получен примерно такой результат: <placeholder-1/>"

#: tablefunc.xml:515(para)
msgid ""
"The <literal>FROM</literal> clause must define the proper number of output "
"columns of the proper data types. If there are <replaceable>N</replaceable> "
"columns in the <parameter>source_sql</parameter> query's result, the first "
"<replaceable>N</replaceable>-2 of them must match up with the first "
"<replaceable>N</replaceable>-2 output columns. The remaining output columns "
"must have the type of the last column of the <parameter>source_sql</"
"parameter> query's result, and there must be exactly as many of them as "
"there are rows in the <parameter>category_sql</parameter> query's result."
msgstr ""
"В предложении <literal>FROM</literal> должно определяться нужное количество "
"выходных столбцов соответствующих типов данных. Если запрос "
"<parameter>source_sql</parameter> выдаёт <replaceable>N</replaceable> "
"столбцов, первые <replaceable>N</replaceable>-2 из них должны "
"соответствовать первым <replaceable>N</replaceable>-2 выходным столбцам. "
"Оставшиеся выходные столбцы должны иметь тип последнего столбца результата "
"<parameter>source_sql</parameter> и их должно быть столько, сколько строк "
"оказалось в результате запроса <parameter>category_sql</parameter>."

#: tablefunc.xml:526(para)
msgid ""
"The <function>crosstab</function> function produces one output row for each "
"consecutive group of input rows with the same <structfield>row_name</"
"structfield> value. The output <structfield>row_name</structfield> column, "
"plus any <quote>extra</quote> columns, are copied from the first row of the "
"group. The output <structfield>value</structfield> columns are filled with "
"the <structfield>value</structfield> fields from rows having matching "
"<structfield>category</structfield> values. If a row's "
"<structfield>category</structfield> does not match any output of the "
"<parameter>category_sql</parameter> query, its <structfield>value</"
"structfield> is ignored. Output columns whose matching category is not "
"present in any input row of the group are filled with nulls."
msgstr ""
"Функция <function>crosstab</function> выдаёт одну выходную строку для каждой "
"последовательной группы входных строк с одним значением "
"<structfield>row_name</structfield>. Выходной столбец <structfield>row_name</"
"structfield> плюс все <quote>дополнительные</quote> столбцы копируются из "
"первой строки группы. Выходные столбцы значений заполняются содержимым полей "
"<structfield>value</structfield> из строк с соответствующими значениями "
"<structfield>category</structfield>. Если в поле <structfield>category</"
"structfield> оказывается значение, отсутствующее в результате запроса "
"<parameter>category_sql</parameter>, содержимое поля <structfield>value</"
"structfield> в этой строке игнорируется. Выходные столбцы, для которых "
"соответствующая категория не представлена ни в одной из входных строк "
"группы, принимают значения NULL."

#: tablefunc.xml:541(para)
msgid ""
"In practice the <parameter>source_sql</parameter> query should always "
"specify <literal>ORDER BY 1</literal> to ensure that values with the same "
"<structfield>row_name</structfield> are brought together. However, ordering "
"of the categories within a group is not important. Also, it is essential to "
"be sure that the order of the <parameter>category_sql</parameter> query's "
"output matches the specified output column order."
msgstr ""
"На практике в запросе <parameter>source_sql</parameter> всегда нужно "
"указывать <literal>ORDER BY 1</literal>, чтобы все значения с одним "
"<structfield>row_name</structfield> гарантированно выводились вместе. "
"Порядок же категорий внутри группы не важен. Кроме того, важно, чтобы "
"порядок значений, выдаваемых запросом <parameter>category_sql</parameter>, "
"соответствовал заданному порядку выходных столбцов."

#: tablefunc.xml:553(programlisting)
#, no-wrap
msgid ""
"create table sales(year int, month int, qty int);\n"
"insert into sales values(2007, 1, 1000);\n"
"insert into sales values(2007, 2, 1500);\n"
"insert into sales values(2007, 7, 500);\n"
"insert into sales values(2007, 11, 1500);\n"
"insert into sales values(2007, 12, 2000);\n"
"insert into sales values(2008, 1, 1000);\n"
"\n"
"select * from crosstab(\n"
"  'select year, month, qty from sales order by 1',\n"
"  'select m from generate_series(1,12) m'\n"
") as (\n"
"  year int,\n"
"  \"Jan\" int,\n"
"  \"Feb\" int,\n"
"  \"Mar\" int,\n"
"  \"Apr\" int,\n"
"  \"May\" int,\n"
"  \"Jun\" int,\n"
"  \"Jul\" int,\n"
"  \"Aug\" int,\n"
"  \"Sep\" int,\n"
"  \"Oct\" int,\n"
"  \"Nov\" int,\n"
"  \"Dec\" int\n"
");\n"
" year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec\n"
"------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------\n"
" 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000\n"
" 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |\n"
"(2 rows)"
msgstr ""
"create table sales(year int, month int, qty int);\n"
"insert into sales values(2007, 1, 1000);\n"
"insert into sales values(2007, 2, 1500);\n"
"insert into sales values(2007, 7, 500);\n"
"insert into sales values(2007, 11, 1500);\n"
"insert into sales values(2007, 12, 2000);\n"
"insert into sales values(2008, 1, 1000);\n"
"\n"
"select * from crosstab(\n"
"  'select year, month, qty from sales order by 1',\n"
"  'select m from generate_series(1,12) m'\n"
") as (\n"
"  year int,\n"
"  \"Jan\" int,\n"
"  \"Feb\" int,\n"
"  \"Mar\" int,\n"
"  \"Apr\" int,\n"
"  \"May\" int,\n"
"  \"Jun\" int,\n"
"  \"Jul\" int,\n"
"  \"Aug\" int,\n"
"  \"Sep\" int,\n"
"  \"Oct\" int,\n"
"  \"Nov\" int,\n"
"  \"Dec\" int\n"
");\n"
" year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec\n"
"------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------\n"
" 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000\n"
" 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |\n"
"(2 rows)"

#: tablefunc.xml:587(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);\n"
"INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');\n"
"INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');\n"
"INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');\n"
"\n"
"SELECT * FROM crosstab\n"
"(\n"
"  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',\n"
"  'SELECT DISTINCT attribute FROM cth ORDER BY 1'\n"
")\n"
"AS\n"
"(\n"
"       rowid text,\n"
"       rowdt timestamp,\n"
"       temperature int4,\n"
"       test_result text,\n"
"       test_startdate timestamp,\n"
"       volts float8\n"
");\n"
" rowid |          rowdt           | temperature | test_result |      test_startdate      | volts\n"
"-------+--------------------------+-------------+-------------+--------------------------+--------\n"
" test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987\n"
" test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234\n"
"(2 rows)"
msgstr ""
"CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);\n"
"INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');\n"
"INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');\n"
"INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');\n"
"INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');\n"
"\n"
"SELECT * FROM crosstab\n"
"(\n"
"  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',\n"
"  'SELECT DISTINCT attribute FROM cth ORDER BY 1'\n"
")\n"
"AS\n"
"(\n"
"       rowid text,\n"
"       rowdt timestamp,\n"
"       temperature int4,\n"
"       test_result text,\n"
"       test_startdate timestamp,\n"
"       volts float8\n"
");\n"
" rowid |          rowdt           | temperature | test_result |      test_startdate      | volts\n"
"-------+--------------------------+-------------+-------------+--------------------------+--------\n"
" test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987\n"
" test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234\n"
"(2 rows)"

#: tablefunc.xml:551(para)
msgid "Here are two complete examples: <placeholder-1/> <placeholder-2/>"
msgstr "Два законченных примера: <placeholder-1/> <placeholder-2/>"

#: tablefunc.xml:619(para)
msgid ""
"You can create predefined functions to avoid having to write out the result "
"column names and types in each query. See the examples in the previous "
"section. The underlying C function for this form of <function>crosstab</"
"function> is named <literal>crosstab_hash</literal>."
msgstr ""
"Вы можете создать предопределённые функции, чтобы не выписывать имена и типы "
"результирующих столбцов в каждом запросе. Примеры приведены в предыдущем "
"разделе. Нижележащая функция C для этой формы <function>crosstab</function> "
"называется <literal>crosstab_hash</literal>."

#: tablefunc.xml:629(function)
msgid "connectby"
msgstr "connectby"

#: tablefunc.xml:635(synopsis)
#, no-wrap
msgid ""
"connectby(text relname, text keyid_fld, text parent_keyid_fld\n"
"          [, text orderby_fld ], text start_with, int max_depth\n"
"          [, text branch_delim ])"
msgstr ""
"connectby(text relname, text keyid_fld, text parent_keyid_fld\n"
"          [, text orderby_fld ], text start_with, int max_depth\n"
"          [, text branch_delim ])"

#: tablefunc.xml:641(para)
msgid ""
"The <function>connectby</function> function produces a display of "
"hierarchical data that is stored in a table. The table must have a key field "
"that uniquely identifies rows, and a parent-key field that references the "
"parent (if any) of each row. <function>connectby</function> can display the "
"sub-tree descending from any row."
msgstr ""
"Функция <function>connectby</function> выдаёт отображение данных, "
"содержащихся в таблице, в иерархическом виде. Таблица должна содержать поле "
"ключа, однозначно идентифицирующее строки, и поле ключа родителя, "
"ссылающееся на родителя строки (если он есть). Функция <function>connectby</"
"function> может вывести вложенное дерево, начиная с любой строки."

#: tablefunc.xml:649(para)
msgid ""
"<xref linkend=\"tablefunc-connectby-parameters\"/> explains the parameters."
msgstr ""
"Параметры описаны в <xref remap=\"6\" linkend=\"tablefunc-connectby-"
"parameters\"/>."

#: tablefunc.xml:655(title)
msgid "<function>connectby</function> Parameters"
msgstr "Параметры <function>connectby</function>"

#: tablefunc.xml:659(entry)
msgid "Parameter"
msgstr "Параметр"

#: tablefunc.xml:665(parameter)
msgid "relname"
msgstr "relname"

#: tablefunc.xml:666(entry)
msgid "Name of the source relation"
msgstr "Имя исходного отношения"

#: tablefunc.xml:669(parameter)
msgid "keyid_fld"
msgstr "keyid_fld"

#: tablefunc.xml:670(entry)
msgid "Name of the key field"
msgstr "Имя поля ключа"

#: tablefunc.xml:673(parameter)
msgid "parent_keyid_fld"
msgstr "parent_keyid_fld"

#: tablefunc.xml:674(entry)
msgid "Name of the parent-key field"
msgstr "Имя поля, содержащего ключ родителя"

#: tablefunc.xml:677(parameter)
msgid "orderby_fld"
msgstr "orderby_fld"

#: tablefunc.xml:678(entry)
msgid "Name of the field to order siblings by (optional)"
msgstr "Имя поля, по которому сортируются потомки (необязательно)"

#: tablefunc.xml:681(parameter)
msgid "start_with"
msgstr "start_with"

#: tablefunc.xml:682(entry)
msgid "Key value of the row to start at"
msgstr "Значение ключа отправной строки"

#: tablefunc.xml:685(parameter)
msgid "max_depth"
msgstr "max_depth"

#: tablefunc.xml:686(entry)
msgid "Maximum depth to descend to, or zero for unlimited depth"
msgstr ""
"Максимальная глубина, на которую можно погрузиться, либо ноль для "
"неограниченного погружения"

#: tablefunc.xml:689(parameter)
msgid "branch_delim"
msgstr "branch_delim"

#: tablefunc.xml:690(entry)
msgid "String to separate keys with in branch output (optional)"
msgstr "Строка, разделяющая ключи в выводе ветви (необязательно)"

#: tablefunc.xml:696(para)
msgid ""
"The key and parent-key fields can be any data type, but they must be the "
"same type. Note that the <parameter>start_with</parameter> value must be "
"entered as a text string, regardless of the type of the key field."
msgstr ""
"Поля ключа и ключа родителя могут быть любого типа, но должны иметь общий "
"тип. Заметьте, что значение <parameter>start_with</parameter> должно "
"задаваться текстовой строкой, вне зависимости от типа поля ключа."

#: tablefunc.xml:702(para)
msgid ""
"The <function>connectby</function> function is declared to return "
"<type>setof record</type>, so the actual names and types of the output "
"columns must be defined in the <literal>FROM</literal> clause of the calling "
"<command>SELECT</command> statement, for example:"
msgstr ""
"Функция <function>connectby</function> объявлена как возвращающая "
"<type>setof record</type>, так что фактические имена и типы выходных "
"столбцов должны определяться в предложении <literal>FROM</literal> "
"вызывающего оператора <command>SELECT</command>, например так:"

#: tablefunc.xml:709(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')\n"
"    AS t(keyid text, parent_keyid text, level int, branch text, pos int);"
msgstr ""
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')\n"
"    AS t(keyid text, parent_keyid text, level int, branch text, pos int);"

#: tablefunc.xml:714(para)
msgid ""
"The first two output columns are used for the current row's key and its "
"parent row's key; they must match the type of the table's key field. The "
"third output column is the depth in the tree and must be of type "
"<type>integer</type>. If a <parameter>branch_delim</parameter> parameter was "
"given, the next output column is the branch display and must be of type "
"<type>text</type>. Finally, if an <parameter>orderby_fld</parameter> "
"parameter was given, the last output column is a serial number, and must be "
"of type <type>integer</type>."
msgstr ""
"Первые два выходных столбца используются для вывода ключа текущей строки и "
"ключа её родителя; их тип должен соответствовать типу поля ключа. Третий "
"выходной столбец задаёт глубину в дереве и должен иметь тип <type>integer</"
"type>. Если передаётся параметр <parameter>branch_delim</parameter>, в "
"следующем столбце выводятся ветви, и этот столбец должен иметь тип "
"<type>text</type>. Наконец, если передаётся параметр <parameter>orderby_fld</"
"parameter>, в последнем столбце выводятся последовательные числа, и он "
"должен иметь тип <type>integer</type>."

#: tablefunc.xml:725(para)
msgid ""
"The <quote>branch</quote> output column shows the path of keys taken to "
"reach the current row. The keys are separated by the specified "
"<parameter>branch_delim</parameter> string. If no branch display is wanted, "
"omit both the <parameter>branch_delim</parameter> parameter and the branch "
"column in the output column list."
msgstr ""
"В столбце <quote>branch</quote> показывается путь по ключам, приведший к "
"текущей строке. Ключи разделяются заданной строкой <parameter>branch_delim</"
"parameter>. Если выводить ветви не требуется, опустите параметр "
"<parameter>branch_delim</parameter> и столбец branch в списке выходных "
"столбцов."

#: tablefunc.xml:733(para)
msgid ""
"If the ordering of siblings of the same parent is important, include the "
"<parameter>orderby_fld</parameter> parameter to specify which field to order "
"siblings by. This field can be of any sortable data type. The output column "
"list must include a final integer serial-number column, if and only if "
"<parameter>orderby_fld</parameter> is specified."
msgstr ""
"Если порядок потомков одного родителя имеет значение, добавьте параметр "
"<parameter>orderby_fld</parameter>, указывающий поле для упорядочивания "
"потомков. Это поле может иметь любой тип, допускающий сортировку. Список "
"выходных столбцов должен включать последним столбцом целочисленный столбец с "
"последовательными значениями, если и только если передаётся параметр "
"<parameter>orderby_fld</parameter>."

#: tablefunc.xml:742(para)
msgid ""
"The parameters representing table and field names are copied as-is into the "
"SQL queries that <function>connectby</function> generates internally. "
"Therefore, include double quotes if the names are mixed-case or contain "
"special characters. You may also need to schema-qualify the table name."
msgstr ""
"Параметры, представляющие имена таблицы и полей, копируются как есть в SQL-"
"запросы, которые <function>connectby</function> генерирует внутри. Таким "
"образом, их нужно заключить в двойные кавычки, если они содержат буквы в "
"разном регистре или специальные символы. Также может понадобиться дополнить "
"имя таблицы схемой."

#: tablefunc.xml:749(para)
msgid ""
"In large tables, performance will be poor unless there is an index on the "
"parent-key field."
msgstr ""
"С большими таблицами производительность будет неудовлетворительной, если не "
"создать индекс по полю с ключом родителя."

#: tablefunc.xml:754(para)
msgid ""
"It is important that the <parameter>branch_delim</parameter> string not "
"appear in any key values, else <function>connectby</function> may "
"incorrectly report an infinite-recursion error. Note that if "
"<parameter>branch_delim</parameter> is not provided, a default value of "
"<literal>~</literal> is used for recursion detection purposes."
msgstr ""
"Важно, чтобы строка <parameter>branch_delim</parameter> не фигурировала в "
"значениях ключа, иначе <function>connectby</function> может некорректно "
"сообщить об ошибке бесконечной вложенности. Заметьте, что если параметр "
"<parameter>branch_delim</parameter> не задаётся, для выявления зацикленности "
"применяется символ <literal>~</literal>."

#: tablefunc.xml:765(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);\n"
"\n"
"INSERT INTO connectby_tree VALUES('row1',NULL, 0);\n"
"INSERT INTO connectby_tree VALUES('row2','row1', 0);\n"
"INSERT INTO connectby_tree VALUES('row3','row1', 0);\n"
"INSERT INTO connectby_tree VALUES('row4','row2', 1);\n"
"INSERT INTO connectby_tree VALUES('row5','row2', 0);\n"
"INSERT INTO connectby_tree VALUES('row6','row4', 0);\n"
"INSERT INTO connectby_tree VALUES('row7','row3', 0);\n"
"INSERT INTO connectby_tree VALUES('row8','row6', 0);\n"
"INSERT INTO connectby_tree VALUES('row9','row5', 0);\n"
"\n"
"-- with branch, without orderby_fld (order of results is not guaranteed)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')\n"
" AS t(keyid text, parent_keyid text, level int, branch text);\n"
" keyid | parent_keyid | level |       branch\n"
"-------+--------------+-------+---------------------\n"
" row2  |              |     0 | row2\n"
" row4  | row2         |     1 | row2~row4\n"
" row6  | row4         |     2 | row2~row4~row6\n"
" row8  | row6         |     3 | row2~row4~row6~row8\n"
" row5  | row2         |     1 | row2~row5\n"
" row9  | row5         |     2 | row2~row5~row9\n"
"(6 rows)\n"
"\n"
"-- without branch, without orderby_fld (order of results is not guaranteed)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)\n"
" AS t(keyid text, parent_keyid text, level int);\n"
" keyid | parent_keyid | level\n"
"-------+--------------+-------\n"
" row2  |              |     0\n"
" row4  | row2         |     1\n"
" row6  | row4         |     2\n"
" row8  | row6         |     3\n"
" row5  | row2         |     1\n"
" row9  | row5         |     2\n"
"(6 rows)\n"
"\n"
"-- with branch, with orderby_fld (notice that row5 comes before row4)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')\n"
" AS t(keyid text, parent_keyid text, level int, branch text, pos int);\n"
" keyid | parent_keyid | level |       branch        | pos\n"
"-------+--------------+-------+---------------------+-----\n"
" row2  |              |     0 | row2                |   1\n"
" row5  | row2         |     1 | row2~row5           |   2\n"
" row9  | row5         |     2 | row2~row5~row9      |   3\n"
" row4  | row2         |     1 | row2~row4           |   4\n"
" row6  | row4         |     2 | row2~row4~row6      |   5\n"
" row8  | row6         |     3 | row2~row4~row6~row8 |   6\n"
"(6 rows)\n"
"\n"
"-- without branch, with orderby_fld (notice that row5 comes before row4)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)\n"
" AS t(keyid text, parent_keyid text, level int, pos int);\n"
" keyid | parent_keyid | level | pos\n"
"-------+--------------+-------+-----\n"
" row2  |              |     0 |   1\n"
" row5  | row2         |     1 |   2\n"
" row9  | row5         |     2 |   3\n"
" row4  | row2         |     1 |   4\n"
" row6  | row4         |     2 |   5\n"
" row8  | row6         |     3 |   6\n"
"(6 rows)"
msgstr ""
"CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);\n"
"\n"
"INSERT INTO connectby_tree VALUES('row1',NULL, 0);\n"
"INSERT INTO connectby_tree VALUES('row2','row1', 0);\n"
"INSERT INTO connectby_tree VALUES('row3','row1', 0);\n"
"INSERT INTO connectby_tree VALUES('row4','row2', 1);\n"
"INSERT INTO connectby_tree VALUES('row5','row2', 0);\n"
"INSERT INTO connectby_tree VALUES('row6','row4', 0);\n"
"INSERT INTO connectby_tree VALUES('row7','row3', 0);\n"
"INSERT INTO connectby_tree VALUES('row8','row6', 0);\n"
"INSERT INTO connectby_tree VALUES('row9','row5', 0);\n"
"\n"
"-- с ветвями без orderby_fld (порядок результатов не гарантируется)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')\n"
" AS t(keyid text, parent_keyid text, level int, branch text);\n"
" keyid | parent_keyid | level |       branch\n"
"-------+--------------+-------+---------------------\n"
" row2  |              |     0 | row2\n"
" row4  | row2         |     1 | row2~row4\n"
" row6  | row4         |     2 | row2~row4~row6\n"
" row8  | row6         |     3 | row2~row4~row6~row8\n"
" row5  | row2         |     1 | row2~row5\n"
" row9  | row5         |     2 | row2~row5~row9\n"
"(6 rows)\n"
"\n"
"-- без ветвей и без orderby_fld (порядок результатов не гарантируется)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)\n"
" AS t(keyid text, parent_keyid text, level int);\n"
" keyid | parent_keyid | level\n"
"-------+--------------+-------\n"
" row2  |              |     0\n"
" row4  | row2         |     1\n"
" row6  | row4         |     2\n"
" row8  | row6         |     3\n"
" row5  | row2         |     1\n"
" row9  | row5         |     2\n"
"(6 rows)\n"
"\n"
"-- с ветвями и с orderby_fld (заметьте, что row5 идёт перед row4)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')\n"
" AS t(keyid text, parent_keyid text, level int, branch text, pos int);\n"
" keyid | parent_keyid | level |       branch        | pos\n"
"-------+--------------+-------+---------------------+-----\n"
" row2  |              |     0 | row2                |   1\n"
" row5  | row2         |     1 | row2~row5           |   2\n"
" row9  | row5         |     2 | row2~row5~row9      |   3\n"
" row4  | row2         |     1 | row2~row4           |   4\n"
" row6  | row4         |     2 | row2~row4~row6      |   5\n"
" row8  | row6         |     3 | row2~row4~row6~row8 |   6\n"
"(6 rows)\n"
"\n"
"-- без ветвей, с orderby_fld (заметьте, что row5 идёт перед row4)\n"
"SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)\n"
" AS t(keyid text, parent_keyid text, level int, pos int);\n"
" keyid | parent_keyid | level | pos\n"
"-------+--------------+-------+-----\n"
" row2  |              |     0 |   1\n"
" row5  | row2         |     1 |   2\n"
" row9  | row5         |     2 |   3\n"
" row4  | row2         |     1 |   4\n"
" row6  | row4         |     2 |   5\n"
" row8  | row6         |     3 |   6\n"
"(6 rows)"

#: tablefunc.xml:763(para)
msgid "Here is an example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#: tablefunc.xml:836(title)
msgid "Author"
msgstr "Автор"

#: tablefunc.xml:838(para)
msgid "Joe Conway"
msgstr "Джо Конвей"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: tablefunc.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
