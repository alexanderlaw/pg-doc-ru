# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: indexam.xml:5(title)
msgid "Index Access Method Interface Definition"
msgstr "Определение интерфейса для методов доступа индекса"

#: indexam.xml:7(para)
msgid ""
"This chapter defines the interface between the core <productname>PostgreSQL</"
"productname> system and <firstterm>index access methods</firstterm>, which "
"manage individual index types. The core system knows nothing about indexes "
"beyond what is specified here, so it is possible to develop entirely new "
"index types by writing add-on code."
msgstr ""
"В этой главе описывается интерфейс между ядром системы "
"<productname>PostgreSQL</productname> и <firstterm>методами доступа "
"индексов</firstterm>, которые управляют отдельными типами индексов. Ядро "
"системы не знает об индексах ничего, кроме того, что описано здесь; "
"благодаря этому можно реализовывать абсолютно новые типы индексов, "
"разрабатывая код в виде расширения."

#: indexam.xml:15(para)
msgid ""
"All indexes in <productname>PostgreSQL</productname> are what are known "
"technically as <firstterm>secondary indexes</firstterm>; that is, the index "
"is physically separate from the table file that it describes. Each index is "
"stored as its own physical <firstterm>relation</firstterm> and so is "
"described by an entry in the <structname>pg_class</structname> catalog. The "
"contents of an index are entirely under the control of its index access "
"method. In practice, all index access methods divide indexes into standard-"
"size pages so that they can use the regular storage manager and buffer "
"manager to access the index contents. (All the existing index access methods "
"furthermore use the standard page layout described in <xref linkend="
"\"storage-page-layout\"/>, and most use the same format for index tuple "
"headers; but these decisions are not forced on an access method.)"
msgstr ""
"Все индексы <productname>PostgreSQL</productname> являются, говоря на "
"техническом уровне, <firstterm>вторичными индексами</firstterm>; то есть, "
"они физически отделены от файла таблицы, к которой относятся. Каждый индекс "
"хранится в собственном отдельном физическом <firstterm>отношении</firstterm> "
"и описывается в отдельной записи в каталоге <structname>pg_class</"
"structname>. Содержимое индекса находится полностью под контролем "
"соответствующего метода доступа. На практике все методы доступа индексов "
"делят индексы на страницы стандартного размера, чтобы для обращения к "
"содержимому индекса можно было задействовать обычный менеджер хранилища и "
"менеджер буферов. (Более того, большинство существующих методов доступа "
"используют одну структуру страницы, описанную в <xref remap=\"6\" linkend="
"\"storage-page-layout\"/>, и одинаковый формат заголовков кортежей индекса; "
"но эти решения методам доступа не навязываются.)"

#: indexam.xml:30(para)
msgid ""
"An index is effectively a mapping from some data key values to "
"<firstterm>tuple identifiers</firstterm>, or <acronym>TIDs</acronym>, of row "
"versions (tuples) in the index's parent table. A TID consists of a block "
"number and an item number within that block (see <xref linkend=\"storage-"
"page-layout\"/>). This is sufficient information to fetch a particular row "
"version from the table. Indexes are not directly aware that under MVCC, "
"there might be multiple extant versions of the same logical row; to an "
"index, each tuple is an independent object that needs its own index entry. "
"Thus, an update of a row always creates all-new index entries for the row, "
"even if the key values did not change. (HOT tuples are an exception to this "
"statement; but indexes do not deal with those, either.) Index entries for "
"dead tuples are reclaimed (by vacuuming) when the dead tuples themselves are "
"reclaimed."
msgstr ""
"Индекс по сути представляет собой сопоставление некоторых значений ключей "
"данных с <firstterm>идентификаторами кортежей</firstterm>, <acronym>TID</"
"acronym> (Tuple Identifier), или версиями строк в основной таблице индекса. "
"TID состоит из номера блока и номера записи в этом блоке (см. <xref remap="
"\"4\" linkend=\"storage-page-layout\"/>). Этой информации достаточно, чтобы "
"выбрать определённую версию строки из таблицы. Индексы сами по себе не "
"знают, что в модели MVCC у одной логической строки может быть несколько "
"существующих версий; для индекса каждый кортеж — независимый объект, "
"которому нужна своя запись в индексе. Таким образом, при изменении строки "
"для неё всегда заново создаются новые записи индекса, даже если значения "
"ключа не изменились. (Кортежи HOT представляют собой исключение из этого "
"утверждения; но индексы всё равно не имеют с этим дела.) Записи индексов для "
"мёртвых кортежей высвобождаются (при очистке), когда высвобождаются сами "
"мёртвые кортежи."

#: indexam.xml:48(title)
msgid "Basic API Structure for Indexes"
msgstr "Базовая структура API для индексов"

#: indexam.xml:50(para)
msgid ""
"Each index access method is described by a row in the <link linkend="
"\"catalog-pg-am\"><structname>pg_am</structname></link> system catalog. The "
"<structname>pg_am</structname> entry specifies a name and a "
"<firstterm>handler function</firstterm> for the access method. These entries "
"can be created and deleted using the <xref linkend=\"sql-create-access-method"
"\"/> and <xref linkend=\"sql-drop-access-method\"/> SQL commands."
msgstr ""
"Каждый метод доступа индекса описывается строкой в системном каталоге <link "
"linkend=\"catalog-pg-am\"><structname>pg_am</structname></link>. В записи "
"<structname>pg_am</structname> указывается имя и <firstterm>функция-"
"обработчик</firstterm> для метода доступа. Эти записи могут создаваться и "
"удаляться командами SQL <xref linkend=\"sql-create-access-method\"/> и <xref "
"linkend=\"sql-drop-access-method\"/>."

#: indexam.xml:60(para)
msgid ""
"An index access method handler function must be declared to accept a single "
"argument of type <type>internal</type> and to return the pseudo-type "
"<type>index_am_handler</type>. The argument is a dummy value that simply "
"serves to prevent handler functions from being called directly from SQL "
"commands. The result of the function must be a palloc'd struct of type "
"<structname>IndexAmRoutine</structname>, which contains everything that the "
"core code needs to know to make use of the index access method. The "
"<structname>IndexAmRoutine</structname> struct, also called the access "
"method's <firstterm>API struct</firstterm>, includes fields specifying "
"assorted fixed properties of the access method, such as whether it can "
"support multicolumn indexes. More importantly, it contains pointers to "
"support functions for the access method, which do all of the real work to "
"access indexes. These support functions are plain C functions and are not "
"visible or callable at the SQL level. The support functions are described in "
"<xref linkend=\"index-functions\"/>."
msgstr ""
"Функция-обработчик метода доступа должна объявляться как принимающая один "
"аргумент типа <type>internal</type> и возвращающая псевдотип "
"<type>index_am_handler</type>. Аргумент в данном случае фиктивный, и нужен "
"только для того, чтобы эту функцию нельзя было вызывать непосредственно из "
"команд SQL. Возвращать эта функция должна структуру типа "
"<structname>IndexAmRoutine</structname> (в памяти palloc), содержащую всё, "
"что нужно знать коду ядра, чтобы использовать этот метод доступа. Структура "
"<structname>IndexAmRoutine</structname>, также называемая "
"<firstterm>структурой API</firstterm> метода доступа, содержит поля, "
"задающие разнообразные предопределённые свойства метода доступа, например, "
"поддерживает ли он составные индексы. Что более важно, она содержит "
"указатели на опорные функции для метода доступа. Это обычные функции на C и "
"они не видны и не могут быть вызваны на уровне SQL. Опорные функции описаны "
"в <xref remap=\"6\" linkend=\"index-functions\"/>."

# well-spelled: МД
#: indexam.xml:80(programlisting)
#, no-wrap
msgid ""
"typedef struct IndexAmRoutine\n"
"{\n"
"    NodeTag     type;\n"
"\n"
"    /*\n"
"     * Total number of strategies (operators) by which we can traverse/search\n"
"     * this AM.  Zero if AM does not have a fixed set of strategy assignments.\n"
"     */\n"
"    uint16      amstrategies;\n"
"    /* total number of support functions that this AM uses */\n"
"    uint16      amsupport;\n"
"    /* does AM support ORDER BY indexed column's value? */\n"
"    bool        amcanorder;\n"
"    /* does AM support ORDER BY result of an operator on indexed column? */\n"
"    bool        amcanorderbyop;\n"
"    /* does AM support backward scanning? */\n"
"    bool        amcanbackward;\n"
"    /* does AM support UNIQUE indexes? */\n"
"    bool        amcanunique;\n"
"    /* does AM support multi-column indexes? */\n"
"    bool        amcanmulticol;\n"
"    /* does AM require scans to have a constraint on the first index column? */\n"
"    bool        amoptionalkey;\n"
"    /* does AM handle ScalarArrayOpExpr quals? */\n"
"    bool        amsearcharray;\n"
"    /* does AM handle IS NULL/IS NOT NULL quals? */\n"
"    bool        amsearchnulls;\n"
"    /* can index storage data type differ from column data type? */\n"
"    bool        amstorage;\n"
"    /* can an index of this type be clustered on? */\n"
"    bool        amclusterable;\n"
"    /* does AM handle predicate locks? */\n"
"    bool        ampredlocks;\n"
"    /* type of data stored in index, or InvalidOid if variable */\n"
"    Oid         amkeytype;\n"
"\n"
"    /* interface functions */\n"
"    ambuild_function ambuild;\n"
"    ambuildempty_function ambuildempty;\n"
"    aminsert_function aminsert;\n"
"    ambulkdelete_function ambulkdelete;\n"
"    amvacuumcleanup_function amvacuumcleanup;\n"
"    amcanreturn_function amcanreturn;   /* can be NULL */\n"
"    amcostestimate_function amcostestimate;\n"
"    amoptions_function amoptions;\n"
"    amproperty_function amproperty;     /* can be NULL */\n"
"    amvalidate_function amvalidate;\n"
"    ambeginscan_function ambeginscan;\n"
"    amrescan_function amrescan;\n"
"    amgettuple_function amgettuple;     /* can be NULL */\n"
"    amgetbitmap_function amgetbitmap;   /* can be NULL */\n"
"    amendscan_function amendscan;\n"
"    ammarkpos_function ammarkpos;       /* can be NULL */\n"
"    amrestrpos_function amrestrpos;     /* can be NULL */\n"
"} IndexAmRoutine;"
msgstr ""
"typedef struct IndexAmRoutine\n"
"{\n"
"    NodeTag     type;\n"
"\n"
"    /*\n"
"     * Общее число стратегий (операторов), с которыми возможен поиск/применение\n"
"     * этого метода доступа (МД).  Ноль, если у этого МД нет фиксированного набора назначенных стратегий.\n"
"     */\n"
"    uint16      amstrategies;\n"
"    /* общее число опорных функций, используемых этим МД */\n"
"    uint16      amsupport;\n"
"    /* поддерживает ли МД упорядочивание (ORDER BY) значений индексированного столбца? */\n"
"    bool        amcanorder;\n"
"    /* поддерживает ли МД упорядочивание (ORDER BY) результата оператора с индексированным столбцом? */\n"
"    bool        amcanorderbyop;\n"
"    /* поддерживает ли МД сканирование в обратном направлении? */\n"
"    bool        amcanbackward;\n"
"    /* поддерживает ли МД уникальные индексы (UNIQUE)? */\n"
"    bool        amcanunique;\n"
"    /* поддерживает ли МД индексы с несколькими столбцами? */\n"
"    bool        amcanmulticol;\n"
"    /* требуется ли для сканирования с МД ограничение первого столбца индекса? */\n"
"    bool        amoptionalkey;\n"
"    /* воспринимает ли МД условия ScalarArrayOpExpr? */\n"
"    bool        amsearcharray;\n"
"    /* воспринимает ли МД условия IS NULL/IS NOT NULL? */\n"
"    bool        amsearchnulls;\n"
"    /* может ли тип, хранящийся в индексе, отличаться от типа столбца? */\n"
"    bool        amstorage;\n"
"    /* возможна ли кластеризация по индексу этого типа? */\n"
"    bool        amclusterable;\n"
"    /* МД обрабатывает предикатные блокировки? */\n"
"    bool        ampredlocks;\n"
"    /* тип данных, хранящихся в индексе, либо InvalidOid, если он переменный */\n"
"    Oid         amkeytype;\n"
"\n"
"    /* интерфейсные функции */\n"
"    ambuild_function ambuild;\n"
"    ambuildempty_function ambuildempty;\n"
"    aminsert_function aminsert;\n"
"    ambulkdelete_function ambulkdelete;\n"
"    amvacuumcleanup_function amvacuumcleanup;\n"
"    amcanreturn_function amcanreturn;   /* может быть NULL */\n"
"    amcostestimate_function amcostestimate;\n"
"    amoptions_function amoptions;\n"
"    amproperty_function amproperty;     /* может быть NULL */\n"
"    amvalidate_function amvalidate;\n"
"    ambeginscan_function ambeginscan;\n"
"    amrescan_function amrescan;\n"
"    amgettuple_function amgettuple;     /* может быть NULL */\n"
"    amgetbitmap_function amgetbitmap;   /* может быть NULL */\n"
"    amendscan_function amendscan;\n"
"    ammarkpos_function ammarkpos;       /* может быть NULL */\n"
"    amrestrpos_function amrestrpos;     /* может быть NULL */\n"
"} IndexAmRoutine;"

#: indexam.xml:78(para)
msgid ""
"The structure <structname>IndexAmRoutine</structname> is defined thus: "
"<placeholder-1/>"
msgstr ""
"Структура <structname>IndexAmRoutine</structname> определяется так: "
"<placeholder-1/>"

#: indexam.xml:139(para)
msgid ""
"To be useful, an index access method must also have one or more "
"<firstterm>operator families</firstterm> and <firstterm>operator classes</"
"firstterm> defined in <link linkend=\"catalog-pg-opfamily"
"\"><structname>pg_opfamily</structname></link>, <link linkend=\"catalog-pg-"
"opclass\"><structname>pg_opclass</structname></link>, <link linkend="
"\"catalog-pg-amop\"><structname>pg_amop</structname></link>, and <link "
"linkend=\"catalog-pg-amproc\"><structname>pg_amproc</structname></link>. "
"These entries allow the planner to determine what kinds of query "
"qualifications can be used with indexes of this access method. Operator "
"families and classes are described in <xref linkend=\"xindex\"/>, which is "
"prerequisite material for reading this chapter."
msgstr ""
"Чтобы метод доступа индекса применялся, необходимо также определить "
"<firstterm>семейства операторов</firstterm> и <firstterm>классы операторов</"
"firstterm> в <link linkend=\"catalog-pg-opfamily\"><structname>pg_opfamily</"
"structname></link>, <link linkend=\"catalog-pg-opclass"
"\"><structname>pg_opclass</structname></link>, <link linkend=\"catalog-pg-"
"amop\"><structname>pg_amop</structname></link> и <link linkend=\"catalog-pg-"
"amproc\"><structname>pg_amproc</structname></link>. Эти записи позволяют "
"планировщику понять, для каких видов условий запросов могут применяться "
"индексы с данными методом доступа. Семейства и классы операторов описываются "
"в <xref remap=\"6\" linkend=\"xindex\"/>; этот материал необходимо изучить, "
"прежде чем читать данную главу."

#: indexam.xml:154(para)
msgid ""
"An individual index is defined by a <link linkend=\"catalog-pg-class"
"\"><structname>pg_class</structname></link> entry that describes it as a "
"physical relation, plus a <link linkend=\"catalog-pg-index"
"\"><structname>pg_index</structname></link> entry that shows the logical "
"content of the index &mdash; that is, the set of index columns it has and "
"the semantics of those columns, as captured by the associated operator "
"classes. The index columns (key values) can be either simple columns of the "
"underlying table or expressions over the table rows. The index access method "
"normally has no interest in where the index key values come from (it is "
"always handed precomputed key values) but it will be very interested in the "
"operator class information in <structname>pg_index</structname>. Both of "
"these catalog entries can be accessed as part of the <structname>Relation</"
"structname> data structure that is passed to all operations on the index."
msgstr ""
"Отдельный индекс определяется записью в <link linkend=\"catalog-pg-class"
"\"><structname>pg_class</structname></link>, описывающей его как физическое "
"отношение, и записью в <link linkend=\"catalog-pg-index"
"\"><structname>pg_index</structname></link>, представляющей логическое "
"содержание индекса &mdash; то есть, набор столбцов индекса и семантическое "
"значение этих столбцов, установленное соответствующими классами операторов. "
"Столбцами индекса (значениями ключа) могут быть либо простые столбцы "
"нижележащей таблицы, либо выражения, вычисляемые по строкам таблицы. Для "
"метода доступа индекса обычно не важно, откуда поступают значения ключа "
"индекса (они всегда поступают в вычисленном виде), но очень важна информация "
"о классе операторов в каталоге <structname>pg_index</structname>. Обе эти "
"записи каталогов представлены в составе структуры данных "
"<structname>Relation</structname>, которая передаётся всем функциям, "
"реализующим операции с индексом."

#: indexam.xml:171(para)
msgid ""
"Some of the flag fields of <structname>IndexAmRoutine</structname> have "
"nonobvious implications. The requirements of <structfield>amcanunique</"
"structfield> are discussed in <xref linkend=\"index-unique-checks\"/>. The "
"<structfield>amcanmulticol</structfield> flag asserts that the access method "
"supports multicolumn indexes, while <structfield>amoptionalkey</structfield> "
"asserts that it allows scans where no indexable restriction clause is given "
"for the first index column. When <structfield>amcanmulticol</structfield> is "
"false, <structfield>amoptionalkey</structfield> essentially says whether the "
"access method supports full-index scans without any restriction clause. "
"Access methods that support multiple index columns <emphasis>must</emphasis> "
"support scans that omit restrictions on any or all of the columns after the "
"first; however they are permitted to require some restriction to appear for "
"the first index column, and this is signaled by setting "
"<structfield>amoptionalkey</structfield> false. One reason that an index AM "
"might set <structfield>amoptionalkey</structfield> false is if it doesn't "
"index null values. Since most indexable operators are strict and hence "
"cannot return true for null inputs, it is at first sight attractive to not "
"store index entries for null values: they could never be returned by an "
"index scan anyway. However, this argument fails when an index scan has no "
"restriction clause for a given index column. In practice this means that "
"indexes that have <structfield>amoptionalkey</structfield> true must index "
"nulls, since the planner might decide to use such an index with no scan keys "
"at all. A related restriction is that an index access method that supports "
"multiple index columns <emphasis>must</emphasis> support indexing null "
"values in columns after the first, because the planner will assume the index "
"can be used for queries that do not restrict these columns. For example, "
"consider an index on (a,b) and a query with <literal>WHERE a = 4</literal>. "
"The system will assume the index can be used to scan for rows with "
"<literal>a = 4</literal>, which is wrong if the index omits rows where "
"<literal>b</literal> is null. It is, however, OK to omit rows where the "
"first indexed column is null. An index access method that does index nulls "
"may also set <structfield>amsearchnulls</structfield>, indicating that it "
"supports <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> "
"clauses as search conditions."
msgstr ""
"С некоторыми полями флагов в <structname>IndexAmRoutine</structname> связаны "
"неочевидные следствия. Требования индексов с <structfield>amcanunique</"
"structfield> описаны в <xref remap=\"6\" linkend=\"index-unique-checks\"/>. "
"Флаг <structfield>amcanmulticol</structfield> показывает, что метод доступа "
"поддерживает составные индексы, а <structfield>amoptionalkey</structfield> "
"обозначает, что метод позволяет выполнить сканирование при отсутствии "
"индексируемого ограничивающего условия для первого столбца индекса. Когда "
"<structfield>amcanmulticol</structfield> равен false, "
"<structfield>amoptionalkey</structfield> по сути говорит, поддерживает ли "
"метод доступа полное сканирование по индексу без ограничивающего условия. "
"Методы доступа, поддерживающие индексы по нескольким столбцам, "
"<emphasis>должны</emphasis> поддерживать сканирования при отсутствии "
"ограничений любых или всех столбцов после первого; однако они могут "
"требовать присутствия какого-либо ограничения для первого столбца индекса, и "
"это требование отмечается значением false флага <structfield>amoptionalkey</"
"structfield>. В <structfield>amoptionalkey</structfield> для метода доступа "
"может устанавливаться false, например, когда этот метод доступа не "
"индексирует значения. Так как большинство индексируемых операторов — "
"строгие, и поэтому не могут вернуть true для операндов NULL, на первый "
"взгляд кажется заманчивой идея не хранить записи индекса для значений NULL: "
"они всё равно никак не могут быть прочитаны при сканировании индекса. Однако "
"этот аргумент отпадает, когда при сканировании индекса вовсе отсутствует "
"ограничение данного столбца индекса. На практике это означает, что индексы с "
"установленным флагом <structfield>amoptionalkey</structfield> должны "
"индексировать значения NULL, так как планировщик может склониться к "
"использованию этого индекса вообще без ключей. С этим связано ещё одно "
"ограничение — метод доступа индекса, поддерживающий составные индексы, "
"<emphasis>должен</emphasis> поддерживать индексирование значений NULL в "
"столбцах после первого, так как планировщик будет полагать, что индекс можно "
"применять для запросов, в которых эти столбцы не ограничиваются. Например, "
"рассмотрим индекс по (a,b) и запрос с ограничением <literal>WHERE a = 4</"
"literal>. Система будет полагать, что по этому индексу можно просканировать "
"строки с <literal>a = 4</literal>, но это будет неверно, если индекс "
"исключит строки, в которых <literal>b</literal> — NULL. Однако, этот индекс "
"вполне может исключить строки, в которых первый столбец содержит NULL. Метод "
"индекса, который индексирует значения NULL, может также установить флаг "
"<structfield>amsearchnulls</structfield>, отметив тем самым, что он "
"поддерживает в качестве условий поиска <literal>IS NULL</literal> и "
"<literal>IS NOT NULL</literal>."

#: indexam.xml:215(title)
msgid "Index Access Method Functions"
msgstr "Функции для метода доступа индекса"

#: indexam.xml:217(para)
msgid ""
"The index construction and maintenance functions that an index access method "
"must provide in <structname>IndexAmRoutine</structname> are:"
msgstr ""
"Метод доступа индекса должен определить в <structname>IndexAmRoutine</"
"structname> следующие функции построения и обслуживания индексов:"

#: indexam.xml:223(programlisting)
#, no-wrap
msgid ""
"IndexBuildResult *\n"
"ambuild (Relation heapRelation,\n"
"         Relation indexRelation,\n"
"         IndexInfo *indexInfo);"
msgstr ""
"IndexBuildResult *\n"
"ambuild (Relation heapRelation,\n"
"         Relation indexRelation,\n"
"         IndexInfo *indexInfo);"

#: indexam.xml:222(para)
msgid ""
"<placeholder-1/> Build a new index. The index relation has been physically "
"created, but is empty. It must be filled in with whatever fixed data the "
"access method requires, plus entries for all tuples already existing in the "
"table. Ordinarily the <function>ambuild</function> function will call "
"<function>IndexBuildHeapScan()</function> to scan the table for existing "
"tuples and compute the keys that need to be inserted into the index. The "
"function must return a palloc'd struct containing statistics about the new "
"index."
msgstr ""
"<placeholder-1/> Строит новый индекс. Отношение индекса уже физически "
"создано, но пока пусто. Оно должно быть наполнено фиксированными данными, "
"которые требуются методу доступа, и записями для всех кортежей, уже "
"существующих в таблице. Обычно функция <function>ambuild</function> вызывает "
"<function>IndexBuildHeapScan()</function> для поиска в таблице существующих "
"кортежей и для вычисления ключей, которые должны вставляться в этот индекс. "
"Эта функция должна возвращать структуру, выделенную вызовом palloc и "
"содержащую статистику нового индекса."

#: indexam.xml:240(programlisting)
#, no-wrap
msgid ""
"void\n"
"ambuildempty (Relation indexRelation);"
msgstr ""
"void\n"
"ambuildempty (Relation indexRelation);"

#: indexam.xml:239(para)
msgid ""
"<placeholder-1/> Build an empty index, and write it to the initialization "
"fork (<symbol>INIT_FORKNUM</symbol>) of the given relation. This method is "
"called only for unlogged indexes; the empty index written to the "
"initialization fork will be copied over the main relation fork on each "
"server restart."
msgstr ""
"<placeholder-1/> Создаёт пустой индекс и записывает его в слой инициализации "
"(<symbol>INIT_FORKNUM</symbol>) данного отношения. Этот метод вызывается "
"только для нежурналируемых индексов; пустой индекс, записанный в слой "
"инициализации, будет копироваться в основной слой отношения при каждом "
"перезапуске сервера."

#: indexam.xml:251(programlisting)
#, no-wrap
msgid ""
"bool\n"
"aminsert (Relation indexRelation,\n"
"          Datum *values,\n"
"          bool *isnull,\n"
"          ItemPointer heap_tid,\n"
"          Relation heapRelation,\n"
"          IndexUniqueCheck checkUnique);"
msgstr ""
"bool\n"
"aminsert (Relation indexRelation,\n"
"          Datum *values,\n"
"          bool *isnull,\n"
"          ItemPointer heap_tid,\n"
"          Relation heapRelation,\n"
"          IndexUniqueCheck checkUnique);"

#: indexam.xml:250(para)
msgid ""
"<placeholder-1/> Insert a new tuple into an existing index. The "
"<literal>values</literal> and <literal>isnull</literal> arrays give the key "
"values to be indexed, and <literal>heap_tid</literal> is the TID to be "
"indexed. If the access method supports unique indexes (its "
"<structfield>amcanunique</structfield> flag is true) then "
"<literal>checkUnique</literal> indicates the type of uniqueness check to "
"perform. This varies depending on whether the unique constraint is "
"deferrable; see <xref linkend=\"index-unique-checks\"/> for details. "
"Normally the access method only needs the <literal>heapRelation</literal> "
"parameter when performing uniqueness checking (since then it will have to "
"look into the heap to verify tuple liveness)."
msgstr ""
"<placeholder-1/> Вставляет новый кортеж в существующий индекс. В массивах "
"<literal>values</literal> и <literal>isnull</literal> передаются значения "
"ключа, которые должны быть проиндексированы, а в <literal>heap_tid</literal> "
"— идентификатор индексируемого кортежа (TID). Если метод доступа "
"поддерживает уникальные индексы (флаг <structfield>amcanunique</structfield> "
"установлен), параметр <literal>checkUnique</literal> указывает, какая "
"проверка уникальности должна выполняться. Это зависит от того, является ли "
"ограничение уникальности откладываемым; за подробностями обратитесь к <xref "
"remap=\"3\" linkend=\"index-unique-checks\"/>. Обычно параметр "
"<literal>heapRelation</literal> нужен методу доступа только для проверки "
"уникальности (так как он должен обратиться к основным данным, чтобы "
"убедиться в актуальности кортежа)."

#: indexam.xml:273(para)
msgid ""
"The function's Boolean result value is significant only when "
"<literal>checkUnique</literal> is <literal>UNIQUE_CHECK_PARTIAL</literal>. "
"In this case a TRUE result means the new entry is known unique, whereas "
"FALSE means it might be non-unique (and a deferred uniqueness check must be "
"scheduled). For other cases a constant FALSE result is recommended."
msgstr ""
"Возвращаемый функцией булевский результат имеет значение, только когда "
"параметр <literal>checkUnique</literal> равен <literal>UNIQUE_CHECK_PARTIAL</"
"literal>. В этом случае результат TRUE означает, что новая запись признана "
"уникальной, тогда как FALSE означает, что она может быть неуникальной (и "
"требуется назначить отложенную проверку уникальности). В других случаях "
"рекомендуется возвращать постоянный результат FALSE."

#: indexam.xml:281(para)
msgid ""
"Some indexes might not index all tuples. If the tuple is not to be indexed, "
"<function>aminsert</function> should just return without doing anything."
msgstr ""
"Некоторые индексы могут индексировать не все кортежи. Если кортеж не будет "
"индексирован, <function>aminsert</function> должна просто завершиться, не "
"делая ничего."

#: indexam.xml:287(programlisting)
#, no-wrap
msgid ""
"IndexBulkDeleteResult *\n"
"ambulkdelete (IndexVacuumInfo *info,\n"
"              IndexBulkDeleteResult *stats,\n"
"              IndexBulkDeleteCallback callback,\n"
"              void *callback_state);"
msgstr ""
"IndexBulkDeleteResult *\n"
"ambulkdelete (IndexVacuumInfo *info,\n"
"              IndexBulkDeleteResult *stats,\n"
"              IndexBulkDeleteCallback callback,\n"
"              void *callback_state);"

#: indexam.xml:286(para)
msgid ""
"<placeholder-1/> Delete tuple(s) from the index. This is a <quote>bulk "
"delete</quote> operation that is intended to be implemented by scanning the "
"whole index and checking each entry to see if it should be deleted. The "
"passed-in <literal>callback</literal> function must be called, in the style "
"<literal>callback(<replaceable>TID</replaceable>, callback_state) returns "
"bool</literal>, to determine whether any particular index entry, as "
"identified by its referenced TID, is to be deleted. Must return either NULL "
"or a palloc'd struct containing statistics about the effects of the deletion "
"operation. It is OK to return NULL if no information needs to be passed on "
"to <function>amvacuumcleanup</function>."
msgstr ""
"<placeholder-1/> Удаляет кортеж(и) из индекса. Это операция <quote>массового "
"удаления</quote>, которая предположительно будет реализована путём "
"сканирования всего индекса и проверки для каждой записи, должна ли она "
"удаляться. Переданная функция <literal>callback</literal> должна вызываться "
"в стиле <literal>callback(<replaceable>TID</replaceable>, callback_state)</"
"literal> с результатом bool, который говорит, должна ли удаляться запись "
"индекса, на которую указывает передаваемый TID. Возвращать эта функция "
"должна NULL или структуру, выделенную вызовом palloc и содержащую статистику "
"результата удаления. NULL можно вернуть, если никакая информация не должна "
"передаваться в <function>amvacuumcleanup</function>."

#: indexam.xml:306(para)
msgid ""
"Because of limited <varname>maintenance_work_mem</varname>, "
"<function>ambulkdelete</function> might need to be called more than once "
"when many tuples are to be deleted. The <literal>stats</literal> argument is "
"the result of the previous call for this index (it is NULL for the first "
"call within a <command>VACUUM</command> operation). This allows the AM to "
"accumulate statistics across the whole operation. Typically, "
"<function>ambulkdelete</function> will modify and return the same struct if "
"the passed <literal>stats</literal> is not null."
msgstr ""
"Из-за ограничения <varname>maintenance_work_mem</varname> процедура "
"<function>ambulkdelete</function> может вызываться несколько раз, когда "
"удалению подлежит большое количество кортежей. В аргументе <literal>stats</"
"literal> передаётся результат предыдущего вызова для данного индекса (при "
"первом вызове в ходе операции <command>VACUUM</command> он содержит NULL). "
"Это позволяет методу доступа накапливать статистику в процессе всей "
"операции. Обычно <function>ambulkdelete</function> модифицирует и возвращает "
"одну и ту же структуру, если в <literal>stats</literal> передаётся не NULL."

#: indexam.xml:318(programlisting)
#, no-wrap
msgid ""
"IndexBulkDeleteResult *\n"
"amvacuumcleanup (IndexVacuumInfo *info,\n"
"                 IndexBulkDeleteResult *stats);"
msgstr ""
"IndexBulkDeleteResult *\n"
"amvacuumcleanup (IndexVacuumInfo *info,\n"
"                 IndexBulkDeleteResult *stats);"

#: indexam.xml:317(para)
msgid ""
"<placeholder-1/> Clean up after a <command>VACUUM</command> operation (zero "
"or more <function>ambulkdelete</function> calls). This does not have to do "
"anything beyond returning index statistics, but it might perform bulk "
"cleanup such as reclaiming empty index pages. <literal>stats</literal> is "
"whatever the last <function>ambulkdelete</function> call returned, or NULL "
"if <function>ambulkdelete</function> was not called because no tuples needed "
"to be deleted. If the result is not NULL it must be a palloc'd struct. The "
"statistics it contains will be used to update <structname>pg_class</"
"structname>, and will be reported by <command>VACUUM</command> if "
"<literal>VERBOSE</literal> is given. It is OK to return NULL if the index "
"was not changed at all during the <command>VACUUM</command> operation, but "
"otherwise correct stats should be returned."
msgstr ""
"<placeholder-1/> Провести очистку после операции <command>VACUUM</command> "
"(до этого <function>ambulkdelete</function> могла вызываться несколько или "
"ноль раз). От этой функции не требуется ничего, кроме как выдать статистику "
"по индексу, но она может произвести массовую очистку, например, высвободить "
"пустые страницы индекса. В <literal>stats</literal> ей передаётся структура, "
"возвращённая при последнем вызове <function>ambulkdelete</function>, либо "
"NULL, если <function>ambulkdelete</function> не вызывалась, так как никакие "
"кортежи удалять не требовалось. Эта функция должна возвращать NULL или "
"структуру, выделенную вызовом palloc. Содержащаяся в этой структуре "
"статистика будет отражена в записи в <structname>pg_class</structname> и "
"попадёт в вывод команды <command>VACUUM</command>, если она выполнялась с "
"указанием <literal>VERBOSE</literal>. NULL может возвращаться, если индекс "
"вовсе не изменился в процессе операции <command>VACUUM</command>, но в "
"противном случае должна возвращаться корректная статистика."

#: indexam.xml:337(para)
msgid ""
"As of <productname>PostgreSQL</productname> 8.4, <function>amvacuumcleanup</"
"function> will also be called at completion of an <command>ANALYZE</command> "
"operation. In this case <literal>stats</literal> is always NULL and any "
"return value will be ignored. This case can be distinguished by checking "
"<literal>info-&gt;analyze_only</literal>. It is recommended that the access "
"method do nothing except post-insert cleanup in such a call, and that only "
"in an autovacuum worker process."
msgstr ""
"Начиная с <productname>PostgreSQL</productname> версии 8.4, "
"<function>amvacuumcleanup</function> также вызывается в конце операции "
"<command>ANALYZE</command>. В этом случае <literal>stats</literal> всегда "
"NULL и любое возвращаемое значение игнорируется. Этот вариант вызова можно "
"распознать, проверив поле <literal>info-&gt;analyze_only</literal>. При "
"таком вызове методу доступа рекомендуется ничего не делать, кроме как "
"провести очистку после добавления данных, и только в рабочем процессе "
"автоочистки."

#: indexam.xml:348(programlisting)
#, no-wrap
msgid ""
"bool\n"
"amcanreturn (Relation indexRelation, int attno);"
msgstr ""
"bool\n"
"amcanreturn (Relation indexRelation, int attno);"

#: indexam.xml:347(para)
msgid ""
"<placeholder-1/> Check whether the index can support <link linkend=\"indexes-"
"index-only-scans\"><firstterm>index-only scans</firstterm></link> on the "
"given column, by returning the indexed column values for an index entry in "
"the form of an <structname>IndexTuple</structname>. The attribute number is "
"1-based, i.e. the first column's attno is 1. Returns TRUE if supported, else "
"FALSE. If the access method does not support index-only scans at all, the "
"<structfield>amcanreturn</structfield> field in its "
"<structname>IndexAmRoutine</structname> struct can be set to NULL."
msgstr ""
"<placeholder-1/> Проверяет, поддерживается ли <link linkend=\"indexes-index-"
"only-scans\"><firstterm>сканирование только индекса</firstterm></link> для "
"заданного столбца, когда для записи индекса возвращаются значения "
"индексируемых столбцов в виде <structname>IndexTuple</structname>. Атрибуты "
"нумеруются с 1, то есть для первого столбца attno равен 1. Возвращает TRUE, "
"если такое сканирование поддерживается, а иначе FALSE. Если метод доступа "
"индекса в принципе не поддерживает сканирование только индекса, в поле "
"<structfield>amcanreturn</structfield> его структуры "
"<structname>IndexAmRoutine</structname> можно записать NULL."

#: indexam.xml:363(programlisting) indexam.xml:1065(programlisting)
#, no-wrap
msgid ""
"void\n"
"amcostestimate (PlannerInfo *root,\n"
"                IndexPath *path,\n"
"                double loop_count,\n"
"                Cost *indexStartupCost,\n"
"                Cost *indexTotalCost,\n"
"                Selectivity *indexSelectivity,\n"
"                double *indexCorrelation);"
msgstr ""
"void\n"
"amcostestimate (PlannerInfo *root,\n"
"                IndexPath *path,\n"
"                double loop_count,\n"
"                Cost *indexStartupCost,\n"
"                Cost *indexTotalCost,\n"
"                Selectivity *indexSelectivity,\n"
"                double *indexCorrelation);"

#: indexam.xml:362(para)
msgid ""
"<placeholder-1/> Estimate the costs of an index scan. This function is "
"described fully in <xref linkend=\"index-cost-estimation\"/>, below."
msgstr ""
"<placeholder-1/> Рассчитывает примерную стоимость сканирования индекса. Эта "
"функция полностью описывается ниже в <xref remap=\"6\" linkend=\"index-cost-"
"estimation\"/>."

#: indexam.xml:378(programlisting)
#, no-wrap
msgid ""
"bytea *\n"
"amoptions (ArrayType *reloptions,\n"
"           bool validate);"
msgstr ""
"bytea *\n"
"amoptions (ArrayType *reloptions,\n"
"           bool validate);"

#: indexam.xml:377(para)
msgid ""
"<placeholder-1/> Parse and validate the reloptions array for an index. This "
"is called only when a non-null reloptions array exists for the index. "
"<parameter>reloptions</parameter> is a <type>text</type> array containing "
"entries of the form <replaceable>name</replaceable><literal>=</"
"literal><replaceable>value</replaceable>. The function should construct a "
"<type>bytea</type> value, which will be copied into the "
"<structfield>rd_options</structfield> field of the index's relcache entry. "
"The data contents of the <type>bytea</type> value are open for the access "
"method to define; most of the standard access methods use struct "
"<structname>StdRdOptions</structname>. When <parameter>validate</parameter> "
"is true, the function should report a suitable error message if any of the "
"options are unrecognized or have invalid values; when <parameter>validate</"
"parameter> is false, invalid entries should be silently ignored. "
"(<parameter>validate</parameter> is false when loading options already "
"stored in <structname>pg_catalog</structname>; an invalid entry could only "
"be found if the access method has changed its rules for options, and in that "
"case ignoring obsolete entries is appropriate.) It is OK to return NULL if "
"default behavior is wanted."
msgstr ""
"<placeholder-1/> Разбирает и проверяет массив параметров для индекса. Эта "
"функция вызывается, только когда для индекса задан отличный от NULL массив "
"reloptions. Массив <parameter>reloptions</parameter> состоит из элементов "
"типа <type>text</type>, содержащих записи вида <replaceable>имя</"
"replaceable><literal>=</literal><replaceable>значение</replaceable>. Данная "
"функция должна получить значение типа <type>bytea</type>, которое будет "
"скопировано в поле <structfield>rd_options</structfield> записи индекса в "
"relcache. Содержимое этого значения <type>bytea</type> определяется самим "
"методом доступа; большинство стандартных методов доступа помещают в него "
"структуру <structname>StdRdOptions</structname>. Когда параметр "
"<parameter>validate</parameter> равен true, эта функция должна выдать "
"подходящее сообщение об ошибке, если какие-либо параметры нераспознаны или "
"имеют недопустимые значения; если же <parameter>validate</parameter> равен "
"false, некорректные записи должны просто игнорироваться. (В "
"<parameter>validate</parameter> передаётся false, когда параметры уже "
"загружены в <structname>pg_catalog</structname>; при этом неверная запись "
"может быть обнаружена, только если в методе доступа поменялись правила "
"обработки параметров, и в этом случае стоит просто игнорировать такие "
"записи.) NULL можно вернуть, когда нужно получить поведение по умолчанию."

#: indexam.xml:403(programlisting)
#, no-wrap
msgid ""
"bool\n"
"amproperty (Oid index_oid, int attno,\n"
"            IndexAMProperty prop, const char *propname,\n"
"            bool *res, bool *isnull);"
msgstr ""
"bool\n"
"amproperty (Oid index_oid, int attno,\n"
"            IndexAMProperty prop, const char *propname,\n"
"            bool *res, bool *isnull);"

#: indexam.xml:402(para)
msgid ""
"<placeholder-1/> The <function>amproperty</function> method allows index "
"access methods to override the default behavior of "
"<function>pg_index_column_has_property</function> and related functions. If "
"the access method does not have any special behavior for index property "
"inquiries, the <structfield>amproperty</structfield> field in its "
"<structname>IndexAmRoutine</structname> struct can be set to NULL. "
"Otherwise, the <function>amproperty</function> method will be called with "
"<parameter>index_oid</parameter> and <parameter>attno</parameter> both zero "
"for <function>pg_indexam_has_property</function> calls, or with "
"<parameter>index_oid</parameter> valid and <parameter>attno</parameter> zero "
"for <function>pg_index_has_property</function> calls, or with "
"<parameter>index_oid</parameter> valid and <parameter>attno</parameter> "
"greater than zero for <function>pg_index_column_has_property</function> "
"calls. <parameter>prop</parameter> is an enum value identifying the property "
"being tested, while <parameter>propname</parameter> is the original property "
"name string. If the core code does not recognize the property name then "
"<parameter>prop</parameter> is <literal>AMPROP_UNKNOWN</literal>. Access "
"methods can define custom property names by checking <parameter>propname</"
"parameter> for a match (use <function>pg_strcasecmp</function> to match, for "
"consistency with the core code); for names known to the core code, it's "
"better to inspect <parameter>prop</parameter>. If the "
"<structfield>amproperty</structfield> method returns <literal>true</literal> "
"then it has determined the property test result: it must set <literal>*res</"
"literal> to the boolean value to return, or set <literal>*isnull</literal> "
"to <literal>true</literal> to return a NULL. (Both of the referenced "
"variables are initialized to <literal>false</literal> before the call.) If "
"the <structfield>amproperty</structfield> method returns <literal>false</"
"literal> then the core code will proceed with its normal logic for "
"determining the property test result."
msgstr ""
"<placeholder-1/> Процедура <function>amproperty</function> позволяет методам "
"доступа индексов переопределять стандартное поведение функции "
"<function>pg_index_column_has_property</function> и связанных с ней. Если "
"метод доступа не проявляет никаких особенностей при запросе свойств "
"индексов, поле <structfield>amproperty</structfield> в структуре "
"<structname>IndexAmRoutine</structname> может содержать NULL. В противном "
"случае процедура <function>amproperty</function> будет вызываться с нулевыми "
"параметрами <parameter>index_oid</parameter> и <parameter>attno</parameter> "
"при вызове <function>pg_indexam_has_property</function>, либо с корректным "
"<parameter>index_oid</parameter> и нулевым <parameter>attno</parameter> при "
"вызове <function>pg_index_has_property</function>, либо с корректным "
"<parameter>index_oid</parameter> и положительным <parameter>attno</"
"parameter> при вызове <function>pg_index_column_has_property</function>. В "
"<parameter>prop</parameter> передаётся значение перечисления, указывающее на "
"проверяемое значение, а в <parameter>propname</parameter> — строка с именем "
"свойства. Если код ядра не распознаёт имя свойства, в <parameter>prop</"
"parameter> передаётся <literal>AMPROP_UNKNOWN</literal>. Методы доступа "
"могут воспринимать нестандартные имена свойств, проверяя "
"<parameter>propname</parameter> на совпадение (для согласованности с кодом "
"ядра используйте для проверки <function>pg_strcasecmp</function>); для имён, "
"известных коду ядра, лучше проверять <parameter>prop</parameter>. Если "
"процедура <structfield>amproperty</structfield> возвращает <literal>true</"
"literal>, это значит, что она установила результат проверки свойства: она "
"должна задать в <literal>*res</literal> возвращаемое булевское значение или "
"установить в <literal>*isnull</literal> значение <literal>true</literal>, "
"чтобы возвратить NULL. (Перед вызовом обе упомянутые переменные "
"инициализируются значением <literal>false</literal>.) Если "
"<structfield>amproperty</structfield> возвращает <literal>false</literal>, "
"код ядра переключается на обычную логику определения результата проверки "
"свойства."

#: indexam.xml:440(para)
msgid ""
"Access methods that support ordering operators should implement "
"<literal>AMPROP_DISTANCE_ORDERABLE</literal> property testing, as the core "
"code does not know how to do that and will return NULL. It may also be "
"advantageous to implement <literal>AMPROP_RETURNABLE</literal> testing, if "
"that can be done more cheaply than by opening the index and calling "
"<structfield>amcanreturn</structfield>, which is the core code's default "
"behavior. The default behavior should be satisfactory for all other standard "
"properties."
msgstr ""
"Методы доступа, поддерживающие операторы упорядочивания, должны "
"реализовывать проверку свойства <literal>AMPROP_DISTANCE_ORDERABLE</"
"literal>, так как код ядра не знает, как это сделать и возвращает NULL. "
"Также может быть полезно реализовать проверку <literal>AMPROP_RETURNABLE</"
"literal>, если это можно сделать проще, чем обращаясь к индексу и вызывая "
"<structfield>amcanreturn</structfield> (что делает код ядра по умолчанию). "
"Для всех остальных стандартных свойств поведение ядра по умолчанию можно "
"считать удовлетворительным."

#: indexam.xml:452(programlisting)
#, no-wrap
msgid ""
"bool\n"
"amvalidate (Oid opclassoid);"
msgstr ""
"bool\n"
"amvalidate (Oid opclassoid);"

#: indexam.xml:451(para)
msgid ""
"<placeholder-1/> Validate the catalog entries for the specified operator "
"class, so far as the access method can reasonably do that. For example, this "
"might include testing that all required support functions are provided. The "
"<function>amvalidate</function> function must return false if the opclass is "
"invalid. Problems should be reported with <function>ereport</function> "
"messages."
msgstr ""
"<placeholder-1/> Проверяет записи в каталоге для заданного класса "
"операторов, насколько это может сделать метод доступа. Например, это может "
"включать проверку, все ли необходимые опорные функции реализованы. Функция "
"<function>amvalidate</function> должна вернуть false, если класс операторов "
"непригоден к использованию. Сообщения о проблеме следует выдать через "
"<function>ereport</function>."

#: indexam.xml:464(para)
msgid ""
"The purpose of an index, of course, is to support scans for tuples matching "
"an indexable <literal>WHERE</literal> condition, often called a "
"<firstterm>qualifier</firstterm> or <firstterm>scan key</firstterm>. The "
"semantics of index scanning are described more fully in <xref linkend="
"\"index-scanning\"/>, below. An index access method can support "
"<quote>plain</quote> index scans, <quote>bitmap</quote> index scans, or "
"both. The scan-related functions that an index access method must or may "
"provide are:"
msgstr ""
"Цель индекса, конечно, в том, чтобы поддерживать поиск кортежей, "
"соответствующих индексируемому условию <literal>WHERE</literal>, по "
"<firstterm>ограничению</firstterm> или <firstterm>ключу поиска</firstterm>. "
"Сканирование индекса описывается более полно ниже, в <xref remap=\"6\" "
"linkend=\"index-scanning\"/>. Метод доступа индекса может поддерживать "
"<quote>простое</quote> сканирование, сканирование по <quote>битовой карте</"
"quote> или и то, и другое. Метод доступа должен или может реализовывать "
"следующие функции, связанные со сканированием:"

#: indexam.xml:475(programlisting)
#, no-wrap
msgid ""
"IndexScanDesc\n"
"ambeginscan (Relation indexRelation,\n"
"             int nkeys,\n"
"             int norderbys);"
msgstr ""
"IndexScanDesc\n"
"ambeginscan (Relation indexRelation,\n"
"             int nkeys,\n"
"             int norderbys);"

#: indexam.xml:474(para)
msgid ""
"<placeholder-1/> Prepare for an index scan. The <literal>nkeys</literal> and "
"<literal>norderbys</literal> parameters indicate the number of quals and "
"ordering operators that will be used in the scan; these may be useful for "
"space allocation purposes. Note that the actual values of the scan keys "
"aren't provided yet. The result must be a palloc'd struct. For "
"implementation reasons the index access method <emphasis>must</emphasis> "
"create this struct by calling <function>RelationGetIndexScan()</function>. "
"In most cases <function>ambeginscan</function> does little beyond making "
"that call and perhaps acquiring locks; the interesting parts of index-scan "
"startup are in <function>amrescan</function>."
msgstr ""
"<placeholder-1/> Подготавливает метод к сканированию индекса. В параметрах "
"<literal>nkeys</literal> и <literal>norderbys</literal> задаётся количество "
"операторов условия и сортировки, которые будут задействованы при "
"сканировании; это может быть полезно для выделения памяти. Заметьте, что "
"фактические значения ключей сканирования в этот момент ещё не "
"предоставляются. В результате функция должна выдать структуру, выделенную "
"средствами palloc. В связи с особенностями реализации, метод доступа "
"<emphasis>должен</emphasis> создать эту структуру, вызвав "
"<function>RelationGetIndexScan()</function>. В большинстве случаев все "
"действия <function>ambeginscan</function> сводятся только к выполнению этого "
"вызова и, возможно, получению блокировок; всё самое интересное при запуске "
"сканирования индекса происходит в <function>amrescan</function>."

#: indexam.xml:495(programlisting)
#, no-wrap
msgid ""
"void\n"
"amrescan (IndexScanDesc scan,\n"
"          ScanKey keys,\n"
"          int nkeys,\n"
"          ScanKey orderbys,\n"
"          int norderbys);"
msgstr ""
"void\n"
"amrescan (IndexScanDesc scan,\n"
"          ScanKey keys,\n"
"          int nkeys,\n"
"          ScanKey orderbys,\n"
"          int norderbys);"

#: indexam.xml:494(para)
msgid ""
"<placeholder-1/> Start or restart an index scan, possibly with new scan "
"keys. (To restart using previously-passed keys, NULL is passed for "
"<literal>keys</literal> and/or <literal>orderbys</literal>.) Note that it is "
"not allowed for the number of keys or order-by operators to be larger than "
"what was passed to <function>ambeginscan</function>. In practice the restart "
"feature is used when a new outer tuple is selected by a nested-loop join and "
"so a new key comparison value is needed, but the scan key structure remains "
"the same."
msgstr ""
"<placeholder-1/> Запускает или перезапускает сканирование индекса, возможно, "
"с новыми ключами сканирования. (Для перезапуска сканирования с ранее "
"переданными ключами в <literal>keys</literal> и/или <literal>orderbys</"
"literal> передаётся NULL.) Заметьте, что количество ключей или операторов "
"сортировки не может превышать значения, поступившие в <function>ambeginscan</"
"function>. На практике возможность перезапуска используется, когда в "
"соединении со вложенным циклом выбирается новый внешний кортеж, так что "
"требуется сравнение с новым ключом, но структура ключей сканирования не "
"меняется."

#: indexam.xml:514(programlisting)
#, no-wrap
msgid ""
"boolean\n"
"amgettuple (IndexScanDesc scan,\n"
"            ScanDirection direction);"
msgstr ""
"boolean\n"
"amgettuple (IndexScanDesc scan,\n"
"            ScanDirection direction);"

#: indexam.xml:513(para)
msgid ""
"<placeholder-1/> Fetch the next tuple in the given scan, moving in the given "
"direction (forward or backward in the index). Returns TRUE if a tuple was "
"obtained, FALSE if no matching tuples remain. In the TRUE case the tuple TID "
"is stored into the <literal>scan</literal> structure. Note that "
"<quote>success</quote> means only that the index contains an entry that "
"matches the scan keys, not that the tuple necessarily still exists in the "
"heap or will pass the caller's snapshot test. On success, "
"<function>amgettuple</function> must also set <literal>scan-&gt;xs_recheck</"
"literal> to TRUE or FALSE. FALSE means it is certain that the index entry "
"matches the scan keys. TRUE means this is not certain, and the conditions "
"represented by the scan keys must be rechecked against the heap tuple after "
"fetching it. This provision supports <quote>lossy</quote> index operators. "
"Note that rechecking will extend only to the scan conditions; a partial "
"index predicate (if any) is never rechecked by <function>amgettuple</"
"function> callers."
msgstr ""
"<placeholder-1/> Выбирает следующий кортеж в ходе данного сканирования, с "
"передвижением по индексу в заданном направлении (вперёд или назад). "
"Возвращает TRUE, если кортеж был получен, или FALSE, если подходящих "
"кортежей не осталось. В случае успеха в структуре <literal>scan</literal> "
"сохраняется TID кортежа. Заметьте, что под <quote>успехом</quote> здесь "
"подразумевается только, что индекс содержит запись, соответствующую ключам "
"сканирования, а не то, что данный кортеж обязательно существует в данных или "
"оказывается видимым в снимке вызывающего субъекта. При положительном "
"результате <function>amgettuple</function> должна также установить для "
"свойства <literal>scan-&gt;xs_recheck</literal> значение TRUE или FALSE. "
"FALSE будет означать, что запись индекса точно соответствует ключам "
"сканирования, а TRUE, что есть сомнение в этом, так что условия, "
"представленные ключами сканирования, необходимо ещё раз перепроверить для "
"фактического кортежа, когда он будет получен. Это свойство введено для "
"поддержки <quote>неточных</quote> операторов индексов. Заметьте, что такая "
"перепроверка касается только условий сканирования; предикат частичного "
"индекса (если он имеется) никогда не перепроверяется кодом, вызывающим "
"<function>amgettuple</function>."

#: indexam.xml:536(para)
msgid ""
"If the index supports <link linkend=\"indexes-index-only-scans\">index-only "
"scans</link> (i.e., <function>amcanreturn</function> returns TRUE for it), "
"then on success the AM must also check <literal>scan-&gt;xs_want_itup</"
"literal>, and if that is true it must return the original indexed data for "
"the index entry, in the form of an <structname>IndexTuple</structname> "
"pointer stored at <literal>scan-&gt;xs_itup</literal>, with tuple descriptor "
"<literal>scan-&gt;xs_itupdesc</literal>. (Management of the data referenced "
"by the pointer is the access method's responsibility. The data must remain "
"good at least until the next <function>amgettuple</function>, "
"<function>amrescan</function>, or <function>amendscan</function> call for "
"the scan.)"
msgstr ""
"Если индекс поддерживает <link linkend=\"indexes-index-only-scans"
"\">сканирование только индекса</link> (то есть, <function>amcanreturn</"
"function> для него равен TRUE), то в случае успеха метод доступа должен "
"также проверить флаг <literal>scan-&gt;xs_want_itup</literal>, и, если он "
"установлен, должен вернуть исходные индексированные данные для этой записи "
"индекса, в виде указателя на <structname>IndexTuple</structname>, "
"сохранённого в <literal>scan-&gt;xs_itup</literal>, и дескриптор кортежа "
"<literal>scan-&gt;xs_itupdesc</literal>. (Контролировать структуру данных, "
"на которую указывает этот указатель, должен сам метод доступа. Она должна "
"сохраняться в рабочем состоянии как минимум до следующего вызова "
"<function>amgettuple</function>, <function>amrescan</function> или "
"<function>amendscan</function> в текущем сканировании.)"

#: indexam.xml:550(para)
msgid ""
"The <function>amgettuple</function> function need only be provided if the "
"access method supports <quote>plain</quote> index scans. If it doesn't, the "
"<structfield>amgettuple</structfield> field in its "
"<structname>IndexAmRoutine</structname> struct must be set to NULL."
msgstr ""
"Функция <function>amgettuple</function> должна быть реализована, только если "
"метод доступа поддерживает <quote>простое</quote> сканирование индекса. В "
"противном случае поле <structfield>amgettuple</structfield> в структуре "
"<structname>IndexAmRoutine</structname> должно содержать NULL."

#: indexam.xml:558(programlisting)
#, no-wrap
msgid ""
"int64\n"
"amgetbitmap (IndexScanDesc scan,\n"
"             TIDBitmap *tbm);"
msgstr ""
"int64\n"
"amgetbitmap (IndexScanDesc scan,\n"
"             TIDBitmap *tbm);"

#: indexam.xml:557(para)
msgid ""
"<placeholder-1/> Fetch all tuples in the given scan and add them to the "
"caller-supplied <type>TIDBitmap</type> (that is, OR the set of tuple IDs "
"into whatever set is already in the bitmap). The number of tuples fetched is "
"returned (this might be just an approximate count, for instance some AMs do "
"not detect duplicates). While inserting tuple IDs into the bitmap, "
"<function>amgetbitmap</function> can indicate that rechecking of the scan "
"conditions is required for specific tuple IDs. This is analogous to the "
"<literal>xs_recheck</literal> output parameter of <function>amgettuple</"
"function>. Note: in the current implementation, support for this feature is "
"conflated with support for lossy storage of the bitmap itself, and therefore "
"callers recheck both the scan conditions and the partial index predicate (if "
"any) for recheckable tuples. That might not always be true, however. "
"<function>amgetbitmap</function> and <function>amgettuple</function> cannot "
"be used in the same index scan; there are other restrictions too when using "
"<function>amgetbitmap</function>, as explained in <xref linkend=\"index-"
"scanning\"/>."
msgstr ""
"<placeholder-1/> Выбирает все кортежи для данного сканирования и добавляет "
"их в передаваемую вызывающим кодом структуру <type>TIDBitmap</type> (то "
"есть, получает логическое объединение множества TID выбранных кортежей с "
"множеством, уже записанным в битовой карте). Возвращает эта функция число "
"полученных кортежей (это может быть только приблизительная оценка; например, "
"некоторые методы доступа не учитывают повторяющиеся значения). Добавляя "
"идентификаторы кортежей в битовую карту, <function>amgetbitmap</function> "
"может обозначить, что для этих кортежей нужно перепроверить условия "
"сканирования. Для этого так же, как и в <function>amgettuple</function>, "
"устанавливается выходной параметр <literal>xs_recheck</literal>. Замечание: "
"в текущей реализации эта возможность увязывается с возможностью неточного "
"хранения самих битовых карт, таким образом вызывающий код перепроверяет для "
"отмеченных кортежей и условия сканирования, и предикат частичного индекса "
"(если он имеется). Однако так может быть не всегда. Функции "
"<function>amgetbitmap</function> и <function>amgettuple</function> не могут "
"использоваться в одном сканировании индекса; есть и другие ограничения в "
"применении <function>amgetbitmap</function>, описанные в <xref remap=\"6\" "
"linkend=\"index-scanning\"/>."

#: indexam.xml:581(para)
msgid ""
"The <function>amgetbitmap</function> function need only be provided if the "
"access method supports <quote>bitmap</quote> index scans. If it doesn't, the "
"<structfield>amgetbitmap</structfield> field in its "
"<structname>IndexAmRoutine</structname> struct must be set to NULL."
msgstr ""
"Функция <function>amgetbitmap</function> должна быть реализована, только "
"если метод доступа поддерживает сканирование индекса <quote>по битовой "
"карте</quote>. В противном случае поле <structfield>amgetbitmap</"
"structfield> в структуре <structname>IndexAmRoutine</structname> должно "
"содержать NULL."

#: indexam.xml:589(programlisting)
#, no-wrap
msgid ""
"void\n"
"amendscan (IndexScanDesc scan);"
msgstr ""
"void\n"
"amendscan (IndexScanDesc scan);"

#: indexam.xml:588(para)
msgid ""
"<placeholder-1/> End a scan and release resources. The <literal>scan</"
"literal> struct itself should not be freed, but any locks or pins taken "
"internally by the access method must be released."
msgstr ""
"<placeholder-1/> Завершает сканирование и освобождает ресурсы. Саму "
"структуру <literal>scan</literal> освобождать не следует, но любые "
"блокировки или закрепления объектов, установленные внутри метода доступа, "
"должны быть сняты."

#: indexam.xml:599(programlisting)
#, no-wrap
msgid ""
"void\n"
"ammarkpos (IndexScanDesc scan);"
msgstr ""
"void\n"
"ammarkpos (IndexScanDesc scan);"

#: indexam.xml:598(para)
msgid ""
"<placeholder-1/> Mark current scan position. The access method need only "
"support one remembered scan position per scan."
msgstr ""
"<placeholder-1/> Помечает текущую позицию сканирования. Метод доступа должен "
"поддерживать сохранение только одной позиции в процессе сканирования."

#: indexam.xml:607(para)
msgid ""
"The <function>ammarkpos</function> function need only be provided if the "
"access method supports ordered scans. If it doesn't, the "
"<structfield>ammarkpos</structfield> field in its "
"<structname>IndexAmRoutine</structname> struct may be set to NULL."
msgstr ""
"Функция <function>ammarkpos</function> должна быть реализована, только если "
"метод доступа поддерживает сканирование по порядку. Если это не так, в поле "
"<structfield>ammarkpos</structfield> в структуре <structname>IndexAmRoutine</"
"structname> можно записать NULL."

#: indexam.xml:615(programlisting)
#, no-wrap
msgid ""
"void\n"
"amrestrpos (IndexScanDesc scan);"
msgstr ""
"void\n"
"amrestrpos (IndexScanDesc scan);"

#: indexam.xml:614(para)
msgid "<placeholder-1/> Restore the scan to the most recently marked position."
msgstr ""
"<placeholder-1/> Восстанавливает позицию сканирования, отмеченную последней."

#: indexam.xml:622(para)
msgid ""
"The <function>amrestrpos</function> function need only be provided if the "
"access method supports ordered scans. If it doesn't, the "
"<structfield>amrestrpos</structfield> field in its "
"<structname>IndexAmRoutine</structname> struct may be set to NULL."
msgstr ""
"Функция <function>amrestrpos</function> должна быть реализована, только если "
"метод доступа поддерживает сканирование по порядку. Если это не так, в поле "
"<structfield>amrestrpos</structfield> в структуре "
"<structname>IndexAmRoutine</structname> можно записать NULL."

#: indexam.xml:631(title)
msgid "Index Scanning"
msgstr "Сканирование индекса"

#: indexam.xml:633(para)
msgid ""
"In an index scan, the index access method is responsible for regurgitating "
"the TIDs of all the tuples it has been told about that match the "
"<firstterm>scan keys</firstterm>. The access method is <emphasis>not</"
"emphasis> involved in actually fetching those tuples from the index's parent "
"table, nor in determining whether they pass the scan's time qualification "
"test or other conditions."
msgstr ""
"В процессе сканирования метод доступа индекса отвечает только за выдачу "
"идентификаторов всех кортежей, которые по его представлению соответствуют "
"<firstterm>ключам сканирования</firstterm>. Метод доступа <emphasis>не</"
"emphasis> участвует в самой процедуре выборки этих кортежей из основной "
"таблицы и не определяет, удовлетворяют ли эти кортежи условиям видимости или "
"другим ограничениям."

#: indexam.xml:642(para)
msgid ""
"A scan key is the internal representation of a <literal>WHERE</literal> "
"clause of the form <replaceable>index_key</replaceable> "
"<replaceable>operator</replaceable> <replaceable>constant</replaceable>, "
"where the index key is one of the columns of the index and the operator is "
"one of the members of the operator family associated with that index column. "
"An index scan has zero or more scan keys, which are implicitly ANDed &mdash; "
"the returned tuples are expected to satisfy all the indicated conditions."
msgstr ""
"Ключом сканирования является внутреннее представление предложения "
"<literal>WHERE</literal> в виде <replaceable>ключ_индекса</replaceable> "
"<replaceable>оператор</replaceable> <replaceable>константа</replaceable>, "
"где ключ индекса — один из столбцов индекса, а оператор — один из членов "
"семейства операторов, связанного с типом данного столбца. При сканировании "
"по индексу могут задаваться несколько или ноль ключей сканирования, "
"результаты поиска которых должны неявно объединяться операцией AND &mdash; "
"ожидается, что возвращаемые кортежи будут удовлетворять всем заданным "
"условиям."

#: indexam.xml:652(para)
msgid ""
"The access method can report that the index is <firstterm>lossy</firstterm>, "
"or requires rechecks, for a particular query. This implies that the index "
"scan will return all the entries that pass the scan key, plus possibly "
"additional entries that do not. The core system's index-scan machinery will "
"then apply the index conditions again to the heap tuple to verify whether or "
"not it really should be selected. If the recheck option is not specified, "
"the index scan must return exactly the set of matching entries."
msgstr ""
"Метод доступа для конкретного запроса может сообщить, что индекс является "
"<firstterm>неточным</firstterm> или, другими словами, требует перепроверки. "
"Это подразумевает, что при сканировании индекса будут возвращены все записи, "
"соответствующие ключу сканирования, плюс, возможно, дополнительные записи, "
"которые ему не соответствуют. Внутренний механизм сканирования затем "
"повторно применит условия индекса к кортежу данных, чтобы проверить, нужно "
"ли его выбирать на самом деле. Если признак перепроверки не установлен, при "
"сканировании индекса должны возвращаться только соответствующие ключам "
"записи."

#: indexam.xml:662(para)
msgid ""
"Note that it is entirely up to the access method to ensure that it correctly "
"finds all and only the entries passing all the given scan keys. Also, the "
"core system will simply hand off all the <literal>WHERE</literal> clauses "
"that match the index keys and operator families, without any semantic "
"analysis to determine whether they are redundant or contradictory. As an "
"example, given <literal>WHERE x &gt; 4 AND x &gt; 14</literal> where "
"<literal>x</literal> is a b-tree indexed column, it is left to the b-tree "
"<function>amrescan</function> function to realize that the first scan key is "
"redundant and can be discarded. The extent of preprocessing needed during "
"<function>amrescan</function> will depend on the extent to which the index "
"access method needs to reduce the scan keys to a <quote>normalized</quote> "
"form."
msgstr ""
"Заметьте, что именно метод доступа должен гарантировать, что корректно будут "
"найдены все и только те записи, которые соответствуют всем переданным ключам "
"сканирования. Также учтите, что ядро системы просто передаёт все предложения "
"<literal>WHERE</literal> с подходящими ключами индекса и семействами "
"операторов, не проводя семантический анализ на предмет их избыточности или "
"противоречивости. Например, с условием <literal>WHERE x &gt; 4 AND x &gt; "
"14</literal>, где <literal>x</literal> — столбец с индексом-B-деревом, "
"именно самой функции <function>amrescan</function> в методе B-дерева "
"предоставляется возможность понять, что первый ключ сканирования избыточный "
"и может быть отброшен. Объём предварительной обработки, которую нужно "
"произвести для этого в <function>amrescan</function>, зависит от того, до "
"какой степени метод доступа должен сводить ключи к <quote>нормализованной</"
"quote> форме."

#: indexam.xml:684(para)
msgid ""
"Access methods that always return entries in the natural ordering of their "
"data (such as btree) should set <structfield>amcanorder</structfield> to "
"true. Currently, such access methods must use btree-compatible strategy "
"numbers for their equality and ordering operators."
msgstr ""
"Для методов доступа, которые всегда возвращают записи в порядке их "
"естественной сортировки (как например, в B-дереве), устанавливается признак "
"<structfield>amcanorder</structfield>. В настоящее время операторам проверки "
"равенства и упорядочивания при этом должны назначаться номера "
"соответствующих стратегий B-дерева."

#: indexam.xml:693(para)
msgid ""
"Access methods that support ordering operators should set "
"<structfield>amcanorderbyop</structfield> to true. This indicates that the "
"index is capable of returning entries in an order satisfying <literal>ORDER "
"BY</literal> <replaceable>index_key</replaceable> <replaceable>operator</"
"replaceable> <replaceable>constant</replaceable>. Scan modifiers of that "
"form can be passed to <function>amrescan</function> as described previously."
msgstr ""
"Для методов доступа, которые поддерживают операторы упорядочивания, "
"устанавливается признак <structfield>amcanorderbyop</structfield>. Он "
"показывает, что индекс может возвращать записи в порядке, определяемом "
"предложением <literal>ORDER BY</literal> <replaceable>ключ_индекса</"
"replaceable> <replaceable>оператор</replaceable> <replaceable>константа</"
"replaceable>. Модификаторы для такого сканирования могут передаваться в "
"<function>amrescan</function>, как описывалось ранее."

#: indexam.xml:677(para)
msgid ""
"Some access methods return index entries in a well-defined order, others do "
"not. There are actually two different ways that an access method can support "
"sorted output: <placeholder-1/>"
msgstr ""
"Некоторые методы доступа возвращают записи индекса в чётко определённом "
"порядке, в отличие от других. Фактически есть два различных варианта "
"реализации упорядоченного вывода некоторым методом доступа: <placeholder-1/>"

#: indexam.xml:706(para)
msgid ""
"The <function>amgettuple</function> function has a <literal>direction</"
"literal> argument, which can be either <literal>ForwardScanDirection</"
"literal> (the normal case) or <literal>BackwardScanDirection</literal>. If "
"the first call after <function>amrescan</function> specifies "
"<literal>BackwardScanDirection</literal>, then the set of matching index "
"entries is to be scanned back-to-front rather than in the normal front-to-"
"back direction, so <function>amgettuple</function> must return the last "
"matching tuple in the index, rather than the first one as it normally would. "
"(This will only occur for access methods that set <structfield>amcanorder</"
"structfield> to true.) After the first call, <function>amgettuple</function> "
"must be prepared to advance the scan in either direction from the most "
"recently returned entry. (But if <structfield>amcanbackward</structfield> is "
"false, all subsequent calls will have the same direction as the first one.)"
msgstr ""
"У функции <function>amgettuple</function> есть аргумент <literal>direction</"
"literal>, который может принимать значение <literal>ForwardScanDirection</"
"literal> (обычный вариант, сканирование вперёд) или "
"<literal>BackwardScanDirection</literal> (сканирование назад). Если в первом "
"вызове после <function>amrescan</function> указывается "
"<literal>BackwardScanDirection</literal>, то множество соответствующих "
"записей индекса сканируется от конца к началу, а не в обычном направлении от "
"начала к концу. В этом случае <function>amgettuple</function> должна вернуть "
"последний соответствующий кортеж индекса, а не первый как обычно. (Это "
"распространяется только на методы доступа с установленным признаком "
"<structfield>amcanorder</structfield>.) После первого вызова "
"<function>amgettuple</function> должна быть готова продолжать сканирование в "
"любом направлении от записи, выданной последней до этого. (Но если признак "
"<structfield>amcanbackward</structfield> не установлен, при всех последующих "
"вызовах должно сохраняться то же направление, что было в первом.)"

#: indexam.xml:722(para)
msgid ""
"Access methods that support ordered scans must support <quote>marking</"
"quote> a position in a scan and later returning to the marked position. The "
"same position might be restored multiple times. However, only one position "
"need be remembered per scan; a new <function>ammarkpos</function> call "
"overrides the previously marked position. An access method that does not "
"support ordered scans need not provide <function>ammarkpos</function> and "
"<function>amrestrpos</function> functions in <structname>IndexAmRoutine</"
"structname>; set those pointers to NULL instead."
msgstr ""
"Методы доступа, которые поддерживают упорядоченное сканирование, должны "
"уметь <quote>помечать</quote> позицию сканирования и затем возвращаться к "
"помеченной позиции (возможно, несколько раз к одной и той же позиции). Но "
"запоминаться должна только одна позиция в ходе сканирования; последующий "
"вызов <function>ammarkpos</function> переопределяет ранее сохранённую "
"позицию. Метод доступа, не поддерживающий упорядоченное сканирование, не "
"должен определять функции <function>ammarkpos</function> и "
"<function>amrestrpos</function> в <structname>IndexAmRoutine</structname>; "
"достаточно записать в эти указатели NULL."

#: indexam.xml:733(para)
msgid ""
"Both the scan position and the mark position (if any) must be maintained "
"consistently in the face of concurrent insertions or deletions in the index. "
"It is OK if a freshly-inserted entry is not returned by a scan that would "
"have found the entry if it had existed when the scan started, or for the "
"scan to return such an entry upon rescanning or backing up even though it "
"had not been returned the first time through. Similarly, a concurrent delete "
"might or might not be reflected in the results of a scan. What is important "
"is that insertions or deletions not cause the scan to miss or multiply "
"return entries that were not themselves being inserted or deleted."
msgstr ""
"И позиция сканирования, и отмеченная позиция (при наличии) должны "
"поддерживаться в согласованном состоянии с учётом одновременных добавлений "
"или удалений записей в индексе. Не будет ошибкой, если только что "
"вставленная запись не будет выдана при сканировании, которое могло бы найти "
"эту запись, если бы она существовала до его начала, либо если сканирование "
"выдаст такую запись после перезапуска или возврата, даже если она не была "
"выдана в первый раз. Подобным образом, параллельное удаление может "
"отражаться, а может и не отражаться в результатах сканирования. Важно "
"только, чтобы при таких операциях добавления или удаления не происходило "
"потерь или дублирования записей, которые в этих операциях не участвовали."

#: indexam.xml:746(para)
msgid ""
"If the index stores the original indexed data values (and not some lossy "
"representation of them), it is useful to support <link linkend=\"indexes-"
"index-only-scans\">index-only scans</link>, in which the index returns the "
"actual data not just the TID of the heap tuple. This will only avoid I/O if "
"the visibility map shows that the TID is on an all-visible page; else the "
"heap tuple must be visited anyway to check MVCC visibility. But that is no "
"concern of the access method's."
msgstr ""
"Если индекс сохраняет исходные индексируемые значения данных (а не их "
"искажённое представление), обычно полезно поддержать <link linkend=\"indexes-"
"index-only-scans\">сканирование только индекса</link>, при котором индекс "
"возвращает фактические данные, а не только TID кортежа данных. Это позволит "
"соптимизировать ввод/вывод, только если карта видимости показывает, что TID "
"относится к полностью видимой странице; в противном случае всё равно "
"придётся посетить кортеж, чтобы проверить его видимость для MVCC. Но это не "
"является заботой метода доступа."

#: indexam.xml:756(para)
msgid ""
"Instead of using <function>amgettuple</function>, an index scan can be done "
"with <function>amgetbitmap</function> to fetch all tuples in one call. This "
"can be noticeably more efficient than <function>amgettuple</function> "
"because it allows avoiding lock/unlock cycles within the access method. In "
"principle <function>amgetbitmap</function> should have the same effects as "
"repeated <function>amgettuple</function> calls, but we impose several "
"restrictions to simplify matters. First of all, <function>amgetbitmap</"
"function> returns all tuples at once and marking or restoring scan positions "
"isn't supported. Secondly, the tuples are returned in a bitmap which doesn't "
"have any specific ordering, which is why <function>amgetbitmap</function> "
"doesn't take a <literal>direction</literal> argument. (Ordering operators "
"will never be supplied for such a scan, either.) Also, there is no provision "
"for index-only scans with <function>amgetbitmap</function>, since there is "
"no way to return the contents of index tuples. Finally, "
"<function>amgetbitmap</function> does not guarantee any locking of the "
"returned tuples, with implications spelled out in <xref linkend=\"index-"
"locking\"/>."
msgstr ""
"Вместо <function>amgettuple</function>, сканирование индекса может "
"осуществляться функцией <function>amgetbitmap</function>, которая выбирает "
"все кортежи за один вызов. Это может быть значительно эффективнее "
"<function>amgettuple</function>, так как позволяет избежать циклов "
"блокировки/разблокировки в методе доступа. В принципе, "
"<function>amgetbitmap</function> должна давать тот же эффект, что и "
"многократные вызовы <function>amgettuple</function>, но простоты ради мы "
"накладываем ряд дополнительных ограничений. Во-первых, "
"<function>amgetbitmap</function> возвращает все кортежи сразу и не "
"поддерживает пометку позиций и возвращение к ним. Во-вторых, кортежи, "
"возвращаемые в битовой карте, не упорядочиваются каким-либо определённым "
"образом, поэтому <function>amgetbitmap</function> не принимает аргумент "
"<literal>direction</literal>. (И операторы упорядочивания никогда не будут "
"передаваться для такого сканирования.) Кроме того, сканирование только "
"индекса с <function>amgetbitmap</function> неосуществимо, так как нет "
"никакой возможности возвратить содержимое кортежей индекса. Наконец, "
"<function>amgetbitmap</function> не гарантирует, что будут установлены какие-"
"либо блокировки для возвращаемых кортежей, и следствия этого описаны в <xref "
"remap=\"6\" linkend=\"index-locking\"/>."

#: indexam.xml:777(para)
msgid ""
"Note that it is permitted for an access method to implement only "
"<function>amgetbitmap</function> and not <function>amgettuple</function>, or "
"vice versa, if its internal implementation is unsuited to one API or the "
"other."
msgstr ""
"Заметьте, что метод доступа может реализовывать только функцию "
"<function>amgetbitmap</function>, но не <function>amgettuple</function>, и "
"наоборот, если его внутренняя реализация несовместима с одной из этих "
"функций."

#: indexam.xml:786(title)
msgid "Index Locking Considerations"
msgstr "Замечания о блокировке с индексами"

#: indexam.xml:788(para)
msgid ""
"Index access methods must handle concurrent updates of the index by multiple "
"processes. The core <productname>PostgreSQL</productname> system obtains "
"<literal>AccessShareLock</literal> on the index during an index scan, and "
"<literal>RowExclusiveLock</literal> when updating the index (including plain "
"<command>VACUUM</command>). Since these lock types do not conflict, the "
"access method is responsible for handling any fine-grained locking it might "
"need. An exclusive lock on the index as a whole will be taken only during "
"index creation, destruction, or <command>REINDEX</command>."
msgstr ""
"Методы доступа индекса должны справляться с параллельными операциями "
"обновления индекса, производимыми несколькими процессами. Ядро системы "
"<productname>PostgreSQL</productname> получает блокировку "
"<literal>AccessShareLock</literal> для индекса в процессе сканирования и "
"<literal>RowExclusiveLock</literal> при модификации индекса (включая и "
"обычную очистку командой <command>VACUUM</command>). Так как эти типы "
"блокировок не конфликтуют, метод доступа должен сам устанавливать более "
"тонкие блокировки, которые ему могут потребоваться. Исключительная "
"блокировка индекса в целом устанавливается только при создании и уничтожении "
"индекса или операции <command>REINDEX</command>."

#: indexam.xml:800(para)
msgid ""
"Building an index type that supports concurrent updates usually requires "
"extensive and subtle analysis of the required behavior. For the b-tree and "
"hash index types, you can read about the design decisions involved in "
"<filename>src/backend/access/nbtree/README</filename> and <filename>src/"
"backend/access/hash/README</filename>."
msgstr ""
"Реализация типа индекса, поддерживающего параллельные изменения, обычно "
"требует глубокого и всестороннего анализа требуемого поведения. Для общего "
"представления вы можете узнать о конструктивных решениях, принятых при "
"реализации B-дерева и индекса по хешу, обратившись к <filename>src/backend/"
"access/nbtree/README</filename> и <filename>src/backend/access/hash/README</"
"filename>."

#: indexam.xml:819(para)
msgid ""
"A new heap entry is made before making its index entries. (Therefore a "
"concurrent index scan is likely to fail to see the heap entry. This is okay "
"because the index reader would be uninterested in an uncommitted row anyway. "
"But see <xref linkend=\"index-unique-checks\"/>.)"
msgstr ""
"Новая запись в области данных добавляется до того, как для неё будут созданы "
"записи в индексах. (Таким образом, при параллельном сканировании индекса эта "
"запись в данных скорее всего не будет замечена. Это не проблема, так как "
"читателю индекса всё равно не нужны незафиксированные строки. Но учтите "
"написанное в <xref remap=\"6\" linkend=\"index-unique-checks\"/>.)"

#: indexam.xml:827(para)
msgid ""
"When a heap entry is to be deleted (by <command>VACUUM</command>), all its "
"index entries must be removed first."
msgstr ""
"Когда запись данных удаляется (командой <command>VACUUM</command>), сначала "
"должны удалиться все созданные для неё записи в индексах."

#: indexam.xml:833(para)
msgid ""
"An index scan must maintain a pin on the index page holding the item last "
"returned by <function>amgettuple</function>, and <function>ambulkdelete</"
"function> cannot delete entries from pages that are pinned by other "
"backends. The need for this rule is explained below."
msgstr ""
"Сканирование индекса должно закрепить страницу индекса, на которой находится "
"элемент, возвращённый последним вызовом <function>amgettuple</function>, а "
"<function>ambulkdelete</function> не должна удалять записи со страниц, "
"закреплённых другими процессами. Чем обосновано это правило, описывается "
"ниже."

#: indexam.xml:808(para)
msgid ""
"Aside from the index's own internal consistency requirements, concurrent "
"updates create issues about consistency between the parent table (the "
"<firstterm>heap</firstterm>) and the index. Because <productname>PostgreSQL</"
"productname> separates accesses and updates of the heap from those of the "
"index, there are windows in which the index might be inconsistent with the "
"heap. We handle this problem with the following rules: <placeholder-1/> "
"Without the third rule, it is possible for an index reader to see an index "
"entry just before it is removed by <command>VACUUM</command>, and then to "
"arrive at the corresponding heap entry after that was removed by "
"<command>VACUUM</command>. This creates no serious problems if that item "
"number is still unused when the reader reaches it, since an empty item slot "
"will be ignored by <function>heap_fetch()</function>. But what if a third "
"backend has already re-used the item slot for something else? When using an "
"MVCC-compliant snapshot, there is no problem because the new occupant of the "
"slot is certain to be too new to pass the snapshot test. However, with a non-"
"MVCC-compliant snapshot (such as <literal>SnapshotAny</literal>), it would "
"be possible to accept and return a row that does not in fact match the scan "
"keys. We could defend against this scenario by requiring the scan keys to be "
"rechecked against the heap row in all cases, but that is too expensive. "
"Instead, we use a pin on an index page as a proxy to indicate that the "
"reader might still be <quote>in flight</quote> from the index entry to the "
"matching heap entry. Making <function>ambulkdelete</function> block on such "
"a pin ensures that <command>VACUUM</command> cannot delete the heap entry "
"before the reader is done with it. This solution costs little in run time, "
"and adds blocking overhead only in the rare cases where there actually is a "
"conflict."
msgstr ""
"Помимо собственных внутренних требований индексов к целостности, при "
"параллельном обновлении данных возникают вопросы согласованности "
"родительской таблицы (<firstterm>основных данных</firstterm>) и индекса. "
"Вследствие того, что <productname>PostgreSQL</productname> отделяет чтение и "
"изменение основных данных от чтения и изменения индекса, образуются "
"временные интервалы, в которых индекс может быть несогласованным с данными. "
"Мы решаем эту проблему, применяя следующие правила: <placeholder-1/> Без "
"третьего правила читатель индекса мог бы увидеть запись индекса за мгновение "
"до того, как она была удалена процедурой <command>VACUUM</command>, а затем "
"обратиться к соответствующей записи данных после того, как <command>VACUUM</"
"command> удалит и её. Это не приведёт к серьёзным проблемам, если данный "
"элемент остаётся незадействованным, когда к нему обращается читатель, так "
"как пустой слот будет игнорироваться функцией <function>heap_fetch()</"
"function>. Но как быть, если третий процесс уже занял этот слот какими-то "
"своими данными? Когда применяется снимок, совместимый с MVCC, и это не "
"проблема, так как эти данные определённо окажутся слишком новыми при "
"проверке видимости для данного снимка. Однако, для снимка несовместимого с "
"MVCC (например, снимка <literal>SnapshotAny</literal>), может так "
"получиться, что будет возвращена строка, на самом деле не соответствующая "
"ключам сканирования. Мы можем защититься от такого исхода, потребовав, чтобы "
"ключи сканирования всегда перепроверялись для строки данных, но это слишком "
"дорогостоящее решение. Вместо этого, мы закрепляем страницу индекса как "
"промежуточный объект, показывающий, что читатель может всё ещё быть <quote>в "
"пути</quote> от записи индекса к соответствующей строке данных. Благодаря "
"тому, что <function>ambulkdelete</function> блокируется при обращении к этой "
"закреплённой странице, процедура <command>VACUUM</command> не сможет удалить "
"строку данных, пока её извлечение не закончит читатель. Это решение "
"оказывается очень недорогим по времени выполнения, а издержки блокирования "
"привносятся только в редких случаях, когда действительно возникает конфликт."

#: indexam.xml:866(para)
msgid ""
"This solution requires that index scans be <quote>synchronous</quote>: we "
"have to fetch each heap tuple immediately after scanning the corresponding "
"index entry. This is expensive for a number of reasons. An "
"<quote>asynchronous</quote> scan in which we collect many TIDs from the "
"index, and only visit the heap tuples sometime later, requires much less "
"index locking overhead and can allow a more efficient heap access pattern. "
"Per the above analysis, we must use the synchronous approach for non-MVCC-"
"compliant snapshots, but an asynchronous scan is workable for a query using "
"an MVCC snapshot."
msgstr ""
"Такое решение требует, чтобы сканирования индексов выполнялись "
"<quote>синхронно</quote>: мы должны выбирать каждый следующий кортеж данных "
"сразу после того получили соответствущую запись индекса. Это оказывается "
"невыгодно по ряду причин. <quote>Асинхронное</quote> сканирование, при "
"котором мы собираем множество TID из индекса, и обращаемся за кортежами "
"данных только после этого, влечёт гораздо меньше издержек с блокировками и "
"позволяет обращаться к данным более эффективным образом. Согласно "
"проведённому выше анализу, мы должны использовать синхронный подход для "
"снимков, несовместимых с MVCC, но для запросов со снимками MVCC будет "
"работать и асинхронное сканирование."

#: indexam.xml:878(para)
msgid ""
"In an <function>amgetbitmap</function> index scan, the access method does "
"not keep an index pin on any of the returned tuples. Therefore it is only "
"safe to use such scans with MVCC-compliant snapshots."
msgstr ""
"При сканировании индекса с <function>amgetbitmap</function>, метод доступа "
"не закрепляет страницы индекса ни для каких из возвращаемых кортежей. "
"Поэтому такое сканирование можно безопасно применять только со снимками MVCC."

#: indexam.xml:884(para)
msgid ""
"When the <structfield>ampredlocks</structfield> flag is not set, any scan "
"using that index access method within a serializable transaction will "
"acquire a nonblocking predicate lock on the full index. This will generate a "
"read-write conflict with the insert of any tuple into that index by a "
"concurrent serializable transaction. If certain patterns of read-write "
"conflicts are detected among a set of concurrent serializable transactions, "
"one of those transactions may be canceled to protect data integrity. When "
"the flag is set, it indicates that the index access method implements finer-"
"grained predicate locking, which will tend to reduce the frequency of such "
"transaction cancellations."
msgstr ""
"Когда флаг <structfield>ampredlocks</structfield> не установлен, любое "
"сканирование с данным методом доступа в сериализуемой транзакции будет "
"получать неблокирующую предикатную блокировку для всего индекса. Это будет "
"приводить к конфликту чтения-записи при добавлении любого кортежа в этот "
"индекс параллельной сериализуемой транзакцией. Если среди набора "
"параллельных сериализуемых транзакций выявляются определённые варианты "
"конфликтов чтения-записи, одна из этих транзакций может быть отменена для "
"сохранения целостности данных. Когда данный флаг установлен, это означает, "
"что метод доступа реализует более точную предикатную блокировку, что "
"способствует сокращению частоты отмены транзакций по этой причине."

#: indexam.xml:900(title)
msgid "Index Uniqueness Checks"
msgstr "Проверки уникальности в индексе"

#: indexam.xml:902(para)
msgid ""
"<productname>PostgreSQL</productname> enforces SQL uniqueness constraints "
"using <firstterm>unique indexes</firstterm>, which are indexes that disallow "
"multiple entries with identical keys. An access method that supports this "
"feature sets <structfield>amcanunique</structfield> true. (At present, only "
"b-tree supports it.)"
msgstr ""
"<productname>PostgreSQL</productname> реализует ограничения уникальности "
"SQL, применяя <firstterm>уникальные индексы</firstterm>, то есть такие "
"индексы, которые не принимают несколько записей с одинаковыми ключами. Для "
"метода доступа, поддерживающего это свойство, устанавливается признак "
"<structfield>amcanunique</structfield>. (В настоящее время это поддерживают "
"только B-деревья.)"

#: indexam.xml:920(para)
msgid ""
"If a conflicting valid row has been deleted by the current transaction, it's "
"okay. (In particular, since an UPDATE always deletes the old row version "
"before inserting the new version, this will allow an UPDATE on a row without "
"changing the key.)"
msgstr ""
"Если конфликтующая строка была удалена текущей транзакцией, это не проблема. "
"(В частности из-за того, что UPDATE всегда удаляет старую версию строки, "
"прежде чем вставлять новую, операцию UPDATE можно выполнять со строкой, не "
"меняя её ключ.)"

#: indexam.xml:928(para)
msgid ""
"If a conflicting row has been inserted by an as-yet-uncommitted transaction, "
"the would-be inserter must wait to see if that transaction commits. If it "
"rolls back then there is no conflict. If it commits without deleting the "
"conflicting row again, there is a uniqueness violation. (In practice we just "
"wait for the other transaction to end and then redo the visibility check in "
"toto.)"
msgstr ""
"Если конфликтующая строка была добавлена ещё не зафиксированной транзакцией, "
"запрос, претендующий на добавление новой строки, должен подождать, пока эта "
"транзакция не будет зафиксирована. Если она откатывается, конфликт исчезает. "
"Если она фиксируется и при этом оставляет конфликтующую строку, возникает "
"нарушение уникальности. (На практике мы просто ждём завершения другой "
"транзакции и затем пересматриваем проверку видимости.)"

#: indexam.xml:938(para)
msgid ""
"Similarly, if a conflicting valid row has been deleted by an as-yet-"
"uncommitted transaction, the would-be inserter must wait for that "
"transaction to commit or abort, and then repeat the test."
msgstr ""
"Подобным образом, если конфликтующая строка была удалена ещё не "
"зафиксированной транзакцией, запрос, претендующий на добавление новой "
"строки, должен дождаться фиксации или отката этой транзакции, а затем "
"повторить проверку."

#: indexam.xml:910(para)
msgid ""
"Because of MVCC, it is always necessary to allow duplicate entries to exist "
"physically in an index: the entries might refer to successive versions of a "
"single logical row. The behavior we actually want to enforce is that no MVCC "
"snapshot could include two rows with equal index keys. This breaks down into "
"the following cases that must be checked when inserting a new row into a "
"unique index: <placeholder-1/>"
msgstr ""
"Вследствие особенностей MVCC, всегда необходимо допускать физическое "
"сосуществование в индексе дублирующихся записей: такие записи могут "
"относиться к последовательным версиям одной логической строки. На самом деле "
"мы хотим добиться только того, чтобы никакой снимок MVCC не мог содержать "
"две строки с одинаковыми ключами индекса. Из этого вытекают следующие "
"ситуации, которые необходимо отследить, добавляя новую строку в уникальный "
"индекс: <placeholder-1/>"

#: indexam.xml:947(para)
msgid ""
"Furthermore, immediately before reporting a uniqueness violation according "
"to the above rules, the access method must recheck the liveness of the row "
"being inserted. If it is committed dead then no violation should be "
"reported. (This case cannot occur during the ordinary scenario of inserting "
"a row that's just been created by the current transaction. It can happen "
"during <command>CREATE UNIQUE INDEX CONCURRENTLY</command>, however.)"
msgstr ""
"Более того, непосредственно перед тем как сообщать о нарушении уникальности "
"согласно вышеприведённым правилам, метод доступа должен перепроверить, "
"продолжает ли существовать добавляемая строка. Если она признана &laquo;"
"мёртвой&raquo;, о предвиденном нарушении он сообщать не должен. (Такого не "
"должно быть при обычном сценарии добавления строки текущей транзакцией, "
"однако это может произойти в процессе <command>CREATE UNIQUE INDEX "
"CONCURRENTLY</command>.)"

#: indexam.xml:957(para)
msgid ""
"We require the index access method to apply these tests itself, which means "
"that it must reach into the heap to check the commit status of any row that "
"is shown to have a duplicate key according to the index contents. This is "
"without a doubt ugly and non-modular, but it saves redundant work: if we did "
"a separate probe then the index lookup for a conflicting row would be "
"essentially repeated while finding the place to insert the new row's index "
"entry. What's more, there is no obvious way to avoid race conditions unless "
"the conflict check is an integral part of insertion of the new index entry."
msgstr ""
"Мы требуем, чтобы метод доступа выполнял эти проверки сам, и это означает, "
"что он должен обратиться к основным данным и проверить состояние фиксации "
"всех строк, которые согласно содержимого индекса содержат дублирующиеся "
"ключи. Это без сомнения некрасивый и немодульный подход, но он избавляет от "
"излишней работы: если бы мы делали отдельную пробу, то поиск конфликтующей "
"строки по индексу пришлось бы по сути повторять, пытаясь найти место, куда "
"вставить запись для новой строки. Более того, не представляется возможным "
"избежать условий гонки, если проверка конфликта не будет неотъемлемой частью "
"процедуры добавления новой записи индекса."

#: indexam.xml:986(para)
msgid ""
"<literal>UNIQUE_CHECK_NO</literal> indicates that no uniqueness checking "
"should be done (this is not a unique index)."
msgstr ""
"<literal>UNIQUE_CHECK_NO</literal> указывает, что проверка уникальности не "
"должна выполняться (это не уникальный индекс)."

#: indexam.xml:992(para)
msgid ""
"<literal>UNIQUE_CHECK_YES</literal> indicates that this is a non-deferrable "
"unique index, and the uniqueness check must be done immediately, as "
"described above."
msgstr ""
"<literal>UNIQUE_CHECK_YES</literal> указывает, что это неоткладываемый "
"уникальный индекс и проверку уникальности нужно выполнить немедленно, как "
"описано выше."

#: indexam.xml:999(para)
msgid ""
"<literal>UNIQUE_CHECK_PARTIAL</literal> indicates that the unique constraint "
"is deferrable. <productname>PostgreSQL</productname> will use this mode to "
"insert each row's index entry. The access method must allow duplicate "
"entries into the index, and report any potential duplicates by returning "
"FALSE from <function>aminsert</function>. For each row for which FALSE is "
"returned, a deferred recheck will be scheduled."
msgstr ""
"<literal>UNIQUE_CHECK_PARTIAL</literal> указывает, что это откладываемое "
"ограничение уникальности. <productname>PostgreSQL</productname> выбирает "
"этот режим для добавления записи индекса для каждой строки. Метод доступа "
"должен допускать добавление в индекс дублирующихся записей и сообщать о "
"возможных конфликтах, возвращая FALSE из <function>aminsert</function>. Для "
"каждой такой строки (для которой возвращается FALSE) будет запланирована "
"отложенная перепроверка."

#: indexam.xml:1009(para)
msgid ""
"The access method must identify any rows which might violate the unique "
"constraint, but it is not an error for it to report false positives. This "
"allows the check to be done without waiting for other transactions to "
"finish; conflicts reported here are not treated as errors and will be "
"rechecked later, by which time they may no longer be conflicts."
msgstr ""
"Метод доступа должен отметить все строки, которые могут нарушать ограничение "
"уникальности, но не будет ошибкой, если он допустит ложное срабатывание. Это "
"позволяет произвести проверку, не дожидаясь завершения других транзакций; "
"конфликты, выявленные на этой стадии, не считаются ошибками и будут "
"перепроверены позже, когда они могут быть уже исчерпаны."

#: indexam.xml:1019(para)
msgid ""
"<literal>UNIQUE_CHECK_EXISTING</literal> indicates that this is a deferred "
"recheck of a row that was reported as a potential uniqueness violation. "
"Although this is implemented by calling <function>aminsert</function>, the "
"access method must <emphasis>not</emphasis> insert a new index entry in this "
"case. The index entry is already present. Rather, the access method must "
"check to see if there is another live index entry. If so, and if the target "
"row is also still live, report error."
msgstr ""
"<literal>UNIQUE_CHECK_EXISTING</literal> указывает, что это отложенная "
"перепроверка строки, которая была отмечена как возможно нарушающая "
"ограничение. Хотя для этой проверки вызывается <function>aminsert</"
"function>, метод доступа <emphasis>не</emphasis> должен добавлять новую "
"запись индекса в данном случае, так как эта запись уже существует. Вместо "
"этого, метод доступа должен проверить, нет ли в индексе другой такой же "
"записи. Если она находится и соответствующая ей строка продолжает "
"существовать, должна выдаваться ошибка."

#: indexam.xml:1029(para)
msgid ""
"It is recommended that in a <literal>UNIQUE_CHECK_EXISTING</literal> call, "
"the access method further verify that the target row actually does have an "
"existing entry in the index, and report error if not. This is a good idea "
"because the index tuple values passed to <function>aminsert</function> will "
"have been recomputed. If the index definition involves functions that are "
"not really immutable, we might be checking the wrong area of the index. "
"Checking that the target row is found in the recheck verifies that we are "
"scanning for the same tuple values as were used in the original insertion."
msgstr ""
"Для варианта <literal>UNIQUE_CHECK_EXISTING</literal> в методе доступа "
"рекомендуется дополнительно проверить, что для целевой строки действительно "
"имеется запись в индексе и сообщить об ошибке, если это не так. Это хорошая "
"идея, так как значения кортежа индекса, передаваемые в <function>aminsert</"
"function>, будут рассчитаны заново. Если в определении индекса задействованы "
"функции, которые на самом деле не постоянные, мы можем проверять "
"неправильную область индекса. Дополнительно убедившись в существовании "
"целевой строки при перепроверке, мы можем быть уверены, что сканируются те "
"же значения кортежа, что передавались при изначальном добавлении строки."

#: indexam.xml:969(para)
msgid ""
"If the unique constraint is deferrable, there is additional complexity: we "
"need to be able to insert an index entry for a new row, but defer any "
"uniqueness-violation error until end of statement or even later. To avoid "
"unnecessary repeat searches of the index, the index access method should do "
"a preliminary uniqueness check during the initial insertion. If this shows "
"that there is definitely no conflicting live tuple, we are done. Otherwise, "
"we schedule a recheck to occur when it is time to enforce the constraint. "
"If, at the time of the recheck, both the inserted tuple and some other tuple "
"with the same key are live, then the error must be reported. (Note that for "
"this purpose, <quote>live</quote> actually means <quote>any tuple in the "
"index entry's HOT chain is live</quote>.) To implement this, the "
"<function>aminsert</function> function is passed a <literal>checkUnique</"
"literal> parameter having one of the following values: <placeholder-1/>"
msgstr ""
"Если ограничение уникальности откладываемое, возникает дополнительная "
"сложность: нам нужна возможность добавлять запись индекса для новой строки, "
"но отложить выводы о нарушении уникальности до конца оператора или даже "
"позже. Чтобы избежать ненужного повторного поиска по индексу, метод доступа "
"должен произвести предварительную проверку уникальности во время "
"изначального добавления строк. Если при этом окажется, что никакие кортежи "
"не конфликтуют, на этом проверка заканчивается. В противном случае мы "
"планируем перепроверку на время, когда это ограничение начинает действовать. "
"Если во время перепроверки продолжают существовать и вставленный кортеж, и "
"какой-либо другой с тем же ключом, должна выдаваться ошибка. (Заметьте, что "
"в данном случае под <quote>существованием</quote> понимается "
"<quote>существование любого кортежа в цепочке HOT записей индекса</quote>.) "
"Для реализации этой схемы в <function>aminsert</function> передаётся "
"параметр <literal>checkUnique</literal>, принимающий одно из следующих "
"значений: <placeholder-1/>"

#: indexam.xml:1047(title)
msgid "Index Cost Estimation Functions"
msgstr "Функции оценки стоимости индекса"

#: indexam.xml:1049(para)
msgid ""
"The <function>amcostestimate</function> function is given information "
"describing a possible index scan, including lists of WHERE and ORDER BY "
"clauses that have been determined to be usable with the index. It must "
"return estimates of the cost of accessing the index and the selectivity of "
"the WHERE clauses (that is, the fraction of parent-table rows that will be "
"retrieved during the index scan). For simple cases, nearly all the work of "
"the cost estimator can be done by calling standard routines in the "
"optimizer; the point of having an <function>amcostestimate</function> "
"function is to allow index access methods to provide index-type-specific "
"knowledge, in case it is possible to improve on the standard estimates."
msgstr ""
"Функции <function>amcostestimate</function> даётся информация, описывающая "
"возможное сканирование индекса, включая списки предложений WHERE и ORDER BY, "
"которые были выбраны как применимые с данным индексом. Она должна вернуть "
"оценки стоимости обращения к индексу и избирательность предложений WHERE (то "
"есть, процент строк основной таблицы, который будет получен в ходе "
"сканирования индекса). Для простых случаев почти всю работу оценщика "
"стоимости можно произвести, вызывая стандартные процедуры оптимизатора; "
"смысл существования функции <function>amcostestimate</function> в том, чтобы "
"методы доступа индексов могли поделиться знаниями, специфичными для типа "
"индекса, когда это может помочь улучшить стандартные оценки."

#: indexam.xml:1080(parameter)
msgid "root"
msgstr "root"

#: indexam.xml:1082(para)
msgid "The planner's information about the query being processed."
msgstr "Информация планировщика о выполняемом запросе."

#: indexam.xml:1089(parameter)
msgid "path"
msgstr "path"

#: indexam.xml:1091(para)
msgid ""
"The index access path being considered. All fields except cost and "
"selectivity values are valid."
msgstr ""
"Рассматриваемый путь доступа к индексу. В нём действительны все поля, кроме "
"значений стоимости и избирательности."

#: indexam.xml:1099(parameter)
msgid "loop_count"
msgstr "loop_count"

#: indexam.xml:1101(para)
msgid ""
"The number of repetitions of the index scan that should be factored into the "
"cost estimates. This will typically be greater than one when considering a "
"parameterized scan for use in the inside of a nestloop join. Note that the "
"cost estimates should still be for just one scan; a larger "
"<parameter>loop_count</parameter> means that it may be appropriate to allow "
"for some caching effects across multiple scans."
msgstr ""
"Число повторений сканирования индекса, которое должно приниматься во "
"внимание при оценке стоимости. Обычно оно будет больше одного, когда при "
"соединении со вложенным циклом планируется параметризованное сканирование. "
"Заметьте, что оценки стоимости, тем не менее, должны рассчитываться для "
"всего одного сканирования; большие значения <parameter>loop_count</"
"parameter> лишь дают основания предположить, что при многократном "
"сканировании положительное влияние может оказать кеширование."

#: indexam.xml:1062(para)
msgid ""
"Each <function>amcostestimate</function> function must have the signature: "
"<placeholder-1/> The first three parameters are inputs: <placeholder-2/>"
msgstr ""
"Каждая функция <function>amcostestimate</function> должна иметь такую "
"сигнатуру: <placeholder-1/> Первые три параметра передают входные значения: "
"<placeholder-2/>"

#: indexam.xml:1119(parameter)
msgid "*indexStartupCost"
msgstr "*indexStartupCost"

#: indexam.xml:1121(para)
msgid "Set to cost of index start-up processing"
msgstr "Стоимость выполнения запуска индекса"

#: indexam.xml:1128(parameter)
msgid "*indexTotalCost"
msgstr "*indexTotalCost"

#: indexam.xml:1130(para)
msgid "Set to total cost of index processing"
msgstr "Общая стоимость использования индекса"

#: indexam.xml:1137(parameter)
msgid "*indexSelectivity"
msgstr "*indexSelectivity"

#: indexam.xml:1139(para)
msgid "Set to index selectivity"
msgstr "Избирательность индекса"

#: indexam.xml:1146(parameter)
msgid "*indexCorrelation"
msgstr "*indexCorrelation"

#: indexam.xml:1148(para)
msgid ""
"Set to correlation coefficient between index scan order and underlying "
"table's order"
msgstr ""
"Коэффициент корреляции между порядком сканирования индекса и порядком "
"записей в нижележащей таблице"

#: indexam.xml:1114(para)
msgid ""
"The last four parameters are pass-by-reference outputs: <placeholder-1/>"
msgstr ""
"Последние четыре параметра — указатели на переменные для выходных значений: "
"<placeholder-1/>"

#: indexam.xml:1157(para)
msgid ""
"Note that cost estimate functions must be written in C, not in SQL or any "
"available procedural language, because they must access internal data "
"structures of the planner/optimizer."
msgstr ""
"Заметьте, что функции оценки стоимости должны разрабатываться на C, а не на "
"SQL или другом доступном процедурном языке, так как они должны обращаться к "
"внутренним структурам данным планировщика/оптимизатора."

#: indexam.xml:1163(para)
msgid ""
"The index access costs should be computed using the parameters used by "
"<filename>src/backend/optimizer/path/costsize.c</filename>: a sequential "
"disk block fetch has cost <varname>seq_page_cost</varname>, a nonsequential "
"fetch has cost <varname>random_page_cost</varname>, and the cost of "
"processing one index row should usually be taken as "
"<varname>cpu_index_tuple_cost</varname>. In addition, an appropriate "
"multiple of <varname>cpu_operator_cost</varname> should be charged for any "
"comparison operators invoked during index processing (especially evaluation "
"of the indexquals themselves)."
msgstr ""
"Стоимости обращения к индексу следует вычислять с использованием параметров, "
"объявленных в <filename>src/backend/optimizer/path/costsize.c</filename>: "
"последовательная выборка дискового блока имеет стоимость "
"<varname>seq_page_cost</varname>, непоследовательная выборка — "
"<varname>random_page_cost</varname>, а стоимостью обработки одной строки "
"индекса обычно принимается <varname>cpu_index_tuple_cost</varname>. Кроме "
"того, за каждый оператор сравнения, вызываемый при обработке индекса, должна "
"взиматься цена <varname>cpu_operator_cost</varname> (особенно за вычисление "
"собственно условий индекса)."

#: indexam.xml:1174(para)
msgid ""
"The access costs should include all disk and CPU costs associated with "
"scanning the index itself, but <emphasis>not</emphasis> the costs of "
"retrieving or processing the parent-table rows that are identified by the "
"index."
msgstr ""
"Стоимость доступа должна включать стоимости всех дисковых и процессорных "
"ресурсов, требующихся для сканирования самого индекса, <emphasis>но</"
"emphasis> не стоимости извлечения или обработки строк основной таблицы, с "
"которой связан индекс."

#: indexam.xml:1180(para)
msgid ""
"The <quote>start-up cost</quote> is the part of the total scan cost that "
"must be expended before we can begin to fetch the first row. For most "
"indexes this can be taken as zero, but an index type with a high start-up "
"cost might want to set it nonzero."
msgstr ""
"<quote>Стоимость запуска</quote> составляет часть общей стоимости "
"сканирования, которая должна быть потрачена, прежде чем можно будет начать "
"чтение первой строки. Для большинства индексов она может считаться нулевой, "
"но для типов индексов с высокими затратами на запуск она может быть больше "
"нуля."

#: indexam.xml:1187(para)
msgid ""
"The <parameter>indexSelectivity</parameter> should be set to the estimated "
"fraction of the parent table rows that will be retrieved during the index "
"scan. In the case of a lossy query, this will typically be higher than the "
"fraction of rows that actually pass the given qual conditions."
msgstr ""
"Значение в <parameter>indexSelectivity</parameter> должно показывать, какой "
"процент строк основной таблицы ожидается получить при сканировании таблицы. "
"В случае неточного запроса это обычно будет больше процента строк, "
"действительно удовлетворяющих заданным ограничивающим условиям."

#: indexam.xml:1194(para)
msgid ""
"The <parameter>indexCorrelation</parameter> should be set to the correlation "
"(ranging between -1.0 and 1.0) between the index order and the table order. "
"This is used to adjust the estimate for the cost of fetching rows from the "
"parent table."
msgstr ""
"В <parameter>indexCorrelation</parameter> записывается корреляция (в "
"диапазоне от -1.0 до 1.0) между порядком записей в индексе и в таблице. Это "
"значение будет корректировать оценку стоимости выборки строк из основной "
"таблицы."

#: indexam.xml:1201(para)
msgid ""
"When <parameter>loop_count</parameter> is greater than one, the returned "
"numbers should be averages expected for any one scan of the index."
msgstr ""
"Когда <parameter>loop_count</parameter> больше нуля, возвращаться должны "
"средние значения, ожидаемые для одного сканирования индекса."

#: indexam.xml:1207(title)
msgid "Cost Estimation"
msgstr "Оценка стоимости"

#: indexam.xml:1208(para)
msgid "A typical cost estimator will proceed as follows:"
msgstr "Типичная процедура оценки выглядит следующим образом:"

#: indexam.xml:1218(programlisting)
#, no-wrap
msgid ""
"*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,\n"
"                                           path-&gt;indexinfo-&gt;rel-&gt;relid,\n"
"                                           JOIN_INNER, NULL);"
msgstr ""
"*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,\n"
"                                           path-&gt;indexinfo-&gt;rel-&gt;relid,\n"
"                                           JOIN_INNER, NULL);"

#: indexam.xml:1213(para)
msgid ""
"Estimate and return the fraction of parent-table rows that will be visited "
"based on the given qual conditions. In the absence of any index-type-"
"specific knowledge, use the standard optimizer function "
"<function>clauselist_selectivity()</function>: <placeholder-1/>"
msgstr ""
"Рассчитать и вернуть процент строк родительской таблицы, которые будут "
"посещены при заданных ограничивающих условиях. В отсутствие каких-либо "
"знаний, специфичных для типа индекса, использовать стандартную функцию "
"оптимизатора <function>clauselist_selectivity()</function>: <placeholder-1/>"

#: indexam.xml:1227(para)
msgid ""
"Estimate the number of index rows that will be visited during the scan. For "
"many index types this is the same as <parameter>indexSelectivity</parameter> "
"times the number of rows in the index, but it might be more. (Note that the "
"index's size in pages and rows is available from the <literal>path-&gt;"
"indexinfo</literal> struct.)"
msgstr ""
"Оценить число строк индекса, которые будут посещены при сканировании. Для "
"многих типов индексов это будет произведение <parameter>indexSelectivity</"
"parameter> и числа строк в индексе, но оно может быть и больше. (Заметьте, "
"что размер индекса в страницах и строках можно узнать из структуры "
"<literal>path-&gt;indexinfo</literal>.)"

#: indexam.xml:1237(para)
msgid ""
"Estimate the number of index pages that will be retrieved during the scan. "
"This might be just <parameter>indexSelectivity</parameter> times the index's "
"size in pages."
msgstr ""
"Рассчитать число страниц индекса, которые будут получены при сканировании. "
"Это может быть просто произведение <parameter>indexSelectivity</parameter> и "
"размера индекса в страницах."

#: indexam.xml:1247(programlisting)
#, no-wrap
msgid ""
"/*\n"
" * Our generic assumption is that the index pages will be read\n"
" * sequentially, so they cost seq_page_cost each, not random_page_cost.\n"
" * Also, we charge for evaluation of the indexquals at each index row.\n"
" * All the costs are assumed to be paid incrementally during the scan.\n"
" */\n"
"cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);\n"
"*indexStartupCost = index_qual_cost.startup;\n"
"*indexTotalCost = seq_page_cost * numIndexPages +\n"
"    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;"
msgstr ""
"/*\n"
" * Вообще предполагается, что страницы индекса будут считываться последовательно,\n"
" * так что стоимость их чтения cost seq_page_cost, а не random_page_cost.\n"
" * Также мы добавляем стоимость за вычисление условия индекса для каждой строки.\n"
" * Все стоимости считаются пропорционально возрастающими при сканировании.\n"
" */\n"
"cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);\n"
"*indexStartupCost = index_qual_cost.startup;\n"
"*indexTotalCost = seq_page_cost * numIndexPages +\n"
"    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;"

#: indexam.xml:1244(para)
msgid ""
"Compute the index access cost. A generic estimator might do this: "
"<placeholder-1/> However, the above does not account for amortization of "
"index reads across repeated index scans."
msgstr ""
"Вычислить стоимость обращения к индексу. Универсальный оценщик может сделать "
"следующее: <placeholder-1/> Однако при таком расчёте не учитывается "
"амортизация чтения индекса при повторном сканировании."

#: indexam.xml:1266(para)
msgid ""
"Estimate the index correlation. For a simple ordered index on a single "
"field, this can be retrieved from pg_statistic. If the correlation is not "
"known, the conservative estimate is zero (no correlation)."
msgstr ""
"Оценить корреляцию индекса. Для простого упорядоченного индекса по одному "
"полю её можно получить из pg_statistic. Если корреляция неизвестна, вернуть "
"консервативную оценку — ноль (корреляция отсутствует)."

#: indexam.xml:1274(para)
msgid ""
"Examples of cost estimator functions can be found in <filename>src/backend/"
"utils/adt/selfuncs.c</filename>."
msgstr ""
"Примеры функций оценки стоимости можно найти в <filename>src/backend/utils/"
"adt/selfuncs.c</filename>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: indexam.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "Index access methods can be defined and dropped using <xref linkend=\"sql-"
#~ "create-access-method\"/> and <xref linkend=\"sql-drop-access-method\"/> "
#~ "SQL commands respectively."
#~ msgstr ""
#~ "Методы доступа могут быть созданы и удалены SQL-командами <xref linkend="
#~ "\"sql-create-access-method\"/> и <xref linkend=\"sql-drop-access-method\"/"
#~ ">, соответственно."
