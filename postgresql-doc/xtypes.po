# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: xtypes.xml:5(title)
msgid "User-defined Types"
msgstr "Пользовательские типы"

#: xtypes.xml:7(indexterm)
msgid "<primary>data type</primary> <secondary>user-defined</secondary>"
msgstr ""
"<primary>тип данных</primary> <secondary>определённый пользователем</"
"secondary>"

#: xtypes.xml:12(para)
msgid ""
"As described in <xref linkend=\"extend-type-system\"/>, "
"<productname>PostgreSQL</productname> can be extended to support new data "
"types. This section describes how to define new base types, which are data "
"types defined below the level of the <acronym>SQL</acronym> language. "
"Creating a new base type requires implementing functions to operate on the "
"type in a low-level language, usually C."
msgstr ""
"Как описывалось в <xref remap=\"6\" linkend=\"extend-type-system\"/>, "
"<productname>PostgreSQL</productname> может расширяться и поддерживать новые "
"типы данных. В этом разделе описывается, как определить новые базовые типы, "
"то есть типы данных, описанные ниже уровня языка <acronym>SQL</acronym>. Для "
"создания нового базового типа необходимо реализовать функции, работающие с "
"этим типом, на языке низкого уровня, обычно C."

#: xtypes.xml:21(para)
msgid ""
"The examples in this section can be found in <filename>complex.sql</"
"filename> and <filename>complex.c</filename> in the <filename>src/tutorial</"
"filename> directory of the source distribution. See the <filename>README</"
"filename> file in that directory for instructions about running the examples."
msgstr ""
"Примеры, рассматриваемые в этой главе, можно найти в <filename>complex.sql</"
"filename> и в <filename>complex.c</filename> в каталоге <filename>src/"
"tutorial</filename> пакета с исходным кодом. Инструкции по запуску этих "
"примеров можно найти в файле <filename>README</filename> в том же каталоге."

#: xtypes.xml:30(indexterm)
msgid "<primary>input function</primary>"
msgstr "<primary>функция ввода</primary>"

#: xtypes.xml:33(indexterm)
msgid "<primary>output function</primary>"
msgstr "<primary>функция вывода</primary>"

#: xtypes.xml:29(para)
msgid ""
"<placeholder-1/> <placeholder-2/> A user-defined type must always have input "
"and output functions. These functions determine how the type appears in "
"strings (for input by the user and output to the user) and how the type is "
"organized in memory. The input function takes a null-terminated character "
"string as its argument and returns the internal (in memory) representation "
"of the type. The output function takes the internal representation of the "
"type as argument and returns a null-terminated character string. If we want "
"to do anything more with the type than merely store it, we must provide "
"additional functions to implement whatever operations we'd like to have for "
"the type."
msgstr ""
"<placeholder-1/> <placeholder-2/> Пользовательский тип должен всегда иметь "
"функции ввода и вывода. Эти функции определяют, как тип будет выглядеть в "
"строковом виде (при вводе и выводе для пользователя) и как этот тип "
"размещается в памяти. Функция ввода принимает в качестве аргумента строку "
"символов, заканчивающуюся нулём, и возвращает внутреннее представление типа "
"(в памяти). Функция вывода принимает в качестве аргумента внутреннее "
"представление типа и возвращает строку символов, заканчивающуюся нулём. Если "
"мы хотим не просто сохранить тип, но делать с ним нечто большее, мы должны "
"предоставить дополнительные функции, реализующие все операции, которые мы "
"хотели бы иметь для этого типа."

#: xtypes.xml:53(programlisting)
#, no-wrap
msgid ""
"typedef struct Complex {\n"
"    double      x;\n"
"    double      y;\n"
"} Complex;"
msgstr ""
"typedef struct Complex {\n"
"    double      x;\n"
"    double      y;\n"
"} Complex;"

#: xtypes.xml:48(para)
msgid ""
"Suppose we want to define a type <type>complex</type> that represents "
"complex numbers. A natural way to represent a complex number in memory would "
"be the following C structure: <placeholder-1/> We will need to make this a "
"pass-by-reference type, since it's too large to fit into a single "
"<type>Datum</type> value."
msgstr ""
"Предположим, что нам нужен тип <type>complex</type>, представляющий "
"комплексные числа. Естественным образом комплексное число можно представить "
"в памяти в виде следующей структуры C: <placeholder-1/> Нам нужно будет "
"передавать этот тип по ссылке, так как он слишком велик, чтобы уместиться в "
"одном значении <type>Datum</type>."

#: xtypes.xml:64(para)
msgid ""
"As the external string representation of the type, we choose a string of the "
"form <literal>(x,y)</literal>."
msgstr ""
"В качестве внешнего строкового представления типа мы выберем строку вида "
"<literal>(x,y)</literal>."

#: xtypes.xml:69(para)
msgid ""
"The input and output functions are usually not hard to write, especially the "
"output function. But when defining the external string representation of the "
"type, remember that you must eventually write a complete and robust parser "
"for that representation as your input function. For instance: <placeholder-1/"
"> The output function can simply be: <placeholder-2/>"
msgstr ""
"Функции ввода и вывода обычно несложно написать, особенно функцию вывода. Но "
"определяя внешнее строковое представление типа, помните, что в конце концов "
"вам придётся реализовать законченный и надёжный метод разбора этого "
"представления в функции ввода. Например, так: <placeholder-1/> Функция "
"вывода может быть простой: <placeholder-2/>"

#: xtypes.xml:119(para)
msgid ""
"You should be careful to make the input and output functions inverses of "
"each other. If you do not, you will have severe problems when you need to "
"dump your data into a file and then read it back in. This is a particularly "
"common problem when floating-point numbers are involved."
msgstr ""
"Вам нужно позаботиться о том, чтобы функции ввода и вывода были обратными "
"друг к другу. В противном случае вы столкнётесь с проблемами, когда вам "
"потребуется выгрузить данные в файл, а затем прочитать их. Это особенно "
"распространённая проблема, когда дело касается чисел с плавающей точкой."

#: xtypes.xml:127(para)
msgid ""
"Optionally, a user-defined type can provide binary input and output "
"routines. Binary I/O is normally faster but less portable than textual I/O. "
"As with textual I/O, it is up to you to define exactly what the external "
"binary representation is. Most of the built-in data types try to provide a "
"machine-independent binary representation. For <type>complex</type>, we will "
"piggy-back on the binary I/O converters for type <type>float8</type>: "
"<placeholder-1/>"
msgstr ""
"Дополнительно пользовательский тип может предоставлять функции для ввода и "
"вывода в двоичном виде. Двоичный ввод/вывод обычно работает быстрее, но хуже "
"портируется, чем текстовый. Как и с текстовым представлением, выбор, каким "
"будет двоичное представление, остаётся за вами. Многие встроенные типы "
"данных стараются обеспечить двоичное представление, независимое от машинной "
"архитектуры. Для типа <type>complex</type> мы воспользуемся функциями "
"двоичного ввода/вывода типа <type>float8</type>: <placeholder-1/>"

#: xtypes.xml:173(programlisting)
#, no-wrap
msgid "CREATE TYPE complex;"
msgstr "CREATE TYPE complex;"

#: xtypes.xml:180(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION complex_in(cstring)\n"
"    RETURNS complex\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE FUNCTION complex_out(complex)\n"
"    RETURNS cstring\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE FUNCTION complex_recv(internal)\n"
"   RETURNS complex\n"
"   AS '<replaceable>filename</replaceable>'\n"
"   LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE FUNCTION complex_send(complex)\n"
"   RETURNS bytea\n"
"   AS '<replaceable>filename</replaceable>'\n"
"   LANGUAGE C IMMUTABLE STRICT;"
msgstr ""
"CREATE FUNCTION complex_in(cstring)\n"
"    RETURNS complex\n"
"    AS '<replaceable>имя_файла</replaceable>'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE FUNCTION complex_out(complex)\n"
"    RETURNS cstring\n"
"    AS '<replaceable>имя_файла</replaceable>'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE FUNCTION complex_recv(internal)\n"
"   RETURNS complex\n"
"   AS '<replaceable>имя_файла</replaceable>'\n"
"   LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE FUNCTION complex_send(complex)\n"
"   RETURNS bytea\n"
"   AS '<replaceable>имя_файла</replaceable>'\n"
"   LANGUAGE C IMMUTABLE STRICT;"

#: xtypes.xml:168(para)
msgid ""
"Once we have written the I/O functions and compiled them into a shared "
"library, we can define the <type>complex</type> type in SQL. First we "
"declare it as a shell type: <placeholder-1/> This serves as a placeholder "
"that allows us to reference the type while defining its I/O functions. Now "
"we can define the I/O functions: <placeholder-2/>"
msgstr ""
"Написав функции ввода/вывода и скомпилировав их в разделяемую библиотеку, мы "
"можем определить тип <type>complex</type> в SQL. Сначала мы объявим его как "
"тип-пустышку: <placeholder-1/> Это позволит нам ссылаться на этот тип, "
"определяя для него функции ввода/вывода. Теперь мы определим функции ввода/"
"вывода: <placeholder-2/>"

#: xtypes.xml:205(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE complex (\n"
"   internallength = 16,\n"
"   input = complex_in,\n"
"   output = complex_out,\n"
"   receive = complex_recv,\n"
"   send = complex_send,\n"
"   alignment = double\n"
");"
msgstr ""
"CREATE TYPE complex (\n"
"   internallength = 16,\n"
"   input = complex_in,\n"
"   output = complex_out,\n"
"   receive = complex_recv,\n"
"   send = complex_send,\n"
"   alignment = double\n"
");"

#: xtypes.xml:203(para)
msgid ""
"Finally, we can provide the full definition of the data type: <placeholder-1/"
">"
msgstr ""
"Наконец, мы можем предоставить полное определение типа данных: "
"<placeholder-1/>"

#: xtypes.xml:218(indexterm)
msgid "<primary>array</primary> <secondary>of user-defined type</secondary>"
msgstr ""
"<primary>массив элементов</primary> <secondary>пользовательского типа</"
"secondary>"

#: xtypes.xml:217(para)
msgid ""
"<placeholder-1/> When you define a new base type, <productname>PostgreSQL</"
"productname> automatically provides support for arrays of that type. The "
"array type typically has the same name as the base type with the underscore "
"character (<literal>_</literal>) prepended."
msgstr ""
"<placeholder-1/> Когда определяется новый базовый тип, "
"<productname>PostgreSQL</productname> автоматически обеспечивает поддержку "
"массивов с элементами такого типа. Тип массива обычно получает имя по имени "
"базового типа с добавленным спереди символом подчёркивания (<literal>_</"
"literal>)."

#: xtypes.xml:229(para)
msgid ""
"Once the data type exists, we can declare additional functions to provide "
"useful operations on the data type. Operators can then be defined atop the "
"functions, and if needed, operator classes can be created to support "
"indexing of the data type. These additional layers are discussed in "
"following sections."
msgstr ""
"Когда тип данных определён, мы можем объявить дополнительные функции для "
"выполнения полезных операций с этим типом. Затем поверх этих функций могут "
"быть определены операторы, а если потребуется, и классы операторов, для "
"поддержки индексации этого типа. Эти дополнительные уровни обсуждаются в "
"следующих разделах."

#: xtypes.xml:237(para)
msgid ""
"If the internal representation of the data type is variable-length, the "
"internal representation must follow the standard layout for variable-length "
"data: the first four bytes must be a <type>char[4]</type> field which is "
"never accessed directly (customarily named <structfield>vl_len_</"
"structfield>). You must use the <function>SET_VARSIZE()</function> macro to "
"store the total size of the datum (including the length field itself) in "
"this field and <function>VARSIZE()</function> to retrieve it. (These macros "
"exist because the length field may be encoded depending on platform.)"
msgstr ""
"Если внутреннее представление типа данных имеет переменную длину, оно должно "
"соответствовать стандартной схеме данных переменной длины: первые четыре "
"байта должно занимать поле <type>char[4]</type>, к которому никогда не "
"следует обращаться напрямую (по обыкновению названное <structfield>vl_len_</"
"structfield>). Чтобы сохранить в этом поле размер элемента (включая длину "
"самого поля), вы должны использовать макрос <function>SET_VARSIZE()</"
"function>, а чтобы получить его — макрос <function>VARSIZE()</function>. "
"(Эти макросы нужны, потому что поле длины может кодироваться по-разному на "
"разных платформах.)"

#: xtypes.xml:248(para)
msgid ""
"For further details see the description of the <xref linkend=\"sql-createtype"
"\"/> command."
msgstr ""
"За дополнительными подробностями обратитесь к команде <xref linkend=\"sql-"
"createtype\"/>."

#: xtypes.xml:254(title)
msgid "TOAST Considerations"
msgstr "Особенности TOAST"

#: xtypes.xml:255(indexterm)
msgid "<primary>TOAST</primary> <secondary>and user-defined types</secondary>"
msgstr ""
"<primary>TOAST</primary> <secondary>и пользовательские типы</secondary>"

#: xtypes.xml:260(para)
msgid ""
"If the values of your data type vary in size (in internal form), it's "
"usually desirable to make the data type <acronym>TOAST</acronym>-able (see "
"<xref linkend=\"storage-toast\"/>). You should do this even if the values "
"are always too small to be compressed or stored externally, because "
"<acronym>TOAST</acronym> can save space on small data too, by reducing "
"header overhead."
msgstr ""
"Если значения вашего типа данных могут быть разного размера (во внутренней "
"форме), обычно для такого типа желательно реализовать поддержку "
"<acronym>TOAST</acronym> (см. <xref remap=\"4\" linkend=\"storage-toast\"/"
">). Это следует делать, даже если значения слишком малы для сжатия или "
"внешнего хранения, так как <acronym>TOAST</acronym> позволяет сэкономить "
"пространство и с данными маленького размера, сокращая издержки в заголовке."

#: xtypes.xml:269(para)
msgid ""
"To support <acronym>TOAST</acronym> storage, the C functions operating on "
"the data type must always be careful to unpack any toasted values they are "
"handed by using <function>PG_DETOAST_DATUM</function>. (This detail is "
"customarily hidden by defining type-specific <function>GETARG_DATATYPE_P</"
"function> macros.) Then, when running the <command>CREATE TYPE</command> "
"command, specify the internal length as <literal>variable</literal> and "
"select some appropriate storage option other than <literal>plain</literal>."
msgstr ""
"Для поддержки хранения <acronym>TOAST</acronym> функции на C, работающие с "
"таким типом данных, должны позаботиться о распаковке поступивших им данных, "
"используя макрос <function>PG_DETOAST_DATUM</function>. (Эту внутреннюю "
"особенность обычно скрывает дополнительный, определяемый для типа макрос "
"<function>GETARG_DATATYPE_P</function>.) Затем, выполняя команду "
"<command>CREATE TYPE</command>, укажите в качестве внутренней длины "
"<literal>variable</literal> и выберите подходящий вариант хранения (не "
"<literal>plain</literal>)."

#: xtypes.xml:279(para)
msgid ""
"If data alignment is unimportant (either just for a specific function or "
"because the data type specifies byte alignment anyway) then it's possible to "
"avoid some of the overhead of <function>PG_DETOAST_DATUM</function>. You can "
"use <function>PG_DETOAST_DATUM_PACKED</function> instead (customarily hidden "
"by defining a <function>GETARG_DATATYPE_PP</function> macro) and using the "
"macros <function>VARSIZE_ANY_EXHDR</function> and <function>VARDATA_ANY</"
"function> to access a potentially-packed datum. Again, the data returned by "
"these macros is not aligned even if the data type definition specifies an "
"alignment. If the alignment is important you must go through the regular "
"<function>PG_DETOAST_DATUM</function> interface."
msgstr ""
"Если выравнивание данных не имеет значения (либо только для некоторой "
"функции, либо потому что для типа данных в любом случае применяется "
"выравнивание по байтам), некоторых издержек, связанных с макросом "
"<function>PG_DETOAST_DATUM</function>, можно избежать. Вместо него можно "
"использовать <function>PG_DETOAST_DATUM_PACKED</function> (его обычно "
"скрывает определяемый для типа макрос <function>GETARG_DATATYPE_PP</"
"function>) и воспользоваться макросами <function>VARSIZE_ANY_EXHDR</"
"function> и <function>VARDATA_ANY</function> для обращения к потенциально "
"сжатым данным. Стоит ещё раз отметить, что данные, возвращаемые этими "
"макросами, не выравниваются, даже если выравнивание задано в определении "
"типа. Если выравнивание важно, вы должны задействовать обычный интерфейс "
"<function>PG_DETOAST_DATUM</function>."

#: xtypes.xml:293(para)
msgid ""
"Older code frequently declares <structfield>vl_len_</structfield> as an "
"<type>int32</type> field instead of <type>char[4]</type>. This is OK as long "
"as the struct definition has other fields that have at least <type>int32</"
"type> alignment. But it is dangerous to use such a struct definition when "
"working with a potentially unaligned datum; the compiler may take it as "
"license to assume the datum actually is aligned, leading to core dumps on "
"architectures that are strict about alignment."
msgstr ""
"В старом коде поле <structfield>vl_len_</structfield> часто объявлялось как "
"<type>int32</type>, а не <type>char[4]</type>. Это ничем не чревато до той "
"поры, пока в определении структуры имеются другие поля с выравниванием как "
"минимум <type>int32</type>. Но с потенциально невыровненными данными такое "
"определение структуры опасно; компилятор может воспринять его как право "
"полагать, что данные выровнены, что может привести к аварийным сбоям в "
"архитектурах, строгих к выравниванию."

#: xtypes.xml:304(para)
msgid ""
"Another feature that's enabled by <acronym>TOAST</acronym> support is the "
"possibility of having an <firstterm>expanded</firstterm> in-memory data "
"representation that is more convenient to work with than the format that is "
"stored on disk. The regular or <quote>flat</quote> varlena storage format is "
"ultimately just a blob of bytes; it cannot for example contain pointers, "
"since it may get copied to other locations in memory. For complex data "
"types, the flat format may be quite expensive to work with, so "
"<productname>PostgreSQL</productname> provides a way to <quote>expand</"
"quote> the flat format into a representation that is more suited to "
"computation, and then pass that format in-memory between functions of the "
"data type."
msgstr ""
"Поддержка <acronym>TOAST</acronym> даёт также возможность иметь "
"<firstterm>развёрнутое</firstterm> представление данных в памяти, работать с "
"которым будет удобнее, чем с форматом хранения на диске. Обычный или "
"<quote>плоский</quote> формат хранения varlena в конце концов представляет "
"собой просто набор байт; он не может содержать указатели, так как эти байты "
"могут быть скопированы в другие адреса. Для сложных типов данных работать с "
"плоским форматом данных может быть довольно дорого, так что "
"<productname>PostgreSQL</productname> даёт возможность <quote>развернуть</"
"quote> плоский формат в представление, более подходящее для вычислений, и "
"затем передавать эту структуру в памяти функциям, работающим с этим типом."

#: xtypes.xml:317(para)
msgid ""
"To use expanded storage, a data type must define an expanded format that "
"follows the rules given in <filename>src/include/utils/expandeddatum.h</"
"filename>, and provide functions to <quote>expand</quote> a flat varlena "
"value into expanded format and <quote>flatten</quote> the expanded format "
"back to the regular varlena representation. Then ensure that all C functions "
"for the data type can accept either representation, possibly by converting "
"one into the other immediately upon receipt. This does not require fixing "
"all existing functions for the data type at once, because the standard "
"<function>PG_DETOAST_DATUM</function> macro is defined to convert expanded "
"inputs into regular flat format. Therefore, existing functions that work "
"with the flat varlena format will continue to work, though slightly "
"inefficiently, with expanded inputs; they need not be converted until and "
"unless better performance is important."
msgstr ""
"Для использования развёрнутого хранения тип данных должен определять "
"развёрнутый формат по правилам, описанным в <filename>src/include/utils/"
"expandeddatum.h</filename>, и предоставлять функции для "
"<quote>разворачивания</quote> плоского значения в этот формат, а также для "
"<quote>заворачивания</quote> этого формата опять в обычное представление "
"varlena. Затем надо добиться, чтобы все функции на C могли принимать любое "
"представление, возможно выполняя преобразование одного в другое "
"непосредственно при получении. Для этого не требуется исправлять сразу все "
"существующие функции для этого типа данных, так как имеющийся стандартный "
"макрос <function>PG_DETOAST_DATUM</function> способен преобразовывать "
"развёрнутые входные данные в обычный плоский формат. Таким образом, все "
"существующие функции, работающие с плоским форматом varlena продолжат "
"работать, хотя и не очень эффективно, с развёрнутыми входными данными; их "
"необязательно переделывать, пока не потребуется оптимизировать "
"производительность."

#: xtypes.xml:333(para)
msgid ""
"C functions that know how to work with an expanded representation typically "
"fall into two categories: those that can only handle expanded format, and "
"those that can handle either expanded or flat varlena inputs. The former are "
"easier to write but may be less efficient overall, because converting a flat "
"input to expanded form for use by a single function may cost more than is "
"saved by operating on the expanded format. When only expanded format need be "
"handled, conversion of flat inputs to expanded form can be hidden inside an "
"argument-fetching macro, so that the function appears no more complex than "
"one working with traditional varlena input. To handle both types of input, "
"write an argument-fetching function that will detoast external, short-"
"header, and compressed varlena inputs, but not expanded inputs. Such a "
"function can be defined as returning a pointer to a union of the flat "
"varlena format and the expanded format. Callers can use the "
"<function>VARATT_IS_EXPANDED_HEADER()</function> macro to determine which "
"format they received."
msgstr ""
"Функции на C, умеющие работать с развёрнутым представлением, обычно делятся "
"на две категории: те, что могут работать с развёрнутым форматом, и те, что "
"могут принимать и развёрнутые, и плоские данные varlena. Первые проще "
"написать, но они могут быть менее эффективными в целом, так как "
"преобразование плоского значения в развёрнутую форму для использования "
"только одной функцией может стоить больше, чем сэкономится при обработке "
"данных в развёрнутом формате. Когда нужно работать только с развёрнутым "
"форматом, преобразование плоских значений в развёрнутую форму можно скрыть в "
"макросе, извлекающем аргументы, чтобы функция была не сложнее, чем "
"работающая с традиционными входными данными varlena. Чтобы принимать оба "
"варианта входных значений, напишите функцию извлечения аргументов, которая "
"будет распаковывать значения с сокращённым заголовком, а также внешние и "
"сжатые, но не развёрнутые данные. Такую функцию можно определить как "
"возвращающую указатель на объединение плоского формата varlena и "
"развёрнутого формата. Какой формат получен фактически, вызывающий код может "
"определить, вызвав макрос <function>VARATT_IS_EXPANDED_HEADER()</function>."

#: xtypes.xml:352(para)
msgid ""
"The <acronym>TOAST</acronym> infrastructure not only allows regular varlena "
"values to be distinguished from expanded values, but also distinguishes "
"<quote>read-write</quote> and <quote>read-only</quote> pointers to expanded "
"values. C functions that only need to examine an expanded value, or will "
"only change it in safe and non-semantically-visible ways, need not care "
"which type of pointer they receive. C functions that produce a modified "
"version of an input value are allowed to modify an expanded input value in-"
"place if they receive a read-write pointer, but must not modify the input if "
"they receive a read-only pointer; in that case they have to copy the value "
"first, producing a new value to modify. A C function that has constructed a "
"new expanded value should always return a read-write pointer to it. Also, a "
"C function that is modifying a read-write expanded value in-place should "
"take care to leave the value in a sane state if it fails partway through."
msgstr ""
"Инфраструктура <acronym>TOAST</acronym> позволяет не только отличить обычные "
"значения varlena от развёрнутых значений, но и различить указатели "
"<quote>для чтения/записи</quote> и <quote>только для чтения</quote> на "
"развёрнутые значения. Функции на C, которым нужно читать развёрнутое "
"значение, или которые будут менять его безопасным и невидимым извне образом, "
"могут не обращать внимания на тип полученного указателя. Если же функции на "
"C выдают изменённую версию входного значения, они могут изменять развёрнутые "
"входные данные на месте, только когда получают указатель для чтения/записи, "
"но не когда получен указатель только для чтения. В последнем случае они "
"должны сначала скопировать значение и получить новое значение, допускающее "
"изменение. Функция на C, создающая новое развёрнутое значение, должна всегда "
"возвращать указатель на него для чтения/записи. Кроме того, функция, "
"изменяющая развёрнутое значение непосредственно по указателю для чтения/"
"записи должна позаботиться о том, чтобы это значение осталось в приемлемом "
"состоянии, если она отработает не полностью."

#: xtypes.xml:369(para)
msgid ""
"For examples of working with expanded values, see the standard array "
"infrastructure, particularly <filename>src/backend/utils/adt/array_expanded."
"c</filename>."
msgstr ""
"Примеры работы с развёрнутыми значениями можно найти в стандартной "
"инфраструктуре массивов, в частности в <filename>src/backend/utils/adt/"
"array_expanded.c</filename>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xtypes.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
