# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:31+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: bgworker.xml:5(title)
msgid "Background Worker Processes"
msgstr "Фоновые рабочие процессы"

#: bgworker.xml:7(indexterm)
msgid "<primary>Background workers</primary>"
msgstr "<primary>Фоновые рабочие процессы</primary>"

#: bgworker.xml:11(para)
msgid ""
"PostgreSQL can be extended to run user-supplied code in separate processes. "
"Such processes are started, stopped and monitored by <command>postgres</"
"command>, which permits them to have a lifetime closely linked to the "
"server's status. These processes have the option to attach to "
"<productname>PostgreSQL</productname>'s shared memory area and to connect to "
"databases internally; they can also run multiple transactions serially, just "
"like a regular client-connected server process. Also, by linking to "
"<application>libpq</application> they can connect to the server and behave "
"like a regular client application."
msgstr ""
"PostgreSQL поддерживает расширенную возможность запускать пользовательский "
"код в отдельных процессах. Такие процессы запускаются, останавливаются и "
"контролируются главным процессом <command>postgres</command>, который "
"позволяет тесно связать их жизненный цикл с состоянием сервера. Эти процессы "
"могут получать доступ к области разделяемой памяти <productname>PostgreSQL</"
"productname> и устанавливать внутренние подключения к базам данных; они "
"также могут последовательно запускать транзакции, как и обычные серверные "
"процессы, обслуживающие клиентов. Кроме того, используя <application>libpq</"
"application>, они могут подключаться к серверу и работать как обычные "
"клиентские приложения."

#: bgworker.xml:23(para)
msgid ""
"There are considerable robustness and security risks in using background "
"worker processes because, being written in the <literal>C</literal> "
"language, they have unrestricted access to data. Administrators wishing to "
"enable modules that include background worker process should exercise "
"extreme caution. Only carefully audited modules should be permitted to run "
"background worker processes."
msgstr ""
"С использованием фоновых рабочих процессов сопряжены угрозы стабильности и "
"безопасности, так как они реализуются на языке <literal>C</literal>, и "
"значит имеют неограниченный доступ к данным. Администраторы, желающие "
"использовать модули, в которых задействованы фоновые рабочие процессы, "
"должны быть крайне осторожными. Запускать рабочие процессы можно разрешать "
"только модулям, прошедшим всесторонний аудит."

#: bgworker.xml:33(para)
msgid ""
"Background workers can be initialized at the time that "
"<productname>PostgreSQL</productname> is started by including the module "
"name in <varname>shared_preload_libraries</varname>. A module wishing to run "
"a background worker can register it by calling "
"<function>RegisterBackgroundWorker(<type>BackgroundWorker *worker</type>)</"
"function> from its <function>_PG_init()</function>. Background workers can "
"also be started after the system is up and running by calling the function "
"<function>RegisterDynamicBackgroundWorker(<type>BackgroundWorker *worker, "
"BackgroundWorkerHandle **handle</type>)</function>. Unlike "
"<function>RegisterBackgroundWorker</function>, which can only be called from "
"within the postmaster, <function>RegisterDynamicBackgroundWorker</function> "
"must be called from a regular backend."
msgstr ""
"Рабочие процессы могут инициализироваться во время запуска "
"<productname>PostgreSQL</productname>, если имя соответствующего модуля "
"добавлено в <varname>shared_preload_libraries</varname>. Модуль, желающий "
"запустить фоновый процесс, может зарегистрировать его, вызвав "
"<function>RegisterBackgroundWorker(<type>BackgroundWorker *worker</type>)</"
"function> из своей функции <function>_PG_init()</function>. Рабочие процессы "
"также могут быть запущены после запуска системы с помощью функции "
"<function>RegisterDynamicBackgroundWorker(<type>BackgroundWorker *worker, "
"BackgroundWorkerHandle **handle</type>)</function>. В отличие от функции "
"<function>RegisterBackgroundWorker</function>, которую можно вызывать только "
"из управляющего процесса, <function>RegisterDynamicBackgroundWorker</"
"function> должна вызываться из обычного обслуживающего процесса."

#: bgworker.xml:50(programlisting)
#, no-wrap
msgid ""
"typedef void (*bgworker_main_type)(Datum main_arg);\n"
"typedef struct BackgroundWorker\n"
"{\n"
"    char        bgw_name[BGW_MAXLEN];\n"
"    int         bgw_flags;\n"
"    BgWorkerStartTime bgw_start_time;\n"
"    int         bgw_restart_time;       /* in seconds, or BGW_NEVER_RESTART */\n"
"    bgworker_main_type bgw_main;\n"
"    char        bgw_library_name[BGW_MAXLEN];   /* only if bgw_main is NULL */\n"
"    char        bgw_function_name[BGW_MAXLEN];  /* only if bgw_main is NULL */\n"
"    Datum       bgw_main_arg;\n"
"    char        bgw_extra[BGW_EXTRALEN];\n"
"    int         bgw_notify_pid;\n"
"} BackgroundWorker;"
msgstr ""
"typedef void (*bgworker_main_type)(Datum main_arg);\n"
"typedef struct BackgroundWorker\n"
"{\n"
"    char        bgw_name[BGW_MAXLEN];\n"
"    int         bgw_flags;\n"
"    BgWorkerStartTime bgw_start_time;\n"
"    int         bgw_restart_time;       /* в секундах, либо BGW_NEVER_RESTART */\n"
"    bgworker_main_type bgw_main;\n"
"    char        bgw_library_name[BGW_MAXLEN];   /* только если bgw_main — NULL */\n"
"    char        bgw_function_name[BGW_MAXLEN];  /* только если bgw_main — NULL */\n"
"    Datum       bgw_main_arg;\n"
"    char        bgw_extra[BGW_EXTRALEN];\n"
"    int         bgw_notify_pid;\n"
"} BackgroundWorker;"

#: bgworker.xml:48(para)
msgid ""
"The structure <structname>BackgroundWorker</structname> is defined thus: "
"<placeholder-1/>"
msgstr ""
"Структура <structname>BackgroundWorker</structname> определяется так: "
"<placeholder-1/>"

#: bgworker.xml:68(para)
msgid ""
"<structfield>bgw_name</structfield> is a string to be used in log messages, "
"process listings and similar contexts."
msgstr ""
"Поле <structfield>bgw_name</structfield> содержит строку, выводимую в "
"отладочных сообщениях, списках процессов и подобных контекстах."

#: bgworker.xml:79(literal)
msgid "BGWORKER_SHMEM_ACCESS"
msgstr "BGWORKER_SHMEM_ACCESS"

#: bgworker.xml:82(indexterm)
msgid "<primary>BGWORKER_SHMEM_ACCESS</primary>"
msgstr "<primary>BGWORKER_SHMEM_ACCESS</primary>"

#: bgworker.xml:81(para)
msgid ""
"<placeholder-1/> Requests shared memory access. Workers without shared "
"memory access cannot access any of <productname>PostgreSQL's</productname> "
"shared data structures, such as heavyweight or lightweight locks, shared "
"buffers, or any custom data structures which the worker itself may wish to "
"create and use."
msgstr ""
"<placeholder-1/> Запрашивается доступ к общей памяти. Рабочие процессы без "
"доступа к общей памяти не могут обращаться к общим структурам данных "
"<productname>PostgreSQL</productname>, в частности, к обычным и лёгким "
"блокировкам, общим буферам, или каким-либо структурам данным, которые "
"рабочий процесс может создавать для собственного пользования."

#: bgworker.xml:93(literal)
msgid "BGWORKER_BACKEND_DATABASE_CONNECTION"
msgstr "BGWORKER_BACKEND_DATABASE_CONNECTION"

#: bgworker.xml:96(indexterm)
msgid "<primary>BGWORKER_BACKEND_DATABASE_CONNECTION</primary>"
msgstr "<primary>BGWORKER_BACKEND_DATABASE_CONNECTION</primary>"

#: bgworker.xml:95(para)
msgid ""
"<placeholder-1/> Requests the ability to establish a database connection "
"through which it can later run transactions and queries. A background worker "
"using <literal>BGWORKER_BACKEND_DATABASE_CONNECTION</literal> to connect to "
"a database must also attach shared memory using "
"<literal>BGWORKER_SHMEM_ACCESS</literal>, or worker start-up will fail."
msgstr ""
"<placeholder-1/> Запрашивается возможность устанавливать подключение к базе "
"данных, через которое можно запускать транзакции и запросы. Рабочий процесс, "
"использующий <literal>BGWORKER_BACKEND_DATABASE_CONNECTION</literal> для "
"подключения к базе данных, должен также запросить доступ к разделяемой "
"памяти, установив <literal>BGWORKER_SHMEM_ACCESS</literal>; в противном "
"случае процесс не запустится."

#: bgworker.xml:73(para)
msgid ""
"<structfield>bgw_flags</structfield> is a bitwise-or'd bit mask indicating "
"the capabilities that the module wants. Possible values are: <placeholder-1/>"
msgstr ""
"Поле <structfield>bgw_flags</structfield> представляет битовую маску, "
"обозначающую запрашиваемые модулем возможности. Допустимые в нём флаги: "
"<placeholder-1/>"

#: bgworker.xml:110(para)
msgid ""
"<structfield>bgw_start_time</structfield> is the server state during which "
"<command>postgres</command> should start the process; it can be one of "
"<literal>BgWorkerStart_PostmasterStart</literal> (start as soon as "
"<command>postgres</command> itself has finished its own initialization; "
"processes requesting this are not eligible for database connections), "
"<literal>BgWorkerStart_ConsistentState</literal> (start as soon as a "
"consistent state has been reached in a hot standby, allowing processes to "
"connect to databases and run read-only queries), and "
"<literal>BgWorkerStart_RecoveryFinished</literal> (start as soon as the "
"system has entered normal read-write state). Note the last two values are "
"equivalent in a server that's not a hot standby. Note that this setting only "
"indicates when the processes are to be started; they do not stop when a "
"different state is reached."
msgstr ""
"В <structfield>bgw_start_time</structfield> определяется состояние сервера, "
"в котором <command>postgres</command> должен запустить этот процесс; "
"возможные варианты: <literal>BgWorkerStart_PostmasterStart</literal> "
"(выполнить запуск сразу после того, как <command>postgres</command> завершит "
"инициализацию; процессы, выбирающие такой режим, не могут подключаться к "
"базам данных), <literal>BgWorkerStart_ConsistentState</literal> (выполнить "
"запуск, когда будет достигнуто согласованное состояние горячего резерва, и "
"когда процессы могут подключаться к базам данных и выполнять запросы на "
"чтение), и <literal>BgWorkerStart_RecoveryFinished</literal> (выполнить "
"запуск, как только система перейдёт в обычный режим чтения-записи). "
"Заметьте, что два последних варианта различаются только для серверов "
"горячего резерва. Заметьте также, что этот параметр указывает только, когда "
"должны запускаться процессы; при переходе в другое состояние они не будут "
"останавливаться."

#: bgworker.xml:126(para)
msgid ""
"<structfield>bgw_restart_time</structfield> is the interval, in seconds, "
"that <command>postgres</command> should wait before restarting the process, "
"in case it crashes. It can be any positive value, or "
"<literal>BGW_NEVER_RESTART</literal>, indicating not to restart the process "
"in case of a crash."
msgstr ""
"<structfield>bgw_restart_time</structfield> задаёт паузу (в секундах), "
"которую должен сделать <command>postgres</command>, прежде чем перезапускать "
"процесс в случае его отказа. Это может быть любое положительное значение, "
"либо <literal>BGW_NEVER_RESTART</literal>, указывающее, что процесс не нужно "
"перезапускать в случае сбоя."

#: bgworker.xml:134(para)
msgid ""
"<structfield>bgw_main</structfield> is a pointer to the function to run when "
"the process is started. This field can only safely be used to launch "
"functions within the core server, because shared libraries may be loaded at "
"different starting addresses in different backend processes. This will "
"happen on all platforms when the library is loaded using any mechanism other "
"than <xref linkend=\"guc-shared-preload-libraries\"/>. Even when that "
"mechanism is used, address space layout variations will still occur on "
"Windows, and when <literal>EXEC_BACKEND</literal> is used. Therefore, most "
"users of this API should set this field to NULL. If it is non-NULL, it takes "
"precedence over <structfield>bgw_library_name</structfield> and "
"<structfield>bgw_function_name</structfield>."
msgstr ""
"В <structfield>bgw_main</structfield> записывается указатель на функцию, "
"вызываемую при запуске процесса. Этот указатель может безопасно "
"использоваться для вызова функций только из ядра сервера, так как "
"разделяемые библиотеки могут загружаться в разные рабочие процессы по разным "
"адресам. Это происходит на всех платформах, если для загрузки библиотек "
"применяется не механизм <xref linkend=\"guc-shared-preload-libraries\"/>. И "
"даже когда применяется этот механизм, в системе Windows в карте адресного "
"пространства возможны различия и при использовании <literal>EXEC_BACKEND</"
"literal>. Поэтому пользователи этого API обычно должны записывать в это поле "
"NULL. Если его значение отлично от NULL, оно имеет приоритет над "
"<structfield>bgw_library_name</structfield> и "
"<structfield>bgw_function_name</structfield>."

#: bgworker.xml:148(para)
msgid ""
"<structfield>bgw_library_name</structfield> is the name of a library in "
"which the initial entry point for the background worker should be sought. "
"The named library will be dynamically loaded by the worker process and "
"<structfield>bgw_function_name</structfield> will be used to identify the "
"function to be called. If loading a function from the core code, "
"<structfield>bgw_main</structfield> should be set instead."
msgstr ""
"<structfield>bgw_library_name</structfield> определяет имя библиотеки, в "
"которой следует искать точку входа для запуска рабочего процесса. Указанная "
"библиотека будет динамически загружена рабочим процессом, а вызываемая "
"функция будет выбрана по имени <structfield>bgw_function_name</structfield>. "
"Для функции, загружаемой из кода ядра, вместо него следует задать "
"<structfield>bgw_main</structfield>."

#: bgworker.xml:157(para)
msgid ""
"<structfield>bgw_function_name</structfield> is the name of a function in a "
"dynamically loaded library which should be used as the initial entry point "
"for a new background worker."
msgstr ""
"<structfield>bgw_function_name</structfield> определяет имя функции в "
"динамически загружаемой библиотеке, которая будет точкой входа в новый "
"рабочий процесс."

#: bgworker.xml:163(para)
msgid ""
"<structfield>bgw_main_arg</structfield> is the <type>Datum</type> argument "
"to the background worker main function. Regardless of whether that function "
"is specified via <structfield>bgw_main</structfield> or via the combination "
"of <function>bgw_library_name</function> and <function>bgw_function_name</"
"function>, this main function should take a single argument of type "
"<type>Datum</type> and return <type>void</type>. <structfield>bgw_main_arg</"
"structfield> will be passed as the argument. In addition, the global "
"variable <literal>MyBgworkerEntry</literal> points to a copy of the "
"<structname>BackgroundWorker</structname> structure passed at registration "
"time; the worker may find it helpful to examine this structure."
msgstr ""
"В <structfield>bgw_main_arg</structfield> задаётся аргумент <type>Datum</"
"type>, передаваемый основной функции фонового процесса. Независимо от того, "
"задаётся ли эта функция значением поля <structfield>bgw_main</structfield> "
"или сочетанием полей <function>bgw_library_name</function> и "
"<function>bgw_function_name</function>, она должна принимать один аргумент "
"типа <type>Datum</type> и возвращать <type>void</type>. В качестве этого "
"аргумента ей и передаётся <structfield>bgw_main_arg</structfield>. Кроме "
"того, глобальная переменная <literal>MyBgworkerEntry</literal> указывает на "
"копию структуры <structname>BackgroundWorker</structname>, переданной при "
"регистрации; содержимое этой структуры может быть полезно рабочему процессу."

#: bgworker.xml:177(para)
msgid ""
"On Windows (and anywhere else where <literal>EXEC_BACKEND</literal> is "
"defined) or in dynamic background workers it is not safe to pass a "
"<type>Datum</type> by reference, only by value. If an argument is required, "
"it is safest to pass an int32 or other small value and use that as an index "
"into an array allocated in shared memory. If a value like a <type>cstring</"
"type> or <type>text</type> is passed then the pointer won't be valid from "
"the new background worker process."
msgstr ""
"В Windows (и везде, где определяется <literal>EXEC_BACKEND</literal>) или в "
"динамических рабочих процессах передавать <type>Datum</type> по ссылке "
"небезопасно, возможна только передача по значению. Поэтому если функции "
"требуется аргумент, наиболее безопасно будет передать int32 или другое "
"небольшое значение, содержащее индекс в массиве, размещённом в разделяемой "
"памяти. Если же попытаться передать значение <type>cstring</type> или "
"<type>text</type>, этот указатель нельзя будет использовать в новом рабочем "
"процессе."

#: bgworker.xml:187(para)
msgid ""
"<structfield>bgw_extra</structfield> can contain extra data to be passed to "
"the background worker. Unlike <structfield>bgw_main_arg</structfield>, this "
"data is not passed as an argument to the worker's main function, but it can "
"be accessed via <literal>MyBgworkerEntry</literal>, as discussed above."
msgstr ""
"Поле <structfield>bgw_extra</structfield> может содержать дополнительные "
"данные, передаваемые фоновому рабочему процессу. В отличие от "
"<structfield>bgw_main_arg</structfield>, эти данные не передаются в качестве "
"аргумента основной функции рабочего процесса, но могут быть получены через "
"<literal>MyBgworkerEntry</literal>, как описывалось выше."

#: bgworker.xml:194(para)
msgid ""
"<structfield>bgw_notify_pid</structfield> is the PID of a PostgreSQL backend "
"process to which the postmaster should send <literal>SIGUSR1</literal> when "
"the process is started or exits. It should be 0 for workers registered at "
"postmaster startup time, or when the backend registering the worker does not "
"wish to wait for the worker to start up. Otherwise, it should be initialized "
"to <literal>MyProcPid</literal>."
msgstr ""
"В <structfield>bgw_notify_pid</structfield> задаётся PID обслуживающего "
"процесса PostgreSQL, которому главный процесс должен посылать сигнал "
"<literal>SIGUSR1</literal> при запуске и завершении нового рабочего "
"процесса. Это поле должно содержать 0 для рабочих процессов, регистрируемых "
"при запуске главного процесса, либо когда обслуживающий процесс не желает "
"ждать окончания запуска рабочего процесса. Во всех остальных случаях в нём "
"должно быть значение <literal>MyProcPid</literal>."

#: bgworker.xml:203(para)
msgid ""
"Once running, the process can connect to a database by calling "
"<function>BackgroundWorkerInitializeConnection(<parameter>char *dbname</"
"parameter>, <parameter>char *username</parameter>)</function> or "
"<function>BackgroundWorkerInitializeConnectionByOid(<parameter>Oid dboid</"
"parameter>, <parameter>Oid useroid</parameter>)</function>. This allows the "
"process to run transactions and queries using the <literal>SPI</literal> "
"interface. If <varname>dbname</varname> is NULL or <varname>dboid</varname> "
"is <literal>InvalidOid</literal>, the session is not connected to any "
"particular database, but shared catalogs can be accessed. If "
"<varname>username</varname> is NULL or <varname>useroid</varname> is "
"<literal>InvalidOid</literal>, the process will run as the superuser created "
"during <command>initdb</command>. A background worker can only call one of "
"these two functions, and only once. It is not possible to switch databases."
msgstr ""
"Запущенный процесс может подключиться к базе данных, вызвав "
"<function>BackgroundWorkerInitializeConnection(<parameter>char *dbname</"
"parameter>, <parameter>char *username</parameter>)</function> или "
"<function>BackgroundWorkerInitializeConnectionByOid(<parameter>Oid dboid</"
"parameter>, <parameter>Oid useroid</parameter>)</function>. Через это "
"подключение процесс сможет выполнять транзакции и запросы, используя функции "
"<literal>SPI</literal>. Если в <varname>dbname</varname> передаётся NULL или "
"<varname>dboid</varname> равен <literal>InvalidOid</literal>, сеанс не "
"подключается ни к какой конкретной базе данных, но может обращаться к общим "
"каталогам. Если в <varname>username</varname> передаётся NULL или "
"<varname>useroid</varname> равен <literal>InvalidOid</literal>, процесс "
"будет действовать от имени суперпользователя, созданного во время "
"<command>initdb</command>. Рабочий процесс может вызывать только одну из "
"двух этих функций и только один раз. Переключаться между базами данных он не "
"может."

#: bgworker.xml:217(para)
msgid ""
"Signals are initially blocked when control reaches the "
"<structfield>bgw_main</structfield> function, and must be unblocked by it; "
"this is to allow the process to customize its signal handlers, if necessary. "
"Signals can be unblocked in the new process by calling "
"<function>BackgroundWorkerUnblockSignals</function> and blocked by calling "
"<function>BackgroundWorkerBlockSignals</function>."
msgstr ""
"Сигналы изначально блокируются при вызове функции <structfield>bgw_main</"
"structfield> и при необходимости должны быть разблокированы ей; это "
"позволяет процессу настроить собственные обработчики событий. Новый процесс "
"может разблокировать сигналы, вызвав "
"<function>BackgroundWorkerUnblockSignals</function>, и заблокировать их, "
"вызвав <function>BackgroundWorkerBlockSignals</function>."

#: bgworker.xml:226(para)
msgid ""
"If <structfield>bgw_restart_time</structfield> for a background worker is "
"configured as <literal>BGW_NEVER_RESTART</literal>, or if it exits with an "
"exit code of 0 or is terminated by <function>TerminateBackgroundWorker</"
"function>, it will be automatically unregistered by the postmaster on exit. "
"Otherwise, it will be restarted after the time period configured via "
"<structfield>bgw_restart_time</structfield>, or immediately if the "
"postmaster reinitializes the cluster due to a backend failure. Backends "
"which need to suspend execution only temporarily should use an interruptible "
"sleep rather than exiting; this can be achieved by calling "
"<function>WaitLatch()</function>. Make sure the "
"<literal>WL_POSTMASTER_DEATH</literal> flag is set when calling that "
"function, and verify the return code for a prompt exit in the emergency case "
"that <command>postgres</command> itself has terminated."
msgstr ""
"Если <structfield>bgw_restart_time</structfield> для рабочего процесса имеет "
"значение <literal>BGW_NEVER_RESTART</literal>, либо он завершается с кодом "
"выхода 0, либо если его работа заканчивается вызовом "
"<function>TerminateBackgroundWorker</function>, он автоматически перестаёт "
"контролироваться управляющим процессом при выходе. В противном случае он "
"будет перезапущен через время, заданное в <structfield>bgw_restart_time</"
"structfield>, либо немедленно, если управляющему серверу пришлось "
"переинициализировать кластер из-за сбоя обслуживающего процесса. "
"Обслуживающие процессы, которым нужно только приостановить своё выполнение "
"на время, должны переходить в состояние прерываемого ожидания, а не "
"завершаться; для этого используется функция <function>WaitLatch()</"
"function>. При вызове этой функции обязательно установите флаг "
"<literal>WL_POSTMASTER_DEATH</literal> и проверьте код возврата, чтобы "
"корректно выйти в экстренном случае, когда был завершён сам "
"<command>postgres</command>."

#: bgworker.xml:242(para)
msgid ""
"When a background worker is registered using the "
"<function>RegisterDynamicBackgroundWorker</function> function, it is "
"possible for the backend performing the registration to obtain information "
"regarding the status of the worker. Backends wishing to do this should pass "
"the address of a <type>BackgroundWorkerHandle *</type> as the second "
"argument to <function>RegisterDynamicBackgroundWorker</function>. If the "
"worker is successfully registered, this pointer will be initialized with an "
"opaque handle that can subsequently be passed to "
"<function>GetBackgroundWorkerPid(<parameter>BackgroundWorkerHandle *</"
"parameter>, <parameter>pid_t *</parameter>)</function> or "
"<function>TerminateBackgroundWorker(<parameter>BackgroundWorkerHandle *</"
"parameter>)</function>. <function>GetBackgroundWorkerPid</function> can be "
"used to poll the status of the worker: a return value of "
"<literal>BGWH_NOT_YET_STARTED</literal> indicates that the worker has not "
"yet been started by the postmaster; <literal>BGWH_STOPPED</literal> "
"indicates that it has been started but is no longer running; and "
"<literal>BGWH_STARTED</literal> indicates that it is currently running. In "
"this last case, the PID will also be returned via the second argument. "
"<function>TerminateBackgroundWorker</function> causes the postmaster to send "
"<literal>SIGTERM</literal> to the worker if it is running, and to unregister "
"it as soon as it is not."
msgstr ""
"Когда рабочий процесс регистрируется функцией "
"<function>RegisterDynamicBackgroundWorker</function>, обслуживающий процесс, "
"производящий эту регистрацию, может получить информацию о состоянии "
"порождённого процесса. Обслуживающие процессы, желающие сделать это, должны "
"передать адрес <type>BackgroundWorkerHandle *</type> во втором аргументе "
"<function>RegisterDynamicBackgroundWorker</function>. Если рабочий процесс "
"успешно зарегистрирован, по этому адресу будет записан указатель на скрытую "
"структуру, который можно затем передать функции "
"<function>GetBackgroundWorkerPid(<parameter>BackgroundWorkerHandle *</"
"parameter>, <parameter>pid_t *</parameter>)</function> или "
"<function>TerminateBackgroundWorker(<parameter>BackgroundWorkerHandle *</"
"parameter>)</function>. Вызывая <function>GetBackgroundWorkerPid</function>, "
"можно опрашивать состояние рабочего процесса: значение результата "
"<literal>BGWH_NOT_YET_STARTED</literal> показывает, что рабочий процесс ещё "
"не запущен управляющим; <literal>BGWH_STOPPED</literal> показывает, что он "
"был запущен, но сейчас не работает; и <literal>BGWH_STARTED</literal> "
"показывает, что он работает в данный момент. В последнем случае через второй "
"аргумент также возвращается PID этого процесса. Обрабатывая вызов "
"<function>TerminateBackgroundWorker</function>, управляющий процесс посылает "
"<literal>SIGTERM</literal> рабочему процессу, если он работает, и перестаёт "
"его контролировать сразу по его завершении."

#: bgworker.xml:265(para)
msgid ""
"In some cases, a process which registers a background worker may wish to "
"wait for the worker to start up. This can be accomplished by initializing "
"<structfield>bgw_notify_pid</structfield> to <literal>MyProcPid</literal> "
"and then passing the <type>BackgroundWorkerHandle *</type> obtained at "
"registration time to "
"<function>WaitForBackgroundWorkerStartup(<parameter>BackgroundWorkerHandle "
"*handle</parameter>, <parameter>pid_t *</parameter>)</function> function. "
"This function will block until the postmaster has attempted to start the "
"background worker, or until the postmaster dies. If the background runner is "
"running, the return value will <literal>BGWH_STARTED</literal>, and the PID "
"will be written to the provided address. Otherwise, the return value will be "
"<literal>BGWH_STOPPED</literal> or <literal>BGWH_POSTMASTER_DIED</literal>."
msgstr ""
"В некоторых случаях процессу, регистрирующему рабочий процесс, может "
"потребоваться дождаться завершения запуска этого процесса. Это можно "
"реализовать, записав в <structfield>bgw_notify_pid</structfield> значение "
"<literal>MyProcPid</literal>, а затем передав указатель "
"<type>BackgroundWorkerHandle *</type>, полученный во время регистрации, "
"функции "
"<function>WaitForBackgroundWorkerStartup(<parameter>BackgroundWorkerHandle "
"*handle</parameter>, <parameter>pid_t *</parameter>)</function>. Эта функция "
"заблокирует выполнение, пока управляющий процесс не попытается запустить "
"рабочий процесс, либо пока сам управляющий процесс не завершится. Если "
"рабочий процесс запущен, возвращается значение <literal>BGWH_STARTED</"
"literal>, и по переданному адресу записывается его PID. В противном случае "
"возвращается значение <literal>BGWH_STOPPED</literal> или "
"<literal>BGWH_POSTMASTER_DIED</literal>."

#: bgworker.xml:281(para)
msgid ""
"If a background worker sends asynchronous notifications with the "
"<command>NOTIFY</command> command via the Server Programming Interface "
"(<acronym>SPI</acronym>), it should call <function>ProcessCompletedNotifies</"
"function> explicitly after committing the enclosing transaction so that any "
"notifications can be delivered. If a background worker registers to receive "
"asynchronous notifications with the <command>LISTEN</command> through "
"<acronym>SPI</acronym>, the worker will log those notifications, but there "
"is no programmatic way for the worker to intercept and respond to those "
"notifications."
msgstr ""
"Если фоновый рабочий процесс передаёт асинхронные уведомления, вызывая "
"команду <command>NOTIFY</command> через <acronym>SPI</acronym> (Server "
"Programming Interface, Интерфейс программирования сервера), он должен явно "
"вызвать <function>ProcessCompletedNotifies</function> после фиксации "
"окружающей транзакции, чтобы все эти уведомления были доставлены. Если "
"рабочий процесс зарегистрируется для получения асинхронных уведомлений, "
"вызвав <command>LISTEN</command> через <acronym>SPI</acronym>, уведомления "
"будут выводиться, но перехватить и обработать эти уведомления программным "
"образом нет возможности."

#: bgworker.xml:293(para)
msgid ""
"The <filename>src/test/modules/worker_spi</filename> module contains a "
"working example, which demonstrates some useful techniques."
msgstr ""
"Рабочий пример, демонстрирующий некоторые полезные приёмы, можно найти в "
"модуле <filename>src/test/modules/worker_spi</filename>."

#: bgworker.xml:299(para)
msgid ""
"The maximum number of registered background workers is limited by <xref "
"linkend=\"guc-max-worker-processes\"/>."
msgstr ""
"Максимальное число рабочих процессов, которые можно зарегистрировать, "
"ограничивается значением <xref linkend=\"guc-max-worker-processes\"/>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: bgworker.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
