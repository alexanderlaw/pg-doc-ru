# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-21 15:23+0300\n"
"PO-Revision-Date: 2017-09-28 18:33+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5(title)
msgid "Frontend/Backend Protocol"
msgstr "Клиент-серверный протокол"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:7(indexterm)
msgid "<primary>protocol</primary> <secondary>frontend-backend</secondary>"
msgstr "<primary>протокол</primary> <secondary>клиент-серверный</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:12(para)
msgid ""
"<productname>PostgreSQL</productname> uses a message-based protocol for "
"communication between frontends and backends (clients and servers). The "
"protocol is supported over <acronym>TCP/IP</acronym> and also over Unix-"
"domain sockets. Port number 5432 has been registered with IANA as the "
"customary TCP port number for servers supporting this protocol, but in "
"practice any non-privileged port number can be used."
msgstr ""
"Клиенты и серверы <productname>PostgreSQL</productname> взаимодействуют друг "
"с другом, используя специальный протокол, основанный на сообщениях. Этот "
"протокол поддерживается для соединений по <acronym>TCP/IP</acronym> и через "
"доменные сокеты Unix. Для серверов, поддерживающих этот протокол, в IANA "
"зарезервирован номер TCP-порта 5432, но на практике можно задействовать "
"любой порт, не требующий особых привилегий."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:21(para)
msgid ""
"This document describes version 3.0 of the protocol, implemented in "
"<productname>PostgreSQL</productname> 7.4 and later. For descriptions of the "
"earlier protocol versions, see previous releases of the "
"<productname>PostgreSQL</productname> documentation. A single server can "
"support multiple protocol versions. The initial startup-request message "
"tells the server which protocol version the client is attempting to use, and "
"then the server follows that protocol if it is able."
msgstr ""
"В этой документации описана версия 3.0 этого протокола, реализованная в "
"<productname>PostgreSQL</productname> версии 7.4 и новее. За описанием "
"предыдущих версий протокола обратитесь к документации более ранних выпусков "
"<productname>PostgreSQL</productname>. Один сервер способен поддерживать "
"несколько версий протокола. Из стартового сообщения при установлении "
"соединения сервер узнаёт, какую версию протокола пытается использовать "
"клиент, и если сервер поддерживает запрошенную версию, он продолжает обмен "
"по этому протоколу."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:32(para)
msgid ""
"In order to serve multiple clients efficiently, the server launches a new "
"<quote>backend</quote> process for each client. In the current "
"implementation, a new child process is created immediately after an incoming "
"connection is detected. This is transparent to the protocol, however. For "
"purposes of the protocol, the terms <quote>backend</quote> and "
"<quote>server</quote> are interchangeable; likewise <quote>frontend</quote> "
"and <quote>client</quote> are interchangeable."
msgstr ""
"Чтобы эффективно обслуживать множество клиентов, сервер запускает отдельный "
"<quote>обслуживающий</quote> процесс для каждого клиента. В текущей "
"реализации новый дочерний процесс запускается немедленно после обнаружения "
"входящего подключения. Однако это происходит прозрачно для протокола. С "
"точки зрения протокола, термины <quote>обслуживающий процесс</quote>, "
"<quote>процесс заднего плана</quote> и <quote>сервер</quote> "
"взаимозаменяемы, как и <quote>приложение переднего плана</quote> и "
"<quote>клиент</quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:44(title)
msgid "Overview"
msgstr "Обзор"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:46(para)
msgid ""
"The protocol has separate phases for startup and normal operation. In the "
"startup phase, the frontend opens a connection to the server and "
"authenticates itself to the satisfaction of the server. (This might involve "
"a single message, or multiple messages depending on the authentication "
"method being used.) If all goes well, the server then sends status "
"information to the frontend, and finally enters normal operation. Except for "
"the initial startup-request message, this part of the protocol is driven by "
"the server."
msgstr ""
"В протоколе выделены отдельные фазы для запуска и обычных операций. На "
"стадии запуска клиент устанавливает подключение к серверу и должен "
"удовлетворить сервер, подтвердив свою подлинность. (Для этого может "
"потребоваться одно или несколько сообщений, в зависимости от применяемого "
"метода проверки подлинности.) Если всё проходит успешно, сервер сообщает "
"клиенту о текущем состоянии, а затем переходит к обычной работе. Не считая "
"начального стартового сообщения, в этой фазе протокола ведущую роль играет "
"сервер."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:57(para)
msgid ""
"During normal operation, the frontend sends queries and other commands to "
"the backend, and the backend sends back query results and other responses. "
"There are a few cases (such as <command>NOTIFY</command>) wherein the "
"backend will send unsolicited messages, but for the most part this portion "
"of a session is driven by frontend requests."
msgstr ""
"В ходе обычной работы клиент передаёт запросы и другие команды серверу, а "
"сервер возвращает результаты запросов и другие ответы. В некоторых случаях "
"(например, с <command>NOTIFY</command>) сервер передаёт клиенту сообщения по "
"своей инициативе, но по большей части эта фаза сеанса управляется запросами "
"клиента."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:66(para)
msgid ""
"Termination of the session is normally by frontend choice, but can be forced "
"by the backend in certain cases. In any case, when the backend closes the "
"connection, it will roll back any open (incomplete) transaction before "
"exiting."
msgstr ""
"Завершение сеанса обычно происходит по желанию клиента, но в некоторых "
"случаях и сервер может принудительно завершить сеанс. В любом случае, когда "
"сервер закрывает соединение, он предварительно откатывает любую открытую "
"(незавершённую) транзакцию."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:73(para)
msgid ""
"Within normal operation, SQL commands can be executed through either of two "
"sub-protocols. In the <quote>simple query</quote> protocol, the frontend "
"just sends a textual query string, which is parsed and immediately executed "
"by the backend. In the <quote>extended query</quote> protocol, processing of "
"queries is separated into multiple steps: parsing, binding of parameter "
"values, and execution. This offers flexibility and performance benefits, at "
"the cost of extra complexity."
msgstr ""
"В процессе обычной работы команды SQL могут выполняться по одному из двух "
"внутренних протоколов. По протоколу <quote>простых запросов</quote> клиент "
"посылает просто текстовую строку запроса, которую сервер сразу же разбирает "
"и выполняет. С протоколом <quote>расширенных запросов</quote> обработка "
"запросов разделяется на несколько этапов: разбор, привязывание значений "
"параметров и исполнение. Это даёт дополнительную гибкость и может увеличить "
"быстродействие ценой большей сложности."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:83(para)
msgid ""
"Normal operation has additional sub-protocols for special operations such as "
"<command>COPY</command>."
msgstr ""
"В обычном режиме также поддерживаются дополнительные внутренние протоколы "
"для специальных операций, например <command>COPY</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:89(title)
msgid "Messaging Overview"
msgstr "Обзор обмена сообщениями"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:91(para)
msgid ""
"All communication is through a stream of messages. The first byte of a "
"message identifies the message type, and the next four bytes specify the "
"length of the rest of the message (this length count includes itself, but "
"not the message-type byte). The remaining contents of the message are "
"determined by the message type. For historical reasons, the very first "
"message sent by the client (the startup message) has no initial message-type "
"byte."
msgstr ""
"Всё взаимодействие представляет собой поток сообщений. Первый байт сообщения "
"определяет тип сообщения, а следующие четыре байта задают длину остального "
"сообщения (эта длина включает размер самого поля длины, но не байт с типом "
"сообщения). Остальное содержимое сообщения определяется его типом. По "
"историческим причинам в самом первом сообщении, передаваемом клиентом, "
"(стартовом сообщении) первый байт с типом сообщения отсутствует."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:101(para)
msgid ""
"To avoid losing synchronization with the message stream, both servers and "
"clients typically read an entire message into a buffer (using the byte "
"count) before attempting to process its contents. This allows easy recovery "
"if an error is detected while processing the contents. In extreme situations "
"(such as not having enough memory to buffer the message), the receiver can "
"use the byte count to determine how much input to skip before it resumes "
"reading messages."
msgstr ""
"Чтобы не потерять синхронизацию в потоке сообщений, и серверы, и клиенты "
"обычно считывают всё сообщение в буфер (его размер определяется счётчиком "
"байт), прежде чем обрабатывать его содержимое. Это позволяет без труда "
"продолжить работу, если возникает ошибка при разборе сообщения. В "
"исключительных случаях (например, при нехватке памяти для помещения "
"сообщения в буфер), счётчик байт помогает получателю определить, сколько "
"поступающих байт нужно пропустить, прежде чем продолжать получать сообщения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:111(para)
msgid ""
"Conversely, both servers and clients must take care never to send an "
"incomplete message. This is commonly done by marshaling the entire message "
"in a buffer before beginning to send it. If a communications failure occurs "
"partway through sending or receiving a message, the only sensible response "
"is to abandon the connection, since there is little hope of recovering "
"message-boundary synchronization."
msgstr ""
"С другой стороны, и клиенты, и серверы, ни при каких условиях не должны "
"передавать неполные сообщения. Чтобы этого не допустить, обычно всё "
"сообщение сначала размещается в буфере, и только потом передаётся. Если в "
"процессе отправки или получения сообщения происходит сбой передачи, "
"единственным разумным вариантом продолжения будет прерывание соединения, так "
"как вероятность восстановления синхронизации по границам сообщений в этой "
"ситуации минимальна."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:122(title)
msgid "Extended Query Overview"
msgstr "Обзор расширенных запросов"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:124(para)
msgid ""
"In the extended-query protocol, execution of SQL commands is divided into "
"multiple steps. The state retained between steps is represented by two types "
"of objects: <firstterm>prepared statements</firstterm> and "
"<firstterm>portals</firstterm>. A prepared statement represents the result "
"of parsing and semantic analysis of a textual query string. A prepared "
"statement is not in itself ready to execute, because it might lack specific "
"values for <firstterm>parameters</firstterm>. A portal represents a ready-to-"
"execute or already-partially-executed statement, with any missing parameter "
"values filled in. (For <command>SELECT</command> statements, a portal is "
"equivalent to an open cursor, but we choose to use a different term since "
"cursors don't handle non-<command>SELECT</command> statements.)"
msgstr ""
"В протоколе расширенных запросов исполнение команд SQL разделяется на "
"несколько этапов. Состояние между этапами представляется объектами двух "
"типов: <firstterm>подготовленные операторы</firstterm> и <firstterm>порталы</"
"firstterm>. Подготовленный оператор представляет собой результат разбора и "
"семантического анализа текстовой строки запроса. Подготовленный оператор сам "
"по себе не готов для исполнения, так как он может не иметь конкретных "
"значений для <firstterm>параметров</firstterm>. Портал представляет собой "
"готовый к исполнению или уже частично выполненный оператор, в котором заданы "
"все недостающие значения параметров. (Для операторов <command>SELECT</"
"command> портал равнозначен открытому курсору, но мы выбрали другой термин, "
"так как курсоры неприменимы к операторам, отличным от <command>SELECT</"
"command>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:138(para)
msgid ""
"The overall execution cycle consists of a <firstterm>parse</firstterm> step, "
"which creates a prepared statement from a textual query string; a "
"<firstterm>bind</firstterm> step, which creates a portal given a prepared "
"statement and values for any needed parameters; and an <firstterm>execute</"
"firstterm> step that runs a portal's query. In the case of a query that "
"returns rows (<command>SELECT</command>, <command>SHOW</command>, etc), the "
"execute step can be told to fetch only a limited number of rows, so that "
"multiple execute steps might be needed to complete the operation."
msgstr ""
"Общий цикл выполнения состоит из этапа <firstterm>разбора</firstterm>, на "
"котором из текстовой строки запроса создаётся подготовленный оператор; этапа "
"<firstterm>привязки</firstterm>, на котором из подготовленного оператора и "
"значений для необходимых параметров создаётся портал; и этапа "
"<firstterm>выполнения</firstterm>, на котором исполняется запрос портала. В "
"случае запроса, возвращающего строки (<command>SELECT</command>, "
"<command>SHOW</command> и т. д.), можно указать, чтобы за один шаг "
"выполнения возвращалось только ограниченное число строк, так что для "
"завершения операции понадобятся несколько шагов выполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:150(para)
msgid ""
"The backend can keep track of multiple prepared statements and portals (but "
"note that these exist only within a session, and are never shared across "
"sessions). Existing prepared statements and portals are referenced by names "
"assigned when they were created. In addition, an <quote>unnamed</quote> "
"prepared statement and portal exist. Although these behave largely the same "
"as named objects, operations on them are optimized for the case of executing "
"a query only once and then discarding it, whereas operations on named "
"objects are optimized on the expectation of multiple uses."
msgstr ""
"Сервер может контролировать одновременно несколько подготовленных операторов "
"и порталов (но учтите, что они существуют только в рамках сеанса и никогда "
"не разделяются между сеансами). Обращаться к подготовленным операторам и "
"порталам можно по именам, которые назначаются им при создании. Кроме того, "
"существуют и <quote>безымянные</quote> подготовленные операторы и порталы. "
"Хотя они практически не отличаются от именованных объектов, операции с ними "
"оптимизированы для разового выполнения запроса с последующим освобождением "
"объекта, тогда как операции с именованными объектами оптимизируются в "
"расчёте на многоразовое использование."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:164(title)
msgid "Formats and Format Codes"
msgstr "Форматы и коды форматов"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:166(para)
msgid ""
"Data of a particular data type might be transmitted in any of several "
"different <firstterm>formats</firstterm>. As of <productname>PostgreSQL</"
"productname> 7.4 the only supported formats are <quote>text</quote> and "
"<quote>binary</quote>, but the protocol makes provision for future "
"extensions. The desired format for any value is specified by a "
"<firstterm>format code</firstterm>. Clients can specify a format code for "
"each transmitted parameter value and for each column of a query result. Text "
"has format code zero, binary has format code one, and all other format codes "
"are reserved for future definition."
msgstr ""
"Данные определённого типа могут передаваться в одном из нескольких различных "
"<firstterm>форматов</firstterm>. С версии 7.4 <productname>PostgreSQL</"
"productname> поддерживаются только текстовый (<quote>text</quote>) и "
"двоичный (<quote>binary</quote>) форматы, но в протоколе предусмотрены "
"возможности для расширения в будущем. Ожидаемый формат для любого значения "
"задаётся <firstterm>кодом формата</firstterm>. Клиенты могут указывать код "
"формата для каждого передаваемого значения параметра и для каждого столбца "
"результата запроса. Текстовый формат имеет код ноль, двоичный — код один, а "
"другие коды оставлены для определения в будущем."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:178(para)
msgid ""
"The text representation of values is whatever strings are produced and "
"accepted by the input/output conversion functions for the particular data "
"type. In the transmitted representation, there is no trailing null "
"character; the frontend must add one to received values if it wants to "
"process them as C strings. (The text format does not allow embedded nulls, "
"by the way.)"
msgstr ""
"Текстовым представлением значений будут строки, которые выдаются и "
"принимаются функциями ввода/вывода определённого типа данных. В передаваемом "
"представлении завершающий нулевой символ отсутствует, клиент должен добавить "
"его сам, если хочет обрабатывать такое представление в виде строки C. "
"(Собственно, данные в текстовом формате не могут содержать нулевые символы.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:187(para)
msgid ""
"Binary representations for integers use network byte order (most significant "
"byte first). For other data types consult the documentation or source code "
"to learn about the binary representation. Keep in mind that binary "
"representations for complex data types might change across server versions; "
"the text format is usually the more portable choice."
msgstr ""
"В двоичном представлении целых чисел применяется сетевой порядок байт "
"(наиболее значащий байт первый). Какое именно двоичное представление имеют "
"другие типы данных, можно узнать в документации или исходном коде. Но "
"учтите, что двоичное представление сложных типов данных может меняться от "
"версии к версии сервера; с точки зрения портируемости обычно лучше текстовый "
"формат."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:198(title)
msgid "Message Flow"
msgstr "Поток сообщений"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:200(para)
msgid ""
"This section describes the message flow and the semantics of each message "
"type. (Details of the exact representation of each message appear in <xref "
"linkend=\"protocol-message-formats\"/>.) There are several different sub-"
"protocols depending on the state of the connection: start-up, query, "
"function call, <command>COPY</command>, and termination. There are also "
"special provisions for asynchronous operations (including notification "
"responses and command cancellation), which can occur at any time after the "
"start-up phase."
msgstr ""
"В этом разделе описывается поток сообщений и семантика каждого типа "
"сообщений. (Подробнее точное представление каждого сообщения описывается в "
"<xref remap=\"6\" linkend=\"protocol-message-formats\"/>.) В зависимости от "
"состояния соединения выделяются несколько различных подразделов протокола: "
"запуск, запрос, вызов функции, копирование (<command>COPY</command>) и "
"завершение. Есть также специальные средства для асинхронных операций (в "
"частности, для уведомлений и отмены команд), которые могут выполняться в "
"любой момент после этапа запуска."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:213(title)
msgid "Start-up"
msgstr "Запуск"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:215(para)
msgid ""
"To begin a session, a frontend opens a connection to the server and sends a "
"startup message. This message includes the names of the user and of the "
"database the user wants to connect to; it also identifies the particular "
"protocol version to be used. (Optionally, the startup message can include "
"additional settings for run-time parameters.) The server then uses this "
"information and the contents of its configuration files (such as "
"<filename>pg_hba.conf</filename>) to determine whether the connection is "
"provisionally acceptable, and what additional authentication is required (if "
"any)."
msgstr ""
"Чтобы начать сеанс, клиент открывает подключение к серверу и передаёт "
"стартовое сообщение. В этом сообщении содержатся имена пользователя и базы "
"данных, к которой пользователь хочет подключиться; в нём также определяется, "
"какая именно версия протокола будет использоваться. (Стартовое сообщение "
"также может содержать дополнительные значения для параметров времени "
"выполнения.) Проанализировав эту информацию и содержимое своих файлов "
"конфигурации (в частности, <filename>pg_hba.conf</filename>), сервер "
"определяет, можно ли предварительно разрешить это подключение, и какая "
"дополнительная проверка подлинности требуется."

#. +> REL_10
#: protocol.xml:228(para)
msgid ""
"The server then sends an appropriate authentication request message, to "
"which the frontend must reply with an appropriate authentication response "
"message (such as a password). For all authentication methods except GSSAPI, "
"SSPI and SASL, there is at most one request and one response. In some "
"methods, no response at all is needed from the frontend, and so no "
"authentication request occurs. For GSSAPI, SSPI and SASL, multiple exchanges "
"of packets may be needed to complete the authentication."
msgstr ""
"Затем сервер отправляет соответствующее сообщение с запросом аутентификации, "
"на которое клиент должен ответить сообщением, подтверждающим его подлинность "
"(например, по паролю). Для всех методов аутентификации, за исключением "
"GSSAPI, SSPI и SASL, может быть максимум один запрос и один ответ. Для "
"некоторых методов ответ клиента вообще не требуется, так что запрос "
"аутентификации также не передаётся. Методы GSSAPI, SSPI и SASL для "
"прохождения проверки подлинности могут потребовать выполнить серию обменов "
"пакетами."

#. +> REL9_6_3 REL9_6
#: protocol.xml:228(para)
msgid ""
"The server then sends an appropriate authentication request message, to "
"which the frontend must reply with an appropriate authentication response "
"message (such as a password). For all authentication methods except GSSAPI "
"and SSPI, there is at most one request and one response. In some methods, no "
"response at all is needed from the frontend, and so no authentication "
"request occurs. For GSSAPI and SSPI, multiple exchanges of packets may be "
"needed to complete the authentication."
msgstr ""
"Затем сервер отправляет соответствующее сообщение с запросом аутентификации, "
"на которое клиент должен ответить сообщением, подтверждающим его подлинность "
"(например, по паролю). Для всех методов аутентификации, за исключением "
"GSSAPI и SSPI, может быть максимум один запрос и один ответ. Для некоторых "
"методов ответ клиента вообще не требуется, так что запрос аутентификации "
"также не передаётся. Методы GSSAPI и SSPI для прохождения проверки "
"подлинности могут потребовать выполнить серию обменов пакетами."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:239(para)
msgid ""
"The authentication cycle ends with the server either rejecting the "
"connection attempt (ErrorResponse), or sending AuthenticationOk."
msgstr ""
"Цикл аутентификации заканчивает сервер, либо запрещая соединение "
"(ErrorResponse), либо принимая его (отправляя AuthenticationOk)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:249(term) protocol.xml:477(term) protocol.xml:591(term)
#: protocol.xml:943(term)
msgid "ErrorResponse"
msgstr "ErrorResponse (Ошибочный ответ)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:251(para)
msgid ""
"The connection attempt has been rejected. The server then immediately closes "
"the connection."
msgstr ""
"Попытка соединения была отвергнута. Сразу после этого сервер закрывает "
"соединение."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:259(term)
msgid "AuthenticationOk"
msgstr "AuthenticationOk (Аутентификация пройдена)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:261(para)
msgid "The authentication exchange is successfully completed."
msgstr "Обмен сообщениями для проверки подлинности завершён успешно."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:268(term)
msgid "AuthenticationKerberosV5"
msgstr "AuthenticationKerberosV5 (Аутентификация Kerberos V5)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:270(para)
msgid ""
"The frontend must now take part in a Kerberos V5 authentication dialog (not "
"described here, part of the Kerberos specification) with the server. If this "
"is successful, the server responds with an AuthenticationOk, otherwise it "
"responds with an ErrorResponse. This is no longer supported."
msgstr ""
"Клиент должен теперь принять участие в диалоге аутентификации по протоколу "
"Kerberos V5 (здесь его детали не описывается, так как они относятся к "
"спецификации Kerberos) с сервером. Если этот диалог завершается успешно, "
"сервер отвечает AuthenticationOk, иначе — ErrorResponse. Этот вариант "
"аутентификации больше не поддерживается."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:282(term)
msgid "AuthenticationCleartextPassword"
msgstr "AuthenticationCleartextPassword (Аутентификация с открытым паролем)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:284(para)
msgid ""
"The frontend must now send a PasswordMessage containing the password in "
"clear-text form. If this is the correct password, the server responds with "
"an AuthenticationOk, otherwise it responds with an ErrorResponse."
msgstr ""
"Клиент должен передать в ответ сообщение PasswordMessage, содержащее пароль "
"в открытом виде. Если пароль правильный, сервер отвечает ему "
"AuthenticationOk, иначе — ErrorResponse."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:294(term)
msgid "AuthenticationMD5Password"
msgstr "AuthenticationMD5Password (Аутентификация с паролем MD5)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:296(para)
msgid ""
"The frontend must now send a PasswordMessage containing the password (with "
"user name) encrypted via MD5, then encrypted again using the 4-byte random "
"salt specified in the AuthenticationMD5Password message. If this is the "
"correct password, the server responds with an AuthenticationOk, otherwise it "
"responds with an ErrorResponse. The actual PasswordMessage can be computed "
"in SQL as <literal>concat('md5', md5(concat(md5(concat(password, username)), "
"random-salt)))</literal>. (Keep in mind the <function>md5()</function> "
"function returns its result as a hex string.)"
msgstr ""
"Клиент должен передать в ответ сообщение PasswordMessage с результатом "
"преобразования пароля (и имени пользователя) в хеш MD5 с последующим "
"хешированием с четырёхбайтовым случайным значением соли, переданным в "
"сообщении AuthenticationMD5Password. Если пароль правильный, сервер отвечает "
"AuthenticationOk, иначе — ErrorResponse. Содержимое сообщения "
"PasswordMessage можно вычислить в SQL как <literal>concat('md5', "
"md5(concat(md5(concat(password, username)), random-salt)))</literal>. "
"(Учтите, что функция <function>md5()</function> возвращает результат в виде "
"шестнадцатеричной строки.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:312(term)
msgid "AuthenticationSCMCredential"
msgstr "AuthenticationSCMCredential (Аутентификация по учётным данным SCM)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:314(para)
msgid ""
"This response is only possible for local Unix-domain connections on "
"platforms that support SCM credential messages. The frontend must issue an "
"SCM credential message and then send a single data byte. (The contents of "
"the data byte are uninteresting; it's only used to ensure that the server "
"waits long enough to receive the credential message.) If the credential is "
"acceptable, the server responds with an AuthenticationOk, otherwise it "
"responds with an ErrorResponse. (This message type is only issued by pre-9.1 "
"servers. It may eventually be removed from the protocol specification.)"
msgstr ""
"Этот ответ возможен только для локальных подключений через доменные сокеты "
"Unix на платформах, поддерживающих сообщения с учётными данными SCM. Клиент "
"должен выдать сообщение с учётными данными SCM и дополнительно отправить "
"один байт данных. (Содержимое этого байта не представляет интереса; его "
"нужно передавать, только чтобы сервер дожидался сообщения с учётными "
"данными.) Если сервер принимает учётные данные, он отвечает "
"AuthenticationOk, иначе — ErrorResponse. (Этот тип сообщений выдают только "
"серверы версии до 9.1. В конце концов он может быть исключён из спецификации "
"протокола.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:330(term)
msgid "AuthenticationGSS"
msgstr "AuthenticationGSS (Аутентификация GSS)"

#. +> REL_10
#: protocol.xml:332(para)
msgid ""
"The frontend must now initiate a GSSAPI negotiation. The frontend will send "
"a GSSResponse message with the first part of the GSSAPI data stream in "
"response to this. If further messages are needed, the server will respond "
"with AuthenticationGSSContinue."
msgstr ""
"Клиент должен начать согласование GSSAPI. В ответ на это сообщение клиент "
"отправляет GSSResponse с первой частью потока данных GSSAPI. Если "
"потребуются дополнительные сообщения, сервер передаст в ответ "
"AuthenticationGSSContinue."

#. +> REL9_6_3 REL9_6
#: protocol.xml:332(para)
msgid ""
"The frontend must now initiate a GSSAPI negotiation. The frontend will send "
"a PasswordMessage with the first part of the GSSAPI data stream in response "
"to this. If further messages are needed, the server will respond with "
"AuthenticationGSSContinue."
msgstr ""
"Клиент должен начать согласование GSSAPI. В ответ на это сообщение клиент "
"отправляет PasswordMessage с первой частью потока данных GSSAPI. Если "
"потребуются дополнительные сообщения, сервер передаст в ответ "
"AuthenticationGSSContinue."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:342(term)
msgid "AuthenticationSSPI"
msgstr "AuthenticationSSPI (Аутентификация SSPI)"

#. +> REL_10
#: protocol.xml:344(para)
msgid ""
"The frontend must now initiate a SSPI negotiation. The frontend will send a "
"GSSResponse with the first part of the SSPI data stream in response to this. "
"If further messages are needed, the server will respond with "
"AuthenticationGSSContinue."
msgstr ""
"Клиент должен начать согласование SSPI. В ответ на это сообщение клиент "
"отправляет GSSResponse с первой частью потока данных SSPI. Если потребуются "
"дополнительные сообщения, сервер передаст в ответ AuthenticationGSSContinue."

#. +> REL9_6_3 REL9_6
#: protocol.xml:344(para)
msgid ""
"The frontend must now initiate a SSPI negotiation. The frontend will send a "
"PasswordMessage with the first part of the SSPI data stream in response to "
"this. If further messages are needed, the server will respond with "
"AuthenticationGSSContinue."
msgstr ""
"Клиент должен начать согласование SSPI. В ответ на это сообщение клиент "
"отправляет PasswordMessage с первой частью потока данных SSPI. Если "
"потребуются дополнительные сообщения, сервер передаст в ответ "
"AuthenticationGSSContinue."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:354(term)
msgid "AuthenticationGSSContinue"
msgstr "AuthenticationGSSContinue (Продолжение аутентификации GSS)"

#. +> REL_10
#: protocol.xml:356(para)
msgid ""
"This message contains the response data from the previous step of GSSAPI or "
"SSPI negotiation (AuthenticationGSS, AuthenticationSSPI or a previous "
"AuthenticationGSSContinue). If the GSSAPI or SSPI data in this message "
"indicates more data is needed to complete the authentication, the frontend "
"must send that data as another GSSResponse message. If GSSAPI or SSPI "
"authentication is completed by this message, the server will next send "
"AuthenticationOk to indicate successful authentication or ErrorResponse to "
"indicate failure."
msgstr ""
"Это сообщение содержит данные ответа на предыдущий шаг согласования GSSAPI "
"или SSPI (AuthenticationGSS, AuthenticationSSPI или предыдущего "
"AuthenticationGSSContinue). Если в структуре GSSAPI или SSPI в этом "
"сообщении указывается, что для завершения аутентификации требуются "
"дополнительные данные, клиент должен передать их в очередном сообщении "
"GSSResponse. Если этим сообщением завершается проверка подлинности GSSAPI "
"или SSPI, сервер затем передаёт AuthenticationOk, сообщая об успешной "
"проверке подлинности, либо ErrorResponse, сообщая об ошибке."

#. +> REL9_6_3 REL9_6
#: protocol.xml:356(para)
msgid ""
"This message contains the response data from the previous step of GSSAPI or "
"SSPI negotiation (AuthenticationGSS, AuthenticationSSPI or a previous "
"AuthenticationGSSContinue). If the GSSAPI or SSPI data in this message "
"indicates more data is needed to complete the authentication, the frontend "
"must send that data as another PasswordMessage. If GSSAPI or SSPI "
"authentication is completed by this message, the server will next send "
"AuthenticationOk to indicate successful authentication or ErrorResponse to "
"indicate failure."
msgstr ""
"Это сообщение содержит данные ответа на предыдущий шаг согласования GSSAPI "
"или SSPI (AuthenticationGSS, AuthenticationSSPI или предыдущего "
"AuthenticationGSSContinue). Если в структуре GSSAPI или SSPI в этом "
"сообщении указывается, что для завершения аутентификации требуются "
"дополнительные данные, клиент должен передать их в очередном сообщении "
"PasswordMessage. Если этим сообщением завершается проверка подлинности "
"GSSAPI или SSPI, сервер затем передаёт AuthenticationOk, сообщая об успешной "
"проверке подлинности, либо ErrorResponse, сообщая об ошибке."

#. +> REL_10
#: protocol.xml:371(term)
msgid "AuthenticationSASL"
msgstr "AuthenticationSASL (Аутентификация SASL)"

#. +> REL_10
#: protocol.xml:373(para)
msgid ""
"The frontend must now initiate a SASL negotiation, using one of the SASL "
"mechanisms listed in the message. The frontend will send a "
"SASLInitialResponse with the name of the selected mechanism, and the first "
"part of the SASL data stream in response to this. If further messages are "
"needed, the server will respond with AuthenticationSASLContinue. See <xref "
"linkend=\"sasl-authentication\"/> for details."
msgstr ""
"Клиент должен начать согласование SASL, используя один из механизмов SASL, "
"перечисленных в сообщении. В ответ на это сообщение клиент отправляет "
"SASLInitialResponse с именем выбранного механизма и первой частью потока "
"данных SASL. Если потребуются дополнительные сообщения, сервер передаст в "
"ответ AuthenticationSASLContinue. За подробностями обратитесь к <xref remap="
"\"3\" linkend=\"sasl-authentication\"/>."

#. +> REL_10
#: protocol.xml:386(term)
msgid "AuthenticationSASLContinue"
msgstr "AuthenticationSASLContinue (Продолжение аутентификации SASL)"

#. +> REL_10
#: protocol.xml:388(para)
msgid ""
"This message contains challenge data from the previous step of SASL "
"negotiation (AuthenticationSASL, or a previous AuthenticationSASLContinue). "
"The frontend must respond with a SASLResponse message."
msgstr ""
"Это сообщение содержит данные вызова с предыдущего шага согласования SASL "
"(AuthenticationSASL или предыдущего AuthenticationSASLContinue). Клиент "
"должен передать в ответ сообщение SASLResponse."

#. +> REL_10
#: protocol.xml:398(term)
msgid "AuthenticationSASLFinal"
msgstr "AuthenticationSASLFinal (Окончание аутентификации SASL)"

#. +> REL_10
#: protocol.xml:400(para)
msgid ""
"SASL authentication has completed with additional mechanism-specific data "
"for the client. The server will next send AuthenticationOk to indicate "
"successful authentication, or an ErrorResponse to indicate failure. This "
"message is sent only if the SASL mechanism specifies additional data to be "
"sent from server to client at completion."
msgstr ""
"Аутентификация SASL завершена с дополнительными данными для клиента, "
"специфичными для механизма. Затем сервер передаст сообщение "
"AuthenticationOk, говорящее об успешной аутентификации, или ErrorResponse, "
"говорящее об ошибке. Данное сообщение передаётся, только если механизм SASL "
"должен в завершение передать с сервера клиенту дополнительные специфичные "
"данные."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:244(para)
msgid ""
"The possible messages from the server in this phase are: <placeholder-1/>"
msgstr ""
"Сервер может передавать в этой фазе следующие сообщения: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:413(para)
msgid ""
"If the frontend does not support the authentication method requested by the "
"server, then it should immediately close the connection."
msgstr ""
"Если клиент не поддерживает метод проверки подлинности, запрошенный "
"сервером, он должен немедленно закрыть соединение."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:419(para)
msgid ""
"After having received AuthenticationOk, the frontend must wait for further "
"messages from the server. In this phase a backend process is being started, "
"and the frontend is just an interested bystander. It is still possible for "
"the startup attempt to fail (ErrorResponse), but in the normal case the "
"backend will send some ParameterStatus messages, BackendKeyData, and finally "
"ReadyForQuery."
msgstr ""
"Получив сообщение AuthenticationOk, клиент должен ждать дальнейших сообщений "
"от сервера. В этой фазе запускается обслуживающий процесс, а клиент "
"представляет собой просто заинтересованного наблюдателя. Ошибка запуска "
"может быть неудачной (и клиент получит ErrorResponse), но в обычной ситуации "
"обслуживающий процесс передаёт несколько сообщений ParameterStatus, "
"BackendKeyData и, наконец, ReadyForQuery."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:428(para)
msgid ""
"During this phase the backend will attempt to apply any additional run-time "
"parameter settings that were given in the startup message. If successful, "
"these values become session defaults. An error causes ErrorResponse and exit."
msgstr ""
"В ходе этой фазы обслуживающий процесс попытается применить все параметры "
"времени выполнения, полученные в стартовом сообщении. Если это удастся, эти "
"значения становятся сеансовыми значениями по умолчанию. При ошибке он "
"передаёт ErrorResponse и завершается."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:440(term)
msgid "BackendKeyData"
msgstr "BackendKeyData (Данные ключа сервера)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:442(para)
msgid ""
"This message provides secret-key data that the frontend must save if it "
"wants to be able to issue cancel requests later. The frontend should not "
"respond to this message, but should continue listening for a ReadyForQuery "
"message."
msgstr ""
"В этом сообщении передаётся секретный ключ, который клиент должен сохранить, "
"чтобы впоследствии иметь возможность выполнять запросы. Клиент не должен "
"отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:452(term)
msgid "ParameterStatus"
msgstr "ParameterStatus (Состояние параметров)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:454(para)
msgid ""
"This message informs the frontend about the current (initial) setting of "
"backend parameters, such as <xref linkend=\"guc-client-encoding\"/> or <xref "
"linkend=\"guc-datestyle\"/>. The frontend can ignore this message, or record "
"the settings for its future use; see <xref linkend=\"protocol-async\"/> for "
"more details. The frontend should not respond to this message, but should "
"continue listening for a ReadyForQuery message."
msgstr ""
"Это сообщение говорит клиенту о текущих (начальных) значениях параметров "
"обслуживающего процесса, например, <xref linkend=\"guc-client-encoding\"/> "
"или <xref linkend=\"guc-datestyle\"/>. Клиент может проигнорировать это "
"сообщение или сохранить значения для дальнейшего использования; за "
"дополнительными подробностями обратитесь к <xref remap=\"3\" linkend="
"\"protocol-async\"/>. Клиент не должен отвечать на это сообщение, он должен "
"дожидаться сообщения ReadyForQuery."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:468(term) protocol.xml:600(term) protocol.xml:964(term)
msgid "ReadyForQuery"
msgstr "ReadyForQuery (Готов к запросам)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:470(para)
msgid "Start-up is completed. The frontend can now issue commands."
msgstr "Запуск завершён. Теперь клиент может выполнять команды."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:479(para)
msgid "Start-up failed. The connection is closed after sending this message."
msgstr ""
"Запуск не удался. Соединение закрывается после передачи этого сообщения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:487(term) protocol.xml:614(term) protocol.xml:975(term)
msgid "NoticeResponse"
msgstr "NoticeResponse (Ответ с замечанием)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:489(para)
msgid ""
"A warning message has been issued. The frontend should display the message "
"but continue listening for ReadyForQuery or ErrorResponse."
msgstr ""
"Выдаётся предупреждающее сообщение. Клиент должен вывести это сообщение, но "
"продолжать ожидать сообщения ReadyForQuery или ErrorResponse."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:435(para)
msgid ""
"The possible messages from the backend in this phase are: <placeholder-1/>"
msgstr ""
"Обслуживающий процесс может передавать в этой фазе следующие сообщения: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:499(para)
msgid ""
"The ReadyForQuery message is the same one that the backend will issue after "
"each command cycle. Depending on the coding needs of the frontend, it is "
"reasonable to consider ReadyForQuery as starting a command cycle, or to "
"consider ReadyForQuery as ending the start-up phase and each subsequent "
"command cycle."
msgstr ""
"Сообщение ReadyForQuery в данной фазе ничем не отличается от сообщений, "
"который передаёт сервер после каждого цикла команд. В зависимости от условий "
"реализации клиента, можно воспринимать сообщение ReadyForQuery как "
"начинающее цикл команд, либо как завершающее фазу запуска и каждый "
"последующий цикл команд."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:509(title)
msgid "Simple Query"
msgstr "Простой запрос"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:511(para)
msgid ""
"A simple query cycle is initiated by the frontend sending a Query message to "
"the backend. The message includes an SQL command (or commands) expressed as "
"a text string. The backend then sends one or more response messages "
"depending on the contents of the query command string, and finally a "
"ReadyForQuery response message. ReadyForQuery informs the frontend that it "
"can safely send a new command. (It is not actually necessary for the "
"frontend to wait for ReadyForQuery before issuing another command, but the "
"frontend must then take responsibility for figuring out what happens if the "
"earlier command fails and already-issued later commands succeed.)"
msgstr ""
"Цикл простого запроса начинает клиент, передавая серверу сообщение Query. "
"Это сообщение включает команду (или команды) SQL, выраженную в виде "
"текстовой строки. В ответ сервер передаёт одно или несколько сообщений, в "
"зависимости от строки запроса, и завершает цикл сообщением ReadyForQuery. "
"ReadyForQuery говорит клиенту, что он может безопасно передавать новую "
"команду. (На самом деле клиент может передать следующую команду, не "
"дожидаясь ReadyForQuery, но тогда он сам должен разобраться в ситуации, "
"когда первая команда завершается ошибкой, а последующая выполняется успешно.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:530(term)
msgid "CommandComplete"
msgstr "CommandComplete (Команда завершена)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:532(para)
msgid "An SQL command completed normally."
msgstr "Команда SQL выполнена нормально."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:539(term)
msgid "CopyInResponse"
msgstr "CopyInResponse (Ответ входящего копирования)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:541(para)
msgid ""
"The backend is ready to copy data from the frontend to a table; see <xref "
"linkend=\"protocol-copy\"/>."
msgstr ""
"Сервер готов копировать данные, получаемые от клиента, в таблицу; см. <xref "
"remap=\"4\" linkend=\"protocol-copy\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:549(term)
msgid "CopyOutResponse"
msgstr "CopyOutResponse (Ответ исходящего копирования)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:551(para)
msgid ""
"The backend is ready to copy data from a table to the frontend; see <xref "
"linkend=\"protocol-copy\"/>."
msgstr ""
"Сервер готов копировать данные из таблицы клиенту; см. <xref remap=\"4\" "
"linkend=\"protocol-copy\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:559(term)
msgid "RowDescription"
msgstr "RowDescription (Описание строк)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:561(para)
msgid ""
"Indicates that rows are about to be returned in response to a "
"<command>SELECT</command>, <command>FETCH</command>, etc query. The contents "
"of this message describe the column layout of the rows. This will be "
"followed by a DataRow message for each row being returned to the frontend."
msgstr ""
"Показывает, что в ответ на запрос <command>SELECT</command>, <command>FETCH</"
"command> и т. п. будут возвращены строки. В содержимом этого сообщения "
"описывается структура столбцов этих строк. За ним для каждой строки, "
"возвращаемой клиенту, следует сообщение DataRow."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:572(term)
msgid "DataRow"
msgstr "DataRow (Строка данных)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:574(para)
msgid ""
"One of the set of rows returned by a <command>SELECT</command>, "
"<command>FETCH</command>, etc query."
msgstr ""
"Одна строка из набора, возвращаемого запросом <command>SELECT</command>, "
"<command>FETCH</command> и т. п."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:582(term)
msgid "EmptyQueryResponse"
msgstr "EmptyQueryResponse (Ответ на пустой запрос)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:584(para)
msgid "An empty query string was recognized."
msgstr "Была принята пустая строка запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:593(para) protocol.xml:945(para)
msgid "An error has occurred."
msgstr "Произошла ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:602(para)
msgid ""
"Processing of the query string is complete. A separate message is sent to "
"indicate this because the query string might contain multiple SQL commands. "
"(CommandComplete marks the end of processing one SQL command, not the whole "
"string.) ReadyForQuery will always be sent, whether processing terminates "
"successfully or with an error."
msgstr ""
"Обработка строки запроса завершена. Чтобы отметить это, отправляется "
"отдельное сообщение, так как строка запроса может содержать несколько команд "
"SQL. (Сообщение CommandComplete говорит о завершении обработки одной команды "
"SQL, а не всей строки.) ReadyForQuery передаётся всегда, и при успешном "
"завершении обработки, и при ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:616(para)
msgid ""
"A warning message has been issued in relation to the query. Notices are in "
"addition to other responses, i.e., the backend will continue processing the "
"command."
msgstr ""
"Выдаётся предупреждение, связанное с запросом. Эти замечания дополняют "
"другие ответы, то есть сервер, выдавая их, продолжает обрабатывать команду."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:525(para) protocol.xml:938(para)
msgid "The possible response messages from the backend are: <placeholder-1/>"
msgstr ""
"Сервер может передавать в этой фазе следующие ответные сообщения: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:627(para)
msgid ""
"The response to a <command>SELECT</command> query (or other queries that "
"return row sets, such as <command>EXPLAIN</command> or <command>SHOW</"
"command>) normally consists of RowDescription, zero or more DataRow "
"messages, and then CommandComplete. <command>COPY</command> to or from the "
"frontend invokes special protocol as described in <xref linkend=\"protocol-"
"copy\"/>. All other query types normally produce only a CommandComplete "
"message."
msgstr ""
"Ответ на запрос <command>SELECT</command> (или другие запросы, возвращающие "
"наборы строк, такие как <command>EXPLAIN</command> и <command>SHOW</"
"command>) обычно состоит из RowDescription, нуля или нескольких сообщений "
"DataRow, и завершающего CommandComplete. Для команды <command>COPY</command> "
"с вводом или выводом данных через клиента, применяется специальный протокол, "
"описанный в <xref remap=\"6\" linkend=\"protocol-copy\"/>. Со всеми другими "
"типами запросами обычно выдаётся только сообщение CommandComplete."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:638(para)
msgid ""
"Since a query string could contain several queries (separated by "
"semicolons), there might be several such response sequences before the "
"backend finishes processing the query string. ReadyForQuery is issued when "
"the entire string has been processed and the backend is ready to accept a "
"new query string."
msgstr ""
"Так как строка запроса может содержать несколько запросов (разделённых "
"точкой с запятой), до завершения обработки всей строки сервер может передать "
"несколько серий таких ответов. Когда сервер завершает обработку всей строки "
"и готов принять следующую строку запроса, он выдаёт сообщение ReadyForQuery."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:646(para)
msgid ""
"If a completely empty (no contents other than whitespace) query string is "
"received, the response is EmptyQueryResponse followed by ReadyForQuery."
msgstr ""
"Если получена полностью пустая строка запроса (не содержащая ничего, кроме "
"пробельных символов), ответом будет EmptyQueryResponse с последующим "
"ReadyForQuery."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:651(para)
msgid ""
"In the event of an error, ErrorResponse is issued followed by ReadyForQuery. "
"All further processing of the query string is aborted by ErrorResponse (even "
"if more queries remained in it). Note that this might occur partway through "
"the sequence of messages generated by an individual query."
msgstr ""
"В случае ошибки выдаётся ErrorResponse с последующим ReadyForQuery. "
"Сообщение ErrorResponse прерывает дальнейшую обработку строки запроса (даже "
"если в ней остались другие запросы). Заметьте, что оно может быть выдано и в "
"середине последовательности сообщений, выдаваемых в ответ на отдельный "
"запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:659(para)
msgid ""
"In simple Query mode, the format of retrieved values is always text, except "
"when the given command is a <command>FETCH</command> from a cursor declared "
"with the <literal>BINARY</literal> option. In that case, the retrieved "
"values are in binary format. The format codes given in the RowDescription "
"message tell which format is being used."
msgstr ""
"В режиме простых запросов получаемые значения всегда передаются в текстовом "
"формате, за исключением результатов команды <command>FETCH</command> для "
"курсора, объявленного с атрибутом <literal>BINARY</literal>. С такой "
"командой значения передаются в двоичном формате. Какой именно формат "
"используется, определяют коды формата, передаваемые в сообщении "
"RowDescription."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:667(para)
msgid ""
"A frontend must be prepared to accept ErrorResponse and NoticeResponse "
"messages whenever it is expecting any other type of message. See also <xref "
"linkend=\"protocol-async\"/> concerning messages that the backend might "
"generate due to outside events."
msgstr ""
"Клиент должен быть готов принять сообщения ErrorResponse и NoticeResponse, "
"ожидая любой другой тип сообщений. Также обратитесь к <xref remap=\"3\" "
"linkend=\"protocol-async\"/> за информацией о сообщениях, которые сервер "
"может выдавать в ответ на внешние события."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:674(para)
msgid ""
"Recommended practice is to code frontends in a state-machine style that will "
"accept any message type at any time that it could make sense, rather than "
"wiring in assumptions about the exact sequence of messages."
msgstr ""
"Код клиента рекомендуется реализовывать в виде машины состояний, которая в "
"любой момент будет принимать сообщения всех типов, имеющих смысл на данном "
"этапе, но не программировать жёстко обработку точной последовательности "
"сообщений."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:682(title)
msgid "Extended Query"
msgstr "Расширенный запрос"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:684(para)
msgid ""
"The extended query protocol breaks down the above-described simple query "
"protocol into multiple steps. The results of preparatory steps can be re-"
"used multiple times for improved efficiency. Furthermore, additional "
"features are available, such as the possibility of supplying data values as "
"separate parameters instead of having to insert them directly into a query "
"string."
msgstr ""
"Протокол расширенных запросов разбивает вышеописанный протокол простых "
"запросов на несколько шагов. Результаты подготовительных шагов можно "
"неоднократно использовать повторно для улучшения эффективности. Кроме того, "
"он открывает дополнительные возможности, в частности, возможность передавать "
"значения данных в отдельных параметрах вместо того, чтобы внедрять их "
"непосредственно в строку запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:693(para)
msgid ""
"In the extended protocol, the frontend first sends a Parse message, which "
"contains a textual query string, optionally some information about data "
"types of parameter placeholders, and the name of a destination prepared-"
"statement object (an empty string selects the unnamed prepared statement). "
"The response is either ParseComplete or ErrorResponse. Parameter data types "
"can be specified by OID; if not given, the parser attempts to infer the data "
"types in the same way as it would do for untyped literal string constants."
msgstr ""
"В расширенном протоколе клиент сначала передаёт сообщение Parse с текстовой "
"строкой запроса и, возможно, некоторыми сведениями о типах параметров и "
"именем целевого объекта подготовленного оператора (если имя пустое, "
"создаётся безымянный подготовленный оператор). Ответом на это сообщение "
"будет ParseComplete или ErrorResponse. Типы параметров указываются по OID; "
"при отсутствии явного указания анализатор запроса пытается определить типы "
"данных так же, как он делал бы для нетипизированных строковых констант."

#. +> REL_10
#: protocol.xml:706(para)
msgid ""
"A parameter data type can be left unspecified by setting it to zero, or by "
"making the array of parameter type OIDs shorter than the number of parameter "
"symbols (<literal>$</literal><replaceable>n</replaceable>) used in the query "
"string. Another special case is that a parameter's type can be specified as "
"<type>void</type> (that is, the OID of the <type>void</type> pseudo-type). "
"This is meant to allow parameter symbols to be used for function parameters "
"that are actually OUT parameters. Ordinarily there is no context in which a "
"<type>void</type> parameter could be used, but if such a parameter symbol "
"appears in a function's parameter list, it is effectively ignored. For "
"example, a function call such as <literal>foo($1,$2,$3,$4)</literal> could "
"match a function with two IN and two OUT arguments, if <literal>$3</literal> "
"and <literal>$4</literal> are specified as having type <type>void</type>."
msgstr ""
"Тип данных параметра можно оставить неопределённым, задав для него значение "
"ноль, либо сделав массив с OID типов параметров короче, чем набор символов "
"параметров (<literal>$</literal><replaceable>n</replaceable>), используемых "
"в строке запроса. Другой особый случай — передача типа параметра как "
"<type>void</type> (то есть передача OID псевдотипа <type>void</type>). Это "
"предусмотрено для того, чтобы символы параметров можно было использовать для "
"параметров функций, на самом деле представляющих собой параметры OUT. Обычно "
"параметр <type>void</type> нельзя использовать ни в каком контексте, но если "
"такой параметр фигурирует в списке параметров функции, он фактически "
"игнорируется. Например, вызову функции <literal>foo($1,$2,$3,$4)</literal> "
"может соответствовать функция с аргументами IN и двумя OUT, если аргументы "
"<literal>$3</literal> и <literal>$4</literal> объявлены как имеющие тип "
"<type>void</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:724(para)
msgid ""
"The query string contained in a Parse message cannot include more than one "
"SQL statement; else a syntax error is reported. This restriction does not "
"exist in the simple-query protocol, but it does exist in the extended "
"protocol, because allowing prepared statements or portals to contain "
"multiple commands would complicate the protocol unduly."
msgstr ""
"Строка запроса, содержащаяся в сообщении Parse, не может содержать больше "
"одного оператора SQL; иначе выдаётся синтаксическая ошибка. Это ограничение "
"отсутствует в протоколе простых запросов, но присутствует в расширенном "
"протоколе, так как добавление поддержки подготовленных операторов или "
"порталов, содержащих несколько команд, неоправданно усложнило бы протокол."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:734(para)
msgid ""
"If successfully created, a named prepared-statement object lasts till the "
"end of the current session, unless explicitly destroyed. An unnamed prepared "
"statement lasts only until the next Parse statement specifying the unnamed "
"statement as destination is issued. (Note that a simple Query message also "
"destroys the unnamed statement.) Named prepared statements must be "
"explicitly closed before they can be redefined by another Parse message, but "
"this is not required for the unnamed statement. Named prepared statements "
"can also be created and accessed at the SQL command level, using "
"<command>PREPARE</command> and <command>EXECUTE</command>."
msgstr ""
"В случае успешного создания именованный подготовленный оператор продолжает "
"существовать до завершения текущего сеанса, если только он не будет "
"уничтожен явно. Безымянный подготовленный оператор сохраняется только до "
"следующей команды Parse, в которой целевым является безымянный оператор. "
"(Заметьте, что сообщение простого запроса также уничтожает безымянный "
"оператор.) Именованные операторы должны явно закрываться, прежде чем их "
"можно будет переопределить другим сообщением Parse, но для безымянных "
"операторов это не требуется. Именованные подготовленные операторы также "
"можно создавать и вызывать на уровне команд SQL, используя команды "
"<command>PREPARE</command> и <command>EXECUTE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:746(para)
msgid ""
"Once a prepared statement exists, it can be readied for execution using a "
"Bind message. The Bind message gives the name of the source prepared "
"statement (empty string denotes the unnamed prepared statement), the name of "
"the destination portal (empty string denotes the unnamed portal), and the "
"values to use for any parameter placeholders present in the prepared "
"statement. The supplied parameter set must match those needed by the "
"prepared statement. (If you declared any <type>void</type> parameters in the "
"Parse message, pass NULL values for them in the Bind message.) Bind also "
"specifies the format to use for any data returned by the query; the format "
"can be specified overall, or per-column. The response is either BindComplete "
"or ErrorResponse."
msgstr ""
"Когда подготовленный оператор существует, его можно подготовить к выполнению "
"сообщением Bind. В сообщении Bind задаётся имя исходного подготовленного "
"оператора (пустая строка подразумевает безымянный подготовленный оператор), "
"имя целевого портала (пустая строка подразумевает безымянный портал) и "
"значения для любых шаблонов параметров, представленных в подготовленном "
"операторе. Набор передаваемых значений должен соответствовать набору "
"параметров, требующихся для подготовленного оператора. (Если вы объявили "
"параметры <type>void</type> в сообщении Parse, передайте для них значения "
"NULL в сообщении Bind.) Bind также принимает указание формата для данных, "
"возвращаемых в результате запроса; формат можно указать для всех данных, "
"либо для отдельных столбцов. Ответом на это сообщение будет BindComplete или "
"ErrorResponse."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:762(para)
msgid ""
"The choice between text and binary output is determined by the format codes "
"given in Bind, regardless of the SQL command involved. The <literal>BINARY</"
"literal> attribute in cursor declarations is irrelevant when using extended "
"query protocol."
msgstr ""
"Выбор между текстовым и двоичным форматом вывода определяется кодами "
"формата, передаваемыми в Bind, вне зависимости от команды SQL. При "
"использовании протокола расширенных запросов атрибут <literal>BINARY</"
"literal> в объявлении курсоров не имеет значения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:770(para)
msgid ""
"Query planning typically occurs when the Bind message is processed. If the "
"prepared statement has no parameters, or is executed repeatedly, the server "
"might save the created plan and re-use it during subsequent Bind messages "
"for the same prepared statement. However, it will do so only if it finds "
"that a generic plan can be created that is not much less efficient than a "
"plan that depends on the specific parameter values supplied. This happens "
"transparently so far as the protocol is concerned."
msgstr ""
"Планирование запроса обычно имеет место при обработке сообщения Bind. Если "
"подготовленный оператор не имеет параметров, либо он выполняется "
"многократно, сервер может сохранить созданный план и использовать его "
"повторно при последующих сообщениях Bind для того же подготовленного "
"оператора. Однако он будет делать это, только если решит, что можно получить "
"универсальный план, который не будет значительно неэффективнее планов, "
"зависящих от конкретных значений параметров. С точки зрения протокола это "
"происходит незаметно."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:780(para)
msgid ""
"If successfully created, a named portal object lasts till the end of the "
"current transaction, unless explicitly destroyed. An unnamed portal is "
"destroyed at the end of the transaction, or as soon as the next Bind "
"statement specifying the unnamed portal as destination is issued. (Note that "
"a simple Query message also destroys the unnamed portal.) Named portals must "
"be explicitly closed before they can be redefined by another Bind message, "
"but this is not required for the unnamed portal. Named portals can also be "
"created and accessed at the SQL command level, using <command>DECLARE "
"CURSOR</command> and <command>FETCH</command>."
msgstr ""
"В случае успешного создания объект именованного портала продолжает "
"существование до конца текущей транзакции, если только он не будет уничтожен "
"явно. Безымянный портал уничтожается в конце транзакции или при выполнении "
"следующей команды Bind, в которой в качестве целевого выбирается безымянный "
"портал. (Заметьте, что сообщение простого запроса также уничтожает "
"безымянный портал.) Именованные порталы должны явно закрываться, прежде чем "
"их можно будет явно переопределить другим сообщением Bind, но это не "
"требуется для безымянных порталов. Именованные порталы также можно создавать "
"и вызывать на уровне команд SQL, используя команды <command>DECLARE CURSOR</"
"command> и <command>FETCH</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:792(para)
msgid ""
"Once a portal exists, it can be executed using an Execute message. The "
"Execute message specifies the portal name (empty string denotes the unnamed "
"portal) and a maximum result-row count (zero meaning <quote>fetch all rows</"
"quote>). The result-row count is only meaningful for portals containing "
"commands that return row sets; in other cases the command is always executed "
"to completion, and the row count is ignored. The possible responses to "
"Execute are the same as those described above for queries issued via simple "
"query protocol, except that Execute doesn't cause ReadyForQuery or "
"RowDescription to be issued."
msgstr ""
"Когда портал существует, его можно запустить на выполнение сообщением "
"Execute. В сообщении Execute указывается имя портала (пустая строка "
"подразумевает безымянный портал) и максимальное число результирующих строк "
"(ноль означает <quote>выбрать все строки</quote>). Число результирующих "
"строк имеет значение только для порталов, которые содержат команды, "
"возвращающие наборы строк; в других случаях команда всегда выполняется до "
"завершения и число строк игнорируется. В ответ на Execute могут быть "
"получены те же сообщения, что описаны выше для запросов, выполняемых через "
"протокол простых запросов, за исключением того, что после Execute не "
"выдаются сообщения ReadyForQuery и RowDescription."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:806(para)
msgid ""
"If Execute terminates before completing the execution of a portal (due to "
"reaching a nonzero result-row count), it will send a PortalSuspended "
"message; the appearance of this message tells the frontend that another "
"Execute should be issued against the same portal to complete the operation. "
"The CommandComplete message indicating completion of the source SQL command "
"is not sent until the portal's execution is completed. Therefore, an Execute "
"phase is always terminated by the appearance of exactly one of these "
"messages: CommandComplete, EmptyQueryResponse (if the portal was created "
"from an empty query string), ErrorResponse, or PortalSuspended."
msgstr ""
"Если операция Execute оканчивается до завершения выполнения портала (из-за "
"достижения ненулевого ограничения на число строк), сервер отправляет "
"сообщение PortalSuspended; появление этого сообщения говорит клиенту о том, "
"что для завершения операции с данным порталом нужно выдать ещё одно "
"сообщение Execute. Сообщение CommandComplete, говорящее о завершении "
"исходной команды SQL, не передаётся до завершения выполнения портала. Таким "
"образом, фаза Execute всегда заканчивается при появлении одного из "
"сообщений: CommandComplete, EmptyQueryResponse (если портал был создан из "
"пустой строки запроса), ErrorResponse или PortalSuspended."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:819(para)
msgid ""
"At completion of each series of extended-query messages, the frontend should "
"issue a Sync message. This parameterless message causes the backend to close "
"the current transaction if it's not inside a <command>BEGIN</command>/"
"<command>COMMIT</command> transaction block (<quote>close</quote> meaning to "
"commit if no error, or roll back if error). Then a ReadyForQuery response is "
"issued. The purpose of Sync is to provide a resynchronization point for "
"error recovery. When an error is detected while processing any extended-"
"query message, the backend issues ErrorResponse, then reads and discards "
"messages until a Sync is reached, then issues ReadyForQuery and returns to "
"normal message processing. (But note that no skipping occurs if an error is "
"detected <emphasis>while</emphasis> processing Sync &mdash; this ensures "
"that there is one and only one ReadyForQuery sent for each Sync.)"
msgstr ""
"В конце каждой серии сообщений расширенных запросов клиент должен выдать "
"сообщение Sync. Получив это сообщение без параметров, сервер закрывает "
"текущую транзакцию, если команды выполняются не внутри блока транзакции "
"<command>BEGIN</command>/<command>COMMIT</command> (под <quote>закрытием</"
"quote> понимается фиксация при отсутствии ошибок или откат в противном "
"случае). Затем он выдаёт ответ ReadyForQuery. Целью сообщения Sync является "
"обозначение точки синхронизации для восстановления в случае ошибок. Если при "
"обработке сообщений расширенных запросов происходит ошибка, сервер выдаёт "
"ErrorResponse, затем считывает и пропускает сообщения до Sync, после чего "
"выдаёт ReadyForQuery и возвращается к обычной обработке сообщений. (Но "
"заметьте, что он не будет пропускать следующие сообщения, если ошибка "
"происходит <emphasis>в процессе</emphasis> обработки Sync &mdash; это "
"гарантирует, что для каждого Sync будет передаваться в точности одно "
"сообщение ReadyForQuery.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:836(para)
msgid ""
"Sync does not cause a transaction block opened with <command>BEGIN</command> "
"to be closed. It is possible to detect this situation since the "
"ReadyForQuery message includes transaction status information."
msgstr ""
"Сообщение Sync не приводит к закрытию блока транзакции, открытого командой "
"<command>BEGIN</command>. Выявить эту ситуацию можно, используя информацию о "
"состоянии транзакции, содержащуюся в сообщении ReadyForQuery."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:843(para)
msgid ""
"In addition to these fundamental, required operations, there are several "
"optional operations that can be used with extended-query protocol."
msgstr ""
"В дополнение к этим фундаментальным и обязательным операциям, протокол "
"расширенных запросов позволяет выполнить и несколько дополнительных операций."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:848(para)
msgid ""
"The Describe message (portal variant) specifies the name of an existing "
"portal (or an empty string for the unnamed portal). The response is a "
"RowDescription message describing the rows that will be returned by "
"executing the portal; or a NoData message if the portal does not contain a "
"query that will return rows; or ErrorResponse if there is no such portal."
msgstr ""
"В сообщении Describe (в вариации для портала) задаётся имя существующего "
"портала (пустая строка обозначает безымянный портал). В ответ передаётся "
"сообщение RowDescription, описывающее строки, которые будут возвращены при "
"выполнении портала; либо сообщение NoData, если портал не содержит запроса, "
"возвращающего строки; либо ErrorResponse, если такого портала нет."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:856(para)
msgid ""
"The Describe message (statement variant) specifies the name of an existing "
"prepared statement (or an empty string for the unnamed prepared statement). "
"The response is a ParameterDescription message describing the parameters "
"needed by the statement, followed by a RowDescription message describing the "
"rows that will be returned when the statement is eventually executed (or a "
"NoData message if the statement will not return rows). ErrorResponse is "
"issued if there is no such prepared statement. Note that since Bind has not "
"yet been issued, the formats to be used for returned columns are not yet "
"known to the backend; the format code fields in the RowDescription message "
"will be zeroes in this case."
msgstr ""
"В сообщении Describe (в вариации для оператора) задаётся имя существующего "
"подготовленного оператора (пустая строка обозначает безымянный "
"подготовленный оператор). В ответ передаётся сообщение ParameterDescription, "
"описывающее параметры, требующиеся для оператора, за которым следует "
"сообщение RowDescription, описывающее строки, которые будут возвращены, "
"когда оператор будет собственно выполнен (или сообщение NoData, если "
"оператор не возвратит строки). ErrorResponse выдаётся, если такой "
"подготовленный оператор отсутствует. Заметьте, что так как команда Bind не "
"выполнялась, сервер ещё не знает, в каком формате будут возвращаться "
"столбцы; в этом случае поля кодов формата в сообщении RowDescription будут "
"содержать нули."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:870(para)
msgid ""
"In most scenarios the frontend should issue one or the other variant of "
"Describe before issuing Execute, to ensure that it knows how to interpret "
"the results it will get back."
msgstr ""
"В большинстве случаев клиент должен выдать ту или иную вариацию Describe, "
"прежде чем выдавать Execute, чтобы понять, как интерпретировать результаты, "
"которые он получит."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:877(para)
msgid ""
"The Close message closes an existing prepared statement or portal and "
"releases resources. It is not an error to issue Close against a nonexistent "
"statement or portal name. The response is normally CloseComplete, but could "
"be ErrorResponse if some difficulty is encountered while releasing "
"resources. Note that closing a prepared statement implicitly closes any open "
"portals that were constructed from that statement."
msgstr ""
"Сообщение Close закрывает существующий подготовленный оператор или портал и "
"освобождает связанные ресурсы. При попытке выполнить Close для имени "
"несуществующего портала или оператора ошибки не будет. Ответ на это "
"сообщение обычно CloseComplete, но может быть и ErrorResponse, если при "
"освобождении ресурсов возникают проблемы. Заметьте, что при закрытии "
"подготовленного оператора неявно закрываются все открытые порталы, которые "
"были получены из этого оператора."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:887(para)
msgid ""
"The Flush message does not cause any specific output to be generated, but "
"forces the backend to deliver any data pending in its output buffers. A "
"Flush must be sent after any extended-query command except Sync, if the "
"frontend wishes to examine the results of that command before issuing more "
"commands. Without Flush, messages returned by the backend will be combined "
"into the minimum possible number of packets to minimize network overhead."
msgstr ""
"Сообщение Flush не приводит к генерации каких-либо данных, а указывает "
"серверу передать все данные, находящиеся в очереди в его буферах вывода. "
"Сообщение Flush клиент должен отправлять после любой команды расширенных "
"запросов, кроме Sync, если он желает проанализировать результаты этой "
"команды, прежде чем выдавать следующие команды. Без Flush сообщения, "
"возвращаемые сервером, будут объединяться вместе в минимальное количество "
"пакетов с целью уменьшения сетевого трафика."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:898(para)
msgid ""
"The simple Query message is approximately equivalent to the series Parse, "
"Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared "
"statement and portal objects and no parameters. One difference is that it "
"will accept multiple SQL statements in the query string, automatically "
"performing the bind/describe/execute sequence for each one in succession. "
"Another difference is that it will not return ParseComplete, BindComplete, "
"CloseComplete, or NoData messages."
msgstr ""
"Простое сообщение Query примерно равнозначно последовательности сообщений "
"Parse, Bind, Describe (для портала), Execute, Close, Sync, с использованием "
"объектов подготовленного оператора и портала без имён и без параметров. Одно "
"отличие состоит в том, что такое сообщение может содержать в строке запроса "
"несколько операторов SQL, для каждого из которых по очереди автоматически "
"выполняется последовательность Bind/Describe/Execute. Другое отличие состоит "
"в том, что в ответ на него не приходят сообщения ParseComplete, "
"BindComplete, CloseComplete или NoData."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:911(title)
msgid "Function Call"
msgstr "Вызов функций"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:913(para)
msgid ""
"The Function Call sub-protocol allows the client to request a direct call of "
"any function that exists in the database's <structname>pg_proc</structname> "
"system catalog. The client must have execute permission for the function."
msgstr ""
"Подраздел протокола &laquo;Вызов функций&raquo; позволяет клиенту запросить "
"непосредственный вызов любой функции, существующей в системном каталоге "
"<structname>pg_proc</structname>. При этом клиент должен иметь право на "
"выполнение этой функции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:921(para)
msgid ""
"The Function Call sub-protocol is a legacy feature that is probably best "
"avoided in new code. Similar results can be accomplished by setting up a "
"prepared statement that does <literal>SELECT function($1, ...)</literal>. "
"The Function Call cycle can then be replaced with Bind/Execute."
msgstr ""
"Этот подраздел протокола считается устаревшим и в новом коде использовать "
"его не следует. Примерно тот же результат можно получить, подготовив "
"оператор с командой <literal>SELECT function($1, ...)</literal>. При таком "
"подходе цикл вызова функции заменяется последовательностью Bind/Execute."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:929(para)
msgid ""
"A Function Call cycle is initiated by the frontend sending a FunctionCall "
"message to the backend. The backend then sends one or more response messages "
"depending on the results of the function call, and finally a ReadyForQuery "
"response message. ReadyForQuery informs the frontend that it can safely send "
"a new query or function call."
msgstr ""
"Цикл вызова функции начинает клиент, передавая серверу сообщение "
"FunctionCall. Сервер возвращает одно или несколько сообщений ответа, в "
"зависимости от результата вызова функции, и завершающее сообщение "
"ReadyForQuery. ReadyForQuery говорит клиенту, что он может свободно "
"передавать новый запрос или вызов функции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:952(term)
msgid "FunctionCallResponse"
msgstr "FunctionCallResponse (Ответ на вызов функции)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:954(para)
msgid ""
"The function call was completed and returned the result given in the "
"message. (Note that the Function Call protocol can only handle a single "
"scalar result, not a row type or set of results.)"
msgstr ""
"Вызов функции завершён и в этом сообщении передаётся её результат. "
"(Заметьте, что протокол вызова функций позволяет выдать только один "
"скалярный результат, но не кортеж или набор результатов.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:966(para)
msgid ""
"Processing of the function call is complete. ReadyForQuery will always be "
"sent, whether processing terminates successfully or with an error."
msgstr ""
"Обработка вызова функции завершена. В ответ всегда передаётся ReadyForQuery, "
"независимо от того, была ли функция выполнена успешно или с ошибкой."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:977(para)
msgid ""
"A warning message has been issued in relation to the function call. Notices "
"are in addition to other responses, i.e., the backend will continue "
"processing the command."
msgstr ""
"Выдаётся предупреждение, связанное с вызовом функции. Эти замечания "
"дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать "
"вызов."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:989(title)
msgid "COPY Operations"
msgstr "Операции COPY"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:991(para)
msgid ""
"The <command>COPY</command> command allows high-speed bulk data transfer to "
"or from the server. Copy-in and copy-out operations each switch the "
"connection into a distinct sub-protocol, which lasts until the operation is "
"completed."
msgstr ""
"Команда <command>COPY</command> позволяет обеспечить скоростную передачу "
"данных на сервер или с сервера. Операции входящего и исходящего копирования "
"переключают соединение в отдельные режимы протокола, которые завершаются "
"только в конце операции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:998(para)
msgid ""
"Copy-in mode (data transfer to the server) is initiated when the backend "
"executes a <command>COPY FROM STDIN</command> SQL statement. The backend "
"sends a CopyInResponse message to the frontend. The frontend should then "
"send zero or more CopyData messages, forming a stream of input data. (The "
"message boundaries are not required to have anything to do with row "
"boundaries, although that is often a reasonable choice.) The frontend can "
"terminate the copy-in mode by sending either a CopyDone message (allowing "
"successful termination) or a CopyFail message (which will cause the "
"<command>COPY</command> SQL statement to fail with an error). The backend "
"then reverts to the command-processing mode it was in before the "
"<command>COPY</command> started, which will be either simple or extended "
"query protocol. It will next send either CommandComplete (if successful) or "
"ErrorResponse (if not)."
msgstr ""
"Режим входящего копирования (передача данных на сервер) включается, когда "
"клиент выполняет SQL-оператор <command>COPY FROM STDIN</command>. Переходя в "
"этот режим, сервер передаёт клиенту сообщение CopyInResponse. После этого "
"клиент должен передать ноль или более сообщений CopyData, образующих поток "
"входных данных. (При этом границы сообщений не обязательно должны совпадать "
"с границами строк данных, хотя часто имеет смысл выровнять их.) Клиент может "
"завершить режим входящего копирования, передав либо сообщение CopyDone "
"(говорящее об успешном завершении), либо CopyFail (которое приведёт к "
"завершению SQL-оператора <command>COPY</command> с ошибкой). При этом сервер "
"вернётся в обычный режим обработки, в котором он находился до выполнения "
"команды <command>COPY</command> (это может быть протокол простых или "
"расширенных запросов). Затем он отправит сообщение CommandComplete (в случае "
"успешного завершения) или ErrorResponse (в противном случае)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1014(para)
msgid ""
"In the event of a backend-detected error during copy-in mode (including "
"receipt of a CopyFail message), the backend will issue an ErrorResponse "
"message. If the <command>COPY</command> command was issued via an extended-"
"query message, the backend will now discard frontend messages until a Sync "
"message is received, then it will issue ReadyForQuery and return to normal "
"processing. If the <command>COPY</command> command was issued in a simple "
"Query message, the rest of that message is discarded and ReadyForQuery is "
"issued. In either case, any subsequent CopyData, CopyDone, or CopyFail "
"messages issued by the frontend will simply be dropped."
msgstr ""
"В случае возникновения ошибки в режиме входящего копирования (включая "
"получение сообщения CopyFail), сервер выдаёт сообщение ErrorResponse. Если "
"команда <command>COPY</command> была получена в сообщении расширенного "
"запроса, сервер не будет обрабатывать последующие сообщения клиента, пока не "
"получит сообщение Sync, после которого он выдаст ReadyForQuery и вернётся в "
"обычный режим работы. Если команда <command>COPY</command> была получена в "
"сообщении простого запроса, остальная часть сообщения игнорируется и сразу "
"выдаётся ReadyForQuery. В любом случае все последующие сообщения CopyData, "
"CopyDone или CopyFail, поступающие от клиента, будут просто игнорироваться."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1026(para)
msgid ""
"The backend will ignore Flush and Sync messages received during copy-in "
"mode. Receipt of any other non-copy message type constitutes an error that "
"will abort the copy-in state as described above. (The exception for Flush "
"and Sync is for the convenience of client libraries that always send Flush "
"or Sync after an Execute message, without checking whether the command to be "
"executed is a <command>COPY FROM STDIN</command>.)"
msgstr ""
"В режиме входящего копирования сервер игнорирует поступающие сообщения Flush "
"и Sync. При поступлении сообщений любого другого типа, не связанного с "
"копированием, возникает ошибка, приводящая к прерыванию режима входящего "
"копирования, как описано выше. (Исключение для сообщений Flush и Sync "
"сделано для удобства клиентских библиотек, которые всегда передают Flush или "
"Sync после сообщения Execute, не проверяя, не запускается ли в нём команда "
"<command>COPY FROM STDIN</command>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1035(para)
msgid ""
"Copy-out mode (data transfer from the server) is initiated when the backend "
"executes a <command>COPY TO STDOUT</command> SQL statement. The backend "
"sends a CopyOutResponse message to the frontend, followed by zero or more "
"CopyData messages (always one per row), followed by CopyDone. The backend "
"then reverts to the command-processing mode it was in before the "
"<command>COPY</command> started, and sends CommandComplete. The frontend "
"cannot abort the transfer (except by closing the connection or issuing a "
"Cancel request), but it can discard unwanted CopyData and CopyDone messages."
msgstr ""
"Режим исходящего копирования (передача данных с сервера) включается, когда "
"клиент выполняет SQL-оператор <command>COPY TO STDOUT</command>. Переходя в "
"этот режим, сервер передаёт клиенту сообщение CopyOutResponse, за ним ноль "
"или более сообщений CopyData (всегда одно сообщение для каждой строки) и в "
"завершение CopyDone. Затем сервер возвращается в обычный режим обработки, в "
"котором он находился до выполнения команды <command>COPY</command>, и "
"передаёт CommandComplete. Клиент не может прервать передачу (кроме как "
"закрыв соединение или выдав запрос Cancel), но он может игнорировать "
"ненужные ему сообщения CopyData и CopyDone."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1047(para)
msgid ""
"In the event of a backend-detected error during copy-out mode, the backend "
"will issue an ErrorResponse message and revert to normal processing. The "
"frontend should treat receipt of ErrorResponse as terminating the copy-out "
"mode."
msgstr ""
"В случае обнаружения ошибки в режиме исходящего копирования, сервер выдаёт "
"сообщение ErrorResponse и возвращается к обычной обработке. Клиент должен "
"воспринимать поступление ErrorResponse как завершение режима исходящего "
"копирования."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1054(para)
msgid ""
"It is possible for NoticeResponse and ParameterStatus messages to be "
"interspersed between CopyData messages; frontends must handle these cases, "
"and should be prepared for other asynchronous message types as well (see "
"<xref linkend=\"protocol-async\"/>). Otherwise, any message type other than "
"CopyData or CopyDone may be treated as terminating copy-out mode."
msgstr ""
"Между сообщениями CopyData могут поступать сообщения NoticeResponse и "
"ParameterStatus; клиенты должны обрабатывать их и быть готовы принимать и "
"другие типы асинхронных сообщений (см. <xref remap=\"4\" linkend=\"protocol-"
"async\"/>). В остальном, сообщения любых типов, кроме CopyData и CopyDone, "
"могут восприниматься как завершающие режим исходящего копирования."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1062(para)
msgid ""
"There is another Copy-related mode called copy-both, which allows high-speed "
"bulk data transfer to <emphasis>and</emphasis> from the server. Copy-both "
"mode is initiated when a backend in walsender mode executes a "
"<command>START_REPLICATION</command> statement. The backend sends a "
"CopyBothResponse message to the frontend. Both the backend and the frontend "
"may then send CopyData messages until either end sends a CopyDone message. "
"After the client sends a CopyDone message, the connection goes from copy-"
"both mode to copy-out mode, and the client may not send any more CopyData "
"messages. Similarly, when the server sends a CopyDone message, the "
"connection goes into copy-in mode, and the server may not send any more "
"CopyData messages. After both sides have sent a CopyDone message, the copy "
"mode is terminated, and the backend reverts to the command-processing mode. "
"In the event of a backend-detected error during copy-both mode, the backend "
"will issue an ErrorResponse message, discard frontend messages until a Sync "
"message is received, and then issue ReadyForQuery and return to normal "
"processing. The frontend should treat receipt of ErrorResponse as "
"terminating the copy in both directions; no CopyDone should be sent in this "
"case. See <xref linkend=\"protocol-replication\"/> for more information on "
"the subprotocol transmitted over copy-both mode."
msgstr ""
"Есть ещё один режим копирования, называемый двусторонним копированием и "
"обеспечивающий высокоскоростную передачу данных на <emphasis>и</emphasis> с "
"сервера. Двустороннее копирование запускается, когда клиент в режиме "
"walsender выполняет оператор <command>START_REPLICATION</command>. В ответ "
"сервер передаёт клиенту сообщение CopyBothResponse. Затем и сервер, и клиент "
"могут передавать друг другу сообщения CopyData, пока кто-то из них не "
"завершит передачу сообщением CopyDone. Когда сообщение CopyDone передаёт "
"клиент, соединение переходит из режима двустороннего в режим исходящего "
"копирования и клиент больше не может передавать сообщения CopyData. "
"Аналогично, когда сообщение CopyDone передаёт сервер, соединение переходит в "
"режим входящего копирования и сервер больше не может передавать сообщения "
"CopyData. Когда сообщения CopyDone переданы обеими сторонами, режим "
"копирования завершается и сервер возвращается в режим обработки команд. В "
"случае обнаружения ошибки на стороне сервера в режиме двустороннего "
"копирования, сервер выдаёт сообщение ErrorResponse, пропускает следующие "
"сообщения клиента, пока не будет получено сообщение Sync, а затем выдаёт "
"ReadyForQuery и возвращается к обычной обработке. Клиент должен воспринимать "
"получение ErrorResponse как завершение двустороннего копирования; в этом "
"случае сообщение CopyDone посылаться не должно. За дополнительной "
"информацией о подразделе протокола, управляющем двусторонним копированием, "
"обратитесь к <xref remap=\"3\" linkend=\"protocol-replication\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1085(para)
msgid ""
"The CopyInResponse, CopyOutResponse and CopyBothResponse messages include "
"fields that inform the frontend of the number of columns per row and the "
"format codes being used for each column. (As of the present implementation, "
"all columns in a given <command>COPY</command> operation will use the same "
"format, but the message design does not assume this.)"
msgstr ""
"Сообщения CopyInResponse, CopyOutResponse и CopyBothResponse содержат поля, "
"из которых клиент может узнать количество столбцов в строке и код формата "
"для каждого столбца. (В текущей реализации для всех столбцов в заданной "
"операции <command>COPY</command> устанавливается один формат, но в "
"конструкции сообщения это не заложено.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1097(title)
msgid "Asynchronous Operations"
msgstr "Асинхронные операции"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1099(para)
msgid ""
"There are several cases in which the backend will send messages that are not "
"specifically prompted by the frontend's command stream. Frontends must be "
"prepared to deal with these messages at any time, even when not engaged in a "
"query. At minimum, one should check for these cases before beginning to read "
"a query response."
msgstr ""
"Возможны ситуации, в которых сервер будет отправлять клиенту сообщения, не "
"предполагаемые потоком команд в текущем режиме. Клиенты должны быть готовы "
"принять эти сообщения в любой момент, даже не в процессе выполнения запроса. "
"Как минимум, следует проверять такие сообщения, прежде чем начинать читать "
"ответ на запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1108(para)
msgid ""
"It is possible for NoticeResponse messages to be generated due to outside "
"activity; for example, if the database administrator commands a <quote>fast</"
"quote> database shutdown, the backend will send a NoticeResponse indicating "
"this fact before closing the connection. Accordingly, frontends should "
"always be prepared to accept and display NoticeResponse messages, even when "
"the connection is nominally idle."
msgstr ""
"Сообщения NoticeResponse могут выдаваться вследствие внешней активности; "
"например, если администратор инициирует <quote>быстрое</quote> отключение "
"баз данных, сервер отправит NoticeResponse, сигнализирующее об этом факте, "
"прежде чем закрывать соединение. Соответственно, клиенты должны быть готовы "
"всегда принять и вывести сообщения NoticeResponse, даже когда соединение "
"фактически простаивает."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1117(para)
msgid ""
"ParameterStatus messages will be generated whenever the active value changes "
"for any of the parameters the backend believes the frontend should know "
"about. Most commonly this occurs in response to a <command>SET</command> SQL "
"command executed by the frontend, and this case is effectively synchronous "
"&mdash; but it is also possible for parameter status changes to occur "
"because the administrator changed a configuration file and then sent the "
"<systemitem>SIGHUP</systemitem> signal to the server. Also, if a "
"<command>SET</command> command is rolled back, an appropriate "
"ParameterStatus message will be generated to report the current effective "
"value."
msgstr ""
"Сообщения ParameterStatus будут выдаваться всякий раз, когда меняется "
"действующее значение одного из параметров, об изменении которых, по мнению "
"сервера, должен знать клиент. Чаще всего это происходит в ответ на SQL-"
"команду <command>SET</command>, выполняемую клиентом и в таком случае это "
"сообщение по сути синхронно &mdash; но состояние параметров может меняться и "
"когда администратор изменяет файл конфигурации, а затем посылает серверу "
"сигнал <systemitem>SIGHUP</systemitem>. Также, если действие команды "
"<command>SET</command> отменяется, клиенту передаётся сообщение "
"ParameterStatus, в котором отражается текущее значение параметра."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1131(para)
msgid ""
"At present there is a hard-wired set of parameters for which ParameterStatus "
"will be generated: they are <varname>server_version</varname>, "
"<varname>server_encoding</varname>, <varname>client_encoding</varname>, "
"<varname>application_name</varname>, <varname>is_superuser</varname>, "
"<varname>session_authorization</varname>, <varname>DateStyle</varname>, "
"<varname>IntervalStyle</varname>, <varname>TimeZone</varname>, "
"<varname>integer_datetimes</varname>, and "
"<varname>standard_conforming_strings</varname>. (<varname>server_encoding</"
"varname>, <varname>TimeZone</varname>, and <varname>integer_datetimes</"
"varname> were not reported by releases before 8.0; "
"<varname>standard_conforming_strings</varname> was not reported by releases "
"before 8.1; <varname>IntervalStyle</varname> was not reported by releases "
"before 8.4; <varname>application_name</varname> was not reported by releases "
"before 9.0.) Note that <varname>server_version</varname>, "
"<varname>server_encoding</varname> and <varname>integer_datetimes</varname> "
"are pseudo-parameters that cannot change after startup. This set might "
"change in the future, or even become configurable. Accordingly, a frontend "
"should simply ignore ParameterStatus for parameters that it does not "
"understand or care about."
msgstr ""
"В настоящее время есть жёстко зафиксированный набор параметров, при "
"изменении которых выдаётся ParameterStatus: <varname>server_version</"
"varname>, <varname>server_encoding</varname>, <varname>client_encoding</"
"varname>, <varname>application_name</varname>, <varname>is_superuser</"
"varname>, <varname>session_authorization</varname>, <varname>DateStyle</"
"varname>, <varname>IntervalStyle</varname>, <varname>TimeZone</varname>, "
"<varname>integer_datetimes</varname> и <varname>standard_conforming_strings</"
"varname>. (<varname>server_encoding</varname>, <varname>TimeZone</varname> и "
"<varname>integer_datetimes</varname> не отслеживались до версии 8.0; "
"<varname>standard_conforming_strings</varname> не отслеживался до 8.1; "
"<varname>IntervalStyle</varname> — до версии 8.4; <varname>application_name</"
"varname> — до версии 9.0.) Заметьте, что <varname>server_version</varname>, "
"<varname>server_encoding</varname> и <varname>integer_datetimes</varname> — "
"это псевдопараметры, которые не могут меняться после запуска сервера. Этот "
"набор может быть изменён в будущем или даже будет настраиваемым. "
"Соответственно, клиент может просто игнорировать сообщения ParameterStatus "
"для параметров, которые ему неизвестны или не представляют интереса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1161(para)
msgid ""
"If a frontend issues a <command>LISTEN</command> command, then the backend "
"will send a NotificationResponse message (not to be confused with "
"NoticeResponse!) whenever a <command>NOTIFY</command> command is executed "
"for the same channel name."
msgstr ""
"Если клиент выполняет команду <command>LISTEN</command>, сервер будет "
"передавать ему сообщения NotificationResponse (не путайте с "
"NoticeResponse!), когда для канала с тем же именем затем будет выполняться "
"команда <command>NOTIFY</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1170(para)
msgid ""
"At present, NotificationResponse can only be sent outside a transaction, and "
"thus it will not occur in the middle of a command-response series, though it "
"might occur just before ReadyForQuery. It is unwise to design frontend logic "
"that assumes that, however. Good practice is to be able to accept "
"NotificationResponse at any point in the protocol."
msgstr ""
"В настоящее время, сообщение NotificationResponse может быть передано только "
"вне транзакции, так что оно не может оказаться в середине серии ответов на "
"команду, хотя может поступить сразу после ReadyForQuery. Однако полагаться "
"на это при проектировании логики клиента неразумно. Лучше разработать код "
"так, чтобы NotificationResponse могло быть принято в любой фазе протокола."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1182(title)
msgid "Canceling Requests in Progress"
msgstr "Отмена выполняющихся запросов"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1184(para)
msgid ""
"During the processing of a query, the frontend might request cancellation of "
"the query. The cancel request is not sent directly on the open connection to "
"the backend for reasons of implementation efficiency: we don't want to have "
"the backend constantly checking for new input from the frontend during query "
"processing. Cancel requests should be relatively infrequent, so we make them "
"slightly cumbersome in order to avoid a penalty in the normal case."
msgstr ""
"В процессе обработки запроса клиент может запросить отмену этого запроса. "
"Запрос отмены не передаётся серверу непосредственно через открытое "
"соединение из соображений эффективности: мы не хотим, чтобы сервер постоянно "
"проверял поступающие от клиента сообщения в процессе выполнения запроса. "
"Запросы отмены должны быть относительно редкими, поэтому мы выбрали для них "
"не самый простой путь во избежание негативного влияния на обычный режим "
"работы."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1195(para)
msgid ""
"To issue a cancel request, the frontend opens a new connection to the server "
"and sends a CancelRequest message, rather than the StartupMessage message "
"that would ordinarily be sent across a new connection. The server will "
"process this request and then close the connection. For security reasons, no "
"direct reply is made to the cancel request message."
msgstr ""
"Чтобы запросить отмену запроса, клиент должен установить новое подключение к "
"серверу и отправить ему сообщение CancelRequest, вместо StartupMessage, "
"обычно передаваемого при установлении нового подключения. Сервер обработает "
"полученную команду и закроет это подключение. По соображениям безопасности "
"сервер не отвечает непосредственно на сообщение с запросом отмены."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1204(para)
msgid ""
"A CancelRequest message will be ignored unless it contains the same key data "
"(PID and secret key) passed to the frontend during connection start-up. If "
"the request matches the PID and secret key for a currently executing "
"backend, the processing of the current query is aborted. (In the existing "
"implementation, this is done by sending a special signal to the backend "
"process that is processing the query.)"
msgstr ""
"Сообщение CancelRequest обрабатывается, только если оно содержит те же "
"ключевые данные (PID и секретный ключ), что были переданы клиенту при "
"запуске. Если PID и секретный ключ в запросе соответствуют данным "
"выполняющегося в данный момент обслуживающего процесса, обработка текущего "
"запроса в нём прерывается. (В существующей реализации это осуществляется "
"путём передачи специального сигнала данному обслуживающему процессу.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1214(para)
msgid ""
"The cancellation signal might or might not have any effect &mdash; for "
"example, if it arrives after the backend has finished processing the query, "
"then it will have no effect. If the cancellation is effective, it results in "
"the current command being terminated early with an error message."
msgstr ""
"Сигнал отмены может подействовать, а может и не подействовать (например, "
"если он поступит после того, как сервер завершит обработку запроса). Если "
"отмена действительно происходит, текущая команда прерывается досрочно с "
"сообщением об ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1222(para)
msgid ""
"The upshot of all this is that for reasons of both security and efficiency, "
"the frontend has no direct way to tell whether a cancel request has "
"succeeded. It must continue to wait for the backend to respond to the query. "
"Issuing a cancel simply improves the odds that the current query will finish "
"soon, and improves the odds that it will fail with an error message instead "
"of succeeding."
msgstr ""
"Вследствие такой организации, объясняемой соображениями безопасности и "
"эффективности, клиент не может непосредственно определить, был ли запрос "
"отмены успешен. Он должен продолжать ожидать ответа сервера на исходный "
"запрос. Запрос отмены просто увеличивает вероятность того, что текущий "
"запрос завершится быстрее, как и вероятность того, что он будет завершён не "
"успешно, а с ошибкой."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1232(para)
msgid ""
"Since the cancel request is sent across a new connection to the server and "
"not across the regular frontend/backend communication link, it is possible "
"for the cancel request to be issued by any process, not just the frontend "
"whose query is to be canceled. This might provide additional flexibility "
"when building multiple-process applications. It also introduces a security "
"risk, in that unauthorized persons might try to cancel queries. The security "
"risk is addressed by requiring a dynamically generated secret key to be "
"supplied in cancel requests."
msgstr ""
"Так как запрос отмены передаётся серверу через новое подключение к серверу, "
"а не через обычный канал связи клиент-сервер, такие запросы могут выдавать "
"любые процессы, а не только клиентский процесс, запрос которого требуется "
"отменить. Это может дать дополнительную гибкость при построении "
"многопроцессных приложений. Это также представляет собой угрозу "
"безопасности, так как попытаться отменить запросы могут и неавторизованные "
"пользователи. Для ликвидации этой угрозы в запросах отмены требуется "
"передавать динамически генерируемый секретный ключ."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1246(title)
msgid "Termination"
msgstr "Завершение"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1248(para)
msgid ""
"The normal, graceful termination procedure is that the frontend sends a "
"Terminate message and immediately closes the connection. On receipt of this "
"message, the backend closes the connection and terminates."
msgstr ""
"Обычная процедура мягкого завершения заключается в том, что клиент "
"отправляет сообщение Terminate и немедленно закрывает соединение. Получая "
"это сообщение, обслуживающий процесс закрывает соединение и завершается."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1255(para)
msgid ""
"In rare cases (such as an administrator-commanded database shutdown) the "
"backend might disconnect without any frontend request to do so. In such "
"cases the backend will attempt to send an error or notice message giving the "
"reason for the disconnection before it closes the connection."
msgstr ""
"В редких случаях (например, при отключении базы данных по команде "
"администратора) обслуживающий процесс может отключиться, даже если клиент не "
"запрашивает этого. В таких случаях, перед тем, как закрыть соединение, этот "
"процесс пытается передать сообщение с ошибкой или уведомлением, в котором "
"будет указана причина отключения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1262(para)
msgid ""
"Other termination scenarios arise from various failure cases, such as core "
"dump at one end or the other, loss of the communications link, loss of "
"message-boundary synchronization, etc. If either frontend or backend sees an "
"unexpected closure of the connection, it should clean up and terminate. The "
"frontend has the option of launching a new backend by recontacting the "
"server if it doesn't want to terminate itself. Closing the connection is "
"also advisable if an unrecognizable message type is received, since this "
"probably indicates loss of message-boundary sync."
msgstr ""
"Другие сценарии завершения возникают с различными вариантами отказа, "
"например, при критическом сбое с дампом памяти на одной или другой стороне, "
"при потере канала соединения, потере синхронизации по границам сообщений и "
"т. д. Если клиент или сервер обнаруживает, что соединение было неожиданно "
"закрыто, он должен очистить ресурсы и завершиться. Клиент при этом может "
"запустить новый обслуживающий процесс, переподключившись к серверу, если он "
"сам хочет продолжать работу. Закрывать соединение также рекомендуется при "
"получении сообщений нераспознанного типа, так как это может быть признаком "
"потери синхронизации по границам сообщений."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1273(para)
msgid ""
"For either normal or abnormal termination, any open transaction is rolled "
"back, not committed. One should note however that if a frontend disconnects "
"while a non-<command>SELECT</command> query is being processed, the backend "
"will probably finish the query before noticing the disconnection. If the "
"query is outside any transaction block (<command>BEGIN</command> ... "
"<command>COMMIT</command> sequence) then its results might be committed "
"before the disconnection is recognized."
msgstr ""
"При штатном или нештатном завершении сеанса любая открытая транзакция "
"откатывается, а не фиксируется. Однако следует заметить, что при отключении "
"клиента в процессе обработки запроса, отличного от <command>SELECT</"
"command>, обслуживающий процесс вероятнее всего завершит запрос, прежде чем "
"заметит отключение. Если запрос выполняется не в блоке транзакции (вне "
"последовательности <command>BEGIN</command> ... <command>COMMIT</command>), "
"его результаты могут быть зафиксированы до того, как будет обнаружено "
"отключение."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1286(title)
msgid "<acronym>SSL</acronym> Session Encryption"
msgstr "Защита сеанса с <acronym>SSL</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1288(para)
msgid ""
"If <productname>PostgreSQL</productname> was built with <acronym>SSL</"
"acronym> support, frontend/backend communications can be encrypted using "
"<acronym>SSL</acronym>. This provides communication security in environments "
"where attackers might be able to capture the session traffic. For more "
"information on encrypting <productname>PostgreSQL</productname> sessions "
"with <acronym>SSL</acronym>, see <xref linkend=\"ssl-tcp\"/>."
msgstr ""
"Если <productname>PostgreSQL</productname> был собран с поддержкой "
"<acronym>SSL</acronym>, взаимодействие клиента с сервером может быть "
"зашифровано с применением <acronym>SSL</acronym>. Это обеспечивает защиту на "
"уровне канала в среде, где злоумышленники могут перехватить трафик сеанса. "
"За дополнительными сведениями о шифровании трафика сеансов "
"<productname>PostgreSQL</productname> с использованием <acronym>SSL</"
"acronym>, обратитесь к <xref remap=\"3\" linkend=\"ssl-tcp\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1298(para)
msgid ""
"To initiate an <acronym>SSL</acronym>-encrypted connection, the frontend "
"initially sends an SSLRequest message rather than a StartupMessage. The "
"server then responds with a single byte containing <literal>S</literal> or "
"<literal>N</literal>, indicating that it is willing or unwilling to perform "
"<acronym>SSL</acronym>, respectively. The frontend might close the "
"connection at this point if it is dissatisfied with the response. To "
"continue after <literal>S</literal>, perform an <acronym>SSL</acronym> "
"startup handshake (not described here, part of the <acronym>SSL</acronym> "
"specification) with the server. If this is successful, continue with sending "
"the usual StartupMessage. In this case the StartupMessage and all subsequent "
"data will be <acronym>SSL</acronym>-encrypted. To continue after <literal>N</"
"literal>, send the usual StartupMessage and proceed without encryption."
msgstr ""
"Чтобы начать сеанс с <acronym>SSL</acronym>-шифрованием, клиент передаёт "
"серверу вместо StartupMessage сообщение SSLRequest. В ответ сервер передаёт "
"один байт, содержащий символ <literal>S</literal> или <literal>N</literal>, "
"показывающий, что он желает, либо не желает включать <acronym>SSL</acronym>, "
"соответственно. Если клиент не удовлетворён ответом, он должен закрыть "
"соединение на этом этапе. Чтобы продолжить установление соединения после "
"получения <literal>S</literal>, он выполняет начальное согласование "
"<acronym>SSL</acronym> с сервером (не описывается здесь, так как относится к "
"протоколу <acronym>SSL</acronym>). Если эта процедура выполняется успешно, "
"он продолжает соединение, передавая обычное сообщение StartupMessage. При "
"этом StartupMessage и все последующие данные будут защищены <acronym>SSL</"
"acronym>-шифрованием. Чтобы продолжить после получения <literal>N</literal>, "
"клиент может передать обычное сообщение StartupMessage и дальше "
"взаимодействовать с сервером без шифрования."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1316(para)
msgid ""
"The frontend should also be prepared to handle an ErrorMessage response to "
"SSLRequest from the server. This would only occur if the server predates the "
"addition of <acronym>SSL</acronym> support to <productname>PostgreSQL</"
"productname>. (Such servers are now very ancient, and likely do not exist in "
"the wild anymore.) In this case the connection must be closed, but the "
"frontend might choose to open a fresh connection and proceed without "
"requesting <acronym>SSL</acronym>."
msgstr ""
"Клиент также должен быть готов обработать сообщение ErrorMessage, полученное "
"от сервера в ответ на SSLRequest. Такая ситуация возможна, только если "
"сервер имеет версию, которая ещё не поддерживала <acronym>SSL</acronym> в "
"<productname>PostgreSQL</productname>. (Такие серверы сейчас антикварная "
"редкость, и скорее всего их уже не встретить в природе.) В этом случае "
"соединение должно быть закрыто, но клиент может решить открыть новое "
"соединение, не запрашивая <acronym>SSL</acronym>-шифрование."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1316(para)
msgid ""
"For the purpose of testing replication commands, you can make a replication "
"connection via <application>psql</application> or any other <literal>libpq</"
"literal>-using tool with a connection string including the "
"<literal>replication</literal> option, e.g.: <placeholder-1/> However, it is "
"often more useful to use <xref linkend=\"app-pgreceivexlog\"/> (for physical "
"replication) or <xref linkend=\"app-pgrecvlogical\"/> (for logical "
"replication)."
msgstr ""
"Для тестирования команд репликации вы можете установить соединение для "
"репликации, запустив <application>psql</application> или другую программу на "
"базе <literal>libpq</literal> со строкой подключения, включающей параметр "
"<literal>replication</literal>, например так: <placeholder-1/> Однако часто "
"полезнее использовать <xref linkend=\"app-pgreceivexlog\"/> (для физической "
"репликации) или <xref linkend=\"app-pgrecvlogical\"/> (для логической)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1327(para)
msgid ""
"An initial SSLRequest can also be used in a connection that is being opened "
"to send a CancelRequest message."
msgstr ""
"Начальный запрос SSLRequest может также передаваться при установлении "
"соединения, открываемого для передачи сообщения CancelRequest."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1332(para)
msgid ""
"While the protocol itself does not provide a way for the server to force "
"<acronym>SSL</acronym> encryption, the administrator can configure the "
"server to reject unencrypted sessions as a byproduct of authentication "
"checking."
msgstr ""
"Так как в самом протоколе не предусмотрено принудительное включение "
"<acronym>SSL</acronym>-шифрования сервером, администратор может настроить "
"сервер так, чтобы в качестве дополнительного условия при проверке "
"подлинности клиента он не принимал незашифрованные сеансы."

#. +> REL_10
#: protocol.xml:1342(title)
msgid "SASL Authentication"
msgstr "Аутентификация SASL"

#. +> REL_10
#: protocol.xml:1344(para)
msgid ""
"<firstterm>SASL</firstterm> is a framework for authentication in connection-"
"oriented protocols. At the moment, <productname>PostgreSQL</productname> "
"implements only one SASL authentication mechanism, SCRAM-SHA-256, but more "
"might be added in the future. The below steps illustrate how SASL "
"authentication is performed in general, while the next subsection gives more "
"details on SCRAM-SHA-256."
msgstr ""
"<firstterm>SASL</firstterm> — это инфраструктура аутентификации для "
"протоколов, ориентированных на соединения. На данный момент "
"<productname>PostgreSQL</productname> реализует только один механизм SASL, "
"SCRAM-SHA-256, но в будущем могут появиться и другие. Далее описывается, как "
"в принципе осуществляется аутентификация SASL, а в следующем подразделе "
"более подробно рассматривается SCRAM-SHA-256."

#. +> REL_10
#: protocol.xml:1353(title)
msgid "SASL Authentication Message Flow"
msgstr "Поток сообщений аутентификации SASL"

#. +> REL_10
#: protocol.xml:1356(para)
msgid ""
"To begin a SASL authentication exchange, the server sends an "
"AuthenticationSASL message. It includes a list of SASL authentication "
"mechanisms that the server can accept, in the server's preferred order."
msgstr ""
"Чтобы начать обмен по схеме аутентификации SASL, сервер передаёт сообщение "
"AuthenticationSASL. Оно содержит список механизмов аутентификации SASL, с "
"которыми может работать сервер, в порядке предпочтений сервера."

#. +> REL_10
#: protocol.xml:1364(para)
msgid ""
"The client selects one of the supported mechanisms from the list, and sends "
"a SASLInitialResponse message to the server. The message includes the name "
"of the selected mechanism, and an optional Initial Client Response, if the "
"selected mechanism uses that."
msgstr ""
"Клиент выбирает один из поддерживаемых механизмов из списка и передаёт "
"серверу сообщение SASLInitialResponse. Это сообщение содержит имя выбранного "
"механизма и может содержать «Начальный ответ клиента», если это использует "
"выбранный механизм."

#. +> REL_10
#: protocol.xml:1373(para)
msgid ""
"One or more server-challenge and client-response message will follow. Each "
"server-challenge is sent in an AuthenticationSASLContinue message, followed "
"by a response from client in an SASLResponse message. The particulars of the "
"messages are mechanism specific."
msgstr ""
"За этим следует одно или нескольких сообщений вызова со стороны сервера и "
"ответов со стороны клиента. Все вызовы сервер передаёт в сообщениях "
"AuthenticationSASLContinue, а клиент отвечает на них сообщениями "
"SASLResponse. Частные детали сообщений зависят от конкретного механизма."

#. +> REL_10
#: protocol.xml:1382(para)
msgid ""
"Finally, when the authentication exchange is completed successfully, the "
"server sends an AuthenticationSASLFinal message, followed immediately by an "
"AuthenticationOk message. The AuthenticationSASLFinal contains additional "
"server-to-client data, whose content is particular to the selected "
"authentication mechanism. If the authentication mechanism doesn't use "
"additional data that's sent at completion, the AuthenticationSASLFinal "
"message is not sent."
msgstr ""
"Наконец, когда обмен аутентификационной информацией заканчивается успешно, "
"сервер передаёт сообщение AuthenticationSASLFinal и сразу за ним сообщение "
"AuthenticationOk. В сообщении AuthenticationSASLFinal передаются "
"дополнительные данные от сервера клиенту, содержимое которых определяется "
"выбранным механизмом аутентификации. Если механизм аутентификации не требует "
"передавать дополнительные данные в завершение обмена, сообщение "
"AuthenticationSASLFinal опускается."

#. +> REL_10
#: protocol.xml:1394(para)
msgid ""
"On error, the server can abort the authentication at any stage, and send an "
"ErrorMessage."
msgstr ""
"В случае ошибки сервер может прервать процесс аутентификации на любом этапе "
"и передать сообщение ErrorMessage."

#. +> REL_10
#: protocol.xml:1400(title)
msgid "SCRAM-SHA-256 authentication"
msgstr "Аутентификация SCRAM-SHA-256"

#. +> REL_10
#: protocol.xml:1402(para)
msgid ""
"<firstterm>SCRAM-SHA-256</firstterm> (called just <firstterm>SCRAM</"
"firstterm> from now on) is the only implemented SASL mechanism, at the "
"moment. It is described in detail in RFC 7677 and RFC 5802."
msgstr ""
"Аутентификация <firstterm>SCRAM-SHA-256</firstterm> (далее называемая просто "
"<firstterm>SCRAM</firstterm>) — единственный реализованный на данный момент "
"механизм SASL. Она подробно описывается в RFC 7677 и RFC 5802."

#. +> REL_10
#: protocol.xml:1408(para)
msgid ""
"When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user "
"name that the client sends in the <structname>client-first-message</"
"structname>. The user name that was already sent in the startup message is "
"used instead. <productname>PostgreSQL</productname> supports multiple "
"character encodings, while SCRAM dictates UTF-8 to be used for the user "
"name, so it might be impossible to represent the PostgreSQL user name in "
"UTF-8."
msgstr ""
"Когда в PostgreSQL задействуется SCRAM-SHA-256, сервер игнорирует имя "
"пользователя, которое клиент передаёт в <structname>client-first-message</"
"structname>. Вместо этого используется имя, переданное ранее в стартовом "
"сообщении. Согласно спецификации SCRAM, имя пользователя должно быть в "
"UTF-8, но <productname>PostgreSQL</productname> поддерживает разные "
"кодировки символов, и значит, имя пользователя PostgreSQL не всегда будет "
"представимо в UTF-8."

#. +> REL_10
#: protocol.xml:1417(para)
msgid ""
"The SCRAM specification dictates that the password is also in UTF-8, and is "
"processed with the <firstterm>SASLprep</firstterm> algorithm. "
"<productname>PostgreSQL</productname>, however, does not require UTF-8 to be "
"used for the password. When a user's password is set, it is processed with "
"SASLprep as if it was in UTF-8, regardless of the actual encoding used. "
"However, if it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte "
"sequences that are prohibited by the SASLprep algorithm, the raw password "
"will be used without SASLprep processing, instead of throwing an error. This "
"allows the password to be normalized when it is in UTF-8, but still allows a "
"non-UTF-8 password to be used, and doesn't require the system to know which "
"encoding the password is in."
msgstr ""
"В спецификации SCRAM говорится, что пароль также должен передаваться в UTF-8 "
"и обрабатываться алгоритмом <firstterm>SASLprep</firstterm>. Однако "
"<productname>PostgreSQL</productname> не требует, чтобы пароль представлялся "
"в UTF-8. Когда устанавливается пароль пользователя, он обрабатывается "
"алгоритмом SASLprep как пароль в UTF-8, вне зависимости от фактической "
"кодировки. Однако, если он представлен недопустимой для UTF-8 "
"последовательностью байтов либо содержит комбинации байтов UTF-8, которые не "
"принимает алгоритм SASLprep, это не будет считаться ошибкой — при "
"аутентификации будет использоваться исходный пароль, без обработки SASLprep. "
"Это позволяет нормализовать пароли, представленные в UTF-8, и при этом "
"использовать пароли не в UTF-8, а также не требует, чтобы система знала, в "
"какой кодировке задан пароль."

#. +> REL_10
#: protocol.xml:1431(para)
msgid "<firstterm>Channel binding</firstterm> has not been implemented yet."
msgstr "<firstterm>Связывание с каналом</firstterm> ещё не реализовано."

#. +> REL_10
#: protocol.xml:1436(title)
msgid "Example"
msgstr "Пример"

#. +> REL_10
#: protocol.xml:1438(para)
msgid ""
"The server sends an AuthenticationSASL message. It includes a list of SASL "
"authentication mechanisms that the server can accept."
msgstr ""
"Сервер передаёт сообщение AuthenticationSASL. Оно содержит список механизмов "
"аутентификации SASL, с которыми может работать сервер."

#. +> REL_10
#: protocol.xml:1444(para)
msgid ""
"The client responds by sending a SASLInitialResponse message, which "
"indicates the chosen mechanism, <literal>SCRAM-SHA-256</literal>. In the "
"Initial Client response field, the message contains the SCRAM "
"<structname>client-first-message</structname>."
msgstr ""
"Клиент в ответ передаёт сообщение SASLInitialResponse, информирующее о "
"выбранном механизме, <literal>SCRAM-SHA-256</literal>. В поле «Начального "
"ответа клиента» это сообщение содержит данные SCRAM <structname>client-first-"
"message</structname>."

#. +> REL_10
#: protocol.xml:1452(para)
msgid ""
"Server sends an AuthenticationSASLContinue message, with a SCRAM "
"<structname>server-first message</structname> as the content."
msgstr ""
"Сервер передаёт сообщение AuthenticationSASLContinue, содержащее данные "
"SCRAM <structname>server-first message</structname>."

#. +> REL_10
#: protocol.xml:1458(para)
msgid ""
"Client sends a SASLResponse message, with SCRAM <structname>client-final-"
"message</structname> as the content."
msgstr ""
"Клиент передаёт сообщение SASLResponse, содержащее данные SCRAM "
"<structname>client-final-message</structname>."

#. +> REL_10
#: protocol.xml:1464(para)
msgid ""
"Server sends an AuthenticationSASLFinal message, with the SCRAM "
"<structname>server-final-message</structname>, followed immediately by an "
"AuthenticationOk message."
msgstr ""
"Сервер передаёт сообщение AuthenticationSASLFinal, содержащее данные SCRAM "
"<structname>server-final-message</structname>, и сразу за ним сообщение "
"AuthenticationOk."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1475(title)
msgid "Streaming Replication Protocol"
msgstr "Протокол потоковой репликации"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1477(para)
msgid ""
"To initiate streaming replication, the frontend sends the "
"<literal>replication</literal> parameter in the startup message. A Boolean "
"value of <literal>true</literal> tells the backend to go into walsender "
"mode, wherein a small set of replication commands can be issued instead of "
"SQL statements. Only the simple query protocol can be used in walsender "
"mode. Replication commands are logged in the server log when <xref linkend="
"\"guc-log-replication-commands\"/> is enabled. Passing <literal>database</"
"literal> as the value instructs walsender to connect to the database "
"specified in the <literal>dbname</literal> parameter, which will allow the "
"connection to be used for logical replication from that database."
msgstr ""
"Чтобы инициировать потоковую репликацию, клиент передаёт в стартовом "
"сообщении параметр <literal>replication</literal>. Логическое значение "
"<literal>true</literal> этого параметра указывает обслуживающему процессу "
"перейти в режим передачи WAL (walsender), в котором вместо SQL-операторов "
"клиент может выдавать только ограниченный набор команд репликации. В режиме "
"walsender можно использовать только протокол простых запросов. Команды "
"репликации будут записываться в журнал сообщений сервера, если включён режим "
"<xref linkend=\"guc-log-replication-commands\"/>. Если этот параметр имеет "
"значение <literal>database</literal>, процесс walsender должен подключиться "
"к базе данных, указанной в параметре <literal>dbname</literal>, что позволит "
"использовать это подключение для логической репликации с указанной базой "
"данных."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1494(programlisting)
#, no-wrap
msgid "psql \"dbname=postgres replication=database\" -c \"IDENTIFY_SYSTEM;\""
msgstr "psql \"dbname=postgres replication=database\" -c \"IDENTIFY_SYSTEM;\""

#. +> REL_10
#: protocol.xml:1489(para)
msgid ""
"For the purpose of testing replication commands, you can make a replication "
"connection via <application>psql</application> or any other <literal>libpq</"
"literal>-using tool with a connection string including the "
"<literal>replication</literal> option, e.g.: <placeholder-1/> However, it is "
"often more useful to use <xref linkend=\"app-pgreceivewal\"/> (for physical "
"replication) or <xref linkend=\"app-pgrecvlogical\"/> (for logical "
"replication)."
msgstr ""
"Для тестирования команд репликации вы можете установить соединение для "
"репликации, запустив <application>psql</application> или другую программу на "
"базе <literal>libpq</literal> со строкой подключения, включающей параметр "
"<literal>replication</literal>, например так: <placeholder-1/> Однако часто "
"полезнее использовать <xref linkend=\"app-pgreceivewal\"/> (для физической "
"репликации) или <xref linkend=\"app-pgrecvlogical\"/> (для логической)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1506(literal)
msgid "IDENTIFY_SYSTEM"
msgstr "IDENTIFY_SYSTEM"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1507(indexterm)
msgid "<primary>IDENTIFY_SYSTEM</primary>"
msgstr "<primary>IDENTIFY_SYSTEM</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1510(para)
msgid ""
"Requests the server to identify itself. Server replies with a result set of "
"a single row, containing four fields:"
msgstr ""
"Запрашивает идентификационные данные сервера. Сервер возвращает набор "
"результатов с одной строкой, содержащей четыре поля:"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1518(term)
msgid "<literal>systemid</literal> (<type>text</type>)"
msgstr "<literal>systemid</literal> (<type>text</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1522(para)
msgid ""
"The unique system identifier identifying the cluster. This can be used to "
"check that the base backup used to initialize the standby came from the same "
"cluster."
msgstr ""
"Уникальный идентификатор системы, идентифицирующий кластер. По нему можно "
"определить, что базовая резервная копия, из которой инициализировался "
"резервный сервер, получена из того же кластера."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1531(term)
msgid "<literal>timeline</literal> (<type>int4</type>)"
msgstr "<literal>timeline</literal> (<type>int4</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1535(para)
msgid ""
"Current timeline ID. Also useful to check that the standby is consistent "
"with the master."
msgstr ""
"Идентификатор текущей линии времени. Также полезен для того, чтобы "
"убедиться, что резервный сервер согласован с главным."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1543(term)
msgid "<literal>xlogpos</literal> (<type>text</type>)"
msgstr "<literal>xlogpos</literal> (<type>text</type>)"

#. +> REL_10
#: protocol.xml:1547(para)
msgid ""
"Current WAL flush location. Useful to get a known location in the write-"
"ahead log where streaming can start."
msgstr ""
"Текущее положение сохранённых данных в WAL. Позволяет узнать, с какой "
"позиции в журнале предзаписи может начаться потоковая передача."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1555(term)
msgid "<literal>dbname</literal> (<type>text</type>)"
msgstr "<literal>dbname</literal> (<type>text</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1559(para)
msgid "Database connected to or null."
msgstr "Подключённая база данных или NULL."

#. +> REL_10
#: protocol.xml:1571(literal)
msgid "SHOW"
msgstr "SHOW"

#. +> REL_10
#: protocol.xml:1571(replaceable) protocol.xml:1582(replaceable)
msgid "name"
msgstr "имя"

#. +> REL_10
#: protocol.xml:1572(indexterm)
msgid "<primary>SHOW</primary>"
msgstr "<primary>SHOW</primary>"

#. +> REL_10
#: protocol.xml:1575(para)
msgid ""
"Requests the server to send the current setting of a run-time parameter. "
"This is similar to the SQL command <xref linkend=\"sql-show\"/>."
msgstr ""
"Запрашивает у сервера текущее значение параметра времени выполнения. Эта "
"команда подобна SQL-команде <xref linkend=\"sql-show\"/>."

#. +> REL_10
#: protocol.xml:1584(para)
msgid ""
"The name of a run-time parameter. Available parameters are documented in "
"<xref linkend=\"runtime-config\"/>."
msgstr ""
"Имя параметра времени выполнения. Доступные параметры описаны в <xref remap="
"\"6\" linkend=\"runtime-config\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1595(literal)
msgid "TIMELINE_HISTORY"
msgstr "TIMELINE_HISTORY"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1595(replaceable)
msgid "tli"
msgstr "tli"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1596(indexterm)
msgid "<primary>TIMELINE_HISTORY</primary>"
msgstr "<primary>TIMELINE_HISTORY</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1599(para)
msgid ""
"Requests the server to send over the timeline history file for timeline "
"<replaceable class=\"parameter\">tli</replaceable>. Server replies with a "
"result set of a single row, containing two fields:"
msgstr ""
"Запрашивает с сервера файл истории для линии времени <replaceable class="
"\"parameter\">лин_врем</replaceable>. Сервер возвращает набор результатов с "
"одной строкой, содержащей два поля:"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1608(term)
msgid "<literal>filename</literal> (<type>text</type>)"
msgstr "<literal>filename</literal> (<type>text</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1612(para)
msgid ""
"File name of the timeline history file, e.g., <filename>00000002.history</"
"filename>."
msgstr ""
"Имя файла с историей линии времени, например <filename>00000002.history</"
"filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1619(term)
msgid "<literal>content</literal> (<type>bytea</type>)"
msgstr "<literal>content</literal> (<type>bytea</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1623(para)
msgid "Contents of the timeline history file."
msgstr "Содержимое файла с историей линией времени."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1636(indexterm)
msgid "<primary>CREATE_REPLICATION_SLOT</primary>"
msgstr "<primary>CREATE_REPLICATION_SLOT</primary>"

#. +> REL_10
#: protocol.xml:1635(term)
msgid ""
"<literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter"
"\">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] "
"{ <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | "
"<literal>LOGICAL</literal> <replaceable class=\"parameter\">output_plugin</"
"replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | "
"<literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> ] } "
"<placeholder-1/>"
msgstr ""
"<literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter"
"\">имя_слота</replaceable> [ <literal>TEMPORARY</literal> ] "
"{ <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | "
"<literal>LOGICAL</literal> <replaceable class=\"parameter\">модуль_вывода</"
"replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | "
"<literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> ] } "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1639(para)
msgid ""
"Create a physical or logical replication slot. See <xref linkend=\"streaming-"
"replication-slots\"/> for more about replication slots."
msgstr ""
"Создаёт слот физической или логической репликации. Слоты репликации описаны "
"подробно в <xref remap=\"6\" linkend=\"streaming-replication-slots\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1646(replaceable) protocol.xml:2135(replaceable)
#: protocol.xml:2176(replaceable) protocol.xml:2187(replaceable)
msgid "slot_name"
msgstr "имя_слота"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1648(para)
msgid ""
"The name of the slot to create. Must be a valid replication slot name (see "
"<xref linkend=\"streaming-replication-slots-manipulation\"/>)."
msgstr ""
"Имя создаваемого слота. Заданное имя должно быть допустимым для слота "
"репликации (см. <xref remap=\"4\" linkend=\"streaming-replication-slots-"
"manipulation\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1656(replaceable)
msgid "output_plugin"
msgstr "модуль_вывода"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1658(para)
msgid ""
"The name of the output plugin used for logical decoding (see <xref linkend="
"\"logicaldecoding-output-plugin\"/>)."
msgstr ""
"Имя модуля вывода, применяемого для логического декодирования (см. <xref "
"remap=\"4\" linkend=\"logicaldecoding-output-plugin\"/>)."

#. +> REL_10
#: protocol.xml:1666(literal)
msgid "TEMPORARY"
msgstr "TEMPORARY"

#. +> REL_10
#: protocol.xml:1668(para)
msgid ""
"Specify that this replication slot is a temporary one. Temporary slots are "
"not saved to disk and are automatically dropped on error or when the session "
"has finished."
msgstr ""
"Это указание отмечает, что данный слот репликации является временным. "
"Временные слоты не сохраняются на диске и автоматически удаляются при ошибке "
"или завершении сеанса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1677(literal)
msgid "RESERVE_WAL"
msgstr "RESERVE_WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1679(para)
msgid ""
"Specify that this physical replication slot reserves <acronym>WAL</acronym> "
"immediately. Otherwise, <acronym>WAL</acronym> is only reserved upon "
"connection from a streaming replication client."
msgstr ""
"Указывает, что этот слот физической репликации резервирует <acronym>WAL</"
"acronym> немедленно. Без этого указания <acronym>WAL</acronym> резервируется "
"только при подключении клиента потоковой репликации."

#. +> REL_10
#: protocol.xml:1688(literal)
msgid "EXPORT_SNAPSHOT"
msgstr "EXPORT_SNAPSHOT"

#. +> REL_10
#: protocol.xml:1689(literal)
msgid "NOEXPORT_SNAPSHOT"
msgstr "NOEXPORT_SNAPSHOT"

#. +> REL_10
#: protocol.xml:1690(literal)
msgid "USE_SNAPSHOT"
msgstr "USE_SNAPSHOT"

#. +> REL_10
#: protocol.xml:1692(para)
msgid ""
"Decides what to do with the snapshot created during logical slot "
"initialization. <literal>EXPORT_SNAPSHOT</literal>, which is the default, "
"will export the snapshot for use in other sessions. This option can't be "
"used inside a transaction. <literal>USE_SNAPSHOT</literal> will use the "
"snapshot for the current transaction executing the command. This option must "
"be used in a transaction, and <literal>CREATE_REPLICATION_SLOT</literal> "
"must be the first command run in that transaction. Finally, "
"<literal>NOEXPORT_SNAPSHOT</literal> will just use the snapshot for logical "
"decoding as normal but won't do anything else with it."
msgstr ""
"Эти указания выбирают, что делать со снимком, создаваемым при инициализации "
"логического слота. С указанием <literal>EXPORT_SNAPSHOT</literal>, "
"подразумеваемым по умолчанию, этот снимок будет экспортироваться для "
"использования в других сеансах. Это указание нельзя использовать внутри "
"транзакции. С указанием <literal>USE_SNAPSHOT</literal> снимок будет "
"использоваться для текущей транзакции, в которой выполняется команда. Это "
"указание должно использоваться в транзакции, при этом команда "
"<literal>CREATE_REPLICATION_SLOT</literal> должна быть первой в этой "
"транзакции. Наконец, с <literal>NOEXPORT_SNAPSHOT</literal> снимок будет "
"использоваться только для логического декодирования в обычном режиме, но "
"ничего больше с ним делать нельзя."

#. +> REL_10
#: protocol.xml:1714(term)
msgid "<literal>slot_name</literal> (<type>text</type>)"
msgstr "<literal>slot_name</literal> (<type>text</type>)"

#. +> REL_10
#: protocol.xml:1716(para)
msgid "The name of the newly-created replication slot."
msgstr "Имя создаваемого слота репликации."

#. +> REL_10
#: protocol.xml:1723(term)
msgid "<literal>consistent_point</literal> (<type>text</type>)"
msgstr "<literal>consistent_point</literal> (<type>text</type>)"

#. +> REL_10
#: protocol.xml:1725(para)
msgid ""
"The WAL location at which the slot became consistent. This is the earliest "
"location from which streaming can start on this replication slot."
msgstr ""
"Позиция в WAL, в которой слот достиг согласованного состояния. Это самая "
"ранняя позиция, с которой может начаться трансляция через этот слот "
"репликации."

#. +> REL_10
#: protocol.xml:1734(term)
msgid "<literal>snapshot_name</literal> (<type>text</type>)"
msgstr "<literal>snapshot_name</literal> (<type>text</type>)"

#. +> REL_10
#: protocol.xml:1736(para)
msgid ""
"The identifier of the snapshot exported by the command. The snapshot is "
"valid until a new command is executed on this connection or the replication "
"connection is closed. Null if the created slot is physical."
msgstr ""
"Идентификатор снимка, экспортированного командой. Этот снимок действителен "
"до тех пор, пока через это соединение не будет выполнена следующая команда "
"или соединение не будет закрыто. Null, если созданный слот — физический."

#. +> REL_10
#: protocol.xml:1746(term)
msgid "<literal>output_plugin</literal> (<type>text</type>)"
msgstr "<literal>output_plugin</literal> (<type>text</type>)"

#. +> REL_10
#: protocol.xml:1748(para)
msgid ""
"The name of the output plugin used by the newly-created replication slot. "
"Null if the created slot is physical."
msgstr ""
"Имя модуля вывода, используемого созданным слотом репликации. Null, если "
"созданный слот — физический."

#. +> REL_10
#: protocol.xml:1708(para)
msgid ""
"In response to this command, the server will send a one-row result set "
"containing the following fields: <placeholder-1/>"
msgstr ""
"В ответ на эту команду сервер передаст набор результатов с одной строкой, "
"содержащей следующие поля: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1761(indexterm)
msgid "<primary>START_REPLICATION</primary>"
msgstr "<primary>START_REPLICATION</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1760(term)
msgid ""
"<literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable "
"class=\"parameter\">slot_name</replaceable> ] [ <literal>PHYSICAL</"
"literal> ] <replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ <literal>TIMELINE</literal> <replaceable class=\"parameter\">tli</"
"replaceable> ] <placeholder-1/>"
msgstr ""
"<literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable "
"class=\"parameter\">имя_слота</replaceable> ] [ <literal>PHYSICAL</"
"literal> ] <replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ <literal>TIMELINE</literal> <replaceable class=\"parameter\">лин_врем</"
"replaceable> ] <placeholder-1/>"

#. +> REL_10
#: protocol.xml:1764(para)
msgid ""
"Instructs server to start streaming WAL, starting at WAL location "
"<replaceable class=\"parameter\">XXX/XXX</replaceable>. If "
"<literal>TIMELINE</literal> option is specified, streaming starts on "
"timeline <replaceable class=\"parameter\">tli</replaceable>; otherwise, the "
"server's current timeline is selected. The server can reply with an error, "
"for example if the requested section of WAL has already been recycled. On "
"success, server responds with a CopyBothResponse message, and then starts to "
"stream WAL to the frontend."
msgstr ""
"Указывает серверу начать потоковую передачу WAL, начиная с позиции "
"<replaceable class=\"parameter\">XXX/XXX</replaceable> в WAL. Если "
"указывается параметр <literal>TIMELINE</literal>, передача начинается на "
"линии времени <replaceable class=\"parameter\">лин_врем</replaceable>, иначе "
"выбирается текущая линия времени сервера. Сервер может вернуть в ответ "
"ошибку, например, если запрошенный сегмент WAL уже потерян. Если проблем не "
"возникает, сервер возвращает сообщение CopyBothResponse, а затем начинает "
"передавать поток WAL клиенту."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1775(para)
msgid ""
"If a slot's name is provided via <replaceable class=\"parameter\">slot_name</"
"replaceable>, it will be updated as replication progresses so that the "
"server knows which WAL segments, and if <varname>hot_standby_feedback</"
"varname> is on which transactions, are still needed by the standby."
msgstr ""
"Если в параметрах передаётся <replaceable class=\"parameter\">имя_слота</"
"replaceable>, сервер будет отражать состояние репликации в этом слоте и "
"отслеживать, какие сегменты, а если включён режим "
"<varname>hot_standby_feedback</varname>, то и в каких транзакциях, всё ещё "
"нужны этому резервному серверу."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1783(para)
msgid ""
"If the client requests a timeline that's not the latest but is part of the "
"history of the server, the server will stream all the WAL on that timeline "
"starting from the requested start point up to the point where the server "
"switched to another timeline. If the client requests streaming at exactly "
"the end of an old timeline, the server responds immediately with "
"CommandComplete without entering COPY mode."
msgstr ""
"Если клиент запрашивает не последнюю, но существующую в истории сервера "
"линию времени, сервер будет передавать весь WAL на этой линии времени, "
"начиная с запрошенной стартовой точки до момента, когда сервер переключился "
"на другую линию времени. Если клиент запрашивает передачу с начальной "
"позицией точно в конце старой линии времени, сервер немедленно отвечает "
"CommandComplete, не переходя в режим COPY."

#. +> REL_10
#: protocol.xml:1792(para)
msgid ""
"After streaming all the WAL on a timeline that is not the latest one, the "
"server will end streaming by exiting the COPY mode. When the client "
"acknowledges this by also exiting COPY mode, the server sends a result set "
"with one row and two columns, indicating the next timeline in this server's "
"history. The first column is the next timeline's ID (type <type>int8</"
"type>), and the second column is the WAL location where the switch happened "
"(type <type>text</type>). Usually, the switch position is the end of the WAL "
"that was streamed, but there are corner cases where the server can send some "
"WAL from the old timeline that it has not itself replayed before promoting. "
"Finally, the server sends CommandComplete message, and is ready to accept a "
"new command."
msgstr ""
"После передачи всех записей WAL на линии времени, не являющейся текущей, "
"сервер завершает потоковую передачу, выходя из режима копирования. Когда "
"клиент подтверждает завершение передачи, также выходя из режима копирования, "
"сервер возвращает набор результатов в одной строке с двумя столбцами, "
"сообщая таким образом о следующей линии времени в истории сервера. В первом "
"столбце передаётся идентификатор следующей линии времени (типа <type>int8</"
"type>), а во втором — позиция в WAL, в которой произошло переключение (типа "
"<type>text</type>). Обычно в этой же позиции завершается передача потока "
"WAL, но возможны исключения, когда сервер может передавать записи WAL из "
"старой линии времени, которые он сам ещё не воспроизвёл до переключения. "
"Наконец сервер передаёт сообщение CommandComplete, после чего он готов "
"принять следующую команду."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1806(para)
msgid ""
"WAL data is sent as a series of CopyData messages. (This allows other "
"information to be intermixed; in particular the server can send an "
"ErrorResponse message if it encounters a failure after beginning to stream.) "
"The payload of each CopyData message from server to the client contains a "
"message of one of the following formats:"
msgstr ""
"Данные WAL передаются в серии сообщений CopyData. (Это позволяет перемежать "
"их с другой информацией; в частности, сервер может передать сообщение "
"ErrorResponse, если он столкнулся с проблемами, уже начав передачу потока.) "
"Полезная нагрузка каждого сообщения CopyData от сервера к клиенту содержит "
"данные в одном из следующих форматов:"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1817(term)
msgid "XLogData (B)"
msgstr "XLogData (B) — данные журнала транзакций"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1824(term)
msgid "Byte1('w')"
msgstr "Byte1('w')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1828(para)
msgid "Identifies the message as WAL data."
msgstr "Указывает, что в этом сообщении передаются данные WAL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1834(term) protocol.xml:1844(term) protocol.xml:1854(term)
#: protocol.xml:1903(term) protocol.xml:1913(term) protocol.xml:1967(term)
#: protocol.xml:1978(term) protocol.xml:1989(term) protocol.xml:1999(term)
#: protocol.xml:2048(term) protocol.xml:5948(term) protocol.xml:5958(term)
#: protocol.xml:6013(term) protocol.xml:6023(term) protocol.xml:6033(term)
#: protocol.xml:6068(term)
msgid "Int64"
msgstr "Int64"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1838(para)
msgid "The starting point of the WAL data in this message."
msgstr "Начальная точка данных WAL в этом сообщении."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1848(para) protocol.xml:1907(para)
msgid "The current end of WAL on the server."
msgstr "Текущее положение конца WAL на сервере."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1848(para)
msgid "The WAL position to begin streaming at."
msgstr "Позиция в WAL, с которой должна начаться передача."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1858(para) protocol.xml:1917(para)
msgid ""
"The server's system clock at the time of transmission, as microseconds since "
"midnight on 2000-01-01."
msgstr ""
"Показания системных часов сервера в момент передачи, в микросекундах с "
"полуночи 2000-01-01."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1865(term) protocol.xml:3002(term) protocol.xml:3118(term)
#: protocol.xml:3173(term) protocol.xml:3352(term) protocol.xml:3711(term)
#: protocol.xml:4085(term) protocol.xml:4447(term) protocol.xml:4521(term)
#: protocol.xml:4570(term) protocol.xml:5338(term) protocol.xml:5384(term)
#: protocol.xml:6589(term)
msgid "Byte<replaceable>n</replaceable>"
msgstr "Byte<replaceable>n</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1869(para)
msgid "A section of the WAL data stream."
msgstr "Фрагмент потока данных WAL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1872(para)
msgid ""
"A single WAL record is never split across two XLogData messages. When a WAL "
"record crosses a WAL page boundary, and is therefore already split using "
"continuation records, it can be split at the page boundary. In other words, "
"the first main WAL record and its continuation records can be sent in "
"different XLogData messages."
msgstr ""
"Одна запись WAL никогда не разделяется на два сообщения XLogData. Когда "
"запись WAL пересекает границу страницы WAL, и таким образом от неё уже "
"оказывается отделена продолжающая запись, её можно разделить на сообщения по "
"границе страницы. Другими словами, первая основная запись WAL и продолжающие "
"её записи могут быть переданы в различных сообщениях XLogData."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1886(term)
msgid "Primary keepalive message (B)"
msgstr "Primary keepalive message (B) — Сообщение об активности ведущего"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1893(term)
msgid "Byte1('k')"
msgstr "Byte1('k')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1897(para)
msgid "Identifies the message as a sender keepalive."
msgstr "Указывает, что это сообщение об активности отправителя."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1924(term) protocol.xml:2010(term) protocol.xml:3522(term)
#: protocol.xml:4132(term) protocol.xml:4230(term) protocol.xml:4654(term)
#: protocol.xml:5140(term)
msgid "Byte1"
msgstr "Byte1"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1928(para)
msgid ""
"1 means that the client should reply to this message as soon as possible, to "
"avoid a timeout disconnect. 0 otherwise."
msgstr ""
"Значение 1 означает, что клиент должен ответить на это сообщение как можно "
"скорее, во избежание отключения по тайм-ауту. Со значением 0 это не "
"требуется."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1941(para)
msgid ""
"The receiving process can send replies back to the sender at any time, using "
"one of the following message formats (also in the payload of a CopyData "
"message):"
msgstr ""
"Принимающий процесс может передавать ответы отправителю в любое время, "
"используя один из следующих форматов данных (также в полезной нагрузке "
"сообщения CopyData):"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1950(term)
msgid "Standby status update (F)"
msgstr "Standby status update (F) — Обновление состояния резервного сервера"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1957(term)
msgid "Byte1('r')"
msgstr "Byte1('r')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1961(para)
msgid "Identifies the message as a receiver status update."
msgstr ""
"Указывает, что это сообщение передаёт обновлённое состояние получателя."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1971(para)
msgid ""
"The location of the last WAL byte + 1 received and written to disk in the "
"standby."
msgstr ""
"Положение следующего за последним байтом WAL, полученным и записанным на "
"диск на резервном сервере."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1982(para)
msgid "The location of the last WAL byte + 1 flushed to disk in the standby."
msgstr ""
"Положение следующего за последним байтом WAL, сохранённым на диске на "
"резервном сервере."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1993(para)
msgid "The location of the last WAL byte + 1 applied in the standby."
msgstr ""
"Положение следующего за последним байтом WAL, применённым на резервном "
"сервере."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2003(para) protocol.xml:2052(para)
msgid ""
"The client's system clock at the time of transmission, as microseconds since "
"midnight on 2000-01-01."
msgstr ""
"Показания системных часов клиента в момент передачи, в микросекундах с "
"полуночи 2000-01-01."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2014(para)
msgid ""
"If 1, the client requests the server to reply to this message immediately. "
"This can be used to ping the server, to test if the connection is still "
"healthy."
msgstr ""
"Если содержит 1, клиент запрашивает от сервера немедленный ответ на это "
"сообщение. Так клиент может запросить отклик сервера и проверить, продолжает "
"ли функционировать соединение."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2031(term)
msgid "Hot Standby feedback message (F)"
msgstr ""
"Hot Standby feedback message (F) — Сообщение обратной связи горячего резерва"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2038(term)
msgid "Byte1('h')"
msgstr "Byte1('h')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2042(para)
msgid "Identifies the message as a Hot Standby feedback message."
msgstr "Указывает, что это сообщение обратной связи горячего резерва."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2059(term) protocol.xml:2073(term) protocol.xml:2083(term)
#: protocol.xml:2095(term) protocol.xml:2982(term) protocol.xml:3037(term)
#: protocol.xml:3098(term) protocol.xml:3153(term) protocol.xml:3221(term)
#: protocol.xml:3231(term) protocol.xml:3266(term) protocol.xml:3339(term)
#: protocol.xml:3467(term) protocol.xml:3477(term) protocol.xml:3512(term)
#: protocol.xml:3604(term) protocol.xml:3701(term) protocol.xml:3783(term)
#: protocol.xml:3830(term) protocol.xml:3905(term) protocol.xml:3978(term)
#: protocol.xml:4049(term) protocol.xml:4072(term) protocol.xml:4122(term)
#: protocol.xml:4215(term) protocol.xml:4281(term) protocol.xml:4302(term)
#: protocol.xml:4373(term) protocol.xml:4383(term) protocol.xml:4434(term)
#: protocol.xml:4498(term) protocol.xml:4508(term) protocol.xml:4560(term)
#: protocol.xml:4639(term) protocol.xml:4705(term) protocol.xml:4715(term)
#: protocol.xml:4770(term) protocol.xml:4794(term) protocol.xml:4828(term)
#: protocol.xml:4882(term) protocol.xml:4930(term) protocol.xml:5003(term)
#: protocol.xml:5084(term) protocol.xml:5179(term) protocol.xml:5212(term)
#: protocol.xml:5234(term) protocol.xml:5255(term) protocol.xml:5306(term)
#: protocol.xml:5327(term) protocol.xml:5374(term) protocol.xml:5446(term)
#: protocol.xml:5969(term) protocol.xml:6117(term) protocol.xml:6194(term)
#: protocol.xml:6204(term) protocol.xml:6238(term) protocol.xml:6292(term)
#: protocol.xml:6348(term) protocol.xml:6451(term) protocol.xml:6579(term)
msgid "Int32"
msgstr "Int32"

#. +> REL_10
#: protocol.xml:2063(para)
msgid ""
"The standby's current global xmin, excluding the catalog_xmin from any "
"replication slots. If both this value and the following catalog_xmin are 0 "
"this is treated as a notification that Hot Standby feedback will no longer "
"be sent on this connection. Later non-zero messages may reinitiate the "
"feedback mechanism."
msgstr ""
"Текущее глобальное значение xmin данного резервного сервера, не учитывающее "
"catalog_xmin всех слотов репликации. Если и это значение, и следующее "
"catalog_xmin, равны 0, это воспринимается как уведомление о том, что через "
"данное подключение больше не будут передаваться сообщения обратной связи "
"горячего резерва. Последующие ненулевые сообщения могут возобновить работу "
"механизма обратной связи."

#. +> REL_10
#: protocol.xml:2077(para)
msgid "The epoch of the global xmin xid on the standby."
msgstr "Эпоха глобального идентификатора транзакции xmin на резервном сервере."

#. +> REL9_6_3 REL9_6
#: protocol.xml:2077(para)
msgid ""
"<filename>pg_xlog</filename>, including subdirectories. If the backup is run "
"with WAL files included, a synthesized version of <filename>pg_xlog</"
"filename> will be included, but it will only contain the files necessary for "
"the backup to work, not the rest of the contents."
msgstr ""
"<filename>pg_xlog</filename>, включая подкаталоги. Если в резервную копию "
"включаются файлы WAL, в архив входит преобразованная версия "
"<filename>pg_xlog</filename>, в которой будут находиться только файлы, "
"необходимые для восстановления копии, но не всё остальное содержимое этого "
"каталога."

#. +> REL_10
#: protocol.xml:2087(para)
msgid ""
"The lowest catalog_xmin of any replication slots on the standby. Set to 0 if "
"no catalog_xmin exists on the standby or if hot standby feedback is being "
"disabled."
msgstr ""
"Наименьшее значение catalog_xmin для всех слотов репликации на резервном "
"сервере. Значение 0 показывает, что на резервном сервере нет catalog_xmin, "
"либо обратная связь горячего резерва отключена."

#. +> REL_10
#: protocol.xml:2099(para)
msgid "The epoch of the catalog_xmin xid on the standby."
msgstr "Эпоха идентификатора транзакции catalog_xmin на резервном сервере."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2113(term)
msgid ""
"<literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable "
"class=\"parameter\">slot_name</replaceable> <literal>LOGICAL</literal> "
"<replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</"
"replaceable> ] [, ...] ) ]"
msgstr ""
"<literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable "
"class=\"parameter\">имя_слота</replaceable> <literal>LOGICAL</literal> "
"<replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ ( <replaceable>имя_параметра</replaceable> "
"[ <replaceable>значение_параметра</replaceable> ] [, ...] ) ]"

#. +> REL_10
#: protocol.xml:2115(para)
msgid ""
"Instructs server to start streaming WAL for logical replication, starting at "
"WAL location <replaceable class=\"parameter\">XXX/XXX</replaceable>. The "
"server can reply with an error, for example if the requested section of WAL "
"has already been recycled. On success, server responds with a "
"CopyBothResponse message, and then starts to stream WAL to the frontend."
msgstr ""
"Указывает серверу начать потоковую передачу WAL для логической репликации, "
"начиная с позиции <replaceable class=\"parameter\">XXX/XXX</replaceable> в "
"WAL. Сервер может вернуть в ответ ошибку, например, если запрошенный сегмент "
"WAL уже потерян. Если проблем не возникает, сервер возвращает сообщение "
"CopyBothResponse, а затем начинает передавать поток WAL клиенту."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2123(para)
msgid ""
"The messages inside the CopyBothResponse messages are of the same format "
"documented for <literal>START_REPLICATION ... PHYSICAL</literal>."
msgstr ""
"Данные, передаваемые внутри сообщений CopyBothResponse, имеют тот же формат, "
"что описан для команды <literal>START_REPLICATION ... PHYSICAL</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2128(para)
msgid ""
"The output plugin associated with the selected slot is used to process the "
"output for streaming."
msgstr ""
"Обработку выводимых данных для передачи выполняет модуль вывода, связанный с "
"выбранным слотом."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2135(literal)
msgid "SLOT"
msgstr "SLOT"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2137(para)
msgid ""
"The name of the slot to stream changes from. This parameter is required, and "
"must correspond to an existing logical replication slot created with "
"<literal>CREATE_REPLICATION_SLOT</literal> in <literal>LOGICAL</literal> "
"mode."
msgstr ""
"Имя слота, из которого передаются изменения. Это имя является обязательным, "
"оно должно соответствовать существующему логическому слоту репликации, "
"созданному командой <literal>CREATE_REPLICATION_SLOT</literal> в режиме "
"<literal>LOGICAL</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2146(replaceable)
msgid "XXX/XXX"
msgstr "XXX/XXX"

#. +> REL_10
#: protocol.xml:2148(para)
msgid "The WAL location to begin streaming at."
msgstr "Позиция в WAL, с которой должна начаться передача."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2154(replaceable)
msgid "option_name"
msgstr "имя_параметра"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2156(para)
msgid "The name of an option passed to the slot's logical decoding plugin."
msgstr ""
"Имя параметра, передаваемого модулю логического декодирования для выбранного "
"слота."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2162(replaceable)
msgid "option_value"
msgstr "значение_параметра"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2164(para)
msgid ""
"Optional value, in the form of a string constant, associated with the "
"specified option."
msgstr ""
"Необязательное значение, в форме строковой константы, связываемое с "
"указанным параметром."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2176(literal)
msgid "DROP_REPLICATION_SLOT"
msgstr "DROP_REPLICATION_SLOT"

#. +> REL_10
#: protocol.xml:2176(literal) protocol.xml:2196(literal)
msgid "WAIT"
msgstr "WAIT"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2177(indexterm)
msgid "<primary>DROP_REPLICATION_SLOT</primary>"
msgstr "<primary>DROP_REPLICATION_SLOT</primary>"

#. +> REL_10
#: protocol.xml:2180(para)
msgid ""
"Drops a replication slot, freeing any reserved server-side resources. If the "
"slot is a logical slot that was created in a database other than the "
"database the walsender is connected to, this command fails."
msgstr ""
"Удаляет слот репликации, что приводит к освобождению всех занятых им "
"ресурсов на стороне сервера. Если слот представляет собой логический слот, "
"созданный не в той базе данных, к которой подключён walsender, команда "
"завершается ошибкой."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2189(para)
msgid "The name of the slot to drop."
msgstr "Имя слота, подлежащего удалению."

#. +> REL_10
#: protocol.xml:2198(para)
msgid ""
"This option causes the command to wait if the slot is active until it "
"becomes inactive, instead of the default behavior of raising an error."
msgstr ""
"С этим указанием команда будет ждать, пока активный слот не станет "
"неактивным (по умолчанию в этом случае выдаётся ошибка)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2211(indexterm)
msgid "<primary>BASE_BACKUP</primary>"
msgstr "<primary>BASE_BACKUP</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2210(term)
msgid ""
"<literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> "
"<replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] "
"[ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</"
"literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] "
"[ <literal>TABLESPACE_MAP</literal> ] <placeholder-1/>"
msgstr ""
"<literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> "
"<replaceable>'метка'</replaceable> ] [ <literal>PROGRESS</literal> ] "
"[ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</"
"literal> ] [ <literal>MAX_RATE</literal> <replaceable>скорость</"
"replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2221(literal)
msgid "LABEL"
msgstr "LABEL"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2221(replaceable)
msgid "'label'"
msgstr "'метка'"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2223(para)
msgid ""
"Sets the label of the backup. If none is specified, a backup label of "
"<literal>base backup</literal> will be used. The quoting rules for the label "
"are the same as a standard SQL string with <xref linkend=\"guc-standard-"
"conforming-strings\"/> turned on."
msgstr ""
"Устанавливает метку для резервной копии. Если метка не задана, по умолчанию "
"устанавливается метка <literal>base backup</literal>. Для метки действуют те "
"же правила применения кавычек, что и для стандартных строк SQL при "
"включённым режиме <xref linkend=\"guc-standard-conforming-strings\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2233(literal)
msgid "PROGRESS"
msgstr "PROGRESS"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2235(para)
msgid ""
"Request information required to generate a progress report. This will send "
"back an approximate size in the header of each tablespace, which can be used "
"to calculate how far along the stream is done. This is calculated by "
"enumerating all the file sizes once before the transfer is even started, and "
"might as such have a negative impact on the performance. In particular, it "
"might take longer before the first data is streamed. Since the database "
"files can change during the backup, the size is only approximate and might "
"both grow and shrink between the time of approximation and the sending of "
"the actual files."
msgstr ""
"Запрашивает информацию, необходимую для отслеживания прогресса операции. "
"Сервер передаёт в ответ приблизительный размер в заголовке каждого "
"табличного пространства, исходя из которого можно понять, насколько "
"продвинулась передача потока. Для вычисления этого размера анализируются "
"размеры всех файлов ещё до начала передачи, и это может негативно повлиять "
"на производительность — в частности, может увеличиться задержка до передачи "
"первых данных. Так как файлы базы данных могут меняться во время резервного "
"копирования, оценка размера не будет точной; размер базы может увеличиться "
"или уменьшиться за время от вычисления этой оценки до передачи актуальных "
"файлов."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2250(literal)
msgid "FAST"
msgstr "FAST"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2252(para)
msgid "Request a fast checkpoint."
msgstr "Запрашивает быструю контрольную точку."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2259(literal)
msgid "WAL"
msgstr "WAL"

#. +> REL_10
#: protocol.xml:2261(para)
msgid ""
"Include the necessary WAL segments in the backup. This will include all the "
"files between start and stop backup in the <filename>pg_wal</filename> "
"directory of the base directory tar file."
msgstr ""
"Включает в резервную копию необходимые сегменты WAL. При этом в подкаталог "
"<filename>pg_wal</filename> архива базового каталога будут включены все "
"файлы с начала до конца копирования."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2271(literal)
msgid "NOWAIT"
msgstr "NOWAIT"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2273(para)
msgid ""
"By default, the backup will wait until the last required WAL segment has "
"been archived, or emit a warning if log archiving is not enabled. Specifying "
"<literal>NOWAIT</literal> disables both the waiting and the warning, leaving "
"the client responsible for ensuring the required log is available."
msgstr ""
"По умолчанию при копировании ожидается завершение архивации последнего "
"требуемого сегмента WAL либо выдаётся предупреждение, если архивация журнала "
"не включена. Указание <literal>NOWAIT</literal> отключает и ожидание, и "
"предупреждение, так что обеспечение наличия требуемого журнала становится "
"задачей клиента."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2284(literal)
msgid "MAX_RATE"
msgstr "MAX_RATE"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2284(replaceable)
msgid "rate"
msgstr "скорость"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2286(para)
msgid ""
"Limit (throttle) the maximum amount of data transferred from server to "
"client per unit of time. The expected unit is kilobytes per second. If this "
"option is specified, the value must either be equal to zero or it must fall "
"within the range from 32 kB through 1 GB (inclusive). If zero is passed or "
"the option is not specified, no restriction is imposed on the transfer."
msgstr ""
"Ограничивает (сдерживает) максимальный объём данных, передаваемый от сервера "
"клиенту за единицу времени. Единица измерения этого параметра — килобайты в "
"секунду. Если задаётся этот параметр, его значение должно быть равно нулю, "
"либо должно находиться в диапазоне от 32 (килобайт/сек) до 1 Гбайта/сек "
"(включая границы). Если передаётся ноль, либо параметр не задаётся, скорость "
"передачи не ограничивается."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2298(literal)
msgid "TABLESPACE_MAP"
msgstr "TABLESPACE_MAP"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2300(para)
msgid ""
"Include information about symbolic links present in the directory "
"<filename>pg_tblspc</filename> in a file named <filename>tablespace_map</"
"filename>. The tablespace map file includes each symbolic link name as it "
"exists in the directory <filename>pg_tblspc/</filename> and the full path of "
"that symbolic link."
msgstr ""
"Включает информацию о символических ссылках, представленных в каталоге "
"<filename>pg_tblspc</filename>, в файл <filename>tablespace_map</filename>. "
"Файл карты табличных пространств содержит имена всех ссылок, содержащихся в "
"каталоге <filename>pg_tblspc/</filename>, и полный путь для каждой ссылки."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2214(para)
msgid ""
"Instructs the server to start streaming a base backup. The system will "
"automatically be put in backup mode before the backup is started, and taken "
"out of it when the backup is complete. The following options are accepted: "
"<placeholder-1/>"
msgstr ""
"Указывает серверу начать потоковую передачу базовой копии. Система "
"автоматически переходит в режим резервного копирования до начала передачи, и "
"выходит из него после завершения копирования. Эта команда принимает "
"следующие параметры: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2311(para)
msgid ""
"When the backup is started, the server will first send two ordinary result "
"sets, followed by one or more CopyResponse results."
msgstr ""
"Когда запускается копирование, сервер сначала передаёт два обычных набора "
"результатов, за которыми следуют один или более результатов CopyResponse."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2316(para)
msgid ""
"The first ordinary result set contains the starting position of the backup, "
"in a single row with two columns. The first column contains the start "
"position given in XLogRecPtr format, and the second column contains the "
"corresponding timeline ID."
msgstr ""
"В первом обычном наборе результатов передаётся начальная позиция резервной "
"копии, в одной строке с двумя столбцами. В первом столбце содержится "
"стартовая позиция в формате XLogRecPtr, а во втором идентификатор "
"соответствующей линии времени."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2327(term)
msgid "<literal>spcoid</literal> (<type>oid</type>)"
msgstr "<literal>spcoid</literal> (<type>oid</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2329(para)
msgid "The OID of the tablespace, or null if it's the base directory."
msgstr "OID табличного пространства либо NULL, если это базовый каталог."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2336(term)
msgid "<literal>spclocation</literal> (<type>text</type>)"
msgstr "<literal>spclocation</literal> (<type>text</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2338(para)
msgid ""
"The full path of the tablespace directory, or null if it's the base "
"directory."
msgstr ""
"Полный путь к каталогу табличного пространства либо NULL, если это базовый "
"каталог."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2345(term)
msgid "<literal>size</literal> (<type>int8</type>)"
msgstr "<literal>size</literal> (<type>int8</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2347(para)
msgid ""
"The approximate size of the tablespace, if progress report has been "
"requested; otherwise it's null."
msgstr ""
"Приблизительный размер табличного пространства, если была запрошена "
"информация о прогрессе операции; в противном случае NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2322(para)
msgid ""
"The second ordinary result set has one row for each tablespace. The fields "
"in this row are: <placeholder-1/>"
msgstr ""
"Во втором обычном наборе результатов передаётся по одной строке для каждого "
"табличного пространства. Эта строка содержит следующие поля: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2355(para)
msgid ""
"After the second regular result set, one or more CopyResponse results will "
"be sent, one for the main data directory and one for each additional "
"tablespace other than <literal>pg_default</literal> and <literal>pg_global</"
"literal>. The data in the CopyResponse results will be a tar format "
"(following the <quote>ustar interchange format</quote> specified in the "
"POSIX 1003.1-2008 standard) dump of the tablespace contents, except that the "
"two trailing blocks of zeroes specified in the standard are omitted. After "
"the tar data is complete, a final ordinary result set will be sent, "
"containing the WAL end position of the backup, in the same format as the "
"start position."
msgstr ""
"За вторым обычным набором результатов следует одна или несколько серий "
"результатов CopyResponse, одна для основного каталога данных и по одной для "
"каждого табличного пространства, отличного от <literal>pg_default</literal> "
"и <literal>pg_global</literal>. Данные в CopyResponse представляют собой "
"выгруженное в формате tar (<quote>формате обмена ustar</quote>, описанном в "
"стандарте POSIX 1003.1-2008) содержимое табличных пространств, за "
"исключением того, что два замыкающих блока нулей, описанных в стандарте, не "
"передаются. После завершения передачи данных tar передаётся заключительный "
"обычный набор результатов, в котором сообщается конечная позиция копии в "
"WAL, в том же формате, что и стартовая позиция."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2376(filename)
msgid "postmaster.pid"
msgstr "postmaster.pid"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2381(filename)
msgid "postmaster.opts"
msgstr "postmaster.opts"

#. +> REL_10
#: protocol.xml:2385(para)
msgid ""
"Various temporary files and directories created during the operation of the "
"PostgreSQL server, such as any file or directory beginning with "
"<filename>pgsql_tmp</filename>."
msgstr ""
"различные временные файлы и каталоги, создаваемые в процессе работы сервером "
"PostgreSQL, в частности файлы и каталоги с именами, начинающимися с "
"<filename>pgsql_tmp</filename>"

#. +> REL_10
#: protocol.xml:2392(para)
msgid ""
"<filename>pg_wal</filename>, including subdirectories. If the backup is run "
"with WAL files included, a synthesized version of <filename>pg_wal</"
"filename> will be included, but it will only contain the files necessary for "
"the backup to work, not the rest of the contents."
msgstr ""
"<filename>pg_wal</filename>, включая подкаталоги. Если в резервную копию "
"включаются файлы WAL, в архив входит преобразованная версия "
"<filename>pg_wal</filename>, в которой будут находиться только файлы, "
"необходимые для восстановления копии, но не всё остальное содержимое этого "
"каталога"

#. +> REL_10
#: protocol.xml:2400(para)
msgid ""
"<filename>pg_dynshmem</filename>, <filename>pg_notify</filename>, "
"<filename>pg_replslot</filename>, <filename>pg_serial</filename>, "
"<filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename>, and "
"<filename>pg_subtrans</filename> are copied as empty directories (even if "
"they are symbolic links)."
msgstr ""
"<filename>pg_dynshmem</filename>, <filename>pg_notify</filename>, "
"<filename>pg_replslot</filename>, <filename>pg_serial</filename>, "
"<filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename> и "
"<filename>pg_subtrans</filename> копируются как пустые каталоги (даже если "
"это символические ссылки)"

#. +> REL_10
#: protocol.xml:2409(para)
msgid ""
"Files other than regular files and directories, such as symbolic links "
"(other than for the directories listed above) and special device files, are "
"skipped. (Symbolic links in <filename>pg_tblspc</filename> are maintained.)"
msgstr ""
"файлы, кроме обычных файлов и каталогов, например, символические ссылки "
"(кроме вышеупомянутых каталогов) и файлы специальных устройств, пропускаются "
"(символические ссылки в <filename>pg_tblspc</filename> сохраняются)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2368(para)
msgid ""
"The tar archive for the data directory and each tablespace will contain all "
"files in the directories, regardless of whether they are "
"<productname>PostgreSQL</productname> files or other files added to the same "
"directory. The only excluded files are: <placeholder-1/> Owner, group, and "
"file mode are set if the underlying file system on the server supports it."
msgstr ""
"Архив tar каталога данных и всех табличных пространств будет содержать все "
"файлы в этих каталогах, будь то файлы <productname>PostgreSQL</productname> "
"или посторонние файлы, добавленные в эти каталоги. Исключение составляют "
"только следующие файлы: <placeholder-1/> Если файловая система сервера "
"поддерживает это, в архив включается информация о владельце, группе и режиме "
"файла."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:1502(para)
msgid "The commands accepted in walsender mode are: <placeholder-1/>"
msgstr "В режиме walsender принимаются следующие команды: <placeholder-1/>"

#. +> REL_10
#: protocol.xml:2429(title)
msgid "Logical Streaming Replication Protocol"
msgstr "Протокол логической потоковой репликации"

#. +> REL_10
#: protocol.xml:2431(para)
msgid ""
"This section describes the logical replication protocol, which is the "
"message flow started by the <literal>START_REPLICATION</literal> "
"<literal>SLOT</literal> <replaceable class=\"parameter\">slot_name</"
"replaceable> <literal>LOGICAL</literal> replication command."
msgstr ""
"В этом разделе описывается протокол логической репликации, регламентирующий "
"поток сообщений, который запускается командой репликации "
"<literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable "
"class=\"parameter\">имя_слота</replaceable> <literal>LOGICAL</literal>."

#. +> REL_10
#: protocol.xml:2438(para)
msgid ""
"The logical streaming replication protocol builds on the primitives of the "
"physical streaming replication protocol."
msgstr ""
"Протокол логической потоковой репликации построен на примитивах протокола "
"физической потоковой репликации."

#. +> REL_10
#: protocol.xml:2444(title)
msgid "Logical Streaming Replication Parameters"
msgstr "Параметры протокола логической потоковой репликации"

#. +> REL_10
#: protocol.xml:2452(term)
msgid "proto_version"
msgstr "proto_version"

#. +> REL_10
#: protocol.xml:2456(para)
msgid ""
"Protocol version. Currently only version <literal>1</literal> is supported."
msgstr ""
"Версия протокола. В настоящее время поддерживается только версия <literal>1</"
"literal>."

#. +> REL_10
#: protocol.xml:2464(term)
msgid "publication_names"
msgstr "publication_names"

#. +> REL_10
#: protocol.xml:2468(para)
msgid ""
"Comma separated list of publication names for which to subscribe (receive "
"changes). The individual publication names are treated as standard objects "
"names and can be quoted the same as needed."
msgstr ""
"Список разделённых запятыми имён публикаций, на которые подписывается клиент "
"(будет получать их изменения). Имена отдельных публикаций обрабатываются как "
"стандартные имена объектов и могут так же заключаться в кавычки при "
"необходимости."

#. +> REL_10
#: protocol.xml:2446(para)
msgid ""
"The logical replication <literal>START_REPLICATION</literal> command accepts "
"following parameters: <placeholder-1/>"
msgstr ""
"Команда логической репликации <literal>START_REPLICATION</literal> принимает "
"следующие параметры: <placeholder-1/>"

#. +> REL_10
#: protocol.xml:2481(title)
msgid "Logical Replication Protocol Messages"
msgstr "Сообщения протокола логической репликации"

#. +> REL_10
#: protocol.xml:2483(para)
msgid ""
"The individual protocol messages are discussed in the following subsections. "
"Individual messages are described in <xref linkend=\"protocol-logicalrep-"
"message-formats\"/>."
msgstr ""
"Отдельные сообщения протокола рассматриваются в следующих подразделах. "
"Собственно сообщения описаны в <xref linkend=\"protocol-logicalrep-message-"
"formats\"/>."

#. +> REL_10
#: protocol.xml:2489(para)
msgid ""
"All top-level protocol messages begin with a message type byte. While "
"represented in code as a character, this is a signed byte with no associated "
"encoding."
msgstr ""
"Все сообщения верхнего уровня начинаются с байта, определяющего тип "
"сообщения. Хотя он представлен в коде символьным типом, это знаковый байт "
"без явно заданной кодировки."

#. +> REL_10
#: protocol.xml:2495(para)
msgid ""
"Since the streaming replication protocol supplies a message length there is "
"no need for top-level protocol messages to embed a length in their header."
msgstr ""
"Так как в протоколе потоковой репликации передаётся длина сообщения, нет "
"необходимости указывать длину в заголовках сообщений верхнего уровня."

#. +> REL_10
#: protocol.xml:2504(title)
msgid "Logical Replication Protocol Message Flow"
msgstr "Поток сообщений протокола логической репликации"

#. +> REL_10
#: protocol.xml:2506(para)
msgid ""
"With the exception of the <literal>START_REPLICATION</literal> command and "
"the replay progress messages, all information flows only from the backend to "
"the frontend."
msgstr ""
"За исключением команды <literal>START_REPLICATION</literal> и сообщений о "
"прогрессе воспроизведения, весь информационный поток направлен от сервера к "
"клиенту."

#. +> REL_10
#: protocol.xml:2512(para)
msgid ""
"The logical replication protocol sends individual transactions one by one. "
"This means that all messages between a pair of Begin and Commit messages "
"belong to the same transaction."
msgstr ""
"Протокол логической репликации передаёт отдельные транзакции одну за другой. "
"Это значит, что все сообщения между парой сообщений Begin и Commit относятся "
"к одной транзакции."

#. +> REL_10
#: protocol.xml:2518(para)
msgid ""
"Every sent transaction contains zero or more DML messages (Insert, Update, "
"Delete). In case of a cascaded setup it can also contain Origin messages. "
"The origin message indicated that the transaction originated on different "
"replication node. Since a replication node in the scope of logical "
"replication protocol can be pretty much anything, the only identifier is the "
"origin name. It's downstream's responsibility to handle this as needed (if "
"needed). The Origin message is always sent before any DML messages in the "
"transaction."
msgstr ""
"Каждая передаваемая транзакция содержит ноль или более сообщений DML "
"(Insert, Update, Delete). В каскадной схеме она может также содержать "
"сообщения Origin. Это сообщение показывает, что транзакция пришла с другого "
"узла в схеме репликации. Так как этим узлом в контексте протокола логической "
"репликации может быть что угодно, единственным идентификатором является его "
"имя. Как воспринимать это имя (если это вообще нужно), определяют "
"нижестоящие узлы. Сообщение Origin всегда передаётся перед всеми остальными "
"сообщениями DML в транзакции."

#. +> REL_10
#: protocol.xml:2529(para)
msgid ""
"Every DML message contains an arbitrary relation ID, which can be mapped to "
"an ID in the Relation messages. The Relation messages describe the schema of "
"the given relation. The Relation message is sent for a given relation either "
"because it is the first time we send a DML message for given relation in the "
"current session or because the relation definition has changed since the "
"last Relation message was sent for it. The protocol assumes that the client "
"is capable of caching the metadata for as many relations as needed."
msgstr ""
"Каждое DML-сообщение содержит произвольный идентификатор отношения, который "
"можно сопоставить с идентификатором в сообщениях Relation. Сообщения "
"Relation описывают схему данного отношения. Такие сообщения передаются для "
"заданного отношения либо когда нужно впервые передать DML-сообщения для "
"этого отношения в текущем сеансе, либо когда определение отношения "
"изменилось со времени предыдущей передачи сообщения Relation о нём. В "
"протоколе предполагается, что клиент сможет кешировать метаданные для "
"достаточно большого числа отношений."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2542(title)
msgid "Message Data Types"
msgstr "Типы данных в сообщениях"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2550(term)
msgid "Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)"
msgstr "Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2554(para)
msgid ""
"An <replaceable>n</replaceable>-bit integer in network byte order (most "
"significant byte first). If <replaceable>i</replaceable> is specified it is "
"the exact value that will appear, otherwise the value is variable. Eg. "
"Int16, Int32(42)."
msgstr ""
"Целое число из <replaceable>n</replaceable> бит с сетевым порядком байт "
"(наиболее значащий байт первый). Если указано <replaceable>i</replaceable>, "
"это поле будет содержать именно указанное значение, в противном случае "
"значение переменное. Например: Int16, Int32(42)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2565(term)
msgid "Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]"
msgstr "Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2569(para)
msgid ""
"An array of <replaceable>k</replaceable> <replaceable>n</replaceable>-bit "
"integers, each in network byte order. The array length <replaceable>k</"
"replaceable> is always determined by an earlier field in the message. Eg. "
"Int16[M]."
msgstr ""
"Массив из <replaceable>k</replaceable> <replaceable>n</replaceable>-битовых "
"целых, каждое записывается с сетевым порядком байт. Длина массива "
"<replaceable>k</replaceable> всегда определяется по предыдущему полю "
"сообщения, например Int16[M]."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2580(term)
msgid "String(<replaceable>s</replaceable>)"
msgstr "String(<replaceable>s</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2584(para)
msgid ""
"A null-terminated string (C-style string). There is no specific length "
"limitation on strings. If <replaceable>s</replaceable> is specified it is "
"the exact value that will appear, otherwise the value is variable. Eg. "
"String, String(\"user\")."
msgstr ""
"Строка, оканчивающаяся нулём (строка в стиле C). На длину строк ограничение "
"не накладывается. Если указывается <replaceable>s</replaceable>, это поле "
"будет содержать именно указанное значение, в противном случае значение "
"переменное. Например: String, String(\"user\")."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2593(para)
msgid ""
"<emphasis>There is no predefined limit</emphasis> on the length of a string "
"that can be returned by the backend. Good coding strategy for a frontend is "
"to use an expandable buffer so that anything that fits in memory can be "
"accepted. If that's not feasible, read the full string and discard trailing "
"characters that don't fit into your fixed-size buffer."
msgstr ""
"<emphasis>Нет никакого предопределённого ограничения</emphasis> длины "
"строки, которую может возвратить сервер. Поэтому при реализации клиента "
"лучше использовать расширяемый буфер, чтобы он мог принять строку любого "
"размера, умещающуюся в памяти. Если такой возможности нет, прочитайте строку "
"целиком и отбросьте последние символы, не помещающиеся в ваш буфер "
"фиксированного размера."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2605(term)
msgid "Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)"
msgstr "Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2609(para)
msgid ""
"Exactly <replaceable>n</replaceable> bytes. If the field width "
"<replaceable>n</replaceable> is not a constant, it is always determinable "
"from an earlier field in the message. If <replaceable>c</replaceable> is "
"specified it is the exact value. Eg. Byte2, Byte1('\\n')."
msgstr ""
"В точности <replaceable>n</replaceable> байт. Если размер поля "
"<replaceable>n</replaceable> задаётся не константой, он всегда определяется "
"по предыдущему полю сообщения. Если указывается <replaceable>c</"
"replaceable>, оно задаёт точное значение. Например: Byte2, Byte1('\\n')."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2544(para)
msgid ""
"This section describes the base data types used in messages. <placeholder-1/>"
msgstr ""
"В этом разделе описываются базовые типы данных, применяемые в сообщениях. "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2624(title)
msgid "Message Formats"
msgstr "Форматы сообщений"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2626(para)
msgid ""
"This section describes the detailed format of each message. Each is marked "
"to indicate that it can be sent by a frontend (F), a backend (B), or both (F "
"&amp; B). Notice that although each message includes a byte count at the "
"beginning, the message format is defined so that the message end can be "
"found without reference to the byte count. This aids validity checking. (The "
"CopyData message is an exception, because it forms part of a data stream; "
"the contents of any individual CopyData message cannot be interpretable on "
"their own.)"
msgstr ""
"В этом разделе подробно описывается формат каждого сообщения. Все сообщения "
"помечены символами, обозначающими, какая сторона может их передавать: сервер "
"(F), клиент (B) или обе стороны (F &amp; B). Заметьте, что хотя каждое "
"сообщение включает счётчик байт в начале, формат сообщения разработан так, "
"чтобы конец сообщения можно было найти, не обращаясь к счётчику байт. Это "
"помогает проверять корректность сообщений. (Исключением является сообщение "
"CopyData, так как оно образует часть потока данных; содержимое любого "
"отдельного сообщения CopyData нельзя интерпретировать само по себе.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2641(term)
msgid "AuthenticationOk (B)"
msgstr "AuthenticationOk (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2649(term) protocol.xml:2694(term) protocol.xml:2738(term)
#: protocol.xml:2782(term) protocol.xml:2837(term) protocol.xml:2882(term)
#: protocol.xml:2927(term) protocol.xml:2972(term) protocol.xml:3027(term)
#: protocol.xml:3088(term) protocol.xml:3143(term) protocol.xml:6107(term)
msgid "Byte1('R')"
msgstr "Byte1('R')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2653(para) protocol.xml:2698(para) protocol.xml:2742(para)
#: protocol.xml:2786(para) protocol.xml:2841(para) protocol.xml:2886(para)
#: protocol.xml:2931(para) protocol.xml:2976(para) protocol.xml:3031(para)
#: protocol.xml:3092(para) protocol.xml:3147(para)
msgid "Identifies the message as an authentication request."
msgstr "Указывает, что это сообщение представляет запрос аутентификации."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2659(term) protocol.xml:2704(term) protocol.xml:2748(term)
#: protocol.xml:2847(term) protocol.xml:2892(term) protocol.xml:2937(term)
#: protocol.xml:2992(term) protocol.xml:5408(term)
msgid "Int32(8)"
msgstr "Int32(8)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2663(para) protocol.xml:2708(para) protocol.xml:2752(para)
#: protocol.xml:2796(para) protocol.xml:2851(para) protocol.xml:2896(para)
#: protocol.xml:2941(para) protocol.xml:2986(para) protocol.xml:3041(para)
#: protocol.xml:3102(para) protocol.xml:3157(para) protocol.xml:3215(para)
#: protocol.xml:3270(para) protocol.xml:3423(para) protocol.xml:3448(para)
#: protocol.xml:3516(para) protocol.xml:3573(para) protocol.xml:3608(para)
#: protocol.xml:3705(para) protocol.xml:3752(para) protocol.xml:3787(para)
#: protocol.xml:3834(para) protocol.xml:3909(para) protocol.xml:3982(para)
#: protocol.xml:4053(para) protocol.xml:4126(para) protocol.xml:4184(para)
#: protocol.xml:4219(para) protocol.xml:4285(para) protocol.xml:4342(para)
#: protocol.xml:4377(para) protocol.xml:4502(para) protocol.xml:4564(para)
#: protocol.xml:4608(para) protocol.xml:4643(para) protocol.xml:4709(para)
#: protocol.xml:4774(para) protocol.xml:4832(para) protocol.xml:4886(para)
#: protocol.xml:4970(para) protocol.xml:5007(para) protocol.xml:5053(para)
#: protocol.xml:5088(para) protocol.xml:5134(para) protocol.xml:5183(para)
#: protocol.xml:5310(para) protocol.xml:5378(para) protocol.xml:5412(para)
#: protocol.xml:5450(para) protocol.xml:5587(para) protocol.xml:5622(para)
msgid "Length of message contents in bytes, including self."
msgstr "Длина содержимого сообщения в байтах, включая само поле длины."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2669(term)
msgid "Int32(0)"
msgstr "Int32(0)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2673(para)
msgid "Specifies that the authentication was successful."
msgstr "Показывает, что проверка подлинности прошла успешно."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2686(term)
msgid "AuthenticationKerberosV5 (B)"
msgstr "AuthenticationKerberosV5 (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2714(term)
msgid "Int32(2)"
msgstr "Int32(2)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2718(para)
msgid "Specifies that Kerberos V5 authentication is required."
msgstr ""
"Указывает, что требуется проверка подлинности по протоколу Kerberos V5."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2730(term)
msgid "AuthenticationCleartextPassword (B)"
msgstr "AuthenticationCleartextPassword (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2758(term)
msgid "Int32(3)"
msgstr "Int32(3)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2762(para)
msgid "Specifies that a clear-text password is required."
msgstr "Указывает, что требуется пароль, передаваемый открытым текстом."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2774(term)
msgid "AuthenticationMD5Password (B)"
msgstr "AuthenticationMD5Password (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2792(term) protocol.xml:3163(term) protocol.xml:3211(term)
msgid "Int32(12)"
msgstr "Int32(12)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2802(term) protocol.xml:5130(term)
msgid "Int32(5)"
msgstr "Int32(5)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2806(para)
msgid "Specifies that an MD5-encrypted password is required."
msgstr "Указывает, что требуется пароль, преобразованный в хеш MD5."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2812(term)
msgid "Byte4"
msgstr "Byte4"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2816(para)
msgid "The salt to use when encrypting the password."
msgstr "Значение соли, с которым должен хешироваться пароль."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2829(term)
msgid "AuthenticationSCMCredential (B)"
msgstr "AuthenticationSCMCredential (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2857(term)
msgid "Int32(6)"
msgstr "Int32(6)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2861(para)
msgid "Specifies that an SCM credentials message is required."
msgstr "Указывает, что требуется сообщение с учётными данными SCM."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2874(term)
msgid "AuthenticationGSS (B)"
msgstr "AuthenticationGSS (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2902(term)
msgid "Int32(7)"
msgstr "Int32(7)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2906(para)
msgid "Specifies that GSSAPI authentication is required."
msgstr "Указывает, что требуется проверка подлинности на базе GSSAPI."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2919(term)
msgid "AuthenticationSSPI (B)"
msgstr "AuthenticationSSPI (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2947(term)
msgid "Int32(9)"
msgstr "Int32(9)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2951(para)
msgid "Specifies that SSPI authentication is required."
msgstr "Указывает, что требуется проверка подлинности на базе SSPI."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2964(term)
msgid "AuthenticationGSSContinue (B)"
msgstr "AuthenticationGSSContinue (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:2996(para)
msgid "Specifies that this message contains GSSAPI or SSPI data."
msgstr "Указывает, что это сообщение содержит данные GSSAPI или SSPI."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3006(para)
msgid "GSSAPI or SSPI authentication data."
msgstr "Данные аутентификации для GSSAPI или SSPI."

#. +> REL_10
#: protocol.xml:3019(term)
msgid "AuthenticationSASL (B)"
msgstr "AuthenticationSASL (B)"

#. +> REL_10
#: protocol.xml:3047(term)
msgid "Int32(10)"
msgstr "Int32(10)"

#. +> REL_10
#: protocol.xml:3051(para)
msgid "Specifies that SASL authentication is required."
msgstr "Указывает, что требуется проверка подлинности на базе SASL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3063(term) protocol.xml:3276(term) protocol.xml:3287(term)
#: protocol.xml:3533(term) protocol.xml:3614(term) protocol.xml:3793(term)
#: protocol.xml:4143(term) protocol.xml:4246(term) protocol.xml:4291(term)
#: protocol.xml:4670(term) protocol.xml:4725(term) protocol.xml:4735(term)
#: protocol.xml:4838(term) protocol.xml:4848(term) protocol.xml:4892(term)
#: protocol.xml:4903(term) protocol.xml:5013(term) protocol.xml:5094(term)
#: protocol.xml:5202(term) protocol.xml:5316(term) protocol.xml:5477(term)
#: protocol.xml:5548(term) protocol.xml:6078(term) protocol.xml:6127(term)
#: protocol.xml:6137(term) protocol.xml:6184(term) protocol.xml:6248(term)
#: protocol.xml:6258(term)
msgid "String"
msgstr "String"

#. +> REL_10
#: protocol.xml:3067(para)
msgid "Name of a SASL authentication mechanism."
msgstr "Имя механизма аутентификации SASL."

#. +> REL_10
#: protocol.xml:3023(para)
msgid ""
"<placeholder-1/> The message body is a list of SASL authentication "
"mechanisms, in the server's order of preference. A zero byte is required as "
"terminator after the last authentication mechanism name. For each mechanism, "
"there is the following: <placeholder-2/>"
msgstr ""
"<placeholder-1/> Тело сообщения содержит список механизмов аутентификации "
"SASL, в порядке предпочтений сервера. За последним именем механизма "
"аутентификации должен идти завершающий нулевой байт. Для каждого механизма "
"передаётся: <placeholder-2/>"

#. +> REL_10
#: protocol.xml:3080(term)
msgid "AuthenticationSASLContinue (B)"
msgstr "AuthenticationSASLContinue (B)"

#. +> REL_10
#: protocol.xml:3108(term)
msgid "Int32(11)"
msgstr "Int32(11)"

#. +> REL_10
#: protocol.xml:3112(para)
msgid "Specifies that this message contains a SASL challenge."
msgstr "Указывает, что это сообщение содержит данные вызова SASL."

#. +> REL_10
#: protocol.xml:3122(para)
msgid "SASL data, specific to the SASL mechanism being used."
msgstr "Данные SASL, специфичные для применяемого механизма SASL."

#. +> REL_10
#: protocol.xml:3135(term)
msgid "AuthenticationSASLFinal (B)"
msgstr "AuthenticationSASLFinal (B)"

#. +> REL_10
#: protocol.xml:3167(para)
msgid "Specifies that SASL authentication has completed."
msgstr "Указывает, что аутентификация SASL завершена."

#. +> REL_10
#: protocol.xml:3177(para)
msgid ""
"SASL outcome \"additional data\", specific to the SASL mechanism being used."
msgstr ""
"«Дополнительные данные» результата SASL, специфичные для применяемого "
"механизма SASL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3191(term)
msgid "BackendKeyData (B)"
msgstr "BackendKeyData (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3199(term) protocol.xml:6360(term) protocol.xml:6463(term)
msgid "Byte1('K')"
msgstr "Byte1('K')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3203(para)
msgid ""
"Identifies the message as cancellation key data. The frontend must save "
"these values if it wishes to be able to issue CancelRequest messages later."
msgstr ""
"Указывает, что это сообщение содержит ключевые данные для отмены запросов. "
"Клиент должен сохранить эти данные, если ему нужна возможность впоследствии "
"выдавать сообщения CancelRequest."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3225(para)
msgid "The process ID of this backend."
msgstr "PID обслуживающего процесса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3235(para)
msgid "The secret key of this backend."
msgstr "Секретный ключ обслуживающего процесса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3248(term)
msgid "Bind (F)"
msgstr "Bind (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3256(term) protocol.xml:5938(term)
msgid "Byte1('B')"
msgstr "Byte1('B')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3260(para)
msgid "Identifies the message as a Bind command."
msgstr "Указывает, что это сообщение представляет команду Bind."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3280(para)
msgid ""
"The name of the destination portal (an empty string selects the unnamed "
"portal)."
msgstr "Имя целевого портала (пустая строка выбирает безымянный портал)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3291(para)
msgid ""
"The name of the source prepared statement (an empty string selects the "
"unnamed prepared statement)."
msgstr ""
"Имя исходного подготовленного оператора (пустая строка выбирает безымянный "
"подготовленный оператор)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3298(term) protocol.xml:3325(term) protocol.xml:3367(term)
#: protocol.xml:3856(term) protocol.xml:3929(term) protocol.xml:4002(term)
#: protocol.xml:4059(term) protocol.xml:4393(term) protocol.xml:4420(term)
#: protocol.xml:4462(term) protocol.xml:4780(term) protocol.xml:4913(term)
#: protocol.xml:5189(term) protocol.xml:5223(term) protocol.xml:5244(term)
#: protocol.xml:5266(term) protocol.xml:6160(term) protocol.xml:6529(term)
msgid "Int16"
msgstr "Int16"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3302(para)
msgid ""
"The number of parameter format codes that follow (denoted <replaceable>C</"
"replaceable> below). This can be zero to indicate that there are no "
"parameters or that the parameters all use the default format (text); or one, "
"in which case the specified format code is applied to all parameters; or it "
"can equal the actual number of parameters."
msgstr ""
"Количество кодов форматов следующих параметров (обозначается ниже символом "
"<replaceable>C</replaceable>). Может быть нулевым, что показывает, что "
"параметры отсутствуют или все параметры передаются в формате по умолчанию "
"(текстовом); либо равняться одному, в этом случае указанный один код формата "
"применяется ко всем параметрам; либо может равняться действительному "
"количеству параметров."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3314(term) protocol.xml:4409(term)
msgid "Int16[<replaceable>C</replaceable>]"
msgstr "Int16[<replaceable>C</replaceable>]"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3318(para)
msgid ""
"The parameter format codes. Each must presently be zero (text) or one "
"(binary)."
msgstr ""
"Коды форматов параметров. В настоящее время допускаются коды ноль (текстовый "
"формат) и один (двоичный)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3329(para)
msgid ""
"The number of parameter values that follow (possibly zero). This must match "
"the number of parameters needed by the query."
msgstr ""
"Количество следующих значений параметров (может быть нулевым). Оно должно "
"совпадать с количеством параметров, требующихся для запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3343(para)
msgid ""
"The length of the parameter value, in bytes (this count does not include "
"itself). Can be zero. As a special case, -1 indicates a NULL parameter "
"value. No value bytes follow in the NULL case."
msgstr ""
"Длина значения параметра, в байтах (само поле длины не считается). Может "
"быть нулевой. В качестве особого значения, -1 представляет значение NULL. В "
"случае с NULL никакие байты значений далее не следуют."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3356(para)
msgid ""
"The value of the parameter, in the format indicated by the associated format "
"code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение параметра в формате, определённом соответствующим кодом формата. "
"Переменная <replaceable>n</replaceable> задаёт длину значения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3371(para)
msgid ""
"The number of result-column format codes that follow (denoted "
"<replaceable>R</replaceable> below). This can be zero to indicate that there "
"are no result columns or that the result columns should all use the default "
"format (text); or one, in which case the specified format code is applied to "
"all result columns (if any); or it can equal the actual number of result "
"columns of the query."
msgstr ""
"Количество кодов формата для следующих столбцов результата (обозначается "
"ниже символом <replaceable>R</replaceable>). Может быть нулевым, что "
"показывает, что столбцы результата отсутствуют или для всех столбцов должен "
"использоваться формат по умолчанию (текстовый), либо равняться одному, в "
"этом случае указанный один код формата применяется ко всем столбцам (если "
"они есть), либо может равняться действительному количеству столбцов "
"результата запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3384(term)
msgid "Int16[<replaceable>R</replaceable>]"
msgstr "Int16[<replaceable>R</replaceable>]"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3388(para)
msgid ""
"The result-column format codes. Each must presently be zero (text) or one "
"(binary)."
msgstr ""
"Коды форматов столбцов результата. В настоящее время допускаются коды ноль "
"(текстовый формат) и один (двоичный)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3252(para)
msgid ""
"<placeholder-1/> Next, the following pair of fields appear for each "
"parameter: <placeholder-2/> After the last parameter, the following fields "
"appear: <placeholder-3/>"
msgstr ""
"<placeholder-1/> Затем для каждого параметра идёт следующая пара полей: "
"<placeholder-2/> За последним параметром идут следующие поля: <placeholder-3/"
">"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3401(term)
msgid "BindComplete (B)"
msgstr "BindComplete (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3409(term)
msgid "Byte1('2')"
msgstr "Byte1('2')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3413(para)
msgid "Identifies the message as a Bind-complete indicator."
msgstr "Указывает, что это сообщение, сигнализирующее о завершении Bind."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3419(term) protocol.xml:3569(term) protocol.xml:3748(term)
#: protocol.xml:4180(term) protocol.xml:4338(term) protocol.xml:4604(term)
#: protocol.xml:4966(term) protocol.xml:5049(term) protocol.xml:5583(term)
#: protocol.xml:5618(term)
msgid "Int32(4)"
msgstr "Int32(4)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3436(term)
msgid "CancelRequest (F)"
msgstr "CancelRequest (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3444(term)
msgid "Int32(16)"
msgstr "Int32(16)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3454(term)
msgid "Int32(80877102)"
msgstr "Int32(80877102)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3458(para)
msgid ""
"The cancel request code. The value is chosen to contain <literal>1234</"
"literal> in the most significant 16 bits, and <literal>5678</literal> in the "
"least significant 16 bits. (To avoid confusion, this code must not be the "
"same as any protocol version number.)"
msgstr ""
"Код запроса отмены. Это специально выбранное значение содержит "
"<literal>1234</literal> в старших 16 битах и <literal>5678</literal> в "
"младших 16 битах. (Во избежание неоднозначности этот код не должен совпадать "
"с номером версии протокола.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3471(para)
msgid "The process ID of the target backend."
msgstr "PID целевого обслуживающего процесса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3481(para)
msgid "The secret key for the target backend."
msgstr "Секретный ключ целевого обслуживающего процесса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3494(term)
msgid "Close (F)"
msgstr "Close (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3502(term) protocol.xml:3594(term) protocol.xml:5993(term)
msgid "Byte1('C')"
msgstr "Byte1('C')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3506(para)
msgid "Identifies the message as a Close command."
msgstr "Указывает, что это сообщение представляет команду Close."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3526(para)
msgid ""
"'<literal>S</literal>' to close a prepared statement; or '<literal>P</"
"literal>' to close a portal."
msgstr ""
"'<literal>S</literal>' для закрытия подготовленного оператора, '<literal>P</"
"literal>' для закрытия портала."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3537(para)
msgid ""
"The name of the prepared statement or portal to close (an empty string "
"selects the unnamed prepared statement or portal)."
msgstr ""
"Имя подготовленного оператора или портала, который должен быть закрыт "
"(пустая строка выбирает безымянный подготовленный оператор или портал)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3551(term)
msgid "CloseComplete (B)"
msgstr "CloseComplete (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3559(term)
msgid "Byte1('3')"
msgstr "Byte1('3')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3563(para)
msgid "Identifies the message as a Close-complete indicator."
msgstr "Указывает, что это сообщение, сигнализирующее о завершении Close."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3586(term)
msgid "CommandComplete (B)"
msgstr "CommandComplete (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3598(para)
msgid "Identifies the message as a command-completed response."
msgstr "Указывает, что это сообщение об успешном завершении команды."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3618(para)
msgid ""
"The command tag. This is usually a single word that identifies which SQL "
"command was completed."
msgstr ""
"Тег команды. Обычно это одно слово, обозначающее завершённую команду SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3623(para)
msgid ""
"For an <command>INSERT</command> command, the tag is <literal>INSERT "
"<replaceable>oid</replaceable> <replaceable>rows</replaceable></literal>, "
"where <replaceable>rows</replaceable> is the number of rows inserted. "
"<replaceable>oid</replaceable> is the object ID of the inserted row if "
"<replaceable>rows</replaceable> is 1 and the target table has OIDs; "
"otherwise <replaceable>oid</replaceable> is 0."
msgstr ""
"Для команды <command>INSERT</command> в качестве тега передаётся "
"<literal>INSERT <replaceable>oid</replaceable> <replaceable>строк</"
"replaceable></literal>, где <replaceable>строк</replaceable> — количество "
"вставленных строк. В поле <replaceable>oid</replaceable> передаётся "
"идентификатор объекта вставленной строки, если число <replaceable>строк</"
"replaceable> равно 1 и в целевой таблице содержатся OID; в противном случае "
"вместо <replaceable>oid</replaceable> передаётся 0."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3634(para)
msgid ""
"For a <command>DELETE</command> command, the tag is <literal>DELETE "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows deleted."
msgstr ""
"Для команды <command>DELETE</command> в качестве тега передаётся "
"<literal>DELETE <replaceable>строк</replaceable></literal>, где "
"<replaceable>строк</replaceable> — количество удалённых строк."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3640(para)
msgid ""
"For an <command>UPDATE</command> command, the tag is <literal>UPDATE "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows updated."
msgstr ""
"Для команды <command>UPDATE</command> в качестве тега передаётся "
"<literal>UPDATE <replaceable>строк</replaceable></literal>, где "
"<replaceable>строк</replaceable> — количество изменённых строк."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3646(para)
msgid ""
"For a <command>SELECT</command> or <command>CREATE TABLE AS</command> "
"command, the tag is <literal>SELECT <replaceable>rows</replaceable></"
"literal> where <replaceable>rows</replaceable> is the number of rows "
"retrieved."
msgstr ""
"Для команды <command>SELECT</command> или <command>CREATE TABLE AS</command> "
"в качестве тега передаётся <literal>SELECT <replaceable>строк</replaceable></"
"literal>, где <replaceable>строк</replaceable> — число полученных строк."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3652(para)
msgid ""
"For a <command>MOVE</command> command, the tag is <literal>MOVE "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows the cursor's position has been changed by."
msgstr ""
"Для команды <command>MOVE</command> в качестве тега передаётся <literal>MOVE "
"<replaceable>строк</replaceable></literal>, где <replaceable>строк</"
"replaceable> — количество строк, на которое изменилась позиция курсора."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3659(para)
msgid ""
"For a <command>FETCH</command> command, the tag is <literal>FETCH "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows that have been retrieved from the cursor."
msgstr ""
"Для команды <command>FETCH</command> в качестве тега передаётся "
"<literal>FETCH <replaceable>строк</replaceable></literal>, где "
"<replaceable>строк</replaceable> — количество строк, полученное через курсор."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3666(para)
msgid ""
"For a <command>COPY</command> command, the tag is <literal>COPY "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows copied. (Note: the row count appears only "
"in <productname>PostgreSQL</productname> 8.2 and later.)"
msgstr ""
"Для команды <command>COPY</command> в качестве тега передаётся <literal>COPY "
"<replaceable>строк</replaceable></literal>, где <replaceable>строк</"
"replaceable> — количество скопированных строк. (Заметьте: число строк "
"выводится, начиная только с <productname>PostgreSQL</productname> 8.2.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3684(term)
msgid "CopyData (F &amp; B)"
msgstr "CopyData (F &amp; B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3691(term)
msgid "Byte1('d')"
msgstr "Byte1('d')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3695(para)
msgid "Identifies the message as <command>COPY</command> data."
msgstr ""
"Указывает, что в этом сообщении передаются данные <command>COPY</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3715(para)
msgid ""
"Data that forms part of a <command>COPY</command> data stream. Messages sent "
"from the backend will always correspond to single data rows, but messages "
"sent by frontends might divide the data stream arbitrarily."
msgstr ""
"Данные, образующие часть информационного потока <command>COPY</command>. "
"Сообщения от сервера всегда соответствуют отдельным строкам данных, но "
"сообщения, передаваемые клиентами, могут разделять поток произвольным "
"образом."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3730(term)
msgid "CopyDone (F &amp; B)"
msgstr "CopyDone (F &amp; B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3738(term)
msgid "Byte1('c')"
msgstr "Byte1('c')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3742(para)
msgid "Identifies the message as a <command>COPY</command>-complete indicator."
msgstr ""
"Указывает, что это сообщение, сигнализирующее о завершении <command>COPY</"
"command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3765(term)
msgid "CopyFail (F)"
msgstr "CopyFail (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3773(term)
msgid "Byte1('f')"
msgstr "Byte1('f')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3777(para)
msgid "Identifies the message as a <command>COPY</command>-failure indicator."
msgstr ""
"Указывает, что это сообщение, сигнализирующее об ошибке операции "
"<command>COPY</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3797(para)
msgid "An error message to report as the cause of failure."
msgstr "Сообщение об ошибке, описывающее причину сбоя операции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3810(term)
msgid "CopyInResponse (B)"
msgstr "CopyInResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3818(term)
msgid "Byte1('G')"
msgstr "Byte1('G')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3822(para)
msgid ""
"Identifies the message as a Start Copy In response. The frontend must now "
"send copy-in data (if not prepared to do so, send a CopyFail message)."
msgstr ""
"Указывает, что это сообщение является ответом на запуск входящего "
"копирования. Получив его, клиент начинает передавать данные на вход операции "
"копирования (если клиент не готов к этому, он передаёт сообщение CopyFail)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3840(term) protocol.xml:3915(term) protocol.xml:3988(term)
#: protocol.xml:6003(term) protocol.xml:6148(term) protocol.xml:6173(term)
msgid "Int8"
msgstr "Int8"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3844(para) protocol.xml:3919(para) protocol.xml:3992(para)
msgid ""
"0 indicates the overall <command>COPY</command> format is textual (rows "
"separated by newlines, columns separated by separator characters, etc). 1 "
"indicates the overall copy format is binary (similar to DataRow format). See "
"<xref linkend=\"sql-copy\"/> for more information."
msgstr ""
"Значение 0 указывает, что для всей операции <command>COPY</command> "
"применяется текстовый формат (строки разделяются символами новой строки, "
"столбцы разделяются символами-разделителями и т. д.). Значение 1 указывает, "
"что для всей операции копирования применяется двоичный формат (подобный "
"формату DataRow). За дополнительными сведениями обратитесь к <xref remap="
"\"3\" linkend=\"sql-copy\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3860(para) protocol.xml:3933(para) protocol.xml:4006(para)
msgid ""
"The number of columns in the data to be copied (denoted <replaceable>N</"
"replaceable> below)."
msgstr ""
"Количество столбцов в копируемых данных (ниже обозначается символом "
"<replaceable>N</replaceable>)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3867(term) protocol.xml:3940(term) protocol.xml:4013(term)
msgid "Int16[<replaceable>N</replaceable>]"
msgstr "Int16[<replaceable>N</replaceable>]"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3871(para) protocol.xml:3944(para) protocol.xml:4017(para)
msgid ""
"The format codes to be used for each column. Each must presently be zero "
"(text) or one (binary). All must be zero if the overall copy format is "
"textual."
msgstr ""
"Коды формата для каждого столбца. В настоящее время допускаются коды ноль "
"(текстовый формат) и один (двоичный). Если общий формат копирования — "
"текстовый, все эти коды должны быть нулевыми."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3886(term)
msgid "CopyOutResponse (B)"
msgstr "CopyOutResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3894(term) protocol.xml:4328(term)
msgid "Byte1('H')"
msgstr "Byte1('H')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3898(para)
msgid ""
"Identifies the message as a Start Copy Out response. This message will be "
"followed by copy-out data."
msgstr ""
"Указывает, что это сообщение является ответом на запуск исходящего "
"копирования. За этим сообщением следуют данные, исходящие со стороны сервера."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3959(term)
msgid "CopyBothResponse (B)"
msgstr "CopyBothResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3967(term)
msgid "Byte1('W')"
msgstr "Byte1('W')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:3971(para)
msgid ""
"Identifies the message as a Start Copy Both response. This message is used "
"only for Streaming Replication."
msgstr ""
"Указывает, что это сообщение является ответом на запуск двустороннего "
"копирования. Это сообщение используется только для потоковой репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4032(term)
msgid "DataRow (B)"
msgstr "DataRow (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4039(term) protocol.xml:4112(term) protocol.xml:6441(term)
msgid "Byte1('D')"
msgstr "Byte1('D')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4043(para)
msgid "Identifies the message as a data row."
msgstr "Указывает, что в этом сообщении передаётся строка данных."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4063(para)
msgid "The number of column values that follow (possibly zero)."
msgstr "Количество последующих значений столбцов (может быть нулевым)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4076(para)
msgid ""
"The length of the column value, in bytes (this count does not include "
"itself). Can be zero. As a special case, -1 indicates a NULL column value. "
"No value bytes follow in the NULL case."
msgstr ""
"Длина значения столбца, в байтах (само поле длины не считается). Может быть "
"нулевой. В качестве особого значения, -1 представляет значение NULL. В "
"случае с NULL никакие байты значений далее не следуют."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4089(para)
msgid ""
"The value of the column, in the format indicated by the associated format "
"code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение столбца в формате, определённом соответствующим кодом формата. "
"Переменная <replaceable>n</replaceable> задаёт длину значения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4036(para)
msgid ""
"<placeholder-1/> Next, the following pair of fields appear for each column: "
"<placeholder-2/>"
msgstr ""
"<placeholder-1/> Затем для каждого столбца идёт следующая пара полей: "
"<placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4104(term)
msgid "Describe (F)"
msgstr "Describe (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4116(para)
msgid "Identifies the message as a Describe command."
msgstr "Указывает, что это сообщение представляет команду Describe."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4136(para)
msgid ""
"'<literal>S</literal>' to describe a prepared statement; or '<literal>P</"
"literal>' to describe a portal."
msgstr ""
"'<literal>S</literal>' для получения описания подготовленного оператора, "
"'<literal>P</literal>' — портала."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4147(para)
msgid ""
"The name of the prepared statement or portal to describe (an empty string "
"selects the unnamed prepared statement or portal)."
msgstr ""
"Имя подготовленного оператора или портала, описание которого запрашивается "
"(пустая строка выбирает безымянный подготовленный оператор или портал)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4161(term)
msgid "EmptyQueryResponse (B)"
msgstr "EmptyQueryResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4169(term) protocol.xml:6282(term)
msgid "Byte1('I')"
msgstr "Byte1('I')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4173(para)
msgid ""
"Identifies the message as a response to an empty query string. (This "
"substitutes for CommandComplete.)"
msgstr ""
"Указывает, что это сообщение является ответом на пустую строку запроса. (Это "
"сообщение заменяет CommandComplete.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4197(term)
msgid "ErrorResponse (B)"
msgstr "ErrorResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4205(term) protocol.xml:4271(term)
msgid "Byte1('E')"
msgstr "Byte1('E')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4209(para)
msgid "Identifies the message as an error."
msgstr "Указывает, что это сообщение ошибки."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4234(para) protocol.xml:4658(para)
msgid ""
"A code identifying the field type; if zero, this is the message terminator "
"and no string follows. The presently defined field types are listed in <xref "
"linkend=\"protocol-error-fields\"/>. Since more field types might be added "
"in future, frontends should silently ignore fields of unrecognized type."
msgstr ""
"Код, задающий тип поля; ноль обозначает конец сообщения, после которого "
"ничего нет. Типы полей, определённые в настоящее время, перечислены в <xref "
"remap=\"6\" linkend=\"protocol-error-fields\"/>. Так как в будущем могут "
"появиться другие типы полей, клиенты должны просто игнорировать поля "
"нераспознанного типа."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4250(para) protocol.xml:4674(para)
msgid "The field value."
msgstr "Значение поля."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4201(para) protocol.xml:4625(para)
msgid ""
"<placeholder-1/> The message body consists of one or more identified fields, "
"followed by a zero byte as a terminator. Fields can appear in any order. For "
"each field there is the following: <placeholder-2/>"
msgstr ""
"<placeholder-1/> Тело сообщения состоит из одного или нескольких "
"определённых полей, за которыми в качестве завершающего следует нулевой "
"байт. Поля могут идти в любом порядке. Для каждого поля передаётся: "
"<placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4263(term)
msgid "Execute (F)"
msgstr "Execute (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4275(para)
msgid "Identifies the message as an Execute command."
msgstr "Указывает, что это сообщение представляет команду Execute."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4295(para)
msgid ""
"The name of the portal to execute (an empty string selects the unnamed "
"portal)."
msgstr ""
"Имя портала, подлежащего выполнению (пустая строка выбирает безымянный "
"портал)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4306(para)
msgid ""
"Maximum number of rows to return, if portal contains a query that returns "
"rows (ignored otherwise). Zero denotes <quote>no limit</quote>."
msgstr ""
"Максимальное число строк, которое должно быть возвращено, если портал "
"содержит запрос, возвращающий строки (в противном случае игнорируется). Ноль "
"означает <quote>без ограничения</quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4320(term)
msgid "Flush (F)"
msgstr "Flush (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4332(para)
msgid "Identifies the message as a Flush command."
msgstr "Указывает, что это сообщение представляет команду Flush."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4355(term)
msgid "FunctionCall (F)"
msgstr "FunctionCall (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4363(term)
msgid "Byte1('F')"
msgstr "Byte1('F')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4367(para)
msgid "Identifies the message as a function call."
msgstr "Указывает, что это сообщение представляет вызов функции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4387(para)
msgid "Specifies the object ID of the function to call."
msgstr "Задаёт идентификатор объекта вызываемой функции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4397(para)
msgid ""
"The number of argument format codes that follow (denoted <replaceable>C</"
"replaceable> below). This can be zero to indicate that there are no "
"arguments or that the arguments all use the default format (text); or one, "
"in which case the specified format code is applied to all arguments; or it "
"can equal the actual number of arguments."
msgstr ""
"Количество кодов форматов следующих аргументов (обозначается ниже символом "
"<replaceable>C</replaceable>). Может быть нулевым, что показывает, что "
"аргументы отсутствуют или все аргументы передаются в формате по умолчанию "
"(текстовом); либо равняться одному, в этом случае указанный один код формата "
"применяется ко всем аргументами, либо может равняться действительному "
"количеству аргументов."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4413(para)
msgid ""
"The argument format codes. Each must presently be zero (text) or one "
"(binary)."
msgstr ""
"Коды форматов аргументов. В настоящее время допускаются коды ноль (текстовый "
"формат) и один (двоичный)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4424(para)
msgid "Specifies the number of arguments being supplied to the function."
msgstr "Задаёт число аргументов, передаваемых функции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4438(para)
msgid ""
"The length of the argument value, in bytes (this count does not include "
"itself). Can be zero. As a special case, -1 indicates a NULL argument value. "
"No value bytes follow in the NULL case."
msgstr ""
"Длина значения аргумента, в байтах (само поле длины не считается). Может "
"быть нулевой. В качестве особого значения, -1 представляет значение NULL. В "
"случае с NULL никакие байты значений далее не следуют."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4451(para)
msgid ""
"The value of the argument, in the format indicated by the associated format "
"code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение аргумента, в формате, определённом соответствующим кодом формата. "
"Переменная <replaceable>n</replaceable> задаёт длину значения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4466(para)
msgid ""
"The format code for the function result. Must presently be zero (text) or "
"one (binary)."
msgstr ""
"Код формата результата функции. В настоящее время допускается код ноль "
"(текстовый формат) и один (двоичный)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4359(para)
msgid ""
"<placeholder-1/> Next, the following pair of fields appear for each "
"argument: <placeholder-2/> After the last argument, the following field "
"appears: <placeholder-3/>"
msgstr ""
"<placeholder-1/> Затем для каждого аргумента идёт следующая пара полей: "
"<placeholder-2/> За последним аргументом идут следующие поля: <placeholder-3/"
">"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4480(term)
msgid "FunctionCallResponse (B)"
msgstr "FunctionCallResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4488(term)
msgid "Byte1('V')"
msgstr "Byte1('V')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4492(para)
msgid "Identifies the message as a function call result."
msgstr "Указывает, что в этом сообщении передаётся результат вызова функции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4512(para)
msgid ""
"The length of the function result value, in bytes (this count does not "
"include itself). Can be zero. As a special case, -1 indicates a NULL "
"function result. No value bytes follow in the NULL case."
msgstr ""
"Длина значения результата функции, в байтах (само поле длины не считается). "
"Может быть нулевой. В качестве особого значения, -1 представляет значение "
"NULL. В случае с NULL никакие байты значения далее не следуют."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4525(para)
msgid ""
"The value of the function result, in the format indicated by the associated "
"format code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение результата функции в формате, определённом соответствующим кодом "
"формата. Переменная <replaceable>n</replaceable> задаёт длину значения."

#. +> REL_10
#: protocol.xml:4540(term)
msgid "GSSResponse (F)"
msgstr "GSSResponse (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4548(term) protocol.xml:4991(term) protocol.xml:5294(term)
#: protocol.xml:5362(term)
msgid "Byte1('p')"
msgstr "Byte1('p')"

#. +> REL_10
#: protocol.xml:4552(para)
msgid ""
"Identifies the message as a GSSAPI or SSPI response. Note that this is also "
"used for SASL and password response messages. The exact message type can be "
"deduced from the context."
msgstr ""
"Обозначает это сообщение как ответ GSSAPI или SSPI. Заметьте, что оно также "
"применяется для ответов SASL и при аутентификации по паролю. Точный тип "
"сообщения можно определить из контекста."

#. +> REL_10
#: protocol.xml:4574(para)
msgid "GSSAPI/SSPI specific message data."
msgstr "Данные сообщения, специфичные для GSSAPI/SSPI."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4586(term)
msgid "NoData (B)"
msgstr "NoData (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4594(term) protocol.xml:6542(term)
msgid "Byte1('n')"
msgstr "Byte1('n')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4598(para)
msgid "Identifies the message as a no-data indicator."
msgstr "Указывает, что это сообщение сигнализирует об отсутствии данных."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4621(term)
msgid "NoticeResponse (B)"
msgstr "NoticeResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4629(term) protocol.xml:6303(term) protocol.xml:6400(term)
msgid "Byte1('N')"
msgstr "Byte1('N')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4633(para)
msgid "Identifies the message as a notice."
msgstr "Указывает, что это сообщение представляет замечание."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4687(term)
msgid "NotificationResponse (B)"
msgstr "NotificationResponse (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4695(term)
msgid "Byte1('A')"
msgstr "Byte1('A')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4699(para)
msgid "Identifies the message as a notification response."
msgstr "Указывает, что это сообщение представляет уведомление."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4719(para)
msgid "The process ID of the notifying backend process."
msgstr "PID обслуживающего процесса, отправляющего уведомление."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4729(para)
msgid "The name of the channel that the notify has been raised on."
msgstr "Имя канала, для которого было выдано уведомление."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4739(para)
msgid "The <quote>payload</quote> string passed from the notifying process."
msgstr "Строка <quote>сообщения</quote>, сопровождающего уведомление."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4752(term)
msgid "ParameterDescription (B)"
msgstr "ParameterDescription (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4760(term) protocol.xml:6569(term)
msgid "Byte1('t')"
msgstr "Byte1('t')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4764(para)
msgid "Identifies the message as a parameter description."
msgstr "Указывает, что это сообщение представляет описание параметра."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4784(para)
msgid "The number of parameters used by the statement (can be zero)."
msgstr "Количество параметров для оператора (может быть нулевым)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4798(para)
msgid "Specifies the object ID of the parameter data type."
msgstr "Задаёт идентификатор объекта типа данных параметра."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4756(para) protocol.xml:4868(para)
msgid ""
"<placeholder-1/> Then, for each parameter, there is the following: "
"<placeholder-2/>"
msgstr ""
"<placeholder-1/> Затем для каждого параметра передаётся: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4810(term)
msgid "ParameterStatus (B)"
msgstr "ParameterStatus (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4818(term) protocol.xml:5573(term)
msgid "Byte1('S')"
msgstr "Byte1('S')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4822(para)
msgid "Identifies the message as a run-time parameter status report."
msgstr ""
"Указывает, что в этом сообщении передаётся состояние параметра времени "
"выполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4842(para)
msgid "The name of the run-time parameter being reported."
msgstr "Имя параметра времени выполнения, состояние которого передаётся."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4852(para)
msgid "The current value of the parameter."
msgstr "Текущее значение параметра."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4864(term)
msgid "Parse (F)"
msgstr "Parse (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4872(term)
msgid "Byte1('P')"
msgstr "Byte1('P')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4876(para)
msgid "Identifies the message as a Parse command."
msgstr "Указывает, что это сообщение представляет команду Parse."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4896(para)
msgid ""
"The name of the destination prepared statement (an empty string selects the "
"unnamed prepared statement)."
msgstr ""
"Имя целевого подготовленного оператора (пустая строка выбирает безымянный "
"подготовленный оператор)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4907(para)
msgid "The query string to be parsed."
msgstr "Строка запроса, которая должна быть разобрана."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4917(para)
msgid ""
"The number of parameter data types specified (can be zero). Note that this "
"is not an indication of the number of parameters that might appear in the "
"query string, only the number that the frontend wants to prespecify types "
"for."
msgstr ""
"Количество типов параметров (может быть нулевым). Заметьте, что это значение "
"представляет не число параметров, которые могут фигурировать в строке "
"запроса, а число параметров, для которых клиент хочет предопределить типы."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4934(para)
msgid ""
"Specifies the object ID of the parameter data type. Placing a zero here is "
"equivalent to leaving the type unspecified."
msgstr ""
"Задаёт идентификатор объекта типа данных параметра. Указание нулевого "
"значения равносильно отсутствию указания типа."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4948(term)
msgid "ParseComplete (B)"
msgstr "ParseComplete (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4956(term)
msgid "Byte1('1')"
msgstr "Byte1('1')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4960(para)
msgid "Identifies the message as a Parse-complete indicator."
msgstr "Указывает, что это сообщение, сигнализирующее о завершении Parse."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:4983(term)
msgid "PasswordMessage (F)"
msgstr "PasswordMessage (F)"

#. +> REL_10
#: protocol.xml:4995(para)
msgid ""
"Identifies the message as a password response. Note that this is also used "
"for GSSAPI, SSPI and SASL response messages. The exact message type can be "
"deduced from the context."
msgstr ""
"Обозначает это сообщение как ответ SASL. Заметьте, что оно также применяется "
"для ответов GSSAPI, SSPI и SASL. Точный тип сообщения можно определить из "
"контекста."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5017(para)
msgid "The password (encrypted, if requested)."
msgstr "Пароль (зашифрованный, если требуется)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5029(term)
msgid "PortalSuspended (B)"
msgstr "PortalSuspended (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5037(term)
msgid "Byte1('s')"
msgstr "Byte1('s')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5041(para)
msgid ""
"Identifies the message as a portal-suspended indicator. Note this only "
"appears if an Execute message's row-count limit was reached."
msgstr ""
"Указывает, что это сообщение сигнализирует о приостановке портала. Заметьте, "
"что оно выдаётся только при достижении ограничения числа строк, заданного в "
"сообщении Execute."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5066(term)
msgid "Query (F)"
msgstr "Query (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5074(term)
msgid "Byte1('Q')"
msgstr "Byte1('Q')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5078(para)
msgid "Identifies the message as a simple query."
msgstr "Указывает, что это сообщение представляет простой запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5098(para)
msgid "The query string itself."
msgstr "Собственно строка запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5111(term)
msgid "ReadyForQuery (B)"
msgstr "ReadyForQuery (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5119(term)
msgid "Byte1('Z')"
msgstr "Byte1('Z')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5123(para)
msgid ""
"Identifies the message type. ReadyForQuery is sent whenever the backend is "
"ready for a new query cycle."
msgstr ""
"Определяет тип сообщения. Сообщение ReadyForQuery передаётся, когда сервер "
"готов к новому циклу запросов."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5144(para)
msgid ""
"Current backend transaction status indicator. Possible values are "
"'<literal>I</literal>' if idle (not in a transaction block); '<literal>T</"
"literal>' if in a transaction block; or '<literal>E</literal>' if in a "
"failed transaction block (queries will be rejected until block is ended)."
msgstr ""
"Индикатор текущего состояния транзакции на сервере. Возможные значения: "
"'<literal>I</literal>', транзакция неактивна (вне блока транзакции), "
"'<literal>T</literal>' в блоке транзакции, либо '<literal>E</literal>' в "
"блоке прерванной транзакции (запросы не будут обрабатываться до завершения "
"блока)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5161(term)
msgid "RowDescription (B)"
msgstr "RowDescription (B)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5169(term)
msgid "Byte1('T')"
msgstr "Byte1('T')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5173(para)
msgid "Identifies the message as a row description."
msgstr "Указывает, что это сообщение представляет описание строки."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5193(para)
msgid "Specifies the number of fields in a row (can be zero)."
msgstr "Задаёт количество полей в строке (может быть нулевым)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5206(para)
msgid "The field name."
msgstr "Имя поля."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5216(para)
msgid ""
"If the field can be identified as a column of a specific table, the object "
"ID of the table; otherwise zero."
msgstr ""
"Если поле связано со столбцом определённой таблицы, идентификатор объекта "
"этой таблицы; в противном случае — ноль."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5227(para)
msgid ""
"If the field can be identified as a column of a specific table, the "
"attribute number of the column; otherwise zero."
msgstr ""
"Если поле связано со столбцом определённой таблицы, номер атрибута для этого "
"столбца; в противном случае — ноль."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5238(para)
msgid "The object ID of the field's data type."
msgstr "Идентификатор объекта типа данных поля."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5248(para)
msgid ""
"The data type size (see <varname>pg_type.typlen</varname>). Note that "
"negative values denote variable-width types."
msgstr ""
"Размер типа данных (см. <varname>pg_type.typlen</varname>). Заметьте, что "
"отрицательные значения показывают, что тип имеет переменную длину."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5259(para)
msgid ""
"The type modifier (see <varname>pg_attribute.atttypmod</varname>). The "
"meaning of the modifier is type-specific."
msgstr ""
"Модификатор типа (см. <varname>pg_attribute.atttypmod</varname>). Смысл "
"этого модификатора зависит от типа."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5270(para)
msgid ""
"The format code being used for the field. Currently will be zero (text) or "
"one (binary). In a RowDescription returned from the statement variant of "
"Describe, the format code is not yet known and will always be zero."
msgstr ""
"Код формата, используемого для поля. В настоящее время допускаются коды ноль "
"(текстовый формат) и один (двоичный). В сообщении RowDescription, "
"возвращаемом вариацией Describe для оператора, код формата ещё не известен и "
"всегда будет нулевым."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5165(para)
msgid ""
"<placeholder-1/> Then, for each field, there is the following: "
"<placeholder-2/>"
msgstr "<placeholder-1/> Затем для каждого поля передаётся: <placeholder-2/>"

#. +> REL_10
#: protocol.xml:5286(term)
msgid "SASLInitialResponse (F)"
msgstr "SASLInitialResponse (F)"

#. +> REL_10
#: protocol.xml:5298(para)
msgid ""
"Identifies the message as an initial SASL response. Note that this is also "
"used for GSSAPI, SSPI and password response messages. The exact message type "
"is deduced from the context."
msgstr ""
"Обозначает это сообщение как начальный ответ SASL. Заметьте, что оно также "
"применяется для ответов GSSAPI, SSPI и при аутентификации по паролю. Точный "
"тип сообщения определяется из контекста."

#. +> REL_10
#: protocol.xml:5320(para)
msgid "Name of the SASL authentication mechanism that the client selected."
msgstr "Имя механизма аутентификации SASL, выбранного клиентом."

#. +> REL_10
#: protocol.xml:5331(para)
msgid ""
"Length of SASL mechanism specific \"Initial Client Response\" that follows, "
"or -1 if there is no Initial Response."
msgstr ""
"Длина последующего сообщения «Начальный ответ клиента», специфичного для "
"механизма SASL, или -1, если начального ответа нет."

#. +> REL_10
#: protocol.xml:5342(para)
msgid "SASL mechanism specific \"Initial Response\"."
msgstr "«Начальный ответ», специфичный для механизма SASL."

#. +> REL_10
#: protocol.xml:5354(term)
msgid "SASLResponse (F)"
msgstr "SASLResponse (F)"

#. +> REL_10
#: protocol.xml:5366(para)
msgid ""
"Identifies the message as a SASL response. Note that this is also used for "
"GSSAPI, SSPI and password response messages. The exact message type can be "
"deduced from the context."
msgstr ""
"Обозначает это сообщение как ответ SASL. Заметьте, что оно также применяется "
"для ответов GSSAPI, SSPI и при аутентификации по паролю. Точный тип "
"сообщения можно определить из контекста."

#. +> REL_10
#: protocol.xml:5388(para)
msgid "SASL mechanism specific message data."
msgstr "Данные сообщения, специфичные для механизма SASL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5400(term)
msgid "SSLRequest (F)"
msgstr "SSLRequest (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5418(term)
msgid "Int32(80877103)"
msgstr "Int32(80877103)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5422(para)
msgid ""
"The <acronym>SSL</acronym> request code. The value is chosen to contain "
"<literal>1234</literal> in the most significant 16 bits, and <literal>5679</"
"literal> in the least significant 16 bits. (To avoid confusion, this code "
"must not be the same as any protocol version number.)"
msgstr ""
"Код запроса <acronym>SSL</acronym>. Это специально выбранное значение "
"содержит <literal>1234</literal> в старших 16 битах и <literal>5679</"
"literal> в младших 16 битах. (Во избежание неоднозначности этот код не "
"должен совпадать с номером версии протокола.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5438(term)
msgid "StartupMessage (F)"
msgstr "StartupMessage (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5456(term)
msgid "Int32(196608)"
msgstr "Int32(196608)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5460(para)
msgid ""
"The protocol version number. The most significant 16 bits are the major "
"version number (3 for the protocol described here). The least significant 16 "
"bits are the minor version number (0 for the protocol described here)."
msgstr ""
"Номер версии протокола. В старших 16 битах задаётся старший номер версии (3 "
"для протокола, описываемого здесь). В младших 16 битах задаётся младший "
"номер версии (0 для протокола, описываемого здесь)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5487(literal)
msgid "user"
msgstr "user"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5490(para)
msgid "The database user name to connect as. Required; there is no default."
msgstr ""
"Имя пользователя баз данных, с которым выполняется подключение. Является "
"обязательным, значения по умолчанию нет."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5498(literal)
msgid "database"
msgstr "database"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5501(para)
msgid "The database to connect to. Defaults to the user name."
msgstr ""
"База данных, к которой выполняется подключение. По умолчанию подставляется "
"имя пользователя."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5508(literal)
msgid "options"
msgstr "options"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5511(para)
msgid ""
"Command-line arguments for the backend. (This is deprecated in favor of "
"setting individual run-time parameters.) Spaces within this string are "
"considered to separate arguments, unless escaped with a backslash (<literal>"
"\\</literal>); write <literal>\\\\</literal> to represent a literal "
"backslash."
msgstr ""
"Аргументы командной строки для обслуживающего процесса. (Этот способ "
"считается устаревшим; теперь следует устанавливать отдельные параметры "
"времени выполнения.) Пробелы в этой строке воспринимаются как разделяющие "
"аргументы, если перед ними нет обратной косой черты (<literal>\\</literal>); "
"чтобы представить обратную косую черту буквально, продублируйте её (<literal>"
"\\\\</literal>)."

#. +> REL_10
#: protocol.xml:5523(literal)
msgid "replication"
msgstr "replication"

#. +> REL_10
#: protocol.xml:5526(para)
msgid ""
"Used to connect in streaming replication mode, where a small set of "
"replication commands can be issued instead of SQL statements. Value can be "
"<literal>true</literal>, <literal>false</literal>, or <literal>database</"
"literal>, and the default is <literal>false</literal>. See <xref linkend="
"\"protocol-replication\"/> for details."
msgstr ""
"Используется для подключения в режиме потоковой репликации, в котором вместо "
"операторов SQL может выполняться небольшой набор команд репликации. "
"Допустимые значения: <literal>true</literal>, <literal>false</literal> (по "
"умолчанию) и <literal>database</literal>. За подробностями обратитесь к "
"<xref remap=\"3\" linkend=\"protocol-replication\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5481(para)
msgid ""
"The parameter name. Currently recognized names are: <placeholder-1/> In "
"addition to the above, any run-time parameter that can be set at backend "
"start time might be listed. Such settings will be applied during backend "
"start (after parsing the command-line arguments if any). The values will act "
"as session defaults."
msgstr ""
"Имя параметра. В настоящее время принимаются имена: <placeholder-1/> В "
"дополнение к этим параметрам можно установить любые параметры времени "
"выполнения, значение которых может быть задано во время запуска "
"обслуживающего процесса. Заданные значения будут применены при запуске "
"обслуживающего процесса (после разбора аргументов командной строки, если они "
"были переданы). Эти значения станут значениями по умолчанию в новом сеансе."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5552(para)
msgid "The parameter value."
msgstr "Значение параметра."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5442(para)
msgid ""
"<placeholder-1/> The protocol version number is followed by one or more "
"pairs of parameter name and value strings. A zero byte is required as a "
"terminator after the last name/value pair. Parameters can appear in any "
"order. <literal>user</literal> is required, others are optional. Each "
"parameter is specified as: <placeholder-2/>"
msgstr ""
"<placeholder-1/> За номером версии протокола следует одна или несколько пар "
"из имени параметра и строки значения. За последней парой имя/значение должен "
"следовать нулевой байт. Передаваться параметры могут в любом порядке. "
"Обязательным является только параметр <literal>user</literal>, остальные "
"могут отсутствовать. Каждый параметр задаётся так: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5565(term)
msgid "Sync (F)"
msgstr "Sync (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5577(para)
msgid "Identifies the message as a Sync command."
msgstr "Указывает, что это сообщение представляет команду Sync."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5600(term)
msgid "Terminate (F)"
msgstr "Terminate (F)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5608(term)
msgid "Byte1('X')"
msgstr "Byte1('X')"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5612(para)
msgid "Identifies the message as a termination."
msgstr "Указывает, что это сообщение завершает сеанс."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5640(title)
msgid "Error and Notice Message Fields"
msgstr "Поля сообщений с ошибками и замечаниями"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5642(para)
msgid ""
"This section describes the fields that can appear in ErrorResponse and "
"NoticeResponse messages. Each field type has a single-byte identification "
"token. Note that any given field type should appear at most once per message."
msgstr ""
"В этом разделе описываются поля, которые могут содержаться в сообщениях "
"ErrorResponse и NoticeResponse. Для каждого типа поля определён свой "
"идентификационный маркер. Заметьте, что в сообщении может содержаться поле "
"любого из этих типов, но не больше одного раза."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5653(literal)
msgid "S"
msgstr "S"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5656(para)
msgid ""
"Severity: the field contents are <literal>ERROR</literal>, <literal>FATAL</"
"literal>, or <literal>PANIC</literal> (in an error message), or "
"<literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal>, or <literal>LOG</literal> (in a notice "
"message), or a localized translation of one of these. Always present."
msgstr ""
"Важность: поле содержит <literal>ERROR</literal>, <literal>FATAL</literal> "
"или <literal>PANIC</literal> (в сообщении об ошибке), либо <literal>WARNING</"
"literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, "
"<literal>INFO</literal> или <literal>LOG</literal> (в сообщении с "
"замечанием), либо переведённые значения (ОШИБКА, ВАЖНО, ПАНИКА, "
"ПРЕДУПРЕЖДЕНИЕ, ЗАМЕЧАНИЕ, ОТЛАДКА, ИНФОРМАЦИЯ, СООБЩЕНИЕ, соответственно). "
"Это поле присутствует всегда."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5669(literal)
msgid "V"
msgstr "V"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5672(para)
msgid ""
"Severity: the field contents are <literal>ERROR</literal>, <literal>FATAL</"
"literal>, or <literal>PANIC</literal> (in an error message), or "
"<literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal>, or <literal>LOG</literal> (in a notice "
"message). This is identical to the <literal>S</literal> field except that "
"the contents are never localized. This is present only in messages generated "
"by <productname>PostgreSQL</productname> versions 9.6 and later."
msgstr ""
"Важность: поле содержит <literal>ERROR</literal>, <literal>FATAL</literal> "
"или <literal>PANIC</literal> (в сообщении об ошибке) либо <literal>WARNING</"
"literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, "
"<literal>INFO</literal> или <literal>LOG</literal> (в сообщении с "
"замечанием). Это поле подобно <literal>S</literal>, но его содержимое "
"никогда не переводится. Присутствует только в сообщениях, выдаваемых "
"<productname>PostgreSQL</productname> версии 9.6 и новее."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5688(literal)
msgid "C"
msgstr "C"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5691(para)
msgid ""
"Code: the SQLSTATE code for the error (see <xref linkend=\"errcodes-appendix"
"\"/>). Not localizable. Always present."
msgstr ""
"Код: код SQLSTATE выданной ошибки (см. <xref remap=\"4\" linkend=\"errcodes-"
"appendix\"/>). Не переводится на другие языки, присутствует всегда."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5700(literal)
msgid "M"
msgstr "M"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5703(para)
msgid ""
"Message: the primary human-readable error message. This should be accurate "
"but terse (typically one line). Always present."
msgstr ""
"Сообщение: основное сообщение об ошибке, предназначенное для человека. "
"Должно быть точным, но кратким (обычно в одну строку). Присутствует всегда."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5713(literal)
msgid "D"
msgstr "D"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5716(para)
msgid ""
"Detail: an optional secondary error message carrying more detail about the "
"problem. Might run to multiple lines."
msgstr ""
"Необязательное дополнительное сообщение об ошибке, передающее более "
"детальную информацию о проблеме. Может занимать несколько строк."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5725(literal)
msgid "H"
msgstr "H"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5728(para)
msgid ""
"Hint: an optional suggestion what to do about the problem. This is intended "
"to differ from Detail in that it offers advice (potentially inappropriate) "
"rather than hard facts. Might run to multiple lines."
msgstr ""
"Подсказка: необязательное предложение решения проблемы. Оно должно "
"отличаться от подробного описания тем, что предлагает совет (не обязательно "
"подходящий во всех случаях), а не сухие факты. Может располагаться в "
"нескольких строках."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5739(literal)
msgid "P"
msgstr "P"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5742(para)
msgid ""
"Position: the field value is a decimal ASCII integer, indicating an error "
"cursor position as an index into the original query string. The first "
"character has index 1, and positions are measured in characters not bytes."
msgstr ""
"Позиция: значение поля представляет целочисленное число в ASCII, указывающее "
"на положение ошибки в исходной строке запроса. Первый символ находится в "
"позиции 1, при этом позиции отсчитываются по символам, а не по байтам."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5753(literal)
msgid "p"
msgstr "p"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5756(para)
msgid ""
"Internal position: this is defined the same as the <literal>P</literal> "
"field, but it is used when the cursor position refers to an internally "
"generated command rather than the one submitted by the client. The "
"<literal>q</literal> field will always appear when this field appears."
msgstr ""
"Внутренняя позиция: она определяется так же, как поле <literal>P</literal>, "
"но отражает положение ошибки во внутренне сгенерированной команде, а не в "
"строке, переданной клиентом. Вместе с этим полем всегда присутствует поле "
"<literal>q</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5767(literal)
msgid "q"
msgstr "q"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5770(para)
msgid ""
"Internal query: the text of a failed internally-generated command. This "
"could be, for example, a SQL query issued by a PL/pgSQL function."
msgstr ""
"Внутренний запрос: текст внутренне сгенерированной команды, в которой "
"произошла ошибка. Это может быть, например, SQL-запрос, выполняемый функцией "
"на PL/pgSQL."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5779(literal)
msgid "W"
msgstr "W"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5782(para)
msgid ""
"Where: an indication of the context in which the error occurred. Presently "
"this includes a call stack traceback of active procedural language functions "
"and internally-generated queries. The trace is one entry per line, most "
"recent first."
msgstr ""
"Где: указывает на контекст, в котором произошла ошибка. В настоящее время "
"включает трассировку стека вызовов текущей функции на процедурном языке и "
"внутренне сгенерированных запросов. Записи трассировки разделяются по "
"строкам, вначале последняя."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5793(literal)
msgid "s"
msgstr "s"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5796(para)
msgid ""
"Schema name: if the error was associated with a specific database object, "
"the name of the schema containing that object, if any."
msgstr ""
"Имя схемы: если ошибка связана с некоторым объектом базы данных, это поле "
"содержит имя схемы, к которой относится объект (если такая есть)."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5805(literal)
msgid "t"
msgstr "t"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5808(para)
msgid ""
"Table name: if the error was associated with a specific table, the name of "
"the table. (Refer to the schema name field for the name of the table's "
"schema.)"
msgstr ""
"Имя таблицы: если ошибка связана с некоторой таблицей, это поле содержит имя "
"таблицы. (Узнать имя схемы таблицы можно из соответствующего отдельного "
"поля.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5818(literal)
msgid "c"
msgstr "c"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5821(para)
msgid ""
"Column name: if the error was associated with a specific table column, the "
"name of the column. (Refer to the schema and table name fields to identify "
"the table.)"
msgstr ""
"Имя столбца: если ошибка связана с некоторым столбцом таблицы, это поле "
"содержит имя столбца. (Идентифицировать таблицу можно, обратившись к полям, "
"содержащим имя таблицы и схемы.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5831(literal)
msgid "d"
msgstr "d"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5834(para)
msgid ""
"Data type name: if the error was associated with a specific data type, the "
"name of the data type. (Refer to the schema name field for the name of the "
"data type's schema.)"
msgstr ""
"Имя типа данных: если ошибка связана с некоторым типом данных, это поле "
"содержит имя типа. (Узнать имя схемы типа можно из соответствующего поля.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5844(literal)
msgid "n"
msgstr "n"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5847(para)
msgid ""
"Constraint name: if the error was associated with a specific constraint, the "
"name of the constraint. Refer to fields listed above for the associated "
"table or domain. (For this purpose, indexes are treated as constraints, even "
"if they weren't created with constraint syntax.)"
msgstr ""
"Имя ограничения: если ошибка связана с некоторым ограничением, это поле "
"содержит имя ограничения. Чтобы узнать, к какой таблице или домену она "
"относится, обратитесь к полям, описанным выше. (В данном контексте индексы "
"считаются ограничениями, даже если они были созданы не с синтаксисом "
"ограничений.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5859(literal)
msgid "F"
msgstr "F"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5862(para)
msgid ""
"File: the file name of the source-code location where the error was reported."
msgstr "Файл: имя файла с исходным кодом, в котором была обнаружена ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5871(literal)
msgid "L"
msgstr "L"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5874(para)
msgid ""
"Line: the line number of the source-code location where the error was "
"reported."
msgstr ""
"Строка: номер строки в исходном коде, в которой была обнаружена ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5883(literal)
msgid "R"
msgstr "R"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5886(para)
msgid "Routine: the name of the source-code routine reporting the error."
msgstr ""
"Программа: имя программы в исходном коде, в которой была обнаружена ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5895(para)
msgid ""
"The fields for schema name, table name, column name, data type name, and "
"constraint name are supplied only for a limited number of error types; see "
"<xref linkend=\"errcodes-appendix\"/>. Frontends should not assume that the "
"presence of any of these fields guarantees the presence of another field. "
"Core error sources observe the interrelationships noted above, but user-"
"defined functions may use these fields in other ways. In the same vein, "
"clients should not assume that these fields denote contemporary objects in "
"the current database."
msgstr ""
"Поля, содержащие имена схемы, таблицы, столбца, типа данных и ограничения, "
"выдаются только для ограниченного числа типов ошибок; см. <xref remap=\"4\" "
"linkend=\"errcodes-appendix\"/>. Клиенты не должны рассчитывать на то, что "
"присутствие одного из полей обязательно влечёт присутствие другого поля. "
"Системные источники ошибок устанавливают связь между ними, но "
"пользовательские функции могут использовать эти поля по-другому. Подобным "
"образом, клиенты не должны полагаться на то, что эти поля ссылаются на "
"актуальные объекты в текущей базе данных."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:5907(para)
msgid ""
"The client is responsible for formatting displayed information to meet its "
"needs; in particular it should break long lines as needed. Newline "
"characters appearing in the error message fields should be treated as "
"paragraph breaks, not line breaks."
msgstr ""
"Клиент отвечает за форматирование отображаемой информации в соответствии с "
"его нуждами; в частности, он должен разбивать длинные строки, как требуется. "
"Символы новой строки, встречающиеся в полях сообщения об ошибке, должны "
"обрабатываться, как разрывы абзацев, а не строк."

#. +> REL_10
#: protocol.xml:5917(title)
msgid "Logical Replication Message Formats"
msgstr "Форматы сообщений логической репликации"

#. +> REL_10
#: protocol.xml:5919(para)
msgid ""
"This section describes the detailed format of each logical replication "
"message. These messages are returned either by the replication slot SQL "
"interface or are sent by a walsender. In case of a walsender they are "
"encapsulated inside the replication protocol WAL messages as described in "
"<xref linkend=\"protocol-replication\"/> and generally obey same message "
"flow as physical replication."
msgstr ""
"В этом разделе подробно описывается формат каждого сообщения логической "
"репликации. Эти сообщения или выдаются через SQL-интерфейс слота репликации "
"или передаются процессом walsender. Когда их передаёт walsender, они "
"помещаются внутрь WAL-сообщений протокола репликации, описанных в <xref "
"remap=\"6\" linkend=\"protocol-replication\"/>, и в общем следуют тому же "
"потоку сообщений, что и сообщения физической репликации."

#. +> REL_10
#: protocol.xml:5930(term)
msgid "Begin"
msgstr "Begin"

#. +> REL_10
#: protocol.xml:5942(para)
msgid "Identifies the message as a begin message."
msgstr "Указывает, что это начальное сообщение."

#. +> REL_10
#: protocol.xml:5952(para)
msgid "The final LSN of the transaction."
msgstr "Окончательный LSN транзакции."

#. +> REL_10
#: protocol.xml:5962(para) protocol.xml:6037(para)
msgid ""
"Commit timestamp of the transaction. The value is in number of microseconds "
"since PostgreSQL epoch (2000-01-01)."
msgstr ""
"Время фиксации транзакции. Значение задаётся в микросекундах, прошедших с "
"начала эпохи PostgreSQL (2000-01-01)."

#. +> REL_10
#: protocol.xml:5973(para)
msgid "Xid of the transaction."
msgstr "Идентификатор транзакции."

#. +> REL_10
#: protocol.xml:5985(term)
msgid "Commit"
msgstr "Commit"

#. +> REL_10
#: protocol.xml:5997(para)
msgid "Identifies the message as a commit message."
msgstr "Указывает, что это сообщение о фиксации."

#. +> REL_10
#: protocol.xml:6007(para)
msgid "Flags; currently unused (must be 0)."
msgstr "Флаги; в настоящее время не используются (поле должно содержать 0)."

#. +> REL_10
#: protocol.xml:6017(para)
msgid "The LSN of the commit."
msgstr "LSN записи фиксации."

#. +> REL_10
#: protocol.xml:6027(para)
msgid "The end LSN of the transaction."
msgstr "Конечный LSN транзакции."

#. +> REL_10
#: protocol.xml:6050(term)
msgid "Origin"
msgstr "Origin"

#. +> REL_10
#: protocol.xml:6058(term) protocol.xml:6374(term) protocol.xml:6476(term)
msgid "Byte1('O')"
msgstr "Byte1('O')"

#. +> REL_10
#: protocol.xml:6062(para)
msgid "Identifies the message as an origin message."
msgstr "Указывает, что это сообщение об источнике."

#. +> REL_10
#: protocol.xml:6072(para)
msgid "The LSN of the commit on the origin server."
msgstr "LSN записи фиксации на сервере-источнике."

#. +> REL_10
#: protocol.xml:6082(para)
msgid "Name of the origin."
msgstr "Имя источника."

#. +> REL_10
#: protocol.xml:6091(para)
msgid ""
"Note that there can be multiple Origin messages inside a single transaction."
msgstr ""
"Заметьте, что внутри одной транзакции может быть несколько сообщений Origin."

#. +> REL_10
#: protocol.xml:6099(term)
msgid "Relation"
msgstr "Relation"

#. +> REL_10
#: protocol.xml:6111(para)
msgid "Identifies the message as a relation message."
msgstr "Указывает, что это сообщение об отношении."

#. +> REL_10
#: protocol.xml:6121(para)
msgid "ID of the relation."
msgstr "Идентификатор отношения."

#. +> REL_10
#: protocol.xml:6131(para) protocol.xml:6252(para)
msgid "Namespace (empty string for <literal>pg_catalog</literal>)."
msgstr "Пространство имён (пустая строка для <literal>pg_catalog</literal>)."

#. +> REL_10
#: protocol.xml:6141(para)
msgid "Relation name."
msgstr "Имя отношения."

#. +> REL_10
#: protocol.xml:6152(para)
msgid ""
"Replica identity setting for the relation (same as "
"<structfield>relreplident</structfield> in <structname>pg_class</"
"structname>)."
msgstr ""
"Свойство идентификации реплики для отношения (то же, что и "
"<structfield>relreplident</structfield> в <structname>pg_class</structname>)."

#. +> REL_10
#: protocol.xml:6164(para) protocol.xml:6533(para)
msgid "Number of columns."
msgstr "Число столбцов."

#. +> REL_10
#: protocol.xml:6177(para)
msgid ""
"Flags for the column. Currently can be either 0 for no flags or 1 which "
"marks the column as part of the key."
msgstr ""
"Флаги столбца. В настоящее время это может быть 0 (флагов нет) или 1 "
"(столбец помечается как часть ключа)."

#. +> REL_10
#: protocol.xml:6188(para)
msgid "Name of the column."
msgstr "Имя столбца."

#. +> REL_10
#: protocol.xml:6198(para)
msgid "ID of the column's data type."
msgstr "Идентификатор типа данных столбца."

#. +> REL_10
#: protocol.xml:6208(para)
msgid "Type modifier of the column (<structfield>atttypmod</structfield>)."
msgstr "Модификатор типа столбца (<structfield>atttypmod</structfield>)."

#. +> REL_10
#: protocol.xml:6103(para)
msgid ""
"<placeholder-1/> Next, the following message part appears for each column: "
"<placeholder-2/>"
msgstr ""
"<placeholder-1/> Затем для каждого столбца идёт следующий блок сообщения: "
"<placeholder-2/>"

#. +> REL_10
#: protocol.xml:6220(term)
msgid "Type"
msgstr "Тип"

#. +> REL_10
#: protocol.xml:6228(term)
msgid "Byte1('Y')"
msgstr "Byte1('Y')"

#. +> REL_10
#: protocol.xml:6232(para)
msgid "Identifies the message as a type message."
msgstr "Указывает, что это сообщение о типе."

#. +> REL_10
#: protocol.xml:6242(para)
msgid "ID of the data type."
msgstr "Идентификатор типа данных."

#. +> REL_10
#: protocol.xml:6262(para)
msgid "Name of the data type."
msgstr "Имя типа данных."

#. +> REL_10
#: protocol.xml:6274(term)
msgid "Insert"
msgstr "Insert"

#. +> REL_10
#: protocol.xml:6286(para)
msgid "Identifies the message as an insert message."
msgstr "Указывает, что это сообщение о добавлении данных."

#. +> REL_10
#: protocol.xml:6296(para) protocol.xml:6352(para) protocol.xml:6455(para)
msgid "ID of the relation corresponding to the ID in the relation message."
msgstr ""
"Идентификатор отношения, соответствующий идентификатору в сообщении об "
"отношении."

#. +> REL_10
#: protocol.xml:6307(para) protocol.xml:6404(para)
msgid "Identifies the following TupleData message as a new tuple."
msgstr "Обозначает следующее сообщение TupleData как содержащее новый кортеж."

#. +> REL_10
#: protocol.xml:6314(term) protocol.xml:6387(term) protocol.xml:6411(term)
#: protocol.xml:6489(term) protocol.xml:6521(term)
msgid "TupleData"
msgstr "TupleData"

#. +> REL_10
#: protocol.xml:6318(para)
msgid "TupleData message part representing the contents of new tuple."
msgstr "Блок сообщения TupleData, представляющий содержимое нового кортежа."

#. +> REL_10
#: protocol.xml:6330(term)
msgid "Update"
msgstr "Update"

#. +> REL_10
#: protocol.xml:6338(term)
msgid "Byte1('U')"
msgstr "Byte1('U')"

#. +> REL_10
#: protocol.xml:6342(para)
msgid "Identifies the message as an update message."
msgstr "Указывает, что это сообщение об изменении данных."

#. +> REL_10
#: protocol.xml:6364(para)
msgid ""
"Identifies the following TupleData submessage as a key. This field is "
"optional and is only present if the update changed data in any of the "
"column(s) that are part of the REPLICA IDENTITY index."
msgstr ""
"Указывает, что следующий блок TupleData содержит ключ. Это поле является "
"необязательным и присутствует, только если изменение затронуло столбцы, "
"являющиеся частью индекса REPLICA IDENTITY."

#. +> REL_10
#: protocol.xml:6378(para)
msgid ""
"Identifies the following TupleData submessage as an old tuple. This field is "
"optional and is only present if table in which the update happened has "
"REPLICA IDENTITY set to FULL."
msgstr ""
"Указывает, что следующий блок TupleData содержит старый кортеж. Это поле "
"является необязательным и присутствует, только если у таблицы, в которой "
"произошло изменение, свойство REPLICA IDENTITY равно FULL."

#. +> REL_10
#: protocol.xml:6391(para)
msgid ""
"TupleData message part representing the contents of the old tuple or primary "
"key. Only present if the previous 'O' or 'K' part is present."
msgstr ""
"Блок сообщения TupleData, представляющий содержимое старого кортежа или "
"первичного ключа. Присутствует, только если перед ним идёт признак 'O' или "
"'K'."

#. +> REL_10
#: protocol.xml:6415(para)
msgid "TupleData message part representing the contents of a new tuple."
msgstr "Блок сообщения TupleData, представляющий содержимое нового кортежа."

#. +> REL_10
#: protocol.xml:6424(para)
msgid ""
"The Update message may contain either a 'K' message part or an 'O' message "
"part or neither of them, but never both of them."
msgstr ""
"Сообщение Update может содержать либо блок 'K', либо блок 'O', либо ни один "
"из них, но не оба сразу."

#. +> REL_10
#: protocol.xml:6433(term)
msgid "Delete"
msgstr "Delete"

#. +> REL_10
#: protocol.xml:6445(para)
msgid "Identifies the message as a delete message."
msgstr "Указывает, что это сообщение об удалении данных."

#. +> REL_10
#: protocol.xml:6467(para)
msgid ""
"Identifies the following TupleData submessage as a key. This field is "
"present if the table in which the delete has happened uses an index as "
"REPLICA IDENTITY."
msgstr ""
"Указывает, что следующий блок TupleData содержит ключ. Это поле "
"присутствует, если таблица, в которой произошло удаление, использует индекс "
"в качестве REPLICA IDENTITY."

#. +> REL_10
#: protocol.xml:6480(para)
msgid ""
"Identifies the following TupleData message as a old tuple. This field is is "
"present if the table in which the delete has happened has REPLICA IDENTITY "
"set to FULL."
msgstr ""
"Указывает, что следующий блок TupleData содержит старый кортеж. Это поле "
"присутствует, если у таблицы, в которой произошло удаление, свойство REPLICA "
"IDENTITY равно FULL."

#. +> REL_10
#: protocol.xml:6493(para)
msgid ""
"TupleData message part representing the contents of the old tuple or primary "
"key, depending on the previous field."
msgstr ""
"Блок сообщения TupleData, представляющий содержимое старого кортежа или "
"первичного ключа, в зависимости от предыдущего поля."

#. +> REL_10
#: protocol.xml:6502(para)
msgid ""
"The Delete message may contain either a 'K' message part or an 'O' message "
"part, but never both of them."
msgstr ""
"Сообщение Delete может содержать либо блок 'K', либо блок 'O', но не оба "
"сразу."

#. +> REL_10
#: protocol.xml:6512(para)
msgid "The following message parts are shared by the above messages."
msgstr "Описанные выше сообщения имеют следующие общие блоки."

#. +> REL_10
#: protocol.xml:6546(para)
msgid "Identifies the data as NULL value."
msgstr "Обозначает данные как значение NULL."

#. +> REL_10
#: protocol.xml:6555(term)
msgid "Byte1('u')"
msgstr "Byte1('u')"

#. +> REL_10
#: protocol.xml:6559(para)
msgid "Identifies unchanged TOASTed value (the actual value is not sent)."
msgstr "Обозначает неизменённое значение TOAST (само значение не передаётся)."

#. +> REL_10
#: protocol.xml:6573(para)
msgid "Identifies the data as text formatted value."
msgstr "Обозначает данные как значение в текстовом формате."

#. +> REL_10
#: protocol.xml:6583(para)
msgid "Length of the column value."
msgstr "Длина значения столбца."

#. +> REL_10
#: protocol.xml:6593(para)
msgid ""
"The value of the column, in text format. (A future release might support "
"additional formats.) <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение столбца в текстовом формате. (В будущих выпусках могут "
"поддерживаться и другие форматы.) Здесь <replaceable>n</replaceable> — "
"заданная выше длина."

#. +> REL_10
#: protocol.xml:6525(para)
msgid ""
"<placeholder-1/> Next, one of the following submessages appears for each "
"column: <placeholder-2/> Or <placeholder-3/> Or <placeholder-4/>"
msgstr ""
"<placeholder-1/> Затем для каждого столбца следует один из следующих блоков "
"для каждого столбца: <placeholder-2/> Или <placeholder-3/> Или "
"<placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6612(title)
msgid "Summary of Changes since Protocol 2.0"
msgstr "Сводка изменений по сравнению с протоколом версии 2.0"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6614(para)
msgid ""
"This section provides a quick checklist of changes, for the benefit of "
"developers trying to update existing client libraries to protocol 3.0."
msgstr ""
"В этом разделе представлен краткий список изменений к сведению "
"разработчиков, желающих модернизировать существующие клиентские библиотеки "
"до протокола 3.0."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6619(para)
msgid ""
"The initial startup packet uses a flexible list-of-strings format instead of "
"a fixed format. Notice that session default values for run-time parameters "
"can now be specified directly in the startup packet. (Actually, you could do "
"that before using the <literal>options</literal> field, but given the "
"limited width of <literal>options</literal> and the lack of any way to quote "
"whitespace in the values, it wasn't a very safe technique.)"
msgstr ""
"В начальном стартовом пакете вместо фиксированного формата применяется "
"гибкий формат списка строк. Заметьте, что теперь сеансовые значения по "
"умолчанию для параметров времени выполнения можно задать непосредственно в "
"стартовом пакете. (Вообще, это можно было делать и раньше, используя поле "
"<literal>options</literal>, но из-за ограниченного размера <literal>options</"
"literal> и невозможности задавать значения с пробелами, это вариант был не "
"очень безопасным.)"

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6628(para)
msgid ""
"All messages now have a length count immediately following the message type "
"byte (except for startup packets, which have no type byte). Also note that "
"PasswordMessage now has a type byte."
msgstr ""
"Во всех сообщениях непосредственно за байтом типа сообщения следует счётчик "
"длины (за исключением стартовых пакетов, в которых нет байта типа). Также "
"заметьте, что байт типа теперь есть в сообщении PasswordMessage."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6634(para)
msgid ""
"ErrorResponse and NoticeResponse ('<literal>E</literal>' and '<literal>N</"
"literal>') messages now contain multiple fields, from which the client code "
"can assemble an error message of the desired level of verbosity. Note that "
"individual fields will typically not end with a newline, whereas the single "
"string sent in the older protocol always did."
msgstr ""
"Сообщения ErrorResponse и NoticeResponse ('<literal>E</literal>' и "
"'<literal>N</literal>') могут содержать несколько полей, из которых "
"клиентский код может собрать сообщение об ошибке желаемого уровня "
"детализации. Заметьте, что текст отдельных полей обычно не завершается новой "
"строкой, тогда как в старом протоколе одиночная строка всегда завершалась "
"так."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6642(para)
msgid ""
"The ReadyForQuery ('<literal>Z</literal>') message includes a transaction "
"status indicator."
msgstr ""
"Сообщение ReadyForQuery ('<literal>Z</literal>') включает индикатор статуса "
"транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6647(para)
msgid ""
"The distinction between BinaryRow and DataRow message types is gone; the "
"single DataRow message type serves for returning data in all formats. Note "
"that the layout of DataRow has changed to make it easier to parse. Also, the "
"representation of binary values has changed: it is no longer directly tied "
"to the server's internal representation."
msgstr ""
"Различие между типами данных BinaryRow и DataRow ушло; один тип сообщений "
"DataRow позволяет возвращать данные во всех форматах. Заметьте, что формат "
"DataRow был изменён для упрощения его разбора. Также изменилось "
"представление двоичных значений: оно больше не привязано к внутреннему "
"представлению сервера."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6655(para)
msgid ""
"There is a new <quote>extended query</quote> sub-protocol, which adds the "
"frontend message types Parse, Bind, Execute, Describe, Close, Flush, and "
"Sync, and the backend message types ParseComplete, BindComplete, "
"PortalSuspended, ParameterDescription, NoData, and CloseComplete. Existing "
"clients do not have to concern themselves with this sub-protocol, but making "
"use of it might allow improvements in performance or functionality."
msgstr ""
"В протоколе появился новый подраздел <quote>расширенный запрос</quote>, в "
"котором добавлены типы сообщений для команд Parse, Bind, Execute, Describe, "
"Close, Flush и Sync, а также типы серверных сообщений ParseComplete, "
"BindComplete, PortalSuspended, ParameterDescription, NoData и CloseComplete. "
"Существующие клиенты могут не подстраиваться под этот раздел протокола, но "
"если они задействует его, это позволит улучшить производительность или "
"функциональность."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6664(para)
msgid ""
"<command>COPY</command> data is now encapsulated into CopyData and CopyDone "
"messages. There is a well-defined way to recover from errors during "
"<command>COPY</command>. The special <quote><literal>\\.</literal></quote> "
"last line is not needed anymore, and is not sent during <command>COPY OUT</"
"command>. (It is still recognized as a terminator during <command>COPY IN</"
"command>, but its use is deprecated and will eventually be removed.) Binary "
"<command>COPY</command> is supported. The CopyInResponse and CopyOutResponse "
"messages include fields indicating the number of columns and the format of "
"each column."
msgstr ""
"Данные <command>COPY</command> теперь внедряются в сообщения CopyData и "
"CopyDone. Есть чётко определённый способ восстановить работу в случае ошибок "
"в процессе <command>COPY</command>. Специальная последняя строка "
"<quote><literal>\\.</literal></quote> больше не нужна, она не передаётся при "
"выполнении <command>COPY OUT</command>. (Она по-прежнему воспринимается как "
"завершающая последовательность в потоке <command>COPY IN</command>, но это "
"считается устаревшим способом завершения, и в конце концов он будет "
"исключён.) Поддерживается <command>COPY</command> в двоичном режиме. "
"Сообщения CopyInResponse и CopyOutResponse включают поля, определяющие число "
"столбцов и формат каждого столбца."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6675(para)
msgid ""
"The layout of FunctionCall and FunctionCallResponse messages has changed. "
"FunctionCall can now support passing NULL arguments to functions. It also "
"can handle passing parameters and retrieving results in either text or "
"binary format. There is no longer any reason to consider FunctionCall a "
"potential security hole, since it does not offer direct access to internal "
"server data representations."
msgstr ""
"Изменилась структура сообщений FunctionCall и FunctionCallResponse. "
"Сообщение FunctionCall теперь позволяет передавать функциям аргументы NULL. "
"Ещё в нём могут передаваться параметры и получаться результаты в текстовом "
"или двоичном формате. Не осталось повода считать сообщение FunctionCall "
"потенциально небезопасным, так как оно не даёт прямого доступа к внутренней "
"презентации данных на сервере."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6684(para)
msgid ""
"The backend sends ParameterStatus ('<literal>S</literal>') messages during "
"connection startup for all parameters it considers interesting to the client "
"library. Subsequently, a ParameterStatus message is sent whenever the active "
"value changes for any of these parameters."
msgstr ""
"Сервер отправляет сообщения ParameterStatus ('<literal>S</literal>') при "
"попытке подключения для всех параметров, которые он считает интересными для "
"клиентской библиотеки. Как следствие, при любом изменении активного значения "
"одного из этих параметров также выдаётся сообщение ParameterStatus."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6691(para)
msgid ""
"The RowDescription ('<literal>T</literal>') message carries new table OID "
"and column number fields for each column of the described row. It also shows "
"the format code for each column."
msgstr ""
"Сообщение RowDescription ('<literal>T</literal>') содержит поля с OID "
"таблицы и номером столбца для каждого столбца описываемой строки. В нём "
"также передаётся код формата для каждого столбца."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6697(para)
msgid ""
"The CursorResponse ('<literal>P</literal>') message is no longer generated "
"by the backend."
msgstr ""
"Сервер более не выдаёт сообщение CursorResponse ('<literal>P</literal>')."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6702(para)
msgid ""
"The NotificationResponse ('<literal>A</literal>') message has an additional "
"string field, which can carry a <quote>payload</quote> string passed from "
"the <command>NOTIFY</command> event sender."
msgstr ""
"В сообщении NotificationResponse ('<literal>A</literal>') добавилось ещё "
"одно строковое поле, в котором может передаваться строка <quote>сообщения</"
"quote> от отправителя события <command>NOTIFY</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:6708(para)
msgid ""
"The EmptyQueryResponse ('<literal>I</literal>') message used to include an "
"empty string parameter; this has been removed."
msgstr ""
"Раньше сообщение EmptyQueryResponse ('<literal>I</literal>') включало пустой "
"строковый параметр; теперь он ликвидирован."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: protocol.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: protocol.xml:666(para)
msgid ""
"A parameter data type can be left unspecified by setting it to zero, or by "
"making the array of parameter type OIDs shorter than the number of parameter "
"symbols (<literal>$</literal><replaceable>n</replaceable>) used in the query "
"string. Another special case is that a parameter's type can be specified as "
"<type>void</type> (that is, the OID of the <type>void</type> pseudotype). "
"This is meant to allow parameter symbols to be used for function parameters "
"that are actually OUT parameters. Ordinarily there is no context in which a "
"<type>void</type> parameter could be used, but if such a parameter symbol "
"appears in a function's parameter list, it is effectively ignored. For "
"example, a function call such as <literal>foo($1,$2,$3,$4)</literal> could "
"match a function with two IN and two OUT arguments, if <literal>$3</literal> "
"and <literal>$4</literal> are specified as having type <type>void</type>."
msgstr ""
"Тип данных параметра можно оставить неопределённым, задав для него значение "
"ноль, либо сделав массив с OID типов параметров короче, чем набор символов "
"параметров (<literal>$</literal><replaceable>n</replaceable>), используемых "
"в строке запроса. Другой особый случай — передача типа параметра как "
"<type>void</type> (то есть передача OID псевдотипа <type>void</type>). Это "
"предусмотрено для того, чтобы символы параметров можно было использовать для "
"параметров функций, на самом деле представляющих собой параметры OUT. Обычно "
"параметр <type>void</type> нельзя использовать ни в каком контексте, но если "
"такой параметр фигурирует в списке параметров функции, он фактически "
"игнорируется. Например, вызову функции <literal>foo($1,$2,$3,$4)</literal> "
"может соответствовать функция с аргументами IN и двумя OUT, если аргументы "
"<literal>$3</literal> и <literal>$4</literal> объявлены как имеющие тип "
"<type>void</type>."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1374(para)
msgid ""
"Current xlog flush location. Useful to get a known location in the "
"transaction log where streaming can start."
msgstr ""
"Текущее положение сохранённых данных в xlog. Позволяет узнать, с какой "
"позиции в журнале транзакций может начаться потоковая передача."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1438(term)
msgid ""
"<literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter"
"\">slot_name</replaceable> { <literal>PHYSICAL</literal> "
"[ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable "
"class=\"parameter\">output_plugin</replaceable> } <placeholder-1/>"
msgstr ""
"<literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter"
"\">имя_слота</replaceable> { <literal>PHYSICAL</literal> "
"[ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable "
"class=\"parameter\">модуль_вывода</replaceable> } <placeholder-1/>"

#. +> REL9_6_3 REL9_6
#: protocol.xml:1487(para)
msgid ""
"Instructs server to start streaming WAL, starting at WAL position "
"<replaceable class=\"parameter\">XXX/XXX</replaceable>. If "
"<literal>TIMELINE</literal> option is specified, streaming starts on "
"timeline <replaceable class=\"parameter\">tli</replaceable>; otherwise, the "
"server's current timeline is selected. The server can reply with an error, "
"for example if the requested section of WAL has already been recycled. On "
"success, server responds with a CopyBothResponse message, and then starts to "
"stream WAL to the frontend."
msgstr ""
"Указывает серверу начать потоковую передачу WAL, начиная с позиции "
"<replaceable class=\"parameter\">XXX/XXX</replaceable> в WAL. Если "
"указывается параметр <literal>TIMELINE</literal>, передача начинается на "
"линии времени <replaceable class=\"parameter\">лин_врем</replaceable>, иначе "
"выбирается текущая линия времени сервера. Сервер может вернуть в ответ "
"ошибку, например, если запрошенный сегмент WAL уже потерян. Если проблем не "
"возникает, сервер возвращает сообщение CopyBothResponse, а затем начинает "
"передавать поток WAL клиенту."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1515(para)
msgid ""
"After streaming all the WAL on a timeline that is not the latest one, the "
"server will end streaming by exiting the COPY mode. When the client "
"acknowledges this by also exiting COPY mode, the server sends a result set "
"with one row and two columns, indicating the next timeline in this server's "
"history. The first column is the next timeline's ID (type <type>int8</"
"type>), and the second column is the WAL position where the switch happened "
"(type <type>text</type>). Usually, the switch position is the end of the WAL "
"that was streamed, but there are corner cases where the server can send some "
"WAL from the old timeline that it has not itself replayed before promoting. "
"Finally, the server sends CommandComplete message, and is ready to accept a "
"new command."
msgstr ""
"После передачи всех записей WAL на линии времени, не являющейся текущей, "
"сервер завершает потоковую передачу, выходя из режима копирования. Когда "
"клиент подтверждает завершение передачи, также выходя из режима копирования, "
"сервер возвращает набор результатов в одной строке с двумя столбцами, "
"сообщая таким образом о следующей линии времени в истории сервера. В первом "
"столбце передаётся идентификатор следующей линии времени (типа <type>int8</"
"type>), а во втором — позиция в WAL, в которой произошло переключение (типа "
"<type>text</type>). Обычно в этой же позиции завершается передача потока "
"WAL, но возможны исключения, когда сервер может передавать записи WAL из "
"старой линии времени, которые он сам ещё не воспроизвёл до переключения. "
"Наконец сервер передаёт сообщение CommandComplete, после чего он готов "
"принять следующую команду."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1786(para)
msgid ""
"The standby's current xmin. This may be 0, if the standby is sending "
"notification that Hot Standby feedback will no longer be sent on this "
"connection. Later non-zero messages may reinitiate the feedback mechanism."
msgstr ""
"Текущее значение xmin данного резервного сервера. Может быть нулевым; это "
"означает, что резервный сервер уведомляет о том, что сообщения обратной "
"связи горячего резерва больше не будут передаваться через это подключение. "
"Последующие ненулевые значения могут восстановить работу механизма обратной "
"связи."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1799(para)
msgid "The standby's current epoch."
msgstr "Текущая эпоха резервного сервера."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1815(para)
msgid ""
"Instructs server to start streaming WAL for logical replication, starting at "
"WAL position <replaceable class=\"parameter\">XXX/XXX</replaceable>. The "
"server can reply with an error, for example if the requested section of WAL "
"has already been recycled. On success, server responds with a "
"CopyBothResponse message, and then starts to stream WAL to the frontend."
msgstr ""
"Указывает серверу начать потоковую передачу WAL для логической репликации, "
"начиная с позиции <replaceable class=\"parameter\">XXX/XXX</replaceable> в "
"WAL. Сервер может вернуть в ответ ошибку, например, если запрошенный сегмент "
"WAL уже потерян. Если проблем не возникает, сервер возвращает сообщение "
"CopyBothResponse, а затем начинает передавать поток WAL клиенту."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1879(para)
msgid ""
"Drops a replication slot, freeing any reserved server-side resources. If the "
"slot is currently in use by an active connection, this command fails."
msgstr ""
"Удаляет слот репликации, что приводит к освобождению всех зарезервированных "
"для него ресурсов на стороне сервера. Если слот в настоящий момент "
"используется активным соединением, команда завершается ошибкой."

#. +> REL9_6_3 REL9_6
#: protocol.xml:1948(para)
msgid ""
"Include the necessary WAL segments in the backup. This will include all the "
"files between start and stop backup in the <filename>pg_xlog</filename> "
"directory of the base directory tar file."
msgstr ""
"Включает в резервную копию необходимые сегменты WAL. При этом в подкаталог "
"<filename>pg_xlog</filename> архива базового каталога будут включены все "
"файлы с начала до конца копирования."

#. +> REL9_6_3 REL9_6
#: protocol.xml:2072(para)
msgid ""
"various temporary files created during the operation of the PostgreSQL server"
msgstr ""
"различные временные файлы, создаваемые в процессе работы сервером PostgreSQL"

#. +> REL9_6_3 REL9_6
#: protocol.xml:2085(para)
msgid "<filename>pg_replslot</filename> is copied as an empty directory."
msgstr "<filename>pg_replslot</filename> копируется в виде пустого каталога."

#. +> REL9_6_3 REL9_6
#: protocol.xml:2090(para)
msgid ""
"Files other than regular files and directories, such as symbolic links and "
"special device files, are skipped. (Symbolic links in <filename>pg_tblspc</"
"filename> are maintained.)"
msgstr ""
"файлы, отличные от обычных файлов и каталогов, например, символические "
"ссылки и файлы специальных устройств, пропускаются. (Символические ссылки в "
"<filename>pg_tblspc</filename> сохраняются.)"

#. +> REL9_6_3 REL9_6
#: protocol.xml:4342(para)
msgid ""
"Identifies the message as a password response. Note that this is also used "
"for GSSAPI and SSPI response messages (which is really a design error, since "
"the contained data is not a null-terminated string in that case, but can be "
"arbitrary binary data)."
msgstr ""
"Указывает, что это сообщение, в котором передаётся пароль. Заметьте, что оно "
"также применяется для передачи сообщений обмена GSSAPI и SSPI (это на самом "
"деле ошибка проектирования, так как в этом случае сообщение может содержать "
"произвольные двоичные данные, а не текстовую строку, оканчивающуюся нулём)."
