# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: protocol.xml:5(title)
msgid "Frontend/Backend Protocol"
msgstr "Клиент-серверный протокол"

#: protocol.xml:7(indexterm)
msgid "<primary>protocol</primary> <secondary>frontend-backend</secondary>"
msgstr "<primary>протокол</primary> <secondary>клиент-серверный</secondary>"

#: protocol.xml:12(para)
msgid ""
"<productname>PostgreSQL</productname> uses a message-based protocol for "
"communication between frontends and backends (clients and servers). The "
"protocol is supported over <acronym>TCP/IP</acronym> and also over Unix-"
"domain sockets. Port number 5432 has been registered with IANA as the "
"customary TCP port number for servers supporting this protocol, but in "
"practice any non-privileged port number can be used."
msgstr ""
"Клиенты и серверы <productname>PostgreSQL</productname> взаимодействуют друг "
"с другом, используя специальный протокол, основанный на сообщениях. Этот "
"протокол поддерживается для соединений по <acronym>TCP/IP</acronym> и через "
"доменные сокеты Unix. Для серверов, поддерживающих этот протокол, в IANA "
"зарезервирован номер TCP-порта 5432, но на практике можно задействовать "
"любой порт, не требующий особых привилегий."

#: protocol.xml:21(para)
msgid ""
"This document describes version 3.0 of the protocol, implemented in "
"<productname>PostgreSQL</productname> 7.4 and later. For descriptions of the "
"earlier protocol versions, see previous releases of the "
"<productname>PostgreSQL</productname> documentation. A single server can "
"support multiple protocol versions. The initial startup-request message "
"tells the server which protocol version the client is attempting to use, and "
"then the server follows that protocol if it is able."
msgstr ""
"В этой документации описана версия 3.0 этого протокола, реализованная в "
"<productname>PostgreSQL</productname> версии 7.4 и новее. За описанием "
"предыдущих версий протокола обратитесь к документации более ранних выпусков "
"<productname>PostgreSQL</productname>. Один сервер способен поддерживать "
"несколько версий протокола. Из стартового сообщения при установлении "
"соединения сервер узнаёт, какую версию протокола пытается использовать "
"клиент, и если сервер поддерживает запрошенную версию, он продолжает обмен "
"по этому протоколу."

#: protocol.xml:32(para)
msgid ""
"In order to serve multiple clients efficiently, the server launches a new "
"<quote>backend</quote> process for each client. In the current "
"implementation, a new child process is created immediately after an incoming "
"connection is detected. This is transparent to the protocol, however. For "
"purposes of the protocol, the terms <quote>backend</quote> and "
"<quote>server</quote> are interchangeable; likewise <quote>frontend</quote> "
"and <quote>client</quote> are interchangeable."
msgstr ""
"Чтобы эффективно обслуживать множество клиентов, сервер запускает отдельный "
"<quote>обслуживающий</quote> процесс для каждого клиента. В текущей "
"реализации новый дочерний процесс запускается немедленно после обнаружения "
"входящего подключения. Однако это происходит прозрачно для протокола. С "
"точки зрения протокола, термины <quote>обслуживающий процесс</quote>, "
"<quote>процесс заднего плана</quote> и <quote>сервер</quote> "
"взаимозаменяемы, как и <quote>приложение переднего плана</quote> и "
"<quote>клиент</quote>."

#: protocol.xml:44(title)
msgid "Overview"
msgstr "Обзор"

#: protocol.xml:46(para)
msgid ""
"The protocol has separate phases for startup and normal operation. In the "
"startup phase, the frontend opens a connection to the server and "
"authenticates itself to the satisfaction of the server. (This might involve "
"a single message, or multiple messages depending on the authentication "
"method being used.) If all goes well, the server then sends status "
"information to the frontend, and finally enters normal operation. Except for "
"the initial startup-request message, this part of the protocol is driven by "
"the server."
msgstr ""
"В протоколе выделены отдельные фазы для запуска и обычных операций. На "
"стадии запуска клиент устанавливает подключение к серверу и должен "
"удовлетворить сервер, подтвердив свою подлинность. (Для этого может "
"потребоваться одно или несколько сообщений, в зависимости от применяемого "
"метода проверки подлинности.) Если всё проходит успешно, сервер сообщает "
"клиенту о текущем состоянии, а затем переходит к обычной работе. Не считая "
"начального стартового сообщения, в этой фазе протокола ведущую роль играет "
"сервер."

#: protocol.xml:57(para)
msgid ""
"During normal operation, the frontend sends queries and other commands to "
"the backend, and the backend sends back query results and other responses. "
"There are a few cases (such as <command>NOTIFY</command>) wherein the "
"backend will send unsolicited messages, but for the most part this portion "
"of a session is driven by frontend requests."
msgstr ""
"В ходе обычной работы клиент передаёт запросы и другие команды серверу, а "
"сервер возвращает результаты запросов и другие ответы. В некоторых случаях "
"(например, с <command>NOTIFY</command>) сервер передаёт клиенту сообщения по "
"своей инициативе, но по большей части эта фаза сеанса управляется запросами "
"клиента."

#: protocol.xml:66(para)
msgid ""
"Termination of the session is normally by frontend choice, but can be forced "
"by the backend in certain cases. In any case, when the backend closes the "
"connection, it will roll back any open (incomplete) transaction before "
"exiting."
msgstr ""
"Завершение сеанса обычно происходит по желанию клиента, но в некоторых "
"случаях и сервер может принудительно завершить сеанс. В любом случае, когда "
"сервер закрывает соединение, он предварительно откатывает любую открытую "
"(незавершённую) транзакцию."

#: protocol.xml:73(para)
msgid ""
"Within normal operation, SQL commands can be executed through either of two "
"sub-protocols. In the <quote>simple query</quote> protocol, the frontend "
"just sends a textual query string, which is parsed and immediately executed "
"by the backend. In the <quote>extended query</quote> protocol, processing of "
"queries is separated into multiple steps: parsing, binding of parameter "
"values, and execution. This offers flexibility and performance benefits, at "
"the cost of extra complexity."
msgstr ""
"В процессе обычной работы команды SQL могут выполняться по одному из двух "
"внутренних протоколов. По протоколу <quote>простых запросов</quote> клиент "
"посылает просто текстовую строку запроса, которую сервер сразу же разбирает "
"и выполняет. С протоколом <quote>расширенных запросов</quote> обработка "
"запросов разделяется на несколько этапов: разбор, привязывание значений "
"параметров и исполнение. Это даёт дополнительную гибкость и может увеличить "
"быстродействие ценой большей сложности."

#: protocol.xml:83(para)
msgid ""
"Normal operation has additional sub-protocols for special operations such as "
"<command>COPY</command>."
msgstr ""
"В обычном режиме также поддерживаются дополнительные внутренние протоколы "
"для специальных операций, например <command>COPY</command>."

#: protocol.xml:89(title)
msgid "Messaging Overview"
msgstr "Обзор обмена сообщениями"

#: protocol.xml:91(para)
msgid ""
"All communication is through a stream of messages. The first byte of a "
"message identifies the message type, and the next four bytes specify the "
"length of the rest of the message (this length count includes itself, but "
"not the message-type byte). The remaining contents of the message are "
"determined by the message type. For historical reasons, the very first "
"message sent by the client (the startup message) has no initial message-type "
"byte."
msgstr ""
"Всё взаимодействие представляет собой поток сообщений. Первый байт сообщения "
"определяет тип сообщения, а следующие четыре байта задают длину остального "
"сообщения (эта длина включает размер самого поля длины, но не байт с типом "
"сообщения). Остальное содержимое сообщения определяется его типом. По "
"историческим причинам в самом первом сообщении, передаваемом клиентом, "
"(стартовом сообщении) первый байт с типом сообщения отсутствует."

#: protocol.xml:101(para)
msgid ""
"To avoid losing synchronization with the message stream, both servers and "
"clients typically read an entire message into a buffer (using the byte "
"count) before attempting to process its contents. This allows easy recovery "
"if an error is detected while processing the contents. In extreme situations "
"(such as not having enough memory to buffer the message), the receiver can "
"use the byte count to determine how much input to skip before it resumes "
"reading messages."
msgstr ""
"Чтобы не потерять синхронизацию в потоке сообщений, и серверы, и клиенты "
"обычно считывают всё сообщение в буфер (его размер определяется счётчиком "
"байт), прежде чем обрабатывать его содержимое. Это позволяет без труда "
"продолжить работу, если возникает ошибка при разборе сообщения. В "
"исключительных случаях (например, при нехватке памяти для помещения "
"сообщения в буфер), счётчик байт помогает получателю определить, сколько "
"поступающих байт нужно пропустить, прежде чем продолжать получать сообщения."

#: protocol.xml:111(para)
msgid ""
"Conversely, both servers and clients must take care never to send an "
"incomplete message. This is commonly done by marshaling the entire message "
"in a buffer before beginning to send it. If a communications failure occurs "
"partway through sending or receiving a message, the only sensible response "
"is to abandon the connection, since there is little hope of recovering "
"message-boundary synchronization."
msgstr ""
"С другой стороны, и клиенты, и серверы, ни при каких условиях не должны "
"передавать неполные сообщения. Чтобы этого не допустить, обычно всё "
"сообщение сначала размещается в буфере, и только потом передаётся. Если в "
"процессе отправки или получения сообщения происходит сбой передачи, "
"единственным разумным вариантом продолжения будет прерывание соединения, так "
"как вероятность восстановления синхронизации по границам сообщений в этой "
"ситуации минимальна."

#: protocol.xml:122(title)
msgid "Extended Query Overview"
msgstr "Обзор расширенных запросов"

#: protocol.xml:124(para)
msgid ""
"In the extended-query protocol, execution of SQL commands is divided into "
"multiple steps. The state retained between steps is represented by two types "
"of objects: <firstterm>prepared statements</firstterm> and "
"<firstterm>portals</firstterm>. A prepared statement represents the result "
"of parsing and semantic analysis of a textual query string. A prepared "
"statement is not in itself ready to execute, because it might lack specific "
"values for <firstterm>parameters</firstterm>. A portal represents a ready-to-"
"execute or already-partially-executed statement, with any missing parameter "
"values filled in. (For <command>SELECT</command> statements, a portal is "
"equivalent to an open cursor, but we choose to use a different term since "
"cursors don't handle non-<command>SELECT</command> statements.)"
msgstr ""
"В протоколе расширенных запросов исполнение команд SQL разделяется на "
"несколько этапов. Состояние между этапами представляется объектами двух "
"типов: <firstterm>подготовленные операторы</firstterm> и <firstterm>порталы</"
"firstterm>. Подготовленный оператор представляет собой результат разбора и "
"семантического анализа текстовой строки запроса. Подготовленный оператор сам "
"по себе не готов для исполнения, так как он может не иметь конкретных "
"значений для <firstterm>параметров</firstterm>. Портал представляет собой "
"готовый к исполнению или уже частично выполненный оператор, в котором заданы "
"все недостающие значения параметров. (Для операторов <command>SELECT</"
"command> портал равнозначен открытому курсору, но мы выбрали другой термин, "
"так как курсоры неприменимы к операторам, отличным от <command>SELECT</"
"command>.)"

#: protocol.xml:138(para)
msgid ""
"The overall execution cycle consists of a <firstterm>parse</firstterm> step, "
"which creates a prepared statement from a textual query string; a "
"<firstterm>bind</firstterm> step, which creates a portal given a prepared "
"statement and values for any needed parameters; and an <firstterm>execute</"
"firstterm> step that runs a portal's query. In the case of a query that "
"returns rows (<command>SELECT</command>, <command>SHOW</command>, etc), the "
"execute step can be told to fetch only a limited number of rows, so that "
"multiple execute steps might be needed to complete the operation."
msgstr ""
"Общий цикл выполнения состоит из этапа <firstterm>разбора</firstterm>, на "
"котором из текстовой строки запроса создаётся подготовленный оператор; этапа "
"<firstterm>привязки</firstterm>, на котором из подготовленного оператора и "
"значений для необходимых параметров создаётся портал; и этапа "
"<firstterm>выполнения</firstterm>, на котором исполняется запрос портала. В "
"случае запроса, возвращающего строки (<command>SELECT</command>, "
"<command>SHOW</command> и т. д.), можно указать, чтобы за один шаг "
"выполнения возвращалось только ограниченное число строк, так что для "
"завершения операции понадобятся несколько шагов выполнения."

#: protocol.xml:150(para)
msgid ""
"The backend can keep track of multiple prepared statements and portals (but "
"note that these exist only within a session, and are never shared across "
"sessions). Existing prepared statements and portals are referenced by names "
"assigned when they were created. In addition, an <quote>unnamed</quote> "
"prepared statement and portal exist. Although these behave largely the same "
"as named objects, operations on them are optimized for the case of executing "
"a query only once and then discarding it, whereas operations on named "
"objects are optimized on the expectation of multiple uses."
msgstr ""
"Сервер может контролировать одновременно несколько подготовленных операторов "
"и порталов (но учтите, что они существуют только в рамках сеанса и никогда "
"не разделяются между сеансами). Обращаться к подготовленным операторам и "
"порталам можно по именам, которые назначаются им при создании. Кроме того, "
"существуют и <quote>безымянные</quote> подготовленные операторы и порталы. "
"Хотя они практически не отличаются от именованных объектов, операции с ними "
"оптимизированы для разового выполнения запроса с последующим освобождением "
"объекта, тогда как операции с именованными объектами оптимизируются в "
"расчёте на многоразовое использование."

#: protocol.xml:164(title)
msgid "Formats and Format Codes"
msgstr "Форматы и коды форматов"

#: protocol.xml:166(para)
msgid ""
"Data of a particular data type might be transmitted in any of several "
"different <firstterm>formats</firstterm>. As of <productname>PostgreSQL</"
"productname> 7.4 the only supported formats are <quote>text</quote> and "
"<quote>binary</quote>, but the protocol makes provision for future "
"extensions. The desired format for any value is specified by a "
"<firstterm>format code</firstterm>. Clients can specify a format code for "
"each transmitted parameter value and for each column of a query result. Text "
"has format code zero, binary has format code one, and all other format codes "
"are reserved for future definition."
msgstr ""
"Данные определённого типа могут передаваться в одном из нескольких различных "
"<firstterm>форматов</firstterm>. С версии 7.4 <productname>PostgreSQL</"
"productname> поддерживаются только текстовый (<quote>text</quote>) и "
"двоичный (<quote>binary</quote>) форматы, но в протоколе предусмотрены "
"возможности для расширения в будущем. Ожидаемый формат для любого значения "
"задаётся <firstterm>кодом формата</firstterm>. Клиенты могут указывать код "
"формата для каждого передаваемого значения параметра и для каждого столбца "
"результата запроса. Текстовый формат имеет код ноль, двоичный — код один, а "
"другие коды оставлены для определения в будущем."

#: protocol.xml:178(para)
msgid ""
"The text representation of values is whatever strings are produced and "
"accepted by the input/output conversion functions for the particular data "
"type. In the transmitted representation, there is no trailing null "
"character; the frontend must add one to received values if it wants to "
"process them as C strings. (The text format does not allow embedded nulls, "
"by the way.)"
msgstr ""
"Текстовым представлением значений будут строки, которые выдаются и "
"принимаются функциями ввода/вывода определённого типа данных. В передаваемом "
"представлении завершающий нулевой символ отсутствует, клиент должен добавить "
"его сам, если хочет обрабатывать такое представление в виде строки C. "
"(Собственно, данные в текстовом формате не могут содержать нулевые символы.)"

#: protocol.xml:187(para)
msgid ""
"Binary representations for integers use network byte order (most significant "
"byte first). For other data types consult the documentation or source code "
"to learn about the binary representation. Keep in mind that binary "
"representations for complex data types might change across server versions; "
"the text format is usually the more portable choice."
msgstr ""
"В двоичном представлении целых чисел применяется сетевой порядок байт "
"(наиболее значащий байт первый). Какое именно двоичное представление имеют "
"другие типы данных, можно узнать в документации или исходном коде. Но "
"учтите, что двоичное представление сложных типов данных может меняться от "
"версии к версии сервера; с точки зрения портируемости обычно лучше текстовый "
"формат."

#: protocol.xml:198(title)
msgid "Message Flow"
msgstr "Поток сообщений"

#: protocol.xml:200(para)
msgid ""
"This section describes the message flow and the semantics of each message "
"type. (Details of the exact representation of each message appear in <xref "
"linkend=\"protocol-message-formats\"/>.) There are several different sub-"
"protocols depending on the state of the connection: start-up, query, "
"function call, <command>COPY</command>, and termination. There are also "
"special provisions for asynchronous operations (including notification "
"responses and command cancellation), which can occur at any time after the "
"start-up phase."
msgstr ""
"В этом разделе описывается поток сообщений и семантика каждого типа "
"сообщений. (Подробнее точное представление каждого сообщения описывается в "
"<xref remap=\"6\" linkend=\"protocol-message-formats\"/>.) В зависимости от "
"состояния соединения выделяются несколько различных подразделов протокола: "
"запуск, запрос, вызов функции, копирование (<command>COPY</command>) и "
"завершение. Есть также специальные средства для асинхронных операций (в "
"частности, для уведомлений и отмены команд), которые могут выполняться в "
"любой момент после этапа запуска."

#: protocol.xml:213(title)
msgid "Start-up"
msgstr "Запуск"

#: protocol.xml:215(para)
msgid ""
"To begin a session, a frontend opens a connection to the server and sends a "
"startup message. This message includes the names of the user and of the "
"database the user wants to connect to; it also identifies the particular "
"protocol version to be used. (Optionally, the startup message can include "
"additional settings for run-time parameters.) The server then uses this "
"information and the contents of its configuration files (such as "
"<filename>pg_hba.conf</filename>) to determine whether the connection is "
"provisionally acceptable, and what additional authentication is required (if "
"any)."
msgstr ""
"Чтобы начать сеанс, клиент открывает подключение к серверу и передаёт "
"стартовое сообщение. В этом сообщении содержатся имена пользователя и базы "
"данных, к которой пользователь хочет подключиться; в нём также определяется, "
"какая именно версия протокола будет использоваться. (Стартовое сообщение "
"также может содержать дополнительные значения для параметров времени "
"выполнения.) Проанализировав эту информацию и содержимое своих файлов "
"конфигурации (в частности, <filename>pg_hba.conf</filename>), сервер "
"определяет, можно ли предварительно разрешить это подключение, и какая "
"дополнительная проверка подлинности требуется."

#: protocol.xml:228(para)
msgid ""
"The server then sends an appropriate authentication request message, to "
"which the frontend must reply with an appropriate authentication response "
"message (such as a password). For all authentication methods except GSSAPI "
"and SSPI, there is at most one request and one response. In some methods, no "
"response at all is needed from the frontend, and so no authentication "
"request occurs. For GSSAPI and SSPI, multiple exchanges of packets may be "
"needed to complete the authentication."
msgstr ""
"Затем сервер отправляет соответствующее сообщение с запросом аутентификации, "
"на которое клиент должен ответить сообщением, подтверждающим его подлинность "
"(например, по паролю). Для всех методов аутентификации, за исключением "
"GSSAPI и SSPI, может быть максимум один запрос и один ответ. Для некоторых "
"методов ответ клиента вообще не требуется, так что запрос аутентификации "
"также не передаётся. Методы GSSAPI и SSPI для прохождения проверки "
"подлинности могут потребовать выполнить серию обменов пакетами."

#: protocol.xml:239(para)
msgid ""
"The authentication cycle ends with the server either rejecting the "
"connection attempt (ErrorResponse), or sending AuthenticationOk."
msgstr ""
"Цикл аутентификации заканчивает сервер, либо запрещая соединение "
"(ErrorResponse), либо принимая его (отправляя AuthenticationOk)."

#: protocol.xml:249(term) protocol.xml:437(term) protocol.xml:551(term)
#: protocol.xml:903(term)
msgid "ErrorResponse"
msgstr "ErrorResponse (Ошибочный ответ)"

#: protocol.xml:251(para)
msgid ""
"The connection attempt has been rejected. The server then immediately closes "
"the connection."
msgstr ""
"Попытка соединения была отвергнута. Сразу после этого сервер закрывает "
"соединение."

#: protocol.xml:259(term)
msgid "AuthenticationOk"
msgstr "AuthenticationOk (Аутентификация пройдена)"

#: protocol.xml:261(para)
msgid "The authentication exchange is successfully completed."
msgstr "Обмен сообщениями для проверки подлинности завершён успешно."

#: protocol.xml:268(term)
msgid "AuthenticationKerberosV5"
msgstr "AuthenticationKerberosV5 (Аутентификация Kerberos V5)"

#: protocol.xml:270(para)
msgid ""
"The frontend must now take part in a Kerberos V5 authentication dialog (not "
"described here, part of the Kerberos specification) with the server. If this "
"is successful, the server responds with an AuthenticationOk, otherwise it "
"responds with an ErrorResponse. This is no longer supported."
msgstr ""
"Клиент должен теперь принять участие в диалоге аутентификации по протоколу "
"Kerberos V5 (здесь его детали не описывается, так как они относятся к "
"спецификации Kerberos) с сервером. Если этот диалог завершается успешно, "
"сервер отвечает AuthenticationOk, иначе — ErrorResponse. Этот вариант "
"аутентификации больше не поддерживается."

#: protocol.xml:282(term)
msgid "AuthenticationCleartextPassword"
msgstr "AuthenticationCleartextPassword (Аутентификация с открытым паролем)"

#: protocol.xml:284(para)
msgid ""
"The frontend must now send a PasswordMessage containing the password in "
"clear-text form. If this is the correct password, the server responds with "
"an AuthenticationOk, otherwise it responds with an ErrorResponse."
msgstr ""
"Клиент должен передать в ответ сообщение PasswordMessage, содержащее пароль "
"в открытом виде. Если пароль правильный, сервер отвечает ему "
"AuthenticationOk, иначе — ErrorResponse."

#: protocol.xml:294(term)
msgid "AuthenticationMD5Password"
msgstr "AuthenticationMD5Password (Аутентификация с паролем MD5)"

#: protocol.xml:296(para)
msgid ""
"The frontend must now send a PasswordMessage containing the password (with "
"user name) encrypted via MD5, then encrypted again using the 4-byte random "
"salt specified in the AuthenticationMD5Password message. If this is the "
"correct password, the server responds with an AuthenticationOk, otherwise it "
"responds with an ErrorResponse. The actual PasswordMessage can be computed "
"in SQL as <literal>concat('md5', md5(concat(md5(concat(password, username)), "
"random-salt)))</literal>. (Keep in mind the <function>md5()</function> "
"function returns its result as a hex string.)"
msgstr ""
"Клиент должен передать в ответ сообщение PasswordMessage с результатом "
"преобразования пароля (и имени пользователя) в хеш MD5 с последующим "
"хешированием с четырёхбайтовым случайным значением соли, переданным в "
"сообщении AuthenticationMD5Password. Если пароль правильный, сервер отвечает "
"AuthenticationOk, иначе — ErrorResponse. Содержимое сообщения "
"PasswordMessage можно вычислить в SQL как <literal>concat('md5', "
"md5(concat(md5(concat(password, username)), random-salt)))</literal>. "
"(Учтите, что функция <function>md5()</function> возвращает результат в виде "
"шестнадцатеричной строки.)"

#: protocol.xml:312(term)
msgid "AuthenticationSCMCredential"
msgstr "AuthenticationSCMCredential (Аутентификация по учётным данным SCM)"

#: protocol.xml:314(para)
msgid ""
"This response is only possible for local Unix-domain connections on "
"platforms that support SCM credential messages. The frontend must issue an "
"SCM credential message and then send a single data byte. (The contents of "
"the data byte are uninteresting; it's only used to ensure that the server "
"waits long enough to receive the credential message.) If the credential is "
"acceptable, the server responds with an AuthenticationOk, otherwise it "
"responds with an ErrorResponse. (This message type is only issued by pre-9.1 "
"servers. It may eventually be removed from the protocol specification.)"
msgstr ""
"Этот ответ возможен только для локальных подключений через доменные сокеты "
"Unix на платформах, поддерживающих сообщения с учётными данными SCM. Клиент "
"должен выдать сообщение с учётными данными SCM и дополнительно отправить "
"один байт данных. (Содержимое этого байта не представляет интереса; его "
"нужно передавать, только чтобы сервер дожидался сообщения с учётными "
"данными.) Если сервер принимает учётные данные, он отвечает "
"AuthenticationOk, иначе — ErrorResponse. (Этот тип сообщений выдают только "
"серверы версии до 9.1. В конце концов он может быть исключён из спецификации "
"протокола.)"

#: protocol.xml:330(term)
msgid "AuthenticationGSS"
msgstr "AuthenticationGSS (Аутентификация GSS)"

#: protocol.xml:332(para)
msgid ""
"The frontend must now initiate a GSSAPI negotiation. The frontend will send "
"a PasswordMessage with the first part of the GSSAPI data stream in response "
"to this. If further messages are needed, the server will respond with "
"AuthenticationGSSContinue."
msgstr ""
"Клиент должен начать согласование GSSAPI. В ответ на это сообщение клиент "
"отправляет PasswordMessage с первой частью потока данных GSSAPI. Если "
"потребуются дополнительные сообщения, сервер передаст в ответ "
"AuthenticationGSSContinue."

#: protocol.xml:342(term)
msgid "AuthenticationSSPI"
msgstr "AuthenticationSSPI (Аутентификация SSPI)"

#: protocol.xml:344(para)
msgid ""
"The frontend must now initiate a SSPI negotiation. The frontend will send a "
"PasswordMessage with the first part of the SSPI data stream in response to "
"this. If further messages are needed, the server will respond with "
"AuthenticationGSSContinue."
msgstr ""
"Клиент должен начать согласование SSPI. В ответ на это сообщение клиент "
"отправляет PasswordMessage с первой частью потока данных SSPI. Если "
"потребуются дополнительные сообщения, сервер передаст в ответ "
"AuthenticationGSSContinue."

#: protocol.xml:354(term)
msgid "AuthenticationGSSContinue"
msgstr "AuthenticationGSSContinue (Продолжение аутентификации GSS)"

#: protocol.xml:356(para)
msgid ""
"This message contains the response data from the previous step of GSSAPI or "
"SSPI negotiation (AuthenticationGSS, AuthenticationSSPI or a previous "
"AuthenticationGSSContinue). If the GSSAPI or SSPI data in this message "
"indicates more data is needed to complete the authentication, the frontend "
"must send that data as another PasswordMessage. If GSSAPI or SSPI "
"authentication is completed by this message, the server will next send "
"AuthenticationOk to indicate successful authentication or ErrorResponse to "
"indicate failure."
msgstr ""
"Это сообщение содержит данные ответа на предыдущий шаг согласования GSSAPI "
"или SSPI (AuthenticationGSS, AuthenticationSSPI или предыдущего "
"AuthenticationGSSContinue). Если в структуре GSSAPI или SSPI в этом "
"сообщении указывается, что для завершения аутентификации требуются "
"дополнительные данные, клиент должен передать их в очередном сообщении "
"PasswordMessage. Если этим сообщением завершается проверка подлинности "
"GSSAPI или SSPI, сервер затем передаёт AuthenticationOk, сообщая об успешной "
"проверке подлинности, либо ErrorResponse, сообщая об ошибке."

#: protocol.xml:244(para)
msgid ""
"The possible messages from the server in this phase are: <placeholder-1/>"
msgstr ""
"Сервер может передавать в этой фазе следующие сообщения: <placeholder-1/>"

#: protocol.xml:373(para)
msgid ""
"If the frontend does not support the authentication method requested by the "
"server, then it should immediately close the connection."
msgstr ""
"Если клиент не поддерживает метод проверки подлинности, запрошенный "
"сервером, он должен немедленно закрыть соединение."

#: protocol.xml:379(para)
msgid ""
"After having received AuthenticationOk, the frontend must wait for further "
"messages from the server. In this phase a backend process is being started, "
"and the frontend is just an interested bystander. It is still possible for "
"the startup attempt to fail (ErrorResponse), but in the normal case the "
"backend will send some ParameterStatus messages, BackendKeyData, and finally "
"ReadyForQuery."
msgstr ""
"Получив сообщение AuthenticationOk, клиент должен ждать дальнейших сообщений "
"от сервера. В этой фазе запускается обслуживающий процесс, а клиент "
"представляет собой просто заинтересованного наблюдателя. Ошибка запуска "
"может быть неудачной (и клиент получит ErrorResponse), но в обычной ситуации "
"обслуживающий процесс передаёт несколько сообщений ParameterStatus, "
"BackendKeyData и, наконец, ReadyForQuery."

#: protocol.xml:388(para)
msgid ""
"During this phase the backend will attempt to apply any additional run-time "
"parameter settings that were given in the startup message. If successful, "
"these values become session defaults. An error causes ErrorResponse and exit."
msgstr ""
"В ходе этой фазы обслуживающий процесс попытается применить все параметры "
"времени выполнения, полученные в стартовом сообщении. Если это удастся, эти "
"значения становятся сеансовыми значениями по умолчанию. При ошибке он "
"передаёт ErrorResponse и завершается."

#: protocol.xml:400(term)
msgid "BackendKeyData"
msgstr "BackendKeyData (Данные ключа сервера)"

#: protocol.xml:402(para)
msgid ""
"This message provides secret-key data that the frontend must save if it "
"wants to be able to issue cancel requests later. The frontend should not "
"respond to this message, but should continue listening for a ReadyForQuery "
"message."
msgstr ""
"В этом сообщении передаётся секретный ключ, который клиент должен сохранить, "
"чтобы впоследствии иметь возможность выполнять запросы. Клиент не должен "
"отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery."

#: protocol.xml:412(term)
msgid "ParameterStatus"
msgstr "ParameterStatus (Состояние параметров)"

#: protocol.xml:414(para)
msgid ""
"This message informs the frontend about the current (initial) setting of "
"backend parameters, such as <xref linkend=\"guc-client-encoding\"/> or <xref "
"linkend=\"guc-datestyle\"/>. The frontend can ignore this message, or record "
"the settings for its future use; see <xref linkend=\"protocol-async\"/> for "
"more details. The frontend should not respond to this message, but should "
"continue listening for a ReadyForQuery message."
msgstr ""
"Это сообщение говорит клиенту о текущих (начальных) значениях параметров "
"обслуживающего процесса, например, <xref linkend=\"guc-client-encoding\"/> "
"или <xref linkend=\"guc-datestyle\"/>. Клиент может проигнорировать это "
"сообщение или сохранить значения для дальнейшего использования; за "
"дополнительными подробностями обратитесь к <xref remap=\"3\" linkend="
"\"protocol-async\"/>. Клиент не должен отвечать на это сообщение, он должен "
"дожидаться сообщения ReadyForQuery."

#: protocol.xml:428(term) protocol.xml:560(term) protocol.xml:924(term)
msgid "ReadyForQuery"
msgstr "ReadyForQuery (Готов к запросам)"

#: protocol.xml:430(para)
msgid "Start-up is completed. The frontend can now issue commands."
msgstr "Запуск завершён. Теперь клиент может выполнять команды."

#: protocol.xml:439(para)
msgid "Start-up failed. The connection is closed after sending this message."
msgstr ""
"Запуск не удался. Соединение закрывается после передачи этого сообщения."

#: protocol.xml:447(term) protocol.xml:574(term) protocol.xml:935(term)
msgid "NoticeResponse"
msgstr "NoticeResponse (Ответ с замечанием)"

#: protocol.xml:449(para)
msgid ""
"A warning message has been issued. The frontend should display the message "
"but continue listening for ReadyForQuery or ErrorResponse."
msgstr ""
"Выдаётся предупреждающее сообщение. Клиент должен вывести это сообщение, но "
"продолжать ожидать сообщения ReadyForQuery или ErrorResponse."

#: protocol.xml:395(para)
msgid ""
"The possible messages from the backend in this phase are: <placeholder-1/>"
msgstr ""
"Обслуживающий процесс может передавать в этой фазе следующие сообщения: "
"<placeholder-1/>"

#: protocol.xml:459(para)
msgid ""
"The ReadyForQuery message is the same one that the backend will issue after "
"each command cycle. Depending on the coding needs of the frontend, it is "
"reasonable to consider ReadyForQuery as starting a command cycle, or to "
"consider ReadyForQuery as ending the start-up phase and each subsequent "
"command cycle."
msgstr ""
"Сообщение ReadyForQuery в данной фазе ничем не отличается от сообщений, "
"который передаёт сервер после каждого цикла команд. В зависимости от условий "
"реализации клиента, можно воспринимать сообщение ReadyForQuery как "
"начинающее цикл команд, либо как завершающее фазу запуска и каждый "
"последующий цикл команд."

#: protocol.xml:469(title)
msgid "Simple Query"
msgstr "Простой запрос"

#: protocol.xml:471(para)
msgid ""
"A simple query cycle is initiated by the frontend sending a Query message to "
"the backend. The message includes an SQL command (or commands) expressed as "
"a text string. The backend then sends one or more response messages "
"depending on the contents of the query command string, and finally a "
"ReadyForQuery response message. ReadyForQuery informs the frontend that it "
"can safely send a new command. (It is not actually necessary for the "
"frontend to wait for ReadyForQuery before issuing another command, but the "
"frontend must then take responsibility for figuring out what happens if the "
"earlier command fails and already-issued later commands succeed.)"
msgstr ""
"Цикл простого запроса начинает клиент, передавая серверу сообщение Query. "
"Это сообщение включает команду (или команды) SQL, выраженную в виде "
"текстовой строки. В ответ сервер передаёт одно или несколько сообщений, в "
"зависимости от строки запроса, и завершает цикл сообщением ReadyForQuery. "
"ReadyForQuery говорит клиенту, что он может безопасно передавать новую "
"команду. (На самом деле клиент может передать следующую команду, не "
"дожидаясь ReadyForQuery, но тогда он сам должен разобраться в ситуации, "
"когда первая команда завершается ошибкой, а последующая выполняется успешно.)"

#: protocol.xml:490(term)
msgid "CommandComplete"
msgstr "CommandComplete (Команда завершена)"

#: protocol.xml:492(para)
msgid "An SQL command completed normally."
msgstr "Команда SQL выполнена нормально."

#: protocol.xml:499(term)
msgid "CopyInResponse"
msgstr "CopyInResponse (Ответ входящего копирования)"

#: protocol.xml:501(para)
msgid ""
"The backend is ready to copy data from the frontend to a table; see <xref "
"linkend=\"protocol-copy\"/>."
msgstr ""
"Сервер готов копировать данные, получаемые от клиента, в таблицу; см. <xref "
"remap=\"4\" linkend=\"protocol-copy\"/>."

#: protocol.xml:509(term)
msgid "CopyOutResponse"
msgstr "CopyOutResponse (Ответ исходящего копирования)"

#: protocol.xml:511(para)
msgid ""
"The backend is ready to copy data from a table to the frontend; see <xref "
"linkend=\"protocol-copy\"/>."
msgstr ""
"Сервер готов копировать данные из таблицы клиенту; см. <xref remap=\"4\" "
"linkend=\"protocol-copy\"/>."

#: protocol.xml:519(term)
msgid "RowDescription"
msgstr "RowDescription (Описание строк)"

#: protocol.xml:521(para)
msgid ""
"Indicates that rows are about to be returned in response to a "
"<command>SELECT</command>, <command>FETCH</command>, etc query. The contents "
"of this message describe the column layout of the rows. This will be "
"followed by a DataRow message for each row being returned to the frontend."
msgstr ""
"Показывает, что в ответ на запрос <command>SELECT</command>, <command>FETCH</"
"command> и т. п. будут возвращены строки. В содержимом этого сообщения "
"описывается структура столбцов этих строк. За ним для каждой строки, "
"возвращаемой клиенту, следует сообщение DataRow."

#: protocol.xml:532(term)
msgid "DataRow"
msgstr "DataRow (Строка данных)"

#: protocol.xml:534(para)
msgid ""
"One of the set of rows returned by a <command>SELECT</command>, "
"<command>FETCH</command>, etc query."
msgstr ""
"Одна строка из набора, возвращаемого запросом <command>SELECT</command>, "
"<command>FETCH</command> и т. п."

#: protocol.xml:542(term)
msgid "EmptyQueryResponse"
msgstr "EmptyQueryResponse (Ответ на пустой запрос)"

#: protocol.xml:544(para)
msgid "An empty query string was recognized."
msgstr "Была принята пустая строка запроса."

#: protocol.xml:553(para) protocol.xml:905(para)
msgid "An error has occurred."
msgstr "Произошла ошибка."

#: protocol.xml:562(para)
msgid ""
"Processing of the query string is complete. A separate message is sent to "
"indicate this because the query string might contain multiple SQL commands. "
"(CommandComplete marks the end of processing one SQL command, not the whole "
"string.) ReadyForQuery will always be sent, whether processing terminates "
"successfully or with an error."
msgstr ""
"Обработка строки запроса завершена. Чтобы отметить это, отправляется "
"отдельное сообщение, так как строка запроса может содержать несколько команд "
"SQL. (Сообщение CommandComplete говорит о завершении обработки одной команды "
"SQL, а не всей строки.) ReadyForQuery передаётся всегда, и при успешном "
"завершении обработки, и при ошибке."

#: protocol.xml:576(para)
msgid ""
"A warning message has been issued in relation to the query. Notices are in "
"addition to other responses, i.e., the backend will continue processing the "
"command."
msgstr ""
"Выдаётся предупреждение, связанное с запросом. Эти замечания дополняют "
"другие ответы, то есть сервер, выдавая их, продолжает обрабатывать команду."

#: protocol.xml:485(para) protocol.xml:898(para)
msgid "The possible response messages from the backend are: <placeholder-1/>"
msgstr ""
"Сервер может передавать в этой фазе следующие ответные сообщения: "
"<placeholder-1/>"

#: protocol.xml:587(para)
msgid ""
"The response to a <command>SELECT</command> query (or other queries that "
"return row sets, such as <command>EXPLAIN</command> or <command>SHOW</"
"command>) normally consists of RowDescription, zero or more DataRow "
"messages, and then CommandComplete. <command>COPY</command> to or from the "
"frontend invokes special protocol as described in <xref linkend=\"protocol-"
"copy\"/>. All other query types normally produce only a CommandComplete "
"message."
msgstr ""
"Ответ на запрос <command>SELECT</command> (или другие запросы, возвращающие "
"наборы строк, такие как <command>EXPLAIN</command> и <command>SHOW</"
"command>) обычно состоит из RowDescription, нуля или нескольких сообщений "
"DataRow, и завершающего CommandComplete. Для команды <command>COPY</command> "
"с вводом или выводом данных через клиента, применяется специальный протокол, "
"описанный в <xref remap=\"6\" linkend=\"protocol-copy\"/>. Со всеми другими "
"типами запросами обычно выдаётся только сообщение CommandComplete."

#: protocol.xml:598(para)
msgid ""
"Since a query string could contain several queries (separated by "
"semicolons), there might be several such response sequences before the "
"backend finishes processing the query string. ReadyForQuery is issued when "
"the entire string has been processed and the backend is ready to accept a "
"new query string."
msgstr ""
"Так как строка запроса может содержать несколько запросов (разделённых "
"точкой с запятой), до завершения обработки всей строки сервер может передать "
"несколько серий таких ответов. Когда сервер завершает обработку всей строки "
"и готов принять следующую строку запроса, он выдаёт сообщение ReadyForQuery."

#: protocol.xml:606(para)
msgid ""
"If a completely empty (no contents other than whitespace) query string is "
"received, the response is EmptyQueryResponse followed by ReadyForQuery."
msgstr ""
"Если получена полностью пустая строка запроса (не содержащая ничего, кроме "
"пробельных символов), ответом будет EmptyQueryResponse с последующим "
"ReadyForQuery."

#: protocol.xml:611(para)
msgid ""
"In the event of an error, ErrorResponse is issued followed by ReadyForQuery. "
"All further processing of the query string is aborted by ErrorResponse (even "
"if more queries remained in it). Note that this might occur partway through "
"the sequence of messages generated by an individual query."
msgstr ""
"В случае ошибки выдаётся ErrorResponse с последующим ReadyForQuery. "
"Сообщение ErrorResponse прерывает дальнейшую обработку строки запроса (даже "
"если в ней остались другие запросы). Заметьте, что оно может быть выдано и в "
"середине последовательности сообщений, выдаваемых в ответ на отдельный "
"запрос."

#: protocol.xml:619(para)
msgid ""
"In simple Query mode, the format of retrieved values is always text, except "
"when the given command is a <command>FETCH</command> from a cursor declared "
"with the <literal>BINARY</literal> option. In that case, the retrieved "
"values are in binary format. The format codes given in the RowDescription "
"message tell which format is being used."
msgstr ""
"В режиме простых запросов получаемые значения всегда передаются в текстовом "
"формате, за исключением результатов команды <command>FETCH</command> для "
"курсора, объявленного с атрибутом <literal>BINARY</literal>. С такой "
"командой значения передаются в двоичном формате. Какой именно формат "
"используется, определяют коды формата, передаваемые в сообщении "
"RowDescription."

#: protocol.xml:627(para)
msgid ""
"A frontend must be prepared to accept ErrorResponse and NoticeResponse "
"messages whenever it is expecting any other type of message. See also <xref "
"linkend=\"protocol-async\"/> concerning messages that the backend might "
"generate due to outside events."
msgstr ""
"Клиент должен быть готов принять сообщения ErrorResponse и NoticeResponse, "
"ожидая любой другой тип сообщений. Также обратитесь к <xref remap=\"3\" "
"linkend=\"protocol-async\"/> за информацией о сообщениях, которые сервер "
"может выдавать в ответ на внешние события."

#: protocol.xml:634(para)
msgid ""
"Recommended practice is to code frontends in a state-machine style that will "
"accept any message type at any time that it could make sense, rather than "
"wiring in assumptions about the exact sequence of messages."
msgstr ""
"Код клиента рекомендуется реализовывать в виде машины состояний, которая в "
"любой момент будет принимать сообщения всех типов, имеющих смысл на данном "
"этапе, но не программировать жёстко обработку точной последовательности "
"сообщений."

#: protocol.xml:642(title)
msgid "Extended Query"
msgstr "Расширенный запрос"

#: protocol.xml:644(para)
msgid ""
"The extended query protocol breaks down the above-described simple query "
"protocol into multiple steps. The results of preparatory steps can be re-"
"used multiple times for improved efficiency. Furthermore, additional "
"features are available, such as the possibility of supplying data values as "
"separate parameters instead of having to insert them directly into a query "
"string."
msgstr ""
"Протокол расширенных запросов разбивает вышеописанный протокол простых "
"запросов на несколько шагов. Результаты подготовительных шагов можно "
"неоднократно использовать повторно для улучшения эффективности. Кроме того, "
"он открывает дополнительные возможности, в частности, возможность передавать "
"значения данных в отдельных параметрах вместо того, чтобы внедрять их "
"непосредственно в строку запроса."

#: protocol.xml:653(para)
msgid ""
"In the extended protocol, the frontend first sends a Parse message, which "
"contains a textual query string, optionally some information about data "
"types of parameter placeholders, and the name of a destination prepared-"
"statement object (an empty string selects the unnamed prepared statement). "
"The response is either ParseComplete or ErrorResponse. Parameter data types "
"can be specified by OID; if not given, the parser attempts to infer the data "
"types in the same way as it would do for untyped literal string constants."
msgstr ""
"В расширенном протоколе клиент сначала передаёт сообщение Parse с текстовой "
"строкой запроса и, возможно, некоторыми сведениями о типах параметров и "
"именем целевого объекта подготовленного оператора (если имя пустое, "
"создаётся безымянный подготовленный оператор). Ответом на это сообщение "
"будет ParseComplete или ErrorResponse. Типы параметров указываются по OID; "
"при отсутствии явного указания анализатор запроса пытается определить типы "
"данных так же, как он делал бы для нетипизированных строковых констант."

#: protocol.xml:666(para)
msgid ""
"A parameter data type can be left unspecified by setting it to zero, or by "
"making the array of parameter type OIDs shorter than the number of parameter "
"symbols (<literal>$</literal><replaceable>n</replaceable>) used in the query "
"string. Another special case is that a parameter's type can be specified as "
"<type>void</type> (that is, the OID of the <type>void</type> pseudotype). "
"This is meant to allow parameter symbols to be used for function parameters "
"that are actually OUT parameters. Ordinarily there is no context in which a "
"<type>void</type> parameter could be used, but if such a parameter symbol "
"appears in a function's parameter list, it is effectively ignored. For "
"example, a function call such as <literal>foo($1,$2,$3,$4)</literal> could "
"match a function with two IN and two OUT arguments, if <literal>$3</literal> "
"and <literal>$4</literal> are specified as having type <type>void</type>."
msgstr ""
"Тип данных параметра можно оставить неопределённым, задав для него значение "
"ноль, либо сделав массив с OID типов параметров короче, чем набор символов "
"параметров (<literal>$</literal><replaceable>n</replaceable>), используемых "
"в строке запроса. Другой особый случай — передача типа параметра как "
"<type>void</type> (то есть передача OID псевдотипа <type>void</type>). Это "
"предусмотрено для того, чтобы символы параметров можно было использовать для "
"параметров функций, на самом деле представляющих собой параметры OUT. Обычно "
"параметр <type>void</type> нельзя использовать ни в каком контексте, но если "
"такой параметр фигурирует в списке параметров функции, он фактически "
"игнорируется. Например, вызову функции <literal>foo($1,$2,$3,$4)</literal> "
"может соответствовать функция с аргументами IN и двумя OUT, если аргументы "
"<literal>$3</literal> и <literal>$4</literal> объявлены как имеющие тип "
"<type>void</type>."

#: protocol.xml:684(para)
msgid ""
"The query string contained in a Parse message cannot include more than one "
"SQL statement; else a syntax error is reported. This restriction does not "
"exist in the simple-query protocol, but it does exist in the extended "
"protocol, because allowing prepared statements or portals to contain "
"multiple commands would complicate the protocol unduly."
msgstr ""
"Строка запроса, содержащаяся в сообщении Parse, не может содержать больше "
"одного оператора SQL; иначе выдаётся синтаксическая ошибка. Это ограничение "
"отсутствует в протоколе простых запросов, но присутствует в расширенном "
"протоколе, так как добавление поддержки подготовленных операторов или "
"порталов, содержащих несколько команд, неоправданно усложнило бы протокол."

#: protocol.xml:694(para)
msgid ""
"If successfully created, a named prepared-statement object lasts till the "
"end of the current session, unless explicitly destroyed. An unnamed prepared "
"statement lasts only until the next Parse statement specifying the unnamed "
"statement as destination is issued. (Note that a simple Query message also "
"destroys the unnamed statement.) Named prepared statements must be "
"explicitly closed before they can be redefined by another Parse message, but "
"this is not required for the unnamed statement. Named prepared statements "
"can also be created and accessed at the SQL command level, using "
"<command>PREPARE</command> and <command>EXECUTE</command>."
msgstr ""
"В случае успешного создания именованный подготовленный оператор продолжает "
"существовать до завершения текущего сеанса, если только он не будет "
"уничтожен явно. Безымянный подготовленный оператор сохраняется только до "
"следующей команды Parse, в которой целевым является безымянный оператор. "
"(Заметьте, что сообщение простого запроса также уничтожает безымянный "
"оператор.) Именованные операторы должны явно закрываться, прежде чем их "
"можно будет переопределить другим сообщением Parse, но для безымянных "
"операторов это не требуется. Именованные подготовленные операторы также "
"можно создавать и вызывать на уровне команд SQL, используя команды "
"<command>PREPARE</command> и <command>EXECUTE</command>."

#: protocol.xml:706(para)
msgid ""
"Once a prepared statement exists, it can be readied for execution using a "
"Bind message. The Bind message gives the name of the source prepared "
"statement (empty string denotes the unnamed prepared statement), the name of "
"the destination portal (empty string denotes the unnamed portal), and the "
"values to use for any parameter placeholders present in the prepared "
"statement. The supplied parameter set must match those needed by the "
"prepared statement. (If you declared any <type>void</type> parameters in the "
"Parse message, pass NULL values for them in the Bind message.) Bind also "
"specifies the format to use for any data returned by the query; the format "
"can be specified overall, or per-column. The response is either BindComplete "
"or ErrorResponse."
msgstr ""
"Когда подготовленный оператор существует, его можно подготовить к выполнению "
"сообщением Bind. В сообщении Bind задаётся имя исходного подготовленного "
"оператора (пустая строка подразумевает безымянный подготовленный оператор), "
"имя целевого портала (пустая строка подразумевает безымянный портал) и "
"значения для любых шаблонов параметров, представленных в подготовленном "
"операторе. Набор передаваемых значений должен соответствовать набору "
"параметров, требующихся для подготовленного оператора. (Если вы объявили "
"параметры <type>void</type> в сообщении Parse, передайте для них значения "
"NULL в сообщении Bind.) Bind также принимает указание формата для данных, "
"возвращаемых в результате запроса; формат можно указать для всех данных, "
"либо для отдельных столбцов. Ответом на это сообщение будет BindComplete или "
"ErrorResponse."

#: protocol.xml:722(para)
msgid ""
"The choice between text and binary output is determined by the format codes "
"given in Bind, regardless of the SQL command involved. The <literal>BINARY</"
"literal> attribute in cursor declarations is irrelevant when using extended "
"query protocol."
msgstr ""
"Выбор между текстовым и двоичным форматом вывода определяется кодами "
"формата, передаваемыми в Bind, вне зависимости от команды SQL. При "
"использовании протокола расширенных запросов атрибут <literal>BINARY</"
"literal> в объявлении курсоров не имеет значения."

#: protocol.xml:730(para)
msgid ""
"Query planning typically occurs when the Bind message is processed. If the "
"prepared statement has no parameters, or is executed repeatedly, the server "
"might save the created plan and re-use it during subsequent Bind messages "
"for the same prepared statement. However, it will do so only if it finds "
"that a generic plan can be created that is not much less efficient than a "
"plan that depends on the specific parameter values supplied. This happens "
"transparently so far as the protocol is concerned."
msgstr ""
"Планирование запроса обычно имеет место при обработке сообщения Bind. Если "
"подготовленный оператор не имеет параметров, либо он выполняется "
"многократно, сервер может сохранить созданный план и использовать его "
"повторно при последующих сообщениях Bind для того же подготовленного "
"оператора. Однако он будет делать это, только если решит, что можно получить "
"универсальный план, который не будет значительно неэффективнее планов, "
"зависящих от конкретных значений параметров. С точки зрения протокола это "
"происходит незаметно."

#: protocol.xml:740(para)
msgid ""
"If successfully created, a named portal object lasts till the end of the "
"current transaction, unless explicitly destroyed. An unnamed portal is "
"destroyed at the end of the transaction, or as soon as the next Bind "
"statement specifying the unnamed portal as destination is issued. (Note that "
"a simple Query message also destroys the unnamed portal.) Named portals must "
"be explicitly closed before they can be redefined by another Bind message, "
"but this is not required for the unnamed portal. Named portals can also be "
"created and accessed at the SQL command level, using <command>DECLARE "
"CURSOR</command> and <command>FETCH</command>."
msgstr ""
"В случае успешного создания объект именованного портала продолжает "
"существование до конца текущей транзакции, если только он не будет уничтожен "
"явно. Безымянный портал уничтожается в конце транзакции или при выполнении "
"следующей команды Bind, в которой в качестве целевого выбирается безымянный "
"портал. (Заметьте, что сообщение простого запроса также уничтожает "
"безымянный портал.) Именованные порталы должны явно закрываться, прежде чем "
"их можно будет явно переопределить другим сообщением Bind, но это не "
"требуется для безымянных порталов. Именованные порталы также можно создавать "
"и вызывать на уровне команд SQL, используя команды <command>DECLARE CURSOR</"
"command> и <command>FETCH</command>."

#: protocol.xml:752(para)
msgid ""
"Once a portal exists, it can be executed using an Execute message. The "
"Execute message specifies the portal name (empty string denotes the unnamed "
"portal) and a maximum result-row count (zero meaning <quote>fetch all rows</"
"quote>). The result-row count is only meaningful for portals containing "
"commands that return row sets; in other cases the command is always executed "
"to completion, and the row count is ignored. The possible responses to "
"Execute are the same as those described above for queries issued via simple "
"query protocol, except that Execute doesn't cause ReadyForQuery or "
"RowDescription to be issued."
msgstr ""
"Когда портал существует, его можно запустить на выполнение сообщением "
"Execute. В сообщении Execute указывается имя портала (пустая строка "
"подразумевает безымянный портал) и максимальное число результирующих строк "
"(ноль означает <quote>выбрать все строки</quote>). Число результирующих "
"строк имеет значение только для порталов, которые содержат команды, "
"возвращающие наборы строк; в других случаях команда всегда выполняется до "
"завершения и число строк игнорируется. В ответ на Execute могут быть "
"получены те же сообщения, что описаны выше для запросов, выполняемых через "
"протокол простых запросов, за исключением того, что после Execute не "
"выдаются сообщения ReadyForQuery и RowDescription."

#: protocol.xml:766(para)
msgid ""
"If Execute terminates before completing the execution of a portal (due to "
"reaching a nonzero result-row count), it will send a PortalSuspended "
"message; the appearance of this message tells the frontend that another "
"Execute should be issued against the same portal to complete the operation. "
"The CommandComplete message indicating completion of the source SQL command "
"is not sent until the portal's execution is completed. Therefore, an Execute "
"phase is always terminated by the appearance of exactly one of these "
"messages: CommandComplete, EmptyQueryResponse (if the portal was created "
"from an empty query string), ErrorResponse, or PortalSuspended."
msgstr ""
"Если операция Execute оканчивается до завершения выполнения портала (из-за "
"достижения ненулевого ограничения на число строк), сервер отправляет "
"сообщение PortalSuspended; появление этого сообщения говорит клиенту о том, "
"что для завершения операции с данным порталом нужно выдать ещё одно "
"сообщение Execute. Сообщение CommandComplete, говорящее о завершении "
"исходной команды SQL, не передаётся до завершения выполнения портала. Таким "
"образом, фаза Execute всегда заканчивается при появлении одного из "
"сообщений: CommandComplete, EmptyQueryResponse (если портал был создан из "
"пустой строки запроса), ErrorResponse или PortalSuspended."

#: protocol.xml:779(para)
msgid ""
"At completion of each series of extended-query messages, the frontend should "
"issue a Sync message. This parameterless message causes the backend to close "
"the current transaction if it's not inside a <command>BEGIN</command>/"
"<command>COMMIT</command> transaction block (<quote>close</quote> meaning to "
"commit if no error, or roll back if error). Then a ReadyForQuery response is "
"issued. The purpose of Sync is to provide a resynchronization point for "
"error recovery. When an error is detected while processing any extended-"
"query message, the backend issues ErrorResponse, then reads and discards "
"messages until a Sync is reached, then issues ReadyForQuery and returns to "
"normal message processing. (But note that no skipping occurs if an error is "
"detected <emphasis>while</emphasis> processing Sync &mdash; this ensures "
"that there is one and only one ReadyForQuery sent for each Sync.)"
msgstr ""
"В конце каждой серии сообщений расширенных запросов клиент должен выдать "
"сообщение Sync. Получив это сообщение без параметров, сервер закрывает "
"текущую транзакцию, если команды выполняются не внутри блока транзакции "
"<command>BEGIN</command>/<command>COMMIT</command> (под <quote>закрытием</"
"quote> понимается фиксация при отсутствии ошибок или откат в противном "
"случае). Затем он выдаёт ответ ReadyForQuery. Целью сообщения Sync является "
"обозначение точки синхронизации для восстановления в случае ошибок. Если при "
"обработке сообщений расширенных запросов происходит ошибка, сервер выдаёт "
"ErrorResponse, затем считывает и пропускает сообщения до Sync, после чего "
"выдаёт ReadyForQuery и возвращается к обычной обработке сообщений. (Но "
"заметьте, что он не будет пропускать следующие сообщения, если ошибка "
"происходит <emphasis>в процессе</emphasis> обработки Sync &mdash; это "
"гарантирует, что для каждого Sync будет передаваться в точности одно "
"сообщение ReadyForQuery.)"

#: protocol.xml:796(para)
msgid ""
"Sync does not cause a transaction block opened with <command>BEGIN</command> "
"to be closed. It is possible to detect this situation since the "
"ReadyForQuery message includes transaction status information."
msgstr ""
"Сообщение Sync не приводит к закрытию блока транзакции, открытого командой "
"<command>BEGIN</command>. Выявить эту ситуацию можно, используя информацию о "
"состоянии транзакции, содержащуюся в сообщении ReadyForQuery."

#: protocol.xml:803(para)
msgid ""
"In addition to these fundamental, required operations, there are several "
"optional operations that can be used with extended-query protocol."
msgstr ""
"В дополнение к этим фундаментальным и обязательным операциям, протокол "
"расширенных запросов позволяет выполнить и несколько дополнительных операций."

#: protocol.xml:808(para)
msgid ""
"The Describe message (portal variant) specifies the name of an existing "
"portal (or an empty string for the unnamed portal). The response is a "
"RowDescription message describing the rows that will be returned by "
"executing the portal; or a NoData message if the portal does not contain a "
"query that will return rows; or ErrorResponse if there is no such portal."
msgstr ""
"В сообщении Describe (в вариации для портала) задаётся имя существующего "
"портала (пустая строка обозначает безымянный портал). В ответ передаётся "
"сообщение RowDescription, описывающее строки, которые будут возвращены при "
"выполнении портала; либо сообщение NoData, если портал не содержит запроса, "
"возвращающего строки; либо ErrorResponse, если такого портала нет."

#: protocol.xml:816(para)
msgid ""
"The Describe message (statement variant) specifies the name of an existing "
"prepared statement (or an empty string for the unnamed prepared statement). "
"The response is a ParameterDescription message describing the parameters "
"needed by the statement, followed by a RowDescription message describing the "
"rows that will be returned when the statement is eventually executed (or a "
"NoData message if the statement will not return rows). ErrorResponse is "
"issued if there is no such prepared statement. Note that since Bind has not "
"yet been issued, the formats to be used for returned columns are not yet "
"known to the backend; the format code fields in the RowDescription message "
"will be zeroes in this case."
msgstr ""
"В сообщении Describe (в вариации для оператора) задаётся имя существующего "
"подготовленного оператора (пустая строка обозначает безымянный "
"подготовленный оператор). В ответ передаётся сообщение ParameterDescription, "
"описывающее параметры, требующиеся для оператора, за которым следует "
"сообщение RowDescription, описывающее строки, которые будут возвращены, "
"когда оператор будет собственно выполнен (или сообщение NoData, если "
"оператор не возвратит строки). ErrorResponse выдаётся, если такой "
"подготовленный оператор отсутствует. Заметьте, что так как команда Bind не "
"выполнялась, сервер ещё не знает, в каком формате будут возвращаться "
"столбцы; в этом случае поля кодов формата в сообщении RowDescription будут "
"содержать нули."

#: protocol.xml:830(para)
msgid ""
"In most scenarios the frontend should issue one or the other variant of "
"Describe before issuing Execute, to ensure that it knows how to interpret "
"the results it will get back."
msgstr ""
"В большинстве случаев клиент должен выдать ту или иную вариацию Describe, "
"прежде чем выдавать Execute, чтобы понять, как интерпретировать результаты, "
"которые он получит."

#: protocol.xml:837(para)
msgid ""
"The Close message closes an existing prepared statement or portal and "
"releases resources. It is not an error to issue Close against a nonexistent "
"statement or portal name. The response is normally CloseComplete, but could "
"be ErrorResponse if some difficulty is encountered while releasing "
"resources. Note that closing a prepared statement implicitly closes any open "
"portals that were constructed from that statement."
msgstr ""
"Сообщение Close закрывает существующий подготовленный оператор или портал и "
"освобождает связанные ресурсы. При попытке выполнить Close для имени "
"несуществующего портала или оператора ошибки не будет. Ответ на это "
"сообщение обычно CloseComplete, но может быть и ErrorResponse, если при "
"освобождении ресурсов возникают проблемы. Заметьте, что при закрытии "
"подготовленного оператора неявно закрываются все открытые порталы, которые "
"были получены из этого оператора."

#: protocol.xml:847(para)
msgid ""
"The Flush message does not cause any specific output to be generated, but "
"forces the backend to deliver any data pending in its output buffers. A "
"Flush must be sent after any extended-query command except Sync, if the "
"frontend wishes to examine the results of that command before issuing more "
"commands. Without Flush, messages returned by the backend will be combined "
"into the minimum possible number of packets to minimize network overhead."
msgstr ""
"Сообщение Flush не приводит к генерации каких-либо данных, а указывает "
"серверу передать все данные, находящиеся в очереди в его буферах вывода. "
"Сообщение Flush клиент должен отправлять после любой команды расширенных "
"запросов, кроме Sync, если он желает проанализировать результаты этой "
"команды, прежде чем выдавать следующие команды. Без Flush сообщения, "
"возвращаемые сервером, будут объединяться вместе в минимальное количество "
"пакетов с целью уменьшения сетевого трафика."

#: protocol.xml:858(para)
msgid ""
"The simple Query message is approximately equivalent to the series Parse, "
"Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared "
"statement and portal objects and no parameters. One difference is that it "
"will accept multiple SQL statements in the query string, automatically "
"performing the bind/describe/execute sequence for each one in succession. "
"Another difference is that it will not return ParseComplete, BindComplete, "
"CloseComplete, or NoData messages."
msgstr ""
"Простое сообщение Query примерно равнозначно последовательности сообщений "
"Parse, Bind, Describe (для портала), Execute, Close, Sync, с использованием "
"объектов подготовленного оператора и портала без имён и без параметров. Одно "
"отличие состоит в том, что такое сообщение может содержать в строке запроса "
"несколько операторов SQL, для каждого из которых по очереди автоматически "
"выполняется последовательность Bind/Describe/Execute. Другое отличие состоит "
"в том, что в ответ на него не приходят сообщения ParseComplete, "
"BindComplete, CloseComplete или NoData."

#: protocol.xml:871(title)
msgid "Function Call"
msgstr "Вызов функций"

#: protocol.xml:873(para)
msgid ""
"The Function Call sub-protocol allows the client to request a direct call of "
"any function that exists in the database's <structname>pg_proc</structname> "
"system catalog. The client must have execute permission for the function."
msgstr ""
"Подраздел протокола &laquo;Вызов функций&raquo; позволяет клиенту запросить "
"непосредственный вызов любой функции, существующей в системном каталоге "
"<structname>pg_proc</structname>. При этом клиент должен иметь право на "
"выполнение этой функции."

#: protocol.xml:881(para)
msgid ""
"The Function Call sub-protocol is a legacy feature that is probably best "
"avoided in new code. Similar results can be accomplished by setting up a "
"prepared statement that does <literal>SELECT function($1, ...)</literal>. "
"The Function Call cycle can then be replaced with Bind/Execute."
msgstr ""
"Этот подраздел протокола считается устаревшим и в новом коде использовать "
"его не следует. Примерно тот же результат можно получить, подготовив "
"оператор с командой <literal>SELECT function($1, ...)</literal>. При таком "
"подходе цикл вызова функции заменяется последовательностью Bind/Execute."

#: protocol.xml:889(para)
msgid ""
"A Function Call cycle is initiated by the frontend sending a FunctionCall "
"message to the backend. The backend then sends one or more response messages "
"depending on the results of the function call, and finally a ReadyForQuery "
"response message. ReadyForQuery informs the frontend that it can safely send "
"a new query or function call."
msgstr ""
"Цикл вызова функции начинает клиент, передавая серверу сообщение "
"FunctionCall. Сервер возвращает одно или несколько сообщений ответа, в "
"зависимости от результата вызова функции, и завершающее сообщение "
"ReadyForQuery. ReadyForQuery говорит клиенту, что он может свободно "
"передавать новый запрос или вызов функции."

#: protocol.xml:912(term)
msgid "FunctionCallResponse"
msgstr "FunctionCallResponse (Ответ на вызов функции)"

#: protocol.xml:914(para)
msgid ""
"The function call was completed and returned the result given in the "
"message. (Note that the Function Call protocol can only handle a single "
"scalar result, not a row type or set of results.)"
msgstr ""
"Вызов функции завершён и в этом сообщении передаётся её результат. "
"(Заметьте, что протокол вызова функций позволяет выдать только один "
"скалярный результат, но не кортеж или набор результатов.)"

#: protocol.xml:926(para)
msgid ""
"Processing of the function call is complete. ReadyForQuery will always be "
"sent, whether processing terminates successfully or with an error."
msgstr ""
"Обработка вызова функции завершена. В ответ всегда передаётся ReadyForQuery, "
"независимо от того, была ли функция выполнена успешно или с ошибкой."

#: protocol.xml:937(para)
msgid ""
"A warning message has been issued in relation to the function call. Notices "
"are in addition to other responses, i.e., the backend will continue "
"processing the command."
msgstr ""
"Выдаётся предупреждение, связанное с вызовом функции. Эти замечания "
"дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать "
"вызов."

#: protocol.xml:949(title)
msgid "COPY Operations"
msgstr "Операции COPY"

#: protocol.xml:951(para)
msgid ""
"The <command>COPY</command> command allows high-speed bulk data transfer to "
"or from the server. Copy-in and copy-out operations each switch the "
"connection into a distinct sub-protocol, which lasts until the operation is "
"completed."
msgstr ""
"Команда <command>COPY</command> позволяет обеспечить скоростную передачу "
"данных на сервер или с сервера. Операции входящего и исходящего копирования "
"переключают соединение в отдельные режимы протокола, которые завершаются "
"только в конце операции."

#: protocol.xml:958(para)
msgid ""
"Copy-in mode (data transfer to the server) is initiated when the backend "
"executes a <command>COPY FROM STDIN</command> SQL statement. The backend "
"sends a CopyInResponse message to the frontend. The frontend should then "
"send zero or more CopyData messages, forming a stream of input data. (The "
"message boundaries are not required to have anything to do with row "
"boundaries, although that is often a reasonable choice.) The frontend can "
"terminate the copy-in mode by sending either a CopyDone message (allowing "
"successful termination) or a CopyFail message (which will cause the "
"<command>COPY</command> SQL statement to fail with an error). The backend "
"then reverts to the command-processing mode it was in before the "
"<command>COPY</command> started, which will be either simple or extended "
"query protocol. It will next send either CommandComplete (if successful) or "
"ErrorResponse (if not)."
msgstr ""
"Режим входящего копирования (передача данных на сервер) включается, когда "
"клиент выполняет SQL-оператор <command>COPY FROM STDIN</command>. Переходя в "
"этот режим, сервер передаёт клиенту сообщение CopyInResponse. После этого "
"клиент должен передать ноль или более сообщений CopyData, образующих поток "
"входных данных. (При этом границы сообщений не обязательно должны совпадать "
"с границами строк данных, хотя часто имеет смысл выровнять их.) Клиент может "
"завершить режим входящего копирования, передав либо сообщение CopyDone "
"(говорящее об успешном завершении), либо CopyFail (которое приведёт к "
"завершению SQL-оператора <command>COPY</command> с ошибкой). При этом сервер "
"вернётся в обычный режим обработки, в котором он находился до выполнения "
"команды <command>COPY</command> (это может быть протокол простых или "
"расширенных запросов). Затем он отправит сообщение CommandComplete (в случае "
"успешного завершения) или ErrorResponse (в противном случае)."

#: protocol.xml:974(para)
msgid ""
"In the event of a backend-detected error during copy-in mode (including "
"receipt of a CopyFail message), the backend will issue an ErrorResponse "
"message. If the <command>COPY</command> command was issued via an extended-"
"query message, the backend will now discard frontend messages until a Sync "
"message is received, then it will issue ReadyForQuery and return to normal "
"processing. If the <command>COPY</command> command was issued in a simple "
"Query message, the rest of that message is discarded and ReadyForQuery is "
"issued. In either case, any subsequent CopyData, CopyDone, or CopyFail "
"messages issued by the frontend will simply be dropped."
msgstr ""
"В случае возникновения ошибки в режиме входящего копирования (включая "
"получение сообщения CopyFail), сервер выдаёт сообщение ErrorResponse. Если "
"команда <command>COPY</command> была получена в сообщении расширенного "
"запроса, сервер не будет обрабатывать последующие сообщения клиента, пока не "
"получит сообщение Sync, после которого он выдаст ReadyForQuery и вернётся в "
"обычный режим работы. Если команда <command>COPY</command> была получена в "
"сообщении простого запроса, остальная часть сообщения игнорируется и сразу "
"выдаётся ReadyForQuery. В любом случае все последующие сообщения CopyData, "
"CopyDone или CopyFail, поступающие от клиента, будут просто игнорироваться."

#: protocol.xml:986(para)
msgid ""
"The backend will ignore Flush and Sync messages received during copy-in "
"mode. Receipt of any other non-copy message type constitutes an error that "
"will abort the copy-in state as described above. (The exception for Flush "
"and Sync is for the convenience of client libraries that always send Flush "
"or Sync after an Execute message, without checking whether the command to be "
"executed is a <command>COPY FROM STDIN</command>.)"
msgstr ""
"В режиме входящего копирования сервер игнорирует поступающие сообщения Flush "
"и Sync. При поступлении сообщений любого другого типа, не связанного с "
"копированием, возникает ошибка, приводящая к прерыванию режима входящего "
"копирования, как описано выше. (Исключение для сообщений Flush и Sync "
"сделано для удобства клиентских библиотек, которые всегда передают Flush или "
"Sync после сообщения Execute, не проверяя, не запускается ли в нём команда "
"<command>COPY FROM STDIN</command>.)"

#: protocol.xml:995(para)
msgid ""
"Copy-out mode (data transfer from the server) is initiated when the backend "
"executes a <command>COPY TO STDOUT</command> SQL statement. The backend "
"sends a CopyOutResponse message to the frontend, followed by zero or more "
"CopyData messages (always one per row), followed by CopyDone. The backend "
"then reverts to the command-processing mode it was in before the "
"<command>COPY</command> started, and sends CommandComplete. The frontend "
"cannot abort the transfer (except by closing the connection or issuing a "
"Cancel request), but it can discard unwanted CopyData and CopyDone messages."
msgstr ""
"Режим исходящего копирования (передача данных с сервера) включается, когда "
"клиент выполняет SQL-оператор <command>COPY TO STDOUT</command>. Переходя в "
"этот режим, сервер передаёт клиенту сообщение CopyOutResponse, за ним ноль "
"или более сообщений CopyData (всегда одно сообщение для каждой строки) и в "
"завершение CopyDone. Затем сервер возвращается в обычный режим обработки, в "
"котором он находился до выполнения команды <command>COPY</command>, и "
"передаёт CommandComplete. Клиент не может прервать передачу (кроме как "
"закрыв соединение или выдав запрос Cancel), но он может игнорировать "
"ненужные ему сообщения CopyData и CopyDone."

#: protocol.xml:1007(para)
msgid ""
"In the event of a backend-detected error during copy-out mode, the backend "
"will issue an ErrorResponse message and revert to normal processing. The "
"frontend should treat receipt of ErrorResponse as terminating the copy-out "
"mode."
msgstr ""
"В случае обнаружения ошибки в режиме исходящего копирования, сервер выдаёт "
"сообщение ErrorResponse и возвращается к обычной обработке. Клиент должен "
"воспринимать поступление ErrorResponse как завершение режима исходящего "
"копирования."

#: protocol.xml:1014(para)
msgid ""
"It is possible for NoticeResponse and ParameterStatus messages to be "
"interspersed between CopyData messages; frontends must handle these cases, "
"and should be prepared for other asynchronous message types as well (see "
"<xref linkend=\"protocol-async\"/>). Otherwise, any message type other than "
"CopyData or CopyDone may be treated as terminating copy-out mode."
msgstr ""
"Между сообщениями CopyData могут поступать сообщения NoticeResponse и "
"ParameterStatus; клиенты должны обрабатывать их и быть готовы принимать и "
"другие типы асинхронных сообщений (см. <xref remap=\"4\" linkend=\"protocol-"
"async\"/>). В остальном, сообщения любых типов, кроме CopyData и CopyDone, "
"могут восприниматься как завершающие режим исходящего копирования."

#: protocol.xml:1022(para)
msgid ""
"There is another Copy-related mode called copy-both, which allows high-speed "
"bulk data transfer to <emphasis>and</emphasis> from the server. Copy-both "
"mode is initiated when a backend in walsender mode executes a "
"<command>START_REPLICATION</command> statement. The backend sends a "
"CopyBothResponse message to the frontend. Both the backend and the frontend "
"may then send CopyData messages until either end sends a CopyDone message. "
"After the client sends a CopyDone message, the connection goes from copy-"
"both mode to copy-out mode, and the client may not send any more CopyData "
"messages. Similarly, when the server sends a CopyDone message, the "
"connection goes into copy-in mode, and the server may not send any more "
"CopyData messages. After both sides have sent a CopyDone message, the copy "
"mode is terminated, and the backend reverts to the command-processing mode. "
"In the event of a backend-detected error during copy-both mode, the backend "
"will issue an ErrorResponse message, discard frontend messages until a Sync "
"message is received, and then issue ReadyForQuery and return to normal "
"processing. The frontend should treat receipt of ErrorResponse as "
"terminating the copy in both directions; no CopyDone should be sent in this "
"case. See <xref linkend=\"protocol-replication\"/> for more information on "
"the subprotocol transmitted over copy-both mode."
msgstr ""
"Есть ещё один режим копирования, называемый двусторонним копированием и "
"обеспечивающий высокоскоростную передачу данных на <emphasis>и</emphasis> с "
"сервера. Двустороннее копирование запускается, когда клиент в режиме "
"walsender выполняет оператор <command>START_REPLICATION</command>. В ответ "
"сервер передаёт клиенту сообщение CopyBothResponse. Затем и сервер, и клиент "
"могут передавать друг другу сообщения CopyData, пока кто-то из них не "
"завершит передачу сообщением CopyDone. Когда сообщение CopyDone передаёт "
"клиент, соединение переходит из режима двустороннего в режим исходящего "
"копирования и клиент больше не может передавать сообщения CopyData. "
"Аналогично, когда сообщение CopyDone передаёт сервер, соединение переходит в "
"режим входящего копирования и сервер больше не может передавать сообщения "
"CopyData. Когда сообщения CopyDone переданы обеими сторонами, режим "
"копирования завершается и сервер возвращается в режим обработки команд. В "
"случае обнаружения ошибки на стороне сервера в режиме двустороннего "
"копирования, сервер выдаёт сообщение ErrorResponse, пропускает следующие "
"сообщения клиента, пока не будет получено сообщение Sync, а затем выдаёт "
"ReadyForQuery и возвращается к обычной обработке. Клиент должен воспринимать "
"получение ErrorResponse как завершение двустороннего копирования; в этом "
"случае сообщение CopyDone посылаться не должно. За дополнительной "
"информацией о подразделе протокола, управляющем двусторонним копированием, "
"обратитесь к <xref remap=\"3\" linkend=\"protocol-replication\"/>."

#: protocol.xml:1045(para)
msgid ""
"The CopyInResponse, CopyOutResponse and CopyBothResponse messages include "
"fields that inform the frontend of the number of columns per row and the "
"format codes being used for each column. (As of the present implementation, "
"all columns in a given <command>COPY</command> operation will use the same "
"format, but the message design does not assume this.)"
msgstr ""
"Сообщения CopyInResponse, CopyOutResponse и CopyBothResponse содержат поля, "
"из которых клиент может узнать количество столбцов в строке и код формата "
"для каждого столбца. (В текущей реализации для всех столбцов в заданной "
"операции <command>COPY</command> устанавливается один формат, но в "
"конструкции сообщения это не заложено.)"

#: protocol.xml:1057(title)
msgid "Asynchronous Operations"
msgstr "Асинхронные операции"

#: protocol.xml:1059(para)
msgid ""
"There are several cases in which the backend will send messages that are not "
"specifically prompted by the frontend's command stream. Frontends must be "
"prepared to deal with these messages at any time, even when not engaged in a "
"query. At minimum, one should check for these cases before beginning to read "
"a query response."
msgstr ""
"Возможны ситуации, в которых сервер будет отправлять клиенту сообщения, не "
"предполагаемые потоком команд в текущем режиме. Клиенты должны быть готовы "
"принять эти сообщения в любой момент, даже не в процессе выполнения запроса. "
"Как минимум, следует проверять такие сообщения, прежде чем начинать читать "
"ответ на запрос."

#: protocol.xml:1068(para)
msgid ""
"It is possible for NoticeResponse messages to be generated due to outside "
"activity; for example, if the database administrator commands a <quote>fast</"
"quote> database shutdown, the backend will send a NoticeResponse indicating "
"this fact before closing the connection. Accordingly, frontends should "
"always be prepared to accept and display NoticeResponse messages, even when "
"the connection is nominally idle."
msgstr ""
"Сообщения NoticeResponse могут выдаваться вследствие внешней активности; "
"например, если администратор инициирует <quote>быстрое</quote> отключение "
"баз данных, сервер отправит NoticeResponse, сигнализирующее об этом факте, "
"прежде чем закрывать соединение. Соответственно, клиенты должны быть готовы "
"всегда принять и вывести сообщения NoticeResponse, даже когда соединение "
"фактически простаивает."

#: protocol.xml:1077(para)
msgid ""
"ParameterStatus messages will be generated whenever the active value changes "
"for any of the parameters the backend believes the frontend should know "
"about. Most commonly this occurs in response to a <command>SET</command> SQL "
"command executed by the frontend, and this case is effectively synchronous "
"&mdash; but it is also possible for parameter status changes to occur "
"because the administrator changed a configuration file and then sent the "
"<systemitem>SIGHUP</systemitem> signal to the server. Also, if a "
"<command>SET</command> command is rolled back, an appropriate "
"ParameterStatus message will be generated to report the current effective "
"value."
msgstr ""
"Сообщения ParameterStatus будут выдаваться всякий раз, когда меняется "
"действующее значение одного из параметров, об изменении которых, по мнению "
"сервера, должен знать клиент. Чаще всего это происходит в ответ на SQL-"
"команду <command>SET</command>, выполняемую клиентом и в таком случае это "
"сообщение по сути синхронно &mdash; но состояние параметров может меняться и "
"когда администратор изменяет файл конфигурации, а затем посылает серверу "
"сигнал <systemitem>SIGHUP</systemitem>. Также, если действие команды "
"<command>SET</command> отменяется, клиенту передаётся сообщение "
"ParameterStatus, в котором отражается текущее значение параметра."

#: protocol.xml:1091(para)
msgid ""
"At present there is a hard-wired set of parameters for which ParameterStatus "
"will be generated: they are <varname>server_version</varname>, "
"<varname>server_encoding</varname>, <varname>client_encoding</varname>, "
"<varname>application_name</varname>, <varname>is_superuser</varname>, "
"<varname>session_authorization</varname>, <varname>DateStyle</varname>, "
"<varname>IntervalStyle</varname>, <varname>TimeZone</varname>, "
"<varname>integer_datetimes</varname>, and "
"<varname>standard_conforming_strings</varname>. (<varname>server_encoding</"
"varname>, <varname>TimeZone</varname>, and <varname>integer_datetimes</"
"varname> were not reported by releases before 8.0; "
"<varname>standard_conforming_strings</varname> was not reported by releases "
"before 8.1; <varname>IntervalStyle</varname> was not reported by releases "
"before 8.4; <varname>application_name</varname> was not reported by releases "
"before 9.0.) Note that <varname>server_version</varname>, "
"<varname>server_encoding</varname> and <varname>integer_datetimes</varname> "
"are pseudo-parameters that cannot change after startup. This set might "
"change in the future, or even become configurable. Accordingly, a frontend "
"should simply ignore ParameterStatus for parameters that it does not "
"understand or care about."
msgstr ""
"В настоящее время есть жёстко зафиксированный набор параметров, при "
"изменении которых выдаётся ParameterStatus: <varname>server_version</"
"varname>, <varname>server_encoding</varname>, <varname>client_encoding</"
"varname>, <varname>application_name</varname>, <varname>is_superuser</"
"varname>, <varname>session_authorization</varname>, <varname>DateStyle</"
"varname>, <varname>IntervalStyle</varname>, <varname>TimeZone</varname>, "
"<varname>integer_datetimes</varname> и <varname>standard_conforming_strings</"
"varname>. (<varname>server_encoding</varname>, <varname>TimeZone</varname> и "
"<varname>integer_datetimes</varname> не отслеживались до версии 8.0; "
"<varname>standard_conforming_strings</varname> не отслеживался до 8.1; "
"<varname>IntervalStyle</varname> — до версии 8.4; <varname>application_name</"
"varname> — до версии 9.0.) Заметьте, что <varname>server_version</varname>, "
"<varname>server_encoding</varname> и <varname>integer_datetimes</varname> — "
"это псевдопараметры, которые не могут меняться после запуска сервера. Этот "
"набор может быть изменён в будущем или даже будет настраиваемым. "
"Соответственно, клиент может просто игнорировать сообщения ParameterStatus "
"для параметров, которые ему неизвестны или не представляют интереса."

#: protocol.xml:1121(para)
msgid ""
"If a frontend issues a <command>LISTEN</command> command, then the backend "
"will send a NotificationResponse message (not to be confused with "
"NoticeResponse!) whenever a <command>NOTIFY</command> command is executed "
"for the same channel name."
msgstr ""
"Если клиент выполняет команду <command>LISTEN</command>, сервер будет "
"передавать ему сообщения NotificationResponse (не путайте с "
"NoticeResponse!), когда для канала с тем же именем затем будет выполняться "
"команда <command>NOTIFY</command>."

#: protocol.xml:1130(para)
msgid ""
"At present, NotificationResponse can only be sent outside a transaction, and "
"thus it will not occur in the middle of a command-response series, though it "
"might occur just before ReadyForQuery. It is unwise to design frontend logic "
"that assumes that, however. Good practice is to be able to accept "
"NotificationResponse at any point in the protocol."
msgstr ""
"В настоящее время, сообщение NotificationResponse может быть передано только "
"вне транзакции, так что оно не может оказаться в середине серии ответов на "
"команду, хотя может поступить сразу после ReadyForQuery. Однако полагаться "
"на это при проектировании логики клиента неразумно. Лучше разработать код "
"так, чтобы NotificationResponse могло быть принято в любой фазе протокола."

#: protocol.xml:1142(title)
msgid "Canceling Requests in Progress"
msgstr "Отмена выполняющихся запросов"

#: protocol.xml:1144(para)
msgid ""
"During the processing of a query, the frontend might request cancellation of "
"the query. The cancel request is not sent directly on the open connection to "
"the backend for reasons of implementation efficiency: we don't want to have "
"the backend constantly checking for new input from the frontend during query "
"processing. Cancel requests should be relatively infrequent, so we make them "
"slightly cumbersome in order to avoid a penalty in the normal case."
msgstr ""
"В процессе обработки запроса клиент может запросить отмену этого запроса. "
"Запрос отмены не передаётся серверу непосредственно через открытое "
"соединение из соображений эффективности: мы не хотим, чтобы сервер постоянно "
"проверял поступающие от клиента сообщения в процессе выполнения запроса. "
"Запросы отмены должны быть относительно редкими, поэтому мы выбрали для них "
"не самый простой путь во избежание негативного влияния на обычный режим "
"работы."

#: protocol.xml:1155(para)
msgid ""
"To issue a cancel request, the frontend opens a new connection to the server "
"and sends a CancelRequest message, rather than the StartupMessage message "
"that would ordinarily be sent across a new connection. The server will "
"process this request and then close the connection. For security reasons, no "
"direct reply is made to the cancel request message."
msgstr ""
"Чтобы запросить отмену запроса, клиент должен установить новое подключение к "
"серверу и отправить ему сообщение CancelRequest, вместо StartupMessage, "
"обычно передаваемого при установлении нового подключения. Сервер обработает "
"полученную команду и закроет это подключение. По соображениям безопасности "
"сервер не отвечает непосредственно на сообщение с запросом отмены."

#: protocol.xml:1164(para)
msgid ""
"A CancelRequest message will be ignored unless it contains the same key data "
"(PID and secret key) passed to the frontend during connection start-up. If "
"the request matches the PID and secret key for a currently executing "
"backend, the processing of the current query is aborted. (In the existing "
"implementation, this is done by sending a special signal to the backend "
"process that is processing the query.)"
msgstr ""
"Сообщение CancelRequest обрабатывается, только если оно содержит те же "
"ключевые данные (PID и секретный ключ), что были переданы клиенту при "
"запуске. Если PID и секретный ключ в запросе соответствуют данным "
"выполняющегося в данный момент обслуживающего процесса, обработка текущего "
"запроса в нём прерывается. (В существующей реализации это осуществляется "
"путём передачи специального сигнала данному обслуживающему процессу.)"

#: protocol.xml:1174(para)
msgid ""
"The cancellation signal might or might not have any effect &mdash; for "
"example, if it arrives after the backend has finished processing the query, "
"then it will have no effect. If the cancellation is effective, it results in "
"the current command being terminated early with an error message."
msgstr ""
"Сигнал отмены может подействовать, а может и не подействовать (например, "
"если он поступит после того, как сервер завершит обработку запроса). Если "
"отмена действительно происходит, текущая команда прерывается досрочно с "
"сообщением об ошибке."

#: protocol.xml:1182(para)
msgid ""
"The upshot of all this is that for reasons of both security and efficiency, "
"the frontend has no direct way to tell whether a cancel request has "
"succeeded. It must continue to wait for the backend to respond to the query. "
"Issuing a cancel simply improves the odds that the current query will finish "
"soon, and improves the odds that it will fail with an error message instead "
"of succeeding."
msgstr ""
"Вследствие такой организации, объясняемой соображениями безопасности и "
"эффективности, клиент не может непосредственно определить, был ли запрос "
"отмены успешен. Он должен продолжать ожидать ответа сервера на исходный "
"запрос. Запрос отмены просто увеличивает вероятность того, что текущий "
"запрос завершится быстрее, как и вероятность того, что он будет завершён не "
"успешно, а с ошибкой."

#: protocol.xml:1192(para)
msgid ""
"Since the cancel request is sent across a new connection to the server and "
"not across the regular frontend/backend communication link, it is possible "
"for the cancel request to be issued by any process, not just the frontend "
"whose query is to be canceled. This might provide additional flexibility "
"when building multiple-process applications. It also introduces a security "
"risk, in that unauthorized persons might try to cancel queries. The security "
"risk is addressed by requiring a dynamically generated secret key to be "
"supplied in cancel requests."
msgstr ""
"Так как запрос отмены передаётся серверу через новое подключение к серверу, "
"а не через обычный канал связи клиент-сервер, такие запросы могут выдавать "
"любые процессы, а не только клиентский процесс, запрос которого требуется "
"отменить. Это может дать дополнительную гибкость при построении "
"многопроцессных приложений. Это также представляет собой угрозу "
"безопасности, так как попытаться отменить запросы могут и неавторизованные "
"пользователи. Для ликвидации этой угрозы в запросах отмены требуется "
"передавать динамически генерируемый секретный ключ."

#: protocol.xml:1206(title)
msgid "Termination"
msgstr "Завершение"

#: protocol.xml:1208(para)
msgid ""
"The normal, graceful termination procedure is that the frontend sends a "
"Terminate message and immediately closes the connection. On receipt of this "
"message, the backend closes the connection and terminates."
msgstr ""
"Обычная процедура мягкого завершения заключается в том, что клиент "
"отправляет сообщение Terminate и немедленно закрывает соединение. Получая "
"это сообщение, обслуживающий процесс закрывает соединение и завершается."

#: protocol.xml:1215(para)
msgid ""
"In rare cases (such as an administrator-commanded database shutdown) the "
"backend might disconnect without any frontend request to do so. In such "
"cases the backend will attempt to send an error or notice message giving the "
"reason for the disconnection before it closes the connection."
msgstr ""
"В редких случаях (например, при отключении базы данных по команде "
"администратора) обслуживающий процесс может отключиться, даже если клиент не "
"запрашивает этого. В таких случаях, перед тем, как закрыть соединение, этот "
"процесс пытается передать сообщение с ошибкой или уведомлением, в котором "
"будет указана причина отключения."

#: protocol.xml:1222(para)
msgid ""
"Other termination scenarios arise from various failure cases, such as core "
"dump at one end or the other, loss of the communications link, loss of "
"message-boundary synchronization, etc. If either frontend or backend sees an "
"unexpected closure of the connection, it should clean up and terminate. The "
"frontend has the option of launching a new backend by recontacting the "
"server if it doesn't want to terminate itself. Closing the connection is "
"also advisable if an unrecognizable message type is received, since this "
"probably indicates loss of message-boundary sync."
msgstr ""
"Другие сценарии завершения возникают с различными вариантами отказа, "
"например, при критическом сбое с дампом памяти на одной или другой стороне, "
"при потере канала соединения, потере синхронизации по границам сообщений и "
"т. д. Если клиент или сервер обнаруживает, что соединение было неожиданно "
"закрыто, он должен очистить ресурсы и завершиться. Клиент при этом может "
"запустить новый обслуживающий процесс, переподключившись к серверу, если он "
"сам хочет продолжать работу. Закрывать соединение также рекомендуется при "
"получении сообщений нераспознанного типа, так как это может быть признаком "
"потери синхронизации по границам сообщений."

#: protocol.xml:1233(para)
msgid ""
"For either normal or abnormal termination, any open transaction is rolled "
"back, not committed. One should note however that if a frontend disconnects "
"while a non-<command>SELECT</command> query is being processed, the backend "
"will probably finish the query before noticing the disconnection. If the "
"query is outside any transaction block (<command>BEGIN</command> ... "
"<command>COMMIT</command> sequence) then its results might be committed "
"before the disconnection is recognized."
msgstr ""
"При штатном или нештатном завершении сеанса любая открытая транзакция "
"откатывается, а не фиксируется. Однако следует заметить, что при отключении "
"клиента в процессе обработки запроса, отличного от <command>SELECT</"
"command>, обслуживающий процесс вероятнее всего завершит запрос, прежде чем "
"заметит отключение. Если запрос выполняется не в блоке транзакции (вне "
"последовательности <command>BEGIN</command> ... <command>COMMIT</command>), "
"его результаты могут быть зафиксированы до того, как будет обнаружено "
"отключение."

#: protocol.xml:1246(title)
msgid "<acronym>SSL</acronym> Session Encryption"
msgstr "Защита сеанса с <acronym>SSL</acronym>"

#: protocol.xml:1248(para)
msgid ""
"If <productname>PostgreSQL</productname> was built with <acronym>SSL</"
"acronym> support, frontend/backend communications can be encrypted using "
"<acronym>SSL</acronym>. This provides communication security in environments "
"where attackers might be able to capture the session traffic. For more "
"information on encrypting <productname>PostgreSQL</productname> sessions "
"with <acronym>SSL</acronym>, see <xref linkend=\"ssl-tcp\"/>."
msgstr ""
"Если <productname>PostgreSQL</productname> был собран с поддержкой "
"<acronym>SSL</acronym>, взаимодействие клиента с сервером может быть "
"зашифровано с применением <acronym>SSL</acronym>. Это обеспечивает защиту на "
"уровне канала в среде, где злоумышленники могут перехватить трафик сеанса. "
"За дополнительными сведениями о шифровании трафика сеансов "
"<productname>PostgreSQL</productname> с использованием <acronym>SSL</"
"acronym>, обратитесь к <xref remap=\"3\" linkend=\"ssl-tcp\"/>."

#: protocol.xml:1258(para)
msgid ""
"To initiate an <acronym>SSL</acronym>-encrypted connection, the frontend "
"initially sends an SSLRequest message rather than a StartupMessage. The "
"server then responds with a single byte containing <literal>S</literal> or "
"<literal>N</literal>, indicating that it is willing or unwilling to perform "
"<acronym>SSL</acronym>, respectively. The frontend might close the "
"connection at this point if it is dissatisfied with the response. To "
"continue after <literal>S</literal>, perform an <acronym>SSL</acronym> "
"startup handshake (not described here, part of the <acronym>SSL</acronym> "
"specification) with the server. If this is successful, continue with sending "
"the usual StartupMessage. In this case the StartupMessage and all subsequent "
"data will be <acronym>SSL</acronym>-encrypted. To continue after <literal>N</"
"literal>, send the usual StartupMessage and proceed without encryption."
msgstr ""
"Чтобы начать сеанс с <acronym>SSL</acronym>-шифрованием, клиент передаёт "
"серверу вместо StartupMessage сообщение SSLRequest. В ответ сервер передаёт "
"один байт, содержащий символ <literal>S</literal> или <literal>N</literal>, "
"показывающий, что он желает, либо не желает включать <acronym>SSL</acronym>, "
"соответственно. Если клиент не удовлетворён ответом, он должен закрыть "
"соединение на этом этапе. Чтобы продолжить установление соединения после "
"получения <literal>S</literal>, он выполняет начальное согласование "
"<acronym>SSL</acronym> с сервером (не описывается здесь, так как относится к "
"протоколу <acronym>SSL</acronym>). Если эта процедура выполняется успешно, "
"он продолжает соединение, передавая обычное сообщение StartupMessage. При "
"этом StartupMessage и все последующие данные будут защищены <acronym>SSL</"
"acronym>-шифрованием. Чтобы продолжить после получения <literal>N</literal>, "
"клиент может передать обычное сообщение StartupMessage и дальше "
"взаимодействовать с сервером без шифрования."

#: protocol.xml:1276(para)
msgid ""
"The frontend should also be prepared to handle an ErrorMessage response to "
"SSLRequest from the server. This would only occur if the server predates the "
"addition of <acronym>SSL</acronym> support to <productname>PostgreSQL</"
"productname>. (Such servers are now very ancient, and likely do not exist in "
"the wild anymore.) In this case the connection must be closed, but the "
"frontend might choose to open a fresh connection and proceed without "
"requesting <acronym>SSL</acronym>."
msgstr ""
"Клиент также должен быть готов обработать сообщение ErrorMessage, полученное "
"от сервера в ответ на SSLRequest. Такая ситуация возможна, только если "
"сервер имеет версию, которая ещё не поддерживала <acronym>SSL</acronym> в "
"<productname>PostgreSQL</productname>. (Такие серверы сейчас антикварная "
"редкость, и скорее всего их уже не встретить в природе.) В этом случае "
"соединение должно быть закрыто, но клиент может решить открыть новое "
"соединение, не запрашивая <acronym>SSL</acronym>-шифрование."

#: protocol.xml:1287(para)
msgid ""
"An initial SSLRequest can also be used in a connection that is being opened "
"to send a CancelRequest message."
msgstr ""
"Начальный запрос SSLRequest может также передаваться при установлении "
"соединения, открываемого для передачи сообщения CancelRequest."

#: protocol.xml:1292(para)
msgid ""
"While the protocol itself does not provide a way for the server to force "
"<acronym>SSL</acronym> encryption, the administrator can configure the "
"server to reject unencrypted sessions as a byproduct of authentication "
"checking."
msgstr ""
"Так как в самом протоколе не предусмотрено принудительное включение "
"<acronym>SSL</acronym>-шифрования сервером, администратор может настроить "
"сервер так, чтобы в качестве дополнительного условия при проверке "
"подлинности клиента он не принимал незашифрованные сеансы."

#: protocol.xml:1302(title)
msgid "Streaming Replication Protocol"
msgstr "Протокол потоковой репликации"

#: protocol.xml:1304(para)
msgid ""
"To initiate streaming replication, the frontend sends the "
"<literal>replication</literal> parameter in the startup message. A Boolean "
"value of <literal>true</literal> tells the backend to go into walsender "
"mode, wherein a small set of replication commands can be issued instead of "
"SQL statements. Only the simple query protocol can be used in walsender "
"mode. Replication commands are logged in the server log when <xref linkend="
"\"guc-log-replication-commands\"/> is enabled. Passing <literal>database</"
"literal> as the value instructs walsender to connect to the database "
"specified in the <literal>dbname</literal> parameter, which will allow the "
"connection to be used for logical replication from that database."
msgstr ""
"Чтобы инициировать потоковую репликацию, клиент передаёт в стартовом "
"сообщении параметр <literal>replication</literal>. Логическое значение "
"<literal>true</literal> этого параметра указывает обслуживающему процессу "
"перейти в режим передачи WAL (walsender), в котором вместо SQL-операторов "
"клиент может выдавать только ограниченный набор команд репликации. В режиме "
"walsender можно использовать только протокол простых запросов. Команды "
"репликации будут записываться в журнал сообщений сервера, если включён режим "
"<xref linkend=\"guc-log-replication-commands\"/>. Если этот параметр имеет "
"значение <literal>database</literal>, процесс walsender должен подключиться "
"к базе данных, указанной в параметре <literal>dbname</literal>, что позволит "
"использовать это подключение для логической репликации с указанной базой "
"данных."

#: protocol.xml:1321(programlisting)
#, no-wrap
msgid "psql \"dbname=postgres replication=database\" -c \"IDENTIFY_SYSTEM;\""
msgstr "psql \"dbname=postgres replication=database\" -c \"IDENTIFY_SYSTEM;\""

#: protocol.xml:1316(para)
msgid ""
"For the purpose of testing replication commands, you can make a replication "
"connection via <application>psql</application> or any other <literal>libpq</"
"literal>-using tool with a connection string including the "
"<literal>replication</literal> option, e.g.: <placeholder-1/> However, it is "
"often more useful to use <xref linkend=\"app-pgreceivexlog\"/> (for physical "
"replication) or <xref linkend=\"app-pgrecvlogical\"/> (for logical "
"replication)."
msgstr ""
"Для тестирования команд репликации вы можете установить соединение для "
"репликации, запустив <application>psql</application> или другую программу на "
"базе <literal>libpq</literal> со строкой подключения, включающей параметр "
"<literal>replication</literal>, например так: <placeholder-1/> Однако часто "
"полезнее использовать <xref linkend=\"app-pgreceivexlog\"/> (для физической "
"репликации) или <xref linkend=\"app-pgrecvlogical\"/> (для логической)."

#: protocol.xml:1333(literal)
msgid "IDENTIFY_SYSTEM"
msgstr "IDENTIFY_SYSTEM"

#: protocol.xml:1334(indexterm)
msgid "<primary>IDENTIFY_SYSTEM</primary>"
msgstr "<primary>IDENTIFY_SYSTEM</primary>"

#: protocol.xml:1337(para)
msgid ""
"Requests the server to identify itself. Server replies with a result set of "
"a single row, containing four fields:"
msgstr ""
"Запрашивает идентификационные данные сервера. Сервер возвращает набор "
"результатов с одной строкой, содержащей четыре поля:"

#: protocol.xml:1345(term)
msgid "<literal>systemid</literal> (<type>text</type>)"
msgstr "<literal>systemid</literal> (<type>text</type>)"

#: protocol.xml:1349(para)
msgid ""
"The unique system identifier identifying the cluster. This can be used to "
"check that the base backup used to initialize the standby came from the same "
"cluster."
msgstr ""
"Уникальный идентификатор системы, идентифицирующий кластер. По нему можно "
"определить, что базовая резервная копия, из которой инициализировался "
"резервный сервер, получена из того же кластера."

#: protocol.xml:1358(term)
msgid "<literal>timeline</literal> (<type>int4</type>)"
msgstr "<literal>timeline</literal> (<type>int4</type>)"

#: protocol.xml:1362(para)
msgid ""
"Current timeline ID. Also useful to check that the standby is consistent "
"with the master."
msgstr ""
"Идентификатор текущей линии времени. Также полезен для того, чтобы "
"убедиться, что резервный сервер согласован с главным."

#: protocol.xml:1370(term)
msgid "<literal>xlogpos</literal> (<type>text</type>)"
msgstr "<literal>xlogpos</literal> (<type>text</type>)"

#: protocol.xml:1374(para)
msgid ""
"Current xlog flush location. Useful to get a known location in the "
"transaction log where streaming can start."
msgstr ""
"Текущее положение сохранённых данных в xlog. Позволяет узнать, с какой "
"позиции в журнале транзакций может начаться потоковая передача."

#: protocol.xml:1382(term)
msgid "<literal>dbname</literal> (<type>text</type>)"
msgstr "<literal>dbname</literal> (<type>text</type>)"

#: protocol.xml:1386(para)
msgid "Database connected to or null."
msgstr "Подключённая база данных или NULL."

#: protocol.xml:1398(literal)
msgid "TIMELINE_HISTORY"
msgstr "TIMELINE_HISTORY"

#: protocol.xml:1398(replaceable)
msgid "tli"
msgstr "tli"

#: protocol.xml:1399(indexterm)
msgid "<primary>TIMELINE_HISTORY</primary>"
msgstr "<primary>TIMELINE_HISTORY</primary>"

#: protocol.xml:1402(para)
msgid ""
"Requests the server to send over the timeline history file for timeline "
"<replaceable class=\"parameter\">tli</replaceable>. Server replies with a "
"result set of a single row, containing two fields:"
msgstr ""
"Запрашивает с сервера файл истории для линии времени <replaceable class="
"\"parameter\">лин_врем</replaceable>. Сервер возвращает набор результатов с "
"одной строкой, содержащей два поля:"

#: protocol.xml:1411(term)
msgid "<literal>filename</literal> (<type>text</type>)"
msgstr "<literal>filename</literal> (<type>text</type>)"

#: protocol.xml:1415(para)
msgid ""
"File name of the timeline history file, e.g., <filename>00000002.history</"
"filename>."
msgstr ""
"Имя файла с историей линии времени, например <filename>00000002.history</"
"filename>."

#: protocol.xml:1422(term)
msgid "<literal>content</literal> (<type>bytea</type>)"
msgstr "<literal>content</literal> (<type>bytea</type>)"

#: protocol.xml:1426(para)
msgid "Contents of the timeline history file."
msgstr "Содержимое файла с историей линией времени."

#: protocol.xml:1439(indexterm)
msgid "<primary>CREATE_REPLICATION_SLOT</primary>"
msgstr "<primary>CREATE_REPLICATION_SLOT</primary>"

#: protocol.xml:1438(term)
msgid ""
"<literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter"
"\">slot_name</replaceable> { <literal>PHYSICAL</literal> "
"[ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable "
"class=\"parameter\">output_plugin</replaceable> } <placeholder-1/>"
msgstr ""
"<literal>CREATE_REPLICATION_SLOT</literal> <replaceable class=\"parameter"
"\">имя_слота</replaceable> { <literal>PHYSICAL</literal> "
"[ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable "
"class=\"parameter\">модуль_вывода</replaceable> } <placeholder-1/>"

#: protocol.xml:1442(para)
msgid ""
"Create a physical or logical replication slot. See <xref linkend=\"streaming-"
"replication-slots\"/> for more about replication slots."
msgstr ""
"Создаёт слот физической или логической репликации. Слоты репликации описаны "
"подробно в <xref remap=\"6\" linkend=\"streaming-replication-slots\"/>."

#: protocol.xml:1449(replaceable) protocol.xml:1835(replaceable)
#: protocol.xml:1875(replaceable) protocol.xml:1885(replaceable)
msgid "slot_name"
msgstr "имя_слота"

#: protocol.xml:1451(para)
msgid ""
"The name of the slot to create. Must be a valid replication slot name (see "
"<xref linkend=\"streaming-replication-slots-manipulation\"/>)."
msgstr ""
"Имя создаваемого слота. Заданное имя должно быть допустимым для слота "
"репликации (см. <xref remap=\"4\" linkend=\"streaming-replication-slots-"
"manipulation\"/>)."

#: protocol.xml:1459(replaceable)
msgid "output_plugin"
msgstr "модуль_вывода"

#: protocol.xml:1461(para)
msgid ""
"The name of the output plugin used for logical decoding (see <xref linkend="
"\"logicaldecoding-output-plugin\"/>)."
msgstr ""
"Имя модуля вывода, применяемого для логического декодирования (см. <xref "
"remap=\"4\" linkend=\"logicaldecoding-output-plugin\"/>)."

#: protocol.xml:1469(literal)
msgid "RESERVE_WAL"
msgstr "RESERVE_WAL"

#: protocol.xml:1471(para)
msgid ""
"Specify that this physical replication slot reserves <acronym>WAL</acronym> "
"immediately. Otherwise, <acronym>WAL</acronym> is only reserved upon "
"connection from a streaming replication client."
msgstr ""
"Указывает, что этот слот физической репликации резервирует <acronym>WAL</"
"acronym> немедленно. Без этого указания <acronym>WAL</acronym> резервируется "
"только при подключении клиента потоковой репликации."

#: protocol.xml:1484(indexterm)
msgid "<primary>START_REPLICATION</primary>"
msgstr "<primary>START_REPLICATION</primary>"

#: protocol.xml:1483(term)
msgid ""
"<literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable "
"class=\"parameter\">slot_name</replaceable> ] [ <literal>PHYSICAL</"
"literal> ] <replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ <literal>TIMELINE</literal> <replaceable class=\"parameter\">tli</"
"replaceable> ] <placeholder-1/>"
msgstr ""
"<literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable "
"class=\"parameter\">имя_слота</replaceable> ] [ <literal>PHYSICAL</"
"literal> ] <replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ <literal>TIMELINE</literal> <replaceable class=\"parameter\">лин_врем</"
"replaceable> ] <placeholder-1/>"

#: protocol.xml:1487(para)
msgid ""
"Instructs server to start streaming WAL, starting at WAL position "
"<replaceable class=\"parameter\">XXX/XXX</replaceable>. If "
"<literal>TIMELINE</literal> option is specified, streaming starts on "
"timeline <replaceable class=\"parameter\">tli</replaceable>; otherwise, the "
"server's current timeline is selected. The server can reply with an error, "
"for example if the requested section of WAL has already been recycled. On "
"success, server responds with a CopyBothResponse message, and then starts to "
"stream WAL to the frontend."
msgstr ""
"Указывает серверу начать потоковую передачу WAL, начиная с позиции "
"<replaceable class=\"parameter\">XXX/XXX</replaceable> в WAL. Если "
"указывается параметр <literal>TIMELINE</literal>, передача начинается на "
"линии времени <replaceable class=\"parameter\">лин_врем</replaceable>, иначе "
"выбирается текущая линия времени сервера. Сервер может вернуть в ответ "
"ошибку, например, если запрошенный сегмент WAL уже потерян. Если проблем не "
"возникает, сервер возвращает сообщение CopyBothResponse, а затем начинает "
"передавать поток WAL клиенту."

#: protocol.xml:1498(para)
msgid ""
"If a slot's name is provided via <replaceable class=\"parameter\">slot_name</"
"replaceable>, it will be updated as replication progresses so that the "
"server knows which WAL segments, and if <varname>hot_standby_feedback</"
"varname> is on which transactions, are still needed by the standby."
msgstr ""
"Если в параметрах передаётся <replaceable class=\"parameter\">имя_слота</"
"replaceable>, сервер будет отражать состояние репликации в этом слоте и "
"отслеживать, какие сегменты, а если включён режим "
"<varname>hot_standby_feedback</varname>, то и в каких транзакциях, всё ещё "
"нужны этому резервному серверу."

#: protocol.xml:1506(para)
msgid ""
"If the client requests a timeline that's not the latest but is part of the "
"history of the server, the server will stream all the WAL on that timeline "
"starting from the requested start point up to the point where the server "
"switched to another timeline. If the client requests streaming at exactly "
"the end of an old timeline, the server responds immediately with "
"CommandComplete without entering COPY mode."
msgstr ""
"Если клиент запрашивает не последнюю, но существующую в истории сервера "
"линию времени, сервер будет передавать весь WAL на этой линии времени, "
"начиная с запрошенной стартовой точки до момента, когда сервер переключился "
"на другую линию времени. Если клиент запрашивает передачу с начальной "
"позицией точно в конце старой линии времени, сервер немедленно отвечает "
"CommandComplete, не переходя в режим COPY."

#: protocol.xml:1515(para)
msgid ""
"After streaming all the WAL on a timeline that is not the latest one, the "
"server will end streaming by exiting the COPY mode. When the client "
"acknowledges this by also exiting COPY mode, the server sends a result set "
"with one row and two columns, indicating the next timeline in this server's "
"history. The first column is the next timeline's ID (type <type>int8</"
"type>), and the second column is the WAL position where the switch happened "
"(type <type>text</type>). Usually, the switch position is the end of the WAL "
"that was streamed, but there are corner cases where the server can send some "
"WAL from the old timeline that it has not itself replayed before promoting. "
"Finally, the server sends CommandComplete message, and is ready to accept a "
"new command."
msgstr ""
"После передачи всех записей WAL на линии времени, не являющейся текущей, "
"сервер завершает потоковую передачу, выходя из режима копирования. Когда "
"клиент подтверждает завершение передачи, также выходя из режима копирования, "
"сервер возвращает набор результатов в одной строке с двумя столбцами, "
"сообщая таким образом о следующей линии времени в истории сервера. В первом "
"столбце передаётся идентификатор следующей линии времени (типа <type>int8</"
"type>), а во втором — позиция в WAL, в которой произошло переключение (типа "
"<type>text</type>). Обычно в этой же позиции завершается передача потока "
"WAL, но возможны исключения, когда сервер может передавать записи WAL из "
"старой линии времени, которые он сам ещё не воспроизвёл до переключения. "
"Наконец сервер передаёт сообщение CommandComplete, после чего он готов "
"принять следующую команду."

#: protocol.xml:1529(para)
msgid ""
"WAL data is sent as a series of CopyData messages. (This allows other "
"information to be intermixed; in particular the server can send an "
"ErrorResponse message if it encounters a failure after beginning to stream.) "
"The payload of each CopyData message from server to the client contains a "
"message of one of the following formats:"
msgstr ""
"Данные WAL передаются в серии сообщений CopyData. (Это позволяет перемежать "
"их с другой информацией; в частности, сервер может передать сообщение "
"ErrorResponse, если он столкнулся с проблемами, уже начав передачу потока.) "
"Полезная нагрузка каждого сообщения CopyData от сервера к клиенту содержит "
"данные в одном из следующих форматов:"

#: protocol.xml:1540(term)
msgid "XLogData (B)"
msgstr "XLogData (B) — данные журнала транзакций"

#: protocol.xml:1547(term)
msgid "Byte1('w')"
msgstr "Byte1('w')"

#: protocol.xml:1551(para)
msgid "Identifies the message as WAL data."
msgstr "Указывает, что в этом сообщении передаются данные WAL."

#: protocol.xml:1557(term) protocol.xml:1567(term) protocol.xml:1577(term)
#: protocol.xml:1626(term) protocol.xml:1636(term) protocol.xml:1690(term)
#: protocol.xml:1701(term) protocol.xml:1712(term) protocol.xml:1722(term)
#: protocol.xml:1771(term)
msgid "Int64"
msgstr "Int64"

#: protocol.xml:1561(para)
msgid "The starting point of the WAL data in this message."
msgstr "Начальная точка данных WAL в этом сообщении."

#: protocol.xml:1571(para) protocol.xml:1630(para)
msgid "The current end of WAL on the server."
msgstr "Текущее положение конца WAL на сервере."

#: protocol.xml:1581(para) protocol.xml:1640(para)
msgid ""
"The server's system clock at the time of transmission, as microseconds since "
"midnight on 2000-01-01."
msgstr ""
"Показания системных часов сервера в момент передачи, в микросекундах с "
"полуночи 2000-01-01."

#: protocol.xml:1588(term) protocol.xml:2567(term) protocol.xml:2745(term)
#: protocol.xml:3104(term) protocol.xml:3478(term) protocol.xml:3840(term)
#: protocol.xml:3914(term)
msgid "Byte<replaceable>n</replaceable>"
msgstr "Byte<replaceable>n</replaceable>"

#: protocol.xml:1592(para)
msgid "A section of the WAL data stream."
msgstr "Фрагмент потока данных WAL."

#: protocol.xml:1595(para)
msgid ""
"A single WAL record is never split across two XLogData messages. When a WAL "
"record crosses a WAL page boundary, and is therefore already split using "
"continuation records, it can be split at the page boundary. In other words, "
"the first main WAL record and its continuation records can be sent in "
"different XLogData messages."
msgstr ""
"Одна запись WAL никогда не разделяется на два сообщения XLogData. Когда "
"запись WAL пересекает границу страницы WAL, и таким образом от неё уже "
"оказывается отделена продолжающая запись, её можно разделить на сообщения по "
"границе страницы. Другими словами, первая основная запись WAL и продолжающие "
"её записи могут быть переданы в различных сообщениях XLogData."

#: protocol.xml:1609(term)
msgid "Primary keepalive message (B)"
msgstr "Primary keepalive message (B) — Сообщение об активности ведущего"

#: protocol.xml:1616(term)
msgid "Byte1('k')"
msgstr "Byte1('k')"

#: protocol.xml:1620(para)
msgid "Identifies the message as a sender keepalive."
msgstr "Указывает, что это сообщение об активности отправителя."

#: protocol.xml:1647(term) protocol.xml:1733(term) protocol.xml:2915(term)
#: protocol.xml:3525(term) protocol.xml:3623(term) protocol.xml:4001(term)
#: protocol.xml:4489(term)
msgid "Byte1"
msgstr "Byte1"

#: protocol.xml:1651(para)
msgid ""
"1 means that the client should reply to this message as soon as possible, to "
"avoid a timeout disconnect. 0 otherwise."
msgstr ""
"Значение 1 означает, что клиент должен ответить на это сообщение как можно "
"скорее, во избежание отключения по тайм-ауту. Со значением 0 это не "
"требуется."

#: protocol.xml:1664(para)
msgid ""
"The receiving process can send replies back to the sender at any time, using "
"one of the following message formats (also in the payload of a CopyData "
"message):"
msgstr ""
"Принимающий процесс может передавать ответы отправителю в любое время, "
"используя один из следующих форматов данных (также в полезной нагрузке "
"сообщения CopyData):"

#: protocol.xml:1673(term)
msgid "Standby status update (F)"
msgstr "Standby status update (F) — Обновление состояния резервного сервера"

#: protocol.xml:1680(term)
msgid "Byte1('r')"
msgstr "Byte1('r')"

#: protocol.xml:1684(para)
msgid "Identifies the message as a receiver status update."
msgstr ""
"Указывает, что это сообщение передаёт обновлённое состояние получателя."

#: protocol.xml:1694(para)
msgid ""
"The location of the last WAL byte + 1 received and written to disk in the "
"standby."
msgstr ""
"Положение следующего за последним байтом WAL, полученным и записанным на "
"диск на резервном сервере."

#: protocol.xml:1705(para)
msgid "The location of the last WAL byte + 1 flushed to disk in the standby."
msgstr ""
"Положение следующего за последним байтом WAL, сохранённым на диске на "
"резервном сервере."

#: protocol.xml:1716(para)
msgid "The location of the last WAL byte + 1 applied in the standby."
msgstr ""
"Положение следующего за последним байтом WAL, применённым на резервном "
"сервере."

#: protocol.xml:1726(para) protocol.xml:1775(para)
msgid ""
"The client's system clock at the time of transmission, as microseconds since "
"midnight on 2000-01-01."
msgstr ""
"Показания системных часов клиента в момент передачи, в микросекундах с "
"полуночи 2000-01-01."

#: protocol.xml:1737(para)
msgid ""
"If 1, the client requests the server to reply to this message immediately. "
"This can be used to ping the server, to test if the connection is still "
"healthy."
msgstr ""
"Если содержит 1, клиент запрашивает от сервера немедленный ответ на это "
"сообщение. Так клиент может запросить отклик сервера и проверить, продолжает "
"ли функционировать соединение."

#: protocol.xml:1754(term)
msgid "Hot Standby feedback message (F)"
msgstr ""
"Hot Standby feedback message (F) — Сообщение обратной связи горячего резерва"

#: protocol.xml:1761(term)
msgid "Byte1('h')"
msgstr "Byte1('h')"

#: protocol.xml:1765(para)
msgid "Identifies the message as a Hot Standby feedback message."
msgstr "Указывает, что это сообщение обратной связи горячего резерва."

#: protocol.xml:1782(term) protocol.xml:1795(term) protocol.xml:2547(term)
#: protocol.xml:2614(term) protocol.xml:2624(term) protocol.xml:2659(term)
#: protocol.xml:2732(term) protocol.xml:2860(term) protocol.xml:2870(term)
#: protocol.xml:2905(term) protocol.xml:2997(term) protocol.xml:3094(term)
#: protocol.xml:3176(term) protocol.xml:3223(term) protocol.xml:3298(term)
#: protocol.xml:3371(term) protocol.xml:3442(term) protocol.xml:3465(term)
#: protocol.xml:3515(term) protocol.xml:3608(term) protocol.xml:3674(term)
#: protocol.xml:3695(term) protocol.xml:3766(term) protocol.xml:3776(term)
#: protocol.xml:3827(term) protocol.xml:3891(term) protocol.xml:3901(term)
#: protocol.xml:3986(term) protocol.xml:4052(term) protocol.xml:4062(term)
#: protocol.xml:4117(term) protocol.xml:4141(term) protocol.xml:4175(term)
#: protocol.xml:4229(term) protocol.xml:4277(term) protocol.xml:4352(term)
#: protocol.xml:4433(term) protocol.xml:4528(term) protocol.xml:4561(term)
#: protocol.xml:4583(term) protocol.xml:4604(term) protocol.xml:4681(term)
msgid "Int32"
msgstr "Int32"

#: protocol.xml:1786(para)
msgid ""
"The standby's current xmin. This may be 0, if the standby is sending "
"notification that Hot Standby feedback will no longer be sent on this "
"connection. Later non-zero messages may reinitiate the feedback mechanism."
msgstr ""
"Текущее значение xmin данного резервного сервера. Может быть нулевым; это "
"означает, что резервный сервер уведомляет о том, что сообщения обратной "
"связи горячего резерва больше не будут передаваться через это подключение. "
"Последующие ненулевые значения могут восстановить работу механизма обратной "
"связи."

#: protocol.xml:1799(para)
msgid "The standby's current epoch."
msgstr "Текущая эпоха резервного сервера."

#: protocol.xml:1813(term)
msgid ""
"<literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable "
"class=\"parameter\">slot_name</replaceable> <literal>LOGICAL</literal> "
"<replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</"
"replaceable> ] [, ...] ) ]"
msgstr ""
"<literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable "
"class=\"parameter\">имя_слота</replaceable> <literal>LOGICAL</literal> "
"<replaceable class=\"parameter\">XXX/XXX</replaceable> "
"[ ( <replaceable>имя_параметра</replaceable> "
"[ <replaceable>значение_параметра</replaceable> ] [, ...] ) ]"

#: protocol.xml:1815(para)
msgid ""
"Instructs server to start streaming WAL for logical replication, starting at "
"WAL position <replaceable class=\"parameter\">XXX/XXX</replaceable>. The "
"server can reply with an error, for example if the requested section of WAL "
"has already been recycled. On success, server responds with a "
"CopyBothResponse message, and then starts to stream WAL to the frontend."
msgstr ""
"Указывает серверу начать потоковую передачу WAL для логической репликации, "
"начиная с позиции <replaceable class=\"parameter\">XXX/XXX</replaceable> в "
"WAL. Сервер может вернуть в ответ ошибку, например, если запрошенный сегмент "
"WAL уже потерян. Если проблем не возникает, сервер возвращает сообщение "
"CopyBothResponse, а затем начинает передавать поток WAL клиенту."

#: protocol.xml:1823(para)
msgid ""
"The messages inside the CopyBothResponse messages are of the same format "
"documented for <literal>START_REPLICATION ... PHYSICAL</literal>."
msgstr ""
"Данные, передаваемые внутри сообщений CopyBothResponse, имеют тот же формат, "
"что описан для команды <literal>START_REPLICATION ... PHYSICAL</literal>."

#: protocol.xml:1828(para)
msgid ""
"The output plugin associated with the selected slot is used to process the "
"output for streaming."
msgstr ""
"Обработку выводимых данных для передачи выполняет модуль вывода, связанный с "
"выбранным слотом."

#: protocol.xml:1835(literal)
msgid "SLOT"
msgstr "SLOT"

#: protocol.xml:1837(para)
msgid ""
"The name of the slot to stream changes from. This parameter is required, and "
"must correspond to an existing logical replication slot created with "
"<literal>CREATE_REPLICATION_SLOT</literal> in <literal>LOGICAL</literal> "
"mode."
msgstr ""
"Имя слота, из которого передаются изменения. Это имя является обязательным, "
"оно должно соответствовать существующему логическому слоту репликации, "
"созданному командой <literal>CREATE_REPLICATION_SLOT</literal> в режиме "
"<literal>LOGICAL</literal>."

#: protocol.xml:1846(replaceable)
msgid "XXX/XXX"
msgstr "XXX/XXX"

#: protocol.xml:1848(para)
msgid "The WAL position to begin streaming at."
msgstr "Позиция в WAL, с которой должна начаться передача."

#: protocol.xml:1854(replaceable)
msgid "option_name"
msgstr "имя_параметра"

#: protocol.xml:1856(para)
msgid "The name of an option passed to the slot's logical decoding plugin."
msgstr ""
"Имя параметра, передаваемого модулю логического декодирования для выбранного "
"слота."

#: protocol.xml:1862(replaceable)
msgid "option_value"
msgstr "значение_параметра"

#: protocol.xml:1864(para)
msgid ""
"Optional value, in the form of a string constant, associated with the "
"specified option."
msgstr ""
"Необязательное значение, в форме строковой константы, связываемое с "
"указанным параметром."

#: protocol.xml:1875(literal)
msgid "DROP_REPLICATION_SLOT"
msgstr "DROP_REPLICATION_SLOT"

#: protocol.xml:1876(indexterm)
msgid "<primary>DROP_REPLICATION_SLOT</primary>"
msgstr "<primary>DROP_REPLICATION_SLOT</primary>"

#: protocol.xml:1879(para)
msgid ""
"Drops a replication slot, freeing any reserved server-side resources. If the "
"slot is currently in use by an active connection, this command fails."
msgstr ""
"Удаляет слот репликации, что приводит к освобождению всех зарезервированных "
"для него ресурсов на стороне сервера. Если слот в настоящий момент "
"используется активным соединением, команда завершается ошибкой."

#: protocol.xml:1887(para)
msgid "The name of the slot to drop."
msgstr "Имя слота, подлежащего удалению."

#: protocol.xml:1898(indexterm)
msgid "<primary>BASE_BACKUP</primary>"
msgstr "<primary>BASE_BACKUP</primary>"

#: protocol.xml:1897(term)
msgid ""
"<literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> "
"<replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] "
"[ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</"
"literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] "
"[ <literal>TABLESPACE_MAP</literal> ] <placeholder-1/>"
msgstr ""
"<literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> "
"<replaceable>'метка'</replaceable> ] [ <literal>PROGRESS</literal> ] "
"[ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</"
"literal> ] [ <literal>MAX_RATE</literal> <replaceable>скорость</"
"replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] <placeholder-1/>"

#: protocol.xml:1908(literal)
msgid "LABEL"
msgstr "LABEL"

#: protocol.xml:1908(replaceable)
msgid "'label'"
msgstr "'метка'"

#: protocol.xml:1910(para)
msgid ""
"Sets the label of the backup. If none is specified, a backup label of "
"<literal>base backup</literal> will be used. The quoting rules for the label "
"are the same as a standard SQL string with <xref linkend=\"guc-standard-"
"conforming-strings\"/> turned on."
msgstr ""
"Устанавливает метку для резервной копии. Если метка не задана, по умолчанию "
"устанавливается метка <literal>base backup</literal>. Для метки действуют те "
"же правила применения кавычек, что и для стандартных строк SQL при "
"включённым режиме <xref linkend=\"guc-standard-conforming-strings\"/>."

#: protocol.xml:1920(literal)
msgid "PROGRESS"
msgstr "PROGRESS"

#: protocol.xml:1922(para)
msgid ""
"Request information required to generate a progress report. This will send "
"back an approximate size in the header of each tablespace, which can be used "
"to calculate how far along the stream is done. This is calculated by "
"enumerating all the file sizes once before the transfer is even started, and "
"might as such have a negative impact on the performance. In particular, it "
"might take longer before the first data is streamed. Since the database "
"files can change during the backup, the size is only approximate and might "
"both grow and shrink between the time of approximation and the sending of "
"the actual files."
msgstr ""
"Запрашивает информацию, необходимую для отслеживания прогресса операции. "
"Сервер передаёт в ответ приблизительный размер в заголовке каждого "
"табличного пространства, исходя из которого можно понять, насколько "
"продвинулась передача потока. Для вычисления этого размера анализируются "
"размеры всех файлов ещё до начала передачи, и это может негативно повлиять "
"на производительность — в частности, может увеличиться задержка до передачи "
"первых данных. Так как файлы базы данных могут меняться во время резервного "
"копирования, оценка размера не будет точной; размер базы может увеличиться "
"или уменьшиться за время от вычисления этой оценки до передачи актуальных "
"файлов."

#: protocol.xml:1937(literal)
msgid "FAST"
msgstr "FAST"

#: protocol.xml:1939(para)
msgid "Request a fast checkpoint."
msgstr "Запрашивает быструю контрольную точку."

#: protocol.xml:1946(literal)
msgid "WAL"
msgstr "WAL"

#: protocol.xml:1948(para)
msgid ""
"Include the necessary WAL segments in the backup. This will include all the "
"files between start and stop backup in the <filename>pg_xlog</filename> "
"directory of the base directory tar file."
msgstr ""
"Включает в резервную копию необходимые сегменты WAL. При этом в подкаталог "
"<filename>pg_xlog</filename> архива базового каталога будут включены все "
"файлы с начала до конца копирования."

#: protocol.xml:1958(literal)
msgid "NOWAIT"
msgstr "NOWAIT"

#: protocol.xml:1960(para)
msgid ""
"By default, the backup will wait until the last required WAL segment has "
"been archived, or emit a warning if log archiving is not enabled. Specifying "
"<literal>NOWAIT</literal> disables both the waiting and the warning, leaving "
"the client responsible for ensuring the required log is available."
msgstr ""
"По умолчанию при копировании ожидается завершение архивации последнего "
"требуемого сегмента WAL либо выдаётся предупреждение, если архивация журнала "
"не включена. Указание <literal>NOWAIT</literal> отключает и ожидание, и "
"предупреждение, так что обеспечение наличия требуемого журнала становится "
"задачей клиента."

#: protocol.xml:1971(literal)
msgid "MAX_RATE"
msgstr "MAX_RATE"

#: protocol.xml:1971(replaceable)
msgid "rate"
msgstr "скорость"

#: protocol.xml:1973(para)
msgid ""
"Limit (throttle) the maximum amount of data transferred from server to "
"client per unit of time. The expected unit is kilobytes per second. If this "
"option is specified, the value must either be equal to zero or it must fall "
"within the range from 32 kB through 1 GB (inclusive). If zero is passed or "
"the option is not specified, no restriction is imposed on the transfer."
msgstr ""
"Ограничивает (сдерживает) максимальный объём данных, передаваемый от сервера "
"клиенту за единицу времени. Единица измерения этого параметра — килобайты в "
"секунду. Если задаётся этот параметр, его значение должно быть равно нулю, "
"либо должно находиться в диапазоне от 32 (килобайт/сек) до 1 Гбайта/сек "
"(включая границы). Если передаётся ноль, либо параметр не задаётся, скорость "
"передачи не ограничивается."

#: protocol.xml:1985(literal)
msgid "TABLESPACE_MAP"
msgstr "TABLESPACE_MAP"

#: protocol.xml:1987(para)
msgid ""
"Include information about symbolic links present in the directory "
"<filename>pg_tblspc</filename> in a file named <filename>tablespace_map</"
"filename>. The tablespace map file includes each symbolic link name as it "
"exists in the directory <filename>pg_tblspc/</filename> and the full path of "
"that symbolic link."
msgstr ""
"Включает информацию о символических ссылках, представленных в каталоге "
"<filename>pg_tblspc</filename>, в файл <filename>tablespace_map</filename>. "
"Файл карты табличных пространств содержит имена всех ссылок, содержащихся в "
"каталоге <filename>pg_tblspc/</filename>, и полный путь для каждой ссылки."

#: protocol.xml:1901(para)
msgid ""
"Instructs the server to start streaming a base backup. The system will "
"automatically be put in backup mode before the backup is started, and taken "
"out of it when the backup is complete. The following options are accepted: "
"<placeholder-1/>"
msgstr ""
"Указывает серверу начать потоковую передачу базовой копии. Система "
"автоматически переходит в режим резервного копирования до начала передачи, и "
"выходит из него после завершения копирования. Эта команда принимает "
"следующие параметры: <placeholder-1/>"

#: protocol.xml:1998(para)
msgid ""
"When the backup is started, the server will first send two ordinary result "
"sets, followed by one or more CopyResponse results."
msgstr ""
"Когда запускается копирование, сервер сначала передаёт два обычных набора "
"результатов, за которыми следуют один или более результатов CopyResponse."

#: protocol.xml:2003(para)
msgid ""
"The first ordinary result set contains the starting position of the backup, "
"in a single row with two columns. The first column contains the start "
"position given in XLogRecPtr format, and the second column contains the "
"corresponding timeline ID."
msgstr ""
"В первом обычном наборе результатов передаётся начальная позиция резервной "
"копии, в одной строке с двумя столбцами. В первом столбце содержится "
"стартовая позиция в формате XLogRecPtr, а во втором идентификатор "
"соответствующей линии времени."

#: protocol.xml:2014(term)
msgid "<literal>spcoid</literal> (<type>oid</type>)"
msgstr "<literal>spcoid</literal> (<type>oid</type>)"

#: protocol.xml:2016(para)
msgid "The OID of the tablespace, or null if it's the base directory."
msgstr "OID табличного пространства либо NULL, если это базовый каталог."

#: protocol.xml:2023(term)
msgid "<literal>spclocation</literal> (<type>text</type>)"
msgstr "<literal>spclocation</literal> (<type>text</type>)"

#: protocol.xml:2025(para)
msgid ""
"The full path of the tablespace directory, or null if it's the base "
"directory."
msgstr ""
"Полный путь к каталогу табличного пространства либо NULL, если это базовый "
"каталог."

#: protocol.xml:2032(term)
msgid "<literal>size</literal> (<type>int8</type>)"
msgstr "<literal>size</literal> (<type>int8</type>)"

#: protocol.xml:2034(para)
msgid ""
"The approximate size of the tablespace, if progress report has been "
"requested; otherwise it's null."
msgstr ""
"Приблизительный размер табличного пространства, если была запрошена "
"информация о прогрессе операции; в противном случае NULL."

#: protocol.xml:2009(para)
msgid ""
"The second ordinary result set has one row for each tablespace. The fields "
"in this row are: <placeholder-1/>"
msgstr ""
"Во втором обычном наборе результатов передаётся по одной строке для каждого "
"табличного пространства. Эта строка содержит следующие поля: <placeholder-1/>"

#: protocol.xml:2042(para)
msgid ""
"After the second regular result set, one or more CopyResponse results will "
"be sent, one for the main data directory and one for each additional "
"tablespace other than <literal>pg_default</literal> and <literal>pg_global</"
"literal>. The data in the CopyResponse results will be a tar format "
"(following the <quote>ustar interchange format</quote> specified in the "
"POSIX 1003.1-2008 standard) dump of the tablespace contents, except that the "
"two trailing blocks of zeroes specified in the standard are omitted. After "
"the tar data is complete, a final ordinary result set will be sent, "
"containing the WAL end position of the backup, in the same format as the "
"start position."
msgstr ""
"За вторым обычным набором результатов следует одна или несколько серий "
"результатов CopyResponse, одна для основного каталога данных и по одной для "
"каждого табличного пространства, отличного от <literal>pg_default</literal> "
"и <literal>pg_global</literal>. Данные в CopyResponse представляют собой "
"выгруженное в формате tar (<quote>формате обмена ustar</quote>, описанном в "
"стандарте POSIX 1003.1-2008) содержимое табличных пространств, за "
"исключением того, что два замыкающих блока нулей, описанных в стандарте, не "
"передаются. После завершения передачи данных tar передаётся заключительный "
"обычный набор результатов, в котором сообщается конечная позиция копии в "
"WAL, в том же формате, что и стартовая позиция."

#: protocol.xml:2063(filename)
msgid "postmaster.pid"
msgstr "postmaster.pid"

#: protocol.xml:2068(filename)
msgid "postmaster.opts"
msgstr "postmaster.opts"

#: protocol.xml:2072(para)
msgid ""
"various temporary files created during the operation of the PostgreSQL server"
msgstr ""
"различные временные файлы, создаваемые в процессе работы сервером PostgreSQL"

#: protocol.xml:2077(para)
msgid ""
"<filename>pg_xlog</filename>, including subdirectories. If the backup is run "
"with WAL files included, a synthesized version of <filename>pg_xlog</"
"filename> will be included, but it will only contain the files necessary for "
"the backup to work, not the rest of the contents."
msgstr ""
"<filename>pg_xlog</filename>, включая подкаталоги. Если в резервную копию "
"включаются файлы WAL, в архив входит преобразованная версия "
"<filename>pg_xlog</filename>, в которой будут находиться только файлы, "
"необходимые для восстановления копии, но не всё остальное содержимое этого "
"каталога."

#: protocol.xml:2085(para)
msgid "<filename>pg_replslot</filename> is copied as an empty directory."
msgstr "<filename>pg_replslot</filename> копируется в виде пустого каталога."

#: protocol.xml:2090(para)
msgid ""
"Files other than regular files and directories, such as symbolic links and "
"special device files, are skipped. (Symbolic links in <filename>pg_tblspc</"
"filename> are maintained.)"
msgstr ""
"файлы, отличные от обычных файлов и каталогов, например, символические "
"ссылки и файлы специальных устройств, пропускаются. (Символические ссылки в "
"<filename>pg_tblspc</filename> сохраняются.)"

#: protocol.xml:2055(para)
msgid ""
"The tar archive for the data directory and each tablespace will contain all "
"files in the directories, regardless of whether they are "
"<productname>PostgreSQL</productname> files or other files added to the same "
"directory. The only excluded files are: <placeholder-1/> Owner, group, and "
"file mode are set if the underlying file system on the server supports it."
msgstr ""
"Архив tar каталога данных и всех табличных пространств будет содержать все "
"файлы в этих каталогах, будь то файлы <productname>PostgreSQL</productname> "
"или посторонние файлы, добавленные в эти каталоги. Исключение составляют "
"только следующие файлы: <placeholder-1/> Если файловая система сервера "
"поддерживает это, в архив включается информация о владельце, группе и режиме "
"файла."

#: protocol.xml:1329(para)
msgid "The commands accepted in walsender mode are: <placeholder-1/>"
msgstr "В режиме walsender принимаются следующие команды: <placeholder-1/>"

#: protocol.xml:2109(title)
msgid "Message Data Types"
msgstr "Типы данных в сообщениях"

#: protocol.xml:2117(term)
msgid "Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)"
msgstr "Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)"

#: protocol.xml:2121(para)
msgid ""
"An <replaceable>n</replaceable>-bit integer in network byte order (most "
"significant byte first). If <replaceable>i</replaceable> is specified it is "
"the exact value that will appear, otherwise the value is variable. Eg. "
"Int16, Int32(42)."
msgstr ""
"Целое число из <replaceable>n</replaceable> бит с сетевым порядком байт "
"(наиболее значащий байт первый). Если указано <replaceable>i</replaceable>, "
"это поле будет содержать именно указанное значение, в противном случае "
"значение переменное. Например: Int16, Int32(42)."

#: protocol.xml:2132(term)
msgid "Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]"
msgstr "Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]"

#: protocol.xml:2136(para)
msgid ""
"An array of <replaceable>k</replaceable> <replaceable>n</replaceable>-bit "
"integers, each in network byte order. The array length <replaceable>k</"
"replaceable> is always determined by an earlier field in the message. Eg. "
"Int16[M]."
msgstr ""
"Массив из <replaceable>k</replaceable> <replaceable>n</replaceable>-битовых "
"целых, каждое записывается с сетевым порядком байт. Длина массива "
"<replaceable>k</replaceable> всегда определяется по предыдущему полю "
"сообщения, например Int16[M]."

#: protocol.xml:2147(term)
msgid "String(<replaceable>s</replaceable>)"
msgstr "String(<replaceable>s</replaceable>)"

#: protocol.xml:2151(para)
msgid ""
"A null-terminated string (C-style string). There is no specific length "
"limitation on strings. If <replaceable>s</replaceable> is specified it is "
"the exact value that will appear, otherwise the value is variable. Eg. "
"String, String(\"user\")."
msgstr ""
"Строка, оканчивающаяся нулём (строка в стиле C). На длину строк ограничение "
"не накладывается. Если указывается <replaceable>s</replaceable>, это поле "
"будет содержать именно указанное значение, в противном случае значение "
"переменное. Например: String, String(\"user\")."

#: protocol.xml:2160(para)
msgid ""
"<emphasis>There is no predefined limit</emphasis> on the length of a string "
"that can be returned by the backend. Good coding strategy for a frontend is "
"to use an expandable buffer so that anything that fits in memory can be "
"accepted. If that's not feasible, read the full string and discard trailing "
"characters that don't fit into your fixed-size buffer."
msgstr ""
"<emphasis>Нет никакого предопределённого ограничения</emphasis> длины "
"строки, которую может возвратить сервер. Поэтому при реализации клиента "
"лучше использовать расширяемый буфер, чтобы он мог принять строку любого "
"размера, умещающуюся в памяти. Если такой возможности нет, прочитайте строку "
"целиком и отбросьте последние символы, не помещающиеся в ваш буфер "
"фиксированного размера."

#: protocol.xml:2172(term)
msgid "Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)"
msgstr "Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)"

#: protocol.xml:2176(para)
msgid ""
"Exactly <replaceable>n</replaceable> bytes. If the field width "
"<replaceable>n</replaceable> is not a constant, it is always determinable "
"from an earlier field in the message. If <replaceable>c</replaceable> is "
"specified it is the exact value. Eg. Byte2, Byte1('\\n')."
msgstr ""
"В точности <replaceable>n</replaceable> байт. Если размер поля "
"<replaceable>n</replaceable> задаётся не константой, он всегда определяется "
"по предыдущему полю сообщения. Если указывается <replaceable>c</"
"replaceable>, оно задаёт точное значение. Например: Byte2, Byte1('\\n')."

#: protocol.xml:2111(para)
msgid ""
"This section describes the base data types used in messages. <placeholder-1/>"
msgstr ""
"В этом разделе описываются базовые типы данных, применяемые в сообщениях. "
"<placeholder-1/>"

#: protocol.xml:2191(title)
msgid "Message Formats"
msgstr "Форматы сообщений"

#: protocol.xml:2193(para)
msgid ""
"This section describes the detailed format of each message. Each is marked "
"to indicate that it can be sent by a frontend (F), a backend (B), or both (F "
"&amp; B). Notice that although each message includes a byte count at the "
"beginning, the message format is defined so that the message end can be "
"found without reference to the byte count. This aids validity checking. (The "
"CopyData message is an exception, because it forms part of a data stream; "
"the contents of any individual CopyData message cannot be interpretable on "
"their own.)"
msgstr ""
"В этом разделе подробно описывается формат каждого сообщения. Все сообщения "
"помечены символами, обозначающими, какая сторона может их передавать: сервер "
"(F), клиент (B) или обе стороны (F &amp; B). Заметьте, что хотя каждое "
"сообщение включает счётчик байт в начале, формат сообщения разработан так, "
"чтобы конец сообщения можно было найти, не обращаясь к счётчику байт. Это "
"помогает проверять корректность сообщений. (Исключением является сообщение "
"CopyData, так как оно образует часть потока данных; содержимое любого "
"отдельного сообщения CopyData нельзя интерпретировать само по себе.)"

#: protocol.xml:2208(term)
msgid "AuthenticationOk (B)"
msgstr "AuthenticationOk (B)"

#: protocol.xml:2216(term) protocol.xml:2261(term) protocol.xml:2305(term)
#: protocol.xml:2349(term) protocol.xml:2404(term) protocol.xml:2449(term)
#: protocol.xml:2494(term) protocol.xml:2537(term)
msgid "Byte1('R')"
msgstr "Byte1('R')"

#: protocol.xml:2220(para) protocol.xml:2265(para) protocol.xml:2309(para)
#: protocol.xml:2353(para) protocol.xml:2408(para) protocol.xml:2453(para)
#: protocol.xml:2498(para) protocol.xml:2541(para)
msgid "Identifies the message as an authentication request."
msgstr "Указывает, что это сообщение представляет запрос аутентификации."

#: protocol.xml:2226(term) protocol.xml:2271(term) protocol.xml:2315(term)
#: protocol.xml:2414(term) protocol.xml:2459(term) protocol.xml:2504(term)
#: protocol.xml:2557(term) protocol.xml:4643(term)
msgid "Int32(8)"
msgstr "Int32(8)"

#: protocol.xml:2230(para) protocol.xml:2275(para) protocol.xml:2319(para)
#: protocol.xml:2363(para) protocol.xml:2418(para) protocol.xml:2463(para)
#: protocol.xml:2508(para) protocol.xml:2551(para) protocol.xml:2608(para)
#: protocol.xml:2663(para) protocol.xml:2816(para) protocol.xml:2841(para)
#: protocol.xml:2909(para) protocol.xml:2966(para) protocol.xml:3001(para)
#: protocol.xml:3098(para) protocol.xml:3145(para) protocol.xml:3180(para)
#: protocol.xml:3227(para) protocol.xml:3302(para) protocol.xml:3375(para)
#: protocol.xml:3446(para) protocol.xml:3519(para) protocol.xml:3577(para)
#: protocol.xml:3612(para) protocol.xml:3678(para) protocol.xml:3735(para)
#: protocol.xml:3770(para) protocol.xml:3895(para) protocol.xml:3955(para)
#: protocol.xml:3990(para) protocol.xml:4056(para) protocol.xml:4121(para)
#: protocol.xml:4179(para) protocol.xml:4233(para) protocol.xml:4317(para)
#: protocol.xml:4356(para) protocol.xml:4402(para) protocol.xml:4437(para)
#: protocol.xml:4483(para) protocol.xml:4532(para) protocol.xml:4647(para)
#: protocol.xml:4685(para) protocol.xml:4806(para) protocol.xml:4841(para)
msgid "Length of message contents in bytes, including self."
msgstr "Длина содержимого сообщения в байтах, включая само поле длины."

#: protocol.xml:2236(term)
msgid "Int32(0)"
msgstr "Int32(0)"

#: protocol.xml:2240(para)
msgid "Specifies that the authentication was successful."
msgstr "Показывает, что проверка подлинности прошла успешно."

#: protocol.xml:2253(term)
msgid "AuthenticationKerberosV5 (B)"
msgstr "AuthenticationKerberosV5 (B)"

#: protocol.xml:2281(term)
msgid "Int32(2)"
msgstr "Int32(2)"

#: protocol.xml:2285(para)
msgid "Specifies that Kerberos V5 authentication is required."
msgstr ""
"Указывает, что требуется проверка подлинности по протоколу Kerberos V5."

#: protocol.xml:2297(term)
msgid "AuthenticationCleartextPassword (B)"
msgstr "AuthenticationCleartextPassword (B)"

#: protocol.xml:2325(term)
msgid "Int32(3)"
msgstr "Int32(3)"

#: protocol.xml:2329(para)
msgid "Specifies that a clear-text password is required."
msgstr "Указывает, что требуется пароль, передаваемый открытым текстом."

#: protocol.xml:2341(term)
msgid "AuthenticationMD5Password (B)"
msgstr "AuthenticationMD5Password (B)"

#: protocol.xml:2359(term) protocol.xml:2604(term)
msgid "Int32(12)"
msgstr "Int32(12)"

#: protocol.xml:2369(term) protocol.xml:4479(term)
msgid "Int32(5)"
msgstr "Int32(5)"

#: protocol.xml:2373(para)
msgid "Specifies that an MD5-encrypted password is required."
msgstr "Указывает, что требуется пароль, преобразованный в хеш MD5."

#: protocol.xml:2379(term)
msgid "Byte4"
msgstr "Byte4"

#: protocol.xml:2383(para)
msgid "The salt to use when encrypting the password."
msgstr "Значение соли, с которым должен хешироваться пароль."

#: protocol.xml:2396(term)
msgid "AuthenticationSCMCredential (B)"
msgstr "AuthenticationSCMCredential (B)"

#: protocol.xml:2424(term)
msgid "Int32(6)"
msgstr "Int32(6)"

#: protocol.xml:2428(para)
msgid "Specifies that an SCM credentials message is required."
msgstr "Указывает, что требуется сообщение с учётными данными SCM."

#: protocol.xml:2441(term)
msgid "AuthenticationGSS (B)"
msgstr "AuthenticationGSS (B)"

#: protocol.xml:2469(term)
msgid "Int32(7)"
msgstr "Int32(7)"

#: protocol.xml:2473(para)
msgid "Specifies that GSSAPI authentication is required."
msgstr "Указывает, что требуется проверка подлинности на базе GSSAPI."

#: protocol.xml:2486(term)
msgid "AuthenticationSSPI (B)"
msgstr "AuthenticationSSPI (B)"

#: protocol.xml:2514(term)
msgid "Int32(9)"
msgstr "Int32(9)"

#: protocol.xml:2518(para)
msgid "Specifies that SSPI authentication is required."
msgstr "Указывает, что требуется проверка подлинности на базе SSPI."

#: protocol.xml:2529(term)
msgid "AuthenticationGSSContinue (B)"
msgstr "AuthenticationGSSContinue (B)"

#: protocol.xml:2561(para)
msgid "Specifies that this message contains GSSAPI or SSPI data."
msgstr "Указывает, что это сообщение содержит данные GSSAPI или SSPI."

#: protocol.xml:2571(para)
msgid "GSSAPI or SSPI authentication data."
msgstr "Данные аутентификации для GSSAPI или SSPI."

#: protocol.xml:2584(term)
msgid "BackendKeyData (B)"
msgstr "BackendKeyData (B)"

#: protocol.xml:2592(term)
msgid "Byte1('K')"
msgstr "Byte1('K')"

#: protocol.xml:2596(para)
msgid ""
"Identifies the message as cancellation key data. The frontend must save "
"these values if it wishes to be able to issue CancelRequest messages later."
msgstr ""
"Указывает, что это сообщение содержит ключевые данные для отмены запросов. "
"Клиент должен сохранить эти данные, если ему нужна возможность впоследствии "
"выдавать сообщения CancelRequest."

#: protocol.xml:2618(para)
msgid "The process ID of this backend."
msgstr "PID обслуживающего процесса."

#: protocol.xml:2628(para)
msgid "The secret key of this backend."
msgstr "Секретный ключ обслуживающего процесса."

#: protocol.xml:2641(term)
msgid "Bind (F)"
msgstr "Bind (F)"

#: protocol.xml:2649(term)
msgid "Byte1('B')"
msgstr "Byte1('B')"

#: protocol.xml:2653(para)
msgid "Identifies the message as a Bind command."
msgstr "Указывает, что это сообщение представляет команду Bind."

#: protocol.xml:2669(term) protocol.xml:2680(term) protocol.xml:2926(term)
#: protocol.xml:3007(term) protocol.xml:3186(term) protocol.xml:3536(term)
#: protocol.xml:3639(term) protocol.xml:3684(term) protocol.xml:4017(term)
#: protocol.xml:4072(term) protocol.xml:4082(term) protocol.xml:4185(term)
#: protocol.xml:4195(term) protocol.xml:4239(term) protocol.xml:4250(term)
#: protocol.xml:4362(term) protocol.xml:4443(term) protocol.xml:4551(term)
#: protocol.xml:4712(term) protocol.xml:4767(term)
msgid "String"
msgstr "String"

#: protocol.xml:2673(para)
msgid ""
"The name of the destination portal (an empty string selects the unnamed "
"portal)."
msgstr "Имя целевого портала (пустая строка выбирает безымянный портал)."

#: protocol.xml:2684(para)
msgid ""
"The name of the source prepared statement (an empty string selects the "
"unnamed prepared statement)."
msgstr ""
"Имя исходного подготовленного оператора (пустая строка выбирает безымянный "
"подготовленный оператор)."

#: protocol.xml:2691(term) protocol.xml:2718(term) protocol.xml:2760(term)
#: protocol.xml:3249(term) protocol.xml:3322(term) protocol.xml:3395(term)
#: protocol.xml:3452(term) protocol.xml:3786(term) protocol.xml:3813(term)
#: protocol.xml:3855(term) protocol.xml:4127(term) protocol.xml:4260(term)
#: protocol.xml:4538(term) protocol.xml:4572(term) protocol.xml:4593(term)
#: protocol.xml:4615(term)
msgid "Int16"
msgstr "Int16"

#: protocol.xml:2695(para)
msgid ""
"The number of parameter format codes that follow (denoted <replaceable>C</"
"replaceable> below). This can be zero to indicate that there are no "
"parameters or that the parameters all use the default format (text); or one, "
"in which case the specified format code is applied to all parameters; or it "
"can equal the actual number of parameters."
msgstr ""
"Количество кодов форматов следующих параметров (обозначается ниже символом "
"<replaceable>C</replaceable>). Может быть нулевым, что показывает, что "
"параметры отсутствуют или все параметры передаются в формате по умолчанию "
"(текстовом); либо равняться одному, в этом случае указанный один код формата "
"применяется ко всем параметрам; либо может равняться действительному "
"количеству параметров."

#: protocol.xml:2707(term) protocol.xml:3802(term)
msgid "Int16[<replaceable>C</replaceable>]"
msgstr "Int16[<replaceable>C</replaceable>]"

#: protocol.xml:2711(para)
msgid ""
"The parameter format codes. Each must presently be zero (text) or one "
"(binary)."
msgstr ""
"Коды форматов параметров. В настоящее время допускаются коды ноль (текстовый "
"формат) и один (двоичный)."

#: protocol.xml:2722(para)
msgid ""
"The number of parameter values that follow (possibly zero). This must match "
"the number of parameters needed by the query."
msgstr ""
"Количество следующих значений параметров (может быть нулевым). Оно должно "
"совпадать с количеством параметров, требующихся для запроса."

#: protocol.xml:2736(para)
msgid ""
"The length of the parameter value, in bytes (this count does not include "
"itself). Can be zero. As a special case, -1 indicates a NULL parameter "
"value. No value bytes follow in the NULL case."
msgstr ""
"Длина значения параметра, в байтах (само поле длины не считается). Может "
"быть нулевой. В качестве особого значения, -1 представляет значение NULL. В "
"случае с NULL никакие байты значений далее не следуют."

#: protocol.xml:2749(para)
msgid ""
"The value of the parameter, in the format indicated by the associated format "
"code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение параметра в формате, определённом соответствующим кодом формата. "
"Переменная <replaceable>n</replaceable> задаёт длину значения."

#: protocol.xml:2764(para)
msgid ""
"The number of result-column format codes that follow (denoted "
"<replaceable>R</replaceable> below). This can be zero to indicate that there "
"are no result columns or that the result columns should all use the default "
"format (text); or one, in which case the specified format code is applied to "
"all result columns (if any); or it can equal the actual number of result "
"columns of the query."
msgstr ""
"Количество кодов формата для следующих столбцов результата (обозначается "
"ниже символом <replaceable>R</replaceable>). Может быть нулевым, что "
"показывает, что столбцы результата отсутствуют или для всех столбцов должен "
"использоваться формат по умолчанию (текстовый), либо равняться одному, в "
"этом случае указанный один код формата применяется ко всем столбцам (если "
"они есть), либо может равняться действительному количеству столбцов "
"результата запроса."

#: protocol.xml:2777(term)
msgid "Int16[<replaceable>R</replaceable>]"
msgstr "Int16[<replaceable>R</replaceable>]"

#: protocol.xml:2781(para)
msgid ""
"The result-column format codes. Each must presently be zero (text) or one "
"(binary)."
msgstr ""
"Коды форматов столбцов результата. В настоящее время допускаются коды ноль "
"(текстовый формат) и один (двоичный)."

#: protocol.xml:2645(para)
msgid ""
"<placeholder-1/> Next, the following pair of fields appear for each "
"parameter: <placeholder-2/> After the last parameter, the following fields "
"appear: <placeholder-3/>"
msgstr ""
"<placeholder-1/> Затем для каждого параметра идёт следующая пара полей: "
"<placeholder-2/> За последним параметром идут следующие поля: <placeholder-3/"
">"

#: protocol.xml:2794(term)
msgid "BindComplete (B)"
msgstr "BindComplete (B)"

#: protocol.xml:2802(term)
msgid "Byte1('2')"
msgstr "Byte1('2')"

#: protocol.xml:2806(para)
msgid "Identifies the message as a Bind-complete indicator."
msgstr "Указывает, что это сообщение, сигнализирующее о завершении Bind."

#: protocol.xml:2812(term) protocol.xml:2962(term) protocol.xml:3141(term)
#: protocol.xml:3573(term) protocol.xml:3731(term) protocol.xml:3951(term)
#: protocol.xml:4313(term) protocol.xml:4398(term) protocol.xml:4802(term)
#: protocol.xml:4837(term)
msgid "Int32(4)"
msgstr "Int32(4)"

#: protocol.xml:2829(term)
msgid "CancelRequest (F)"
msgstr "CancelRequest (F)"

#: protocol.xml:2837(term)
msgid "Int32(16)"
msgstr "Int32(16)"

#: protocol.xml:2847(term)
msgid "Int32(80877102)"
msgstr "Int32(80877102)"

#: protocol.xml:2851(para)
msgid ""
"The cancel request code. The value is chosen to contain <literal>1234</"
"literal> in the most significant 16 bits, and <literal>5678</literal> in the "
"least significant 16 bits. (To avoid confusion, this code must not be the "
"same as any protocol version number.)"
msgstr ""
"Код запроса отмены. Это специально выбранное значение содержит "
"<literal>1234</literal> в старших 16 битах и <literal>5678</literal> в "
"младших 16 битах. (Во избежание неоднозначности этот код не должен совпадать "
"с номером версии протокола.)"

#: protocol.xml:2864(para)
msgid "The process ID of the target backend."
msgstr "PID целевого обслуживающего процесса."

#: protocol.xml:2874(para)
msgid "The secret key for the target backend."
msgstr "Секретный ключ целевого обслуживающего процесса."

#: protocol.xml:2887(term)
msgid "Close (F)"
msgstr "Close (F)"

#: protocol.xml:2895(term) protocol.xml:2987(term)
msgid "Byte1('C')"
msgstr "Byte1('C')"

#: protocol.xml:2899(para)
msgid "Identifies the message as a Close command."
msgstr "Указывает, что это сообщение представляет команду Close."

#: protocol.xml:2919(para)
msgid ""
"'<literal>S</literal>' to close a prepared statement; or '<literal>P</"
"literal>' to close a portal."
msgstr ""
"'<literal>S</literal>' для закрытия подготовленного оператора, '<literal>P</"
"literal>' для закрытия портала."

#: protocol.xml:2930(para)
msgid ""
"The name of the prepared statement or portal to close (an empty string "
"selects the unnamed prepared statement or portal)."
msgstr ""
"Имя подготовленного оператора или портала, который должен быть закрыт "
"(пустая строка выбирает безымянный подготовленный оператор или портал)."

#: protocol.xml:2944(term)
msgid "CloseComplete (B)"
msgstr "CloseComplete (B)"

#: protocol.xml:2952(term)
msgid "Byte1('3')"
msgstr "Byte1('3')"

#: protocol.xml:2956(para)
msgid "Identifies the message as a Close-complete indicator."
msgstr "Указывает, что это сообщение, сигнализирующее о завершении Close."

#: protocol.xml:2979(term)
msgid "CommandComplete (B)"
msgstr "CommandComplete (B)"

#: protocol.xml:2991(para)
msgid "Identifies the message as a command-completed response."
msgstr "Указывает, что это сообщение об успешном завершении команды."

#: protocol.xml:3011(para)
msgid ""
"The command tag. This is usually a single word that identifies which SQL "
"command was completed."
msgstr ""
"Тег команды. Обычно это одно слово, обозначающее завершённую команду SQL."

#: protocol.xml:3016(para)
msgid ""
"For an <command>INSERT</command> command, the tag is <literal>INSERT "
"<replaceable>oid</replaceable> <replaceable>rows</replaceable></literal>, "
"where <replaceable>rows</replaceable> is the number of rows inserted. "
"<replaceable>oid</replaceable> is the object ID of the inserted row if "
"<replaceable>rows</replaceable> is 1 and the target table has OIDs; "
"otherwise <replaceable>oid</replaceable> is 0."
msgstr ""
"Для команды <command>INSERT</command> в качестве тега передаётся "
"<literal>INSERT <replaceable>oid</replaceable> <replaceable>строк</"
"replaceable></literal>, где <replaceable>строк</replaceable> — количество "
"вставленных строк. В поле <replaceable>oid</replaceable> передаётся "
"идентификатор объекта вставленной строки, если число <replaceable>строк</"
"replaceable> равно 1 и в целевой таблице содержатся OID; в противном случае "
"вместо <replaceable>oid</replaceable> передаётся 0."

#: protocol.xml:3027(para)
msgid ""
"For a <command>DELETE</command> command, the tag is <literal>DELETE "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows deleted."
msgstr ""
"Для команды <command>DELETE</command> в качестве тега передаётся "
"<literal>DELETE <replaceable>строк</replaceable></literal>, где "
"<replaceable>строк</replaceable> — количество удалённых строк."

#: protocol.xml:3033(para)
msgid ""
"For an <command>UPDATE</command> command, the tag is <literal>UPDATE "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows updated."
msgstr ""
"Для команды <command>UPDATE</command> в качестве тега передаётся "
"<literal>UPDATE <replaceable>строк</replaceable></literal>, где "
"<replaceable>строк</replaceable> — количество изменённых строк."

#: protocol.xml:3039(para)
msgid ""
"For a <command>SELECT</command> or <command>CREATE TABLE AS</command> "
"command, the tag is <literal>SELECT <replaceable>rows</replaceable></"
"literal> where <replaceable>rows</replaceable> is the number of rows "
"retrieved."
msgstr ""
"Для команды <command>SELECT</command> или <command>CREATE TABLE AS</command> "
"в качестве тега передаётся <literal>SELECT <replaceable>строк</replaceable></"
"literal>, где <replaceable>строк</replaceable> — число полученных строк."

#: protocol.xml:3045(para)
msgid ""
"For a <command>MOVE</command> command, the tag is <literal>MOVE "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows the cursor's position has been changed by."
msgstr ""
"Для команды <command>MOVE</command> в качестве тега передаётся <literal>MOVE "
"<replaceable>строк</replaceable></literal>, где <replaceable>строк</"
"replaceable> — количество строк, на которое изменилась позиция курсора."

#: protocol.xml:3052(para)
msgid ""
"For a <command>FETCH</command> command, the tag is <literal>FETCH "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows that have been retrieved from the cursor."
msgstr ""
"Для команды <command>FETCH</command> в качестве тега передаётся "
"<literal>FETCH <replaceable>строк</replaceable></literal>, где "
"<replaceable>строк</replaceable> — количество строк, полученное через курсор."

#: protocol.xml:3059(para)
msgid ""
"For a <command>COPY</command> command, the tag is <literal>COPY "
"<replaceable>rows</replaceable></literal> where <replaceable>rows</"
"replaceable> is the number of rows copied. (Note: the row count appears only "
"in <productname>PostgreSQL</productname> 8.2 and later.)"
msgstr ""
"Для команды <command>COPY</command> в качестве тега передаётся <literal>COPY "
"<replaceable>строк</replaceable></literal>, где <replaceable>строк</"
"replaceable> — количество скопированных строк. (Заметьте: число строк "
"выводится, начиная только с <productname>PostgreSQL</productname> 8.2.)"

#: protocol.xml:3077(term)
msgid "CopyData (F &amp; B)"
msgstr "CopyData (F &amp; B)"

#: protocol.xml:3084(term)
msgid "Byte1('d')"
msgstr "Byte1('d')"

#: protocol.xml:3088(para)
msgid "Identifies the message as <command>COPY</command> data."
msgstr ""
"Указывает, что в этом сообщении передаются данные <command>COPY</command>."

#: protocol.xml:3108(para)
msgid ""
"Data that forms part of a <command>COPY</command> data stream. Messages sent "
"from the backend will always correspond to single data rows, but messages "
"sent by frontends might divide the data stream arbitrarily."
msgstr ""
"Данные, образующие часть информационного потока <command>COPY</command>. "
"Сообщения от сервера всегда соответствуют отдельным строкам данных, но "
"сообщения, передаваемые клиентами, могут разделять поток произвольным "
"образом."

#: protocol.xml:3123(term)
msgid "CopyDone (F &amp; B)"
msgstr "CopyDone (F &amp; B)"

#: protocol.xml:3131(term)
msgid "Byte1('c')"
msgstr "Byte1('c')"

#: protocol.xml:3135(para)
msgid "Identifies the message as a <command>COPY</command>-complete indicator."
msgstr ""
"Указывает, что это сообщение, сигнализирующее о завершении <command>COPY</"
"command>."

#: protocol.xml:3158(term)
msgid "CopyFail (F)"
msgstr "CopyFail (F)"

#: protocol.xml:3166(term)
msgid "Byte1('f')"
msgstr "Byte1('f')"

#: protocol.xml:3170(para)
msgid "Identifies the message as a <command>COPY</command>-failure indicator."
msgstr ""
"Указывает, что это сообщение, сигнализирующее об ошибке операции "
"<command>COPY</command>."

#: protocol.xml:3190(para)
msgid "An error message to report as the cause of failure."
msgstr "Сообщение об ошибке, описывающее причину сбоя операции."

#: protocol.xml:3203(term)
msgid "CopyInResponse (B)"
msgstr "CopyInResponse (B)"

#: protocol.xml:3211(term)
msgid "Byte1('G')"
msgstr "Byte1('G')"

#: protocol.xml:3215(para)
msgid ""
"Identifies the message as a Start Copy In response. The frontend must now "
"send copy-in data (if not prepared to do so, send a CopyFail message)."
msgstr ""
"Указывает, что это сообщение является ответом на запуск входящего "
"копирования. Получив его, клиент начинает передавать данные на вход операции "
"копирования (если клиент не готов к этому, он передаёт сообщение CopyFail)."

#: protocol.xml:3233(term) protocol.xml:3308(term) protocol.xml:3381(term)
msgid "Int8"
msgstr "Int8"

#: protocol.xml:3237(para) protocol.xml:3312(para) protocol.xml:3385(para)
msgid ""
"0 indicates the overall <command>COPY</command> format is textual (rows "
"separated by newlines, columns separated by separator characters, etc). 1 "
"indicates the overall copy format is binary (similar to DataRow format). See "
"<xref linkend=\"sql-copy\"/> for more information."
msgstr ""
"Значение 0 указывает, что для всей операции <command>COPY</command> "
"применяется текстовый формат (строки разделяются символами новой строки, "
"столбцы разделяются символами-разделителями и т. д.). Значение 1 указывает, "
"что для всей операции копирования применяется двоичный формат (подобный "
"формату DataRow). За дополнительными сведениями обратитесь к <xref remap="
"\"3\" linkend=\"sql-copy\"/>."

#: protocol.xml:3253(para) protocol.xml:3326(para) protocol.xml:3399(para)
msgid ""
"The number of columns in the data to be copied (denoted <replaceable>N</"
"replaceable> below)."
msgstr ""
"Количество столбцов в копируемых данных (ниже обозначается символом "
"<replaceable>N</replaceable>)."

#: protocol.xml:3260(term) protocol.xml:3333(term) protocol.xml:3406(term)
msgid "Int16[<replaceable>N</replaceable>]"
msgstr "Int16[<replaceable>N</replaceable>]"

#: protocol.xml:3264(para) protocol.xml:3337(para) protocol.xml:3410(para)
msgid ""
"The format codes to be used for each column. Each must presently be zero "
"(text) or one (binary). All must be zero if the overall copy format is "
"textual."
msgstr ""
"Коды формата для каждого столбца. В настоящее время допускаются коды ноль "
"(текстовый формат) и один (двоичный). Если общий формат копирования — "
"текстовый, все эти коды должны быть нулевыми."

#: protocol.xml:3279(term)
msgid "CopyOutResponse (B)"
msgstr "CopyOutResponse (B)"

#: protocol.xml:3287(term) protocol.xml:3721(term)
msgid "Byte1('H')"
msgstr "Byte1('H')"

#: protocol.xml:3291(para)
msgid ""
"Identifies the message as a Start Copy Out response. This message will be "
"followed by copy-out data."
msgstr ""
"Указывает, что это сообщение является ответом на запуск исходящего "
"копирования. За этим сообщением следуют данные, исходящие со стороны сервера."

#: protocol.xml:3352(term)
msgid "CopyBothResponse (B)"
msgstr "CopyBothResponse (B)"

#: protocol.xml:3360(term)
msgid "Byte1('W')"
msgstr "Byte1('W')"

#: protocol.xml:3364(para)
msgid ""
"Identifies the message as a Start Copy Both response. This message is used "
"only for Streaming Replication."
msgstr ""
"Указывает, что это сообщение является ответом на запуск двустороннего "
"копирования. Это сообщение используется только для потоковой репликации."

#: protocol.xml:3425(term)
msgid "DataRow (B)"
msgstr "DataRow (B)"

#: protocol.xml:3432(term) protocol.xml:3505(term)
msgid "Byte1('D')"
msgstr "Byte1('D')"

#: protocol.xml:3436(para)
msgid "Identifies the message as a data row."
msgstr "Указывает, что в этом сообщении передаётся строка данных."

#: protocol.xml:3456(para)
msgid "The number of column values that follow (possibly zero)."
msgstr "Количество последующих значений столбцов (может быть нулевым)."

#: protocol.xml:3469(para)
msgid ""
"The length of the column value, in bytes (this count does not include "
"itself). Can be zero. As a special case, -1 indicates a NULL column value. "
"No value bytes follow in the NULL case."
msgstr ""
"Длина значения столбца, в байтах (само поле длины не считается). Может быть "
"нулевой. В качестве особого значения, -1 представляет значение NULL. В "
"случае с NULL никакие байты значений далее не следуют."

#: protocol.xml:3482(para)
msgid ""
"The value of the column, in the format indicated by the associated format "
"code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение столбца в формате, определённом соответствующим кодом формата. "
"Переменная <replaceable>n</replaceable> задаёт длину значения."

#: protocol.xml:3429(para)
msgid ""
"<placeholder-1/> Next, the following pair of fields appear for each column: "
"<placeholder-2/>"
msgstr ""
"<placeholder-1/> Затем для каждого столбца идёт следующая пара полей: "
"<placeholder-2/>"

#: protocol.xml:3497(term)
msgid "Describe (F)"
msgstr "Describe (F)"

#: protocol.xml:3509(para)
msgid "Identifies the message as a Describe command."
msgstr "Указывает, что это сообщение представляет команду Describe."

#: protocol.xml:3529(para)
msgid ""
"'<literal>S</literal>' to describe a prepared statement; or '<literal>P</"
"literal>' to describe a portal."
msgstr ""
"'<literal>S</literal>' для получения описания подготовленного оператора, "
"'<literal>P</literal>' — портала."

#: protocol.xml:3540(para)
msgid ""
"The name of the prepared statement or portal to describe (an empty string "
"selects the unnamed prepared statement or portal)."
msgstr ""
"Имя подготовленного оператора или портала, описание которого запрашивается "
"(пустая строка выбирает безымянный подготовленный оператор или портал)."

#: protocol.xml:3554(term)
msgid "EmptyQueryResponse (B)"
msgstr "EmptyQueryResponse (B)"

#: protocol.xml:3562(term)
msgid "Byte1('I')"
msgstr "Byte1('I')"

#: protocol.xml:3566(para)
msgid ""
"Identifies the message as a response to an empty query string. (This "
"substitutes for CommandComplete.)"
msgstr ""
"Указывает, что это сообщение является ответом на пустую строку запроса. (Это "
"сообщение заменяет CommandComplete.)"

#: protocol.xml:3590(term)
msgid "ErrorResponse (B)"
msgstr "ErrorResponse (B)"

#: protocol.xml:3598(term) protocol.xml:3664(term)
msgid "Byte1('E')"
msgstr "Byte1('E')"

#: protocol.xml:3602(para)
msgid "Identifies the message as an error."
msgstr "Указывает, что это сообщение ошибки."

#: protocol.xml:3627(para) protocol.xml:4005(para)
msgid ""
"A code identifying the field type; if zero, this is the message terminator "
"and no string follows. The presently defined field types are listed in <xref "
"linkend=\"protocol-error-fields\"/>. Since more field types might be added "
"in future, frontends should silently ignore fields of unrecognized type."
msgstr ""
"Код, задающий тип поля; ноль обозначает конец сообщения, после которого "
"ничего нет. Типы полей, определённые в настоящее время, перечислены в <xref "
"remap=\"6\" linkend=\"protocol-error-fields\"/>. Так как в будущем могут "
"появиться другие типы полей, клиенты должны просто игнорировать поля "
"нераспознанного типа."

#: protocol.xml:3643(para) protocol.xml:4021(para)
msgid "The field value."
msgstr "Значение поля."

#: protocol.xml:3594(para) protocol.xml:3972(para)
msgid ""
"<placeholder-1/> The message body consists of one or more identified fields, "
"followed by a zero byte as a terminator. Fields can appear in any order. For "
"each field there is the following: <placeholder-2/>"
msgstr ""
"<placeholder-1/> Тело сообщения состоит из одного или нескольких "
"определённых полей, за которыми в качестве завершающего следует нулевой "
"байт. Поля могут идти в любом порядке. Для каждого поля передаётся: "
"<placeholder-2/>"

#: protocol.xml:3656(term)
msgid "Execute (F)"
msgstr "Execute (F)"

#: protocol.xml:3668(para)
msgid "Identifies the message as an Execute command."
msgstr "Указывает, что это сообщение представляет команду Execute."

#: protocol.xml:3688(para)
msgid ""
"The name of the portal to execute (an empty string selects the unnamed "
"portal)."
msgstr ""
"Имя портала, подлежащего выполнению (пустая строка выбирает безымянный "
"портал)."

#: protocol.xml:3699(para)
msgid ""
"Maximum number of rows to return, if portal contains a query that returns "
"rows (ignored otherwise). Zero denotes <quote>no limit</quote>."
msgstr ""
"Максимальное число строк, которое должно быть возвращено, если портал "
"содержит запрос, возвращающий строки (в противном случае игнорируется). Ноль "
"означает <quote>без ограничения</quote>."

#: protocol.xml:3713(term)
msgid "Flush (F)"
msgstr "Flush (F)"

#: protocol.xml:3725(para)
msgid "Identifies the message as a Flush command."
msgstr "Указывает, что это сообщение представляет команду Flush."

#: protocol.xml:3748(term)
msgid "FunctionCall (F)"
msgstr "FunctionCall (F)"

#: protocol.xml:3756(term)
msgid "Byte1('F')"
msgstr "Byte1('F')"

#: protocol.xml:3760(para)
msgid "Identifies the message as a function call."
msgstr "Указывает, что это сообщение представляет вызов функции."

#: protocol.xml:3780(para)
msgid "Specifies the object ID of the function to call."
msgstr "Задаёт идентификатор объекта вызываемой функции."

#: protocol.xml:3790(para)
msgid ""
"The number of argument format codes that follow (denoted <replaceable>C</"
"replaceable> below). This can be zero to indicate that there are no "
"arguments or that the arguments all use the default format (text); or one, "
"in which case the specified format code is applied to all arguments; or it "
"can equal the actual number of arguments."
msgstr ""
"Количество кодов форматов следующих аргументов (обозначается ниже символом "
"<replaceable>C</replaceable>). Может быть нулевым, что показывает, что "
"аргументы отсутствуют или все аргументы передаются в формате по умолчанию "
"(текстовом); либо равняться одному, в этом случае указанный один код формата "
"применяется ко всем аргументами, либо может равняться действительному "
"количеству аргументов."

#: protocol.xml:3806(para)
msgid ""
"The argument format codes. Each must presently be zero (text) or one "
"(binary)."
msgstr ""
"Коды форматов аргументов. В настоящее время допускаются коды ноль (текстовый "
"формат) и один (двоичный)."

#: protocol.xml:3817(para)
msgid "Specifies the number of arguments being supplied to the function."
msgstr "Задаёт число аргументов, передаваемых функции."

#: protocol.xml:3831(para)
msgid ""
"The length of the argument value, in bytes (this count does not include "
"itself). Can be zero. As a special case, -1 indicates a NULL argument value. "
"No value bytes follow in the NULL case."
msgstr ""
"Длина значения аргумента, в байтах (само поле длины не считается). Может "
"быть нулевой. В качестве особого значения, -1 представляет значение NULL. В "
"случае с NULL никакие байты значений далее не следуют."

#: protocol.xml:3844(para)
msgid ""
"The value of the argument, in the format indicated by the associated format "
"code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение аргумента, в формате, определённом соответствующим кодом формата. "
"Переменная <replaceable>n</replaceable> задаёт длину значения."

#: protocol.xml:3859(para)
msgid ""
"The format code for the function result. Must presently be zero (text) or "
"one (binary)."
msgstr ""
"Код формата результата функции. В настоящее время допускается код ноль "
"(текстовый формат) и один (двоичный)."

#: protocol.xml:3752(para)
msgid ""
"<placeholder-1/> Next, the following pair of fields appear for each "
"argument: <placeholder-2/> After the last argument, the following field "
"appears: <placeholder-3/>"
msgstr ""
"<placeholder-1/> Затем для каждого аргумента идёт следующая пара полей: "
"<placeholder-2/> За последним аргументом идут следующие поля: <placeholder-3/"
">"

#: protocol.xml:3873(term)
msgid "FunctionCallResponse (B)"
msgstr "FunctionCallResponse (B)"

#: protocol.xml:3881(term)
msgid "Byte1('V')"
msgstr "Byte1('V')"

#: protocol.xml:3885(para)
msgid "Identifies the message as a function call result."
msgstr "Указывает, что в этом сообщении передаётся результат вызова функции."

#: protocol.xml:3905(para)
msgid ""
"The length of the function result value, in bytes (this count does not "
"include itself). Can be zero. As a special case, -1 indicates a NULL "
"function result. No value bytes follow in the NULL case."
msgstr ""
"Длина значения результата функции, в байтах (само поле длины не считается). "
"Может быть нулевой. В качестве особого значения, -1 представляет значение "
"NULL. В случае с NULL никакие байты значения далее не следуют."

#: protocol.xml:3918(para)
msgid ""
"The value of the function result, in the format indicated by the associated "
"format code. <replaceable>n</replaceable> is the above length."
msgstr ""
"Значение результата функции в формате, определённом соответствующим кодом "
"формата. Переменная <replaceable>n</replaceable> задаёт длину значения."

#: protocol.xml:3933(term)
msgid "NoData (B)"
msgstr "NoData (B)"

#: protocol.xml:3941(term)
msgid "Byte1('n')"
msgstr "Byte1('n')"

#: protocol.xml:3945(para)
msgid "Identifies the message as a no-data indicator."
msgstr "Указывает, что это сообщение сигнализирует об отсутствии данных."

#: protocol.xml:3968(term)
msgid "NoticeResponse (B)"
msgstr "NoticeResponse (B)"

#: protocol.xml:3976(term)
msgid "Byte1('N')"
msgstr "Byte1('N')"

#: protocol.xml:3980(para)
msgid "Identifies the message as a notice."
msgstr "Указывает, что это сообщение представляет замечание."

#: protocol.xml:4034(term)
msgid "NotificationResponse (B)"
msgstr "NotificationResponse (B)"

#: protocol.xml:4042(term)
msgid "Byte1('A')"
msgstr "Byte1('A')"

#: protocol.xml:4046(para)
msgid "Identifies the message as a notification response."
msgstr "Указывает, что это сообщение представляет уведомление."

#: protocol.xml:4066(para)
msgid "The process ID of the notifying backend process."
msgstr "PID обслуживающего процесса, отправляющего уведомление."

#: protocol.xml:4076(para)
msgid "The name of the channel that the notify has been raised on."
msgstr "Имя канала, для которого было выдано уведомление."

#: protocol.xml:4086(para)
msgid "The <quote>payload</quote> string passed from the notifying process."
msgstr "Строка <quote>сообщения</quote>, сопровождающего уведомление."

#: protocol.xml:4099(term)
msgid "ParameterDescription (B)"
msgstr "ParameterDescription (B)"

#: protocol.xml:4107(term)
msgid "Byte1('t')"
msgstr "Byte1('t')"

#: protocol.xml:4111(para)
msgid "Identifies the message as a parameter description."
msgstr "Указывает, что это сообщение представляет описание параметра."

#: protocol.xml:4131(para)
msgid "The number of parameters used by the statement (can be zero)."
msgstr "Количество параметров для оператора (может быть нулевым)."

#: protocol.xml:4145(para)
msgid "Specifies the object ID of the parameter data type."
msgstr "Задаёт идентификатор объекта типа данных параметра."

#: protocol.xml:4103(para) protocol.xml:4215(para)
msgid ""
"<placeholder-1/> Then, for each parameter, there is the following: "
"<placeholder-2/>"
msgstr ""
"<placeholder-1/> Затем для каждого параметра передаётся: <placeholder-2/>"

#: protocol.xml:4157(term)
msgid "ParameterStatus (B)"
msgstr "ParameterStatus (B)"

#: protocol.xml:4165(term) protocol.xml:4792(term)
msgid "Byte1('S')"
msgstr "Byte1('S')"

#: protocol.xml:4169(para)
msgid "Identifies the message as a run-time parameter status report."
msgstr ""
"Указывает, что в этом сообщении передаётся состояние параметра времени "
"выполнения."

#: protocol.xml:4189(para)
msgid "The name of the run-time parameter being reported."
msgstr "Имя параметра времени выполнения, состояние которого передаётся."

#: protocol.xml:4199(para)
msgid "The current value of the parameter."
msgstr "Текущее значение параметра."

#: protocol.xml:4211(term)
msgid "Parse (F)"
msgstr "Parse (F)"

#: protocol.xml:4219(term)
msgid "Byte1('P')"
msgstr "Byte1('P')"

#: protocol.xml:4223(para)
msgid "Identifies the message as a Parse command."
msgstr "Указывает, что это сообщение представляет команду Parse."

#: protocol.xml:4243(para)
msgid ""
"The name of the destination prepared statement (an empty string selects the "
"unnamed prepared statement)."
msgstr ""
"Имя целевого подготовленного оператора (пустая строка выбирает безымянный "
"подготовленный оператор)."

#: protocol.xml:4254(para)
msgid "The query string to be parsed."
msgstr "Строка запроса, которая должна быть разобрана."

#: protocol.xml:4264(para)
msgid ""
"The number of parameter data types specified (can be zero). Note that this "
"is not an indication of the number of parameters that might appear in the "
"query string, only the number that the frontend wants to prespecify types "
"for."
msgstr ""
"Количество типов параметров (может быть нулевым). Заметьте, что это значение "
"представляет не число параметров, которые могут фигурировать в строке "
"запроса, а число параметров, для которых клиент хочет предопределить типы."

#: protocol.xml:4281(para)
msgid ""
"Specifies the object ID of the parameter data type. Placing a zero here is "
"equivalent to leaving the type unspecified."
msgstr ""
"Задаёт идентификатор объекта типа данных параметра. Указание нулевого "
"значения равносильно отсутствию указания типа."

#: protocol.xml:4295(term)
msgid "ParseComplete (B)"
msgstr "ParseComplete (B)"

#: protocol.xml:4303(term)
msgid "Byte1('1')"
msgstr "Byte1('1')"

#: protocol.xml:4307(para)
msgid "Identifies the message as a Parse-complete indicator."
msgstr "Указывает, что это сообщение, сигнализирующее о завершении Parse."

#: protocol.xml:4330(term)
msgid "PasswordMessage (F)"
msgstr "PasswordMessage (F)"

#: protocol.xml:4338(term)
msgid "Byte1('p')"
msgstr "Byte1('p')"

#: protocol.xml:4342(para)
msgid ""
"Identifies the message as a password response. Note that this is also used "
"for GSSAPI and SSPI response messages (which is really a design error, since "
"the contained data is not a null-terminated string in that case, but can be "
"arbitrary binary data)."
msgstr ""
"Указывает, что это сообщение, в котором передаётся пароль. Заметьте, что оно "
"также применяется для передачи сообщений обмена GSSAPI и SSPI (это на самом "
"деле ошибка проектирования, так как в этом случае сообщение может содержать "
"произвольные двоичные данные, а не текстовую строку, оканчивающуюся нулём)."

#: protocol.xml:4366(para)
msgid "The password (encrypted, if requested)."
msgstr "Пароль (зашифрованный, если требуется)."

#: protocol.xml:4378(term)
msgid "PortalSuspended (B)"
msgstr "PortalSuspended (B)"

#: protocol.xml:4386(term)
msgid "Byte1('s')"
msgstr "Byte1('s')"

#: protocol.xml:4390(para)
msgid ""
"Identifies the message as a portal-suspended indicator. Note this only "
"appears if an Execute message's row-count limit was reached."
msgstr ""
"Указывает, что это сообщение сигнализирует о приостановке портала. Заметьте, "
"что оно выдаётся только при достижении ограничения числа строк, заданного в "
"сообщении Execute."

#: protocol.xml:4415(term)
msgid "Query (F)"
msgstr "Query (F)"

#: protocol.xml:4423(term)
msgid "Byte1('Q')"
msgstr "Byte1('Q')"

#: protocol.xml:4427(para)
msgid "Identifies the message as a simple query."
msgstr "Указывает, что это сообщение представляет простой запрос."

#: protocol.xml:4447(para)
msgid "The query string itself."
msgstr "Собственно строка запроса."

#: protocol.xml:4460(term)
msgid "ReadyForQuery (B)"
msgstr "ReadyForQuery (B)"

#: protocol.xml:4468(term)
msgid "Byte1('Z')"
msgstr "Byte1('Z')"

#: protocol.xml:4472(para)
msgid ""
"Identifies the message type. ReadyForQuery is sent whenever the backend is "
"ready for a new query cycle."
msgstr ""
"Определяет тип сообщения. Сообщение ReadyForQuery передаётся, когда сервер "
"готов к новому циклу запросов."

#: protocol.xml:4493(para)
msgid ""
"Current backend transaction status indicator. Possible values are "
"'<literal>I</literal>' if idle (not in a transaction block); '<literal>T</"
"literal>' if in a transaction block; or '<literal>E</literal>' if in a "
"failed transaction block (queries will be rejected until block is ended)."
msgstr ""
"Индикатор текущего состояния транзакции на сервере. Возможные значения: "
"'<literal>I</literal>', транзакция неактивна (вне блока транзакции), "
"'<literal>T</literal>' в блоке транзакции, либо '<literal>E</literal>' в "
"блоке прерванной транзакции (запросы не будут обрабатываться до завершения "
"блока)."

#: protocol.xml:4510(term)
msgid "RowDescription (B)"
msgstr "RowDescription (B)"

#: protocol.xml:4518(term)
msgid "Byte1('T')"
msgstr "Byte1('T')"

#: protocol.xml:4522(para)
msgid "Identifies the message as a row description."
msgstr "Указывает, что это сообщение представляет описание строки."

#: protocol.xml:4542(para)
msgid "Specifies the number of fields in a row (can be zero)."
msgstr "Задаёт количество полей в строке (может быть нулевым)."

#: protocol.xml:4555(para)
msgid "The field name."
msgstr "Имя поля."

#: protocol.xml:4565(para)
msgid ""
"If the field can be identified as a column of a specific table, the object "
"ID of the table; otherwise zero."
msgstr ""
"Если поле связано со столбцом определённой таблицы, идентификатор объекта "
"этой таблицы; в противном случае — ноль."

#: protocol.xml:4576(para)
msgid ""
"If the field can be identified as a column of a specific table, the "
"attribute number of the column; otherwise zero."
msgstr ""
"Если поле связано со столбцом определённой таблицы, номер атрибута для этого "
"столбца; в противном случае — ноль."

#: protocol.xml:4587(para)
msgid "The object ID of the field's data type."
msgstr "Идентификатор объекта типа данных поля."

#: protocol.xml:4597(para)
msgid ""
"The data type size (see <varname>pg_type.typlen</varname>). Note that "
"negative values denote variable-width types."
msgstr ""
"Размер типа данных (см. <varname>pg_type.typlen</varname>). Заметьте, что "
"отрицательные значения показывают, что тип имеет переменную длину."

#: protocol.xml:4608(para)
msgid ""
"The type modifier (see <varname>pg_attribute.atttypmod</varname>). The "
"meaning of the modifier is type-specific."
msgstr ""
"Модификатор типа (см. <varname>pg_attribute.atttypmod</varname>). Смысл "
"этого модификатора зависит от типа."

#: protocol.xml:4619(para)
msgid ""
"The format code being used for the field. Currently will be zero (text) or "
"one (binary). In a RowDescription returned from the statement variant of "
"Describe, the format code is not yet known and will always be zero."
msgstr ""
"Код формата, используемого для поля. В настоящее время допускаются коды ноль "
"(текстовый формат) и один (двоичный). В сообщении RowDescription, "
"возвращаемом вариацией Describe для оператора, код формата ещё не известен и "
"всегда будет нулевым."

#: protocol.xml:4514(para)
msgid ""
"<placeholder-1/> Then, for each field, there is the following: "
"<placeholder-2/>"
msgstr "<placeholder-1/> Затем для каждого поля передаётся: <placeholder-2/>"

#: protocol.xml:4635(term)
msgid "SSLRequest (F)"
msgstr "SSLRequest (F)"

#: protocol.xml:4653(term)
msgid "Int32(80877103)"
msgstr "Int32(80877103)"

#: protocol.xml:4657(para)
msgid ""
"The <acronym>SSL</acronym> request code. The value is chosen to contain "
"<literal>1234</literal> in the most significant 16 bits, and <literal>5679</"
"literal> in the least significant 16 bits. (To avoid confusion, this code "
"must not be the same as any protocol version number.)"
msgstr ""
"Код запроса <acronym>SSL</acronym>. Это специально выбранное значение "
"содержит <literal>1234</literal> в старших 16 битах и <literal>5679</"
"literal> в младших 16 битах. (Во избежание неоднозначности этот код не "
"должен совпадать с номером версии протокола.)"

#: protocol.xml:4673(term)
msgid "StartupMessage (F)"
msgstr "StartupMessage (F)"

#: protocol.xml:4691(term)
msgid "Int32(196608)"
msgstr "Int32(196608)"

#: protocol.xml:4695(para)
msgid ""
"The protocol version number. The most significant 16 bits are the major "
"version number (3 for the protocol described here). The least significant 16 "
"bits are the minor version number (0 for the protocol described here)."
msgstr ""
"Номер версии протокола. В старших 16 битах задаётся старший номер версии (3 "
"для протокола, описываемого здесь). В младших 16 битах задаётся младший "
"номер версии (0 для протокола, описываемого здесь)."

#: protocol.xml:4722(literal)
msgid "user"
msgstr "user"

#: protocol.xml:4725(para)
msgid "The database user name to connect as. Required; there is no default."
msgstr ""
"Имя пользователя баз данных, с которым выполняется подключение. Является "
"обязательным, значения по умолчанию нет."

#: protocol.xml:4733(literal)
msgid "database"
msgstr "database"

#: protocol.xml:4736(para)
msgid "The database to connect to. Defaults to the user name."
msgstr ""
"База данных, к которой выполняется подключение. По умолчанию подставляется "
"имя пользователя."

#: protocol.xml:4743(literal)
msgid "options"
msgstr "options"

#: protocol.xml:4746(para)
msgid ""
"Command-line arguments for the backend. (This is deprecated in favor of "
"setting individual run-time parameters.) Spaces within this string are "
"considered to separate arguments, unless escaped with a backslash (<literal>"
"\\</literal>); write <literal>\\\\</literal> to represent a literal "
"backslash."
msgstr ""
"Аргументы командной строки для обслуживающего процесса. (Этот способ "
"считается устаревшим; теперь следует устанавливать отдельные параметры "
"времени выполнения.) Пробелы в этой строке воспринимаются как разделяющие "
"аргументы, если перед ними нет обратной косой черты (<literal>\\</literal>); "
"чтобы представить обратную косую черту буквально, продублируйте её (<literal>"
"\\\\</literal>)."

#: protocol.xml:4716(para)
msgid ""
"The parameter name. Currently recognized names are: <placeholder-1/> In "
"addition to the above, any run-time parameter that can be set at backend "
"start time might be listed. Such settings will be applied during backend "
"start (after parsing the command-line arguments if any). The values will act "
"as session defaults."
msgstr ""
"Имя параметра. В настоящее время принимаются имена: <placeholder-1/> В "
"дополнение к этим параметрам можно установить любые параметры времени "
"выполнения, значение которых может быть задано во время запуска "
"обслуживающего процесса. Заданные значения будут применены при запуске "
"обслуживающего процесса (после разбора аргументов командной строки, если они "
"были переданы). Эти значения станут значениями по умолчанию в новом сеансе."

#: protocol.xml:4771(para)
msgid "The parameter value."
msgstr "Значение параметра."

#: protocol.xml:4677(para)
msgid ""
"<placeholder-1/> The protocol version number is followed by one or more "
"pairs of parameter name and value strings. A zero byte is required as a "
"terminator after the last name/value pair. Parameters can appear in any "
"order. <literal>user</literal> is required, others are optional. Each "
"parameter is specified as: <placeholder-2/>"
msgstr ""
"<placeholder-1/> За номером версии протокола следует одна или несколько пар "
"из имени параметра и строки значения. За последней парой имя/значение должен "
"следовать нулевой байт. Передаваться параметры могут в любом порядке. "
"Обязательным является только параметр <literal>user</literal>, остальные "
"могут отсутствовать. Каждый параметр задаётся так: <placeholder-2/>"

#: protocol.xml:4784(term)
msgid "Sync (F)"
msgstr "Sync (F)"

#: protocol.xml:4796(para)
msgid "Identifies the message as a Sync command."
msgstr "Указывает, что это сообщение представляет команду Sync."

#: protocol.xml:4819(term)
msgid "Terminate (F)"
msgstr "Terminate (F)"

#: protocol.xml:4827(term)
msgid "Byte1('X')"
msgstr "Byte1('X')"

#: protocol.xml:4831(para)
msgid "Identifies the message as a termination."
msgstr "Указывает, что это сообщение завершает сеанс."

#: protocol.xml:4859(title)
msgid "Error and Notice Message Fields"
msgstr "Поля сообщений с ошибками и замечаниями"

#: protocol.xml:4861(para)
msgid ""
"This section describes the fields that can appear in ErrorResponse and "
"NoticeResponse messages. Each field type has a single-byte identification "
"token. Note that any given field type should appear at most once per message."
msgstr ""
"В этом разделе описываются поля, которые могут содержаться в сообщениях "
"ErrorResponse и NoticeResponse. Для каждого типа поля определён свой "
"идентификационный маркер. Заметьте, что в сообщении может содержаться поле "
"любого из этих типов, но не больше одного раза."

#: protocol.xml:4872(literal)
msgid "S"
msgstr "S"

#: protocol.xml:4875(para)
msgid ""
"Severity: the field contents are <literal>ERROR</literal>, <literal>FATAL</"
"literal>, or <literal>PANIC</literal> (in an error message), or "
"<literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal>, or <literal>LOG</literal> (in a notice "
"message), or a localized translation of one of these. Always present."
msgstr ""
"Важность: поле содержит <literal>ERROR</literal>, <literal>FATAL</literal> "
"или <literal>PANIC</literal> (в сообщении об ошибке), либо <literal>WARNING</"
"literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, "
"<literal>INFO</literal> или <literal>LOG</literal> (в сообщении с "
"замечанием), либо переведённые значения (ОШИБКА, ВАЖНО, ПАНИКА, "
"ПРЕДУПРЕЖДЕНИЕ, ЗАМЕЧАНИЕ, ОТЛАДКА, ИНФОРМАЦИЯ, СООБЩЕНИЕ, соответственно). "
"Это поле присутствует всегда."

#: protocol.xml:4888(literal)
msgid "V"
msgstr "V"

#: protocol.xml:4891(para)
msgid ""
"Severity: the field contents are <literal>ERROR</literal>, <literal>FATAL</"
"literal>, or <literal>PANIC</literal> (in an error message), or "
"<literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</"
"literal>, <literal>INFO</literal>, or <literal>LOG</literal> (in a notice "
"message). This is identical to the <literal>S</literal> field except that "
"the contents are never localized. This is present only in messages generated "
"by <productname>PostgreSQL</productname> versions 9.6 and later."
msgstr ""
"Важность: поле содержит <literal>ERROR</literal>, <literal>FATAL</literal> "
"или <literal>PANIC</literal> (в сообщении об ошибке) либо <literal>WARNING</"
"literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, "
"<literal>INFO</literal> или <literal>LOG</literal> (в сообщении с "
"замечанием). Это поле подобно <literal>S</literal>, но его содержимое "
"никогда не переводится. Присутствует только в сообщениях, выдаваемых "
"<productname>PostgreSQL</productname> версии 9.6 и новее."

#: protocol.xml:4907(literal)
msgid "C"
msgstr "C"

#: protocol.xml:4910(para)
msgid ""
"Code: the SQLSTATE code for the error (see <xref linkend=\"errcodes-appendix"
"\"/>). Not localizable. Always present."
msgstr ""
"Код: код SQLSTATE выданной ошибки (см. <xref remap=\"4\" linkend=\"errcodes-"
"appendix\"/>). Не переводится на другие языки, присутствует всегда."

#: protocol.xml:4919(literal)
msgid "M"
msgstr "M"

#: protocol.xml:4922(para)
msgid ""
"Message: the primary human-readable error message. This should be accurate "
"but terse (typically one line). Always present."
msgstr ""
"Сообщение: основное сообщение об ошибке, предназначенное для человека. "
"Должно быть точным, но кратким (обычно в одну строку). Присутствует всегда."

#: protocol.xml:4932(literal)
msgid "D"
msgstr "D"

#: protocol.xml:4935(para)
msgid ""
"Detail: an optional secondary error message carrying more detail about the "
"problem. Might run to multiple lines."
msgstr ""
"Необязательное дополнительное сообщение об ошибке, передающее более "
"детальную информацию о проблеме. Может занимать несколько строк."

#: protocol.xml:4944(literal)
msgid "H"
msgstr "H"

#: protocol.xml:4947(para)
msgid ""
"Hint: an optional suggestion what to do about the problem. This is intended "
"to differ from Detail in that it offers advice (potentially inappropriate) "
"rather than hard facts. Might run to multiple lines."
msgstr ""
"Подсказка: необязательное предложение решения проблемы. Оно должно "
"отличаться от подробного описания тем, что предлагает совет (не обязательно "
"подходящий во всех случаях), а не сухие факты. Может располагаться в "
"нескольких строках."

#: protocol.xml:4958(literal)
msgid "P"
msgstr "P"

#: protocol.xml:4961(para)
msgid ""
"Position: the field value is a decimal ASCII integer, indicating an error "
"cursor position as an index into the original query string. The first "
"character has index 1, and positions are measured in characters not bytes."
msgstr ""
"Позиция: значение поля представляет целочисленное число в ASCII, указывающее "
"на положение ошибки в исходной строке запроса. Первый символ находится в "
"позиции 1, при этом позиции отсчитываются по символам, а не по байтам."

#: protocol.xml:4972(literal)
msgid "p"
msgstr "p"

#: protocol.xml:4975(para)
msgid ""
"Internal position: this is defined the same as the <literal>P</literal> "
"field, but it is used when the cursor position refers to an internally "
"generated command rather than the one submitted by the client. The "
"<literal>q</literal> field will always appear when this field appears."
msgstr ""
"Внутренняя позиция: она определяется так же, как поле <literal>P</literal>, "
"но отражает положение ошибки во внутренне сгенерированной команде, а не в "
"строке, переданной клиентом. Вместе с этим полем всегда присутствует поле "
"<literal>q</literal>."

#: protocol.xml:4986(literal)
msgid "q"
msgstr "q"

#: protocol.xml:4989(para)
msgid ""
"Internal query: the text of a failed internally-generated command. This "
"could be, for example, a SQL query issued by a PL/pgSQL function."
msgstr ""
"Внутренний запрос: текст внутренне сгенерированной команды, в которой "
"произошла ошибка. Это может быть, например, SQL-запрос, выполняемый функцией "
"на PL/pgSQL."

#: protocol.xml:4998(literal)
msgid "W"
msgstr "W"

#: protocol.xml:5001(para)
msgid ""
"Where: an indication of the context in which the error occurred. Presently "
"this includes a call stack traceback of active procedural language functions "
"and internally-generated queries. The trace is one entry per line, most "
"recent first."
msgstr ""
"Где: указывает на контекст, в котором произошла ошибка. В настоящее время "
"включает трассировку стека вызовов текущей функции на процедурном языке и "
"внутренне сгенерированных запросов. Записи трассировки разделяются по "
"строкам, вначале последняя."

#: protocol.xml:5012(literal)
msgid "s"
msgstr "s"

#: protocol.xml:5015(para)
msgid ""
"Schema name: if the error was associated with a specific database object, "
"the name of the schema containing that object, if any."
msgstr ""
"Имя схемы: если ошибка связана с некоторым объектом базы данных, это поле "
"содержит имя схемы, к которой относится объект (если такая есть)."

#: protocol.xml:5024(literal)
msgid "t"
msgstr "t"

#: protocol.xml:5027(para)
msgid ""
"Table name: if the error was associated with a specific table, the name of "
"the table. (Refer to the schema name field for the name of the table's "
"schema.)"
msgstr ""
"Имя таблицы: если ошибка связана с некоторой таблицей, это поле содержит имя "
"таблицы. (Узнать имя схемы таблицы можно из соответствующего отдельного "
"поля.)"

#: protocol.xml:5037(literal)
msgid "c"
msgstr "c"

#: protocol.xml:5040(para)
msgid ""
"Column name: if the error was associated with a specific table column, the "
"name of the column. (Refer to the schema and table name fields to identify "
"the table.)"
msgstr ""
"Имя столбца: если ошибка связана с некоторым столбцом таблицы, это поле "
"содержит имя столбца. (Идентифицировать таблицу можно, обратившись к полям, "
"содержащим имя таблицы и схемы.)"

#: protocol.xml:5050(literal)
msgid "d"
msgstr "d"

#: protocol.xml:5053(para)
msgid ""
"Data type name: if the error was associated with a specific data type, the "
"name of the data type. (Refer to the schema name field for the name of the "
"data type's schema.)"
msgstr ""
"Имя типа данных: если ошибка связана с некоторым типом данных, это поле "
"содержит имя типа. (Узнать имя схемы типа можно из соответствующего поля.)"

#: protocol.xml:5063(literal)
msgid "n"
msgstr "n"

#: protocol.xml:5066(para)
msgid ""
"Constraint name: if the error was associated with a specific constraint, the "
"name of the constraint. Refer to fields listed above for the associated "
"table or domain. (For this purpose, indexes are treated as constraints, even "
"if they weren't created with constraint syntax.)"
msgstr ""
"Имя ограничения: если ошибка связана с некоторым ограничением, это поле "
"содержит имя ограничения. Чтобы узнать, к какой таблице или домену она "
"относится, обратитесь к полям, описанным выше. (В данном контексте индексы "
"считаются ограничениями, даже если они были созданы не с синтаксисом "
"ограничений.)"

#: protocol.xml:5078(literal)
msgid "F"
msgstr "F"

#: protocol.xml:5081(para)
msgid ""
"File: the file name of the source-code location where the error was reported."
msgstr "Файл: имя файла с исходным кодом, в котором была обнаружена ошибка."

#: protocol.xml:5090(literal)
msgid "L"
msgstr "L"

#: protocol.xml:5093(para)
msgid ""
"Line: the line number of the source-code location where the error was "
"reported."
msgstr ""
"Строка: номер строки в исходном коде, в которой была обнаружена ошибка."

#: protocol.xml:5102(literal)
msgid "R"
msgstr "R"

#: protocol.xml:5105(para)
msgid "Routine: the name of the source-code routine reporting the error."
msgstr ""
"Программа: имя программы в исходном коде, в которой была обнаружена ошибка."

#: protocol.xml:5114(para)
msgid ""
"The fields for schema name, table name, column name, data type name, and "
"constraint name are supplied only for a limited number of error types; see "
"<xref linkend=\"errcodes-appendix\"/>. Frontends should not assume that the "
"presence of any of these fields guarantees the presence of another field. "
"Core error sources observe the interrelationships noted above, but user-"
"defined functions may use these fields in other ways. In the same vein, "
"clients should not assume that these fields denote contemporary objects in "
"the current database."
msgstr ""
"Поля, содержащие имена схемы, таблицы, столбца, типа данных и ограничения, "
"выдаются только для ограниченного числа типов ошибок; см. <xref remap=\"4\" "
"linkend=\"errcodes-appendix\"/>. Клиенты не должны рассчитывать на то, что "
"присутствие одного из полей обязательно влечёт присутствие другого поля. "
"Системные источники ошибок устанавливают связь между ними, но "
"пользовательские функции могут использовать эти поля по-другому. Подобным "
"образом, клиенты не должны полагаться на то, что эти поля ссылаются на "
"актуальные объекты в текущей базе данных."

#: protocol.xml:5126(para)
msgid ""
"The client is responsible for formatting displayed information to meet its "
"needs; in particular it should break long lines as needed. Newline "
"characters appearing in the error message fields should be treated as "
"paragraph breaks, not line breaks."
msgstr ""
"Клиент отвечает за форматирование отображаемой информации в соответствии с "
"его нуждами; в частности, он должен разбивать длинные строки, как требуется. "
"Символы новой строки, встречающиеся в полях сообщения об ошибке, должны "
"обрабатываться, как разрывы абзацев, а не строк."

#: protocol.xml:5136(title)
msgid "Summary of Changes since Protocol 2.0"
msgstr "Сводка изменений по сравнению с протоколом версии 2.0"

#: protocol.xml:5138(para)
msgid ""
"This section provides a quick checklist of changes, for the benefit of "
"developers trying to update existing client libraries to protocol 3.0."
msgstr ""
"В этом разделе представлен краткий список изменений к сведению "
"разработчиков, желающих модернизировать существующие клиентские библиотеки "
"до протокола 3.0."

#: protocol.xml:5143(para)
msgid ""
"The initial startup packet uses a flexible list-of-strings format instead of "
"a fixed format. Notice that session default values for run-time parameters "
"can now be specified directly in the startup packet. (Actually, you could do "
"that before using the <literal>options</literal> field, but given the "
"limited width of <literal>options</literal> and the lack of any way to quote "
"whitespace in the values, it wasn't a very safe technique.)"
msgstr ""
"В начальном стартовом пакете вместо фиксированного формата применяется "
"гибкий формат списка строк. Заметьте, что теперь сеансовые значения по "
"умолчанию для параметров времени выполнения можно задать непосредственно в "
"стартовом пакете. (Вообще, это можно было делать и раньше, используя поле "
"<literal>options</literal>, но из-за ограниченного размера <literal>options</"
"literal> и невозможности задавать значения с пробелами, это вариант был не "
"очень безопасным.)"

#: protocol.xml:5152(para)
msgid ""
"All messages now have a length count immediately following the message type "
"byte (except for startup packets, which have no type byte). Also note that "
"PasswordMessage now has a type byte."
msgstr ""
"Во всех сообщениях непосредственно за байтом типа сообщения следует счётчик "
"длины (за исключением стартовых пакетов, в которых нет байта типа). Также "
"заметьте, что байт типа теперь есть в сообщении PasswordMessage."

#: protocol.xml:5158(para)
msgid ""
"ErrorResponse and NoticeResponse ('<literal>E</literal>' and '<literal>N</"
"literal>') messages now contain multiple fields, from which the client code "
"can assemble an error message of the desired level of verbosity. Note that "
"individual fields will typically not end with a newline, whereas the single "
"string sent in the older protocol always did."
msgstr ""
"Сообщения ErrorResponse и NoticeResponse ('<literal>E</literal>' и "
"'<literal>N</literal>') могут содержать несколько полей, из которых "
"клиентский код может собрать сообщение об ошибке желаемого уровня "
"детализации. Заметьте, что текст отдельных полей обычно не завершается новой "
"строкой, тогда как в старом протоколе одиночная строка всегда завершалась "
"так."

#: protocol.xml:5166(para)
msgid ""
"The ReadyForQuery ('<literal>Z</literal>') message includes a transaction "
"status indicator."
msgstr ""
"Сообщение ReadyForQuery ('<literal>Z</literal>') включает индикатор статуса "
"транзакции."

#: protocol.xml:5171(para)
msgid ""
"The distinction between BinaryRow and DataRow message types is gone; the "
"single DataRow message type serves for returning data in all formats. Note "
"that the layout of DataRow has changed to make it easier to parse. Also, the "
"representation of binary values has changed: it is no longer directly tied "
"to the server's internal representation."
msgstr ""
"Различие между типами данных BinaryRow и DataRow ушло; один тип сообщений "
"DataRow позволяет возвращать данные во всех форматах. Заметьте, что формат "
"DataRow был изменён для упрощения его разбора. Также изменилось "
"представление двоичных значений: оно больше не привязано к внутреннему "
"представлению сервера."

#: protocol.xml:5179(para)
msgid ""
"There is a new <quote>extended query</quote> sub-protocol, which adds the "
"frontend message types Parse, Bind, Execute, Describe, Close, Flush, and "
"Sync, and the backend message types ParseComplete, BindComplete, "
"PortalSuspended, ParameterDescription, NoData, and CloseComplete. Existing "
"clients do not have to concern themselves with this sub-protocol, but making "
"use of it might allow improvements in performance or functionality."
msgstr ""
"В протоколе появился новый подраздел <quote>расширенный запрос</quote>, в "
"котором добавлены типы сообщений для команд Parse, Bind, Execute, Describe, "
"Close, Flush и Sync, а также типы серверных сообщений ParseComplete, "
"BindComplete, PortalSuspended, ParameterDescription, NoData и CloseComplete. "
"Существующие клиенты могут не подстраиваться под этот раздел протокола, но "
"если они задействует его, это позволит улучшить производительность или "
"функциональность."

#: protocol.xml:5188(para)
msgid ""
"<command>COPY</command> data is now encapsulated into CopyData and CopyDone "
"messages. There is a well-defined way to recover from errors during "
"<command>COPY</command>. The special <quote><literal>\\.</literal></quote> "
"last line is not needed anymore, and is not sent during <command>COPY OUT</"
"command>. (It is still recognized as a terminator during <command>COPY IN</"
"command>, but its use is deprecated and will eventually be removed.) Binary "
"<command>COPY</command> is supported. The CopyInResponse and CopyOutResponse "
"messages include fields indicating the number of columns and the format of "
"each column."
msgstr ""
"Данные <command>COPY</command> теперь внедряются в сообщения CopyData и "
"CopyDone. Есть чётко определённый способ восстановить работу в случае ошибок "
"в процессе <command>COPY</command>. Специальная последняя строка "
"<quote><literal>\\.</literal></quote> больше не нужна, она не передаётся при "
"выполнении <command>COPY OUT</command>. (Она по-прежнему воспринимается как "
"завершающая последовательность в потоке <command>COPY IN</command>, но это "
"считается устаревшим способом завершения, и в конце концов он будет "
"исключён.) Поддерживается <command>COPY</command> в двоичном режиме. "
"Сообщения CopyInResponse и CopyOutResponse включают поля, определяющие число "
"столбцов и формат каждого столбца."

#: protocol.xml:5199(para)
msgid ""
"The layout of FunctionCall and FunctionCallResponse messages has changed. "
"FunctionCall can now support passing NULL arguments to functions. It also "
"can handle passing parameters and retrieving results in either text or "
"binary format. There is no longer any reason to consider FunctionCall a "
"potential security hole, since it does not offer direct access to internal "
"server data representations."
msgstr ""
"Изменилась структура сообщений FunctionCall и FunctionCallResponse. "
"Сообщение FunctionCall теперь позволяет передавать функциям аргументы NULL. "
"Ещё в нём могут передаваться параметры и получаться результаты в текстовом "
"или двоичном формате. Не осталось повода считать сообщение FunctionCall "
"потенциально небезопасным, так как оно не даёт прямого доступа к внутренней "
"презентации данных на сервере."

#: protocol.xml:5208(para)
msgid ""
"The backend sends ParameterStatus ('<literal>S</literal>') messages during "
"connection startup for all parameters it considers interesting to the client "
"library. Subsequently, a ParameterStatus message is sent whenever the active "
"value changes for any of these parameters."
msgstr ""
"Сервер отправляет сообщения ParameterStatus ('<literal>S</literal>') при "
"попытке подключения для всех параметров, которые он считает интересными для "
"клиентской библиотеки. Как следствие, при любом изменении активного значения "
"одного из этих параметров также выдаётся сообщение ParameterStatus."

#: protocol.xml:5215(para)
msgid ""
"The RowDescription ('<literal>T</literal>') message carries new table OID "
"and column number fields for each column of the described row. It also shows "
"the format code for each column."
msgstr ""
"Сообщение RowDescription ('<literal>T</literal>') содержит поля с OID "
"таблицы и номером столбца для каждого столбца описываемой строки. В нём "
"также передаётся код формата для каждого столбца."

#: protocol.xml:5221(para)
msgid ""
"The CursorResponse ('<literal>P</literal>') message is no longer generated "
"by the backend."
msgstr ""
"Сервер более не выдаёт сообщение CursorResponse ('<literal>P</literal>')."

#: protocol.xml:5226(para)
msgid ""
"The NotificationResponse ('<literal>A</literal>') message has an additional "
"string field, which can carry a <quote>payload</quote> string passed from "
"the <command>NOTIFY</command> event sender."
msgstr ""
"В сообщении NotificationResponse ('<literal>A</literal>') добавилось ещё "
"одно строковое поле, в котором может передаваться строка <quote>сообщения</"
"quote> от отправителя события <command>NOTIFY</command>."

#: protocol.xml:5232(para)
msgid ""
"The EmptyQueryResponse ('<literal>I</literal>') message used to include an "
"empty string parameter; this has been removed."
msgstr ""
"Раньше сообщение EmptyQueryResponse ('<literal>I</literal>') включало пустой "
"строковый параметр; теперь он ликвидирован."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: protocol.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
