# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:13+0300\n"
"PO-Revision-Date: 2017-08-15 11:32+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:5(title)
msgid "pageinspect"
msgstr "pageinspect"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:7(indexterm)
msgid "<primary>pageinspect</primary>"
msgstr "<primary>pageinspect</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:11(para)
msgid ""
"The <filename>pageinspect</filename> module provides functions that allow "
"you to inspect the contents of database pages at a low level, which is "
"useful for debugging purposes. All of these functions may be used only by "
"superusers."
msgstr ""
"Модуль <filename>pageinspect</filename> предоставляет функции, позволяющие "
"исследовать страницы баз данных на низком уровне, что бывает полезно для "
"отладки. Все эти функции могут вызывать только суперпользователи."

#. +> REL_10
#: pageinspect.xml:18(title)
msgid "General Functions"
msgstr "Функции общего назначения"

#. +> REL9_6_3 REL9_6
#: pageinspect.xml:18(title)
msgid "Functions"
msgstr "Функции"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:23(function)
msgid "get_raw_page(relname text, fork text, blkno int) returns bytea"
msgstr "get_raw_page(relname text, fork text, blkno int) returns bytea"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:24(indexterm)
msgid "<primary>get_raw_page</primary>"
msgstr "<primary>get_raw_page</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:30(para)
msgid ""
"<function>get_raw_page</function> reads the specified block of the named "
"relation and returns a copy as a <type>bytea</type> value. This allows a "
"single time-consistent copy of the block to be obtained. <replaceable>fork</"
"replaceable> should be <literal>'main'</literal> for the main data fork, "
"<literal>'fsm'</literal> for the free space map, <literal>'vm'</literal> for "
"the visibility map, or <literal>'init'</literal> for the initialization fork."
msgstr ""
"Функция <function>get_raw_page</function> считывает указанный блок отношения "
"с заданным именем и возвращает копию значения <type>bytea</type>. Это "
"позволяет получить одну согласованную во времени копию блока. В параметре "
"<parameter>fork</parameter> нужно передать <literal>'main'</literal>, чтобы "
"обратиться к основному слою данных, <literal>'fsm'</literal> — к карте "
"свободного пространства, <literal>'vm'</literal> — к карте видимости, либо "
"<literal>'init'</literal> — к слою инициализации."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:44(function)
msgid "get_raw_page(relname text, blkno int) returns bytea"
msgstr "get_raw_page(relname text, blkno int) returns bytea"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:48(para)
msgid ""
"A shorthand version of <function>get_raw_page</function>, for reading from "
"the main fork. Equivalent to <literal>get_raw_page(relname, 'main', blkno)</"
"literal>"
msgstr ""
"Упрощённая версия <function>get_raw_page</function> для чтения данных из "
"основного слоя. Синоним <literal>get_raw_page(relname, 'main', blkno)</"
"literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:58(function)
msgid "page_header(page bytea) returns record"
msgstr "page_header(page bytea) returns record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:59(indexterm)
msgid "<primary>page_header</primary>"
msgstr "<primary>page_header</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:65(para)
msgid ""
"<function>page_header</function> shows fields that are common to all "
"<productname>PostgreSQL</productname> heap and index pages."
msgstr ""
"Функция <function>page_header</function> показывает поля, общие для всех "
"страниц кучи и индекса <productname>PostgreSQL</productname>."

#. +> REL_10
#: pageinspect.xml:70(para)
msgid ""
"A page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>\n"
"test=# SELECT * FROM page_header(get_raw_page('pg_class', 0));\n"
"    lsn    | checksum | flags  | lower | upper | special | pagesize | "
"version | prune_xid\n"
"-----------+----------+--------+-------+-------+---------+----------"
"+---------+-----------\n"
" 0/24A1B50 |        0 |      1 |   232 |   368 |    8192 |     8192 |       "
"4 |         0\n"
"</screen> The returned columns correspond to the fields in the "
"<structname>PageHeaderData</structname> struct. See <filename>src/include/"
"storage/bufpage.h</filename> for details."
msgstr ""
"В качестве аргумента ей передаётся образ страницы, полученный в результате "
"вызова <function>get_raw_page</function>. Например: <screen>\n"
"test=# SELECT * FROM page_header(get_raw_page('pg_class', 0));\n"
"    lsn    | checksum | flags  | lower | upper | special | pagesize | "
"version | prune_xid\n"
"-----------+----------+--------+-------+-------+---------+----------"
"+---------+-----------\n"
" 0/24A1B50 |        0 |      1 |   232 |   368 |    8192 |     8192 |       "
"4 |         0\n"
"</screen> Возвращаемые столбцы соответствуют полям в структуре "
"<structname>PageHeaderData</structname>. За подробностями обратитесь к "
"<filename>src/include/storage/bufpage.h</filename>."

#. +> REL9_6_3 REL9_6
#: pageinspect.xml:70(para)
msgid ""
"A page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>\n"
"test=# SELECT * FROM page_header(get_raw_page('pg_class', 0));\n"
"    lsn    | checksum | flags  | lower | upper | special | pagesize | "
"version | prune_xid\n"
"-----------+----------+--------+-------+-------+---------+----------"
"+---------+-----------\n"
" 0/24A1B50 |        1 |      1 |   232 |   368 |    8192 |     8192 |       "
"4 |         0\n"
"</screen> The returned columns correspond to the fields in the "
"<structname>PageHeaderData</structname> struct. See <filename>src/include/"
"storage/bufpage.h</filename> for details."
msgstr ""
"В качестве аргумента ей передаётся образ страницы, полученный в результате "
"вызова <function>get_raw_page</function>. Например: <screen>\n"
"test=# SELECT * FROM page_header(get_raw_page('pg_class', 0));\n"
"    lsn    | checksum | flags  | lower | upper | special | pagesize | "
"version | prune_xid\n"
"-----------+----------+--------+-------+-------+---------+----------"
"+---------+-----------\n"
" 0/24A1B50 |        1 |      1 |   232 |   368 |    8192 |     8192 |       "
"4 |         0\n"
"</screen> Возвращаемые столбцы соответствуют полям в структуре "
"<structname>PageHeaderData</structname>. За подробностями обратитесь к "
"<filename>src/include/storage/bufpage.h</filename>."

#. +> REL_10
#: pageinspect.xml:84(para)
msgid ""
"The <structfield>checksum</structfield> field is the checksum stored in the "
"page, which might be incorrect if the page is somehow corrupted. If data "
"checksums are not enabled for this instance, then the value stored is "
"meaningless."
msgstr ""
"Поле <structfield>checksum</structfield> содержит контрольную сумму, "
"сохранённую для страницы. Эта сумма может быть неверной при повреждении "
"страницы. Если в данном экземпляре кластера контрольные суммы отключены, это "
"значение не имеет смысла."

#. +> REL_10
#: pageinspect.xml:95(function)
msgid "page_checksum(page bytea, blkno int4) returns smallint"
msgstr "page_checksum(page bytea, blkno int4) returns smallint"

#. +> REL_10
#: pageinspect.xml:96(indexterm)
msgid "<primary>page_checksum</primary>"
msgstr "<primary>page_checksum</primary>"

#. +> REL_10
#: pageinspect.xml:102(para)
msgid ""
"<function>page_checksum</function> computes the checksum for the page, as if "
"it was located at the given block."
msgstr ""
"Функция <function>page_checksum</function> вычисляет контрольную сумму "
"страницы, которая должна была бы находиться в заданном блоке."

#. +> REL_10
#: pageinspect.xml:107(para)
msgid ""
"A page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>\n"
"test=# SELECT page_checksum(get_raw_page('pg_class', 0), 0);\n"
" page_checksum\n"
"---------------\n"
"         13443\n"
"</screen> Note that the checksum depends on the block number, so matching "
"block numbers should be passed (except when doing esoteric debugging)."
msgstr ""
"В качестве аргумента ей передаётся образ страницы, полученный в результате "
"вызова <function>get_raw_page</function>. Например: <screen>\n"
"test=# SELECT page_checksum(get_raw_page('pg_class', 0), 0);\n"
" page_checksum\n"
"---------------\n"
"         13443\n"
"</screen> Заметьте, что вычисление контрольной суммы зависит от номера "
"блока, поэтому обеим функциям нужно передавать одинаковые номера (за "
"исключением случаев эзотерической отладки)."

#. +> REL_10
#: pageinspect.xml:120(para)
msgid ""
"The checksum computed with this function can be compared with the "
"<structfield>checksum</structfield> result field of the function "
"<function>page_header</function>. If data checksums are enabled for this "
"instance, then the two values should be equal."
msgstr ""
"Контрольную сумму, вычисленную этой функцией, можно сравнить с полем "
"<structfield>checksum</structfield> результата функции "
"<function>page_header</function>. Если контрольные суммы для текущего "
"экземпляра БД включены, эти значения должны быть равны."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:131(function)
msgid "heap_page_items(page bytea) returns setof record"
msgstr "heap_page_items(page bytea) returns setof record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:132(indexterm)
msgid "<primary>heap_page_items</primary>"
msgstr "<primary>heap_page_items</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:138(para)
msgid ""
"<function>heap_page_items</function> shows all line pointers on a heap page. "
"For those line pointers that are in use, tuple headers as well as tuple raw "
"data are also shown. All tuples are shown, whether or not the tuples were "
"visible to an MVCC snapshot at the time the raw page was copied."
msgstr ""
"Функция <function>heap_page_items</function> показывает все указатели "
"линейных блоков на странице кучи. Для используемых блоков также выводятся "
"заголовки кортежей. При этом показываются все кортежи, независимо от того, "
"были ли видны они в снимке MVCC в момент копирования исходной страницы."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:145(para)
msgid ""
"A heap page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>\n"
"test=# SELECT * FROM heap_page_items(get_raw_page('pg_class', 0));\n"
"</screen> See <filename>src/include/storage/itemid.h</filename> and "
"<filename>src/include/access/htup_details.h</filename> for explanations of "
"the fields returned."
msgstr ""
"В качестве аргумента ей передаётся образ страницы кучи, полученный в "
"результате вызова <function>get_raw_page</function>. Например: <screen>\n"
"test=# SELECT * FROM heap_page_items(get_raw_page('pg_class', 0));\n"
"</screen> Описание возвращаемых полей можно найти в <filename>src/include/"
"storage/itemid.h</filename> и <filename>src/include/access/htup_details.h</"
"filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:160(function)
msgid ""
"tuple_data_split(rel_oid, t_data bytea, t_infomask integer, t_infomask2 "
"integer, t_bits text [, do_detoast bool]) returns bytea[]"
msgstr ""
"tuple_data_split(rel_oid, t_data bytea, t_infomask integer, t_infomask2 "
"integer, t_bits text [, do_detoast bool]) returns bytea[]"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:161(indexterm)
msgid "<primary>tuple_data_split</primary>"
msgstr "<primary>tuple_data_split</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:166(para)
msgid ""
"<function>tuple_data_split</function> splits tuple data into attributes in "
"the same way as backend internals. <screen>\n"
"test=# SELECT tuple_data_split('pg_class'::regclass, t_data, t_infomask, "
"t_infomask2, t_bits) FROM heap_page_items(get_raw_page('pg_class', 0));\n"
"</screen> This function should be called with the same arguments as the "
"return attributes of <function>heap_page_items</function>."
msgstr ""
"Функция <function>tuple_data_split</function> разделяет данные кортежей на "
"атрибуты так, как это происходит внутри сервера. <screen>\n"
"test=# SELECT tuple_data_split('pg_class'::regclass, t_data, t_infomask, "
"t_infomask2, t_bits) FROM heap_page_items(get_raw_page('pg_class', 0));\n"
"</screen> В качестве аргументов этой функции должны передаваться атрибуты, "
"возвращаемые функцией <function>heap_page_items</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:175(para)
msgid ""
"If <parameter>do_detoast</parameter> is <literal>true</literal>, attribute "
"that will be detoasted as needed. Default value is <literal>false</literal>."
msgstr ""
"Если параметр <parameter>do_detoast</parameter> равен <literal>true</"
"literal>, полученные атрибуты будут распакованы по мере необходимости. Если "
"он не задан, подразумевается <literal>false</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:185(function)
msgid ""
"heap_page_item_attrs(rel_oid, t_data bytea, [, do_detoast bool]) returns "
"bytea[]"
msgstr ""
"heap_page_item_attrs(rel_oid, t_data bytea, [, do_detoast bool]) returns "
"bytea[]"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:186(indexterm)
msgid "<primary>heap_page_item_attrs</primary>"
msgstr "<primary>heap_page_item_attrs</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:191(para)
msgid ""
"<function>heap_page_item_attrs</function> is equivalent to "
"<function>heap_page_items</function> except that it returns tuple raw data "
"as an array of attributes that can optionally be detoasted by "
"<parameter>do_detoast</parameter> which is <literal>false</literal> by "
"default."
msgstr ""
"Функция <function>heap_page_item_attrs</function> похожа на "
"<function>heap_page_items</function>, но возвращает неструктурированное "
"содержимое кортежа в виде массива атрибутов, которые могут быть распакованы, "
"если установлен флаг <parameter>do_detoast</parameter> (по умолчанию они не "
"распаковываются)."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:198(para)
msgid ""
"A heap page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>\n"
"test=# SELECT * FROM heap_page_item_attrs(get_raw_page('pg_class', 0), "
"'pg_class'::regclass);\n"
"</screen>"
msgstr ""
"В качестве аргумента ей передаётся образ страницы кучи, полученный в "
"результате вызова <function>get_raw_page</function>. Например: <screen>\n"
"test=# SELECT * FROM heap_page_item_attrs(get_raw_page('pg_class', 0), "
"'pg_class'::regclass);\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:210(function)
msgid "fsm_page_contents(page bytea) returns text"
msgstr "fsm_page_contents(page bytea) returns text"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:211(indexterm)
msgid "<primary>fsm_page_contents</primary>"
msgstr "<primary>fsm_page_contents</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:217(para)
msgid ""
"<function>fsm_page_contents</function> shows the internal node structure of "
"a FSM page. The output is a multiline string, with one line per node in the "
"binary tree within the page. Only those nodes that are not zero are printed. "
"The so-called \"next\" pointer, which points to the next slot to be returned "
"from the page, is also printed."
msgstr ""
"Функция <function>fsm_page_contents</function> показывает внутреннюю "
"структуру узла на странице FSM. Она выдаёт текст из нескольких строк, по "
"одной строке на узел двоичного дерева на заданной странице. При этом "
"выдаются только ненулевые узлы. Также выводится так называемый указатель "
"&laquo;следующего слота&raquo;, который указывает на следующий слот, "
"получаемый с этой страницы."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:224(para)
msgid ""
"See <filename>src/backend/storage/freespace/README</filename> for more "
"information on the structure of an FSM page."
msgstr ""
"Подробнее структура страницы FSM описана в <filename>src/backend/storage/"
"freespace/README</filename>."

#. +> REL_10
#: pageinspect.xml:234(title)
msgid "B-tree Functions"
msgstr "Функции для индексов-B-деревьев"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:239(function)
msgid "bt_metap(relname text) returns record"
msgstr "bt_metap(relname text) returns record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:240(indexterm)
msgid "<primary>bt_metap</primary>"
msgstr "<primary>bt_metap</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:246(para)
msgid ""
"<function>bt_metap</function> returns information about a B-tree index's "
"metapage. For example: <screen>\n"
"test=# SELECT * FROM bt_metap('pg_cast_oid_index');\n"
"-[ RECORD 1 ]-----\n"
"magic     | 340322\n"
"version   | 2\n"
"root      | 1\n"
"level     | 0\n"
"fastroot  | 1\n"
"fastlevel | 0\n"
"</screen>"
msgstr ""
"Функция <function>bt_metap</function> возвращает информацию о метастранице "
"индекса-B-дерева. Например: <screen>\n"
"test=# SELECT * FROM bt_metap('pg_cast_oid_index');\n"
"-[ RECORD 1 ]-----\n"
"magic     | 340322\n"
"version   | 2\n"
"root      | 1\n"
"level     | 0\n"
"fastroot  | 1\n"
"fastlevel | 0\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:265(function)
msgid "bt_page_stats(relname text, blkno int) returns record"
msgstr "bt_page_stats(relname text, blkno int) returns record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:266(indexterm)
msgid "<primary>bt_page_stats</primary>"
msgstr "<primary>bt_page_stats</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:272(para)
msgid ""
"<function>bt_page_stats</function> returns summary information about single "
"pages of B-tree indexes. For example: <screen>\n"
"test=# SELECT * FROM bt_page_stats('pg_cast_oid_index', 1);\n"
"-[ RECORD 1 ]-+-----\n"
"blkno         | 1\n"
"type          | l\n"
"live_items    | 256\n"
"dead_items    | 0\n"
"avg_item_size | 12\n"
"page_size     | 8192\n"
"free_size     | 4056\n"
"btpo_prev     | 0\n"
"btpo_next     | 0\n"
"btpo          | 0\n"
"btpo_flags    | 3\n"
"</screen>"
msgstr ""
"<function>bt_page_stats</function> возвращает сводную информацию по "
"единичным страницам B-дерева. Например: <screen>\n"
"test=# SELECT * FROM bt_page_stats('pg_cast_oid_index', 1);\n"
"-[ RECORD 1 ]-+-----\n"
"blkno         | 1\n"
"type          | l\n"
"live_items    | 256\n"
"dead_items    | 0\n"
"avg_item_size | 12\n"
"page_size     | 8192\n"
"free_size     | 4056\n"
"btpo_prev     | 0\n"
"btpo_next     | 0\n"
"btpo          | 0\n"
"btpo_flags    | 3\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:296(function)
msgid "bt_page_items(relname text, blkno int) returns setof record"
msgstr "bt_page_items(relname text, blkno int) returns setof record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:297(indexterm) pageinspect.xml:341(indexterm)
msgid "<primary>bt_page_items</primary>"
msgstr "<primary>bt_page_items</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:303(para)
msgid ""
"<function>bt_page_items</function> returns detailed information about all of "
"the items on a B-tree index page. For example: <screen>\n"
"test=# SELECT * FROM bt_page_items('pg_cast_oid_index', 1);\n"
" itemoffset |  ctid   | itemlen | nulls | vars |    data\n"
"------------+---------+---------+-------+------+-------------\n"
"          1 | (0,1)   |      12 | f     | f    | 23 27 00 00\n"
"          2 | (0,2)   |      12 | f     | f    | 24 27 00 00\n"
"          3 | (0,3)   |      12 | f     | f    | 25 27 00 00\n"
"          4 | (0,4)   |      12 | f     | f    | 26 27 00 00\n"
"          5 | (0,5)   |      12 | f     | f    | 27 27 00 00\n"
"          6 | (0,6)   |      12 | f     | f    | 28 27 00 00\n"
"          7 | (0,7)   |      12 | f     | f    | 29 27 00 00\n"
"          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00\n"
"</screen> In a B-tree leaf page, <structfield>ctid</structfield> points to a "
"heap tuple. In an internal page, the block number part of <structfield>ctid</"
"structfield> points to another page in the index itself, while the offset "
"part (the second number) is ignored and is usually 1."
msgstr ""
"<function>bt_page_items</function> возвращает детализированную информацию "
"обо всех элементах на странице B-дерева. Например: <screen>\n"
"test=# SELECT * FROM bt_page_items('pg_cast_oid_index', 1);\n"
" itemoffset |  ctid   | itemlen | nulls | vars |    data\n"
"------------+---------+---------+-------+------+-------------\n"
"          1 | (0,1)   |      12 | f     | f    | 23 27 00 00\n"
"          2 | (0,2)   |      12 | f     | f    | 24 27 00 00\n"
"          3 | (0,3)   |      12 | f     | f    | 25 27 00 00\n"
"          4 | (0,4)   |      12 | f     | f    | 26 27 00 00\n"
"          5 | (0,5)   |      12 | f     | f    | 27 27 00 00\n"
"          6 | (0,6)   |      12 | f     | f    | 28 27 00 00\n"
"          7 | (0,7)   |      12 | f     | f    | 29 27 00 00\n"
"          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00\n"
"</screen> На странице уровня листьев B-дерева, <structfield>ctid</"
"structfield> указывает на кортеж в куче. На внутренней странице часть "
"<structfield>ctid</structfield>, содержащая номер блока, указывает на другую "
"страницу в самом индексе, а часть смещения (второе число) игнорируется и "
"обычно равняется 1."

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:324(para)
msgid ""
"Note that the first item on any non-rightmost page (any page with a non-zero "
"value in the <structfield>btpo_next</structfield> field) is the page's "
"<quote>high key</quote>, meaning its <structfield>data</structfield> serves "
"as an upper bound on all items appearing on the page, while its "
"<structfield>ctid</structfield> field is meaningless. Also, on non-leaf "
"pages, the first real data item (the first item that is not a high key) is a "
"<quote>minus infinity</quote> item, with no actual value in its "
"<structfield>data</structfield> field. Such an item does have a valid "
"downlink in its <structfield>ctid</structfield> field, however."
msgstr ""
"Заметьте, что первый элемент в любой, кроме самой правой, странице (то есть "
"в любой странице с ненулевым значением в поле <structfield>btpo_next</"
"structfield>) представляет собой <quote>верхний ключ</quote>, то есть его "
"поле <structfield>data</structfield> задаёт верхнюю границу всех элементов, "
"находящихся на странице, а поле <structfield>ctid</structfield> лишено "
"смысла. Кроме того, на внутренних страницах первый действительный элемент "
"данных (первый элемент после верхнего ключа) представляет элемент "
"<quote>минус бесконечность</quote>, без фактического значения в поле "
"<structfield>data</structfield>. Однако такой элемент содержит в своём поле "
"<structfield>ctid</structfield> корректную ссылку на данные."

#. +> REL_10
#: pageinspect.xml:340(function)
msgid "bt_page_items(page bytea) returns setof record"
msgstr "bt_page_items(page bytea) returns setof record"

#. +> REL_10
#: pageinspect.xml:347(para)
msgid ""
"It is also possible to pass a page to <function>bt_page_items</function> as "
"a <type>bytea</type> value. A page image obtained with "
"<function>get_raw_page</function> should be passed as argument. So the last "
"example could also be rewritten like this: <screen>\n"
"test=# SELECT * FROM bt_page_items(get_raw_page('pg_cast_oid_index', 1));\n"
" itemoffset |  ctid   | itemlen | nulls | vars |    data\n"
"------------+---------+---------+-------+------+-------------\n"
"          1 | (0,1)   |      12 | f     | f    | 23 27 00 00\n"
"          2 | (0,2)   |      12 | f     | f    | 24 27 00 00\n"
"          3 | (0,3)   |      12 | f     | f    | 25 27 00 00\n"
"          4 | (0,4)   |      12 | f     | f    | 26 27 00 00\n"
"          5 | (0,5)   |      12 | f     | f    | 27 27 00 00\n"
"          6 | (0,6)   |      12 | f     | f    | 28 27 00 00\n"
"          7 | (0,7)   |      12 | f     | f    | 29 27 00 00\n"
"          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00\n"
"</screen> All the other details are the same as explained in the previous "
"item."
msgstr ""
"Также можно передать функции <function>bt_page_items</function> страницу в "
"виде значения <type>bytea</type>. Образ страницы для передачи в аргументе "
"можно получить в результате вызова <function>get_raw_page</function>. Таким "
"образом, последний пример можно также переписать так: <screen>\n"
"test=# SELECT * FROM bt_page_items(get_raw_page('pg_cast_oid_index', 1));\n"
" itemoffset |  ctid   | itemlen | nulls | vars |    data\n"
"------------+---------+---------+-------+------+-------------\n"
"          1 | (0,1)   |      12 | f     | f    | 23 27 00 00\n"
"          2 | (0,2)   |      12 | f     | f    | 24 27 00 00\n"
"          3 | (0,3)   |      12 | f     | f    | 25 27 00 00\n"
"          4 | (0,4)   |      12 | f     | f    | 26 27 00 00\n"
"          5 | (0,5)   |      12 | f     | f    | 27 27 00 00\n"
"          6 | (0,6)   |      12 | f     | f    | 28 27 00 00\n"
"          7 | (0,7)   |      12 | f     | f    | 29 27 00 00\n"
"          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00\n"
"</screen> Все остальные детали те же, что и с предыдущим вариантом вызова."

#. +> REL_10
#: pageinspect.xml:373(title)
msgid "BRIN Functions"
msgstr "Функции для индексов BRIN"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:378(function)
msgid "brin_page_type(page bytea) returns text"
msgstr "brin_page_type(page bytea) returns text"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:379(indexterm)
msgid "<primary>brin_page_type</primary>"
msgstr "<primary>brin_page_type</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:385(para)
msgid ""
"<function>brin_page_type</function> returns the page type of the given "
"<acronym>BRIN</acronym> index page, or throws an error if the page is not a "
"valid <acronym>BRIN</acronym> page. For example: <screen>\n"
"test=# SELECT brin_page_type(get_raw_page('brinidx', 0));\n"
" brin_page_type \n"
"----------------\n"
" meta\n"
"</screen>"
msgstr ""
"Функция <function>brin_page_type</function> возвращает тип страницы для "
"заданной страницы индекса <acronym>BRIN</acronym> или выдаёт ошибку, если "
"эта страница не является корректной страницей индекса <acronym>BRIN</"
"acronym>. Например: <screen>\n"
"test=# SELECT brin_page_type(get_raw_page('brinidx', 0));\n"
" brin_page_type \n"
"----------------\n"
" meta\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:401(function)
msgid "brin_metapage_info(page bytea) returns record"
msgstr "brin_metapage_info(page bytea) returns record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:402(indexterm)
msgid "<primary>brin_metapage_info</primary>"
msgstr "<primary>brin_metapage_info</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:408(para)
msgid ""
"<function>brin_metapage_info</function> returns assorted information about a "
"<acronym>BRIN</acronym> index metapage. For example: <screen>\n"
"test=# SELECT * FROM brin_metapage_info(get_raw_page('brinidx', 0));\n"
"   magic    | version | pagesperrange | lastrevmappage \n"
"------------+---------+---------------+----------------\n"
" 0xA8109CFA |       1 |             4 |              2\n"
"</screen>"
msgstr ""
"Функция <function>brin_metapage_info</function> возвращает разнообразные "
"сведения о метастранице индекса <acronym>BRIN</acronym>. Например: <screen>\n"
"test=# SELECT * FROM brin_metapage_info(get_raw_page('brinidx', 0));\n"
"   magic    | version | pagesperrange | lastrevmappage \n"
"------------+---------+---------------+----------------\n"
" 0xA8109CFA |       1 |             4 |              2\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:423(function)
msgid "brin_revmap_data(page bytea) returns setof tid"
msgstr "brin_revmap_data(page bytea) returns setof tid"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:424(indexterm)
msgid "<primary>brin_revmap_data</primary>"
msgstr "<primary>brin_revmap_data</primary>"

#. +> REL_10
#: pageinspect.xml:430(para)
msgid ""
"<function>brin_revmap_data</function> returns the list of tuple identifiers "
"in a <acronym>BRIN</acronym> index range map page. For example: <screen>\n"
"test=# SELECT * FROM brin_revmap_data(get_raw_page('brinidx', 2)) LIMIT 5;\n"
"  pages  \n"
"---------\n"
" (6,137)\n"
" (6,138)\n"
" (6,139)\n"
" (6,140)\n"
" (6,141)\n"
"</screen>"
msgstr ""
"Функция <function>brin_revmap_data</function> выдаёт список идентификаторов "
"кортежей со страницы сопоставлений зон индекса <acronym>BRIN</acronym>. "
"Например: <screen>\n"
"test=# SELECT * FROM brin_revmap_data(get_raw_page('brinidx', 2)) LIMIT 5;\n"
"  pages  \n"
"---------\n"
" (6,137)\n"
" (6,138)\n"
" (6,139)\n"
" (6,140)\n"
" (6,141)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:450(function)
msgid "brin_page_items(page bytea, index oid) returns setof record"
msgstr "brin_page_items(page bytea, index oid) returns setof record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:451(indexterm)
msgid "<primary>brin_page_items</primary>"
msgstr "<primary>brin_page_items</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:457(para)
msgid ""
"<function>brin_page_items</function> returns the data stored in the "
"<acronym>BRIN</acronym> data page. For example: <screen>\n"
"test=# SELECT * FROM brin_page_items(get_raw_page('brinidx', 5),\n"
"                                     'brinidx')\n"
"       ORDER BY blknum, attnum LIMIT 6;\n"
" itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |    "
"value     \n"
"------------+--------+--------+----------+----------+-------------"
"+--------------\n"
"        137 |      0 |      1 | t        | f        | f           | \n"
"        137 |      0 |      2 | f        | f        | f           | {1 .. "
"88}\n"
"        138 |      4 |      1 | t        | f        | f           | \n"
"        138 |      4 |      2 | f        | f        | f           | {89 .. "
"176}\n"
"        139 |      8 |      1 | t        | f        | f           | \n"
"        139 |      8 |      2 | f        | f        | f           | {177 .. "
"264}\n"
"</screen> The returned columns correspond to the fields in the "
"<structname>BrinMemTuple</structname> and <structname>BrinValues</"
"structname> structs. See <filename>src/include/access/brin_tuple.h</"
"filename> for details."
msgstr ""
"Функция <function>brin_page_items</function> выдаёт содержимое, сохранённое "
"в странице данных <acronym>BRIN</acronym>. Например: <screen>\n"
"test=# SELECT * FROM brin_page_items(get_raw_page('brinidx', 5),\n"
"                                     'brinidx')\n"
"       ORDER BY blknum, attnum LIMIT 6;\n"
" itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |    "
"value     \n"
"------------+--------+--------+----------+----------+-------------"
"+--------------\n"
"        137 |      0 |      1 | t        | f        | f           | \n"
"        137 |      0 |      2 | f        | f        | f           | {1 .. "
"88}\n"
"        138 |      4 |      1 | t        | f        | f           | \n"
"        138 |      4 |      2 | f        | f        | f           | {89 .. "
"176}\n"
"        139 |      8 |      1 | t        | f        | f           | \n"
"        139 |      8 |      2 | f        | f        | f           | {177 .. "
"264}\n"
"</screen> Возвращаемые столбцы соответствуют полям в структурах "
"<structname>BrinMemTuple</structname> и <structname>BrinValues</structname>. "
"Подробнее они описаны в <filename>src/include/access/brin_tuple.h</filename>."

#. +> REL_10
#: pageinspect.xml:483(title)
msgid "GIN Functions"
msgstr "Функции для индексов GIN"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:488(function)
msgid "gin_metapage_info(page bytea) returns record"
msgstr "gin_metapage_info(page bytea) returns record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:489(indexterm)
msgid "<primary>gin_metapage_info</primary>"
msgstr "<primary>gin_metapage_info</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:495(para)
msgid ""
"<function>gin_metapage_info</function> returns information about a "
"<acronym>GIN</acronym> index metapage. For example: <screen>\n"
"test=# SELECT * FROM gin_metapage_info(get_raw_page('gin_index', 0));\n"
"-[ RECORD 1 ]----+-----------\n"
"pending_head     | 4294967295\n"
"pending_tail     | 4294967295\n"
"tail_free_size   | 0\n"
"n_pending_pages  | 0\n"
"n_pending_tuples | 0\n"
"n_total_pages    | 7\n"
"n_entry_pages    | 6\n"
"n_data_pages     | 0\n"
"n_entries        | 693\n"
"version          | 2\n"
"</screen>"
msgstr ""
"Функция <function>gin_metapage_info</function> выдаёт информацию о "
"метастранице индекса <acronym>GIN</acronym>. Например: <screen>\n"
"test=# SELECT * FROM gin_metapage_info(get_raw_page('gin_index', 0));\n"
"-[ RECORD 1 ]----+-----------\n"
"pending_head     | 4294967295\n"
"pending_tail     | 4294967295\n"
"tail_free_size   | 0\n"
"n_pending_pages  | 0\n"
"n_pending_tuples | 0\n"
"n_total_pages    | 7\n"
"n_entry_pages    | 6\n"
"n_data_pages     | 0\n"
"n_entries        | 693\n"
"version          | 2\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:518(function)
msgid "gin_page_opaque_info(page bytea) returns record"
msgstr "gin_page_opaque_info(page bytea) returns record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:519(indexterm)
msgid "<primary>gin_page_opaque_info</primary>"
msgstr "<primary>gin_page_opaque_info</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:525(para)
msgid ""
"<function>gin_page_opaque_info</function> returns information about a "
"<acronym>GIN</acronym> index opaque area, like the page type. For example: "
"<screen>\n"
"test=# SELECT * FROM gin_page_opaque_info(get_raw_page('gin_index', 2));\n"
" rightlink | maxoff |         flags\n"
"-----------+--------+------------------------\n"
"         5 |      0 | {data,leaf,compressed}\n"
"(1 row)\n"
"</screen>"
msgstr ""
"Функция <function>gin_page_opaque_info</function> выдаёт информацию из "
"непрозрачной области индекса <acronym>GIN</acronym>, например, тип страницы. "
"Например: <screen>\n"
"test=# SELECT * FROM gin_page_opaque_info(get_raw_page('gin_index', 2));\n"
" rightlink | maxoff |         flags\n"
"-----------+--------+------------------------\n"
"         5 |      0 | {data,leaf,compressed}\n"
"(1 row)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:542(function)
msgid "gin_leafpage_items(page bytea) returns setof record"
msgstr "gin_leafpage_items(page bytea) returns setof record"

#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:543(indexterm)
msgid "<primary>gin_leafpage_items</primary>"
msgstr "<primary>gin_leafpage_items</primary>"

#. +> REL_10
#: pageinspect.xml:549(para)
msgid ""
"<function>gin_leafpage_items</function> returns information about the data "
"stored in a <acronym>GIN</acronym> leaf page. For example: <screen>\n"
"test=# SELECT first_tid, nbytes, tids[0:5] AS some_tids\n"
"        FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));\n"
" first_tid | nbytes |                        some_tids\n"
"-----------+--------"
"+----------------------------------------------------------\n"
" (8,41)    |    244 | {\"(8,41)\",\"(8,43)\",\"(8,44)\",\"(8,45)\","
"\"(8,46)\"}\n"
" (10,45)   |    248 | {\"(10,45)\",\"(10,46)\",\"(10,47)\",\"(10,48)\","
"\"(10,49)\"}\n"
" (12,52)   |    248 | {\"(12,52)\",\"(12,53)\",\"(12,54)\",\"(12,55)\","
"\"(12,56)\"}\n"
" (14,59)   |    320 | {\"(14,59)\",\"(14,60)\",\"(14,61)\",\"(14,62)\","
"\"(14,63)\"}\n"
" (167,16)  |    376 | {\"(167,16)\",\"(167,17)\",\"(167,18)\",\"(167,19)\","
"\"(167,20)\"}\n"
" (170,30)  |    376 | {\"(170,30)\",\"(170,31)\",\"(170,32)\",\"(170,33)\","
"\"(170,34)\"}\n"
" (173,44)  |    197 | {\"(173,44)\",\"(173,45)\",\"(173,46)\",\"(173,47)\","
"\"(173,48)\"}\n"
"(7 rows)\n"
"</screen>"
msgstr ""
"Функция <function>gin_leafpage_items</function> выдаёт информацию о данных, "
"хранящихся в странице индекса <acronym>GIN</acronym> на уровне листьев. "
"Например: <screen>\n"
"test=# SELECT first_tid, nbytes, tids[0:5] AS some_tids\n"
"        FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));\n"
" first_tid | nbytes |                        some_tids\n"
"-----------+--------"
"+----------------------------------------------------------\n"
" (8,41)    |    244 | {\"(8,41)\",\"(8,43)\",\"(8,44)\",\"(8,45)\","
"\"(8,46)\"}\n"
" (10,45)   |    248 | {\"(10,45)\",\"(10,46)\",\"(10,47)\",\"(10,48)\","
"\"(10,49)\"}\n"
" (12,52)   |    248 | {\"(12,52)\",\"(12,53)\",\"(12,54)\",\"(12,55)\","
"\"(12,56)\"}\n"
" (14,59)   |    320 | {\"(14,59)\",\"(14,60)\",\"(14,61)\",\"(14,62)\","
"\"(14,63)\"}\n"
" (167,16)  |    376 | {\"(167,16)\",\"(167,17)\",\"(167,18)\",\"(167,19)\","
"\"(167,20)\"}\n"
" (170,30)  |    376 | {\"(170,30)\",\"(170,31)\",\"(170,32)\",\"(170,33)\","
"\"(170,34)\"}\n"
" (173,44)  |    197 | {\"(173,44)\",\"(173,45)\",\"(173,46)\",\"(173,47)\","
"\"(173,48)\"}\n"
"(7 rows)\n"
"</screen>"

#. +> REL_10
#: pageinspect.xml:573(title)
msgid "Hash Functions"
msgstr "Функции для хеш-индексов"

#. +> REL_10
#: pageinspect.xml:578(function)
msgid "hash_page_type(page bytea) returns text"
msgstr "hash_page_type(page bytea) returns text"

#. +> REL_10
#: pageinspect.xml:579(indexterm)
msgid "<primary>hash_page_type</primary>"
msgstr "<primary>hash_page_type</primary>"

#. +> REL_10
#: pageinspect.xml:585(para)
msgid ""
"<function>hash_page_type</function> returns page type of the given "
"<acronym>HASH</acronym> index page. For example: <screen>\n"
"test=# SELECT hash_page_type(get_raw_page('con_hash_index', 0));\n"
" hash_page_type \n"
"----------------\n"
" metapage\n"
"</screen>"
msgstr ""
"Функция <function>hash_page_type</function> возвращает тип страницы для "
"заданной страницы хеш-индекса. Например: <screen>\n"
"test=# SELECT hash_page_type(get_raw_page('con_hash_index', 0));\n"
" hash_page_type \n"
"----------------\n"
" metapage\n"
"</screen>"

#. +> REL_10
#: pageinspect.xml:600(function)
msgid "hash_page_stats(page bytea) returns setof record"
msgstr "hash_page_stats(page bytea) returns setof record"

#. +> REL_10
#: pageinspect.xml:601(indexterm)
msgid "<primary>hash_page_stats</primary>"
msgstr "<primary>hash_page_stats</primary>"

#. +> REL_10
#: pageinspect.xml:607(para)
msgid ""
"<function>hash_page_stats</function> returns information about a bucket or "
"overflow page of a <acronym>HASH</acronym> index. For example: <screen>\n"
"test=# SELECT * FROM hash_page_stats(get_raw_page('con_hash_index', 1));\n"
"-[ RECORD 1 ]---+-----------\n"
"live_items      | 407\n"
"dead_items      | 0\n"
"page_size       | 8192\n"
"free_size       | 8\n"
"hasho_prevblkno | 4096\n"
"hasho_nextblkno | 8474\n"
"hasho_bucket    | 0\n"
"hasho_flag      | 66\n"
"hasho_page_id   | 65408\n"
"</screen>"
msgstr ""
"Функция <function>hash_page_stats</function> возвращает информацию о "
"странице группы или переполнения хеш-индекса. Например: <screen>\n"
"test=# SELECT * FROM hash_page_stats(get_raw_page('con_hash_index', 1));\n"
"-[ RECORD 1 ]---+-----------\n"
"live_items      | 407\n"
"dead_items      | 0\n"
"page_size       | 8192\n"
"free_size       | 8\n"
"hasho_prevblkno | 4096\n"
"hasho_nextblkno | 8474\n"
"hasho_bucket    | 0\n"
"hasho_flag      | 66\n"
"hasho_page_id   | 65408\n"
"</screen>"

#. +> REL_10
#: pageinspect.xml:630(function)
msgid "hash_page_items(page bytea) returns setof record"
msgstr "hash_page_items(page bytea) returns setof record"

#. +> REL_10
#: pageinspect.xml:631(indexterm)
msgid "<primary>hash_page_items</primary>"
msgstr "<primary>hash_page_items</primary>"

#. +> REL_10
#: pageinspect.xml:637(para)
msgid ""
"<function>hash_page_items</function> returns information about the data "
"stored in a bucket or overflow page of a <acronym>HASH</acronym> index page. "
"For example: <screen>\n"
"test=# SELECT * FROM hash_page_items(get_raw_page('con_hash_index', 1)) "
"LIMIT 5;\n"
" itemoffset |   ctid    |    data    \n"
"------------+-----------+------------\n"
"          1 | (899,77)  | 1053474816\n"
"          2 | (897,29)  | 1053474816\n"
"          3 | (894,207) | 1053474816\n"
"          4 | (892,159) | 1053474816\n"
"          5 | (890,111) | 1053474816\n"
"</screen>"
msgstr ""
"Функция <function>hash_page_items</function> возвращает информацию о данных, "
"хранящихся на странице группы или переполнения хеш-индекса. Например: "
"<screen>\n"
"test=# SELECT * FROM hash_page_items(get_raw_page('con_hash_index', 1)) "
"LIMIT 5;\n"
" itemoffset |   ctid    |    data    \n"
"------------+-----------+------------\n"
"          1 | (899,77)  | 1053474816\n"
"          2 | (897,29)  | 1053474816\n"
"          3 | (894,207) | 1053474816\n"
"          4 | (892,159) | 1053474816\n"
"          5 | (890,111) | 1053474816\n"
"</screen>"

#. +> REL_10
#: pageinspect.xml:657(function)
msgid "hash_bitmap_info(index oid, blkno int) returns record"
msgstr "hash_bitmap_info(index oid, blkno int) returns record"

#. +> REL_10
#: pageinspect.xml:658(indexterm)
msgid "<primary>hash_bitmap_info</primary>"
msgstr "<primary>hash_bitmap_info</primary>"

#. +> REL_10
#: pageinspect.xml:664(para)
msgid ""
"<function>hash_bitmap_info</function> shows the status of a bit in the "
"bitmap page for a particular overflow page of <acronym>HASH</acronym> index. "
"For example: <screen>\n"
"test=# SELECT * FROM hash_bitmap_info('con_hash_index', 2052);\n"
" bitmapblkno | bitmapbit | bitstatus \n"
"-------------+-----------+-----------\n"
"          65 |         3 | t\n"
"</screen>"
msgstr ""
"Функция <function>hash_bitmap_info</function> показывает состояние бита в "
"странице битовой карты для определённой страницы переполнения хеш-индекса. "
"Например: <screen>\n"
"test=# SELECT * FROM hash_bitmap_info('con_hash_index', 2052);\n"
" bitmapblkno | bitmapbit | bitstatus \n"
"-------------+-----------+-----------\n"
"          65 |         3 | t\n"
"</screen>"

#. +> REL_10
#: pageinspect.xml:680(function)
msgid "hash_metapage_info(page bytea) returns record"
msgstr "hash_metapage_info(page bytea) returns record"

#. +> REL_10
#: pageinspect.xml:681(indexterm)
msgid "<primary>hash_metapage_info</primary>"
msgstr "<primary>hash_metapage_info</primary>"

#. +> REL_10
#: pageinspect.xml:687(para)
msgid ""
"<function>hash_metapage_info</function> returns information stored in meta "
"page of a <acronym>HASH</acronym> index. For example: <screen>\n"
"test=# SELECT magic, version, ntuples, ffactor, bsize, bmsize, bmshift,\n"
"test-#     maxbucket, highmask, lowmask, ovflpoint, firstfree, nmaps, "
"procid,\n"
"test-#     regexp_replace(spares::text, '(,0)*}', '}') as spares,\n"
"test-#     regexp_replace(mapp::text, '(,0)*}', '}') as mapp\n"
"test-# FROM hash_metapage_info(get_raw_page('con_hash_index', 0));\n"
"-[ RECORD "
"1 ]-------------------------------------------------------------------------------\n"
"spares    | "
"{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}\n"
"magic     | 105121344\n"
"version   | 3\n"
"ntuples   | 500500\n"
"ffactor   | 40\n"
"bsize     | 8152\n"
"bmsize    | 4096\n"
"bmshift   | 15\n"
"maxbucket | 12512\n"
"highmask  | 16383\n"
"lowmask   | 8191\n"
"ovflpoint | 28\n"
"firstfree | 1204\n"
"nmaps     | 1\n"
"procid    | 450\n"
"spares    | "
"{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}\n"
"mapp      | {65}\n"
"</screen>"
msgstr ""
"<function>hash_metapage_info</function> возвращает информацию, хранящуюся в "
"метастранице хеш-индекса. Например: <screen>\n"
"test=# SELECT magic, version, ntuples, ffactor, bsize, bmsize, bmshift,\n"
"test-#     maxbucket, highmask, lowmask, ovflpoint, firstfree, nmaps, "
"procid,\n"
"test-#     regexp_replace(spares::text, '(,0)*}', '}') as spares,\n"
"test-#     regexp_replace(mapp::text, '(,0)*}', '}') as mapp\n"
"test-# FROM hash_metapage_info(get_raw_page('con_hash_index', 0));\n"
"-[ RECORD "
"1 ]-------------------------------------------------------------------------------\n"
"spares    | "
"{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}\n"
"magic     | 105121344\n"
"version   | 3\n"
"ntuples   | 500500\n"
"ffactor   | 40\n"
"bsize     | 8152\n"
"bmsize    | 4096\n"
"bmshift   | 15\n"
"maxbucket | 12512\n"
"highmask  | 16383\n"
"lowmask   | 8191\n"
"ovflpoint | 28\n"
"firstfree | 1204\n"
"nmaps     | 1\n"
"procid    | 450\n"
"spares    | "
"{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}\n"
"mapp      | {65}\n"
"</screen>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: pageinspect.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: pageinspect.xml:320(para)
msgid ""
"<function>brin_revmap_data</function> returns the list of tuple identifiers "
"in a <acronym>BRIN</acronym> index range map page. For example: <screen>\n"
"test=# SELECT * FROM brin_revmap_data(get_raw_page('brinidx', 2)) limit 5;\n"
"  pages  \n"
"---------\n"
" (6,137)\n"
" (6,138)\n"
" (6,139)\n"
" (6,140)\n"
" (6,141)\n"
"</screen>"
msgstr ""
"Функция <function>brin_revmap_data</function> выдаёт список идентификаторов "
"кортежей со страницы сопоставлений зон индекса <acronym>BRIN</acronym>. "
"Например: <screen>\n"
"test=# SELECT * FROM brin_revmap_data(get_raw_page('brinidx', 2)) limit 5;\n"
"  pages  \n"
"---------\n"
" (6,137)\n"
" (6,138)\n"
" (6,139)\n"
" (6,140)\n"
" (6,141)\n"
"</screen>"

#. +> REL9_6_3 REL9_6
#: pageinspect.xml:433(para)
msgid ""
"<function>gin_leafpage_items</function> returns information about the data "
"stored in a <acronym>GIN</acronym> leaf page. For example: <screen>\n"
"test=# SELECT first_tid, nbytes, tids[0:5] as some_tids\n"
"        FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));\n"
" first_tid | nbytes |                        some_tids\n"
"-----------+--------"
"+----------------------------------------------------------\n"
" (8,41)    |    244 | {\"(8,41)\",\"(8,43)\",\"(8,44)\",\"(8,45)\","
"\"(8,46)\"}\n"
" (10,45)   |    248 | {\"(10,45)\",\"(10,46)\",\"(10,47)\",\"(10,48)\","
"\"(10,49)\"}\n"
" (12,52)   |    248 | {\"(12,52)\",\"(12,53)\",\"(12,54)\",\"(12,55)\","
"\"(12,56)\"}\n"
" (14,59)   |    320 | {\"(14,59)\",\"(14,60)\",\"(14,61)\",\"(14,62)\","
"\"(14,63)\"}\n"
" (167,16)  |    376 | {\"(167,16)\",\"(167,17)\",\"(167,18)\",\"(167,19)\","
"\"(167,20)\"}\n"
" (170,30)  |    376 | {\"(170,30)\",\"(170,31)\",\"(170,32)\",\"(170,33)\","
"\"(170,34)\"}\n"
" (173,44)  |    197 | {\"(173,44)\",\"(173,45)\",\"(173,46)\",\"(173,47)\","
"\"(173,48)\"}\n"
"(7 rows)\n"
"</screen>"
msgstr ""
"Функция <function>gin_leafpage_items</function> выдаёт информацию о данных, "
"хранящихся в странице индекса <acronym>GIN</acronym> на уровне листьев. "
"Например: <screen>\n"
"test=# SELECT first_tid, nbytes, tids[0:5] as some_tids\n"
"        FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));\n"
" first_tid | nbytes |                        some_tids\n"
"-----------+--------"
"+----------------------------------------------------------\n"
" (8,41)    |    244 | {\"(8,41)\",\"(8,43)\",\"(8,44)\",\"(8,45)\","
"\"(8,46)\"}\n"
" (10,45)   |    248 | {\"(10,45)\",\"(10,46)\",\"(10,47)\",\"(10,48)\","
"\"(10,49)\"}\n"
" (12,52)   |    248 | {\"(12,52)\",\"(12,53)\",\"(12,54)\",\"(12,55)\","
"\"(12,56)\"}\n"
" (14,59)   |    320 | {\"(14,59)\",\"(14,60)\",\"(14,61)\",\"(14,62)\","
"\"(14,63)\"}\n"
" (167,16)  |    376 | {\"(167,16)\",\"(167,17)\",\"(167,18)\",\"(167,19)\","
"\"(167,20)\"}\n"
" (170,30)  |    376 | {\"(170,30)\",\"(170,31)\",\"(170,32)\",\"(170,33)\","
"\"(170,34)\"}\n"
" (173,44)  |    197 | {\"(173,44)\",\"(173,45)\",\"(173,46)\",\"(173,47)\","
"\"(173,48)\"}\n"
"(7 rows)\n"
"</screen>"

#~ msgid ""
#~ "<function>hash_metapage_info</function> returns information stored in "
#~ "meta page of a <acronym>HASH</acronym> index. For example: <screen>\n"
#~ "test=# SELECT * FROM hash_metapage_info(get_raw_page('con_hash_index', "
#~ "0));\n"
#~ "-[ RECORD "
#~ "1 ]-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
#~ "magic     | 105121344\n"
#~ "version   | 3\n"
#~ "ntuples   | 500500\n"
#~ "ffactor   | 40\n"
#~ "bsize     | 8152\n"
#~ "bmsize    | 4096\n"
#~ "bmshift   | 15\n"
#~ "maxbucket | 12512\n"
#~ "highmask  | 16383\n"
#~ "lowmask   | 8191\n"
#~ "ovflpoint | 28\n"
#~ "firstfree | 1204\n"
#~ "nmaps     | 1\n"
#~ "procid    | 450\n"
#~ "spares    | "
#~ "{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}\n"
#~ "mapp      | "
#~ "{65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}\n"
#~ "</screen>"
#~ msgstr ""
#~ "Функция <function>hash_metapage_info</function> возвращает информацию, "
#~ "хранящуюся в метастранице хеш-индекса. Например: <screen>\n"
#~ "test=# SELECT * FROM hash_metapage_info(get_raw_page('con_hash_index', "
#~ "0));\n"
#~ "-[ RECORD "
#~ "1 ]-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n"
#~ "magic     | 105121344\n"
#~ "version   | 3\n"
#~ "ntuples   | 500500\n"
#~ "ffactor   | 40\n"
#~ "bsize     | 8152\n"
#~ "bmsize    | 4096\n"
#~ "bmshift   | 15\n"
#~ "maxbucket | 12512\n"
#~ "highmask  | 16383\n"
#~ "lowmask   | 8191\n"
#~ "ovflpoint | 28\n"
#~ "firstfree | 1204\n"
#~ "nmaps     | 1\n"
#~ "procid    | 450\n"
#~ "spares    | "
#~ "{0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}\n"
#~ "mapp      | "
#~ "{65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}\n"
#~ "</screen>"
