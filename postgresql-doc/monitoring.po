# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-10-02 10:32+0300\n"
"PO-Revision-Date: 2017-10-03 12:15+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:5(title)
msgid "Monitoring Database Activity"
msgstr "Мониторинг работы СУБД"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:7(indexterm)
msgid "<primary>monitoring</primary> <secondary>database activity</secondary>"
msgstr ""
"<primary>мониторинг</primary> <secondary>активность базы данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:12(indexterm)
msgid "<primary>database activity</primary> <secondary>monitoring</secondary>"
msgstr ""
"<primary>активность базы данных</primary> <secondary>мониторинг</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:17(para)
msgid ""
"A database administrator frequently wonders, <quote>What is the system doing "
"right now?</quote> This chapter discusses how to find that out."
msgstr ""
"Администратор базы данных часто задумывается &mdash; <quote>чем в данный "
"момент занята система?</quote> В этой главе рассказывается о том, как это "
"выяснить."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:23(para)
msgid ""
"Several tools are available for monitoring database activity and analyzing "
"performance. Most of this chapter is devoted to describing "
"<productname>PostgreSQL</productname>'s statistics collector, but one should "
"not neglect regular Unix monitoring programs such as <command>ps</command>, "
"<command>top</command>, <command>iostat</command>, and <command>vmstat</"
"command>. Also, once one has identified a poorly-performing query, further "
"investigation might be needed using <productname>PostgreSQL</productname>'s "
"<xref linkend=\"sql-explain\"/> command. <xref linkend=\"using-explain\"/> "
"discusses <command>EXPLAIN</command> and other methods for understanding the "
"behavior of an individual query."
msgstr ""
"Для мониторинга работы СУБД и анализа её производительности существуют "
"различные инструменты. Большая часть этой главы посвящена описанию работы "
"сборщика статистики <productname>PostgreSQL</productname>, однако не следует "
"пренебрегать и обычными командами мониторинга Unix, такими как <command>ps</"
"command>, <command>top</command>, <command>iostat</command>, и "
"<command>vmstat</command>. Кроме того, после обнаружения запроса с низкой "
"производительностью может потребоваться дополнительное исследование с "
"использованием <productname>PostgreSQL</productname> команды <xref linkend="
"\"sql-explain\"/>. В <xref remap=\"6\" linkend=\"using-explain\"/> "
"рассматриваются <command>EXPLAIN</command> и другие методы для изучения "
"поведения отдельного запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:38(title)
msgid "Standard Unix Tools"
msgstr "Стандартные инструменты Unix"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:40(indexterm)
msgid "<primary>ps</primary> <secondary>to monitor activity</secondary>"
msgstr "<primary>ps</primary> <secondary>мониторинг активности</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:45(para)
msgid ""
"On most Unix platforms, <productname>PostgreSQL</productname> modifies its "
"command title as reported by <command>ps</command>, so that individual "
"server processes can readily be identified. A sample display is <screen>\n"
"$ ps auxww | grep ^postgres\n"
"postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -"
"i\n"
"postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: "
"writer process\n"
"postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: "
"checkpointer process\n"
"postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: "
"wal writer process\n"
"postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: "
"autovacuum launcher process\n"
"postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: "
"stats collector process\n"
"postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: "
"joe runbug 127.0.0.1 idle\n"
"postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: "
"tgl regression [local] SELECT waiting\n"
"postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: "
"tgl regression [local] idle in transaction\n"
"</screen> (The appropriate invocation of <command>ps</command> varies across "
"different platforms, as do the details of what is shown. This example is "
"from a recent Linux system.) The first process listed here is the master "
"server process. The command arguments shown for it are the same ones used "
"when it was launched. The next five processes are background worker "
"processes automatically launched by the master process. (The <quote>stats "
"collector</quote> process will not be present if you have set the system not "
"to start the statistics collector; likewise the <quote>autovacuum launcher</"
"quote> process can be disabled.) Each of the remaining processes is a server "
"process handling one client connection. Each such process sets its command "
"line display in the form <screen>\n"
"postgres: <replaceable>user</replaceable> <replaceable>database</"
"replaceable> <replaceable>host</replaceable> <replaceable>activity</"
"replaceable>\n"
"</screen> The user, database, and (client) host items remain the same for "
"the life of the client connection, but the activity indicator changes. The "
"activity can be <literal>idle</literal> (i.e., waiting for a client "
"command), <literal>idle in transaction</literal> (waiting for client inside "
"a <command>BEGIN</command> block), or a command type name such as "
"<literal>SELECT</literal>. Also, <literal>waiting</literal> is appended if "
"the server process is presently waiting on a lock held by another session. "
"In the above example we can infer that process 15606 is waiting for process "
"15610 to complete its transaction and thereby release some lock. (Process "
"15610 must be the blocker, because there is no other active session. In more "
"complicated cases it would be necessary to look into the <link linkend="
"\"view-pg-locks\"><structname>pg_locks</structname></link> system view to "
"determine who is blocking whom.)"
msgstr ""
"В большинстве Unix платформ <productname>PostgreSQL</productname> "
"модифицирует заголовок команды, который выводится на экран при выполнении "
"команды <command>ps</command> так, что серверные процессы можно легко "
"различить. Вот пример вывода этой команды: <screen>\n"
"$ ps auxww | grep ^postgres\n"
"postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -"
"i\n"
"postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: "
"writer process\n"
"postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: "
"checkpointer process\n"
"postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: "
"wal writer process\n"
"postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: "
"autovacuum launcher process\n"
"postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: "
"stats collector process\n"
"postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: "
"joe runbug 127.0.0.1 idle\n"
"postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: "
"tgl regression [local] SELECT waiting\n"
"postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: "
"tgl regression [local] idle in transaction\n"
"</screen> (Формат вызова <command>ps</command>, а так же детали отображаемой "
"информации зависят от платформы. Это пример для одной из последних Linux "
"систем.) Первым здесь перечислен главный процесс сервера. Для этого процесса "
"отображены аргументы команды, которые использовались при его запуске. "
"Следующие пять процессов &mdash; это фоновые рабочие процессы, которые были "
"автоматически запущены процессом сервера. (Процесса <quote>stats collector</"
"quote> в этом списке не будет, если запуск сборщика статистики отключён в "
"системе; аналогично может быть отключён и процесс <quote>autovacuum "
"launcher</quote> &mdash; фоновый процесс автоочистки.) Во всех остальных "
"строках перечислены серверные процессы, каждый из которых обрабатывает одно "
"клиентское подключение. Командная строка каждого такого процесса имеет "
"следующий формат: <screen>\n"
"postgres: <replaceable>user</replaceable> <replaceable>database</"
"replaceable> <replaceable>host</replaceable> <replaceable>activity</"
"replaceable>\n"
"</screen> Пользователь, СУБД и компьютер (клиента) остаются неизменными на "
"протяжении всего клиентского подключения, а индикатор деятельности меняется. "
"Возможные виды деятельности: <literal>idle</literal> (т. е. ожидание команды "
"клиента), <literal>idle in transaction</literal> (ожидание клиента внутри "
"блока <command>BEGIN</command>) или название типа команды, например, "
"<literal>SELECT</literal>. Кроме того, если в настоящий момент серверный "
"процесс ожидает высвобождения блокировки, которую держит другая сессия, то к "
"виду деятельности добавляется <literal>waiting</literal>. В приведённом выше "
"примере мы видим, что процесс 15606 ожидает, когда процесс 15610 завершит "
"свою транзакцию и, следовательно, освободит какую-то блокировку. (Процесс "
"15610 является блокирующим, поскольку никаких других активных сессий нет. В "
"более сложных случаях может потребоваться обращение к системному "
"представлению <link linkend=\"view-pg-locks\"><structname>pg_locks</"
"structname></link>, для того чтобы определить, кто кого блокирует.)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:95(para)
msgid ""
"If <xref linkend=\"guc-cluster-name\"/> has been configured the cluster name "
"will also be shown in <command>ps</command> output: <screen>\n"
"$ psql -c 'SHOW cluster_name'\n"
" cluster_name\n"
"--------------\n"
" server1\n"
"(1 row)\n"
"\n"
"$ ps aux|grep server1\n"
"postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: "
"server1: writer process\n"
"...\n"
"</screen>"
msgstr ""
"Если установлено значение <xref linkend=\"guc-cluster-name\"/>, имя кластера "
"также будет показываться в выводе команды <command>ps</command>: <screen>\n"
"$ psql -c 'SHOW cluster_name'\n"
" cluster_name\n"
"--------------\n"
" server1\n"
"(1 row)\n"
"\n"
"$ ps aux|grep server1\n"
"postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: "
"server1: writer process\n"
"...\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:111(para)
msgid ""
"If you have turned off <xref linkend=\"guc-update-process-title\"/> then the "
"activity indicator is not updated; the process title is set only once when a "
"new process is launched. On some platforms this saves a measurable amount of "
"per-command overhead; on others it's insignificant."
msgstr ""
"Если параметр <xref linkend=\"guc-update-process-title\"/> был отключён, то "
"индикатор деятельности не обновляется; название процесса устанавливается "
"только один раз при запуске нового процесса. На некоторых платформах это "
"позволяет значительно сократить накладные расходы при выполнении команды; на "
"других платформах этот выигрыш может быть незначителен."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:119(para)
msgid ""
"<productname>Solaris</productname> requires special handling. You must use "
"<command>/usr/ucb/ps</command>, rather than <command>/bin/ps</command>. You "
"also must use two <option>w</option> flags, not just one. In addition, your "
"original invocation of the <command>postgres</command> command must have a "
"shorter <command>ps</command> status display than that provided by each "
"server process. If you fail to do all three things, the <command>ps</"
"command> output for each server process will be the original "
"<command>postgres</command> command line."
msgstr ""
"В <productname>Solaris</productname> требуется особый подход. Следует "
"использовать <command>/usr/ucb/ps</command> вместо <command>/bin/ps</"
"command>. Также следует использовать два флага <option>w</option>, а не "
"один. Кроме того, при выводе статусов команд с помощью <command>ps</command> "
"статус для исходной команды <command>postgres</command> должен отображаться "
"в сокращённом формате для каждого серверного процесса. Если вы не сделаете "
"все три вещи, то вывод <command>ps</command> для каждого серверного процесса "
"будет исходной командной строкой <command>postgres</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:134(title)
msgid "The Statistics Collector"
msgstr "Сборщик статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:136(indexterm)
msgid "<primary>statistics</primary>"
msgstr "<primary>статистика</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:140(para)
msgid ""
"<productname>PostgreSQL</productname>'s <firstterm>statistics collector</"
"firstterm> is a subsystem that supports collection and reporting of "
"information about server activity. Presently, the collector can count "
"accesses to tables and indexes in both disk-block and individual-row terms. "
"It also tracks the total number of rows in each table, and information about "
"vacuum and analyze actions for each table. It can also count calls to user-"
"defined functions and the total time spent in each one."
msgstr ""
"<firstterm>Сборщик статистики</firstterm> в <productname>PostgreSQL</"
"productname> представляет собой подсистему, которая собирает и отображает "
"информацию о работе сервера. В настоящее время сборщик может подсчитывать "
"количество обращений к таблицам и индексам &mdash; в виде количества "
"прочитанных блоков или строк с диска. Кроме того, он отслеживает общее число "
"строк в каждой таблице, информацию о выполнении очистки и сбора статистики "
"для каждой таблицы. Он также может подсчитывать вызовы пользовательских "
"функций и общее время, затраченное на выполнение каждой из них."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:150(para)
msgid ""
"<productname>PostgreSQL</productname> also supports reporting dynamic "
"information about exactly what is going on in the system right now, such as "
"the exact command currently being executed by other server processes, and "
"which other connections exist in the system. This facility is independent of "
"the collector process."
msgstr ""
"Кроме того, <productname>PostgreSQL</productname> может предоставить "
"динамическую информацию о том, что происходит в системе прямо сейчас, в "
"частности, сообщить, какие именно команды выполняются другими серверными "
"процессами и какие другие соединения существуют в системе. Эта возможность "
"не зависит от процесса сборщика."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:159(title)
msgid "Statistics Collection Configuration"
msgstr "Конфигурация системы сбора статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:161(para)
msgid ""
"Since collection of statistics adds some overhead to query execution, the "
"system can be configured to collect or not collect information. This is "
"controlled by configuration parameters that are normally set in "
"<filename>postgresql.conf</filename>. (See <xref linkend=\"runtime-config\"/"
"> for details about setting configuration parameters.)"
msgstr ""
"Поскольку сбор статистики несколько увеличивает накладные расходы при "
"выполнении запроса, есть возможность настроить СУБД так, чтобы выполнять или "
"не выполнять сбор статистической информации. Это контролируется "
"конфигурационными параметрами, которые обычно устанавливаются в файле "
"<filename>postgresql.conf</filename>. (Подробно установка конфигурационных "
"параметров описывается в <xref remap=\"6\" linkend=\"runtime-config\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:169(para)
msgid ""
"The parameter <xref linkend=\"guc-track-activities\"/> enables monitoring of "
"the current command being executed by any server process."
msgstr ""
"Параметр <xref linkend=\"guc-track-activities\"/> включает мониторинг "
"текущих команд, выполняемой любым серверным процессом."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:174(para)
msgid ""
"The parameter <xref linkend=\"guc-track-counts\"/> controls whether "
"statistics are collected about table and index accesses."
msgstr ""
"Параметр <xref linkend=\"guc-track-counts\"/> определяет необходимость сбора "
"статистики по обращениям к таблицам и индексам."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:179(para)
msgid ""
"The parameter <xref linkend=\"guc-track-functions\"/> enables tracking of "
"usage of user-defined functions."
msgstr ""
"Параметр <xref linkend=\"guc-track-functions\"/> включает отслеживание "
"использования пользовательских функций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:184(para)
msgid ""
"The parameter <xref linkend=\"guc-track-io-timing\"/> enables monitoring of "
"block read and write times."
msgstr ""
"Параметр <xref linkend=\"guc-track-io-timing\"/> включает мониторинг времени "
"чтения и записи блоков."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:189(para)
msgid ""
"Normally these parameters are set in <filename>postgresql.conf</filename> so "
"that they apply to all server processes, but it is possible to turn them on "
"or off in individual sessions using the <xref linkend=\"sql-set\"/> command. "
"(To prevent ordinary users from hiding their activity from the "
"administrator, only superusers are allowed to change these parameters with "
"<command>SET</command>.)"
msgstr ""
"Обычно эти параметры устанавливаются в <filename>postgresql.conf</filename>, "
"поэтому они применяются ко всем серверным процессам, однако, используя "
"команду <xref linkend=\"sql-set\"/>, их можно включать и выключать в "
"отдельных сессиях. (Для того чтобы обычные пользователи не скрывали свою "
"работу от администратора СУБД, изменять эти параметры с помощью команды "
"<command>SET</command> могут только суперпользователи.)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:199(para)
msgid ""
"The statistics collector transmits the collected information to other "
"<productname>PostgreSQL</productname> processes through temporary files. "
"These files are stored in the directory named by the <xref linkend=\"guc-"
"stats-temp-directory\"/> parameter, <filename>pg_stat_tmp</filename> by "
"default. For better performance, <varname>stats_temp_directory</varname> can "
"be pointed at a RAM-based file system, decreasing physical I/O requirements. "
"When the server shuts down cleanly, a permanent copy of the statistics data "
"is stored in the <filename>pg_stat</filename> subdirectory, so that "
"statistics can be retained across server restarts. When recovery is "
"performed at server start (e.g. after immediate shutdown, server crash, and "
"point-in-time recovery), all statistics counters are reset."
msgstr ""
"Сборщик статистики использует временные файлы для передачи собранной "
"информации другим процессам <productname>PostgreSQL</productname>. Имя "
"каталога, в котором хранятся эти файлы, задаётся параметром <xref linkend="
"\"guc-stats-temp-directory\"/>, по умолчанию он называется "
"<filename>pg_stat_tmp</filename>. Для повышения производительности "
"<varname>stats_temp_directory</varname> может указывать на каталог, "
"расположенный в оперативной памяти, что сокращает время физического ввода/"
"вывода. При остановке сервера постоянная копия статистической информации "
"сохраняется в подкаталоге <filename>pg_stat</filename>, поэтому статистику "
"можно хранить на протяжении нескольких перезапусков сервера. Когда "
"восстановление выполняется при запуске сервера (например, после "
"непосредственного завершения работы, катастрофического отказа сервера, и "
"восстановлении на заданную точку во времени), все статистические данные "
"счётчиков сбрасываются."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:217(title)
msgid "Viewing Statistics"
msgstr "Просмотр статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:219(para)
msgid ""
"Several predefined views, listed in <xref linkend=\"monitoring-stats-dynamic-"
"views-table\"/>, are available to show the current state of the system. "
"There are also several other views, listed in <xref linkend=\"monitoring-"
"stats-views-table\"/>, available to show the results of statistics "
"collection. Alternatively, one can build custom views using the underlying "
"statistics functions, as discussed in <xref linkend=\"monitoring-stats-"
"functions\"/>."
msgstr ""
"Для просмотра текущего состояния системы предназначены несколько "
"предопределённых представлений, которые перечислены в <xref remap=\"6\" "
"linkend=\"monitoring-stats-dynamic-views-table\"/>. В дополнение к ним есть "
"несколько других представлений, перечисленных в <xref remap=\"6\" linkend="
"\"monitoring-stats-views-table\"/>, позволяющих просмотреть результаты сбора "
"статистики. Кроме того, на базе нижележащих статистических функций можно "
"создать собственные представления, как описано в <xref remap=\"6\" linkend="
"\"monitoring-stats-functions\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:230(para)
msgid ""
"When using the statistics to monitor collected data, it is important to "
"realize that the information does not update instantaneously. Each "
"individual server process transmits new statistical counts to the collector "
"just before going idle; so a query or transaction still in progress does not "
"affect the displayed totals. Also, the collector itself emits a new report "
"at most once per <varname>PGSTAT_STAT_INTERVAL</varname> milliseconds (500 "
"ms unless altered while building the server). So the displayed information "
"lags behind actual activity. However, current-query information collected by "
"<varname>track_activities</varname> is always up-to-date."
msgstr ""
"Наблюдая собранные данные в сборщике статистики, важно понимать, что эта "
"информация обновляется не сразу. Каждый серверный процесс передаёт новые "
"статистические данные сборщику статистики непосредственно перед переходом в "
"режим ожидания; то есть запрос или транзакция в процессе выполнения не "
"влияют на отображаемые данные статистики. К тому же, сам сборщик статистики "
"формирует новый отчёт не чаще, чем раз в <varname>PGSTAT_STAT_INTERVAL</"
"varname> миллисекунд (500 мс, если этот параметр не изменялся при установке "
"сервера). Так что отображаемая информация отстаёт от того, что происходит в "
"настоящий момент. Однако информация о текущем запросе, собираемая с "
"параметром <varname>track_activities</varname>, всегда актуальна."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:243(para)
msgid ""
"Another important point is that when a server process is asked to display "
"any of these statistics, it first fetches the most recent report emitted by "
"the collector process and then continues to use this snapshot for all "
"statistical views and functions until the end of its current transaction. So "
"the statistics will show static information as long as you continue the "
"current transaction. Similarly, information about the current queries of all "
"sessions is collected when any such information is first requested within a "
"transaction, and the same information will be displayed throughout the "
"transaction. This is a feature, not a bug, because it allows you to perform "
"several queries on the statistics and correlate the results without worrying "
"that the numbers are changing underneath you. But if you want to see new "
"results with each query, be sure to do the queries outside any transaction "
"block. Alternatively, you can invoke <function>pg_stat_clear_snapshot</"
"function>(), which will discard the current transaction's statistics "
"snapshot (if any). The next use of statistical information will cause a new "
"snapshot to be fetched."
msgstr ""
"Ещё одним важным моментом является то, что когда в серверном процессе "
"запрашивают какую-либо статистику, сначала он получает наиболее свежий "
"моментальный снимок от сборщика статистики и затем до окончания текущей "
"транзакции использует этот снимок для всех статистических представлений и "
"функций. Так что на протяжении одной транзакции статистическая информация "
"меняться не будет. Подобным же образом информация о текущих запросах во всех "
"сессиях собирается в тот момент, когда она впервые запрашивается в рамках "
"транзакции, и эта же самая информация будет отображаться на протяжении всей "
"транзакции. Это не ошибка, а полезное свойство СУБД, поскольку оно позволяет "
"выполнять запросы к статистическим данным и сравнивать результаты, не "
"беспокоясь о том, что статистические данные изменяются. Но если для каждого "
"запроса вам нужны новые результаты, то их следует выполнять вне любых "
"транзакционных блоков. Или же можно вызывать функцию "
"<function>pg_stat_clear_snapshot</function>(), которая сбросит ранее "
"полученный снимок статистики в текущей транзакции (если он был). При "
"следующем обращении к статистической информации будет сформирован новый "
"моментальный снимок."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:263(para)
msgid ""
"A transaction can also see its own statistics (as yet untransmitted to the "
"collector) in the views <structname>pg_stat_xact_all_tables</structname>, "
"<structname>pg_stat_xact_sys_tables</structname>, "
"<structname>pg_stat_xact_user_tables</structname>, and "
"<structname>pg_stat_xact_user_functions</structname>. These numbers do not "
"act as stated above; instead they update continuously throughout the "
"transaction."
msgstr ""
"Через представления <structname>pg_stat_xact_all_tables</structname>, "
"<structname>pg_stat_xact_sys_tables</structname>, "
"<structname>pg_stat_xact_user_tables</structname>, и "
"<structname>pg_stat_xact_user_functions</structname> транзакции также "
"доступна её собственная статистика (ещё не переданная сборщику статистики). "
"Данные в этих представлениях ведут себя не так, как описано выше; наоборот, "
"в течение транзакции они постоянно обновляются."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:273(title)
msgid "Dynamic Statistics Views"
msgstr "Динамические статистические представления"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:278(entry) monitoring.xml:346(entry)
msgid "View Name"
msgstr "Имя представления"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:279(entry) monitoring.xml:347(entry)
#: monitoring.xml:562(entry) monitoring.xml:843(entry)
#: monitoring.xml:1643(entry) monitoring.xml:1891(entry)
#: monitoring.xml:1982(entry) monitoring.xml:2055(entry)
#: monitoring.xml:2126(entry) monitoring.xml:2183(entry)
#: monitoring.xml:2269(entry) monitoring.xml:2406(entry)
#: monitoring.xml:2470(entry) monitoring.xml:2613(entry)
#: monitoring.xml:2709(entry) monitoring.xml:2790(entry)
#: monitoring.xml:2851(entry) monitoring.xml:2898(entry)
#: monitoring.xml:2978(entry) monitoring.xml:3097(entry)
#: monitoring.xml:3267(entry) monitoring.xml:3363(entry)
#: monitoring.xml:3500(entry)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:286(structname)
msgid "pg_stat_activity"
msgstr "pg_stat_activity"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:287(indexterm)
msgid "<primary>pg_stat_activity</primary>"
msgstr "<primary>pg_stat_activity</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:289(entry)
msgid ""
"One row per server process, showing information related to the current "
"activity of that process, such as state and current query. See <xref linkend="
"\"pg-stat-activity-view\"/> for details."
msgstr ""
"Одна строка для каждого серверного процесса c информацией по текущей "
"активности процесса, такой как состояние и текущий запрос. За подробностями "
"обратитесь к <xref remap=\"3\" linkend=\"pg-stat-activity-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:297(structname)
msgid "pg_stat_replication"
msgstr "pg_stat_replication"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:297(indexterm)
msgid "<primary>pg_stat_replication</primary>"
msgstr "<primary>pg_stat_replication</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:298(entry)
msgid ""
"One row per WAL sender process, showing statistics about replication to that "
"sender's connected standby server. See <xref linkend=\"pg-stat-replication-"
"view\"/> for details."
msgstr ""
"По одной строке для каждого процесса-передатчика WAL со статистикой по "
"репликации на ведомом сервере, к которому подключён этот процесс. За "
"подробностями обратитесь к <xref remap=\"3\" linkend=\"pg-stat-replication-"
"view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:305(structname)
msgid "pg_stat_wal_receiver"
msgstr "pg_stat_wal_receiver"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:305(indexterm)
msgid "<primary>pg_stat_wal_receiver</primary>"
msgstr "<primary>pg_stat_wal_receiver</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:306(entry)
msgid ""
"Only one row, showing statistics about the WAL receiver from that receiver's "
"connected server. See <xref linkend=\"pg-stat-wal-receiver-view\"/> for "
"details."
msgstr ""
"Только одна строка со статистикой приёмника WAL, полученной с сервера, на "
"котором работает приёмник. За подробностями обратитесь к <xref remap=\"3\" "
"linkend=\"pg-stat-wal-receiver-view\"/>."

#. +> REL_10
#: monitoring.xml:313(structname)
msgid "pg_stat_subscription"
msgstr "pg_stat_subscription"

#. +> REL_10
#: monitoring.xml:313(indexterm)
msgid "<primary>pg_stat_subscription</primary>"
msgstr "<primary>pg_stat_subscription</primary>"

#. +> REL_10
#: monitoring.xml:314(entry)
msgid ""
"At least one row per subscription, showing information about the "
"subscription workers. See <xref linkend=\"pg-stat-subscription\"/> for "
"details."
msgstr ""
"Как минимум одна строка для подписки, сообщающая о рабочих процессах "
"подписки. За подробностями обратитесь к <xref remap=\"3\" linkend=\"pg-stat-"
"subscription\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:321(structname)
msgid "pg_stat_ssl"
msgstr "pg_stat_ssl"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:321(indexterm)
msgid "<primary>pg_stat_ssl</primary>"
msgstr "<primary>pg_stat_ssl</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:322(entry)
msgid ""
"One row per connection (regular and replication), showing information about "
"SSL used on this connection. See <xref linkend=\"pg-stat-ssl-view\"/> for "
"details."
msgstr ""
"Одна строка для каждого подключения (обычного и реплицирующего), в которой "
"показывается информация об использовании SSL для данного подключения. "
"Подробности описаны в <xref remap=\"6\" linkend=\"pg-stat-ssl-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:329(structname)
msgid "pg_stat_progress_vacuum"
msgstr "pg_stat_progress_vacuum"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:329(indexterm)
msgid "<primary>pg_stat_progress_vacuum</primary>"
msgstr "<primary>pg_stat_progress_vacuum</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:330(entry)
msgid ""
"One row for each backend (including autovacuum worker processes) running "
"<command>VACUUM</command>, showing current progress. See <xref linkend="
"\"vacuum-progress-reporting\"/>."
msgstr ""
"По одной строке с текущим состоянием для каждого обслуживающего процесса "
"(включая рабочие процессы автоочистки), в котором работает <command>VACUUM</"
"command>. См. <xref remap=\"4\" linkend=\"vacuum-progress-reporting\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:341(title)
msgid "Collected Statistics Views"
msgstr "Представления собранной статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:353(structname)
msgid "pg_stat_archiver"
msgstr "pg_stat_archiver"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:353(indexterm)
msgid "<primary>pg_stat_archiver</primary>"
msgstr "<primary>pg_stat_archiver</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:354(entry)
msgid ""
"One row only, showing statistics about the WAL archiver process's activity. "
"See <xref linkend=\"pg-stat-archiver-view\"/> for details."
msgstr ""
"Только одна строка со статистикой о работе активности процесса архивации "
"WAL. Более подробно смотрите <xref linkend=\"pg-stat-archiver-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:361(structname)
msgid "pg_stat_bgwriter"
msgstr "pg_stat_bgwriter"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:361(indexterm)
msgid "<primary>pg_stat_bgwriter</primary>"
msgstr "<primary>pg_stat_bgwriter</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:362(entry)
msgid ""
"One row only, showing statistics about the background writer process's "
"activity. See <xref linkend=\"pg-stat-bgwriter-view\"/> for details."
msgstr ""
"Только одна строка со статистикой о работе фонового процесса записи. Более "
"подробно смотрите <xref linkend=\"pg-stat-bgwriter-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:369(structname)
msgid "pg_stat_database"
msgstr "pg_stat_database"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:369(indexterm)
msgid "<primary>pg_stat_database</primary>"
msgstr "<primary>pg_stat_database</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:370(entry)
msgid ""
"One row per database, showing database-wide statistics. See <xref linkend="
"\"pg-stat-database-view\"/> for details."
msgstr ""
"Одна строка для каждой базы данных со статистикой на уровне базы. Более "
"подробно смотрите <xref linkend=\"pg-stat-database-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:376(structname)
msgid "pg_stat_database_conflicts"
msgstr "pg_stat_database_conflicts"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:376(indexterm)
msgid "<primary>pg_stat_database_conflicts</primary>"
msgstr "<primary>pg_stat_database_conflicts</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:377(entry)
msgid ""
"One row per database, showing database-wide statistics about query cancels "
"due to conflict with recovery on standby servers. See <xref linkend=\"pg-"
"stat-database-conflicts-view\"/> for details."
msgstr ""
"По одной строке на каждую базу данных со статистикой по отменам запросов, "
"выполненным вследствие конфликта с процессами восстановления на ведомых "
"серверах. Более подробно смотрите <xref linkend=\"pg-stat-database-conflicts-"
"view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:385(structname)
msgid "pg_stat_all_tables"
msgstr "pg_stat_all_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:385(indexterm)
msgid "<primary>pg_stat_all_tables</primary>"
msgstr "<primary>pg_stat_all_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:386(entry)
msgid ""
"One row for each table in the current database, showing statistics about "
"accesses to that specific table. See <xref linkend=\"pg-stat-all-tables-view"
"\"/> for details."
msgstr ""
"По одной строке на каждую таблицу в текущей базе данных со статистикой по "
"обращениям к этой таблице. Более подробно смотрите <xref linkend=\"pg-stat-"
"all-tables-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:394(structname)
msgid "pg_stat_sys_tables"
msgstr "pg_stat_sys_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:394(indexterm)
msgid "<primary>pg_stat_sys_tables</primary>"
msgstr "<primary>pg_stat_sys_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:395(entry)
msgid ""
"Same as <structname>pg_stat_all_tables</structname>, except that only system "
"tables are shown."
msgstr ""
"Аналогично <structname>pg_stat_all_tables</structname>, за исключением того, "
"что отображаются только системные таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:400(structname)
msgid "pg_stat_user_tables"
msgstr "pg_stat_user_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:400(indexterm)
msgid "<primary>pg_stat_user_tables</primary>"
msgstr "<primary>pg_stat_user_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:401(entry)
msgid ""
"Same as <structname>pg_stat_all_tables</structname>, except that only user "
"tables are shown."
msgstr ""
"Аналогично <structname>pg_stat_all_tables</structname>, за исключением того, "
"что отображаются только пользовательские таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:406(structname)
msgid "pg_stat_xact_all_tables"
msgstr "pg_stat_xact_all_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:406(indexterm)
msgid "<primary>pg_stat_xact_all_tables</primary>"
msgstr "<primary>pg_stat_xact_all_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:407(entry)
msgid ""
"Similar to <structname>pg_stat_all_tables</structname>, but counts actions "
"taken so far within the current transaction (which are <emphasis>not</"
"emphasis> yet included in <structname>pg_stat_all_tables</structname> and "
"related views). The columns for numbers of live and dead rows and vacuum and "
"analyze actions are not present in this view."
msgstr ""
"Подобно <structname>pg_stat_all_tables</structname>, но подсчитывает "
"действия, выполненные в текущей транзакции к настоящему моменту (которые ещё "
"<emphasis>не</emphasis> вошли в <structname>pg_stat_all_tables</structname> "
"и связанные представления). Столбцы для числа живых и мёртвых строк, а также "
"количества операций очистки и сбора статистики, в этом представлении "
"отсутствуют."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:415(structname)
msgid "pg_stat_xact_sys_tables"
msgstr "pg_stat_xact_sys_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:415(indexterm)
msgid "<primary>pg_stat_xact_sys_tables</primary>"
msgstr "<primary>pg_stat_xact_sys_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:416(entry)
msgid ""
"Same as <structname>pg_stat_xact_all_tables</structname>, except that only "
"system tables are shown."
msgstr ""
"Аналогично <structname>pg_stat_xact_all_tables</structname>, за исключением "
"того, что отображаются только системные таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:421(structname)
msgid "pg_stat_xact_user_tables"
msgstr "pg_stat_xact_user_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:421(indexterm)
msgid "<primary>pg_stat_xact_user_tables</primary>"
msgstr "<primary>pg_stat_xact_user_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:422(entry)
msgid ""
"Same as <structname>pg_stat_xact_all_tables</structname>, except that only "
"user tables are shown."
msgstr ""
"Аналогично <structname>pg_stat_xact_all_tables</structname>, за исключением "
"того, что отображаются только пользовательские таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:427(structname)
msgid "pg_stat_all_indexes"
msgstr "pg_stat_all_indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:427(indexterm)
msgid "<primary>pg_stat_all_indexes</primary>"
msgstr "<primary>pg_stat_all_indexes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:428(entry)
msgid ""
"One row for each index in the current database, showing statistics about "
"accesses to that specific index. See <xref linkend=\"pg-stat-all-indexes-view"
"\"/> for details."
msgstr ""
"По одной строке для каждого индекса в текущей базе данных со статистикой по "
"обращениям к этому индексу. Более подробно смотрите <xref linkend=\"pg-stat-"
"all-indexes-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:436(structname)
msgid "pg_stat_sys_indexes"
msgstr "pg_stat_sys_indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:436(indexterm)
msgid "<primary>pg_stat_sys_indexes</primary>"
msgstr "<primary>pg_stat_sys_indexes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:437(entry)
msgid ""
"Same as <structname>pg_stat_all_indexes</structname>, except that only "
"indexes on system tables are shown."
msgstr ""
"Аналогично <structname>pg_stat_all_indexes</structname>, за исключением "
"того, что показываются только индексы по системным таблицам."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:442(structname)
msgid "pg_stat_user_indexes"
msgstr "pg_stat_user_indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:442(indexterm)
msgid "<primary>pg_stat_user_indexes</primary>"
msgstr "<primary>pg_stat_user_indexes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:443(entry)
msgid ""
"Same as <structname>pg_stat_all_indexes</structname>, except that only "
"indexes on user tables are shown."
msgstr ""
"Аналогично <structname>pg_stat_all_indexes</structname>, за исключением "
"того, что показываются только индексы по пользовательским таблицам."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:448(structname)
msgid "pg_statio_all_tables"
msgstr "pg_statio_all_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:448(indexterm)
msgid "<primary>pg_statio_all_tables</primary>"
msgstr "<primary>pg_statio_all_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:449(entry)
msgid ""
"One row for each table in the current database, showing statistics about I/O "
"on that specific table. See <xref linkend=\"pg-statio-all-tables-view\"/> "
"for details."
msgstr ""
"По одной строке для каждой таблицы в текущей базе данных со статистикой по "
"операциям ввода/вывода для этой таблицы. Более подробно смотрите <xref "
"linkend=\"pg-statio-all-tables-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:457(structname)
msgid "pg_statio_sys_tables"
msgstr "pg_statio_sys_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:457(indexterm)
msgid "<primary>pg_statio_sys_tables</primary>"
msgstr "<primary>pg_statio_sys_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:458(entry)
msgid ""
"Same as <structname>pg_statio_all_tables</structname>, except that only "
"system tables are shown."
msgstr ""
"Аналогично <structname>pg_statio_all_tables</structname>, за исключением "
"того, что показываются только системные таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:463(structname)
msgid "pg_statio_user_tables"
msgstr "pg_statio_user_tables"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:463(indexterm)
msgid "<primary>pg_statio_user_tables</primary>"
msgstr "<primary>pg_statio_user_tables</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:464(entry)
msgid ""
"Same as <structname>pg_statio_all_tables</structname>, except that only user "
"tables are shown."
msgstr ""
"Аналогично <structname>pg_statio_all_tables</structname>, за исключением "
"того, что показываются только пользовательские таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:469(structname)
msgid "pg_statio_all_indexes"
msgstr "pg_statio_all_indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:469(indexterm)
msgid "<primary>pg_statio_all_indexes</primary>"
msgstr "<primary>pg_statio_all_indexes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:470(entry)
msgid ""
"One row for each index in the current database, showing statistics about I/O "
"on that specific index. See <xref linkend=\"pg-statio-all-indexes-view\"/> "
"for details."
msgstr ""
"По одной строке для каждого индекса в текущей базе данных со статистикой по "
"операциям ввода/вывода для этого индекса. Более подробно смотрите <xref "
"linkend=\"pg-statio-all-indexes-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:478(structname)
msgid "pg_statio_sys_indexes"
msgstr "pg_statio_sys_indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:478(indexterm)
msgid "<primary>pg_statio_sys_indexes</primary>"
msgstr "<primary>pg_statio_sys_indexes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:479(entry)
msgid ""
"Same as <structname>pg_statio_all_indexes</structname>, except that only "
"indexes on system tables are shown."
msgstr ""
"Аналогично <structname>pg_statio_all_indexes</structname>, за исключением "
"того, что показываются только индексы по системным таблицам."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:484(structname)
msgid "pg_statio_user_indexes"
msgstr "pg_statio_user_indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:484(indexterm)
msgid "<primary>pg_statio_user_indexes</primary>"
msgstr "<primary>pg_statio_user_indexes</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:485(entry)
msgid ""
"Same as <structname>pg_statio_all_indexes</structname>, except that only "
"indexes on user tables are shown."
msgstr ""
"Аналогично <structname>pg_statio_all_indexes</structname>, за исключением "
"того, что показываются только индексы по пользовательским таблицам."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:490(structname)
msgid "pg_statio_all_sequences"
msgstr "pg_statio_all_sequences"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:490(indexterm)
msgid "<primary>pg_statio_all_sequences</primary>"
msgstr "<primary>pg_statio_all_sequences</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:491(entry)
msgid ""
"One row for each sequence in the current database, showing statistics about "
"I/O on that specific sequence. See <xref linkend=\"pg-statio-all-sequences-"
"view\"/> for details."
msgstr ""
"По одной строке для каждой последовательности в текущей базе данных со "
"статистикой по операциям ввода/вывода для этой последовательности. Более "
"подробно смотрите <xref linkend=\"pg-statio-all-sequences-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:499(structname)
msgid "pg_statio_sys_sequences"
msgstr "pg_statio_sys_sequences"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:499(indexterm)
msgid "<primary>pg_statio_sys_sequences</primary>"
msgstr "<primary>pg_statio_sys_sequences</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:500(entry)
msgid ""
"Same as <structname>pg_statio_all_sequences</structname>, except that only "
"system sequences are shown. (Presently, no system sequences are defined, so "
"this view is always empty.)"
msgstr ""
"Аналогично <structname>pg_statio_all_sequences</structname>, за исключением "
"того, что показываются только системные последовательности. (В настоящее "
"время системных последовательностей нет, поэтому это представление всегда "
"пусто.)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:506(structname)
msgid "pg_statio_user_sequences"
msgstr "pg_statio_user_sequences"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:506(indexterm)
msgid "<primary>pg_statio_user_sequences</primary>"
msgstr "<primary>pg_statio_user_sequences</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:507(entry)
msgid ""
"Same as <structname>pg_statio_all_sequences</structname>, except that only "
"user sequences are shown."
msgstr ""
"Аналогично <structname>pg_statio_all_sequences</structname>, за исключением "
"того, что показываются только пользовательские последовательности."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:512(structname)
msgid "pg_stat_user_functions"
msgstr "pg_stat_user_functions"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:512(indexterm)
msgid "<primary>pg_stat_user_functions</primary>"
msgstr "<primary>pg_stat_user_functions</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:513(entry)
msgid ""
"One row for each tracked function, showing statistics about executions of "
"that function. See <xref linkend=\"pg-stat-user-functions-view\"/> for "
"details."
msgstr ""
"По одной строке для каждой отслеживаемой функции со статистикой по "
"выполнениям этой функции. Более подробно смотрите <xref linkend=\"pg-stat-"
"user-functions-view\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:521(structname)
msgid "pg_stat_xact_user_functions"
msgstr "pg_stat_xact_user_functions"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:521(indexterm)
msgid "<primary>pg_stat_xact_user_functions</primary>"
msgstr "<primary>pg_stat_xact_user_functions</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:522(entry)
msgid ""
"Similar to <structname>pg_stat_user_functions</structname>, but counts only "
"calls during the current transaction (which are <emphasis>not</emphasis> yet "
"included in <structname>pg_stat_user_functions</structname>)."
msgstr ""
"Аналогично <structname>pg_stat_user_functions</structname>, однако "
"подсчитываются только вызовы функций, выполненные в текущей транзакции "
"(которые ещё <emphasis>не</emphasis> были включены в "
"<structname>pg_stat_user_functions</structname>)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:531(para)
msgid ""
"The per-index statistics are particularly useful to determine which indexes "
"are being used and how effective they are."
msgstr ""
"Статистика по отдельным индексам особенно полезна для определения того, "
"какие индексы используются и насколько они эффективны."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:536(para)
msgid ""
"The <structname>pg_statio_</structname> views are primarily useful to "
"determine the effectiveness of the buffer cache. When the number of actual "
"disk reads is much smaller than the number of buffer hits, then the cache is "
"satisfying most read requests without invoking a kernel call. However, these "
"statistics do not give the entire story: due to the way in which "
"<productname>PostgreSQL</productname> handles disk I/O, data that is not in "
"the <productname>PostgreSQL</productname> buffer cache might still reside in "
"the kernel's I/O cache, and might therefore still be fetched without "
"requiring a physical read. Users interested in obtaining more detailed "
"information on <productname>PostgreSQL</productname> I/O behavior are "
"advised to use the <productname>PostgreSQL</productname> statistics "
"collector in combination with operating system utilities that allow insight "
"into the kernel's handling of I/O."
msgstr ""
"Представления <structname>pg_statio_</structname> полезны, прежде всего, для "
"определения эффективности буферного кеша. Если количество фактических "
"дисковых чтений существенно меньше количества чтений из буферного кеша, то "
"это означает, что кеш справляется с большинством запросов на чтение без "
"обращения к ядру. Однако эта статистика не даёт полной картины: "
"<productname>PostgreSQL</productname> обрабатывает дисковый ввод/вывод так, "
"что данные, не находящиеся в буферном кеше <productname>PostgreSQL</"
"productname>, могут все ещё располагаться в кеше ввода/вывода ядра, и, "
"следовательно, для их получения физическое чтение может не использоваться. "
"Для получения более детальной информации о процессе ввода/вывода в "
"<productname>PostgreSQL</productname> рекомендуется использовать сборщик "
"статистики <productname>PostgreSQL</productname> в сочетании с утилитами "
"операционной системы, которые дают более полное представление о том, как "
"ядро осуществляет ввод/вывод."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:555(title)
msgid "<structname>pg_stat_activity</structname> View"
msgstr "Представление <structname>pg_stat_activity</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:560(entry) monitoring.xml:1641(entry)
#: monitoring.xml:1889(entry) monitoring.xml:1980(entry)
#: monitoring.xml:2053(entry) monitoring.xml:2124(entry)
#: monitoring.xml:2181(entry) monitoring.xml:2267(entry)
#: monitoring.xml:2404(entry) monitoring.xml:2468(entry)
#: monitoring.xml:2611(entry) monitoring.xml:2707(entry)
#: monitoring.xml:2788(entry) monitoring.xml:2849(entry)
#: monitoring.xml:2896(entry) monitoring.xml:3265(entry)
msgid "Column"
msgstr "Столбец"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:561(entry) monitoring.xml:1642(entry)
#: monitoring.xml:1890(entry) monitoring.xml:1981(entry)
#: monitoring.xml:2054(entry) monitoring.xml:2125(entry)
#: monitoring.xml:2182(entry) monitoring.xml:2268(entry)
#: monitoring.xml:2405(entry) monitoring.xml:2469(entry)
#: monitoring.xml:2612(entry) monitoring.xml:2708(entry)
#: monitoring.xml:2789(entry) monitoring.xml:2850(entry)
#: monitoring.xml:2897(entry) monitoring.xml:3266(entry)
#: monitoring.xml:3929(entry)
msgid "Type"
msgstr "Тип"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:568(structfield) monitoring.xml:2275(structfield)
#: monitoring.xml:2412(structfield) monitoring.xml:3278(structfield)
msgid "datid"
msgstr "datid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:569(type) monitoring.xml:584(type) monitoring.xml:1655(type)
#: monitoring.xml:1989(type) monitoring.xml:2276(type)
#: monitoring.xml:2413(type) monitoring.xml:2477(type)
#: monitoring.xml:2620(type) monitoring.xml:2625(type)
#: monitoring.xml:2716(type) monitoring.xml:2797(type)
#: monitoring.xml:2802(type) monitoring.xml:2858(type)
#: monitoring.xml:2905(type) monitoring.xml:3136(type)
#: monitoring.xml:3154(type) monitoring.xml:3279(type)
#: monitoring.xml:3289(type)
msgid "oid"
msgstr "oid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:570(entry) monitoring.xml:3137(entry)
msgid "OID of the database this backend is connected to"
msgstr "OID базы данных, к которой подключён этот серверный процесс"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:573(structfield) monitoring.xml:2280(structfield)
#: monitoring.xml:2417(structfield) monitoring.xml:3283(structfield)
msgid "datname"
msgstr "datname"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:574(type) monitoring.xml:589(type) monitoring.xml:1660(type)
#: monitoring.xml:2281(type) monitoring.xml:2418(type)
#: monitoring.xml:2482(type) monitoring.xml:2487(type)
#: monitoring.xml:2630(type) monitoring.xml:2635(type)
#: monitoring.xml:2640(type) monitoring.xml:2721(type)
#: monitoring.xml:2726(type) monitoring.xml:2807(type)
#: monitoring.xml:2812(type) monitoring.xml:2817(type)
#: monitoring.xml:2863(type) monitoring.xml:2868(type)
#: monitoring.xml:2910(type) monitoring.xml:2915(type)
#: monitoring.xml:3284(type)
msgid "name"
msgstr "name"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:575(entry)
msgid "Name of the database this backend is connected to"
msgstr "Имя базы данных, к которой подключён этот серверный процесс"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:578(structfield) monitoring.xml:1649(structfield)
#: monitoring.xml:1897(structfield) monitoring.xml:1998(structfield)
#: monitoring.xml:2061(structfield) monitoring.xml:3273(structfield)
msgid "pid"
msgstr "pid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:579(type) monitoring.xml:618(type) monitoring.xml:1650(type)
#: monitoring.xml:1688(type) monitoring.xml:1797(type)
#: monitoring.xml:1898(type) monitoring.xml:1914(type)
#: monitoring.xml:1926(type) monitoring.xml:1999(type)
#: monitoring.xml:2062(type) monitoring.xml:2084(type)
#: monitoring.xml:2286(type) monitoring.xml:2987(type)
#: monitoring.xml:2994(type) monitoring.xml:3130(type)
#: monitoring.xml:3142(type) monitoring.xml:3274(type)
msgid "integer"
msgstr "integer"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:580(entry) monitoring.xml:3143(entry)
msgid "Process ID of this backend"
msgstr "Идентификатор процесса этого серверного процесса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:583(structfield) monitoring.xml:1654(structfield)
msgid "usesysid"
msgstr "usesysid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:585(entry) monitoring.xml:3155(entry)
msgid "OID of the user logged into this backend"
msgstr "OID пользователя, подключённого к этому серверному процессу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:588(structfield) monitoring.xml:1659(structfield)
msgid "usename"
msgstr "usename"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:590(entry)
msgid "Name of the user logged into this backend"
msgstr "Имя пользователя, подключённого к этому серверному процессу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:593(structfield) monitoring.xml:1664(structfield)
msgid "application_name"
msgstr "application_name"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:594(type) monitoring.xml:609(type) monitoring.xml:654(type)
#: monitoring.xml:733(type) monitoring.xml:740(type) monitoring.xml:794(type)
#: monitoring.xml:805(type) monitoring.xml:1665(type) monitoring.xml:1679(type)
#: monitoring.xml:1708(type) monitoring.xml:1804(type)
#: monitoring.xml:1903(type) monitoring.xml:1954(type)
#: monitoring.xml:1959(type) monitoring.xml:1994(type)
#: monitoring.xml:2072(type) monitoring.xml:2078(type)
#: monitoring.xml:2096(type) monitoring.xml:2138(type)
#: monitoring.xml:2153(type) monitoring.xml:3112(type)
#: monitoring.xml:3160(type) monitoring.xml:3168(type)
#: monitoring.xml:3294(type)
msgid "text"
msgstr "text"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:595(entry)
msgid "Name of the application that is connected to this backend"
msgstr "Название приложения, подключённого к этому серверному процессу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:599(structfield) monitoring.xml:1670(structfield)
msgid "client_addr"
msgstr "client_addr"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:600(type) monitoring.xml:1671(type) monitoring.xml:3124(type)
msgid "inet"
msgstr "inet"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:601(entry)
msgid ""
"IP address of the client connected to this backend. If this field is null, "
"it indicates either that the client is connected via a Unix socket on the "
"server machine or that this is an internal process such as autovacuum."
msgstr ""
"IP-адрес клиента, подключённого к этому серверному процессу. Значение null в "
"этом поле означает, что клиент подключён через сокет Unix на стороне сервера "
"или что это внутренний процесс, например, автоочистка."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:608(structfield) monitoring.xml:1678(structfield)
msgid "client_hostname"
msgstr "client_hostname"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:610(entry) monitoring.xml:1680(entry)
msgid ""
"Host name of the connected client, as reported by a reverse DNS lookup of "
"<structfield>client_addr</structfield>. This field will only be non-null for "
"IP connections, and only when <xref linkend=\"guc-log-hostname\"/> is "
"enabled."
msgstr ""
"Имя компьютера для подключённого клиента, получаемое в результате обратного "
"поиска в DNS по <structfield>client_addr</structfield>. Это поле будет "
"отлично от null только в случае соединений по IP и только при включённом "
"режиме <xref linkend=\"guc-log-hostname\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:617(structfield) monitoring.xml:1687(structfield)
msgid "client_port"
msgstr "client_port"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:619(entry)
msgid ""
"TCP port number that the client is using for communication with this "
"backend, or <literal>-1</literal> if a Unix socket is used"
msgstr ""
"Номер TCP-порта, который используется клиентом для соединения с этим "
"серверным процессом, или <literal>-1</literal>, если используется сокет Unix"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:624(structfield) monitoring.xml:1694(structfield)
msgid "backend_start"
msgstr "backend_start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:625(type) monitoring.xml:632(type) monitoring.xml:641(type)
#: monitoring.xml:649(type) monitoring.xml:1695(type) monitoring.xml:1934(type)
#: monitoring.xml:1939(type) monitoring.xml:1949(type)
#: monitoring.xml:2016(type) monitoring.xml:2021(type)
#: monitoring.xml:2033(type) monitoring.xml:2143(type)
#: monitoring.xml:2158(type) monitoring.xml:2163(type)
#: monitoring.xml:2250(type) monitoring.xml:2387(type)
#: monitoring.xml:2548(type) monitoring.xml:2554(type)
#: monitoring.xml:2560(type) monitoring.xml:2565(type)
#: monitoring.xml:3006(type) monitoring.xml:3118(type)
#: monitoring.xml:3148(type) monitoring.xml:3176(type)
msgid "timestamp with time zone"
msgstr "timestamp with time zone"

#. +> REL_10
#: monitoring.xml:626(entry)
msgid ""
"Time when this process was started. For client backends, this is the time "
"the client connected to the server."
msgstr ""
"Время запуска процесса. Для процессов, обслуживающих клиентов, это время "
"подключения клиента к серверу."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:631(structfield)
msgid "xact_start"
msgstr "xact_start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:633(entry)
msgid ""
"Time when this process' current transaction was started, or null if no "
"transaction is active. If the current query is the first of its transaction, "
"this column is equal to the <structfield>query_start</structfield> column."
msgstr ""
"Время начала текущей транзакции в этом процессе или null при отсутствии "
"активной транзакции. Если текущий запрос был первым в своей транзакции, то "
"значение в этом столбце совпадает со значением столбца "
"<structfield>query_start</structfield>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:640(structfield)
msgid "query_start"
msgstr "query_start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:642(entry)
msgid ""
"Time when the currently active query was started, or if <structfield>state</"
"structfield> is not <literal>active</literal>, when the last query was "
"started"
msgstr ""
"Время начала выполнения активного в данный момент запроса, или, если "
"<structfield>state</structfield> не <literal>active</literal>, то время "
"начала выполнения последнего запроса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:648(structfield)
msgid "state_change"
msgstr "state_change"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:650(entry)
msgid "Time when the <structfield>state</structfield> was last changed"
msgstr ""
"Время последнего изменения состояния (поля <structfield>state</structfield>)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:653(structfield)
msgid "wait_event_type"
msgstr "wait_event_type"

#. +> REL_10
#: monitoring.xml:659(para)
msgid ""
"<literal>LWLock</literal>: The backend is waiting for a lightweight lock. "
"Each such lock protects a particular data structure in shared memory. "
"<literal>wait_event</literal> will contain a name identifying the purpose of "
"the lightweight lock. (Some locks have specific names; others are part of a "
"group of locks each with a similar purpose.)"
msgstr ""
"<literal>LWLock</literal>: обслуживающий процесс ожидает лёгкую блокировку. "
"Такие блокировки защищают определённые структуры данных в разделяемой "
"памяти. В <literal>wait_event</literal> будет содержаться имя, отражающее "
"цель получения лёгкой блокировки. (Некоторые блокировки имеют особые имена; "
"другие объединяются в группы блокировок со схожим предназначением.)"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:659(para)
msgid ""
"<literal>LWLockTranche</literal>: The backend is waiting for one of a group "
"of related lightweight locks. All locks in the group perform a similar "
"function; <literal>wait_event</literal> will identify the general purpose of "
"locks in that group."
msgstr ""
"<literal>LWLockTranche</literal>: Обслуживающий процесс ожидает одну из "
"группы связанных лёгких блокировок. Все блокировки в этой группе выполняют "
"схожие функции; общее предназначение блокировок в этой группе показывается в "
"<literal>wait_event</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:668(para)
msgid ""
"<literal>Lock</literal>: The backend is waiting for a heavyweight lock. "
"Heavyweight locks, also known as lock manager locks or simply locks, "
"primarily protect SQL-visible objects such as tables. However, they are also "
"used to ensure mutual exclusion for certain internal operations such as "
"relation extension. <literal>wait_event</literal> will identify the type of "
"lock awaited."
msgstr ""
"<literal>Lock</literal>: Обслуживающий процесс ожидает тяжёлую блокировку. "
"Тяжёлые блокировки, также называемые блокировками менеджера блокировок или "
"просто блокировками, в основном защищают объекты уровня SQL, такие как "
"таблицы. Однако они также применяются для взаимоисключающего выполнения "
"некоторых внутренних операций, например, для расширения отношений. Тип "
"ожидаемой блокировки показывается в <literal>wait_event</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:678(para)
msgid ""
"<literal>BufferPin</literal>: The server process is waiting to access to a "
"data buffer during a period when no other process can be examining that "
"buffer. Buffer pin waits can be protracted if another process holds an open "
"cursor which last read data from the buffer in question."
msgstr ""
"<literal>BufferPin</literal>: Серверный процесс ожидает доступа к буферу "
"данных, когда никакой другой процесс не обращается к этому буферу. Ожидание "
"закрепления буфера может растягиваться, если другой процесс удерживает "
"открытый курсор, который читал данные из нужного буфера."

#. +> REL_10
#: monitoring.xml:687(para)
msgid ""
"<literal>Activity</literal>: The server process is idle. This is used by "
"system processes waiting for activity in their main processing loop. "
"<literal>wait_event</literal> will identify the specific wait point."
msgstr ""
"<literal>Activity</literal>: Серверный процесс простаивает. Это состояние "
"наблюдается в системных процессах, ожидающих активности в основном цикле "
"обработки. В <literal>wait_event</literal> обозначается конкретное место "
"ожидания."

#. +> REL_10
#: monitoring.xml:694(para)
msgid ""
"<literal>Extension</literal>: The server process is waiting for activity in "
"an extension module. This category is useful for modules to track custom "
"waiting points."
msgstr ""
"<literal>Extension</literal>: Серверный процесс ожидает активности в модуле "
"расширения. Эта категория полезна при использовании модулей, она помогает "
"отслеживать нестандартные места ожидания."

#. +> REL_10
#: monitoring.xml:701(para)
msgid ""
"<literal>Client</literal>: The server process is waiting for some activity "
"on a socket from user applications, and that the server expects something to "
"happen that is independent from its internal processes. <literal>wait_event</"
"literal> will identify the specific wait point."
msgstr ""
"<literal>Client</literal>: Серверный процесс ожидает в сокете некоторую "
"активность пользовательского приложения, и события, ожидаемые сервером, не "
"зависят от его внутренних процессов. В <literal>wait_event</literal> "
"обозначается конкретное место ожидания."

#. +> REL_10
#: monitoring.xml:709(para)
msgid ""
"<literal>IPC</literal>: The server process is waiting for some activity from "
"another process in the server. <literal>wait_event</literal> will identify "
"the specific wait point."
msgstr ""
"<literal>IPC</literal>: Серверный процесс ожидает некоторой активности "
"другого процесса на сервере. В <literal>wait_event</literal> обозначается "
"конкретное место ожидания."

#. +> REL_10
#: monitoring.xml:716(para)
msgid ""
"<literal>Timeout</literal>: The server process is waiting for a timeout to "
"expire. <literal>wait_event</literal> will identify the specific wait point."
msgstr ""
"<literal>Timeout</literal>: Серверный процесс ожидает истечения "
"определённого времени. В <literal>wait_event</literal> обозначается "
"конкретное место ожидания."

#. +> REL_10
#: monitoring.xml:723(para)
msgid ""
"<literal>IO</literal>: The server process is waiting for a IO to complete. "
"<literal>wait_event</literal> will identify the specific wait point."
msgstr ""
"<literal>IO</literal>: Серверный процесс ожидает завершения операции ввода/"
"вывода. В <literal>wait_event</literal> обозначается конкретное место "
"ожидания."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:655(entry)
msgid ""
"The type of event for which the backend is waiting, if any; otherwise NULL. "
"Possible values are: <placeholder-1/>"
msgstr ""
"Тип события, которого ждёт обслуживающий процесс, если это имеет место; в "
"противном случае — NULL. Возможные значения: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:732(structfield)
msgid "wait_event"
msgstr "wait_event"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:734(entry) monitoring.xml:3169(entry)
msgid ""
"Wait event name if backend is currently waiting, otherwise NULL. See <xref "
"linkend=\"wait-event-table\"/> for details."
msgstr ""
"Имя ожидаемого события, если обслуживающий процесс находится в состоянии "
"ожидания, а в противном случае — NULL. За подробностями обратитесь к <xref "
"remap=\"3\" linkend=\"wait-event-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:739(structfield) monitoring.xml:1707(structfield)
msgid "state"
msgstr "state"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:745(para)
msgid "<literal>active</literal>: The backend is executing a query."
msgstr "<literal>active</literal>: серверный процесс выполняет запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:750(para)
msgid ""
"<literal>idle</literal>: The backend is waiting for a new client command."
msgstr ""
"<literal>idle</literal>: серверный процесс ожидает новой команды от клиента."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:755(para)
msgid ""
"<literal>idle in transaction</literal>: The backend is in a transaction, but "
"is not currently executing a query."
msgstr ""
"<literal>idle in transaction</literal>: серверный процесс находится внутри "
"транзакции, но в настоящее время не выполняет никакой запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:761(para)
msgid ""
"<literal>idle in transaction (aborted)</literal>: This state is similar to "
"<literal>idle in transaction</literal>, except one of the statements in the "
"transaction caused an error."
msgstr ""
"<literal>idle in transaction (aborted)</literal>: Это состояние подобно "
"<literal>idle in transaction</literal>, за исключением того, что один из "
"операторов в транзакции вызывал ошибку."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:768(para)
msgid ""
"<literal>fastpath function call</literal>: The backend is executing a fast-"
"path function."
msgstr ""
"<literal>fastpath function call</literal>: серверный процесс выполняет fast-"
"path функцию."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:774(para)
msgid ""
"<literal>disabled</literal>: This state is reported if <xref linkend=\"guc-"
"track-activities\"/> is disabled in this backend."
msgstr ""
"<literal>disabled</literal>: Это состояние отображается для серверных "
"процессов, у которых параметр <xref linkend=\"guc-track-activities\"/> "
"отключён."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:741(entry)
msgid ""
"Current overall state of this backend. Possible values are: <placeholder-1/>"
msgstr ""
"Общее текущее состояние этого серверного процесса. Возможные значения: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:783(structfield)
msgid "backend_xid"
msgstr "backend_xid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:784(type) monitoring.xml:789(type) monitoring.xml:1702(type)
msgid "xid"
msgstr "xid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:785(entry)
msgid "Top-level transaction identifier of this backend, if any."
msgstr ""
"Идентификатор верхнего уровня транзакции этого серверного процесса или любой "
"другой."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:788(structfield) monitoring.xml:1701(structfield)
msgid "backend_xmin"
msgstr "backend_xmin"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:790(entry)
msgid "The current backend's <literal>xmin</literal> horizon."
msgstr "текущая граница <literal>xmin</literal> для серверного процесса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:793(structfield)
msgid "query"
msgstr "query"

#. +> REL_10
#: monitoring.xml:795(entry)
msgid ""
"Text of this backend's most recent query. If <structfield>state</"
"structfield> is <literal>active</literal> this field shows the currently "
"executing query. In all other states, it shows the last query that was "
"executed. By default the query text is truncated at 1024 characters; this "
"value can be changed via the parameter <xref linkend=\"guc-track-activity-"
"query-size\"/>."
msgstr ""
"Текст последнего запроса этого серверного процесса. Если <structfield>state</"
"structfield> имеет значение <literal>active</literal>, то в этом поле "
"отображается запрос, который выполняется в настоящий момент. Если процесс "
"находится в любом другом состоянии, то в этом поле отображается последний "
"выполненный запрос. По умолчанию текст запроса обрезается до 1024 символов; "
"это число определяется параметром <xref linkend=\"guc-track-activity-query-"
"size\"/>."

#. +> REL_10
#: monitoring.xml:804(structfield)
msgid "backend_type"
msgstr "backend_type"

#. +> REL_10
#: monitoring.xml:806(entry)
msgid ""
"Type of current backend. Possible types are <literal>autovacuum launcher</"
"literal>, <literal>autovacuum worker</literal>, <literal>background worker</"
"literal>, <literal>background writer</literal>, <literal>client backend</"
"literal>, <literal>checkpointer</literal>, <literal>startup</literal>, "
"<literal>walreceiver</literal>, <literal>walsender</literal> and "
"<literal>walwriter</literal>."
msgstr ""
"Тип текущего серверного процесса. Возможные варианты: <literal>autovacuum "
"launcher</literal>, <literal>autovacuum worker</literal>, "
"<literal>background worker</literal>, <literal>background writer</literal>, "
"<literal>client backend</literal>, <literal>checkpointer</literal>, "
"<literal>startup</literal>, <literal>walreceiver</literal>, "
"<literal>walsender</literal> и <literal>walwriter</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:818(para)
msgid ""
"The <structname>pg_stat_activity</structname> view will have one row per "
"server process, showing information related to the current activity of that "
"process."
msgstr ""
"В представлении <structname>pg_stat_activity</structname> для каждого "
"серверного процесса будет присутствовать по одной строке с информацией, "
"относящейся к текущей деятельности этого процесса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:825(para)
msgid ""
"The <structfield>wait_event</structfield> and <structfield>state</"
"structfield> columns are independent. If a backend is in the "
"<literal>active</literal> state, it may or may not be <literal>waiting</"
"literal> on some event. If the state is <literal>active</literal> and "
"<structfield>wait_event</structfield> is non-null, it means that a query is "
"being executed, but is being blocked somewhere in the system."
msgstr ""
"Значения в столбцах <structfield>wait_event</structfield> и "
"<structfield>state</structfield> не зависят друг от друга. Если "
"обслуживающий процесс находится в состоянии <literal>active</literal> "
"(активен), он может ожидать какое-то событие, или не ожидать никакое. Если "
"состояние <literal>active</literal> и поле <structfield>wait_event</"
"structfield> содержит не NULL, это означает, что запрос выполняется, но "
"заблокирован чем-то в системе."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:836(title)
msgid "<structname>wait_event</structname> Description"
msgstr "Описание <structname>wait_event</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:841(entry)
msgid "Wait Event Type"
msgstr "Тип события ожидания"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:842(entry)
msgid "Wait Event Name"
msgstr "Название события ожидания"

#. +> REL_10
#: monitoring.xml:849(literal)
msgid "LWLock"
msgstr "LWLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:850(literal)
msgid "ShmemIndexLock"
msgstr "ShmemIndexLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:851(entry)
msgid "Waiting to find or allocate space in shared memory."
msgstr "Ожидание при поиске или выделении области в разделяемой памяти."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:854(literal)
msgid "OidGenLock"
msgstr "OidGenLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:855(entry)
msgid "Waiting to allocate or assign an OID."
msgstr "Ожидание при выделении или назначении OID."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:858(literal)
msgid "XidGenLock"
msgstr "XidGenLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:859(entry)
msgid "Waiting to allocate or assign a transaction id."
msgstr "Ожидание при выделении или назначении идентификатора транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:862(literal)
msgid "ProcArrayLock"
msgstr "ProcArrayLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:863(entry)
msgid ""
"Waiting to get a snapshot or clearing a transaction id at transaction end."
msgstr ""
"Ожидание при получении снимка или очистке идентификатора транзакции в конце "
"транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:867(literal)
msgid "SInvalReadLock"
msgstr "SInvalReadLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:868(entry)
msgid "Waiting to retrieve or remove messages from shared invalidation queue."
msgstr ""
"Ожидание при получении или удалении из общей очереди сообщений аннулирования."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:872(literal)
msgid "SInvalWriteLock"
msgstr "SInvalWriteLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:873(entry)
msgid "Waiting to add a message in shared invalidation queue."
msgstr "Ожидание при добавлении в общую очередь сообщения аннулирования."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:876(literal)
msgid "WALBufMappingLock"
msgstr "WALBufMappingLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:877(entry)
msgid "Waiting to replace a page in WAL buffers."
msgstr "Ожидание при замене страницы в буферах WAL."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:880(literal)
msgid "WALWriteLock"
msgstr "WALWriteLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:881(entry)
msgid "Waiting for WAL buffers to be written to disk."
msgstr "Ожидание при записи буферов WAL на диск."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:884(literal)
msgid "ControlFileLock"
msgstr "ControlFileLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:885(entry)
msgid ""
"Waiting to read or update the control file or creation of a new WAL file."
msgstr ""
"Ожидание при чтении или изменении управляющего файла либо при создании "
"нового файла WAL."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:889(literal)
msgid "CheckpointLock"
msgstr "CheckpointLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:890(entry)
msgid "Waiting to perform checkpoint."
msgstr "Ожидание при выполнении контрольной точки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:893(literal)
msgid "CLogControlLock"
msgstr "CLogControlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:894(entry)
msgid "Waiting to read or update transaction status."
msgstr "Ожидание при чтении или изменении состояния транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:897(literal)
msgid "SubtransControlLock"
msgstr "SubtransControlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:898(entry)
msgid "Waiting to read or update sub-transaction information."
msgstr "Ожидание при чтении или изменении информации о подтранзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:901(literal)
msgid "MultiXactGenLock"
msgstr "MultiXactGenLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:902(entry)
msgid "Waiting to read or update shared multixact state."
msgstr "Ожидание при чтении или изменении общего состояния мультитранзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:905(literal)
msgid "MultiXactOffsetControlLock"
msgstr "MultiXactOffsetControlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:906(entry)
msgid "Waiting to read or update multixact offset mappings."
msgstr "Ожидание при чтении или изменении смещений мультитранзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:909(literal)
msgid "MultiXactMemberControlLock"
msgstr "MultiXactMemberControlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:910(entry)
msgid "Waiting to read or update multixact member mappings."
msgstr "Ожидание при чтении или изменении членов мультитранзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:913(literal)
msgid "RelCacheInitLock"
msgstr "RelCacheInitLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:914(entry)
msgid "Waiting to read or write relation cache initialization file."
msgstr "Ожидание при чтении или записи файла инициализации кеша отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:918(literal)
msgid "CheckpointerCommLock"
msgstr "CheckpointerCommLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:919(entry)
msgid "Waiting to manage fsync requests."
msgstr "Ожидание при управлении запросами fsync."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:922(literal)
msgid "TwoPhaseStateLock"
msgstr "TwoPhaseStateLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:923(entry)
msgid "Waiting to read or update the state of prepared transactions."
msgstr "Ожидание при чтении или изменении состояния подготовленных транзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:926(literal)
msgid "TablespaceCreateLock"
msgstr "TablespaceCreateLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:927(entry)
msgid "Waiting to create or drop the tablespace."
msgstr "Ожидание при создании или удалении табличного пространства."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:930(literal)
msgid "BtreeVacuumLock"
msgstr "BtreeVacuumLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:931(entry)
msgid ""
"Waiting to read or update vacuum-related information for a B-tree index."
msgstr ""
"Ожидание при чтении или изменении информации, связанной с очисткой, для "
"индекса-B-дерева."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:935(literal)
msgid "AddinShmemInitLock"
msgstr "AddinShmemInitLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:936(entry)
msgid "Waiting to manage space allocation in shared memory."
msgstr "Ожидание при управлении выделением блоков в общей памяти."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:939(literal)
msgid "AutovacuumLock"
msgstr "AutovacuumLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:940(entry)
msgid ""
"Autovacuum worker or launcher waiting to update or read the current state of "
"autovacuum workers."
msgstr ""
"Ожидание в рабочем процессе или процедуре запуска автоочистки при изменении "
"или чтении текущего состояния рабочих процессов автоочистки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:944(literal)
msgid "AutovacuumScheduleLock"
msgstr "AutovacuumScheduleLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:945(entry)
msgid ""
"Waiting to ensure that the table it has selected for a vacuum still needs "
"vacuuming."
msgstr ""
"Ожидание при подтверждении, что таблица, выбранная для очистки, всё ещё "
"нуждается в очистке."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:950(literal)
msgid "SyncScanLock"
msgstr "SyncScanLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:951(entry)
msgid ""
"Waiting to get the start location of a scan on a table for synchronized "
"scans."
msgstr ""
"Ожидание при получении начального положения сканирования таблицы для "
"синхронизированного сканирования."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:955(literal)
msgid "RelationMappingLock"
msgstr "RelationMappingLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:956(entry)
msgid ""
"Waiting to update the relation map file used to store catalog to filenode "
"mapping."
msgstr ""
"Ожидание при изменении в файле сопоставления отношений, используемого для "
"хранения связей файловых узлов с каталогом БД."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:961(literal)
msgid "AsyncCtlLock"
msgstr "AsyncCtlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:962(entry)
msgid "Waiting to read or update shared notification state."
msgstr "Ожидание при чтении или изменении общего состояния уведомлений."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:965(literal)
msgid "AsyncQueueLock"
msgstr "AsyncQueueLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:966(entry)
msgid "Waiting to read or update notification messages."
msgstr "Ожидание при чтении или изменении сообщений уведомлений."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:969(literal)
msgid "SerializableXactHashLock"
msgstr "SerializableXactHashLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:970(entry)
msgid ""
"Waiting to retrieve or store information about serializable transactions."
msgstr ""
"Ожидание при получении или сохранении информации о сериализуемых транзакциях."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:974(literal)
msgid "SerializableFinishedListLock"
msgstr "SerializableFinishedListLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:975(entry)
msgid "Waiting to access the list of finished serializable transactions."
msgstr "Ожидание при обращении к списку завершённых сериализуемых транзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:979(literal)
msgid "SerializablePredicateLockListLock"
msgstr "SerializablePredicateLockListLock"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:979(literal)
msgid "LWLockTranche"
msgstr "LWLockTranche"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:980(entry)
msgid ""
"Waiting to perform an operation on a list of locks held by serializable "
"transactions."
msgstr ""
"Ожидание при выполнении операции со списком блокировок, удерживаемых "
"сериализуемыми транзакциями."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:984(literal)
msgid "OldSerXidLock"
msgstr "OldSerXidLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:985(entry)
msgid "Waiting to read or record conflicting serializable transactions."
msgstr ""
"Ожидание при чтении или записи информации о конфликтующих сериализуемых "
"транзакциях."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:989(literal)
msgid "SyncRepLock"
msgstr "SyncRepLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:990(entry)
msgid "Waiting to read or update information about synchronous replicas."
msgstr "Ожидание при чтении или изменении сведений о синхронных репликах."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:994(literal)
msgid "BackgroundWorkerLock"
msgstr "BackgroundWorkerLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:995(entry)
msgid "Waiting to read or update background worker state."
msgstr ""
"Ожидание при чтении или изменении состояния фонового рабочего процесса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:998(literal)
msgid "DynamicSharedMemoryControlLock"
msgstr "DynamicSharedMemoryControlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:999(entry)
msgid "Waiting to read or update dynamic shared memory state."
msgstr "Ожидание при чтении или изменении состояния динамической общей памяти."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1002(literal)
msgid "AutoFileLock"
msgstr "AutoFileLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1003(entry)
msgid "Waiting to update the <filename>postgresql.auto.conf</filename> file."
msgstr ""
"Ожидание при изменении файла <filename>postgresql.auto.conf</filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1006(literal)
msgid "ReplicationSlotAllocationLock"
msgstr "ReplicationSlotAllocationLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1007(entry)
msgid "Waiting to allocate or free a replication slot."
msgstr "Ожидание при выделении или освобождении слота репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1010(literal)
msgid "ReplicationSlotControlLock"
msgstr "ReplicationSlotControlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1011(entry)
msgid "Waiting to read or update replication slot state."
msgstr "Ожидание при чтении или изменении состояния слота репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1014(literal)
msgid "CommitTsControlLock"
msgstr "CommitTsControlLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1015(entry)
msgid "Waiting to read or update transaction commit timestamps."
msgstr "Ожидание при чтении или изменении времени фиксирования транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1018(literal)
msgid "CommitTsLock"
msgstr "CommitTsLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1019(entry)
msgid ""
"Waiting to read or update the last value set for the transaction timestamp."
msgstr ""
"Ожидание при чтении или изменении последнего значения, заданного в качестве "
"времени транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1023(literal)
msgid "ReplicationOriginLock"
msgstr "ReplicationOriginLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1024(entry)
msgid "Waiting to setup, drop or use replication origin."
msgstr ""
"Ожидание при подготовке, удалении или использовании источника репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1027(literal)
msgid "MultiXactTruncationLock"
msgstr "MultiXactTruncationLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1028(entry)
msgid "Waiting to read or truncate multixact information."
msgstr "Ожидание при чтении или очистке информации мультитранзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1031(literal)
msgid "OldSnapshotTimeMapLock"
msgstr "OldSnapshotTimeMapLock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1032(entry)
msgid "Waiting to read or update old snapshot control information."
msgstr "Ожидание при чтении или изменении информации о старом снимке."

#. +> REL_10
#: monitoring.xml:1035(literal)
msgid "BackendRandomLock"
msgstr "BackendRandomLock"

#. +> REL_10
#: monitoring.xml:1036(entry)
msgid "Waiting to generate a random number."
msgstr "Ожидание генерирования случайного числа."

#. +> REL_10
#: monitoring.xml:1039(literal)
msgid "LogicalRepWorkerLock"
msgstr "LogicalRepWorkerLock"

#. +> REL_10
#: monitoring.xml:1040(entry)
msgid "Waiting for action on logical replication worker to finish."
msgstr "Ожидание завершения действия процесса логической репликации."

#. +> REL_10
#: monitoring.xml:1043(literal)
msgid "CLogTruncationLock"
msgstr "CLogTruncationLock"

#. +> REL_10
#: monitoring.xml:1044(entry)
msgid ""
"Waiting to truncate the write-ahead log or waiting for write-ahead log "
"truncation to finish."
msgstr ""
"Ожидание при усечении журнала предзаписи или ожидание завершения усечения "
"журнала предзаписи."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1047(literal)
msgid "clog"
msgstr "clog"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1048(entry)
msgid "Waiting for I/O on a clog (transaction status) buffer."
msgstr "Ожидание при вводе/выводе с буфером clog (буфер состояния транзакций)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1051(literal)
msgid "commit_timestamp"
msgstr "commit_timestamp"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1052(entry)
msgid "Waiting for I/O on commit timestamp buffer."
msgstr "Ожидание при вводе/выводе с буфером времени фиксирования транзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1055(literal)
msgid "subtrans"
msgstr "subtrans"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1056(entry)
msgid "Waiting for I/O a subtransaction buffer."
msgstr "Ожидание при вводе/выводе с буфером подтранзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1059(literal)
msgid "multixact_offset"
msgstr "multixact_offset"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1060(entry)
msgid "Waiting for I/O on a multixact offset buffer."
msgstr "Ожидание при вводе/выводе с буфером смещений мультитранзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1063(literal)
msgid "multixact_member"
msgstr "multixact_member"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1064(entry)
msgid "Waiting for I/O on a multixact_member buffer."
msgstr "Ожидание при вводе/выводе с буфером multixact_member."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1067(literal)
msgid "async"
msgstr "async"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1068(entry)
msgid "Waiting for I/O on an async (notify) buffer."
msgstr ""
"Ожидание при вводе/выводе с буфером асинхронных сообщений (уведомлений)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1071(literal)
msgid "oldserxid"
msgstr "oldserxid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1072(entry)
msgid "Waiting to I/O on an oldserxid buffer."
msgstr "Ожидание при вводе/выводе с буфером oldserxid."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1075(literal)
msgid "wal_insert"
msgstr "wal_insert"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1076(entry)
msgid "Waiting to insert WAL into a memory buffer."
msgstr "Ожидание при добавлении записей WAL в буфер в памяти."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1079(literal)
msgid "buffer_content"
msgstr "buffer_content"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1080(entry)
msgid "Waiting to read or write a data page in memory."
msgstr "Ожидание при чтении или записи страницы данных в памяти."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1080(entry)
msgid "Waiting to acquire a userlock."
msgstr "Ожидание при запросе пользовательской блокировки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1083(literal)
msgid "buffer_io"
msgstr "buffer_io"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1084(entry)
msgid "Waiting for I/O on a data page."
msgstr "Ожидание при вводе/выводе, связанном со страницей данных."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1087(literal)
msgid "replication_origin"
msgstr "replication_origin"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1088(entry)
msgid "Waiting to read or update the replication progress."
msgstr "Ожидание при чтении или изменении состояния репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1091(literal)
msgid "replication_slot_io"
msgstr "replication_slot_io"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1092(entry)
msgid "Waiting for I/O on a replication slot."
msgstr "Ожидание при вводе/выводе со слотом репликации."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1095(literal)
msgid "proc"
msgstr "proc"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1096(entry)
msgid "Waiting to read or update the fast-path lock information."
msgstr ""
"Ожидание при чтении или изменении информации о блокировках по быстрому пути."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1099(literal)
msgid "buffer_mapping"
msgstr "buffer_mapping"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1100(entry)
msgid "Waiting to associate a data block with a buffer in the buffer pool."
msgstr "Ожидание при связывании блока данных с буфером в пуле буферов."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1104(literal)
msgid "lock_manager"
msgstr "lock_manager"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1105(entry)
msgid ""
"Waiting to add or examine locks for backends, or waiting to join or exit a "
"locking group (used by parallel query)."
msgstr ""
"Ожидание при добавлении или обращении к блокировкам обслуживающих процессов "
"либо ожидание входа или выхода из группы блокировок (используется в "
"параллельных запросах)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1109(literal)
msgid "predicate_lock_manager"
msgstr "predicate_lock_manager"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1110(entry)
msgid "Waiting to add or examine predicate lock information."
msgstr ""
"Ожидание при добавлении или обращении к информации о предикатных блокировках."

#. +> REL_10
#: monitoring.xml:1113(literal)
msgid "parallel_query_dsa"
msgstr "parallel_query_dsa"

#. +> REL_10
#: monitoring.xml:1114(entry)
msgid "Waiting for parallel query dynamic shared memory allocation lock."
msgstr ""
"Ожидание блокировки выделения динамической общей памяти для параллельного "
"запроса."

#. +> REL_10
#: monitoring.xml:1117(literal)
msgid "tbm"
msgstr "tbm"

#. +> REL_10
#: monitoring.xml:1118(entry)
msgid "Waiting for TBM shared iterator lock."
msgstr "Ожидание блокировки общего итератора TBM."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1121(literal)
msgid "Lock"
msgstr "Lock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1122(literal)
msgid "relation"
msgstr "relation"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1123(entry)
msgid "Waiting to acquire a lock on a relation."
msgstr "Ожидание при запросе блокировки для отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1126(literal)
msgid "extend"
msgstr "extend"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1127(entry)
msgid "Waiting to extend a relation."
msgstr "Ожидание при расширении отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1130(literal)
msgid "page"
msgstr "page"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1131(entry)
msgid "Waiting to acquire a lock on page of a relation."
msgstr "Ожидание при запросе блокировки для страницы отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1134(literal)
msgid "tuple"
msgstr "tuple"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1135(entry)
msgid "Waiting to acquire a lock on a tuple."
msgstr "Ожидание при запросе блокировки для кортежа."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1138(literal)
msgid "transactionid"
msgstr "transactionid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1139(entry)
msgid "Waiting for a transaction to finish."
msgstr "Ожидание завершения транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1142(literal)
msgid "virtualxid"
msgstr "virtualxid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1143(entry)
msgid "Waiting to acquire a virtual xid lock."
msgstr "Ожидание при запросе блокировки виртуального xid."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1146(literal)
msgid "speculative token"
msgstr "speculative token"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1147(entry)
msgid "Waiting to acquire a speculative insertion lock."
msgstr "Ожидание при запросе блокировки спекулятивного добавления."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1150(literal)
msgid "object"
msgstr "object"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1151(entry)
msgid "Waiting to acquire a lock on a non-relation database object."
msgstr "Ожидание при запросе блокировки для нереляционного объекта БД."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1154(literal)
msgid "userlock"
msgstr "userlock"

#. +> REL_10
#: monitoring.xml:1155(entry)
msgid "Waiting to acquire a user lock."
msgstr "Ожидание при запросе пользовательской блокировки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1158(literal)
msgid "advisory"
msgstr "advisory"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1159(entry)
msgid "Waiting to acquire an advisory user lock."
msgstr "Ожидание при запросе рекомендательной пользовательской блокировки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1162(literal) monitoring.xml:1163(literal)
msgid "BufferPin"
msgstr "BufferPin"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1164(entry)
msgid "Waiting to acquire a pin on a buffer."
msgstr "Ожидание при закреплении буфера."

#. +> REL_10
#: monitoring.xml:1167(literal)
msgid "Activity"
msgstr "Activity"

#. +> REL_10
#: monitoring.xml:1168(literal)
msgid "ArchiverMain"
msgstr "ArchiverMain"

#. +> REL_10
#: monitoring.xml:1169(entry)
msgid "Waiting in main loop of the archiver process."
msgstr "Ожидание в основном цикле процесса архиватора."

#. +> REL_10
#: monitoring.xml:1172(literal)
msgid "AutoVacuumMain"
msgstr "AutoVacuumMain"

#. +> REL_10
#: monitoring.xml:1173(entry)
msgid "Waiting in main loop of autovacuum launcher process."
msgstr "Ожидание в основном цикле процесса запуска автоочистки."

#. +> REL_10
#: monitoring.xml:1176(literal)
msgid "BgWriterHibernate"
msgstr "BgWriterHibernate"

#. +> REL_10
#: monitoring.xml:1177(entry)
msgid "Waiting in background writer process, hibernating."
msgstr "Ожидание в фоновом процессе записи, переход в режим «заморозки»."

#. +> REL_10
#: monitoring.xml:1180(literal)
msgid "BgWriterMain"
msgstr "BgWriterMain"

#. +> REL_10
#: monitoring.xml:1181(entry)
msgid "Waiting in main loop of background writer process background worker."
msgstr "Ожидание в основном цикле рабочего процесса фоновой записи."

#. +> REL_10
#: monitoring.xml:1184(literal)
msgid "CheckpointerMain"
msgstr "CheckpointerMain"

#. +> REL_10
#: monitoring.xml:1185(entry)
msgid "Waiting in main loop of checkpointer process."
msgstr "Ожидание в основном цикле процесса контрольной точки."

#. +> REL_10
#: monitoring.xml:1188(literal)
msgid "LogicalLauncherMain"
msgstr "LogicalLauncherMain"

#. +> REL_10
#: monitoring.xml:1189(entry)
msgid "Waiting in main loop of logical launcher process."
msgstr ""
"Ожидание в основном цикле процесса запуска обработчиков логической "
"репликации."

#. +> REL_10
#: monitoring.xml:1192(literal)
msgid "LogicalApplyMain"
msgstr "LogicalApplyMain"

#. +> REL_10
#: monitoring.xml:1193(entry)
msgid "Waiting in main loop of logical apply process."
msgstr "Ожидание в основном цикле процесса применения логической репликации."

#. +> REL_10
#: monitoring.xml:1196(literal)
msgid "PgStatMain"
msgstr "PgStatMain"

#. +> REL_10
#: monitoring.xml:1197(entry)
msgid "Waiting in main loop of the statistics collector process."
msgstr "Ожидание в основном цикле процесса сборщика статистики."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1197(entry)
msgid "Last transaction log position sent on this connection"
msgstr ""
"Позиция последней транзакции в журнале транзакций, отправленной по этому "
"соединению"

#. +> REL_10
#: monitoring.xml:1200(literal)
msgid "RecoveryWalAll"
msgstr "RecoveryWalAll"

#. +> REL_10
#: monitoring.xml:1201(entry)
msgid ""
"Waiting for WAL from any kind of source (local, archive or stream) at "
"recovery."
msgstr ""
"Ожидание поступления WAL из любого источника (локального, архива или потока) "
"при восстановлении."

#. +> REL_10
#: monitoring.xml:1204(literal)
msgid "RecoveryWalStream"
msgstr "RecoveryWalStream"

#. +> REL_10
#: monitoring.xml:1205(entry)
msgid "Waiting for WAL from a stream at recovery."
msgstr "Ожидание поступления WAL из потока при восстановлении."

#. +> REL_10
#: monitoring.xml:1208(literal)
msgid "SysLoggerMain"
msgstr "SysLoggerMain"

#. +> REL_10
#: monitoring.xml:1209(entry)
msgid "Waiting in main loop of syslogger process."
msgstr "Ожидание в основном цикле процесса системного журнала (syslogger)."

#. +> REL_10
#: monitoring.xml:1212(literal)
msgid "WalReceiverMain"
msgstr "WalReceiverMain"

#. +> REL_10
#: monitoring.xml:1213(entry)
msgid "Waiting in main loop of WAL receiver process."
msgstr "Ожидание в основном цикле процесса-приёмника WAL."

#. +> REL_10
#: monitoring.xml:1216(literal)
msgid "WalSenderMain"
msgstr "WalSenderMain"

#. +> REL_10
#: monitoring.xml:1217(entry)
msgid "Waiting in main loop of WAL sender process."
msgstr "Ожидание в основном цикле процесса-передатчика WAL."

#. +> REL_10
#: monitoring.xml:1220(literal)
msgid "WalWriterMain"
msgstr "WalWriterMain"

#. +> REL_10
#: monitoring.xml:1221(entry)
msgid "Waiting in main loop of WAL writer process."
msgstr "Ожидание в основном цикле процесса, пишущего WAL."

#. +> REL_10
#: monitoring.xml:1224(literal)
msgid "Client"
msgstr "Client"

#. +> REL_10
#: monitoring.xml:1225(literal)
msgid "ClientRead"
msgstr "ClientRead"

#. +> REL_10
#: monitoring.xml:1226(entry)
msgid "Waiting to read data from the client."
msgstr "Ожидание при чтении данных, получаемых от клиента."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1226(entry)
msgid "Synchronous state of this standby server"
msgstr "Состояние синхронизации для этого ведомого сервера"

#. +> REL_10
#: monitoring.xml:1229(literal)
msgid "ClientWrite"
msgstr "ClientWrite"

#. +> REL_10
#: monitoring.xml:1230(entry)
msgid "Waiting to write data from the client."
msgstr "Ожидание при записи данных, передаваемых клиенту."

#. +> REL_10
#: monitoring.xml:1233(literal)
msgid "LibPQWalReceiverConnect"
msgstr "LibPQWalReceiverConnect"

#. +> REL_10
#: monitoring.xml:1234(entry)
msgid "Waiting in WAL receiver to establish connection to remote server."
msgstr ""
"Ожидание в приёмнике WAL установления подключения к удалённому серверу."

#. +> REL_10
#: monitoring.xml:1237(literal)
msgid "LibPQWalReceiverReceive"
msgstr "LibPQWalReceiverReceive"

#. +> REL_10
#: monitoring.xml:1238(entry)
msgid "Waiting in WAL receiver to receive data from remote server."
msgstr "Ожидание в приёмнике WAL поступления данных от удалённого сервера."

#. +> REL_10
#: monitoring.xml:1241(literal)
msgid "SSLOpenServer"
msgstr "SSLOpenServer"

#. +> REL_10
#: monitoring.xml:1242(entry)
msgid "Waiting for SSL while attempting connection."
msgstr "Ожидание SSL при попытке установления соединения."

#. +> REL_10
#: monitoring.xml:1245(literal)
msgid "WalReceiverWaitStart"
msgstr "WalReceiverWaitStart"

#. +> REL_10
#: monitoring.xml:1246(entry)
msgid ""
"Waiting for startup process to send initial data for streaming replication."
msgstr ""
"Ожидание от стартового процесса передачи начальных данных для потоковой "
"репликации."

#. +> REL_10
#: monitoring.xml:1249(literal)
msgid "WalSenderWaitForWAL"
msgstr "WalSenderWaitForWAL"

#. +> REL_10
#: monitoring.xml:1250(entry)
msgid "Waiting for WAL to be flushed in WAL sender process."
msgstr "Ожидание сброса WAL в процессе-передатчике WAL."

#. +> REL_10
#: monitoring.xml:1253(literal)
msgid "WalSenderWriteData"
msgstr "WalSenderWriteData"

#. +> REL_10
#: monitoring.xml:1254(entry)
msgid ""
"Waiting for any activity when processing replies from WAL receiver in WAL "
"sender process."
msgstr ""
"Ожидание какой-либо активности при обработке ответов от WAL-приёмника в "
"процессе-передатчике WAL."

#. +> REL_10
#: monitoring.xml:1257(literal) monitoring.xml:1258(literal)
msgid "Extension"
msgstr "Extension"

#. +> REL_10
#: monitoring.xml:1259(entry)
msgid "Waiting in an extension."
msgstr "Ожидание в расширении."

#. +> REL_10
#: monitoring.xml:1262(literal)
msgid "IPC"
msgstr "IPC"

#. +> REL_10
#: monitoring.xml:1263(literal)
msgid "BgWorkerShutdown"
msgstr "BgWorkerShutdown"

#. +> REL_10
#: monitoring.xml:1264(entry)
msgid "Waiting for background worker to shut down."
msgstr "Ожидание завершения фонового рабочего процесса."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1264(entry)
msgid "First transaction log position used when WAL receiver is started"
msgstr "Первая позиция в журнале транзакции в момент запуска приёмника WAL"

#. +> REL_10
#: monitoring.xml:1267(literal)
msgid "BgWorkerStartup"
msgstr "BgWorkerStartup"

#. +> REL_10
#: monitoring.xml:1268(entry)
msgid "Waiting for background worker to start up."
msgstr "Ожидание запуска фонового рабочего процесса."

#. +> REL_10
#: monitoring.xml:1271(literal)
msgid "BtreePage"
msgstr "BtreePage"

#. +> REL_10
#: monitoring.xml:1272(entry)
msgid ""
"Waiting for the page number needed to continue a parallel B-tree scan to "
"become available."
msgstr ""
"Ожидание доступности номера страницы, необходимого для продолжения "
"параллельного сканирования B-дерева."

#. +> REL_10
#: monitoring.xml:1275(literal)
msgid "ExecuteGather"
msgstr "ExecuteGather"

#. +> REL_10
#: monitoring.xml:1276(entry)
msgid ""
"Waiting for activity from child process when executing <literal>Gather</"
"literal> node."
msgstr ""
"Ожидание активности дочернего процесса при выполнении узла <literal>Gather</"
"literal>."

#. +> REL_10
#: monitoring.xml:1279(literal)
msgid "LogicalSyncData"
msgstr "LogicalSyncData"

#. +> REL_10
#: monitoring.xml:1280(entry)
msgid ""
"Waiting for logical replication remote server to send data for initial table "
"synchronization."
msgstr ""
"Ожидание от удалённого сервера логической репликации передачи данных для "
"начальной синхронизации таблиц."

#. +> REL_10
#: monitoring.xml:1283(literal)
msgid "LogicalSyncStateChange"
msgstr "LogicalSyncStateChange"

#. +> REL_10
#: monitoring.xml:1284(entry)
msgid "Waiting for logical replication remote server to change state."
msgstr "Ожидание изменения состояния удалённого сервера логической репликации."

#. +> REL_10
#: monitoring.xml:1287(literal)
msgid "MessageQueueInternal"
msgstr "MessageQueueInternal"

#. +> REL_10
#: monitoring.xml:1288(entry)
msgid "Waiting for other process to be attached in shared message queue."
msgstr "Ожидание подключения другого процесса к общей очереди сообщений."

#. +> REL_10
#: monitoring.xml:1291(literal)
msgid "MessageQueuePutMessage"
msgstr "MessageQueuePutMessage"

#. +> REL_10
#: monitoring.xml:1292(entry)
msgid "Waiting to write a protocol message to a shared message queue."
msgstr "Ожидание записи сообщения протокола в общую очередь сообщений."

#. +> REL_10
#: monitoring.xml:1295(literal)
msgid "MessageQueueReceive"
msgstr "MessageQueueReceive"

#. +> REL_10
#: monitoring.xml:1296(entry)
msgid "Waiting to receive bytes from a shared message queue."
msgstr "Ожидание получения байтов из общей очереди сообщений."

#. +> REL_10
#: monitoring.xml:1299(literal)
msgid "MessageQueueSend"
msgstr "MessageQueueSend"

#. +> REL_10
#: monitoring.xml:1300(entry)
msgid "Waiting to send bytes to a shared message queue."
msgstr "Ожидание передачи байтов в общую очередь сообщений."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1300(entry)
msgid "Last transaction log position reported to origin WAL sender"
msgstr ""
"Последняя позиция в журнале транзакций, сообщённая изначальному передатчику "
"WAL"

#. +> REL_10
#: monitoring.xml:1303(literal)
msgid "ParallelFinish"
msgstr "ParallelFinish"

#. +> REL_10
#: monitoring.xml:1304(entry)
msgid "Waiting for parallel workers to finish computing."
msgstr "Ожидание завершения вычислений параллельными рабочими процессами."

#. +> REL_10
#: monitoring.xml:1307(literal)
msgid "ParallelBitmapScan"
msgstr "ParallelBitmapScan"

#. +> REL_10
#: monitoring.xml:1308(entry)
msgid "Waiting for parallel bitmap scan to become initialized."
msgstr "Ожидание инициализации параллельного сканирования по битовой карте."

#. +> REL_10
#: monitoring.xml:1311(literal)
msgid "ProcArrayGroupUpdate"
msgstr "ProcArrayGroupUpdate"

#. +> REL_10
#: monitoring.xml:1312(entry)
msgid "Waiting for group leader to clear transaction id at transaction end."
msgstr ""
"Ожидание очистки ведущим группы идентификатора транзакции в конце транзакции."

#. +> REL_10
#: monitoring.xml:1315(literal)
msgid "ReplicationOriginDrop"
msgstr "ReplicationOriginDrop"

#. +> REL_10
#: monitoring.xml:1316(entry)
msgid "Waiting for a replication origin to become inactive to be dropped."
msgstr ""
"Ожидание перехода источника репликации в неактивное состояние для "
"последующего удаления."

#. +> REL_10
#: monitoring.xml:1319(literal)
msgid "ReplicationSlotDrop"
msgstr "ReplicationSlotDrop"

#. +> REL_10
#: monitoring.xml:1320(entry)
msgid "Waiting for a replication slot to become inactive to be dropped."
msgstr ""
"Ожидание перехода слота репликации в неактивное состояние для последующего "
"удаления."

#. +> REL_10
#: monitoring.xml:1323(literal)
msgid "SafeSnapshot"
msgstr "SafeSnapshot"

#. +> REL_10
#: monitoring.xml:1324(entry)
msgid ""
"Waiting for a snapshot for a <literal>READ ONLY DEFERRABLE</literal> "
"transaction."
msgstr ""
"Ожидание снимка для транзакции <literal>READ ONLY DEFERRABLE</literal>."

#. +> REL_10
#: monitoring.xml:1327(literal)
msgid "SyncRep"
msgstr "SyncRep"

#. +> REL_10
#: monitoring.xml:1328(entry)
msgid ""
"Waiting for confirmation from remote server during synchronous replication."
msgstr ""
"Ожидание подтверждения от удалённого сервера при синхронной репликации."

#. +> REL_10
#: monitoring.xml:1331(literal)
msgid "Timeout"
msgstr "Timeout"

#. +> REL_10
#: monitoring.xml:1332(literal)
msgid "BaseBackupThrottle"
msgstr "BaseBackupThrottle"

#. +> REL_10
#: monitoring.xml:1333(entry)
msgid "Waiting during base backup when throttling activity."
msgstr ""
"Ожидание в процессе базового резервного копирования из-за ограничения "
"активности."

#. +> REL_10
#: monitoring.xml:1336(literal)
msgid "PgSleep"
msgstr "PgSleep"

#. +> REL_10
#: monitoring.xml:1337(entry)
msgid "Waiting in process that called <function>pg_sleep</function>."
msgstr "Ожидание в процессе, вызвавшем <function>pg_sleep</function>."

#. +> REL_10
#: monitoring.xml:1340(literal)
msgid "RecoveryApplyDelay"
msgstr "RecoveryApplyDelay"

#. +> REL_10
#: monitoring.xml:1341(entry)
msgid "Waiting to apply WAL at recovery because it is delayed."
msgstr "Ожидание применения WAL при восстановлении из-за задержки."

#. +> REL_10
#: monitoring.xml:1344(literal)
msgid "IO"
msgstr "IO"

#. +> REL_10
#: monitoring.xml:1345(literal)
msgid "BufFileRead"
msgstr "BufFileRead"

#. +> REL_10
#: monitoring.xml:1346(entry)
msgid "Waiting for a read from a buffered file."
msgstr "Ожидание чтения из буферизованного файла."

#. +> REL_10
#: monitoring.xml:1349(literal)
msgid "BufFileWrite"
msgstr "BufFileWrite"

#. +> REL_10
#: monitoring.xml:1350(entry)
msgid "Waiting for a write to a buffered file."
msgstr "Ожидание записи в буферизованный файл."

#. +> REL_10
#: monitoring.xml:1353(literal)
msgid "ControlFileRead"
msgstr "ControlFileRead"

#. +> REL_10
#: monitoring.xml:1354(entry)
msgid "Waiting for a read from the control file."
msgstr "Ожидание чтения из управляющего файла."

#. +> REL_10
#: monitoring.xml:1357(literal)
msgid "ControlFileSync"
msgstr "ControlFileSync"

#. +> REL_10
#: monitoring.xml:1358(entry)
msgid "Waiting for the control file to reach stable storage."
msgstr "Ожидание помещения управляющего файла в надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1361(literal)
msgid "ControlFileSyncUpdate"
msgstr "ControlFileSyncUpdate"

#. +> REL_10
#: monitoring.xml:1362(entry)
msgid "Waiting for an update to the control file to reach stable storage."
msgstr "Ожидание переноса изменений управляющего файла в надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1365(literal)
msgid "ControlFileWrite"
msgstr "ControlFileWrite"

#. +> REL_10
#: monitoring.xml:1366(entry)
msgid "Waiting for a write to the control file."
msgstr "Ожидание записи в управляющий файл."

#. +> REL_10
#: monitoring.xml:1369(literal)
msgid "ControlFileWriteUpdate"
msgstr "ControlFileWriteUpdate"

#. +> REL_10
#: monitoring.xml:1370(entry)
msgid "Waiting for a write to update the control file."
msgstr "Ожидание записи для изменения управляющего файла."

#. +> REL_10
#: monitoring.xml:1373(literal)
msgid "CopyFileRead"
msgstr "CopyFileRead"

#. +> REL_10
#: monitoring.xml:1374(entry)
msgid "Waiting for a read during a file copy operation."
msgstr "Ожидание чтения во время операции копирования файла."

#. +> REL_10
#: monitoring.xml:1377(literal)
msgid "CopyFileWrite"
msgstr "CopyFileWrite"

#. +> REL_10
#: monitoring.xml:1378(entry)
msgid "Waiting for a write during a file copy operation."
msgstr "Ожидание записи во время операции копирования файла."

#. +> REL_10
#: monitoring.xml:1381(literal)
msgid "DataFileExtend"
msgstr "DataFileExtend"

#. +> REL_10
#: monitoring.xml:1382(entry)
msgid "Waiting for a relation data file to be extended."
msgstr "Ожидание расширения файла данных отношения."

#. +> REL_10
#: monitoring.xml:1385(literal)
msgid "DataFileFlush"
msgstr "DataFileFlush"

#. +> REL_10
#: monitoring.xml:1386(entry)
msgid "Waiting for a relation data file to reach stable storage."
msgstr "Ожидание помещения файла данных отношения в надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1389(literal)
msgid "DataFileImmediateSync"
msgstr "DataFileImmediateSync"

#. +> REL_10
#: monitoring.xml:1390(entry)
msgid ""
"Waiting for an immediate synchronization of a relation data file to stable "
"storage."
msgstr ""
"Ожидание немедленной синхронизации файла данных отношения с надёжным "
"хранилищем."

#. +> REL_10
#: monitoring.xml:1393(literal)
msgid "DataFilePrefetch"
msgstr "DataFilePrefetch"

#. +> REL_10
#: monitoring.xml:1394(entry)
msgid "Waiting for an asynchronous prefetch from a relation data file."
msgstr "Ожидание асинхронной предвыборки из файла данных отношения."

#. +> REL_10
#: monitoring.xml:1397(literal)
msgid "DataFileRead"
msgstr "DataFileRead"

#. +> REL_10
#: monitoring.xml:1398(entry)
msgid "Waiting for a read from a relation data file."
msgstr "Ожидание чтения из файла данных отношения."

#. +> REL_10
#: monitoring.xml:1401(literal)
msgid "DataFileSync"
msgstr "DataFileSync"

#. +> REL_10
#: monitoring.xml:1402(entry)
msgid "Waiting for changes to a relation data file to reach stable storage."
msgstr ""
"Ожидание переноса изменений в файле данных отношений в надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1405(literal)
msgid "DataFileTruncate"
msgstr "DataFileTruncate"

#. +> REL_10
#: monitoring.xml:1406(entry)
msgid "Waiting for a relation data file to be truncated."
msgstr "Ожидание усечения файла данных отношения."

#. +> REL_10
#: monitoring.xml:1409(literal)
msgid "DataFileWrite"
msgstr "DataFileWrite"

#. +> REL_10
#: monitoring.xml:1410(entry)
msgid "Waiting for a write to a relation data file."
msgstr "Ожидание записи в файл данных отношения."

#. +> REL_10
#: monitoring.xml:1413(literal)
msgid "DSMFillZeroWrite"
msgstr "DSMFillZeroWrite"

#. +> REL_10
#: monitoring.xml:1414(entry)
msgid "Waiting to write zero bytes to a dynamic shared memory backing file."
msgstr ""
"Ожидание записи нулевых байт в файл, поддерживающий работу динамической "
"общей памяти."

#. +> REL_10
#: monitoring.xml:1417(literal)
msgid "LockFileAddToDataDirRead"
msgstr "LockFileAddToDataDirRead"

#. +> REL_10
#: monitoring.xml:1418(entry)
msgid "Waiting for a read while adding a line to the data directory lock file."
msgstr ""
"Ожидание чтения при добавлении строки в файл блокировки каталога данных."

#. +> REL_10
#: monitoring.xml:1421(literal)
msgid "LockFileAddToDataDirSync"
msgstr "LockFileAddToDataDirSync"

#. +> REL_10
#: monitoring.xml:1422(entry)
msgid ""
"Waiting for data to reach stable storage while adding a line to the data "
"directory lock file."
msgstr ""
"Ожидание помещения данных в надёжное хранилище при добавлении строки в файл "
"блокировки каталога данных."

#. +> REL_10
#: monitoring.xml:1425(literal)
msgid "LockFileAddToDataDirWrite"
msgstr "LockFileAddToDataDirWrite"

#. +> REL_10
#: monitoring.xml:1426(entry)
msgid ""
"Waiting for a write while adding a line to the data directory lock file."
msgstr ""
"Ожидание записи при добавлении строки в файл блокировки каталога данных."

#. +> REL_10
#: monitoring.xml:1429(literal)
msgid "LockFileCreateRead"
msgstr "LockFileCreateRead"

#. +> REL_10
#: monitoring.xml:1430(entry)
msgid "Waiting to read while creating the data directory lock file."
msgstr "Ожидание чтения при создании файла блокировки каталога данных."

#. +> REL_10
#: monitoring.xml:1433(literal)
msgid "LockFileCreateSync"
msgstr "LockFileCreateSync"

#. +> REL_10
#: monitoring.xml:1434(entry)
msgid ""
"Waiting for data to reach stable storage while creating the data directory "
"lock file."
msgstr ""
"Ожидание помещения данных в надёжное хранилище при создании файла блокировки "
"каталога данных."

#. +> REL_10
#: monitoring.xml:1437(literal)
msgid "LockFileCreateWrite"
msgstr "LockFileCreateWrite"

#. +> REL_10
#: monitoring.xml:1438(entry)
msgid "Waiting for a write while creating the data directory lock file."
msgstr "Ожидание записи при создании файла блокировки каталога данных."

#. +> REL_10
#: monitoring.xml:1441(literal)
msgid "LockFileReCheckDataDirRead"
msgstr "LockFileReCheckDataDirRead"

#. +> REL_10
#: monitoring.xml:1442(entry)
msgid "Waiting for a read during recheck of the data directory lock file."
msgstr ""
"Ожидание чтения во время перепроверки файла блокировки каталога данных."

#. +> REL_10
#: monitoring.xml:1445(literal)
msgid "LogicalRewriteCheckpointSync"
msgstr "LogicalRewriteCheckpointSync"

#. +> REL_10
#: monitoring.xml:1446(entry)
msgid ""
"Waiting for logical rewrite mappings to reach stable storage during a "
"checkpoint."
msgstr ""
"Ожидание помещения отображений логической перезаписи в надёжное хранилище во "
"время контрольной точки."

#. +> REL_10
#: monitoring.xml:1449(literal)
msgid "LogicalRewriteMappingSync"
msgstr "LogicalRewriteMappingSync"

#. +> REL_10
#: monitoring.xml:1450(entry)
msgid ""
"Waiting for mapping data to reach stable storage during a logical rewrite."
msgstr ""
"Ожидание помещения данных отображений в надёжное хранилище в процессе "
"логической перезаписи."

#. +> REL_10
#: monitoring.xml:1453(literal)
msgid "LogicalRewriteMappingWrite"
msgstr "LogicalRewriteMappingWrite"

#. +> REL_10
#: monitoring.xml:1454(entry)
msgid "Waiting for a write of mapping data during a logical rewrite."
msgstr "Ожидание записи данных отображений в процессе логической перезаписи."

#. +> REL_10
#: monitoring.xml:1457(literal)
msgid "LogicalRewriteSync"
msgstr "LogicalRewriteSync"

#. +> REL_10
#: monitoring.xml:1458(entry)
msgid "Waiting for logical rewrite mappings to reach stable storage."
msgstr ""
"Ожидание помещения отображений логической перезаписи в надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1461(literal)
msgid "LogicalRewriteWrite"
msgstr "LogicalRewriteWrite"

#. +> REL_10
#: monitoring.xml:1462(entry)
msgid "Waiting for a write of logical rewrite mappings."
msgstr "Ожидание сохранения отображений логической перезаписи."

#. +> REL_10
#: monitoring.xml:1465(literal)
msgid "RelationMapRead"
msgstr "RelationMapRead"

#. +> REL_10
#: monitoring.xml:1466(entry)
msgid "Waiting for a read of the relation map file."
msgstr "Ожидание чтения файла отображений отношений."

#. +> REL_10
#: monitoring.xml:1469(literal)
msgid "RelationMapSync"
msgstr "RelationMapSync"

#. +> REL_10
#: monitoring.xml:1470(entry)
msgid "Waiting for the relation map file to reach stable storage."
msgstr "Ожидание помещения файла отображений отношений в надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1473(literal)
msgid "RelationMapWrite"
msgstr "RelationMapWrite"

#. +> REL_10
#: monitoring.xml:1474(entry)
msgid "Waiting for a write to the relation map file."
msgstr "Ожидание записи в файл отображений отношений."

#. +> REL_10
#: monitoring.xml:1477(literal)
msgid "ReorderBufferRead"
msgstr "ReorderBufferRead"

#. +> REL_10
#: monitoring.xml:1478(entry)
msgid "Waiting for a read during reorder buffer management."
msgstr "Ожидание чтения при работе с буфером переупорядочивания."

#. +> REL_10
#: monitoring.xml:1481(literal)
msgid "ReorderBufferWrite"
msgstr "ReorderBufferWrite"

#. +> REL_10
#: monitoring.xml:1482(entry)
msgid "Waiting for a write during reorder buffer management."
msgstr "Ожидание записи при работе с буфером переупорядочивания."

#. +> REL_10
#: monitoring.xml:1485(literal)
msgid "ReorderLogicalMappingRead"
msgstr "ReorderLogicalMappingRead"

#. +> REL_10
#: monitoring.xml:1486(entry)
msgid ""
"Waiting for a read of a logical mapping during reorder buffer management."
msgstr ""
"Ожидание чтения логического отображения при работе с буфером "
"переупорядочивания."

#. +> REL_10
#: monitoring.xml:1489(literal)
msgid "ReplicationSlotRead"
msgstr "ReplicationSlotRead"

#. +> REL_10
#: monitoring.xml:1490(entry)
msgid "Waiting for a read from a replication slot control file."
msgstr "Ожидание чтения из управляющего файла слота репликации."

#. +> REL_10
#: monitoring.xml:1493(literal)
msgid "ReplicationSlotRestoreSync"
msgstr "ReplicationSlotRestoreSync"

#. +> REL_10
#: monitoring.xml:1494(entry)
msgid ""
"Waiting for a replication slot control file to reach stable storage while "
"restoring it to memory."
msgstr ""
"Ожидание помещения в надёжное хранилище управляющего файла слота репликации "
"при восстановлении его в памяти."

#. +> REL_10
#: monitoring.xml:1497(literal)
msgid "ReplicationSlotSync"
msgstr "ReplicationSlotSync"

#. +> REL_10
#: monitoring.xml:1498(entry)
msgid "Waiting for a replication slot control file to reach stable storage."
msgstr ""
"Ожидание помещения в надёжное хранилище управляющего файла слота репликации."

#. +> REL_10
#: monitoring.xml:1501(literal)
msgid "ReplicationSlotWrite"
msgstr "ReplicationSlotWrite"

#. +> REL_10
#: monitoring.xml:1502(entry)
msgid "Waiting for a write to a replication slot control file."
msgstr "Ожидание записи в управляющий файл слота репликации."

#. +> REL_10
#: monitoring.xml:1505(literal)
msgid "SLRUFlushSync"
msgstr "SLRUFlushSync"

#. +> REL_10
#: monitoring.xml:1506(entry)
msgid ""
"Waiting for SLRU data to reach stable storage during a checkpoint or "
"database shutdown."
msgstr ""
"Ожидание помещения данных SLRU в надёжное хранилище во время контрольной "
"точки или отключения базы данных."

#. +> REL_10
#: monitoring.xml:1509(literal)
msgid "SLRURead"
msgstr "SLRURead"

#. +> REL_10
#: monitoring.xml:1510(entry)
msgid "Waiting for a read of an SLRU page."
msgstr "Ожидание чтения страницы SLRU."

#. +> REL_10
#: monitoring.xml:1513(literal)
msgid "SLRUSync"
msgstr "SLRUSync"

#. +> REL_10
#: monitoring.xml:1514(entry)
msgid "Waiting for SLRU data to reach stable storage following a page write."
msgstr ""
"Ожидание помещения данных SLRU в надёжное хранилище после записи страницы."

#. +> REL_10
#: monitoring.xml:1517(literal)
msgid "SLRUWrite"
msgstr "SLRUWrite"

#. +> REL_10
#: monitoring.xml:1518(entry)
msgid "Waiting for a write of an SLRU page."
msgstr "Ожидание записи страницы SLRU."

#. +> REL_10
#: monitoring.xml:1521(literal)
msgid "SnapbuildRead"
msgstr "SnapbuildRead"

#. +> REL_10
#: monitoring.xml:1522(entry)
msgid "Waiting for a read of a serialized historical catalog snapshot."
msgstr "Ожидание чтения сериализованного исторического снимка каталога БД."

#. +> REL_10
#: monitoring.xml:1525(literal)
msgid "SnapbuildSync"
msgstr "SnapbuildSync"

#. +> REL_10
#: monitoring.xml:1526(entry)
msgid ""
"Waiting for a serialized historical catalog snapshot to reach stable storage."
msgstr ""
"Ожидание помещения сериализованного исторического снимка каталога БД в "
"надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1529(literal)
msgid "SnapbuildWrite"
msgstr "SnapbuildWrite"

#. +> REL_10
#: monitoring.xml:1530(entry)
msgid "Waiting for a write of a serialized historical catalog snapshot."
msgstr "Ожидание записи сериализованного исторического снимка каталога БД."

#. +> REL_10
#: monitoring.xml:1533(literal)
msgid "TimelineHistoryFileSync"
msgstr "TimelineHistoryFileSync"

#. +> REL_10
#: monitoring.xml:1534(entry)
msgid ""
"Waiting for a timeline history file received via streaming replication to "
"reach stable storage."
msgstr ""
"Ожидание помещения в надёжное хранилище файла истории линии времени, "
"полученного через потоковую репликацию."

#. +> REL_10
#: monitoring.xml:1537(literal)
msgid "TimelineHistoryFileWrite"
msgstr "TimelineHistoryFileWrite"

#. +> REL_10
#: monitoring.xml:1538(entry)
msgid ""
"Waiting for a write of a timeline history file received via streaming "
"replication."
msgstr ""
"Ожидание записи файла истории линии времени, полученного через потоковую "
"репликацию."

#. +> REL_10
#: monitoring.xml:1541(literal)
msgid "TimelineHistoryRead"
msgstr "TimelineHistoryRead"

#. +> REL_10
#: monitoring.xml:1542(entry)
msgid "Waiting for a read of a timeline history file."
msgstr "Ожидание чтения файла истории линии времени."

#. +> REL_10
#: monitoring.xml:1545(literal)
msgid "TimelineHistorySync"
msgstr "TimelineHistorySync"

#. +> REL_10
#: monitoring.xml:1546(entry)
msgid ""
"Waiting for a newly created timeline history file to reach stable storage."
msgstr ""
"Ожидание помещения в надёжное хранилище только что созданного файла истории "
"линии времени."

#. +> REL_10
#: monitoring.xml:1549(literal)
msgid "TimelineHistoryWrite"
msgstr "TimelineHistoryWrite"

#. +> REL_10
#: monitoring.xml:1550(entry)
msgid "Waiting for a write of a newly created timeline history file."
msgstr "Ожидание записи только что созданного файла истории линии времени."

#. +> REL_10
#: monitoring.xml:1553(literal)
msgid "TwophaseFileRead"
msgstr "TwophaseFileRead"

#. +> REL_10
#: monitoring.xml:1554(entry)
msgid "Waiting for a read of a two phase state file."
msgstr "Ожидание чтения файла двухфазного состояния."

#. +> REL_10
#: monitoring.xml:1557(literal)
msgid "TwophaseFileSync"
msgstr "TwophaseFileSync"

#. +> REL_10
#: monitoring.xml:1558(entry)
msgid "Waiting for a two phase state file to reach stable storage."
msgstr "Ожидание помещения файла двухфазного состояния в надёжное хранилище."

#. +> REL_10
#: monitoring.xml:1561(literal)
msgid "TwophaseFileWrite"
msgstr "TwophaseFileWrite"

#. +> REL_10
#: monitoring.xml:1562(entry)
msgid "Waiting for a write of a two phase state file."
msgstr "Ожидание записи файла двухфазного состояния."

#. +> REL_10
#: monitoring.xml:1565(literal)
msgid "WALBootstrapSync"
msgstr "WALBootstrapSync"

#. +> REL_10
#: monitoring.xml:1566(entry)
msgid "Waiting for WAL to reach stable storage during bootstrapping."
msgstr ""
"Ожидание помещения WAL в надёжное хранилище в процессе начальной загрузки."

#. +> REL_10
#: monitoring.xml:1569(literal)
msgid "WALBootstrapWrite"
msgstr "WALBootstrapWrite"

#. +> REL_10
#: monitoring.xml:1570(entry)
msgid "Waiting for a write of a WAL page during bootstrapping."
msgstr "Ожидание записи страницы WAL в процессе начальной загрузки."

#. +> REL_10
#: monitoring.xml:1573(literal)
msgid "WALCopyRead"
msgstr "WALCopyRead"

#. +> REL_10
#: monitoring.xml:1574(entry)
msgid ""
"Waiting for a read when creating a new WAL segment by copying an existing "
"one."
msgstr ""
"Ожидание чтения при создании нового сегмента WAL путём копирования "
"существующего."

#. +> REL_10
#: monitoring.xml:1577(literal)
msgid "WALCopySync"
msgstr "WALCopySync"

#. +> REL_10
#: monitoring.xml:1578(entry)
msgid ""
"Waiting a new WAL segment created by copying an existing one to reach stable "
"storage."
msgstr ""
"Ожидание помещения в надёжное хранилище нового сегмента WAL, созданного "
"путём копирования существующего."

#. +> REL_10
#: monitoring.xml:1581(literal)
msgid "WALCopyWrite"
msgstr "WALCopyWrite"

#. +> REL_10
#: monitoring.xml:1582(entry)
msgid ""
"Waiting for a write when creating a new WAL segment by copying an existing "
"one."
msgstr ""
"Ожидание записи при создании нового сегмента WAL путём копирования "
"существующего."

#. +> REL_10
#: monitoring.xml:1585(literal)
msgid "WALInitSync"
msgstr "WALInitSync"

#. +> REL_10
#: monitoring.xml:1586(entry)
msgid "Waiting for a newly initialized WAL file to reach stable storage."
msgstr ""
"Ожидание помещения в надёжное хранилище нового инициализированного файла WAL."

#. +> REL_10
#: monitoring.xml:1589(literal)
msgid "WALInitWrite"
msgstr "WALInitWrite"

#. +> REL_10
#: monitoring.xml:1590(entry)
msgid "Waiting for a write while initializing a new WAL file."
msgstr "Ожидание записи при инициализации нового файла WAL."

#. +> REL_10
#: monitoring.xml:1593(literal)
msgid "WALRead"
msgstr "WALRead"

#. +> REL_10
#: monitoring.xml:1594(entry)
msgid "Waiting for a read from a WAL file."
msgstr "Ожидание чтения из файла WAL."

#. +> REL_10
#: monitoring.xml:1597(literal)
msgid "WALSenderTimelineHistoryRead"
msgstr "WALSenderTimelineHistoryRead"

#. +> REL_10
#: monitoring.xml:1598(entry)
msgid ""
"Waiting for a read from a timeline history file during walsender timeline "
"command."
msgstr ""
"Ожидание чтения из файла истории линии времени при обработки процессом "
"walsender команды timeline."

#. +> REL_10
#: monitoring.xml:1601(literal)
msgid "WALSyncMethodAssign"
msgstr "WALSyncMethodAssign"

#. +> REL_10
#: monitoring.xml:1602(entry)
msgid ""
"Waiting for data to reach stable storage while assigning WAL sync method."
msgstr ""
"Ожидание помещения данных в надёжное хранилище при смене метода "
"синхронизации WAL."

#. +> REL_10
#: monitoring.xml:1605(literal)
msgid "WALWrite"
msgstr "WALWrite"

#. +> REL_10
#: monitoring.xml:1606(entry)
msgid "Waiting for a write to a WAL file."
msgstr "Ожидание записи в файл WAL."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1613(para)
msgid ""
"For tranches registered by extensions, the name is specified by extension "
"and this will be displayed as <structfield>wait_event</structfield>. It is "
"quite possible that user has registered the tranche in one of the backends "
"(by having allocation in dynamic shared memory) in which case other backends "
"won't have that information, so we display <literal>extension</literal> for "
"such cases."
msgstr ""
"Для траншей, регистрируемых расширениями, в поле <structfield>wait_event</"
"structfield> выводится имя, указываемое расширением. Пользователь вполне "
"может зарегистрировать транш и в обслуживающем процессе (воспользовавшись "
"динамической общей памятью), в результате чего другие процессы не получат "
"доступа к этой информации; в таких случаях в этом поле выводится "
"<literal>extension</literal>."

#. +> REL_10
#: monitoring.xml:1626(programlisting)
#, no-wrap
msgid ""
"SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;\n"
" pid  | wait_event_type |  wait_event\n"
"------+-----------------+---------------\n"
" 2540 | Lock            | relation\n"
" 6644 | LWLock          | ProcArrayLock\n"
"(2 rows)"
msgstr ""
"SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;\n"
" pid  | wait_event_type |  wait_event\n"
"------+-----------------+---------------\n"
" 2540 | Lock            | relation\n"
" 6644 | LWLock          | ProcArrayLock\n"
"(2 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1623(para)
msgid "Here is an example of how wait events can be viewed <placeholder-1/>"
msgstr ""
"Следующая команда показывает, как можно просмотреть события ожидания: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1637(title)
msgid "<structname>pg_stat_replication</structname> View"
msgstr "Представление <structname>pg_stat_replication</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1651(entry)
msgid "Process ID of a WAL sender process"
msgstr "Идентификатор процесса-передатчика WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1656(entry)
msgid "OID of the user logged into this WAL sender process"
msgstr "OID пользователя, подключённого к этому процессу-передатчику WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1661(entry)
msgid "Name of the user logged into this WAL sender process"
msgstr "Имя пользователя, подключённого к этому процессу-передатчику WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1666(entry)
msgid "Name of the application that is connected to this WAL sender"
msgstr "Имя приложения, которое подключено к этому процессу-передатчику WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1672(entry)
msgid ""
"IP address of the client connected to this WAL sender. If this field is "
"null, it indicates that the client is connected via a Unix socket on the "
"server machine."
msgstr ""
"IP-адрес клиента, подключённого к этому процессу-передатчику WAL. Значение "
"null в этом поле говорит о том, что клиент подсоединён через сокет Unix на "
"сервере."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1689(entry)
msgid ""
"TCP port number that the client is using for communication with this WAL "
"sender, or <literal>-1</literal> if a Unix socket is used"
msgstr ""
"Номер TCP-порта, который используется клиентом для взаимодействия с "
"процессом-передатчиком WAL, или <literal>-1</literal>, если используется "
"сокет Unix"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1696(entry)
msgid ""
"Time when this process was started, i.e., when the client connected to this "
"WAL sender"
msgstr ""
"Время запуска процесса, т. е. время подключения клиента к этому процессу-"
"передатчику WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1703(entry)
msgid ""
"This standby's <literal>xmin</literal> horizon reported by <xref linkend="
"\"guc-hot-standby-feedback\"/>."
msgstr ""
"Значение <literal>xmin</literal>, полученное от ведомого сервера при "
"включённом <xref linkend=\"guc-hot-standby-feedback\"/>."

#. +> REL_10
#: monitoring.xml:1713(para)
msgid "<literal>startup</literal>: This WAL sender is starting up."
msgstr "<literal>startup</literal>: Передатчик WAL запускается."

#. +> REL_10
#: monitoring.xml:1718(para)
msgid ""
"<literal>catchup</literal>: This WAL sender's connected standby is catching "
"up with the primary."
msgstr ""
"<literal>catchup</literal>: Подключённый к этому передатчику WAL ведомый "
"сервер догоняет ведущий."

#. +> REL_10
#: monitoring.xml:1724(para)
msgid ""
"<literal>streaming</literal>: This WAL sender is streaming changes after its "
"connected standby server has caught up with the primary."
msgstr ""
"<literal>streaming</literal>: Передатчик WAL транслирует изменения после "
"того, как подключённый к нему ведомый сервер нагнал ведущий."

#. +> REL_10
#: monitoring.xml:1730(para)
msgid "<literal>backup</literal>: This WAL sender is sending a backup."
msgstr "<literal>backup</literal>: Передатчик WAL передаёт резервную копию."

#. +> REL_10
#: monitoring.xml:1735(para)
msgid "<literal>stopping</literal>: This WAL sender is stopping."
msgstr "<literal>stopping</literal>: Передатчик WAL останавливается."

#. +> REL_10
#: monitoring.xml:1709(entry)
msgid "Current WAL sender state. Possible values are: <placeholder-1/>"
msgstr ""
"Текущее состояние процесса-передатчика WAL. Возможные значения: "
"<placeholder-1/>"

#. +> REL_10
#: monitoring.xml:1743(structfield)
msgid "sent_lsn"
msgstr "sent_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1744(type) monitoring.xml:1749(type)
#: monitoring.xml:1755(type) monitoring.xml:1761(type)
#: monitoring.xml:1908(type) monitoring.xml:1919(type)
#: monitoring.xml:1944(type) monitoring.xml:2010(type)
#: monitoring.xml:2027(type)
msgid "pg_lsn"
msgstr "pg_lsn"

#. +> REL_10
#: monitoring.xml:1745(entry)
msgid "Last write-ahead log location sent on this connection"
msgstr ""
"Последняя позиция в журнале предзаписи, переданная через это соединение"

#. +> REL_10
#: monitoring.xml:1748(structfield)
msgid "write_lsn"
msgstr "write_lsn"

#. +> REL_10
#: monitoring.xml:1750(entry)
msgid "Last write-ahead log location written to disk by this standby server"
msgstr ""
"Последняя позиция в журнале предзаписи, записанная на диск этим ведомым "
"сервером"

#. +> REL_10
#: monitoring.xml:1754(structfield)
msgid "flush_lsn"
msgstr "flush_lsn"

#. +> REL_10
#: monitoring.xml:1756(entry)
msgid "Last write-ahead log location flushed to disk by this standby server"
msgstr ""
"Последняя позиция в журнале предзаписи, сброшенная на диск этим ведомым "
"сервером"

#. +> REL_10
#: monitoring.xml:1760(structfield)
msgid "replay_lsn"
msgstr "replay_lsn"

#. +> REL_10
#: monitoring.xml:1762(entry)
msgid ""
"Last write-ahead log location replayed into the database on this standby "
"server"
msgstr ""
"Последняя позиция в журнале предзаписи, воспроизведённая в базе данных этим "
"ведомым сервером"

#. +> REL_10
#: monitoring.xml:1766(structfield)
msgid "write_lag"
msgstr "write_lag"

#. +> REL_10
#: monitoring.xml:1767(type) monitoring.xml:1777(type)
#: monitoring.xml:1787(type)
msgid "interval"
msgstr "interval"

#. +> REL_10
#: monitoring.xml:1768(entry)
msgid ""
"Time elapsed between flushing recent WAL locally and receiving notification "
"that this standby server has written it (but not yet flushed it or applied "
"it). This can be used to gauge the delay that <literal>synchronous_commit</"
"literal> level <literal>remote_write</literal> incurred while committing if "
"this server was configured as a synchronous standby."
msgstr ""
"Время, прошедшее с момента локального сброса последних данных WAL до "
"получения уведомления о том, что этот ведомый сервер записал их (но ещё не "
"сбросил на диск и не применил). Это позволяет оценить задержку, возникающую "
"при фиксации транзакции, когда в <literal>synchronous_commit</literal> "
"выбран уровень <literal>remote_write</literal>, если данный сервер будет "
"настроен как синхронный ведомый."

#. +> REL_10
#: monitoring.xml:1776(structfield)
msgid "flush_lag"
msgstr "flush_lag"

#. +> REL_10
#: monitoring.xml:1778(entry)
msgid ""
"Time elapsed between flushing recent WAL locally and receiving notification "
"that this standby server has written and flushed it (but not yet applied "
"it). This can be used to gauge the delay that <literal>synchronous_commit</"
"literal> level <literal>remote_flush</literal> incurred while committing if "
"this server was configured as a synchronous standby."
msgstr ""
"Время, прошедшее с момента локального сброса последних данных WAL до "
"получения уведомления о том, что этот ведомый сервер записал и сбросил их на "
"диск (но ещё не применил). Это позволяет оценить задержку, возникающую при "
"фиксации транзакции, когда в <literal>synchronous_commit</literal> выбран "
"уровень <literal>remote_flush</literal>, если данный сервер будет настроен "
"как синхронный ведомый."

#. +> REL_10
#: monitoring.xml:1786(structfield)
msgid "replay_lag"
msgstr "replay_lag"

#. +> REL_10
#: monitoring.xml:1788(entry)
msgid ""
"Time elapsed between flushing recent WAL locally and receiving notification "
"that this standby server has written, flushed and applied it. This can be "
"used to gauge the delay that <literal>synchronous_commit</literal> level "
"<literal>remote_apply</literal> incurred while committing if this server was "
"configured as a synchronous standby."
msgstr ""
"Время, прошедшее с момента локального сброса последних данных WAL до "
"получения уведомления о том, что этот ведомый сервер записал, сбросил на "
"диск и применил их. Это позволяет оценить задержку, возникающую при фиксации "
"транзакции, когда в <literal>synchronous_commit</literal> выбран уровень "
"<literal>remote_apply</literal>, если данный сервер будет настроен как "
"синхронный ведомый."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1796(structfield)
msgid "sync_priority"
msgstr "sync_priority"

#. +> REL_10
#: monitoring.xml:1798(entry)
msgid ""
"Priority of this standby server for being chosen as the synchronous standby "
"in a priority-based synchronous replication. This has no effect in a quorum-"
"based synchronous replication."
msgstr ""
"Приоритет этого ведомого сервера для выбора в качестве синхронного ведомого "
"при синхронной репликации с учётом приоритетов. При синхронной репликации с "
"учётом кворума не имеет значения."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1803(structfield)
msgid "sync_state"
msgstr "sync_state"

#. +> REL_10
#: monitoring.xml:1809(para)
msgid "<literal>async</literal>: This standby server is asynchronous."
msgstr "<literal>async</literal>: Этот ведомый сервер является асинхронным."

#. +> REL_10
#: monitoring.xml:1814(para)
msgid ""
"<literal>potential</literal>: This standby server is now asynchronous, but "
"can potentially become synchronous if one of current synchronous ones fails."
msgstr ""
"<literal>potential</literal>: Этот ведомый сервер сейчас является "
"асинхронным, но может стать синхронным в случае отказа одного из текущих "
"синхронных серверов."

#. +> REL_10
#: monitoring.xml:1821(para)
msgid "<literal>sync</literal>: This standby server is synchronous."
msgstr "<literal>sync</literal>: Этот ведомый сервер является синхронным."

#. +> REL_10
#: monitoring.xml:1826(para)
msgid ""
"<literal>quorum</literal>: This standby server is considered as a candidate "
"for quorum standbys."
msgstr ""
"<literal>quorum</literal>: Этот ведомый сервер считается кандитатом на "
"участие в кворуме."

#. +> REL_10
#: monitoring.xml:1805(entry)
msgid ""
"Synchronous state of this standby server. Possible values are: "
"<placeholder-1/>"
msgstr ""
"Состояние синхронизации этого ведомого сервера. Возможные значения: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1838(para)
msgid ""
"The <structname>pg_stat_replication</structname> view will contain one row "
"per WAL sender process, showing statistics about replication to that "
"sender's connected standby server. Only directly connected standbys are "
"listed; no information is available about downstream standby servers."
msgstr ""
"Представление <structname>pg_stat_replication</structname> для каждого "
"процесса-передатчика WAL будет содержать по одной строке со статистикой о "
"репликации на ведомый сервер, к которому подключён этот процесс. В "
"представлении перечисляются только ведомые серверы, подключённые напрямую; "
"информация о ведомых серверах, подключённых опосредованно, не представлена."

#. +> REL_10
#: monitoring.xml:1845(para)
msgid ""
"The lag times reported in the <structname>pg_stat_replication</structname> "
"view are measurements of the time taken for recent WAL to be written, "
"flushed and replayed and for the sender to know about it. These times "
"represent the commit delay that was (or would have been) introduced by each "
"synchronous commit level, if the remote server was configured as a "
"synchronous standby. For an asynchronous standby, the "
"<structfield>replay_lag</structfield> column approximates the delay before "
"recent transactions became visible to queries. If the standby server has "
"entirely caught up with the sending server and there is no more WAL "
"activity, the most recently measured lag times will continue to be displayed "
"for a short time and then show NULL."
msgstr ""
"Длительность задержек, показываемая в представлении "
"<structname>pg_stat_replication</structname>, включает время, которое "
"потребовалось для того, чтобы записать, сбросить на диск и воспроизвести "
"последние записи WAL и для того, чтобы передатчик WAL узнал об этом. Эта "
"длительность отражает задержку фиксации, которая была (или могла быть) "
"добавлена на уровнях синхронной фиксации, если ведомый сервер был настроен "
"как синхронный. Для асинхронного ведомого в столбце <structfield>replay_lag</"
"structfield> показывается примерная задержка перед тем, как последние "
"транзакции становятся видны для запросов. Если ведомый сервер нагоняет "
"передающий и в WAL отсутствует активность, последние длительности задержек "
"будут отображаться ещё некоторое время, а затем сменятся на NULL."

#. +> REL_10
#: monitoring.xml:1859(para)
msgid ""
"Lag times work automatically for physical replication. Logical decoding "
"plugins may optionally emit tracking messages; if they do not, the tracking "
"mechanism will simply display NULL lag."
msgstr ""
"Длительность задержек автоматически определяется при физической репликации. "
"Модули логического декодирования могут не выдавать необходимые контрольные "
"сообщения; в их отсутствие механизм отслеживания просто выводит задержку "
"NULL."

#. +> REL_10
#: monitoring.xml:1866(para)
msgid ""
"The reported lag times are not predictions of how long it will take for the "
"standby to catch up with the sending server assuming the current rate of "
"replay. Such a system would show similar times while new WAL is being "
"generated, but would differ when the sender becomes idle. In particular, "
"when the standby has caught up completely, <structname>pg_stat_replication</"
"structname> shows the time taken to write, flush and replay the most recent "
"reported WAL location rather than zero as some users might expect. This is "
"consistent with the goal of measuring synchronous commit and transaction "
"visibility delays for recent write transactions. To reduce confusion for "
"users expecting a different model of lag, the lag columns revert to NULL "
"after a short time on a fully replayed idle system. Monitoring systems "
"should choose whether to represent this as missing data, zero or continue to "
"display the last known value."
msgstr ""
"Выдаваемые длительности задержек не являются предсказанием времени, которое "
"потребуется ведомому серверу, чтобы нагнать передающий сервер с учётом "
"текущей скорости воспроизведения. Эти показатели будут близки в процессе "
"генерирования нового WAL, но не в то время, когда передающий сервер будет "
"простаивать. В частности, когда ведомый сервер нагоняет ведущий, в "
"<structname>pg_stat_replication</structname> показывается, сколько времени "
"потребовалось для записи, сброса на диск и воспроизведения последних данных "
"WAL, а не 0, как могли ожидать некоторые пользователи. Это соответствует "
"задаче измерения задержек синхронной фиксации и видимости транзакций для "
"недавно записанных транзакций. Чтобы меньше смущать пользователей, ожидающих "
"видеть другую модель задержек, столбцы задержек сбрасываются в NULL после "
"небольшой паузы в системе, которая воспроизвела все изменения и теперь "
"простаивает. Системы мониторинга могут представлять это как отсутствующие "
"данные, 0 или продолжать показывать последнее известное значение."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1885(title)
msgid "<structname>pg_stat_wal_receiver</structname> View"
msgstr "Представление <structname>pg_stat_wal_receiver</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1899(entry)
msgid "Process ID of the WAL receiver process"
msgstr "Идентификатор процесса WAL-приёмника"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1902(structfield)
msgid "status"
msgstr "status"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1904(entry)
msgid "Activity status of the WAL receiver process"
msgstr "Состояние активности процесса WAL-приёмника"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1907(structfield)
msgid "receive_start_lsn"
msgstr "receive_start_lsn"

#. +> REL_10
#: monitoring.xml:1909(entry)
msgid "First write-ahead log location used when WAL receiver is started"
msgstr "Первая позиция в журнале предзаписи в момент запуска приёмника WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1913(structfield)
msgid "receive_start_tli"
msgstr "receive_start_tli"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1915(entry)
msgid "First timeline number used when WAL receiver is started"
msgstr "Первый номер линии времени в момент запуска приёмника WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1918(structfield) monitoring.xml:2009(structfield)
msgid "received_lsn"
msgstr "received_lsn"

#. +> REL_10
#: monitoring.xml:1920(entry)
msgid ""
"Last write-ahead log location already received and flushed to disk, the "
"initial value of this field being the first log location used when WAL "
"receiver is started"
msgstr ""
"Последняя позиция в журнале предзаписи, уже полученная и сброшенная на диск; "
"начальным значением этого поля будет первая позиция в журнале в момент "
"запуска приёмника WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1925(structfield)
msgid "received_tli"
msgstr "received_tli"

#. +> REL_10
#: monitoring.xml:1927(entry)
msgid ""
"Timeline number of last write-ahead log location received and flushed to "
"disk, the initial value of this field being the timeline number of the first "
"log location used when WAL receiver is started"
msgstr ""
"Номер линии времени последней позиции в журнале предзаписи, уже полученной и "
"сброшенной на диск; начальным значением этого поля будет номер линии времени "
"первой позиции в момент запуска приёмника WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1933(structfield) monitoring.xml:2015(structfield)
msgid "last_msg_send_time"
msgstr "last_msg_send_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1935(entry) monitoring.xml:2017(entry)
msgid "Send time of last message received from origin WAL sender"
msgstr ""
"Время отправки последнего сообщения, полученного от изначального передатчика "
"WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1938(structfield) monitoring.xml:2020(structfield)
msgid "last_msg_receipt_time"
msgstr "last_msg_receipt_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1940(entry) monitoring.xml:2022(entry)
msgid "Receipt time of last message received from origin WAL sender"
msgstr ""
"Время поступления последнего сообщения, полученного от изначального "
"передатчика WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1943(structfield) monitoring.xml:2026(structfield)
msgid "latest_end_lsn"
msgstr "latest_end_lsn"

#. +> REL_10
#: monitoring.xml:1945(entry) monitoring.xml:2028(entry)
msgid "Last write-ahead log location reported to origin WAL sender"
msgstr ""
"Последняя позиция в журнале предзаписи, сообщённая изначальному передатчику "
"WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1948(structfield) monitoring.xml:2032(structfield)
msgid "latest_end_time"
msgstr "latest_end_time"

#. +> REL_10
#: monitoring.xml:1950(entry) monitoring.xml:2034(entry)
msgid "Time of last write-ahead log location reported to origin WAL sender"
msgstr ""
"Время последней позиции в журнале предзаписи, сообщённой изначальному "
"передатчику WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1953(structfield)
msgid "slot_name"
msgstr "slot_name"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1955(entry)
msgid "Replication slot name used by this WAL receiver"
msgstr "Имя слота репликации, используемого этим приёмником WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1958(structfield)
msgid "conninfo"
msgstr "conninfo"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1960(entry)
msgid ""
"Connection string used by this WAL receiver, with security-sensitive fields "
"obfuscated."
msgstr ""
"Строка подключения, используемая этим приёмником WAL (секретные поля в ней "
"скрыты)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:1969(para)
msgid ""
"The <structname>pg_stat_wal_receiver</structname> view will contain only one "
"row, showing statistics about the WAL receiver from that receiver's "
"connected server."
msgstr ""
"Представление <structname>pg_stat_wal_receiver</structname> будет иметь "
"только одну строку со статистикой приёмника WAL от сервера, на котором "
"работает приёмник."

#. +> REL_10
#: monitoring.xml:1976(title)
msgid "<structname>pg_stat_subscription</structname> View"
msgstr "Представление <structname>pg_stat_subscription</structname>"

#. +> REL_10
#: monitoring.xml:1988(structfield)
msgid "subid"
msgstr "subid"

#. +> REL_10
#: monitoring.xml:1990(entry)
msgid "OID of the subscription"
msgstr "OID подписки"

#. +> REL_10
#: monitoring.xml:1993(structfield)
msgid "subname"
msgstr "subname"

#. +> REL_10
#: monitoring.xml:1995(entry)
msgid "Name of the subscription"
msgstr "Имя подписки"

#. +> REL_10
#: monitoring.xml:2000(entry)
msgid "Process ID of the subscription worker process"
msgstr "Идентификатор рабочего процесса, обслуживающего подписку"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2003(structfield) monitoring.xml:2476(structfield)
#: monitoring.xml:2619(structfield) monitoring.xml:2715(structfield)
#: monitoring.xml:2796(structfield) monitoring.xml:2857(structfield)
#: monitoring.xml:3288(structfield)
msgid "relid"
msgstr "relid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2004(type) monitoring.xml:3953(type)
msgid "Oid"
msgstr "Oid"

#. +> REL_10
#: monitoring.xml:2005(entry)
msgid ""
"OID of the relation that the worker is synchronizing; null for the main "
"apply worker"
msgstr ""
"OID отношения, которое синхронизирует рабочий процесс сейчас; null для "
"основного процесса применения изменений"

#. +> REL_10
#: monitoring.xml:2011(entry)
msgid ""
"Last write-ahead log location received, the initial value of this field "
"being 0"
msgstr ""
"Последняя позиция в журнале предзаписи (начальное значение этого поля — 0)"

#. +> REL_10
#: monitoring.xml:2041(para)
msgid ""
"The <structname>pg_stat_subscription</structname> view will contain one row "
"per subscription for main worker (with null PID if the worker is not "
"running), and additional rows for workers handling the initial data copy of "
"the subscribed tables."
msgstr ""
"Представление <structname>pg_stat_subscription</structname> содержит по "
"одной строке для подписки для основного рабочего процесса (с NULL в PID, "
"если процесс не работает) и дополнительные строки для рабочих процессов, "
"осуществляющих копирование начальных данных для таблиц в подписке."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2049(title)
msgid "<structname>pg_stat_ssl</structname> View"
msgstr "Представление <structname>pg_stat_ssl</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2063(entry)
msgid "Process ID of a backend or WAL sender process"
msgstr "Идентификатор обслуживающего процесса или процесса, передающего WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2066(structfield)
msgid "ssl"
msgstr "ssl"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2067(type) monitoring.xml:2090(type)
msgid "boolean"
msgstr "boolean"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2068(entry)
msgid "True if SSL is used on this connection"
msgstr "True, если для этого подключения используется SSL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2071(structfield)
msgid "version"
msgstr "version"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2073(entry)
msgid "Version of SSL in use, or NULL if SSL is not in use on this connection"
msgstr "Версия SSL либо NULL, если SSL для этого подключения не используется"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2077(structfield)
msgid "cipher"
msgstr "cipher"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2079(entry)
msgid ""
"Name of SSL cipher in use, or NULL if SSL is not in use on this connection"
msgstr ""
"Имя применяемого шифра SSL либо NULL, если SSL для этого подключения не "
"используется"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2083(structfield)
msgid "bits"
msgstr "bits"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2085(entry)
msgid ""
"Number of bits in the encryption algorithm used, or NULL if SSL is not used "
"on this connection"
msgstr ""
"Число бит в применяемом алгоритме шифрования либо NULL, если SSL для этого "
"подключения не используется"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2089(structfield)
msgid "compression"
msgstr "compression"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2091(entry)
msgid ""
"True if SSL compression is in use, false if not, or NULL if SSL is not in "
"use on this connection"
msgstr ""
"True, если применяется сжатие SSL, false в противном случае, либо NULL, если "
"SSL для этого подключения не используется"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2095(structfield)
msgid "clientdn"
msgstr "clientdn"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2097(entry)
msgid ""
"Distinguished Name (DN) field from the client certificate used, or NULL if "
"no client certificate was supplied or if SSL is not in use on this "
"connection. This field is truncated if the DN field is longer than "
"<symbol>NAMEDATALEN</symbol> (64 characters in a standard build)"
msgstr ""
"Поле DN (Distinguished Name, Уникальное имя) из используемого клиентского "
"сертификата либо NULL, если клиент не передал сертификат или SSL для этого "
"подключения не используется. Это значение усекается, если поле DN "
"оказывается длиннее <symbol>NAMEDATALEN</symbol> символов (64 символов в "
"стандартной сборке)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2108(para)
msgid ""
"The <structname>pg_stat_ssl</structname> view will contain one row per "
"backend or WAL sender process, showing statistics about SSL usage on this "
"connection. It can be joined to <structname>pg_stat_activity</structname> or "
"<structname>pg_stat_replication</structname> on the <structfield>pid</"
"structfield> column to get more details about the connection."
msgstr ""
"Представление <structname>pg_stat_ssl</structname> содержит по одной строке "
"для каждого обслуживающего процесса и процесса, передающего WAL, и "
"показывает статистику использования SSL для подключений. Его можно соединить "
"с <structname>pg_stat_activity</structname> или "
"<structname>pg_stat_replication</structname> по столбцу <structfield>pid</"
"structfield> и получить дополнительные сведения о подключении."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2119(title)
msgid "<structname>pg_stat_archiver</structname> View"
msgstr "Представление <structname>pg_stat_archiver</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2132(structfield)
msgid "archived_count"
msgstr "archived_count"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2133(type) monitoring.xml:2148(type)
#: monitoring.xml:2190(type) monitoring.xml:2195(type)
#: monitoring.xml:2217(type) monitoring.xml:2222(type)
#: monitoring.xml:2227(type) monitoring.xml:2233(type)
#: monitoring.xml:2238(type) monitoring.xml:2245(type)
#: monitoring.xml:2294(type) monitoring.xml:2300(type)
#: monitoring.xml:2306(type) monitoring.xml:2311(type)
#: monitoring.xml:2319(type) monitoring.xml:2324(type)
#: monitoring.xml:2329(type) monitoring.xml:2334(type)
#: monitoring.xml:2339(type) monitoring.xml:2344(type)
#: monitoring.xml:2352(type) monitoring.xml:2361(type)
#: monitoring.xml:2370(type) monitoring.xml:2423(type)
#: monitoring.xml:2429(type) monitoring.xml:2435(type)
#: monitoring.xml:2441(type) monitoring.xml:2447(type)
#: monitoring.xml:2492(type) monitoring.xml:2497(type)
#: monitoring.xml:2502(type) monitoring.xml:2507(type)
#: monitoring.xml:2512(type) monitoring.xml:2517(type)
#: monitoring.xml:2522(type) monitoring.xml:2527(type)
#: monitoring.xml:2533(type) monitoring.xml:2538(type)
#: monitoring.xml:2543(type) monitoring.xml:2571(type)
#: monitoring.xml:2577(type) monitoring.xml:2583(type)
#: monitoring.xml:2588(type) monitoring.xml:2645(type)
#: monitoring.xml:2650(type) monitoring.xml:2655(type)
#: monitoring.xml:2731(type) monitoring.xml:2736(type)
#: monitoring.xml:2741(type) monitoring.xml:2746(type)
#: monitoring.xml:2751(type) monitoring.xml:2756(type)
#: monitoring.xml:2761(type) monitoring.xml:2766(type)
#: monitoring.xml:2822(type) monitoring.xml:2827(type)
#: monitoring.xml:2873(type) monitoring.xml:2878(type)
#: monitoring.xml:2920(type) monitoring.xml:3301(type)
#: monitoring.xml:3310(type) monitoring.xml:3322(type)
#: monitoring.xml:3332(type) monitoring.xml:3339(type)
#: monitoring.xml:3348(type)
msgid "bigint"
msgstr "bigint"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2134(entry)
msgid "Number of WAL files that have been successfully archived"
msgstr "Число файлов WAL, которые были успешно архивированы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2137(structfield)
msgid "last_archived_wal"
msgstr "last_archived_wal"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2139(entry)
msgid "Name of the last WAL file successfully archived"
msgstr "Имя последнего файла WAL успешно архивированного"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2142(structfield)
msgid "last_archived_time"
msgstr "last_archived_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2144(entry)
msgid "Time of the last successful archive operation"
msgstr "Время последней успешной архивации"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2147(structfield)
msgid "failed_count"
msgstr "failed_count"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2149(entry)
msgid "Number of failed attempts for archiving WAL files"
msgstr "Число неудачных попыток архивации файлов WAL"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2152(structfield)
msgid "last_failed_wal"
msgstr "last_failed_wal"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2154(entry)
msgid "Name of the WAL file of the last failed archival operation"
msgstr "Имя файла WAL последней неудавшейся архивации"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2157(structfield)
msgid "last_failed_time"
msgstr "last_failed_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2159(entry)
msgid "Time of the last failed archival operation"
msgstr "Время последней неудавшейся архивации"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2162(structfield) monitoring.xml:2249(structfield)
#: monitoring.xml:2386(structfield)
msgid "stats_reset"
msgstr "stats_reset"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2164(entry) monitoring.xml:2251(entry)
#: monitoring.xml:2388(entry)
msgid "Time at which these statistics were last reset"
msgstr "Последнее время сброса этих статистических данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2170(para)
msgid ""
"The <structname>pg_stat_archiver</structname> view will always have a single "
"row, containing data about the archiver process of the cluster."
msgstr ""
"Представление <structname>pg_stat_archiver</structname> всегда будет иметь "
"одну строку, содержащую данные о текущем состоянии процесса архивации "
"кластера."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2176(title)
msgid "<structname>pg_stat_bgwriter</structname> View"
msgstr "Представление <structname>pg_stat_bgwriter</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2189(structfield)
msgid "checkpoints_timed"
msgstr "checkpoints_timed"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2191(entry)
msgid "Number of scheduled checkpoints that have been performed"
msgstr ""
"Количество запланированных контрольных точек, которые уже были выполнены"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2194(structfield)
msgid "checkpoints_req"
msgstr "checkpoints_req"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2196(entry)
msgid "Number of requested checkpoints that have been performed"
msgstr "Количество запрошенных контрольных точек, которые уже были выполнены"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2199(structfield)
msgid "checkpoint_write_time"
msgstr "checkpoint_write_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2200(type) monitoring.xml:2208(type)
#: monitoring.xml:2375(type) monitoring.xml:2381(type)
#: monitoring.xml:2925(type) monitoring.xml:2931(type)
msgid "double precision"
msgstr "double precision"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2201(entry)
msgid ""
"Total amount of time that has been spent in the portion of checkpoint "
"processing where files are written to disk, in milliseconds"
msgstr ""
"Общее время, которое было затрачено на этап обработки контрольной точки, в "
"котором файлы записываются на диск, в миллисекундах"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2207(structfield)
msgid "checkpoint_sync_time"
msgstr "checkpoint_sync_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2209(entry)
msgid ""
"Total amount of time that has been spent in the portion of checkpoint "
"processing where files are synchronized to disk, in milliseconds"
msgstr ""
"Общее время, которое было затрачено на этап обработки контрольной точки, в "
"котором файлы синхронизируются с диском, в миллисекундах"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2216(structfield)
msgid "buffers_checkpoint"
msgstr "buffers_checkpoint"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2218(entry)
msgid "Number of buffers written during checkpoints"
msgstr "Количество буферов, записанных при выполнении контрольных точек"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2221(structfield)
msgid "buffers_clean"
msgstr "buffers_clean"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2223(entry)
msgid "Number of buffers written by the background writer"
msgstr "Количество буферов, записанных фоновым процессом записи"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2226(structfield)
msgid "maxwritten_clean"
msgstr "maxwritten_clean"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2228(entry)
msgid ""
"Number of times the background writer stopped a cleaning scan because it had "
"written too many buffers"
msgstr ""
"Сколько раз фоновый процесс записи останавливал сброс грязных страниц на "
"диск из-за того, что записал слишком много буферов"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2232(structfield)
msgid "buffers_backend"
msgstr "buffers_backend"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2234(entry)
msgid "Number of buffers written directly by a backend"
msgstr "Количество буферов, записанных самим серверным процессом"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2237(structfield)
msgid "buffers_backend_fsync"
msgstr "buffers_backend_fsync"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2239(entry)
msgid ""
"Number of times a backend had to execute its own <function>fsync</function> "
"call (normally the background writer handles those even when the backend "
"does its own write)"
msgstr ""
"Сколько раз серверному процессу пришлось выполнить <function>fsync</"
"function> самостоятельно (обычно фоновый процесс записи сам обрабатывает эти "
"вызовы, даже когда серверный процесс выполняет запись самостоятельно)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2244(structfield)
msgid "buffers_alloc"
msgstr "buffers_alloc"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2246(entry)
msgid "Number of buffers allocated"
msgstr "Количество выделенных буферов"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2257(para)
msgid ""
"The <structname>pg_stat_bgwriter</structname> view will always have a single "
"row, containing global data for the cluster."
msgstr ""
"В представлении <structname>pg_stat_bgwriter</structname> всегда будет "
"только одна строка, в которой будут представлены общие данные по всему "
"кластеру."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2263(title)
msgid "<structname>pg_stat_database</structname> View"
msgstr "Представление <structname>pg_stat_database</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2277(entry) monitoring.xml:2414(entry)
msgid "OID of a database"
msgstr "OID базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2282(entry) monitoring.xml:2419(entry)
msgid "Name of this database"
msgstr "Имя базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2285(structfield)
msgid "numbackends"
msgstr "numbackends"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2287(entry)
msgid ""
"Number of backends currently connected to this database. This is the only "
"column in this view that returns a value reflecting current state; all other "
"columns return the accumulated values since the last reset."
msgstr ""
"Количество серверных процессов, в настоящее время подключённых к этой базе "
"данных. Это единственный столбец в этом представлении, значение в котором "
"отражает текущее состояние; все другие столбцы возвращают суммарные значения "
"со времени последнего сброса статистики."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2293(structfield)
msgid "xact_commit"
msgstr "xact_commit"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2295(entry)
msgid "Number of transactions in this database that have been committed"
msgstr "Количество зафиксированных транзакций в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2299(structfield)
msgid "xact_rollback"
msgstr "xact_rollback"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2301(entry)
msgid "Number of transactions in this database that have been rolled back"
msgstr ""
"Количество транзакций в этой базе данных, для которых был выполнен откат "
"транзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2305(structfield) monitoring.xml:2872(structfield)
msgid "blks_read"
msgstr "blks_read"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2307(entry)
msgid "Number of disk blocks read in this database"
msgstr "Количество прочитанных дисковых блоков в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2310(structfield) monitoring.xml:2877(structfield)
msgid "blks_hit"
msgstr "blks_hit"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2312(entry)
msgid ""
"Number of times disk blocks were found already in the buffer cache, so that "
"a read was not necessary (this only includes hits in the PostgreSQL buffer "
"cache, not the operating system's file system cache)"
msgstr ""
"Сколько раз дисковые блоки обнаруживались в буферном кеше, так что чтение с "
"диска не потребовалось (в значение входят только случаи обнаружения в "
"буферном кеше PostgreSQL, а не в кеше файловой системы ОС)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2318(structfield)
msgid "tup_returned"
msgstr "tup_returned"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2320(entry)
msgid "Number of rows returned by queries in this database"
msgstr "Количество строк, возвращённое запросами в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2323(structfield)
msgid "tup_fetched"
msgstr "tup_fetched"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2325(entry)
msgid "Number of rows fetched by queries in this database"
msgstr "Количество строк, извлечённое запросами в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2328(structfield)
msgid "tup_inserted"
msgstr "tup_inserted"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2330(entry)
msgid "Number of rows inserted by queries in this database"
msgstr "Количество строк, вставленное запросами в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2333(structfield)
msgid "tup_updated"
msgstr "tup_updated"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2335(entry)
msgid "Number of rows updated by queries in this database"
msgstr "Количество строк, изменённое запросами в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2338(structfield)
msgid "tup_deleted"
msgstr "tup_deleted"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2340(entry)
msgid "Number of rows deleted by queries in this database"
msgstr "Количество строк, удалённое запросами в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2343(structfield)
msgid "conflicts"
msgstr "conflicts"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2345(entry)
msgid ""
"Number of queries canceled due to conflicts with recovery in this database. "
"(Conflicts occur only on standby servers; see <xref linkend=\"pg-stat-"
"database-conflicts-view\"/> for details.)"
msgstr ""
"Количество запросов, отменённых из-за конфликта с восстановлением в этой "
"базе данных. (Конфликты происходят только на ведомых серверах; более "
"подробно смотрите <xref linkend=\"pg-stat-database-conflicts-view\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2351(structfield)
msgid "temp_files"
msgstr "temp_files"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2353(entry)
msgid ""
"Number of temporary files created by queries in this database. All temporary "
"files are counted, regardless of why the temporary file was created (e.g., "
"sorting or hashing), and regardless of the <xref linkend=\"guc-log-temp-files"
"\"/> setting."
msgstr ""
"Количество временных файлов, созданных запросами в этой базе данных. "
"Подсчитываются все временные файлы независимо от причины их создания "
"(например, для сортировки или для хеширования) и независимо от "
"установленного значения <xref linkend=\"guc-log-temp-files\"/>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2360(structfield)
msgid "temp_bytes"
msgstr "temp_bytes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2362(entry)
msgid ""
"Total amount of data written to temporary files by queries in this database. "
"All temporary files are counted, regardless of why the temporary file was "
"created, and regardless of the <xref linkend=\"guc-log-temp-files\"/> "
"setting."
msgstr ""
"Общий объём данных, записанных во временные файлы запросами в этой базе "
"данных. Учитываются все временные файлы, вне зависимости от того, по какой "
"причине они созданы и вне зависимости от значения <xref linkend=\"guc-log-"
"temp-files\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2369(structfield)
msgid "deadlocks"
msgstr "deadlocks"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2371(entry)
msgid "Number of deadlocks detected in this database"
msgstr "Количество взаимных блокировок, зафиксированное в этой базе данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2374(structfield)
msgid "blk_read_time"
msgstr "blk_read_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2376(entry)
msgid ""
"Time spent reading data file blocks by backends in this database, in "
"milliseconds"
msgstr ""
"Время, затраченное серверными процессами в этой базе данных, на чтение "
"блоков из файлов данных, в миллисекундах"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2380(structfield)
msgid "blk_write_time"
msgstr "blk_write_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2382(entry)
msgid ""
"Time spent writing data file blocks by backends in this database, in "
"milliseconds"
msgstr ""
"Время, затраченное серверными процессами в этой базе данных, на запись "
"блоков в файлы данных, в миллисекундах"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2394(para)
msgid ""
"The <structname>pg_stat_database</structname> view will contain one row for "
"each database in the cluster, showing database-wide statistics."
msgstr ""
"Представление <structname>pg_stat_database</structname> содержит одну строку "
"со статистикой на каждую базу данных кластера."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2400(title)
msgid "<structname>pg_stat_database_conflicts</structname> View"
msgstr "Представление <structname>pg_stat_database_conflicts</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2422(structfield)
msgid "confl_tablespace"
msgstr "confl_tablespace"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2424(entry)
msgid ""
"Number of queries in this database that have been canceled due to dropped "
"tablespaces"
msgstr ""
"Количество запросов в этой базе данных, отменённых из-за того, что табличные "
"пространства были удалены"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2428(structfield)
msgid "confl_lock"
msgstr "confl_lock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2430(entry)
msgid ""
"Number of queries in this database that have been canceled due to lock "
"timeouts"
msgstr ""
"Количество запросов в этой базе данных, отменённых по истечении времени "
"ожидания блокировки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2434(structfield)
msgid "confl_snapshot"
msgstr "confl_snapshot"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2436(entry)
msgid ""
"Number of queries in this database that have been canceled due to old "
"snapshots"
msgstr ""
"Количество запросов в этой базе данных, отменённых из-за устаревших снимков "
"данных"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2440(structfield)
msgid "confl_bufferpin"
msgstr "confl_bufferpin"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2442(entry)
msgid ""
"Number of queries in this database that have been canceled due to pinned "
"buffers"
msgstr ""
"Количество запросов в этой базе данных, отменённых из-за прикреплённых "
"страниц буфера"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2446(structfield)
msgid "confl_deadlock"
msgstr "confl_deadlock"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2448(entry)
msgid ""
"Number of queries in this database that have been canceled due to deadlocks"
msgstr ""
"Количество запросов в этой базе данных, отменённых из-за взаимных блокировок"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2455(para)
msgid ""
"The <structname>pg_stat_database_conflicts</structname> view will contain "
"one row per database, showing database-wide statistics about query cancels "
"occurring due to conflicts with recovery on standby servers. This view will "
"only contain information on standby servers, since conflicts do not occur on "
"master servers."
msgstr ""
"Представление <structname>pg_stat_database_conflicts</structname> для каждой "
"базы данных будет содержать по одной строке со статистикой на уровне базы по "
"отменам запросов, произошедшим вследствие конфликтов с процессами "
"восстановления на ведомых серверах. В этом представлении будет содержаться "
"только информация по ведомым серверам, поскольку на главных серверах "
"конфликты не возникают."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2464(title)
msgid "<structname>pg_stat_all_tables</structname> View"
msgstr "Представление <structname>pg_stat_all_tables</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2478(entry) monitoring.xml:2717(entry)
msgid "OID of a table"
msgstr "OID таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2481(structfield) monitoring.xml:2629(structfield)
#: monitoring.xml:2720(structfield) monitoring.xml:2806(structfield)
#: monitoring.xml:2862(structfield) monitoring.xml:2909(structfield)
msgid "schemaname"
msgstr "schemaname"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2483(entry) monitoring.xml:2722(entry)
msgid "Name of the schema that this table is in"
msgstr "Имя схемы, в которой расположена эта таблица"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2486(structfield) monitoring.xml:2634(structfield)
#: monitoring.xml:2725(structfield) monitoring.xml:2811(structfield)
#: monitoring.xml:2867(structfield)
msgid "relname"
msgstr "relname"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2488(entry) monitoring.xml:2727(entry)
msgid "Name of this table"
msgstr "Имя таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2491(structfield)
msgid "seq_scan"
msgstr "seq_scan"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2493(entry)
msgid "Number of sequential scans initiated on this table"
msgstr "Количество последовательных чтений, запущенных по этой таблице"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2496(structfield)
msgid "seq_tup_read"
msgstr "seq_tup_read"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2498(entry)
msgid "Number of live rows fetched by sequential scans"
msgstr "Количество \"живых\" строк, прочитанных при последовательных чтениях"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2501(structfield) monitoring.xml:2644(structfield)
msgid "idx_scan"
msgstr "idx_scan"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2503(entry)
msgid "Number of index scans initiated on this table"
msgstr "Количество сканирований по индексу, запущенных по этой таблице"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2506(structfield) monitoring.xml:2654(structfield)
msgid "idx_tup_fetch"
msgstr "idx_tup_fetch"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2508(entry)
msgid "Number of live rows fetched by index scans"
msgstr "Количество \"живых\" строк, отобранных при сканированиях по индексу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2511(structfield)
msgid "n_tup_ins"
msgstr "n_tup_ins"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2513(entry)
msgid "Number of rows inserted"
msgstr "Количество вставленных строк"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2516(structfield)
msgid "n_tup_upd"
msgstr "n_tup_upd"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2518(entry)
msgid "Number of rows updated (includes HOT updated rows)"
msgstr "Количество изменённых строк (включая изменения по схеме HOT)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2521(structfield)
msgid "n_tup_del"
msgstr "n_tup_del"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2523(entry)
msgid "Number of rows deleted"
msgstr "Количество удалённых строк"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2526(structfield)
msgid "n_tup_hot_upd"
msgstr "n_tup_hot_upd"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2528(entry)
msgid ""
"Number of rows HOT updated (i.e., with no separate index update required)"
msgstr ""
"Количество строк, обновлённых в режиме HOT (т. е. без отдельного изменения "
"индекса)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2532(structfield)
msgid "n_live_tup"
msgstr "n_live_tup"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2534(entry)
msgid "Estimated number of live rows"
msgstr "Оценочное количество \"живых\" строк"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2537(structfield)
msgid "n_dead_tup"
msgstr "n_dead_tup"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2539(entry)
msgid "Estimated number of dead rows"
msgstr "Оценочное количество \"мёртвых\" строк"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2542(structfield)
msgid "n_mod_since_analyze"
msgstr "n_mod_since_analyze"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2544(entry)
msgid "Estimated number of rows modified since this table was last analyzed"
msgstr ""
"Оценочное число строк, изменённых в этой таблице, с момента последнего сбора "
"статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2547(structfield)
msgid "last_vacuum"
msgstr "last_vacuum"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2549(entry)
msgid ""
"Last time at which this table was manually vacuumed (not counting "
"<command>VACUUM FULL</command>)"
msgstr ""
"Время последней очистки этой таблицы вручную (<command>VACUUM FULL</command> "
"не учитывается)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2553(structfield)
msgid "last_autovacuum"
msgstr "last_autovacuum"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2555(entry)
msgid "Last time at which this table was vacuumed by the autovacuum daemon"
msgstr "Время последней очистки таблицы фоновым процессом автоочистки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2559(structfield)
msgid "last_analyze"
msgstr "last_analyze"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2561(entry)
msgid "Last time at which this table was manually analyzed"
msgstr "Время последнего выполнения сбора статистики для этой таблицы вручную"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2564(structfield)
msgid "last_autoanalyze"
msgstr "last_autoanalyze"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2566(entry)
msgid "Last time at which this table was analyzed by the autovacuum daemon"
msgstr ""
"Время последнего выполнения сбора статистики для этой таблицы фоновым "
"процессом автоочистки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2570(structfield)
msgid "vacuum_count"
msgstr "vacuum_count"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2572(entry)
msgid ""
"Number of times this table has been manually vacuumed (not counting "
"<command>VACUUM FULL</command>)"
msgstr ""
"Сколько раз очистка этой таблицы была выполнена вручную (<command>VACUUM "
"FULL</command> не учитывается)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2576(structfield)
msgid "autovacuum_count"
msgstr "autovacuum_count"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2578(entry)
msgid "Number of times this table has been vacuumed by the autovacuum daemon"
msgstr ""
"Сколько раз очистка этой таблицы была выполнена фоновым процессом автоочистки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2582(structfield)
msgid "analyze_count"
msgstr "analyze_count"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2584(entry)
msgid "Number of times this table has been manually analyzed"
msgstr "Сколько раз сбор статистики для этой таблицы был выполнен вручную"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2587(structfield)
msgid "autoanalyze_count"
msgstr "autoanalyze_count"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2589(entry)
msgid "Number of times this table has been analyzed by the autovacuum daemon"
msgstr ""
"Сколько раз сбор статистики для этой таблицы был выполнен фоновым процессом "
"автоочистки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2596(para)
msgid ""
"The <structname>pg_stat_all_tables</structname> view will contain one row "
"for each table in the current database (including TOAST tables), showing "
"statistics about accesses to that specific table. The "
"<structname>pg_stat_user_tables</structname> and "
"<structname>pg_stat_sys_tables</structname> views contain the same "
"information, but filtered to only show user and system tables respectively."
msgstr ""
"Представление <structname>pg_stat_all_tables</structname> будет содержать по "
"одной строке на каждую таблицу в текущей базе данных (включая таблицы TOAST) "
"со статистикой по обращениям к этой таблице. Представления "
"<structname>pg_stat_user_tables</structname> и "
"<structname>pg_stat_sys_tables</structname> содержат ту же самую информацию, "
"но отфильтрованную так, чтобы показывать только пользовательские и системные "
"таблицы соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2607(title)
msgid "<structname>pg_stat_all_indexes</structname> View"
msgstr "Представление <structname>pg_stat_all_indexes</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2621(entry) monitoring.xml:2798(entry)
msgid "OID of the table for this index"
msgstr "OID таблицы для индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2624(structfield) monitoring.xml:2801(structfield)
msgid "indexrelid"
msgstr "indexrelid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2626(entry) monitoring.xml:2803(entry)
msgid "OID of this index"
msgstr "OID индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2631(entry) monitoring.xml:2808(entry)
msgid "Name of the schema this index is in"
msgstr "Имя схемы, в которой расположен индекс"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2636(entry) monitoring.xml:2813(entry)
msgid "Name of the table for this index"
msgstr "Имя таблицы для индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2639(structfield) monitoring.xml:2816(structfield)
msgid "indexrelname"
msgstr "indexrelname"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2641(entry) monitoring.xml:2818(entry)
msgid "Name of this index"
msgstr "Имя индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2646(entry)
msgid "Number of index scans initiated on this index"
msgstr "Количество запущенных сканирований по этому индексу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2649(structfield)
msgid "idx_tup_read"
msgstr "idx_tup_read"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2651(entry)
msgid "Number of index entries returned by scans on this index"
msgstr ""
"Количество элементов индекса, возвращённых при сканированиях по этому индексу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2656(entry)
msgid ""
"Number of live table rows fetched by simple index scans using this index"
msgstr ""
"Количество живых строк таблицы, отобранных при простых сканированиях по "
"этому индексу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2663(para)
msgid ""
"The <structname>pg_stat_all_indexes</structname> view will contain one row "
"for each index in the current database, showing statistics about accesses to "
"that specific index. The <structname>pg_stat_user_indexes</structname> and "
"<structname>pg_stat_sys_indexes</structname> views contain the same "
"information, but filtered to only show user and system indexes respectively."
msgstr ""
"Представление <structname>pg_stat_all_indexes</structname> для каждого "
"индекса в текущей базе данных будет содержать по одной строке со статистикой "
"по обращениям к этому индексу. Представления "
"<structname>pg_stat_user_indexes</structname> и "
"<structname>pg_stat_sys_indexes</structname> содержат ту же самую "
"информацию, но отфильтрованную так, чтобы показывать только пользовательские "
"и системные индексы соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2673(para)
msgid ""
"Indexes can be used by simple index scans, <quote>bitmap</quote> index "
"scans, and the optimizer. In a bitmap scan the output of several indexes can "
"be combined via AND or OR rules, so it is difficult to associate individual "
"heap row fetches with specific indexes when a bitmap scan is used. "
"Therefore, a bitmap scan increments the <structname>pg_stat_all_indexes</"
"structname>.<structfield>idx_tup_read</structfield> count(s) for the "
"index(es) it uses, and it increments the <structname>pg_stat_all_tables</"
"structname>.<structfield>idx_tup_fetch</structfield> count for the table, "
"but it does not affect <structname>pg_stat_all_indexes</structname>."
"<structfield>idx_tup_fetch</structfield>. The optimizer also accesses "
"indexes to check for supplied constants whose values are outside the "
"recorded range of the optimizer statistics because the optimizer statistics "
"might be stale."
msgstr ""
"Индексы могут использоваться при простом сканировании по индексу, при "
"сканировании <quote>битовой карты</quote> индекса и в работе оптимизатора. "
"Результаты сканирования битовых карт разных индексов могут объединяться "
"логическим умножением или сложением, поэтому когда применяются битовые "
"карты, сложно связать выборки отдельных строк с определёнными индексами. "
"Поэтому при сканировании битовых карт увеличиваются счётчики "
"<structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</"
"structfield> для задействованных индексов и счётчик "
"<structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</"
"structfield> для каждой таблицы, а <structname>pg_stat_all_indexes</"
"structname>.<structfield>idx_tup_fetch</structfield> не меняется. "
"Оптимизатор тоже обращается к индексам для проверки переданных констант, "
"значения которых оказываются вне диапазона, записанного в статистике "
"оптимизатора, так как эта статистика может быть неактуальной."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2691(para)
msgid ""
"The <structfield>idx_tup_read</structfield> and <structfield>idx_tup_fetch</"
"structfield> counts can be different even without any use of bitmap scans, "
"because <structfield>idx_tup_read</structfield> counts index entries "
"retrieved from the index while <structfield>idx_tup_fetch</structfield> "
"counts live rows fetched from the table. The latter will be less if any dead "
"or not-yet-committed rows are fetched using the index, or if any heap "
"fetches are avoided by means of an index-only scan."
msgstr ""
"Значения счётчиков <structfield>idx_tup_read</structfield> и "
"<structfield>idx_tup_fetch</structfield> могут различаться, даже если "
"сканирование с использованием битовой карты не используется, поскольку "
"<structfield>idx_tup_read</structfield> подсчитывает полученные из индекса "
"элементы, а <structfield>idx_tup_fetch</structfield> &mdash; количество "
"\"живых\" строк, выбранных из таблицы. Различие будет меньше, если \"мёртвые"
"\" или ещё незафиксированные строки будут извлекаться с использованием "
"индекса или если для получения строк таблицы будет использоваться "
"сканирование только по индексу."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2703(title)
msgid "<structname>pg_statio_all_tables</structname> View"
msgstr "Представление <structname>pg_statio_all_tables</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2730(structfield)
msgid "heap_blks_read"
msgstr "heap_blks_read"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2732(entry)
msgid "Number of disk blocks read from this table"
msgstr "Количество дисковых блоков, прочитанных из этой таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2735(structfield)
msgid "heap_blks_hit"
msgstr "heap_blks_hit"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2737(entry)
msgid "Number of buffer hits in this table"
msgstr "Число попаданий в буфер для этой таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2740(structfield) monitoring.xml:2821(structfield)
msgid "idx_blks_read"
msgstr "idx_blks_read"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2742(entry)
msgid "Number of disk blocks read from all indexes on this table"
msgstr "Количество дисковых блоков, прочитанных из всех индексов этой таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2745(structfield) monitoring.xml:2826(structfield)
msgid "idx_blks_hit"
msgstr "idx_blks_hit"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2747(entry)
msgid "Number of buffer hits in all indexes on this table"
msgstr "Число попаданий в буфер для всех индексов по этой таблице"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2750(structfield)
msgid "toast_blks_read"
msgstr "toast_blks_read"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2752(entry)
msgid "Number of disk blocks read from this table's TOAST table (if any)"
msgstr ""
"Количество прочитанных дисковых блоков TOAST (если есть) для этой таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2755(structfield)
msgid "toast_blks_hit"
msgstr "toast_blks_hit"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2757(entry)
msgid "Number of buffer hits in this table's TOAST table (if any)"
msgstr ""
"Число попаданий в буфер в таблице TOAST для этой таблицы (если такие есть)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2760(structfield)
msgid "tidx_blks_read"
msgstr "tidx_blks_read"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2762(entry)
msgid ""
"Number of disk blocks read from this table's TOAST table indexes (if any)"
msgstr ""
"Количество прочитанных дисковых блоков из индекса по TOAST (если есть) для "
"этой таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2765(structfield)
msgid "tidx_blks_hit"
msgstr "tidx_blks_hit"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2767(entry)
msgid "Number of buffer hits in this table's TOAST table indexes (if any)"
msgstr ""
"Число попаданий в буфер для индекса по TOAST (если есть) для этой таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2773(para)
msgid ""
"The <structname>pg_statio_all_tables</structname> view will contain one row "
"for each table in the current database (including TOAST tables), showing "
"statistics about I/O on that specific table. The "
"<structname>pg_statio_user_tables</structname> and "
"<structname>pg_statio_sys_tables</structname> views contain the same "
"information, but filtered to only show user and system tables respectively."
msgstr ""
"Представление <structname>pg_statio_all_tables</structname> для каждой "
"таблицы (включая таблицы TOAST) в текущей базе данных будет содержать по "
"одной строке со статистикой по операциям ввода/вывода для этой таблицы. "
"Представления <structname>pg_statio_user_tables</structname> и "
"<structname>pg_statio_sys_tables</structname> содержат ту же самую "
"информацию, но отфильтрованную так, чтобы показывать только пользовательские "
"или системные таблицы соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2784(title)
msgid "<structname>pg_statio_all_indexes</structname> View"
msgstr "Представление <structname>pg_statio_all_indexes</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2823(entry)
msgid "Number of disk blocks read from this index"
msgstr "Количество дисковых блоков, прочитанных из этого индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2828(entry)
msgid "Number of buffer hits in this index"
msgstr "Число попаданий в буфер для этого индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2834(para)
msgid ""
"The <structname>pg_statio_all_indexes</structname> view will contain one row "
"for each index in the current database, showing statistics about I/O on that "
"specific index. The <structname>pg_statio_user_indexes</structname> and "
"<structname>pg_statio_sys_indexes</structname> views contain the same "
"information, but filtered to only show user and system indexes respectively."
msgstr ""
"Представление <structname>pg_statio_all_indexes</structname> для каждого "
"индекса в текущей базе данных будет содержать по одной строке со статистикой "
"по операциям ввода/вывода для этого индекса. Представления "
"<structname>pg_statio_user_indexes</structname> и "
"<structname>pg_statio_sys_indexes</structname> содержат ту же самую "
"информацию, но отфильтрованную так, чтобы показывать только пользовательские "
"или системные индексы соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2845(title)
msgid "<structname>pg_statio_all_sequences</structname> View"
msgstr "Представление <structname>pg_statio_all_sequences</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2859(entry)
msgid "OID of a sequence"
msgstr "OID последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2864(entry)
msgid "Name of the schema this sequence is in"
msgstr "Имя схемы, в которой расположена эта последовательность"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2869(entry)
msgid "Name of this sequence"
msgstr "Имя последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2874(entry)
msgid "Number of disk blocks read from this sequence"
msgstr "Количество дисковых блоков, прочитанных из этой последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2879(entry)
msgid "Number of buffer hits in this sequence"
msgstr "Число попаданий в буфер в этой последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2885(para)
msgid ""
"The <structname>pg_statio_all_sequences</structname> view will contain one "
"row for each sequence in the current database, showing statistics about I/O "
"on that specific sequence."
msgstr ""
"Представление <structname>pg_statio_all_sequences</structname> для каждой "
"последовательности в текущей базе данных будет содержать по одной строке со "
"статистикой по операциям ввода/вывода для этой последовательности."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2892(title)
msgid "<structname>pg_stat_user_functions</structname> View"
msgstr "Представление <structname>pg_stat_user_functions</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2904(structfield)
msgid "funcid"
msgstr "funcid"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2906(entry)
msgid "OID of a function"
msgstr "OID функции"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2911(entry)
msgid "Name of the schema this function is in"
msgstr "Имя схемы, в которой расположена функция"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2914(structfield)
msgid "funcname"
msgstr "funcname"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2916(entry)
msgid "Name of this function"
msgstr "Имя функции"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2919(structfield)
msgid "calls"
msgstr "calls"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2921(entry)
msgid "Number of times this function has been called"
msgstr "Сколько раз вызывалась функция"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2924(structfield)
msgid "total_time"
msgstr "total_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2926(entry)
msgid ""
"Total time spent in this function and all other functions called by it, in "
"milliseconds"
msgstr ""
"Общее время, потраченное на выполнение этой функции и всех других функций, "
"вызванных ею, в миллисекундах"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2930(structfield)
msgid "self_time"
msgstr "self_time"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2932(entry)
msgid ""
"Total time spent in this function itself, not including other functions "
"called by it, in milliseconds"
msgstr ""
"Общее время, потраченное на выполнение самой функции, без учёта других "
"функций, которые были ею вызваны, в миллисекундах"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2939(para)
msgid ""
"The <structname>pg_stat_user_functions</structname> view will contain one "
"row for each tracked function, showing statistics about executions of that "
"function. The <xref linkend=\"guc-track-functions\"/> parameter controls "
"exactly which functions are tracked."
msgstr ""
"Представление <structname>pg_stat_user_functions</structname> для каждой "
"отслеживаемой функции будет содержать по одной строке со статистикой по "
"выполнениям этой функции. Отслеживаемые функции определяются параметром "
"<xref linkend=\"guc-track-functions\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2949(title)
msgid "Statistics Functions"
msgstr "Статистические функции"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2951(para)
msgid ""
"Other ways of looking at the statistics can be set up by writing queries "
"that use the same underlying statistics access functions used by the "
"standard views shown above. For details such as the functions' names, "
"consult the definitions of the standard views. (For example, in "
"<application>psql</application> you could issue <literal>\\d+ "
"pg_stat_activity</literal>.) The access functions for per-database "
"statistics take a database OID as an argument to identify which database to "
"report on. The per-table and per-index functions take a table or index OID. "
"The functions for per-function statistics take a function OID. Note that "
"only tables, indexes, and functions in the current database can be seen with "
"these functions."
msgstr ""
"Статистическую информацию можно просматривать и другими способами. Для этого "
"можно написать запросы, использующие те же функции доступа к статистике, что "
"лежат в основе описанных выше стандартных представлений. За более подробной "
"информацией, например, об именах этих функций, обратитесь к определениям "
"этих стандартных представлений. (Например, в <application>psql</application> "
"можно выполнить <literal>\\d+ pg_stat_activity</literal>.) В качестве "
"аргумента функции, предоставляющие доступ к статистике на уровне базы, "
"принимают OID базы данных, по которой должна быть выдана информация. "
"Функции, которые работают на уровне таблиц и индексов, принимают в качестве "
"аргумента OID таблицы или индекса. Аргументом для функции, предоставляющей "
"статистику на уровне функций, является OID функции. Обратите внимание, что с "
"помощью этих функций можно получить информацию по таблицам, индексам и "
"функциям исключительно в текущей базе данных."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2965(para)
msgid ""
"Additional functions related to statistics collection are listed in <xref "
"linkend=\"monitoring-stats-funcs-table\"/>."
msgstr ""
"Дополнительные функции, связанные со сбором статистики, перечислены в <xref "
"remap=\"6\" linkend=\"monitoring-stats-funcs-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2971(title)
msgid "Additional Statistics Functions"
msgstr "Дополнительные статистические функции"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2976(entry) monitoring.xml:3095(entry)
msgid "Function"
msgstr "Функция"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2977(entry) monitoring.xml:3096(entry)
msgid "Return Type"
msgstr "Тип результата"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2986(function)
msgid "pg_backend_pid()"
msgstr "pg_backend_pid()"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2988(entry)
msgid "Process ID of the server process handling the current session"
msgstr "Идентификатор серверного процесса, выполняющего текущую сессию"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2994(function)
msgid "pg_stat_get_activity"
msgstr "pg_stat_get_activity"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2994(literal)
msgid "<placeholder-1/>(<placeholder-2/>)"
msgstr "<placeholder-1/>(<placeholder-2/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2994(indexterm)
msgid "<primary>pg_stat_get_activity</primary>"
msgstr "<primary>pg_stat_get_activity</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2995(type)
msgid "setof record"
msgstr "setof record"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:2996(entry)
msgid ""
"Returns a record of information about the backend with the specified PID, or "
"one record for each active backend in the system if <symbol>NULL</symbol> is "
"specified. The fields returned are a subset of those in the "
"<structname>pg_stat_activity</structname> view."
msgstr ""
"Возвращает запись с информацией о серверном процессе с заданным PID или по "
"одной строке для каждого активного серверного процесса в системе, если был "
"указан <symbol>NULL</symbol>. Возвращаемые поля являются подмножеством "
"столбцов представления <structname>pg_stat_activity</structname>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3005(function)
msgid "pg_stat_get_snapshot_timestamp()"
msgstr "pg_stat_get_snapshot_timestamp()"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3005(indexterm)
msgid "<primary>pg_stat_get_snapshot_timestamp</primary>"
msgstr "<primary>pg_stat_get_snapshot_timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3007(entry)
msgid "Returns the timestamp of the current statistics snapshot"
msgstr "Возвращает время снимка текущей статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3013(function)
msgid "pg_stat_clear_snapshot()"
msgstr "pg_stat_clear_snapshot()"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3013(indexterm)
msgid "<primary>pg_stat_clear_snapshot</primary>"
msgstr "<primary>pg_stat_clear_snapshot</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3014(type) monitoring.xml:3022(type)
#: monitoring.xml:3032(type) monitoring.xml:3046(type)
#: monitoring.xml:3056(type)
msgid "void"
msgstr "void"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3015(entry)
msgid "Discard the current statistics snapshot"
msgstr "Сбросить текущий снимок статистики"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3021(function)
msgid "pg_stat_reset()"
msgstr "pg_stat_reset()"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3021(indexterm)
msgid "<primary>pg_stat_reset</primary>"
msgstr "<primary>pg_stat_reset</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3023(entry)
msgid ""
"Reset all statistics counters for the current database to zero (requires "
"superuser privileges by default, but EXECUTE for this function can be "
"granted to others.)"
msgstr ""
"Сбросить в ноль все статистические счётчики в текущей базе данных (по "
"умолчанию разрешено только суперпользователям, но право выполнения (EXECUTE) "
"этой функции можно дать и другим)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3031(function)
msgid "pg_stat_reset_shared"
msgstr "pg_stat_reset_shared"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3031(literal)
msgid "<placeholder-1/>(text)"
msgstr "<placeholder-1/>(text)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3031(indexterm)
msgid "<primary>pg_stat_reset_shared</primary>"
msgstr "<primary>pg_stat_reset_shared</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3033(entry)
msgid ""
"Reset some cluster-wide statistics counters to zero, depending on the "
"argument (requires superuser privileges by default, but EXECUTE for this "
"function can be granted to others). Calling "
"<literal>pg_stat_reset_shared('bgwriter')</literal> will zero all the "
"counters shown in the <structname>pg_stat_bgwriter</structname> view. "
"Calling <literal>pg_stat_reset_shared('archiver')</literal> will zero all "
"the counters shown in the <structname>pg_stat_archiver</structname> view."
msgstr ""
"Сбросить в ноль некоторые статистические счётчики на уровне кластера, в "
"зависимости от заданного аргумента (по умолчанию разрешено только "
"суперпользователям, но право выполнения (EXECUTE) этой функции можно дать и "
"другим). Вызов <literal>pg_stat_reset_shared('bgwriter')</literal> сбросит в "
"ноль все счётчики, которые показываются в представлении "
"<structname>pg_stat_bgwriter</structname>, а вызов "
"<literal>pg_stat_reset_shared('archiver')</literal> — все счётчики в "
"представлении <structname>pg_stat_archiver</structname>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3045(function)
msgid "pg_stat_reset_single_table_counters"
msgstr "pg_stat_reset_single_table_counters"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3045(literal) monitoring.xml:3055(literal)
msgid "<placeholder-1/>(oid)"
msgstr "<placeholder-1/>(oid)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3045(indexterm)
msgid "<primary>pg_stat_reset_single_table_counters</primary>"
msgstr "<primary>pg_stat_reset_single_table_counters</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3047(entry)
msgid ""
"Reset statistics for a single table or index in the current database to zero "
"(requires superuser privileges by default, but EXECUTE for this function can "
"be granted to others)"
msgstr ""
"Сбросить в ноль статистику по отдельной таблице или индексу в текущей базе "
"данных (по умолчанию разрешено только суперпользователям, но право "
"выполнения (EXECUTE) этой функции можно дать и другим)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3055(function)
msgid "pg_stat_reset_single_function_counters"
msgstr "pg_stat_reset_single_function_counters"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3055(indexterm)
msgid "<primary>pg_stat_reset_single_function_counters</primary>"
msgstr "<primary>pg_stat_reset_single_function_counters</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3057(entry)
msgid ""
"Reset statistics for a single function in the current database to zero "
"(requires superuser privileges by default, but EXECUTE for this function can "
"be granted to others)"
msgstr ""
"Сбросить в ноль статистику по отдельной функции в текущей базе данных (по "
"умолчанию разрешено только суперпользователям, но право выполнения (EXECUTE) "
"этой функции можно дать и другим)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3082(programlisting)
#, no-wrap
msgid ""
"SELECT pg_stat_get_backend_pid(s.backendid) AS pid,\n"
"       pg_stat_get_backend_activity(s.backendid) AS query\n"
"    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;"
msgstr ""
"SELECT pg_stat_get_backend_pid(s.backendid) AS pid,\n"
"       pg_stat_get_backend_activity(s.backendid) AS query\n"
"    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3067(para)
msgid ""
"<function>pg_stat_get_activity</function>, the underlying function of the "
"<structname>pg_stat_activity</structname> view, returns a set of records "
"containing all the available information about each backend process. "
"Sometimes it may be more convenient to obtain just a subset of this "
"information. In such cases, an older set of per-backend statistics access "
"functions can be used; these are shown in <xref linkend=\"monitoring-stats-"
"backend-funcs-table\"/>. These access functions use a backend ID number, "
"which ranges from one to the number of currently active backends. The "
"function <function>pg_stat_get_backend_idset</function> provides a "
"convenient way to generate one row for each active backend for invoking "
"these functions. For example, to show the <acronym>PID</acronym>s and "
"current queries of all backends: <placeholder-1/>"
msgstr ""
"Функция <function>pg_stat_get_activity</function>, на которой основано "
"представление <structname>pg_stat_activity</structname>, возвращает набор "
"строк, содержащих всю доступную информацию о каждом серверном процессе. "
"Иногда более удобным оказывается получение только части этой информации. В "
"таких случаях можно использовать набор более старых функций, дающих доступ к "
"статистике на уровне серверных процессов; эти функции описаны в <xref remap="
"\"6\" linkend=\"monitoring-stats-backend-funcs-table\"/>. Эти функции "
"используют идентификатор серверного процесса, значение которого варьируется "
"от единицы до числа активных в настоящий момент серверных процессов. Функция "
"<function>pg_stat_get_backend_idset</function> генерирует по одной строке "
"для каждого активного серверного процесса, что необходимо для вызова этих "
"функций. Например, для того, чтобы отобразить значения <acronym>PID</"
"acronym> и текущие запросы всех серверных процессов: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3090(title)
msgid "Per-Backend Statistics Functions"
msgstr "Статистические функции на уровне серверных процессов"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3104(function)
msgid "pg_stat_get_backend_idset()"
msgstr "pg_stat_get_backend_idset()"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3105(type)
msgid "setof integer"
msgstr "setof integer"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3106(entry)
msgid ""
"Set of currently active backend ID numbers (from 1 to the number of active "
"backends)"
msgstr ""
"Набор значений идентификаторов активных в настоящий момент серверных "
"процессов (от 1 до числа активных серверных процессов)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3111(function)
msgid "pg_stat_get_backend_activity(integer)"
msgstr "pg_stat_get_backend_activity(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3113(entry)
msgid "Text of this backend's most recent query"
msgstr "Текст последнего запроса этого серверного процесса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3117(function)
msgid "pg_stat_get_backend_activity_start(integer)"
msgstr "pg_stat_get_backend_activity_start(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3119(entry)
msgid "Time when the most recent query was started"
msgstr "Время запуска последнего запроса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3123(function)
msgid "pg_stat_get_backend_client_addr(integer)"
msgstr "pg_stat_get_backend_client_addr(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3125(entry)
msgid "IP address of the client connected to this backend"
msgstr "IP-адрес клиента, подключённого к этому серверному процессу"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3129(function)
msgid "pg_stat_get_backend_client_port(integer)"
msgstr "pg_stat_get_backend_client_port(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3131(entry)
msgid "TCP port number that the client is using for communication"
msgstr "Номер TCP-порта, который клиент использует для взаимодействия"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3135(function)
msgid "pg_stat_get_backend_dbid(integer)"
msgstr "pg_stat_get_backend_dbid(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3141(function)
msgid "pg_stat_get_backend_pid(integer)"
msgstr "pg_stat_get_backend_pid(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3147(function)
msgid "pg_stat_get_backend_start(integer)"
msgstr "pg_stat_get_backend_start(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3149(entry)
msgid "Time when this process was started"
msgstr "Время запуска этого процесса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3153(function)
msgid "pg_stat_get_backend_userid(integer)"
msgstr "pg_stat_get_backend_userid(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3159(function)
msgid "pg_stat_get_backend_wait_event_type(integer)"
msgstr "pg_stat_get_backend_wait_event_type(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3161(entry)
msgid ""
"Wait event type name if backend is currently waiting, otherwise NULL. See "
"<xref linkend=\"wait-event-table\"/> for details."
msgstr ""
"Имя типа ожидаемого события, если обслуживающий процесс находится в "
"состоянии ожидания, а в противном случае — NULL. За подробностями обратитесь "
"к <xref remap=\"3\" linkend=\"wait-event-table\"/>."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3161(entry)
msgid ""
"Probe that fires when a server process has been released from its wait for "
"an LWLock (it does not actually have the lock yet). arg0 is the LWLock's "
"tranche. arg1 is the LWLock's offset within its tranche. arg2 is the "
"requested lock mode, either exclusive or shared."
msgstr ""
"Срабатывает, когда серверный процесс прекращает ожидание блокировки LWLock "
"(но саму блокировку он ещё не получил). arg0 задаёт идентификатор блокировки "
"LWLock. arg1 задаёт смещение внутри идентификатора блокировки LWLock. arg2 "
"задаёт тип запрошенной блокировки, монопольная или разделяемая."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3167(function)
msgid "pg_stat_get_backend_wait_event(integer)"
msgstr "pg_stat_get_backend_wait_event(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3175(function)
msgid "pg_stat_get_backend_xact_start(integer)"
msgstr "pg_stat_get_backend_xact_start(integer)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3177(entry)
msgid "Time when the current transaction was started"
msgstr "Время начала текущей транзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3188(title)
msgid "Viewing Locks"
msgstr "Просмотр информации о блокировках"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3190(indexterm)
msgid "<primary>lock</primary> <secondary>monitoring</secondary>"
msgstr "<primary>блокировка</primary> <secondary>мониторинг</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3204(para)
msgid ""
"View all the locks currently outstanding, all the locks on relations in a "
"particular database, all the locks on a particular relation, or all the "
"locks held by a particular <productname>PostgreSQL</productname> session."
msgstr ""
"просмотра всех имеющихся на данный момент блокировок, всех блокировок на "
"отношения в определённой базе данных, всех блокировок на определённое "
"отношение или всех блокировок, которые удерживает определённая сессия "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3213(para)
msgid ""
"Determine the relation in the current database with the most ungranted locks "
"(which might be a source of contention among database clients)."
msgstr ""
"определения отношения в текущей базе данных с наибольшим количеством "
"неразрешённых блокировок (оно может быть причиной конкуренции между "
"клиентами базы данных)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3221(para)
msgid ""
"Determine the effect of lock contention on overall database performance, as "
"well as the extent to which contention varies with overall database traffic."
msgstr ""
"определения воздействия конкуренции за блокировку на производительность базы "
"данных в целом, а так же то, как меняется конкуренция в зависимости от "
"загруженности базы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3195(para)
msgid ""
"Another useful tool for monitoring database activity is the "
"<structname>pg_locks</structname> system table. It allows the database "
"administrator to view information about the outstanding locks in the lock "
"manager. For example, this capability can be used to: <placeholder-1/> "
"Details of the <structname>pg_locks</structname> view appear in <xref "
"linkend=\"view-pg-locks\"/>. For more information on locking and managing "
"concurrency with <productname>PostgreSQL</productname>, refer to <xref "
"linkend=\"mvcc\"/>."
msgstr ""
"Ещё одним удобным средством для отслеживания работы базы данных является "
"системная таблица <structname>pg_locks</structname>. Она позволяет "
"администратору базы просматривать информацию об имеющихся блокировках в "
"менеджере блокировок. Например, это может использоваться для: <placeholder-1/"
"> Более детально представление <structname>pg_locks</structname> описано в "
"<xref remap=\"6\" linkend=\"view-pg-locks\"/>. Более подробную информацию о "
"блокировках и управлению параллельным доступом в <productname>PostgreSQL</"
"productname> можно получить в <xref remap=\"6\" linkend=\"mvcc\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3237(title)
msgid "Progress Reporting"
msgstr "Отслеживание выполнения"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3239(para)
msgid ""
"<productname>PostgreSQL</productname> has the ability to report the progress "
"of certain commands during command execution. Currently, the only command "
"which supports progress reporting is <command>VACUUM</command>. This may be "
"expanded in the future."
msgstr ""
"<productname>PostgreSQL</productname> имеет возможность отслеживать "
"выполнение определённых команд. В настоящее время такое отслеживание "
"поддерживает только команда <command>VACUUM</command>, но в будущем сфера "
"его применения может быть расширена."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3247(title)
msgid "VACUUM Progress Reporting"
msgstr "Отслеживание выполнения VACUUM"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3249(para)
msgid ""
"Whenever <command>VACUUM</command> is running, the "
"<structname>pg_stat_progress_vacuum</structname> view will contain one row "
"for each backend (including autovacuum worker processes) that is currently "
"vacuuming. The tables below describe the information that will be reported "
"and provide information about how to interpret it. Progress reporting is not "
"currently supported for <command>VACUUM FULL</command> and backends running "
"<command>VACUUM FULL</command> will not be listed in this view."
msgstr ""
"Во время выполнения <command>VACUUM</command> представление "
"<structname>pg_stat_progress_vacuum</structname> будет содержать по одной "
"строке для каждого обслуживающего процесса (включая рабочие процессы "
"автоочистки), производящего очистку. Таблицы ниже показывают, какая "
"информация будет отслеживаться, и рассказывают, как её интерпретировать. В "
"настоящее время отслеживание выполнения не поддерживается для команды "
"<command>VACUUM FULL</command>, так что процессы, выполняющие "
"<command>VACUUM FULL</command>, не будут видны в этом представлении."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3261(title)
msgid "<structname>pg_stat_progress_vacuum</structname> View"
msgstr "Представление <structname>pg_stat_progress_vacuum</structname>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3275(entry)
msgid "Process ID of backend."
msgstr "Идентификатор (PID) этого обслуживающего процесса"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3280(entry)
msgid "OID of the database to which this backend is connected."
msgstr "OID базы данных, к которой подключён этот обслуживающий процесс."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3285(entry)
msgid "Name of the database to which this backend is connected."
msgstr "Имя базы данных, к которой подключён этот обслуживающий процесс."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3290(entry)
msgid "OID of the table being vacuumed."
msgstr "OID очищаемой таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3293(structfield)
msgid "phase"
msgstr "phase"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3295(entry)
msgid ""
"Current processing phase of vacuum. See <xref linkend=\"vacuum-phases\"/>."
msgstr ""
"Текущая фаза очистки. См. <xref remap=\"4\" linkend=\"vacuum-phases\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3300(structfield)
msgid "heap_blks_total"
msgstr "heap_blks_total"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3302(entry)
msgid ""
"Total number of heap blocks in the table. This number is reported as of the "
"beginning of the scan; blocks added later will not be (and need not be) "
"visited by this <command>VACUUM</command>."
msgstr ""
"Общее число блоков кучи в таблице. Это число отражает состояние в начале "
"сканирования; блоки, добавленные позже, не будут (и не должны) "
"обрабатываться текущей командой <command>VACUUM</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3309(structfield)
msgid "heap_blks_scanned"
msgstr "heap_blks_scanned"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3311(entry)
msgid ""
"Number of heap blocks scanned. Because the <link linkend=\"storage-vm"
"\">visibility map</link> is used to optimize scans, some blocks will be "
"skipped without inspection; skipped blocks are included in this total, so "
"that this number will eventually become equal to "
"<structfield>heap_blks_total</structfield> when the vacuum is complete. This "
"counter only advances when the phase is <literal>scanning heap</literal>."
msgstr ""
"Число просканированных блоков кучи. Так как для оптимизации сканирования "
"применяется <link linkend=\"storage-vm\">карта видимости</link>, некоторые "
"блоки могут пропускаться без осмотра; пропущенные блоки входят в это общее "
"число, так что по завершении очистки это число станет равно "
"<structfield>heap_blks_total</structfield>. Этот счётчик увеличивается "
"только в фазе <literal>scanning heap</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3321(structfield)
msgid "heap_blks_vacuumed"
msgstr "heap_blks_vacuumed"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3323(entry)
msgid ""
"Number of heap blocks vacuumed. Unless the table has no indexes, this "
"counter only advances when the phase is <literal>vacuuming heap</literal>. "
"Blocks that contain no dead tuples are skipped, so the counter may sometimes "
"skip forward in large increments."
msgstr ""
"Число очищенных блоков кучи. Если в таблице нет индексов, этот счётчик "
"увеличивается только в фазе <literal>vacuuming heap</literal> (очистка "
"кучи). Блоки, не содержащие &laquo;мёртвых&raquo; кортежей, при этом "
"пропускаются, так что этот счётчик иногда может увеличиваться резкими "
"рывками."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3331(structfield)
msgid "index_vacuum_count"
msgstr "index_vacuum_count"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3333(entry)
msgid "Number of completed index vacuum cycles."
msgstr "Количество завершённых циклов очистки индекса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3338(structfield)
msgid "max_dead_tuples"
msgstr "max_dead_tuples"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3340(entry)
msgid ""
"Number of dead tuples that we can store before needing to perform an index "
"vacuum cycle, based on <xref linkend=\"guc-maintenance-work-mem\"/>."
msgstr ""
"Число &laquo;мёртвых&raquo; кортежей, которое мы можем сохранить, прежде чем "
"потребуется выполнить цикл очистки индекса, в зависимости от <xref linkend="
"\"guc-maintenance-work-mem\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3347(structfield)
msgid "num_dead_tuples"
msgstr "num_dead_tuples"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3349(entry)
msgid "Number of dead tuples collected since the last index vacuum cycle."
msgstr ""
"Число &laquo;мёртвых&raquo; кортежей, собранных со времени последнего цикла "
"очистки индекса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3358(title)
msgid "VACUUM phases"
msgstr "Фазы VACUUM"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3362(entry)
msgid "Phase"
msgstr "Фаза"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3369(literal)
msgid "initializing"
msgstr "initializing"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3370(entry)
msgid ""
"<command>VACUUM</command> is preparing to begin scanning the heap. This "
"phase is expected to be very brief."
msgstr ""
"Инициализация — <command>VACUUM</command> готовится начать сканирование "
"кучи. Эта фаза должна быть очень быстрой."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3376(literal)
msgid "scanning heap"
msgstr "scanning heap"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3377(entry)
msgid ""
"<command>VACUUM</command> is currently scanning the heap. It will prune and "
"defragment each page if required, and possibly perform freezing activity. "
"The <structfield>heap_blks_scanned</structfield> column can be used to "
"monitor the progress of the scan."
msgstr ""
"Сканирование кучи — <command>VACUUM</command> в настоящее время сканирует "
"кучу. При этом будет очищена и, если требуется, дефрагментирована каждая "
"страница, а возможно, также будет произведена заморозка. Отслеживать процесс "
"сканирования можно, следя за содержимым столбца "
"<structfield>heap_blks_scanned</structfield>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3385(literal)
msgid "vacuuming indexes"
msgstr "vacuuming indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3386(entry)
msgid ""
"<command>VACUUM</command> is currently vacuuming the indexes. If a table has "
"any indexes, this will happen at least once per vacuum, after the heap has "
"been completely scanned. It may happen multiple times per vacuum if <xref "
"linkend=\"guc-maintenance-work-mem\"/> is insufficient to store the number "
"of dead tuples found."
msgstr ""
"Очистка индексов — <command>VACUUM</command> в настоящее время очищает "
"индексы. Если у таблицы есть какие-либо индексы, эта фаза будет наблюдаться "
"минимум единожды в процессе очистки, после того, как куча будет "
"просканирована полностью. Она может повторяться несколько раз в процессе "
"очистки, если объёма <xref linkend=\"guc-maintenance-work-mem\"/> "
"оказывается недостаточно для сохранения всех найденных &laquo;мёртвых&raquo; "
"кортежей."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3395(literal)
msgid "vacuuming heap"
msgstr "vacuuming heap"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3396(entry)
msgid ""
"<command>VACUUM</command> is currently vacuuming the heap. Vacuuming the "
"heap is distinct from scanning the heap, and occurs after each instance of "
"vacuuming indexes. If <structfield>heap_blks_scanned</structfield> is less "
"than <structfield>heap_blks_total</structfield>, the system will return to "
"scanning the heap after this phase is completed; otherwise, it will begin "
"cleaning up indexes after this phase is completed."
msgstr ""
"Очистка кучи — <command>VACUUM</command> в настоящее время очищает кучу. "
"Очистка кучи отличается от сканирования, так как она происходит после каждой "
"операции очистки индексов. Если <structfield>heap_blks_scanned</structfield> "
"меньше чем <structfield>heap_blks_total</structfield>, система вернётся к "
"сканированию кучи после завершения этой фазы; в противном случае она начнёт "
"уборку индексов."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3406(literal)
msgid "cleaning up indexes"
msgstr "cleaning up indexes"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3407(entry)
msgid ""
"<command>VACUUM</command> is currently cleaning up indexes. This occurs "
"after the heap has been completely scanned and all vacuuming of the indexes "
"and the heap has been completed."
msgstr ""
"Уборка индексов — <command>VACUUM</command> в настоящее время производит "
"уборку в индексах. Это происходит после завершения полного сканирования кучи "
"и очистки индексов и кучи."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3414(literal)
msgid "truncating heap"
msgstr "truncating heap"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3415(entry)
msgid ""
"<command>VACUUM</command> is currently truncating the heap so as to return "
"empty pages at the end of the relation to the operating system. This occurs "
"after cleaning up indexes."
msgstr ""
"Усечение кучи — <command>VACUUM</command> в настоящее время усекает кучу, "
"чтобы возвратить операционной системе объём пустых страниц в конце "
"отношения. Это происходит после уборки индексов."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3422(literal)
msgid "performing final cleanup"
msgstr "performing final cleanup"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3423(entry)
msgid ""
"<command>VACUUM</command> is performing final cleanup. During this phase, "
"<command>VACUUM</command> will vacuum the free space map, update statistics "
"in <literal>pg_class</literal>, and report statistics to the statistics "
"collector. When this phase is completed, <command>VACUUM</command> will end."
msgstr ""
"Выполнение окончательной очистки — <command>VACUUM</command> выполняет "
"окончательную очистку. На этой стадии <command>VACUUM</command> очищает "
"карту свободного пространства, обновляет статистику в <literal>pg_class</"
"literal> и передаёт статистику сборщику статистики, После этой фазы "
"<command>VACUUM</command> завершит свою работу."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3438(title)
msgid "Dynamic Tracing"
msgstr "Динамическая трассировка"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3440(indexterm)
msgid "<primary>DTrace</primary>"
msgstr "<primary>DTrace</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3444(para)
msgid ""
"<productname>PostgreSQL</productname> provides facilities to support dynamic "
"tracing of the database server. This allows an external utility to be called "
"at specific points in the code and thereby trace execution."
msgstr ""
"<productname>PostgreSQL</productname> позволяет выполнять динамическую "
"трассировку сервера базы данных. Имеющиеся возможности позволяют вызывать "
"внешнюю утилиту в определённых точках кода и таким образом отслеживать его "
"выполнение."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3451(para)
msgid ""
"A number of probes or trace points are already inserted into the source "
"code. These probes are intended to be used by database developers and "
"administrators. By default the probes are not compiled into "
"<productname>PostgreSQL</productname>; the user needs to explicitly tell the "
"configure script to make the probes available."
msgstr ""
"Несколько подобных точек сбора метрик, или точек трассировки, уже встроено в "
"исходный код. Предполагается, что эти точки будут использоваться "
"разработчиками и администраторами базы данных. По умолчанию точки "
"трассировки не входят в сборку <productname>PostgreSQL</productname>; "
"пользователь должен явно указать конфигурационному скрипту необходимость "
"включения этих макросов."

#. +> REL_10
#: monitoring.xml:3459(para)
msgid ""
"Currently, the <ulink url=\"https://en.wikipedia.org/wiki/DTrace\">DTrace</"
"ulink> utility is supported, which, at the time of this writing, is "
"available on Solaris, macOS, FreeBSD, NetBSD, and Oracle Linux. The <ulink "
"url=\"http://sourceware.org/systemtap/\">SystemTap</ulink> project for Linux "
"provides a DTrace equivalent and can also be used. Supporting other dynamic "
"tracing utilities is theoretically possible by changing the definitions for "
"the macros in <filename>src/include/utils/probes.h</filename>."
msgstr ""
"В настоящее время поддерживается только утилита <ulink url=\"https://en."
"wikipedia.org/wiki/DTrace\">DTrace</ulink>, которая доступна для Solaris, "
"macOS, FreeBSD, NetBSD и Oracle Linux. Проект <ulink url=\"http://sourceware."
"org/systemtap/\">SystemTap</ulink> для Linux представляет собой эквивалент "
"DTrace и также может быть использован. Теоретически возможна поддержка и "
"других утилит динамической трассировки, для этого необходимо изменить "
"определения для макроса в <filename>src/include/utils/probes.h</filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3471(title)
msgid "Compiling for Dynamic Tracing"
msgstr "Компиляция для включения динамической трассировки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3473(para)
msgid ""
"By default, probes are not available, so you will need to explicitly tell "
"the configure script to make the probes available in "
"<productname>PostgreSQL</productname>. To include DTrace support specify "
"<option>--enable-dtrace</option> to configure. See <xref linkend=\"install-"
"procedure\"/> for further information."
msgstr ""
"По умолчанию точки трассировки недоступны, поэтому в конфигурационном "
"скрипте <productname>PostgreSQL</productname> требуется явно указать "
"необходимость их подключения. Для поддержки утилиты DTrace укажите <option>--"
"enable-dtrace</option> в конфигурационном файле. Более подробно смотрите "
"<xref linkend=\"install-procedure\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3483(title)
msgid "Built-in Probes"
msgstr "Встроенные точки трассировки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3485(para)
msgid ""
"A number of standard probes are provided in the source code, as shown in "
"<xref linkend=\"dtrace-probe-point-table\"/>; <xref linkend=\"typedefs-table"
"\"/> shows the types used in the probes. More probes can certainly be added "
"to enhance <productname>PostgreSQL</productname>'s observability."
msgstr ""
"В исходный код входит несколько стандартных точек трассировки, которые "
"представлены в <xref remap=\"6\" linkend=\"dtrace-probe-point-table\"/>; в "
"<xref remap=\"6\" linkend=\"typedefs-table\"/> показаны типы данных, которые "
"используются для этих точек. Конечно, для более детального отслеживания "
"работы <productname>PostgreSQL</productname> можно добавлять и другие точки "
"трассировки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3494(title)
msgid "Built-in DTrace Probes"
msgstr "Встроенные точки трассировки DTrace"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3498(entry)
msgid "Name"
msgstr "Имя"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3499(entry)
msgid "Parameters"
msgstr "Параметры"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3507(literal)
msgid "transaction-start"
msgstr "transaction-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3508(literal) monitoring.xml:3514(literal)
#: monitoring.xml:3520(literal)
msgid "(LocalTransactionId)"
msgstr "(LocalTransactionId)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3509(entry)
msgid ""
"Probe that fires at the start of a new transaction. arg0 is the transaction "
"ID."
msgstr ""
"Срабатывает в начале новой транзакции. arg0 задаёт идентификатор транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3513(literal)
msgid "transaction-commit"
msgstr "transaction-commit"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3515(entry)
msgid ""
"Probe that fires when a transaction completes successfully. arg0 is the "
"transaction ID."
msgstr ""
"Срабатывает при успешном завершении транзакции. arg0 задаёт идентификатор "
"транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3519(literal)
msgid "transaction-abort"
msgstr "transaction-abort"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3521(entry)
msgid ""
"Probe that fires when a transaction completes unsuccessfully. arg0 is the "
"transaction ID."
msgstr ""
"Срабатывает, когда транзакция завершается с ошибкой. arg0 задаёт "
"идентификатор транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3525(literal)
msgid "query-start"
msgstr "query-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3526(literal) monitoring.xml:3532(literal)
#: monitoring.xml:3538(literal) monitoring.xml:3544(literal)
#: monitoring.xml:3550(literal) monitoring.xml:3556(literal)
#: monitoring.xml:3582(literal)
msgid "(const char *)"
msgstr "(const char *)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3527(entry)
msgid ""
"Probe that fires when the processing of a query is started. arg0 is the "
"query string."
msgstr ""
"Срабатывает, когда начинается обработка запроса. arg0 задаёт текст запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3531(literal)
msgid "query-done"
msgstr "query-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3533(entry)
msgid ""
"Probe that fires when the processing of a query is complete. arg0 is the "
"query string."
msgstr ""
"Срабатывает по завершении обработки запроса. arg0 задаёт текст запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3537(literal)
msgid "query-parse-start"
msgstr "query-parse-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3539(entry)
msgid ""
"Probe that fires when the parsing of a query is started. arg0 is the query "
"string."
msgstr ""
"Срабатывает, когда начинается разбор запроса. arg0 задаёт текст запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3543(literal)
msgid "query-parse-done"
msgstr "query-parse-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3545(entry)
msgid ""
"Probe that fires when the parsing of a query is complete. arg0 is the query "
"string."
msgstr ""
"Срабатывает по завершении разбора (parsing) запроса. arg0 задаёт текст "
"запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3549(literal)
msgid "query-rewrite-start"
msgstr "query-rewrite-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3551(entry)
msgid ""
"Probe that fires when the rewriting of a query is started. arg0 is the query "
"string."
msgstr ""
"Срабатывает, когда начинается модификация запроса. arg0 задаёт текст запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3555(literal)
msgid "query-rewrite-done"
msgstr "query-rewrite-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3557(entry)
msgid ""
"Probe that fires when the rewriting of a query is complete. arg0 is the "
"query string."
msgstr ""
"Срабатывает по завершении модификации запроса. arg0 задаёт текст запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3561(literal)
msgid "query-plan-start"
msgstr "query-plan-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3562(literal) monitoring.xml:3567(literal)
#: monitoring.xml:3572(literal) monitoring.xml:3577(literal)
#: monitoring.xml:3680(literal) monitoring.xml:3686(literal)
#: monitoring.xml:3692(literal) monitoring.xml:3698(literal)
#: monitoring.xml:3766(literal) monitoring.xml:3774(literal)
#: monitoring.xml:3786(literal) monitoring.xml:3915(literal)
msgid "()"
msgstr "()"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3563(entry)
msgid "Probe that fires when the planning of a query is started."
msgstr "Срабатывает, когда начинает работать планировщик выполнения запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3566(literal)
msgid "query-plan-done"
msgstr "query-plan-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3568(entry)
msgid "Probe that fires when the planning of a query is complete."
msgstr "Срабатывает по завершении работы планировщика запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3571(literal)
msgid "query-execute-start"
msgstr "query-execute-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3573(entry)
msgid "Probe that fires when the execution of a query is started."
msgstr "Срабатывает, когда начинается выполнение запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3576(literal)
msgid "query-execute-done"
msgstr "query-execute-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3578(entry)
msgid "Probe that fires when the execution of a query is complete."
msgstr "Срабатывает по завершении выполнения запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3581(literal)
msgid "statement-status"
msgstr "statement-status"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3583(entry)
msgid ""
"Probe that fires anytime the server process updates its "
"<structname>pg_stat_activity</structname>.<structfield>status</structfield>. "
"arg0 is the new status string."
msgstr ""
"Срабатывает каждый раз, когда серверный процесс обновляет свой статус в "
"<structname>pg_stat_activity</structname>.<structfield>status</structfield>. "
"arg0 задаёт новую строку состояния."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3588(literal)
msgid "checkpoint-start"
msgstr "checkpoint-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3589(literal) monitoring.xml:3648(literal)
#: monitoring.xml:3664(literal)
msgid "(int)"
msgstr "(int)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3590(entry)
msgid ""
"Probe that fires when a checkpoint is started. arg0 holds the bitwise flags "
"used to distinguish different checkpoint types, such as shutdown, immediate "
"or force."
msgstr ""
"Срабатывает в начале контрольной точки. arg0 содержит битовые флаги, с "
"помощью которых задаются разные типы контрольных точек, такие как shutdown, "
"immediate или force."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3595(literal)
msgid "checkpoint-done"
msgstr "checkpoint-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3596(literal)
msgid "(int, int, int, int, int)"
msgstr "(int, int, int, int, int)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3597(entry)
msgid ""
"Probe that fires when a checkpoint is complete. (The probes listed next fire "
"in sequence during checkpoint processing.) arg0 is the number of buffers "
"written. arg1 is the total number of buffers. arg2, arg3 and arg4 contain "
"the number of WAL files added, removed and recycled respectively."
msgstr ""
"Срабатывает по завершении контрольной точки. (Перечисленные далее точки "
"трассировки срабатывают последовательно при обработке контрольной точки.) "
"arg0 задаёт число записанных буферов. arg1 &mdash; общее число буферов. "
"arg2, arg3 и arg4 задают число файлов WAL, которые были добавлены, удалены "
"или переработаны, соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3604(literal)
msgid "clog-checkpoint-start"
msgstr "clog-checkpoint-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3605(literal) monitoring.xml:3612(literal)
#: monitoring.xml:3618(literal) monitoring.xml:3626(literal)
#: monitoring.xml:3633(literal) monitoring.xml:3641(literal)
msgid "(bool)"
msgstr "(bool)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3606(entry)
msgid ""
"Probe that fires when the CLOG portion of a checkpoint is started. arg0 is "
"true for normal checkpoint, false for shutdown checkpoint."
msgstr ""
"Срабатывает, когда начинается запись контрольной точки в CLOG. arg0 = true "
"для обычных контрольных точек и false для контрольных точек типа shutdown."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3611(literal)
msgid "clog-checkpoint-done"
msgstr "clog-checkpoint-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3613(entry)
msgid ""
"Probe that fires when the CLOG portion of a checkpoint is complete. arg0 has "
"the same meaning as for <literal>clog-checkpoint-start</literal>."
msgstr ""
"Срабатывает по завершении записи контрольной точки в CLOG. Значение arg0 "
"задаётся аналогично значению для <literal>clog-checkpoint-start</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3617(literal)
msgid "subtrans-checkpoint-start"
msgstr "subtrans-checkpoint-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3619(entry)
msgid ""
"Probe that fires when the SUBTRANS portion of a checkpoint is started. arg0 "
"is true for normal checkpoint, false for shutdown checkpoint."
msgstr ""
"Срабатывает, когда начинается запись контрольной точки в SUBTRANS. arg0 = "
"true для обычных контрольных точек и false для контрольных точек типа "
"shutdown."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3625(literal)
msgid "subtrans-checkpoint-done"
msgstr "subtrans-checkpoint-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3627(entry)
msgid ""
"Probe that fires when the SUBTRANS portion of a checkpoint is complete. arg0 "
"has the same meaning as for <literal>subtrans-checkpoint-start</literal>."
msgstr ""
"Срабатывает по завершении записи контрольной точки в SUBTRANS. Значение arg0 "
"задаётся аналогично значению для <literal>subtrans-checkpoint-start</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3632(literal)
msgid "multixact-checkpoint-start"
msgstr "multixact-checkpoint-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3634(entry)
msgid ""
"Probe that fires when the MultiXact portion of a checkpoint is started. arg0 "
"is true for normal checkpoint, false for shutdown checkpoint."
msgstr ""
"Срабатывает, когда начинается запись контрольной точки в MultiXact. arg0 = "
"true для обычных контрольных точек и false для контрольных точек типа "
"shutdown."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3640(literal)
msgid "multixact-checkpoint-done"
msgstr "multixact-checkpoint-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3642(entry)
msgid ""
"Probe that fires when the MultiXact portion of a checkpoint is complete. "
"arg0 has the same meaning as for <literal>multixact-checkpoint-start</"
"literal>."
msgstr ""
"Срабатывает по завершении записи контрольной точки в MultiXact. Значение "
"arg0 задаётся аналогично значению для <literal>multixact-checkpoint-start</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3647(literal)
msgid "buffer-checkpoint-start"
msgstr "buffer-checkpoint-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3649(entry)
msgid ""
"Probe that fires when the buffer-writing portion of a checkpoint is started. "
"arg0 holds the bitwise flags used to distinguish different checkpoint types, "
"such as shutdown, immediate or force."
msgstr ""
"Срабатывает, когда начинается запись буферов контрольной точки. arg0 "
"содержит битовые флаги, с помощью которых задаются разные типы контрольных "
"точек, такие как shutdown, immediate или force."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3655(literal)
msgid "buffer-sync-start"
msgstr "buffer-sync-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3656(literal)
msgid "(int, int)"
msgstr "(int, int)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3657(entry)
msgid ""
"Probe that fires when we begin to write dirty buffers during checkpoint "
"(after identifying which buffers must be written). arg0 is the total number "
"of buffers. arg1 is the number that are currently dirty and need to be "
"written."
msgstr ""
"Срабатывает во время контрольной точки, когда начинается запись грязных "
"буферов (после нахождения буферов, которые должны быть записаны). arg0 "
"задаёт общее число буферов. arg1 задаёт число буферов, которые в настоящий "
"момент являются грязными и должны быть записаны."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3663(literal)
msgid "buffer-sync-written"
msgstr "buffer-sync-written"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3665(entry)
msgid ""
"Probe that fires after each buffer is written during checkpoint. arg0 is the "
"ID number of the buffer."
msgstr ""
"Срабатывает после записи каждого буфера при выполнении контрольной точки. "
"arg0 задаёт идентификатор буфера."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3669(literal)
msgid "buffer-sync-done"
msgstr "buffer-sync-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3670(literal)
msgid "(int, int, int)"
msgstr "(int, int, int)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3671(entry)
msgid ""
"Probe that fires when all dirty buffers have been written. arg0 is the total "
"number of buffers. arg1 is the number of buffers actually written by the "
"checkpoint process. arg2 is the number that were expected to be written "
"(arg1 of <literal>buffer-sync-start</literal>); any difference reflects "
"other processes flushing buffers during the checkpoint."
msgstr ""
"Срабатывает после записи всех грязных буферов. arg0 задаёт общее число "
"буферов. arg1 задаёт число буферов, которые фактически были записаны "
"процессом выполнения контрольной точки. arg2 задаёт число буферов, которое "
"должно было быть записано (arg1 из <literal>buffer-sync-start</literal>); "
"разные значения говорят о том, что во время выполнения этой контрольной "
"точки буферы сбрасывались другими процессами."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3679(literal)
msgid "buffer-checkpoint-sync-start"
msgstr "buffer-checkpoint-sync-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3681(entry)
msgid ""
"Probe that fires after dirty buffers have been written to the kernel, and "
"before starting to issue fsync requests."
msgstr ""
"Срабатывает после записи грязных буферов в ядро и до начала формирования "
"запросов fsync."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3685(literal)
msgid "buffer-checkpoint-done"
msgstr "buffer-checkpoint-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3687(entry)
msgid "Probe that fires when syncing of buffers to disk is complete."
msgstr "Срабатывает по завершении синхронизации буферов с диском."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3691(literal)
msgid "twophase-checkpoint-start"
msgstr "twophase-checkpoint-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3693(entry)
msgid "Probe that fires when the two-phase portion of a checkpoint is started."
msgstr ""
"Срабатывает, когда начинается двухфазный этап выполнения контрольной точки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3697(literal)
msgid "twophase-checkpoint-done"
msgstr "twophase-checkpoint-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3699(entry)
msgid ""
"Probe that fires when the two-phase portion of a checkpoint is complete."
msgstr ""
"Срабатывает по завершении двухфазного этапа выполнения контрольной точки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3703(literal)
msgid "buffer-read-start"
msgstr "buffer-read-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3704(literal)
msgid "(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)"
msgstr "(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3705(entry)
msgid ""
"Probe that fires when a buffer read is started. arg0 and arg1 contain the "
"fork and block numbers of the page (but arg1 will be -1 if this is a "
"relation extension request). arg2, arg3, and arg4 contain the tablespace, "
"database, and relation OIDs identifying the relation. arg5 is the ID of the "
"backend which created the temporary relation for a local buffer, or "
"<symbol>InvalidBackendId</symbol> (-1) for a shared buffer. arg6 is true for "
"a relation extension request, false for normal read."
msgstr ""
"Срабатывает, когда начинается чтение из буфера. arg0 и arg1 содержат номер "
"слоя и блока этой страницы (arg1 будет иметь значение -1, если выполняется "
"запрос на расширение места для таблицы). arg2, arg3 и arg4 содержат OID-ы "
"табличного пространства, базы данных и отношения, которые однозначно "
"идентифицируют отношение. arg5 для локального буфера задаёт идентификатор "
"серверного процесса, создавшего временное отношение, или "
"<symbol>InvalidBackendId</symbol> (-1) &mdash; для разделяемого буфера. arg6 "
"= true для запросов на расширение места для таблицы, false &mdash; в случае "
"обычного чтения."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3716(literal)
msgid "buffer-read-done"
msgstr "buffer-read-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3717(literal)
msgid "(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)"
msgstr "(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3718(entry)
msgid ""
"Probe that fires when a buffer read is complete. arg0 and arg1 contain the "
"fork and block numbers of the page (if this is a relation extension request, "
"arg1 now contains the block number of the newly added block). arg2, arg3, "
"and arg4 contain the tablespace, database, and relation OIDs identifying the "
"relation. arg5 is the ID of the backend which created the temporary relation "
"for a local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared "
"buffer. arg6 is true for a relation extension request, false for normal "
"read. arg7 is true if the buffer was found in the pool, false if not."
msgstr ""
"Срабатывает по завершении чтения буфера. arg0 и arg1 содержат номер слоя и "
"номер блока этой страницы (arg1 будет содержать номер только что "
"добавленного блока, если выполняется запрос на расширение места для "
"таблицы). arg2, arg3 и arg4 содержат OID-ы табличного пространства, базы "
"данных и отношения, которые однозначно идентифицируют отношение. arg5 для "
"локального буфера задаёт идентификатор серверного процесса, создавшего "
"временное отношение, или <symbol>InvalidBackendId</symbol> (-1) &mdash; для "
"разделяемого буфера. arg6 = true для запросов на расширение места для "
"таблицы, false &mdash; в случае обычного чтения. arg7 = true, если буфер был "
"обнаружен в пуле, false &mdash; если нет."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3731(literal)
msgid "buffer-flush-start"
msgstr "buffer-flush-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3732(literal) monitoring.xml:3741(literal)
#: monitoring.xml:3749(literal) monitoring.xml:3760(literal)
msgid "(ForkNumber, BlockNumber, Oid, Oid, Oid)"
msgstr "(ForkNumber, BlockNumber, Oid, Oid, Oid)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3733(entry)
msgid ""
"Probe that fires before issuing any write request for a shared buffer. arg0 "
"and arg1 contain the fork and block numbers of the page. arg2, arg3, and "
"arg4 contain the tablespace, database, and relation OIDs identifying the "
"relation."
msgstr ""
"Срабатывает перед формированием любого запроса на запись в разделяемый "
"буфер. arg0 и arg1 содержат номер слоя и номер блока этой страницы. arg2, "
"arg3 и arg4 содержат OID-ы табличного пространства, базы данных и отношения, "
"которые однозначно идентифицируют отношение."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3740(literal)
msgid "buffer-flush-done"
msgstr "buffer-flush-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3742(entry)
msgid ""
"Probe that fires when a write request is complete. (Note that this just "
"reflects the time to pass the data to the kernel; it's typically not "
"actually been written to disk yet.) The arguments are the same as for "
"<literal>buffer-flush-start</literal>."
msgstr ""
"Срабатывает по завершении запроса на запись. (Учтите, что это отражает "
"только момент передачи данных в ядро; обычно на диск они ещё не записаны.) "
"Аргументы аналогичны <literal>buffer-flush-start</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3748(literal)
msgid "buffer-write-dirty-start"
msgstr "buffer-write-dirty-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3750(entry)
msgid ""
"Probe that fires when a server process begins to write a dirty buffer. (If "
"this happens often, it implies that <xref linkend=\"guc-shared-buffers\"/> "
"is too small or the background writer control parameters need adjustment.) "
"arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, "
"and arg4 contain the tablespace, database, and relation OIDs identifying the "
"relation."
msgstr ""
"Срабатывает, когда серверный процесс начинает запись грязного буфера. "
"(Частое повторение такой пробы означает, что значение <xref linkend=\"guc-"
"shared-buffers\"/> слишком мало или что необходимо откорректировать "
"управляющие параметры процесса фоновой записи.) arg0 и arg1 содержат номер "
"слоя и блока этой страницы. arg2, arg3 и arg4 содержат OID-ы табличного "
"пространства, базы данных и отношения, которые однозначно идентифицируют "
"отношение."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3759(literal)
msgid "buffer-write-dirty-done"
msgstr "buffer-write-dirty-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3761(entry)
msgid ""
"Probe that fires when a dirty-buffer write is complete. The arguments are "
"the same as for <literal>buffer-write-dirty-start</literal>."
msgstr ""
"Срабатывает по завершении записи грязного буфера. Аргументы аналогичны "
"<literal>buffer-write-dirty-start</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3765(literal)
msgid "wal-buffer-write-dirty-start"
msgstr "wal-buffer-write-dirty-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3767(entry)
msgid ""
"Probe that fires when a server process begins to write a dirty WAL buffer "
"because no more WAL buffer space is available. (If this happens often, it "
"implies that <xref linkend=\"guc-wal-buffers\"/> is too small.)"
msgstr ""
"Срабатывает, когда серверный процесс начинает запись грязного WAL буфера из-"
"за того, что свободные WAL буферы закончились. (Частое повторение такой "
"ситуации означает, что значение <xref linkend=\"guc-wal-buffers\"/> слишком "
"мало.)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3773(literal)
msgid "wal-buffer-write-dirty-done"
msgstr "wal-buffer-write-dirty-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3775(entry)
msgid "Probe that fires when a dirty WAL buffer write is complete."
msgstr "Срабатывает по завершении записи грязного WAL буфера."

#. +> REL_10
#: monitoring.xml:3778(literal)
msgid "wal-insert"
msgstr "wal-insert"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3779(literal)
msgid "(unsigned char, unsigned char)"
msgstr "(unsigned char, unsigned char)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3780(entry)
msgid ""
"Probe that fires when a WAL record is inserted. arg0 is the resource manager "
"(rmid) for the record. arg1 contains the info flags."
msgstr ""
"Срабатывает при добавлении записи в WAL. arg0 задаёт идентификатор менеджера "
"ресурсов (rmid) для этой записи. arg1 задаёт информационные флаги."

#. +> REL_10
#: monitoring.xml:3785(literal)
msgid "wal-switch"
msgstr "wal-switch"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3787(entry)
msgid "Probe that fires when a WAL segment switch is requested."
msgstr "Срабатывает при запросе на переключение сегмента WAL."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3790(literal)
msgid "smgr-md-read-start"
msgstr "smgr-md-read-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3791(literal) monitoring.xml:3813(literal)
msgid "(ForkNumber, BlockNumber, Oid, Oid, Oid, int)"
msgstr "(ForkNumber, BlockNumber, Oid, Oid, Oid, int)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3792(entry)
msgid ""
"Probe that fires when beginning to read a block from a relation. arg0 and "
"arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 "
"contain the tablespace, database, and relation OIDs identifying the "
"relation. arg5 is the ID of the backend which created the temporary relation "
"for a local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared "
"buffer."
msgstr ""
"Срабатывает, когда начинается чтение блока из отношения. arg0 and arg1 "
"содержат номер слоя и номер блока этой страницы. arg2, arg3 и arg4 содержат "
"OID-ы табличного пространства, базы данных и отношения, которые однозначно "
"идентифицируют отношение. arg5 для локального буфера задаёт идентификатор "
"серверного процесса, создавшего временное отношение, или "
"<symbol>InvalidBackendId</symbol> (-1) для разделяемого буфера."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3800(literal)
msgid "smgr-md-read-done"
msgstr "smgr-md-read-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3801(literal) monitoring.xml:3823(literal)
msgid "(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)"
msgstr "(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3802(entry)
msgid ""
"Probe that fires when a block read is complete. arg0 and arg1 contain the "
"fork and block numbers of the page. arg2, arg3, and arg4 contain the "
"tablespace, database, and relation OIDs identifying the relation. arg5 is "
"the ID of the backend which created the temporary relation for a local "
"buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer. arg6 "
"is the number of bytes actually read, while arg7 is the number requested (if "
"these are different it indicates trouble)."
msgstr ""
"Срабатывает по завершении чтения блока. arg0 и arg1 содержат номер слоя и "
"номер блока страницы. arg2, arg3 и arg4 содержат OID-ы табличного "
"пространства, базы данных и отношения, которые однозначно идентифицируют "
"отношение. arg5 для локального буфера задаёт идентификатор серверного "
"процесса, создавшего временное отношение, или <symbol>InvalidBackendId</"
"symbol> (-1) &mdash; для разделяемого буфера. arg6 задаёт количество "
"фактически прочитанных байтов, тогда как arg7 задаёт количество запрошенных "
"байтов (различия говорят о наличии проблемы)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3812(literal)
msgid "smgr-md-write-start"
msgstr "smgr-md-write-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3814(entry)
msgid ""
"Probe that fires when beginning to write a block to a relation. arg0 and "
"arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 "
"contain the tablespace, database, and relation OIDs identifying the "
"relation. arg5 is the ID of the backend which created the temporary relation "
"for a local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared "
"buffer."
msgstr ""
"Срабатывает, когда начинается запись блока в отношение. arg0 и arg1 содержат "
"номер слоя и номер блока этой страницы. arg2, arg3 и arg4 содержат OID-ы "
"табличного пространства, базы данных и отношения, которые однозначно "
"идентифицируют отношение. arg5 для локального буфера задаёт идентификатор "
"серверного процесса, создавшего временное отношение, или "
"<symbol>InvalidBackendId</symbol> (-1) &mdash; для разделяемого буфера."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3822(literal)
msgid "smgr-md-write-done"
msgstr "smgr-md-write-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3824(entry)
msgid ""
"Probe that fires when a block write is complete. arg0 and arg1 contain the "
"fork and block numbers of the page. arg2, arg3, and arg4 contain the "
"tablespace, database, and relation OIDs identifying the relation. arg5 is "
"the ID of the backend which created the temporary relation for a local "
"buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer. arg6 "
"is the number of bytes actually written, while arg7 is the number requested "
"(if these are different it indicates trouble)."
msgstr ""
"Срабатывает по завершении записи блока. arg0 и arg1 содержат номер слоя и "
"номер блока этой страницы. arg2, arg3 и arg4 содержат OID-ы табличного "
"пространства, базы данных и отношения, которые однозначно идентифицируют "
"отношение. arg5 для локального буфера задаёт идентификатор серверного "
"процесса, создавшего временное отношение, или <symbol>InvalidBackendId</"
"symbol> (-1) &mdash; для разделяемого буфера. arg6 задаёт количество "
"фактически записанных байтов, тогда как arg7 задаёт количество запрошенных "
"байтов (различия говорят о наличии проблемы)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3834(literal)
msgid "sort-start"
msgstr "sort-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3835(literal)
msgid "(int, bool, int, int, bool)"
msgstr "(int, bool, int, int, bool)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3836(entry)
msgid ""
"Probe that fires when a sort operation is started. arg0 indicates heap, "
"index or datum sort. arg1 is true for unique-value enforcement. arg2 is the "
"number of key columns. arg3 is the number of kilobytes of work memory "
"allowed. arg4 is true if random access to the sort result is required."
msgstr ""
"Срабатывает, когда начинается операция сортировки. arg0 задаёт сортировку "
"таблицы, индекса или элемента данных. arg1 = true, если данные ожидаются "
"уникальными. arg2 задаёт число ключевых столбцов. arg3 задаёт объём "
"доступной рабочей памяти в килобайтах. arg4 = true, если требуется "
"произвольный доступ к результату сортировки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3844(literal)
msgid "sort-done"
msgstr "sort-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3845(literal)
msgid "(bool, long)"
msgstr "(bool, long)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3846(entry)
msgid ""
"Probe that fires when a sort is complete. arg0 is true for external sort, "
"false for internal sort. arg1 is the number of disk blocks used for an "
"external sort, or kilobytes of memory used for an internal sort."
msgstr ""
"Срабатывает по завершении сортировки. arg0 = true для внешней сортировки, "
"false &mdash; для внутренней сортировки. arg1 задаёт число дисковых блоков, "
"использованных для внешней сортировки, или объём памяти, использованной для "
"внутренней сортировки, в килобайтах."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3852(literal)
msgid "lwlock-acquire"
msgstr "lwlock-acquire"

#. +> REL_10
#: monitoring.xml:3853(literal) monitoring.xml:3867(literal)
#: monitoring.xml:3875(literal) monitoring.xml:3883(literal)
#: monitoring.xml:3891(literal)
msgid "(char *, LWLockMode)"
msgstr "(char *, LWLockMode)"

#. +> REL_10
#: monitoring.xml:3854(entry)
msgid ""
"Probe that fires when an LWLock has been acquired. arg0 is the LWLock's "
"tranche. arg1 is the requested lock mode, either exclusive or shared."
msgstr ""
"Срабатывает, когда выдаётся блокировка LWLock. В arg0 передаётся транш "
"блокировки, в arg1 запрошенный режим блокировки (исключительная или "
"разделяемая)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3859(literal)
msgid "lwlock-release"
msgstr "lwlock-release"

#. +> REL_10
#: monitoring.xml:3860(literal)
msgid "(char *)"
msgstr "(char *)"

#. +> REL_10
#: monitoring.xml:3861(entry)
msgid ""
"Probe that fires when an LWLock has been released (but note that any "
"released waiters have not yet been awakened). arg0 is the LWLock's tranche."
msgstr ""
"Срабатывает, когда блокировка LWLock освобождается (но учтите, что никакие "
"ждущие процессы ещё не пробуждены). В arg0 передаётся транш блокировки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3866(literal)
msgid "lwlock-wait-start"
msgstr "lwlock-wait-start"

#. +> REL_10
#: monitoring.xml:3868(entry)
msgid ""
"Probe that fires when an LWLock was not immediately available and a server "
"process has begun to wait for the lock to become available. arg0 is the "
"LWLock's tranche. arg1 is the requested lock mode, either exclusive or "
"shared."
msgstr ""
"Срабатывает, когда блокировка LWLock не доступна моментально, и серверный "
"процесс начал ожидать её доступности. В arg0 передаётся транш блокировки, в "
"arg1 запрошенный режим блокировки (исключительная или разделяемая)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3874(literal)
msgid "lwlock-wait-done"
msgstr "lwlock-wait-done"

#. +> REL_10
#: monitoring.xml:3876(entry)
msgid ""
"Probe that fires when a server process has been released from its wait for "
"an LWLock (it does not actually have the lock yet). arg0 is the LWLock's "
"tranche. arg1 is the requested lock mode, either exclusive or shared."
msgstr ""
"Срабатывает, когда серверный процесс прекращает ожидание блокировки LWLock "
"(но саму блокировку он ещё не получил). В arg0 передаётся транш блокировки, "
"в arg1 запрошенный режим блокировки (исключительная или разделяемая)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3882(literal)
msgid "lwlock-condacquire"
msgstr "lwlock-condacquire"

#. +> REL_10
#: monitoring.xml:3884(entry)
msgid ""
"Probe that fires when an LWLock was successfully acquired when the caller "
"specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested "
"lock mode, either exclusive or shared."
msgstr ""
"Срабатывает, когда блокировка LWLock была успешно получена процессом, "
"запросившим её в режиме без ожидания. В arg0 передаётся транш блокировки, в "
"arg1 запрошенный режим блокировки (исключительная или разделяемая)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3890(literal)
msgid "lwlock-condacquire-fail"
msgstr "lwlock-condacquire-fail"

#. +> REL_10
#: monitoring.xml:3892(entry)
msgid ""
"Probe that fires when an LWLock was not successfully acquired when the "
"caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the "
"requested lock mode, either exclusive or shared."
msgstr ""
"Срабатывает, когда блокировка LWLock не была успешно получена процессом, "
"запросившим её в режиме без ожидания. В arg0 передаётся транш блокировки, в "
"arg1 запрошенный режим блокировки (исключительная или разделяемая)."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3898(literal)
msgid "lock-wait-start"
msgstr "lock-wait-start"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3899(literal) monitoring.xml:3908(literal)
msgid ""
"(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, "
"LOCKMODE)"
msgstr ""
"(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, "
"LOCKMODE)"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3900(entry)
msgid ""
"Probe that fires when a request for a heavyweight lock (lmgr lock) has begun "
"to wait because the lock is not available. arg0 through arg3 are the tag "
"fields identifying the object being locked. arg4 indicates the type of "
"object being locked. arg5 indicates the lock type being requested."
msgstr ""
"Срабатывает, когда запрос на тяжёлую блокировку (блокировку lmgr) переходит "
"в состояние ожидания, поскольку блокировка недоступна. Аргументы с arg0 до "
"arg3 задают атрибуты, идентифицирующие объект, на который накладывается "
"блокировка. arg4 задаёт тип объекта, на который накладывается блокировка. "
"arg5 задаёт тип запрошенной блокировки."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3907(literal)
msgid "lock-wait-done"
msgstr "lock-wait-done"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3909(entry)
msgid ""
"Probe that fires when a request for a heavyweight lock (lmgr lock) has "
"finished waiting (i.e., has acquired the lock). The arguments are the same "
"as for <literal>lock-wait-start</literal>."
msgstr ""
"Срабатывает, когда запрос на тяжёлую блокировку (блокировку lmgr) выходит из "
"состояния ожидания (т. е. получает блокировку). Аргументы аналогичны "
"<literal>lock-wait-start</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3914(literal)
msgid "deadlock-found"
msgstr "deadlock-found"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3916(entry)
msgid "Probe that fires when a deadlock is found by the deadlock detector."
msgstr ""
"Срабатывает, когда детектор взаимных блокировок обнаруживает такую взаимную "
"блокировку"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3925(title)
msgid "Defined Types Used in Probe Parameters"
msgstr "Предопределённые типы, используемые в параметрах точек трассировки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3930(entry)
msgid "Definition"
msgstr "Определение"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3937(type)
msgid "LocalTransactionId"
msgstr "LocalTransactionId"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3938(type) monitoring.xml:3950(type)
#: monitoring.xml:3954(type)
msgid "unsigned int"
msgstr "unsigned int"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3941(type)
msgid "LWLockMode"
msgstr "LWLockMode"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3942(type) monitoring.xml:3946(type)
#: monitoring.xml:3958(type)
msgid "int"
msgstr "int"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3945(type)
msgid "LOCKMODE"
msgstr "LOCKMODE"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3949(type)
msgid "BlockNumber"
msgstr "BlockNumber"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3957(type)
msgid "ForkNumber"
msgstr "ForkNumber"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3961(type)
msgid "bool"
msgstr "bool"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3962(type)
msgid "char"
msgstr "char"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3973(title)
msgid "Using Probes"
msgstr "Использование точек трассировки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3979(programlisting)
#, no-wrap
msgid ""
"#!/usr/sbin/dtrace -qs\n"
"\n"
"postgresql$1:::transaction-start\n"
"{\n"
"      @start[\"Start\"] = count();\n"
"      self-&gt;ts  = timestamp;\n"
"}\n"
"\n"
"postgresql$1:::transaction-abort\n"
"{\n"
"      @abort[\"Abort\"] = count();\n"
"}\n"
"\n"
"postgresql$1:::transaction-commit\n"
"/self-&gt;ts/\n"
"{\n"
"      @commit[\"Commit\"] = count();\n"
"      @time[\"Total time (ns)\"] = sum(timestamp - self-&gt;ts);\n"
"      self-&gt;ts=0;\n"
"}"
msgstr ""
"#!/usr/sbin/dtrace -qs\n"
"\n"
"postgresql$1:::transaction-start\n"
"{\n"
"      @start[\"Start\"] = count();\n"
"      self-&gt;ts  = timestamp;\n"
"}\n"
"\n"
"postgresql$1:::transaction-abort\n"
"{\n"
"      @abort[\"Abort\"] = count();\n"
"}\n"
"\n"
"postgresql$1:::transaction-commit\n"
"/self-&gt;ts/\n"
"{\n"
"      @commit[\"Commit\"] = count();\n"
"      @time[\"Total time (ns)\"] = sum(timestamp - self-&gt;ts);\n"
"      self-&gt;ts=0;\n"
"}"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:3975(para)
msgid ""
"The example below shows a DTrace script for analyzing transaction counts in "
"the system, as an alternative to snapshotting <structname>pg_stat_database</"
"structname> before and after a performance test: <placeholder-1/> When "
"executed, the example D script gives output such as: <screen>\n"
"# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;\n"
"^C\n"
"\n"
"Start                                          71\n"
"Commit                                         70\n"
"Total time (ns)                        2312105013\n"
"</screen>"
msgstr ""
"В приведённом ниже примере показан скрипт DTrace для анализа числа "
"транзакций в системе, который можно использовать в качестве альтернативы "
"созданию снимка данных <structname>pg_stat_database</structname> до и после "
"выполнения теста производительности: <placeholder-1/> При выполнении этот D-"
"скрипт возвращает результат вида: <screen>\n"
"# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;\n"
"^C\n"
"\n"
"Start                                          71\n"
"Commit                                         70\n"
"Total time (ns)                        2312105013\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4013(para)
msgid ""
"SystemTap uses a different notation for trace scripts than DTrace does, even "
"though the underlying trace points are compatible. One point worth noting is "
"that at this writing, SystemTap scripts must reference probe names using "
"double underscores in place of hyphens. This is expected to be fixed in "
"future SystemTap releases."
msgstr ""
"SystemTap использует отличную от DTrace нотацию для скриптов трассировки, "
"хотя лежащие в их основе точки трассировки совместимы. Стоит отметить, что "
"на момент написания этой главы в скриптах SystemTap имена точек трассировки "
"должны обрамляться двойными подчёркиваниями, а не дефисами. Ожидается, что "
"эта проблема будет решена в следующих версиях SystemTap."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4022(para)
msgid ""
"You should remember that DTrace scripts need to be carefully written and "
"debugged, otherwise the trace information collected might be meaningless. In "
"most cases where problems are found it is the instrumentation that is at "
"fault, not the underlying system. When discussing information found using "
"dynamic tracing, be sure to enclose the script used to allow that too to be "
"checked and discussed."
msgstr ""
"Необходимо помнить, что скрипты DTrace должны быть аккуратно написаны и "
"отлажены, в противном случае собранная трассировочная информация может "
"оказаться бессмысленной. В большинстве случаев причиной обнаруженных проблем "
"является инструментарий, а не сама система. Отправляя на рассмотрение "
"данные, полученные с использованием динамической трассировки, обязательно "
"прилагайте скрипт, с помощью которого они были получены, для того чтобы его "
"также проверить и обсудить."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4033(title)
msgid "Defining New Probes"
msgstr "Задание новых точек трассировки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4035(para)
msgid ""
"New probes can be defined within the code wherever the developer desires, "
"though this will require a recompilation. Below are the steps for inserting "
"new probes:"
msgstr ""
"Новые точки трассировки разработчик может определить в любом участке кода, "
"однако это потребует перекомпиляции. Ниже приведены шаги, необходимые для "
"добавления новых точек трассировки:"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4043(para)
msgid "Decide on probe names and data to be made available through the probes"
msgstr ""
"Определить имена точек трассировки и данные, которые будут доступны в этих "
"точках"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4049(para)
msgid ""
"Add the probe definitions to <filename>src/backend/utils/probes.d</filename>"
msgstr ""
"Добавить описание точек трассировки в <filename>src/backend/utils/probes.d</"
"filename>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4055(para)
msgid ""
"Include <filename>pg_trace.h</filename> if it is not already present in the "
"module(s) containing the probe points, and insert <literal>TRACE_POSTGRESQL</"
"literal> probe macros at the desired locations in the source code"
msgstr ""
"Включить <filename>pg_trace.h</filename>, если его ещё не использовали в "
"модуле (модулях), содержащих точки трассировки, и вставить "
"<literal>TRACE_POSTGRESQL</literal> отладочные макросы в нужные места "
"исходного кода"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4064(para)
msgid "Recompile and verify that the new probes are available"
msgstr "Перекомпилировать и убедиться в доступности новых точек трассировки"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4071(title)
msgid "Example:"
msgstr "Пример:"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4072(para)
msgid ""
"Here is an example of how you would add a probe to trace all new "
"transactions by transaction ID."
msgstr ""
"Вот пример того, как можно добавить точку для трассировки всех новых "
"транзакций по их идентификатору."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4080(para)
msgid ""
"Decide that the probe will be named <literal>transaction-start</literal> and "
"requires a parameter of type <type>LocalTransactionId</type>"
msgstr ""
"Устанавливаем, что проба будет называться <literal>transaction-start</"
"literal> и принимать параметр типа <type>LocalTransactionId</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4089(programlisting)
#, no-wrap
msgid "probe transaction__start(LocalTransactionId);"
msgstr "probe transaction__start(LocalTransactionId);"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4087(para)
msgid ""
"Add the probe definition to <filename>src/backend/utils/probes.d</filename>: "
"<placeholder-1/> Note the use of the double underline in the probe name. In "
"a DTrace script using the probe, the double underline needs to be replaced "
"with a hyphen, so <literal>transaction-start</literal> is the name to "
"document for users."
msgstr ""
"Добавляем определение пробы в <filename>src/backend/utils/probes.d</"
"filename>: <placeholder-1/> Обратите внимание на использование двойного "
"подчёркивания в имени пробы. В скрипте DTrace, использующем эту точку, "
"двойное подчёркивание нужно будет заменить дефисом, поэтому в документации "
"для пользователей имя этой пробы — <literal>transaction-start</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4107(programlisting)
#, no-wrap
msgid "TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);"
msgstr "TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4100(para)
msgid ""
"At compile time, <literal>transaction__start</literal> is converted to a "
"macro called <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal> (notice "
"the underscores are single here), which is available by including "
"<filename>pg_trace.h</filename>. Add the macro call to the appropriate "
"location in the source code. In this case, it looks like the following: "
"<placeholder-1/>"
msgstr ""
"Во время компиляции <literal>transaction__start</literal> преобразуется в "
"макрос <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal> (обратите "
"внимание, что здесь используется одинарное подчёркивание), который доступен "
"в результате включения <filename>pg_trace.h</filename>. Добавим вызов "
"макроса в требуемую точку исходного кода. В данном случае это будет "
"выглядеть приблизительно так: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4114(para)
msgid ""
"After recompiling and running the new binary, check that your newly added "
"probe is available by executing the following DTrace command. You should see "
"similar output: <screen>\n"
"# dtrace -ln transaction-start\n"
"   ID    PROVIDER          MODULE           FUNCTION NAME\n"
"18705 postgresql49878     postgres     StartTransactionCommand transaction-"
"start\n"
"18755 postgresql49877     postgres     StartTransactionCommand transaction-"
"start\n"
"18805 postgresql49876     postgres     StartTransactionCommand transaction-"
"start\n"
"18855 postgresql49875     postgres     StartTransactionCommand transaction-"
"start\n"
"18986 postgresql49873     postgres     StartTransactionCommand transaction-"
"start\n"
"</screen>"
msgstr ""
"После перекомпиляции и запуска нового бинарного файла используйте следующую "
"команду DTrace, чтобы проверить доступность только что добавленной пробы. "
"Должен получиться результат, подобный этому: <screen>\n"
"# dtrace -ln transaction-start\n"
"   ID    PROVIDER          MODULE           FUNCTION NAME\n"
"18705 postgresql49878     postgres     StartTransactionCommand transaction-"
"start\n"
"18755 postgresql49877     postgres     StartTransactionCommand transaction-"
"start\n"
"18805 postgresql49876     postgres     StartTransactionCommand transaction-"
"start\n"
"18855 postgresql49875     postgres     StartTransactionCommand transaction-"
"start\n"
"18986 postgresql49873     postgres     StartTransactionCommand transaction-"
"start\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4137(para)
msgid ""
"You should take care that the data types specified for a probe's parameters "
"match the data types of the variables used in the macro. Otherwise, you will "
"get compilation errors."
msgstr ""
"Нужно убедиться, что типы данных, определённые в параметрах пробы, совпадают "
"с типами данных переменных, которые используются в макросе. В противном "
"случае компиляция завершится с ошибками."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4157(programlisting)
#, no-wrap
msgid ""
"if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())\n"
"    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));"
msgstr ""
"if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())\n"
"    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));"

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4146(para)
msgid ""
"On most platforms, if <productname>PostgreSQL</productname> is built with "
"<option>--enable-dtrace</option>, the arguments to a trace macro will be "
"evaluated whenever control passes through the macro, <emphasis>even if no "
"tracing is being done</emphasis>. This is usually not worth worrying about "
"if you are just reporting the values of a few local variables. But beware of "
"putting expensive function calls into the arguments. If you need to do that, "
"consider protecting the macro with a check to see if the trace is actually "
"enabled: <placeholder-1/> Each trace macro has a corresponding "
"<literal>ENABLED</literal> macro."
msgstr ""
"В большинстве платформ в случае, если <productname>PostgreSQL</productname> "
"собран с указанием <option>--enable-dtrace</option>, то аргументы макроса "
"трассировки вычисляются каждый раз, когда макрос получает управление, "
"<emphasis>даже если трассировка не выполняется</emphasis>. Об этом не стоит "
"беспокоиться, если вы просто возвращаете значения небольшого числа локальных "
"переменных. Однако избегайте использования ресурсоёмких вызовов функций в "
"аргументах. Если это необходимо, то постарайтесь защитить макрос проверкой, "
"которая будет определять, действительно ли включена трассировка: "
"<placeholder-1/> Каждый макрос трассировки имеет соответствующий макрос "
"<literal>ENABLED</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:4131(para)
msgid ""
"There are a few things to be careful about when adding trace macros to the C "
"code: <placeholder-1/>"
msgstr ""
"При добавлении макросов трассировки в код, написанный на языке C, необходимо "
"позаботиться о следующем: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: monitoring.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:618(entry)
msgid ""
"Time when this process was started, i.e., when the client connected to the "
"server"
msgstr ""
"Время запуска процесса, т. е. время, когда клиент подсоединился к серверу"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:651(para)
msgid ""
"<literal>LWLockNamed</literal>: The backend is waiting for a specific named "
"lightweight lock. Each such lock protects a particular data structure in "
"shared memory. <literal>wait_event</literal> will contain the name of the "
"lightweight lock."
msgstr ""
"<literal>LWLockNamed</literal>: Обслуживающий процесс ожидает определённую "
"именованную лёгкую блокировку. Такие блокировки защищают определённые "
"структуры данных в разделяемой памяти. Имя блокировки будет показывается в "
"<literal>wait_event</literal>."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:752(entry)
msgid ""
"Text of this backend's most recent query. If <structfield>state</"
"structfield> is <literal>active</literal> this field shows the currently "
"executing query. In all other states, it shows the last query that was "
"executed."
msgstr ""
"Текст последнего запроса этого серверного процесса. Если <structfield>state</"
"structfield> имеет значение <literal>active</literal>, то в этом поле "
"отображается запрос, который выполняется в настоящий момент. Если процесс "
"находится в любом другом состоянии, то в этом поле отображается последний "
"выполненный запрос."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:793(literal)
msgid "LWLockNamed"
msgstr "LWLockNamed"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1109(programlisting)
#, no-wrap
msgid ""
"SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;\n"
" pid  | wait_event_type |  wait_event\n"
"------+-----------------+---------------\n"
" 2540 | Lock            | relation\n"
" 6644 | LWLockNamed     | ProcArrayLock\n"
"(2 rows)"
msgstr ""
"SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;\n"
" pid  | wait_event_type |  wait_event\n"
"------+-----------------+---------------\n"
" 2540 | Lock            | relation\n"
" 6644 | LWLockNamed     | ProcArrayLock\n"
"(2 rows)"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1192(entry)
msgid "Current WAL sender state"
msgstr "Текущее состояние процесса-передатчика WAL"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1195(structfield)
msgid "sent_location"
msgstr "sent_location"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1200(structfield)
msgid "write_location"
msgstr "write_location"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1202(entry)
msgid "Last transaction log position written to disk by this standby server"
msgstr ""
"Позиция последней транзакции в журнале транзакций, записанной на диск "
"ведомым сервером"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1206(structfield)
msgid "flush_location"
msgstr "flush_location"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1208(entry)
msgid "Last transaction log position flushed to disk by this standby server"
msgstr ""
"Позиция последней транзакции в журнале транзакций, сброшенной на диск "
"ведомым сервером"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1212(structfield)
msgid "replay_location"
msgstr "replay_location"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1214(entry)
msgid ""
"Last transaction log position replayed into the database on this standby "
"server"
msgstr ""
"Позиция последней транзакции в журнале транзакций, выполненной в этой базе "
"данных на ведомом сервере"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1220(entry)
msgid ""
"Priority of this standby server for being chosen as the synchronous standby"
msgstr ""
"Приоритет этого ведомого сервера для выбора в качестве синхронного ведомого"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1275(entry)
msgid ""
"Last transaction log position already received and flushed to disk, the "
"initial value of this field being the first log position used when WAL "
"receiver is started"
msgstr ""
"Последняя позиция в журнале транзакций, уже полученная и сброшенная на диск; "
"начальным значением этого поля будет первая позиция в журнале в момент "
"запуска приёмника WAL"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1282(entry)
msgid ""
"Timeline number of last transaction log position received and flushed to "
"disk, the initial value of this field being the timeline number of the first "
"log position used when WAL receiver is started"
msgstr ""
"Номер линии времени последней позиции в журнале транзакции, уже полученной и "
"сброшенной на диск; начальным значением этого поля будет линия времени "
"первой позиции в момент запуска приёмника WAL"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:1305(entry)
msgid "Time of last transaction log position reported to origin WAL sender"
msgstr ""
"Время, когда последняя позиция в журнале транзакций была сообщена "
"изначальному передатчику WAL"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:2741(para)
msgid ""
"Currently, the <ulink url=\"https://en.wikipedia.org/wiki/DTrace\">DTrace</"
"ulink> utility is supported, which, at the time of this writing, is "
"available on Solaris, OS X, FreeBSD, NetBSD, and Oracle Linux. The <ulink "
"url=\"http://sourceware.org/systemtap/\">SystemTap</ulink> project for Linux "
"provides a DTrace equivalent and can also be used. Supporting other dynamic "
"tracing utilities is theoretically possible by changing the definitions for "
"the macros in <filename>src/include/utils/probes.h</filename>."
msgstr ""
"В настоящее время поддерживается только утилита <ulink url=\"https://en."
"wikipedia.org/wiki/DTrace\">DTrace</ulink>, которая доступна для Solaris, OS "
"X, FreeBSD, NetBSD, и Oracle Linux. Проект <ulink url=\"http://sourceware."
"org/systemtap/\">SystemTap</ulink> для Linux представляет собой эквивалент "
"DTrace и также может быть использован. Теоретически возможна поддержка и "
"других утилит динамической трассировки, для этого необходимо изменить "
"определения для макроса в <filename>src/include/utils/probes.h</filename>."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3060(literal)
msgid "xlog-insert"
msgstr "xlog-insert"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3067(literal)
msgid "xlog-switch"
msgstr "xlog-switch"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3135(literal) monitoring.xml:3151(literal)
#: monitoring.xml:3160(literal) monitoring.xml:3169(literal)
#: monitoring.xml:3178(literal)
msgid "(char *, int, LWLockMode)"
msgstr "(char *, int, LWLockMode)"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3136(entry)
msgid ""
"Probe that fires when an LWLock has been acquired. arg0 is the LWLock's "
"tranche. arg1 is the LWLock's offset within its tranche. arg2 is the "
"requested lock mode, either exclusive or shared."
msgstr ""
"Срабатывает, когда накладывается блокировка LWLock. arg0 задаёт "
"идентификатор блокировки. arg1 задаёт смещение LWLOCK в своей части. arg2 "
"задаёт тип запрошенной блокировки: монопольная или разделяемая."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3143(literal)
msgid "(char *, int)"
msgstr "(char *, int)"

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3144(entry)
msgid ""
"Probe that fires when an LWLock has been released (but note that any "
"released waiters have not yet been awakened). arg0 is the LWLock's tranche. "
"arg1 is the LWLock's offset within its tranche."
msgstr ""
"Срабатывает, когда блокировка LWLock была снята (однако учтите, что никакие "
"ждущие процессы ещё не были активированы). arg0 задаёт идентификатор "
"блокировки LWLock. arg1 задаёт смещение внутри идентификатора блокировки "
"LWLock."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3152(entry)
msgid ""
"Probe that fires when an LWLock was not immediately available and a server "
"process has begun to wait for the lock to become available. arg0 is the "
"LWLock's tranche. arg1 is the LWLock's offset within its tranche. arg2 is "
"the requested lock mode, either exclusive or shared."
msgstr ""
"Срабатывает, когда оказывается, что наложить блокировку LWLock немедленно "
"нельзя, и серверный процесс начинает ожидать освобождения блокировки. arg0 "
"задаёт идентификатор блокировки LWLock. arg1 задаёт смещение внутри "
"идентификатора блокировки LWLock. arg2 задаёт тип запрошенной блокировки, "
"монопольная или разделяемая."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3170(entry)
msgid ""
"Probe that fires when an LWLock was successfully acquired when the caller "
"specified no waiting. arg0 is the LWLock's tranche. arg1 is the LWLock's "
"offset within its tranche. arg2 is the requested lock mode, either exclusive "
"or shared."
msgstr ""
"Срабатывает, когда блокировка LWLock была успешно получена процессом, "
"запросившим её в режиме без ожидания. arg0 задаёт идентификатор блокировки "
"LWLock. arg1 задаёт смещение внутри идентификатора блокировки LWLock. arg2 "
"задаёт тип запрошенной блокировки, монопольная или разделяемая."

#. +> REL9_6_3 REL9_6
#: monitoring.xml:3179(entry)
msgid ""
"Probe that fires when an LWLock was not successfully acquired when the "
"caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the "
"LWLock's offset within its tranche. arg2 is the requested lock mode, either "
"exclusive or shared."
msgstr ""
"Срабатывает, когда процесс, запросивший блокировку LWLock в режиме без "
"ожидания, не смог её получить. arg0 задаёт идентификатор блокировки LWLock. "
"arg1 задаёт смещение внутри идентификатора блокировки LWLock. arg2 задаёт "
"тип запрошенной блокировки, монопольная или разделяемая."

#~ msgid "Waiting for the leader to populate the TidBitmap."
#~ msgstr "Ожидание наполнения TidBitmap ведущим процессом."
