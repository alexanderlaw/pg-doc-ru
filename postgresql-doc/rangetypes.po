# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:14+0300\n"
"PO-Revision-Date: 2017-06-29 14:42+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:5(title)
msgid "Range Types"
msgstr "Диапазонные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:7(indexterm)
msgid "<primary>range type</primary>"
msgstr "<primary>диапазонный тип</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:11(para)
msgid ""
"Range types are data types representing a range of values of some element "
"type (called the range's <firstterm>subtype</firstterm>). For instance, "
"ranges of <type>timestamp</type> might be used to represent the ranges of "
"time that a meeting room is reserved. In this case the data type is "
"<type>tsrange</type> (short for <quote>timestamp range</quote>), and "
"<type>timestamp</type> is the subtype. The subtype must have a total order "
"so that it is well-defined whether element values are within, before, or "
"after a range of values."
msgstr ""
"Диапазонные типы представляют диапазоны значений некоторого типа данных (он "
"также называется <firstterm>подтипом</firstterm> диапазона). Например, "
"диапазон типа <type>timestamp</type> может представлять временной интервал, "
"когда зарезервирован зал заседаний. В данном случае типом данных будет "
"<type>tsrange</type> (сокращение от <quote>timestamp range</quote>), а "
"подтипом &mdash; <type>timestamp</type>. Подтип должен быть полностью "
"упорядочиваемым, чтобы можно было однозначно определить, где находится "
"значение по отношению к диапазону: внутри, до или после него."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:23(para)
msgid ""
"Range types are useful because they represent many element values in a "
"single range value, and because concepts such as overlapping ranges can be "
"expressed clearly. The use of time and date ranges for scheduling purposes "
"is the clearest example; but price ranges, measurement ranges from an "
"instrument, and so forth can also be useful."
msgstr ""
"Диапазонные типы полезны тем, что позволяют представить множество возможных "
"значений в одной структуре данных и чётко выразить такие понятия, как "
"пересечение диапазонов. Наиболее очевидный вариант их использования &mdash; "
"применять диапазоны даты и времени для составления расписания, но также "
"полезными могут оказаться диапазоны цен, интервалы измерений и т. д."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:32(title)
msgid "Built-in Range Types"
msgstr "Встроенные диапазонные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:38(para)
msgid "<type>int4range</type> &mdash; Range of <type>integer</type>"
msgstr "<type>int4range</type> &mdash; диапазон подтипа <type>integer</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:43(para)
msgid "<type>int8range</type> &mdash; Range of <type>bigint</type>"
msgstr "<type>int8range</type> &mdash; диапазон подтипа <type>bigint</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:48(para)
msgid "<type>numrange</type> &mdash; Range of <type>numeric</type>"
msgstr "<type>numrange</type> &mdash; диапазон подтипа <type>numeric</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:53(para)
msgid ""
"<type>tsrange</type> &mdash; Range of <type>timestamp without time zone</"
"type>"
msgstr ""
"<type>tsrange</type> &mdash; диапазон подтипа <type>timestamp without time "
"zone</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:58(para)
msgid ""
"<type>tstzrange</type> &mdash; Range of <type>timestamp with time zone</type>"
msgstr ""
"<type>tstzrange</type> &mdash; диапазон подтипа <type>timestamp with time "
"zone</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:63(para)
msgid "<type>daterange</type> &mdash; Range of <type>date</type>"
msgstr "<type>daterange</type> &mdash; диапазон подтипа <type>date</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:34(para)
msgid ""
"PostgreSQL comes with the following built-in range types: <placeholder-1/> "
"In addition, you can define your own range types; see <xref linkend=\"sql-"
"createtype\"/> for more information."
msgstr ""
"PostgreSQL имеет следующие встроенные диапазонные типы: <placeholder-1/> "
"Помимо этого, вы можете определять собственные типы; подробнее это описано в "
"<xref remap=\"6\" linkend=\"sql-createtype\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:74(title)
msgid "Examples"
msgstr "Примеры"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:77(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE reservation (room int, during tsrange);\n"
"INSERT INTO reservation VALUES\n"
"    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');\n"
"\n"
"-- Containment\n"
"SELECT int4range(10, 20) @&gt; 3;\n"
"\n"
"-- Overlaps\n"
"SELECT numrange(11.1, 22.2) &amp;&amp; numrange(20.0, 30.0);\n"
"\n"
"-- Extract the upper bound\n"
"SELECT upper(int8range(15, 25));\n"
"\n"
"-- Compute the intersection\n"
"SELECT int4range(10, 20) * int4range(15, 25);\n"
"\n"
"-- Is the range empty?\n"
"SELECT isempty(numrange(1, 5));"
msgstr ""
"CREATE TABLE reservation (room int, during tsrange);\n"
"INSERT INTO reservation VALUES\n"
"    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');\n"
"\n"
"-- Вхождение\n"
"SELECT int4range(10, 20) @&gt; 3;\n"
"\n"
"-- Перекрытие\n"
"SELECT numrange(11.1, 22.2) &amp;&amp; numrange(20.0, 30.0);\n"
"\n"
"-- Получение верхней границы\n"
"SELECT upper(int8range(15, 25));\n"
"\n"
"-- Вычисление пересечения\n"
"SELECT int4range(10, 20) * int4range(15, 25);\n"
"\n"
"-- Является ли диапазон пустым?\n"
"SELECT isempty(numrange(1, 5));"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:76(para)
msgid ""
"<placeholder-1/> See <xref linkend=\"range-operators-table\"/> and <xref "
"linkend=\"range-functions-table\"/> for complete lists of operators and "
"functions on range types."
msgstr ""
"<placeholder-1/> Полный список операторов и функций, предназначенных для "
"диапазонных типов, приведён в <xref remap=\"6\" linkend=\"range-operators-"
"table\"/> и <xref remap=\"6\" linkend=\"range-functions-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:105(title)
msgid "Inclusive and Exclusive Bounds"
msgstr "Включение и исключение границ"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:107(para)
msgid ""
"Every non-empty range has two bounds, the lower bound and the upper bound. "
"All points between these values are included in the range. An inclusive "
"bound means that the boundary point itself is included in the range as well, "
"while an exclusive bound means that the boundary point is not included in "
"the range."
msgstr ""
"Любой непустой диапазон имеет две границы, верхнюю и нижнюю, и включает все "
"точки между этими значениями. В него также может входить точка, лежащая на "
"границе, если диапазон включает эту границу. И наоборот, если диапазон не "
"включает границу, считается, что точка, лежащая на этой границе, в него не "
"входит."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:115(para)
msgid ""
"In the text form of a range, an inclusive lower bound is represented by "
"<quote><literal>[</literal></quote> while an exclusive lower bound is "
"represented by <quote><literal>(</literal></quote>. Likewise, an inclusive "
"upper bound is represented by <quote><literal>]</literal></quote>, while an "
"exclusive upper bound is represented by <quote><literal>)</literal></quote>. "
"(See <xref linkend=\"rangetypes-io\"/> for more details.)"
msgstr ""
"В текстовой записи диапазона включение нижней границы обозначается символом "
"<quote><literal>[</literal></quote>, а исключением &mdash; символом "
"<quote><literal>(</literal></quote>. Для верхней границы включение "
"обозначается аналогично, символом <quote><literal>]</literal></quote>, а "
"исключение &mdash; символом <quote><literal>)</literal></quote>. (Подробнее "
"это описано в <xref remap=\"6\" linkend=\"rangetypes-io\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:124(para)
msgid ""
"The functions <literal>lower_inc</literal> and <literal>upper_inc</literal> "
"test the inclusivity of the lower and upper bounds of a range value, "
"respectively."
msgstr ""
"Для проверки, включается ли нижняя или верхняя граница в диапазон, "
"предназначены функции <literal>lower_inc</literal> и <literal>upper_inc</"
"literal>, соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:132(title)
msgid "Infinite (Unbounded) Ranges"
msgstr "Неограниченные (бесконечные) диапазоны"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:134(para)
msgid ""
"The lower bound of a range can be omitted, meaning that all points less than "
"the upper bound are included in the range. Likewise, if the upper bound of "
"the range is omitted, then all points greater than the lower bound are "
"included in the range. If both lower and upper bounds are omitted, all "
"values of the element type are considered to be in the range."
msgstr ""
"Нижнюю границу диапазона можно опустить и определить тем самым диапазон, "
"включающий все точки, лежащие ниже верхней границы. Подобным образом, если "
"не определить верхнюю границу, в диапазон войдут все точки, лежащие выше "
"нижней границы. Если же опущена и нижняя, и правая границы, такой диапазон "
"будет включать все возможные значения своего подтипа."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:142(para)
msgid ""
"This is equivalent to considering that the lower bound is <quote>minus "
"infinity</quote>, or the upper bound is <quote>plus infinity</quote>, "
"respectively. But note that these infinite values are never values of the "
"range's element type, and can never be part of the range. (So there is no "
"such thing as an inclusive infinite bound &mdash; if you try to write one, "
"it will automatically be converted to an exclusive bound.)"
msgstr ""
"Это равнозначно тому, что нижней границей будет считаться <quote>минус "
"бесконечность</quote>, а верхней &mdash; <quote>плюс бесконечность</quote>. "
"Но заметьте, что эти бесконечные значения не являются значениями подтипа "
"диапазона и поэтому также не могут входить в диапазон. (Как следствие, нет "
"такого понятия, как включаемая нижняя бесконечная граница &mdash; если "
"попытаться записать такой диапазон, она будет автоматически преобразована в "
"исключаемую.)"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:151(para)
msgid ""
"Also, some element types have a notion of <quote>infinity</quote>, but that "
"is just another value so far as the range type mechanisms are concerned. For "
"example, in timestamp ranges, <literal>[today,]</literal> means the same "
"thing as <literal>[today,)</literal>. But <literal>[today,infinity]</"
"literal> means something different from <literal>[today,infinity)</literal> "
"&mdash; the latter excludes the special <type>timestamp</type> value "
"<literal>infinity</literal>."
msgstr ""
"Кроме этого, в некоторых типах есть понятие <quote>бесконечность</quote>, но "
"в данном контексте оно считается просто одним из значений. Например, во "
"временных диапазонах <literal>[today,]</literal> означает то же самое, что и "
"<literal>[today,)</literal>. Но диапазон <literal>[today,infinity]</literal> "
"отличается от <literal>[today,infinity)</literal> &mdash; в последнем "
"специальное значение <literal>infinity</literal> типа <type>timestamp</type> "
"не входит в диапазон."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:160(para)
msgid ""
"The functions <literal>lower_inf</literal> and <literal>upper_inf</literal> "
"test for infinite lower and upper bounds of a range, respectively."
msgstr ""
"Проверить, определена ли верхняя или нижняя граница, можно с помощью функций "
"<literal>lower_inf</literal> и <literal>upper_inf</literal>, соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:168(title)
msgid "Range Input/Output"
msgstr "Ввод/вывод диапазонов"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:170(para)
msgid ""
"The input for a range value must follow one of the following patterns: "
"<synopsis>\n"
"(<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</"
"replaceable>)\n"
"(<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</"
"replaceable>]\n"
"[<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</"
"replaceable>)\n"
"[<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</"
"replaceable>]\n"
"empty\n"
"</synopsis> The parentheses or brackets indicate whether the lower and upper "
"bounds are exclusive or inclusive, as described previously. Notice that the "
"final pattern is <literal>empty</literal>, which represents an empty range "
"(a range that contains no points)."
msgstr ""
"Вводимое значение диапазона должно записываться в одной из следующих форм: "
"<synopsis>\n"
"(<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</"
"replaceable>)\n"
"(<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</"
"replaceable>]\n"
"[<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</"
"replaceable>)\n"
"[<replaceable>нижняя-граница</replaceable>,<replaceable>верхняя-граница</"
"replaceable>]\n"
"empty\n"
"</synopsis> Тип скобок (квадратные или круглые) определяет, включаются ли в "
"диапазон соответствующие границы, как описано выше. Заметьте, что последняя "
"форма содержит только слово <literal>empty</literal> и определяет пустой "
"диапазон (диапазон, не содержащий точек)."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:185(para)
msgid ""
"The <replaceable>lower-bound</replaceable> may be either a string that is "
"valid input for the subtype, or empty to indicate no lower bound. Likewise, "
"<replaceable>upper-bound</replaceable> may be either a string that is valid "
"input for the subtype, or empty to indicate no upper bound."
msgstr ""
"Здесь <replaceable>нижняя-граница</replaceable> может быть строкой с "
"допустимым значением подтипа или быть пустой (тогда диапазон будет без "
"нижней границы). Аналогично, <replaceable>верхняя-граница</replaceable> "
"может задаваться одним из значений подтипа или быть неопределённой (пустой)."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:193(para)
msgid ""
"Each bound value can be quoted using <literal>\"</literal> (double quote) "
"characters. This is necessary if the bound value contains parentheses, "
"brackets, commas, double quotes, or backslashes, since these characters "
"would otherwise be taken as part of the range syntax. To put a double quote "
"or backslash in a quoted bound value, precede it with a backslash. (Also, a "
"pair of double quotes within a double-quoted bound value is taken to "
"represent a double quote character, analogously to the rules for single "
"quotes in SQL literal strings.) Alternatively, you can avoid quoting and use "
"backslash-escaping to protect all data characters that would otherwise be "
"taken as range syntax. Also, to write a bound value that is an empty string, "
"write <literal>\"\"</literal>, since writing nothing means an infinite bound."
msgstr ""
"Любое значение диапазона можно заключить в кавычки (<literal>\"</literal>). "
"А если значение содержит круглые или квадратные скобки, запятые, кавычки или "
"обратную косую черту, использовать кавычки необходимо, чтобы эти символы не "
"рассматривались как часть синтаксиса диапазона. Чтобы включить в значение "
"диапазона, заключённое в кавычки, такие символы, как кавычки или обратная "
"косая черта, перед ними нужно добавить обратную косую черту. (Кроме того, "
"продублированные кавычки в значении диапазона, заключённого в кавычки, "
"воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой "
"стороны, можно обойтись без кавычек, защитив все символы в данных, которые "
"могут быть восприняты как часть синтаксиса диапазона, с помощью "
"спецпоследовательностей. Чтобы задать в качестве границы пустую строку, "
"нужно ввести <literal>\"\"</literal>, так как пустая строка без кавычек "
"будет означать отсутствие границы."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:208(para)
msgid ""
"Whitespace is allowed before and after the range value, but any whitespace "
"between the parentheses or brackets is taken as part of the lower or upper "
"bound value. (Depending on the element type, it might or might not be "
"significant.)"
msgstr ""
"Пробельные символы до и после определения диапазона игнорируются, но когда "
"они присутствуют внутри скобок, они воспринимаются как часть значения "
"верхней или нижней границы. (Хотя они могут также игнорироваться в "
"зависимости от подтипа диапазона.)"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:216(para)
msgid ""
"These rules are very similar to those for writing field values in composite-"
"type literals. See <xref linkend=\"rowtypes-io-syntax\"/> for additional "
"commentary."
msgstr ""
"Эти правила очень похожи на правила записи значений для полей составных "
"типов. Дополнительные замечания приведены в <xref remap=\"6\" linkend="
"\"rowtypes-io-syntax\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:225(programlisting)
#, no-wrap
msgid ""
"-- includes 3, does not include 7, and does include all points in between\n"
"SELECT '[3,7)'::int4range;\n"
"\n"
"-- does not include either 3 or 7, but includes all points in between\n"
"SELECT '(3,7)'::int4range;\n"
"\n"
"-- includes only the single point 4\n"
"SELECT '[4,4]'::int4range;\n"
"\n"
"-- includes no points (and will be normalized to 'empty')\n"
"SELECT '[4,4)'::int4range;"
msgstr ""
"-- в диапазон включается 3, не включается 7 и включаются все точки между ними\n"
"SELECT '[3,7)'::int4range;\n"
"\n"
"-- в диапазон не включаются 3 и 7, но включаются все точки между ними\n"
"SELECT '(3,7)'::int4range;\n"
"\n"
"-- в диапазон включается только одно значение 4\n"
"SELECT '[4,4]'::int4range;\n"
"\n"
"-- диапазон не включает никаких точек (нормализация заменит его определение\n"
"--  на 'empty')\n"
"SELECT '[4,4)'::int4range;"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:223(para)
msgid "Examples: <placeholder-1/>"
msgstr "Примеры: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:242(title)
msgid "Constructing Ranges"
msgstr "Конструирование диапазонов"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:260(programlisting)
#, no-wrap
msgid ""
"-- The full form is: lower bound, upper bound, and text argument indicating\n"
"-- inclusivity/exclusivity of bounds.\n"
"SELECT numrange(1.0, 14.0, '(]');\n"
"\n"
"-- If the third argument is omitted, '[)' is assumed.\n"
"SELECT numrange(1.0, 14.0);\n"
"\n"
"-- Although '(]' is specified here, on display the value will be converted to\n"
"-- canonical form, since int8range is a discrete range type (see below).\n"
"SELECT int8range(1, 14, '(]');\n"
"\n"
"-- Using NULL for either bound causes the range to be unbounded on that side.\n"
"SELECT numrange(NULL, 2.2);"
msgstr ""
"-- Полная форма: нижняя граница, верхняя граница и текстовая строка, определяющая\n"
"-- включение/исключение границ.\n"
"SELECT numrange(1.0, 14.0, '(]');\n"
"\n"
"-- Если третий аргумент опущен, подразумевается '[)'.\n"
"SELECT numrange(1.0, 14.0);\n"
"\n"
"-- Хотя здесь указывается '(]', при выводе значение будет приведено к\n"
"-- каноническому виду, так как int8range &mdash; тип дискретного диапазона (см. ниже).\n"
"SELECT int8range(1, 14, '(]');\n"
"\n"
"-- Когда вместо любой границы указывается NULL, соответствующей границы\n"
"--  у диапазона не будет.\n"
"SELECT numrange(NULL, 2.2);"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:244(para)
msgid ""
"Each range type has a constructor function with the same name as the range "
"type. Using the constructor function is frequently more convenient than "
"writing a range literal constant, since it avoids the need for extra quoting "
"of the bound values. The constructor function accepts two or three "
"arguments. The two-argument form constructs a range in standard form (lower "
"bound inclusive, upper bound exclusive), while the three-argument form "
"constructs a range with bounds of the form specified by the third argument. "
"The third argument must be one of the strings <quote><literal>()</literal></"
"quote>, <quote><literal>(]</literal></quote>, <quote><literal>[)</literal></"
"quote>, or <quote><literal>[]</literal></quote>. For example: <placeholder-1/"
">"
msgstr ""
"Для каждого диапазонного типа определена функция конструктора, имеющая то же "
"имя, что и данный тип. Использовать этот конструктор обычно удобнее, чем "
"записывать текстовую константу диапазона, так как это избавляет от "
"потребности в дополнительных кавычках. Функция конструктора может принимать "
"два или три параметра. Вариант с двумя параметрами создаёт диапазон в "
"стандартной форме (нижняя граница включается, верхняя исключается), тогда "
"как для варианта с тремя параметрами включение границ определяется третьим "
"параметром. Третий параметр должен содержать одну из строк: "
"<quote><literal>()</literal></quote>, <quote><literal>(]</literal></quote>, "
"<quote><literal>[)</literal></quote> или <quote><literal>[]</literal></"
"quote>. Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:279(title)
msgid "Discrete Range Types"
msgstr "Типы дискретных диапазонов"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:281(para)
msgid ""
"A discrete range is one whose element type has a well-defined <quote>step</"
"quote>, such as <type>integer</type> or <type>date</type>. In these types "
"two elements can be said to be adjacent, when there are no valid values "
"between them. This contrasts with continuous ranges, where it's always (or "
"almost always) possible to identify other element values between two given "
"values. For example, a range over the <type>numeric</type> type is "
"continuous, as is a range over <type>timestamp</type>. (Even though "
"<type>timestamp</type> has limited precision, and so could theoretically be "
"treated as discrete, it's better to consider it continuous since the step "
"size is normally not of interest.)"
msgstr ""
"Дискретным диапазоном считается диапазон, для подтипа которого однозначно "
"определён <quote>шаг</quote>, как например для типов <type>integer</type> и "
"<type>date</type>. Значения этих двух типов можно назвать соседними, когда "
"между ними нет никаких других значений. В непрерывных диапазонах, напротив, "
"всегда (или почти всегда) можно найти ещё одно значение между двумя данными. "
"Например, непрерывным диапазоном будет диапазон с подтипами <type>numeric</"
"type> и <type>timestamp</type>. (Хотя <type>timestamp</type> имеет "
"ограниченную точность, то есть теоретически он является дискретным, но всё "
"же лучше считать его непрерывным, так как шаг его обычно не определён.)"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:294(para)
msgid ""
"Another way to think about a discrete range type is that there is a clear "
"idea of a <quote>next</quote> or <quote>previous</quote> value for each "
"element value. Knowing that, it is possible to convert between inclusive and "
"exclusive representations of a range's bounds, by choosing the next or "
"previous element value instead of the one originally given. For example, in "
"an integer range type <literal>[4,8]</literal> and <literal>(3,9)</literal> "
"denote the same set of values; but this would not be so for a range over "
"numeric."
msgstr ""
"Можно также считать дискретным подтип диапазона, в котором чётко определены "
"понятия <quote>следующего</quote> и <quote>предыдущего</quote> элемента для "
"каждого значения. Такие определения позволяют преобразовывать границы "
"диапазона из включаемых в исключаемые, выбирая следующий или предыдущий "
"элемент вместо заданного значения. Например, диапазоны целочисленного типа "
"<literal>[4,8]</literal> и <literal>(3,9)</literal> описывают одно и то же "
"множество значений; но для диапазона подтипа numeric это не так."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:305(para)
msgid ""
"A discrete range type should have a <firstterm>canonicalization</firstterm> "
"function that is aware of the desired step size for the element type. The "
"canonicalization function is charged with converting equivalent values of "
"the range type to have identical representations, in particular consistently "
"inclusive or exclusive bounds. If a canonicalization function is not "
"specified, then ranges with different formatting will always be treated as "
"unequal, even though they might represent the same set of values in reality."
msgstr ""
"Для типа дискретного диапазона определяется функция <firstterm>канонизации</"
"firstterm>, учитывающая размер шага для данного подтипа. Задача этой функции "
"&mdash; преобразовать равнозначные диапазоны к единственному представлению, "
"в частности нормализовать включаемые и исключаемые границы. Если функция "
"канонизации не определена, диапазоны с различным определением будут всегда "
"считаться разными, даже когда они на самом деле представляют одно множество "
"значений."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:316(para)
msgid ""
"The built-in range types <type>int4range</type>, <type>int8range</type>, and "
"<type>daterange</type> all use a canonical form that includes the lower "
"bound and excludes the upper bound; that is, <literal>[)</literal>. User-"
"defined range types can use other conventions, however."
msgstr ""
"Для встроенных типов <type>int4range</type>, <type>int8range</type> и "
"<type>daterange</type> каноническое представление включает нижнюю границу и "
"не включает верхнюю; то есть диапазон приводится к виду <literal>[)</"
"literal>. Однако для нестандартных типов можно использовать и другие "
"соглашения."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:326(title)
msgid "Defining New Range Types"
msgstr "Определение новых диапазонных типов"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:334(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE floatrange AS RANGE (\n"
"    subtype = float8,\n"
"    subtype_diff = float8mi\n"
");\n"
"\n"
"SELECT '[1.234, 5.678]'::floatrange;"
msgstr ""
"CREATE TYPE floatrange AS RANGE (\n"
"    subtype = float8,\n"
"    subtype_diff = float8mi\n"
");\n"
"\n"
"SELECT '[1.234, 5.678]'::floatrange;"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:328(para)
msgid ""
"Users can define their own range types. The most common reason to do this is "
"to use ranges over subtypes not provided among the built-in range types. For "
"example, to define a new range type of subtype <type>float8</type>: "
"<placeholder-1/> Because <type>float8</type> has no meaningful <quote>step</"
"quote>, we do not define a canonicalization function in this example."
msgstr ""
"Пользователи могут определять собственные диапазонные типы. Это может быть "
"полезно, когда нужно использовать диапазоны с подтипами, для которых нет "
"встроенных диапазонных типов. Например, можно определить новый тип диапазона "
"для подтипа <type>float8</type>: <placeholder-1/> Так как для <type>float8</"
"type> осмысленное значение <quote>шага</quote> не определено, функция "
"канонизации в данном примере не задаётся."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:348(para)
msgid ""
"Defining your own range type also allows you to specify a different subtype "
"B-tree operator class or collation to use, so as to change the sort ordering "
"that determines which values fall into a given range."
msgstr ""
"Определяя собственный диапазонный тип, вы также можете выбрать другие "
"правила сортировки или класс оператора B-дерева для его подтипа, что "
"позволит изменить порядок значений, от которого зависит, какие значения "
"попадают в заданный диапазон."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:354(para)
msgid ""
"If the subtype is considered to have discrete rather than continuous values, "
"the <command>CREATE TYPE</command> command should specify a "
"<literal>canonical</literal> function. The canonicalization function takes "
"an input range value, and must return an equivalent range value that may "
"have different bounds and formatting. The canonical output for two ranges "
"that represent the same set of values, for example the integer ranges "
"<literal>[1, 7]</literal> and <literal>[1, 8)</literal>, must be identical. "
"It doesn't matter which representation you choose to be the canonical one, "
"so long as two equivalent values with different formattings are always "
"mapped to the same value with the same formatting. In addition to adjusting "
"the inclusive/exclusive bounds format, a canonicalization function might "
"round off boundary values, in case the desired step size is larger than what "
"the subtype is capable of storing. For instance, a range type over "
"<type>timestamp</type> could be defined to have a step size of an hour, in "
"which case the canonicalization function would need to round off bounds that "
"weren't a multiple of an hour, or perhaps throw an error instead."
msgstr ""
"Если подтип можно рассматривать как дискретный, а не непрерывный, в команде "
"<command>CREATE TYPE</command> следует также задать функцию "
"<literal>канонизации</literal>. Этой функции будет передаваться значение "
"диапазона, а она должна вернуть равнозначное значение, но, возможно, с "
"другими границами и форматированием. Для двух диапазонов, представляющих "
"одно множество значений, например, целочисленные диапазоны <literal>[1, 7]</"
"literal> и <literal>[1, 8)</literal>, функция канонизации должна выдавать "
"один результат. Какое именно представление будет считаться каноническим, не "
"имеет значения &mdash; главное, чтобы два равнозначных диапазона, "
"отформатированных по-разному, всегда преобразовывались в одно значение с "
"одинаковым форматированием. Помимо исправления формата включаемых/"
"исключаемых границ, функция канонизации может округлять значения границ, "
"если размер шага превышает точность хранения подтипа. Например, в типе "
"диапазона для подтипа <type>timestamp</type> можно определить размер шага, "
"равный часу, тогда функция канонизации должна будет округлить границы, "
"заданные, например с точностью до минут, либо вместо этого выдать ошибку."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:374(para)
msgid ""
"In addition, any range type that is meant to be used with GiST or SP-GiST "
"indexes should define a subtype difference, or <literal>subtype_diff</"
"literal>, function. (The index will still work without "
"<literal>subtype_diff</literal>, but it is likely to be considerably less "
"efficient than if a difference function is provided.) The subtype difference "
"function takes two input values of the subtype, and returns their difference "
"(i.e., <replaceable>X</replaceable> minus <replaceable>Y</replaceable>) "
"represented as a <type>float8</type> value. In our example above, the "
"function <function>float8mi</function> that underlies the regular "
"<type>float8</type> minus operator can be used; but for any other subtype, "
"some type conversion would be necessary. Some creative thought about how to "
"represent differences as numbers might be needed, too. To the greatest "
"extent possible, the <literal>subtype_diff</literal> function should agree "
"with the sort ordering implied by the selected operator class and collation; "
"that is, its result should be positive whenever its first argument is "
"greater than its second according to the sort ordering."
msgstr ""
"Помимо этого, для любого диапазонного типа, ориентированного на "
"использование с индексами GiST или SP-GiST, должна быть определена разница "
"значений подтипов, функция <literal>subtype_diff</literal>. (Индекс сможет "
"работать и без <literal>subtype_diff</literal>, но в большинстве случаев это "
"будет не так эффективно.) Эта функция принимает на вход два значения подтипа "
"и возвращает их разницу (т. е. <replaceable>X</replaceable> минус "
"<replaceable>Y</replaceable>) в значении типа <type>float8</type>. В "
"показанном выше примере может использоваться функция <function>float8mi</"
"function>, определяющая нижележащую реализацию обычного оператора "
"<quote>минус</quote> для типа <type>float8</type>, но для другого подтипа "
"могут потребоваться дополнительные преобразования. Иногда для представления "
"разницы в числовом виде требуется ещё и творческий подход. Функция "
"<literal>subtype_diff</literal>, насколько это возможно, должна быть "
"согласована с порядком сортировки, вытекающим из выбранных правил сортировки "
"и класса оператора; то есть, её результат должен быть положительным, если "
"согласно порядку сортировки первый её аргумент больше второго."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:393(para)
msgid ""
"A less-oversimplified example of a <literal>subtype_diff</literal> function "
"is:"
msgstr ""
"Ещё один, не столь тривиальный пример функции <literal>subtype_diff</"
"literal>:"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:397(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS\n"
"'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;\n"
"\n"
"CREATE TYPE timerange AS RANGE (\n"
"    subtype = time,\n"
"    subtype_diff = time_subtype_diff\n"
");\n"
"\n"
"SELECT '[11:10, 23:00]'::timerange;"
msgstr ""
"CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS\n"
"'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;\n"
"\n"
"CREATE TYPE timerange AS RANGE (\n"
"    subtype = time,\n"
"    subtype_diff = time_subtype_diff\n"
");\n"
"\n"
"SELECT '[11:10, 23:00]'::timerange;"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:409(para)
msgid ""
"See <xref linkend=\"sql-createtype\"/> for more information about creating "
"range types."
msgstr ""
"Дополнительные сведения о создании диапазонных типов можно найти в описании "
"<xref linkend=\"sql-createtype\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:416(title)
msgid "Indexing"
msgstr "Индексация"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:418(indexterm)
msgid "<primary>range type</primary> <secondary>indexes on</secondary>"
msgstr "<primary>диапазонный тип</primary> <secondary>индексы</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:426(programlisting)
#, no-wrap
msgid "CREATE INDEX reservation_idx ON reservation USING GIST (during);"
msgstr "CREATE INDEX reservation_idx ON reservation USING GIST (during);"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:423(para)
msgid ""
"GiST and SP-GiST indexes can be created for table columns of range types. "
"For instance, to create a GiST index: <placeholder-1/> A GiST or SP-GiST "
"index can accelerate queries involving these range operators: <literal>=</"
"literal>, <literal>&amp;&amp;</literal>, <literal>&lt;@</literal>, "
"<literal>@&gt;</literal>, <literal>&lt;&lt;</literal>, <literal>&gt;&gt;</"
"literal>, <literal>-|-</literal>, <literal>&amp;&lt;</literal>, and "
"<literal>&amp;&gt;</literal> (see <xref linkend=\"range-operators-table\"/> "
"for more information)."
msgstr ""
"Для столбцов, имеющих диапазонный тип, можно создать индексы GiST и SP-GiST. "
"Например, так создаётся индекс GiST: <placeholder-1/> Индекс GiST или SP-"
"GiST помогает ускорить запросы со следующими операторами: <literal>=</"
"literal>, <literal>&amp;&amp;</literal>, <literal>&lt;@</literal>, "
"<literal>@&gt;</literal>, <literal>&lt;&lt;</literal>, <literal>&gt;&gt;</"
"literal>, <literal>-|-</literal>, <literal>&amp;&lt;</literal> и "
"<literal>&amp;&gt;</literal> (дополнительно о них можно узнать в <xref remap="
"\"6\" linkend=\"range-operators-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:442(para)
msgid ""
"In addition, B-tree and hash indexes can be created for table columns of "
"range types. For these index types, basically the only useful range "
"operation is equality. There is a B-tree sort ordering defined for range "
"values, with corresponding <literal>&lt;</literal> and <literal>&gt;</"
"literal> operators, but the ordering is rather arbitrary and not usually "
"useful in the real world. Range types' B-tree and hash support is primarily "
"meant to allow sorting and hashing internally in queries, rather than "
"creation of actual indexes."
msgstr ""
"Кроме того, для таких столбцов можно создать индексы на основе хеша и B-"
"деревьев. Для индексов таких типов полезен по сути только один оператор "
"диапазона &mdash; равно. Порядок сортировки B-дерева определяется для "
"значений диапазона соответствующими операторами <literal>&lt;</literal> и "
"<literal>&gt;</literal>, но этот порядок может быть произвольным и он не "
"очень важен в реальном мире. Поддержка B-деревьев и хешей диапазонными "
"типами нужна в основном для сортировки и хеширования при выполнении "
"запросов, но не для создания самих индексов."

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:455(title)
msgid "Constraints on Ranges"
msgstr "Ограничения для диапазонов"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:457(indexterm)
msgid "<primary>range type</primary> <secondary>exclude</secondary>"
msgstr "<primary>диапазонный тип</primary> <secondary>исключение</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:471(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE reservation (\n"
"    during tsrange,\n"
"    EXCLUDE USING GIST (during WITH &amp;&amp;)\n"
");"
msgstr ""
"CREATE TABLE reservation (\n"
"    during tsrange,\n"
"    EXCLUDE USING GIST (during WITH &amp;&amp;)\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:481(programlisting)
#, no-wrap
msgid ""
"INSERT INTO reservation VALUES\n"
"    ('[2010-01-01 11:30, 2010-01-01 15:00)');\n"
"INSERT 0 1\n"
"\n"
"INSERT INTO reservation VALUES\n"
"    ('[2010-01-01 14:45, 2010-01-01 15:45)');\n"
"ERROR:  conflicting key value violates exclusion constraint \"reservation_during_excl\"\n"
"DETAIL:  Key (during)=([\"2010-01-01 14:45:00\",\"2010-01-01 15:45:00\")) conflicts\n"
"with existing key (during)=([\"2010-01-01 11:30:00\",\"2010-01-01 15:00:00\"))."
msgstr ""
"INSERT INTO reservation VALUES\n"
"    ('[2010-01-01 11:30, 2010-01-01 15:00)');\n"
"INSERT 0 1\n"
"\n"
"INSERT INTO reservation VALUES\n"
"    ('[2010-01-01 14:45, 2010-01-01 15:45)');\n"
"ОШИБКА:  конфликтующее значение ключа нарушает ограничение-исключение \"reservation_during_excl\"\n"
"ПОДРОБНОСТИ: Ключ (during)=([\"2010-01-01 14:45:00\",\"2010-01-01 15:45:00\"))\n"
"конфликтует с существующим ключом (during)=([\"2010-01-01 11:30:00\",\"2010-01-01 15:00:00\"))"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:462(para)
msgid ""
"While <literal>UNIQUE</literal> is a natural constraint for scalar values, "
"it is usually unsuitable for range types. Instead, an exclusion constraint "
"is often more appropriate (see <link linkend=\"sql-createtable-exclude"
"\">CREATE TABLE ... CONSTRAINT ... EXCLUDE</link>). Exclusion constraints "
"allow the specification of constraints such as <quote>non-overlapping</"
"quote> on a range type. For example: <placeholder-1/> That constraint will "
"prevent any overlapping values from existing in the table at the same time: "
"<placeholder-2/>"
msgstr ""
"Тогда как для скалярных значений естественным ограничением является "
"<literal>UNIQUE</literal>, оно обычно не подходит для диапазонных типов. "
"Вместо этого чаще оказываются полезнее ограничения-исключения (см. <link "
"linkend=\"sql-createtable-exclude\">CREATE TABLE ... CONSTRAINT ... EXCLUDE</"
"link>). Такие ограничения позволяют, например определить условие "
"<quote>непересечения</quote> диапазонов. Например: <placeholder-1/> Это "
"ограничение не позволит одновременно сохранить в таблице несколько "
"диапазонов, которые накладываются друг на друга: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:502(programlisting)
#, no-wrap
msgid ""
"CREATE EXTENSION btree_gist;\n"
"CREATE TABLE room_reservation (\n"
"    room text,\n"
"    during tsrange,\n"
"    EXCLUDE USING GIST (room WITH =, during WITH &amp;&amp;)\n"
");\n"
"\n"
"INSERT INTO room_reservation VALUES\n"
"    ('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');\n"
"INSERT 0 1\n"
"\n"
"INSERT INTO room_reservation VALUES\n"
"    ('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');\n"
"ERROR:  conflicting key value violates exclusion constraint \"room_reservation_room_during_excl\"\n"
"DETAIL:  Key (room, during)=(123A, [\"2010-01-01 14:30:00\",\"2010-01-01 15:30:00\")) conflicts\n"
"with existing key (room, during)=(123A, [\"2010-01-01 14:00:00\",\"2010-01-01 15:00:00\")).\n"
"\n"
"INSERT INTO room_reservation VALUES\n"
"    ('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');\n"
"INSERT 0 1"
msgstr ""
"CREATE EXTENSION btree_gist;\n"
"CREATE TABLE room_reservation (\n"
"    room text,\n"
"    during tsrange,\n"
"    EXCLUDE USING GIST (room WITH =, during WITH &amp;&amp;)\n"
");\n"
"\n"
"INSERT INTO room_reservation VALUES\n"
"    ('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');\n"
"INSERT 0 1\n"
"\n"
"INSERT INTO room_reservation VALUES\n"
"    ('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');\n"
"ОШИБКА:  конфликтующее значение ключа нарушает ограничение-исключение\n"
"  \"room_reservation_room_during_excl\"\n"
"ПОДРОБНОСТИ:  Ключ (room, during)=(123A, [ 2010-01-01 14:30:00,\n"
"  2010-01-01 15:30:00 )) конфликтует\n"
"с существующим ключом (room, during)=(123A, [\"2010-01-01 14:00:00\",\"2010-01-01 15:00:00\")).\n"
"\n"
"INSERT INTO room_reservation VALUES\n"
"    ('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');\n"
"INSERT 0 1"

#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:494(para)
msgid ""
"You can use the <link linkend=\"btree-gist\"><literal>btree_gist</literal></"
"link> extension to define exclusion constraints on plain scalar data types, "
"which can then be combined with range exclusions for maximum flexibility. "
"For example, after <literal>btree_gist</literal> is installed, the following "
"constraint will reject overlapping ranges only if the meeting room numbers "
"are equal: <placeholder-1/>"
msgstr ""
"Для максимальной гибкости в ограничении-исключении можно сочетать простые "
"скалярные типы данных с диапазонами, используя расширение <link linkend="
"\"btree-gist\"><literal>btree_gist</literal></link>. Например, если "
"<literal>btree_gist</literal> установлено, следующее ограничение не будет "
"допускать пересекающиеся диапазоны, только если совпадают также и номера "
"комнат: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: rangetypes.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
