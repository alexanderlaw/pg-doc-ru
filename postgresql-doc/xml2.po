# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: xml2.xml:5(title)
msgid "xml2"
msgstr "xml2"

#: xml2.xml:7(indexterm)
msgid "<primary>xml2</primary>"
msgstr "<primary>xml2</primary>"

#: xml2.xml:11(para)
msgid ""
"The <filename>xml2</filename> module provides XPath querying and XSLT "
"functionality."
msgstr ""
"Модуль <filename>xml2</filename> предоставляет функции для выполнения "
"запросов XPath и преобразований XSLT."

#: xml2.xml:17(title)
msgid "Deprecation Notice"
msgstr "Уведомление об актуальности"

#: xml2.xml:19(para)
msgid ""
"From <productname>PostgreSQL</productname> 8.3 on, there is XML-related "
"functionality based on the SQL/XML standard in the core server. That "
"functionality covers XML syntax checking and XPath queries, which is what "
"this module does, and more, but the API is not at all compatible. It is "
"planned that this module will be removed in a future version of PostgreSQL "
"in favor of the newer standard API, so you are encouraged to try converting "
"your applications. If you find that some of the functionality of this module "
"is not available in an adequate form with the newer API, please explain your "
"issue to <email>pgsql-hackers@postgresql.org</email> so that the deficiency "
"can be addressed."
msgstr ""
"Начиная с <productname>PostgreSQL</productname> 8.3, функциональность, "
"связанная с XML, основана на стандарте SQL/XML и включена в ядро сервера. "
"Эта функциональность охватывает проверку синтаксиса XML и запросы XPath, что "
"в частности делает и этот модуль, но он имеет абсолютно несовместимый API. "
"Этот модуль планируется удалить в будущей версии PostgreSQL в пользу нового "
"стандартного API, так что мы рекомендуем вам попробовать перевести свои "
"приложения на новый API. Если вы обнаружите, что какая-то функциональность "
"этого модуля не представлена новым API в подходящей форме, пожалуйста, "
"напишите о вашем затруднении в <email>pgsql-hackers@postgresql.org</email>, "
"чтобы этот недостаток был рассмотрен и, возможно, устранён."

#: xml2.xml:35(title)
msgid "Description of Functions"
msgstr "Описание функций"

#: xml2.xml:37(para)
msgid ""
"<xref linkend=\"xml2-functions-table\"/> shows the functions provided by "
"this module. These functions provide straightforward XML parsing and XPath "
"queries. All arguments are of type <type>text</type>, so for brevity that is "
"not shown."
msgstr ""
"Функции, предоставляемые этим модулем, перечислены в <xref remap=\"6\" "
"linkend=\"xml2-functions-table\"/>. Эти функции позволяют выполнять простой "
"разбор XML и запросы XPath. Все их аргументы имеют тип <type>text</type>, "
"поэтому для краткости типы опущены."

#: xml2.xml:44(title)
msgid "Functions"
msgstr "Функции"

#: xml2.xml:48(entry)
msgid "Function"
msgstr "Функция"

#: xml2.xml:49(entry)
msgid "Returns"
msgstr "Возвращает"

#: xml2.xml:50(entry) xml2.xml:224(entry)
msgid "Description"
msgstr "Описание"

#: xml2.xml:56(function)
msgid "xml_is_well_formed(document)"
msgstr "xml_is_well_formed(document)"

#: xml2.xml:61(type) xml2.xml:106(type)
msgid "bool"
msgstr "bool"

#: xml2.xml:64(para)
msgid ""
"This parses the document text in its parameter and returns true if the "
"document is well-formed XML. (Note: before PostgreSQL 8.2, this function was "
"called <function>xml_valid()</function>. That is the wrong name since "
"validity and well-formedness have different meanings in XML. The old name is "
"still available, but is deprecated.)"
msgstr ""
"Эта функция разбирает текст документа, переданный в параметре, и возвращает "
"true, если это правильно сформированный XML. (Замечание: до PostgreSQL 8.2 "
"эта функция называлась <function>xml_valid()</function>. Это имя было "
"некорректным, так как понятия правильности формата (well-formed) и "
"допустимости (valid) в XML различаются. Старое имя по-прежнему сохраняется, "
"но считается устаревшим.)"

#: xml2.xml:75(function)
msgid "xpath_string(document, query)"
msgstr "xpath_string(document, query)"

#: xml2.xml:80(type) xml2.xml:116(type) xml2.xml:139(type) xml2.xml:154(type)
#: xml2.xml:169(type) xml2.xml:186(type)
msgid "text"
msgstr "text"

#: xml2.xml:83(para)
msgid ""
"These functions evaluate the XPath query on the supplied document, and cast "
"the result to the specified type."
msgstr ""
"Эти функции обрабатывают запрос XPath для переданного документа и приводят "
"результат к указанному типу."

#: xml2.xml:91(function)
msgid "xpath_number(document, query)"
msgstr "xpath_number(document, query)"

#: xml2.xml:96(type)
msgid "float4"
msgstr "float4"

#: xml2.xml:101(function)
msgid "xpath_bool(document, query)"
msgstr "xpath_bool(document, query)"

#: xml2.xml:111(function)
msgid "xpath_nodeset(document, query, toptag, itemtag)"
msgstr "xpath_nodeset(document, query, toptag, itemtag)"

#: xml2.xml:119(para)
msgid ""
"This evaluates query on document and wraps the result in XML tags. If the "
"result is multivalued, the output will look like: <synopsis>\n"
"&lt;toptag&gt;\n"
"&lt;itemtag&gt;Value 1 which could be an XML fragment&lt;/itemtag&gt;\n"
"&lt;itemtag&gt;Value 2....&lt;/itemtag&gt;\n"
"&lt;/toptag&gt;\n"
"</synopsis> If either <literal>toptag</literal> or <literal>itemtag</"
"literal> is an empty string, the relevant tag is omitted."
msgstr ""
"Эта функция обрабатывает запрос для документа и помещает результат внутрь "
"XML-тегов. Если результат содержит несколько значений, она выдаст: "
"<synopsis>\n"
"&lt;toptag&gt;\n"
"&lt;itemtag&gt;Значение 1, которое может быть фрагментом XML&lt;/"
"itemtag&gt;\n"
"&lt;itemtag&gt;Значение 2....&lt;/itemtag&gt;\n"
"&lt;/toptag&gt;\n"
"</synopsis> Если <literal>toptag</literal> или <literal>itemtag</literal> — "
"пустая строка, соответствующий тег опускается."

#: xml2.xml:134(function)
msgid "xpath_nodeset(document, query)"
msgstr "xpath_nodeset(document, query)"

#: xml2.xml:142(para)
msgid ""
"Like <function>xpath_nodeset(document, query, toptag, itemtag)</function> "
"but result omits both tags."
msgstr ""
"Подобна <function>xpath_nodeset(document, query, toptag, itemtag)</"
"function>, но выводит результат без обоих тегов."

#: xml2.xml:149(function)
msgid "xpath_nodeset(document, query, itemtag)"
msgstr "xpath_nodeset(document, query, itemtag)"

#: xml2.xml:157(para)
msgid ""
"Like <function>xpath_nodeset(document, query, toptag, itemtag)</function> "
"but result omits <literal>toptag</literal>."
msgstr ""
"Подобна <function>xpath_nodeset(document, query, toptag, itemtag)</"
"function>, но выводит результат без <literal>toptag</literal>."

#: xml2.xml:164(function)
msgid "xpath_list(document, query, separator)"
msgstr "xpath_list(document, query, separator)"

#: xml2.xml:172(para)
msgid ""
"This function returns multiple values separated by the specified separator, "
"for example <literal>Value 1,Value 2,Value 3</literal> if separator is "
"<literal>,</literal>."
msgstr ""
"Эта функция возвращает несколько значений, вставляя между ними заданный "
"разделитель, например: <literal>Значение 1,Значение 2,Значение 3</literal>, "
"если разделитель — знак <literal>,</literal>."

#: xml2.xml:181(function)
msgid "xpath_list(document, query)"
msgstr "xpath_list(document, query)"

#: xml2.xml:188(entry)
msgid ""
"This is a wrapper for the above function that uses <literal>,</literal> as "
"the separator."
msgstr ""
"Это обёртка предыдущей функции, устанавливающая в качестве разделителя знак "
"<literal>,</literal>."

#: xml2.xml:199(literal)
msgid "xpath_table"
msgstr "xpath_table"

#: xml2.xml:201(indexterm)
msgid "<primary>xpath_table</primary>"
msgstr "<primary>xpath_table</primary>"

#: xml2.xml:205(synopsis)
#, no-wrap
msgid "xpath_table(text key, text document, text relation, text xpaths, text criteria) returns setof record"
msgstr "xpath_table(text key, text document, text relation, text xpaths, text criteria) returns setof record"

#: xml2.xml:209(para)
msgid ""
"<function>xpath_table</function> is a table function that evaluates a set of "
"XPath queries on each of a set of documents and returns the results as a "
"table. The primary key field from the original document table is returned as "
"the first column of the result so that the result set can readily be used in "
"joins. The parameters are described in <xref linkend=\"xml2-xpath-table-"
"parameters\"/>."
msgstr ""
"Табличная функция <function>xpath_table</function> выполняет набор запросов "
"XPath для каждого из набора документов и возвращает результаты в виде "
"таблицы. В первом столбце результата возвращается первичный ключ из таблицы "
"документов, так что результат оказывается готовым к применению в "
"соединениях. Параметры функции описаны в <xref remap=\"6\" linkend=\"xml2-"
"xpath-table-parameters\"/>."

#: xml2.xml:219(title)
msgid "<function>xpath_table</function> Parameters"
msgstr "Параметры <function>xpath_table</function>"

#: xml2.xml:223(entry)
msgid "Parameter"
msgstr "Параметр"

#: xml2.xml:229(parameter)
msgid "key"
msgstr "key"

#: xml2.xml:231(para)
msgid ""
"the name of the <quote>key</quote> field &mdash; this is just a field to be "
"used as the first column of the output table, i.e., it identifies the record "
"from which each output row came (see note below about multiple values)"
msgstr ""
"имя <quote>ключевого</quote> поля &mdash; содержимое этого поля просто "
"окажется в первом столбце выходной таблицы, то есть оно указывает на запись, "
"из которой была получена определённая выходная строка (см. замечание о "
"нескольких значениях ниже)"

#: xml2.xml:239(parameter)
msgid "document"
msgstr "document"

#: xml2.xml:241(para)
msgid "the name of the field containing the XML document"
msgstr "имя поля, содержащего XML-документ"

#: xml2.xml:247(parameter)
msgid "relation"
msgstr "relation"

#: xml2.xml:249(para)
msgid "the name of the table or view containing the documents"
msgstr "имя таблицы (или представления), содержащей документы"

#: xml2.xml:255(parameter)
msgid "xpaths"
msgstr "xpaths"

#: xml2.xml:257(para)
msgid "one or more XPath expressions, separated by <literal>|</literal>"
msgstr ""
"одно или несколько выражений XPath, разделённых символом <literal>|</literal>"

#: xml2.xml:263(parameter)
msgid "criteria"
msgstr "criteria"

#: xml2.xml:265(para)
msgid ""
"the contents of the WHERE clause. This cannot be omitted, so use "
"<literal>true</literal> or <literal>1=1</literal> if you want to process all "
"the rows in the relation"
msgstr ""
"содержимое предложения WHERE. Оно не может быть пустым, так что если вам "
"нужно обработать все строки в отношении, напишите <literal>true</literal> "
"или <literal>1=1</literal>"

#: xml2.xml:276(para)
msgid ""
"These parameters (except the XPath strings) are just substituted into a "
"plain SQL SELECT statement, so you have some flexibility &mdash; the "
"statement is"
msgstr ""
"Эти параметры (за исключением строк XPath) просто подставляются в обычный "
"оператор SQL SELECT, так что у вас есть определённая гибкость &mdash; "
"оператор выглядит так:"

#: xml2.xml:283(literal)
msgid ""
"SELECT &lt;key&gt;, &lt;document&gt; FROM &lt;relation&gt; WHERE &lt;"
"criteria&gt;"
msgstr ""
"SELECT &lt;key&gt;, &lt;document&gt; FROM &lt;relation&gt; WHERE &lt;"
"criteria&gt;"

#: xml2.xml:288(para)
msgid ""
"so those parameters can be <emphasis>anything</emphasis> valid in those "
"particular locations. The result from this SELECT needs to return exactly "
"two columns (which it will unless you try to list multiple fields for key or "
"document). Beware that this simplistic approach requires that you validate "
"any user-supplied values to avoid SQL injection attacks."
msgstr ""
"поэтому в этих параметрах можно передать <emphasis>всё</emphasis>, что будет "
"корректно воспринято в этих позициях. Этот SELECT должен возвращать ровно "
"два столбца (что и будет иметь место, если только вы не перечислите "
"несколько полей в параметрах key или document). Будьте осторожны — при таком "
"примитивном подходе обязательно нужно проверять все значения, получаемые от "
"пользователя, во избежание атак с инъекцией SQL."

#: xml2.xml:299(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM\n"
"xpath_table('article_id',\n"
"            'article_xml',\n"
"            'articles',\n"
"            '/article/author|/article/pages|/article/title',\n"
"            'date_entered &gt; ''2003-01-01'' ')\n"
"AS t(article_id integer, author text, page_count integer, title text);"
msgstr ""
"SELECT * FROM\n"
"xpath_table('article_id',\n"
"            'article_xml',\n"
"            'articles',\n"
"            '/article/author|/article/pages|/article/title',\n"
"            'date_entered &gt; ''2003-01-01'' ')\n"
"AS t(article_id integer, author text, page_count integer, title text);"

#: xml2.xml:296(para)
msgid ""
"The function has to be used in a <literal>FROM</literal> expression, with an "
"<literal>AS</literal> clause to specify the output columns; for example "
"<placeholder-1/> The <literal>AS</literal> clause defines the names and "
"types of the columns in the output table. The first is the <quote>key</"
"quote> field and the rest correspond to the XPath queries. If there are more "
"XPath queries than result columns, the extra queries will be ignored. If "
"there are more result columns than XPath queries, the extra columns will be "
"NULL."
msgstr ""
"Эта функция предназначена для использования в выражении <literal>FROM</"
"literal>, с предложением <literal>AS</literal>, задающим выходные столбцы; "
"например: <placeholder-1/> Предложение <literal>AS</literal> определяет "
"имена и типы столбцов в выходной таблице. Первым определяется "
"<quote>ключевое</quote> поле, а за ним поля, соответствующие запросам XPath. "
"Если запросов XPath больше, чем столбцов в результате, лишние запросы будут "
"игнорироваться. Если же результирующих столбцов больше, чем запросов XPath, "
"дополнительные столбцы принимают значение NULL."

#: xml2.xml:316(para)
msgid ""
"Notice that this example defines the <structname>page_count</structname> "
"result column as an integer. The function deals internally with string "
"representations, so when you say you want an integer in the output, it will "
"take the string representation of the XPath result and use PostgreSQL input "
"functions to transform it into an integer (or whatever type the <type>AS</"
"type> clause requests). An error will result if it can't do this &mdash; for "
"example if the result is empty &mdash; so you may wish to just stick to "
"<type>text</type> as the column type if you think your data has any problems."
msgstr ""
"Заметьте, что в этом примере столбец результата <structname>page_count</"
"structname> определён как целочисленный. Данная функция внутри имеет дело со "
"строковыми значениями, так что, когда вы указываете, что в результате нужно "
"получить целое число, она берёт текстовое представление результата XPath и, "
"применяя функции ввода PostgreSQL, преобразует её в целое число (или в тот "
"тип, который указан в предложении <type>AS</type>). Если она не сможет "
"сделать это, произойдёт ошибка &mdash; например, если результат пустой "
"&mdash; так что если вы допускаете возможность таких проблем с данными, "
"возможно, будет лучше просто оставить для столбца тип <type>text</type>."

#: xml2.xml:333(programlisting)
#, no-wrap
msgid ""
"SELECT t.title, p.fullname, p.email\n"
"FROM xpath_table('article_id', 'article_xml', 'articles',\n"
"                 '/article/title|/article/author/@id',\n"
"                 'xpath_string(article_xml,''/article/@date'') &gt; ''2003-03-20'' ')\n"
"       AS t(article_id integer, title text, author_id integer),\n"
"     tblPeopleInfo AS p\n"
"WHERE t.author_id = p.person_id;"
msgstr ""
"SELECT t.title, p.fullname, p.email\n"
"FROM xpath_table('article_id', 'article_xml', 'articles',\n"
"                 '/article/title|/article/author/@id',\n"
"                 'xpath_string(article_xml,''/article/@date'') &gt; ''2003-03-20'' ')\n"
"       AS t(article_id integer, title text, author_id integer),\n"
"     tblPeopleInfo AS p\n"
"WHERE t.author_id = p.person_id;"

#: xml2.xml:327(para)
msgid ""
"The calling <command>SELECT</command> statement doesn't necessarily have to "
"be just <literal>SELECT *</literal> &mdash; it can reference the output "
"columns by name or join them to other tables. The function produces a "
"virtual table with which you can perform any operation you wish (e.g. "
"aggregation, joining, sorting etc). So we could also have: <placeholder-1/> "
"as a more complicated example. Of course, you could wrap all of this in a "
"view for convenience."
msgstr ""
"Вызывающий оператор <command>SELECT</command> не обязательно должен быть "
"простым <literal>SELECT *</literal> &mdash; он может обращаться к выходным "
"столбцам по именам и соединять их с другими таблицами. Эта функция формирует "
"виртуальную таблицу, с которой вы можете выполнять любые операции, какие "
"пожелаете (например, агрегировать, соединять, сортировать данные и т. д.). "
"Поэтому возможен и такой запрос: <placeholder-1/> в качестве более сложного "
"примера. Разумеется, для удобства вы можете завернуть весь этот запрос в "
"представление."

#: xml2.xml:347(title)
msgid "Multivalued Results"
msgstr "Результаты с набором значений"

#: xml2.xml:349(para)
msgid ""
"The <function>xpath_table</function> function assumes that the results of "
"each XPath query might be multivalued, so the number of rows returned by the "
"function may not be the same as the number of input documents. The first row "
"returned contains the first result from each query, the second row the "
"second result from each query. If one of the queries has fewer values than "
"the others, null values will be returned instead."
msgstr ""
"Функция <function>xpath_table</function> рассчитана на то, что результатом "
"каждого запроса XPath может быть набор данных, так что количество "
"возвращённых этой функцией строк может не совпадать с количеством входных "
"документов. В первой строке возвращается первый результат каждого запроса, "
"во второй — второй результат и т. д. Если один из запросов возвращает меньше "
"значений, чем другие, вместо недостающих значений будет возвращаться NULL."

#: xml2.xml:366(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test (\n"
"    id int PRIMARY KEY,\n"
"    xml text\n"
");\n"
"\n"
"INSERT INTO test VALUES (1, '&lt;doc num=\"C1\"&gt;\n"
"&lt;line num=\"L1\"&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;c&gt;3&lt;/c&gt;&lt;/line&gt;\n"
"&lt;line num=\"L2\"&gt;&lt;a&gt;11&lt;/a&gt;&lt;b&gt;22&lt;/b&gt;&lt;c&gt;33&lt;/c&gt;&lt;/line&gt;\n"
"&lt;/doc&gt;');\n"
"\n"
"INSERT INTO test VALUES (2, '&lt;doc num=\"C2\"&gt;\n"
"&lt;line num=\"L1\"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;\n"
"&lt;line num=\"L2\"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;\n"
"&lt;/doc&gt;');\n"
"\n"
"SELECT * FROM\n"
"  xpath_table('id','xml','test',\n"
"              '/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',\n"
"              'true')\n"
"  AS t(id int, doc_num varchar(10), line_num varchar(10), val1 int, val2 int, val3 int)\n"
"WHERE id = 1 ORDER BY doc_num, line_num\n"
"\n"
" id | doc_num | line_num | val1 | val2 | val3\n"
"----+---------+----------+------+------+------\n"
"  1 | C1      | L1       |    1 |    2 |    3\n"
"  1 |         | L2       |   11 |   22 |   33"
msgstr ""
"CREATE TABLE test (\n"
"    id int PRIMARY KEY,\n"
"    xml text\n"
");\n"
"\n"
"INSERT INTO test VALUES (1, '&lt;doc num=\"C1\"&gt;\n"
"&lt;line num=\"L1\"&gt;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;c&gt;3&lt;/c&gt;&lt;/line&gt;\n"
"&lt;line num=\"L2\"&gt;&lt;a&gt;11&lt;/a&gt;&lt;b&gt;22&lt;/b&gt;&lt;c&gt;33&lt;/c&gt;&lt;/line&gt;\n"
"&lt;/doc&gt;');\n"
"\n"
"INSERT INTO test VALUES (2, '&lt;doc num=\"C2\"&gt;\n"
"&lt;line num=\"L1\"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;\n"
"&lt;line num=\"L2\"&gt;&lt;a&gt;111&lt;/a&gt;&lt;b&gt;222&lt;/b&gt;&lt;c&gt;333&lt;/c&gt;&lt;/line&gt;\n"
"&lt;/doc&gt;');\n"
"\n"
"SELECT * FROM\n"
"  xpath_table('id','xml','test',\n"
"              '/doc/@num|/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',\n"
"              'true')\n"
"  AS t(id int, doc_num varchar(10), line_num varchar(10), val1 int, val2 int, val3 int)\n"
"WHERE id = 1 ORDER BY doc_num, line_num\n"
"\n"
" id | doc_num | line_num | val1 | val2 | val3\n"
"----+---------+----------+------+------+------\n"
"  1 | C1      | L1       |    1 |    2 |    3\n"
"  1 |         | L2       |   11 |   22 |   33"

#: xml2.xml:358(para)
msgid ""
"In some cases, a user will know that a given XPath query will return only a "
"single result (perhaps a unique document identifier) &mdash; if used "
"alongside an XPath query returning multiple results, the single-valued "
"result will appear only on the first row of the result. The solution to this "
"is to use the key field as part of a join against a simpler XPath query. As "
"an example: <placeholder-1/>"
msgstr ""
"В некоторых случаях пользователь знает, что некоторый запрос XPath будет "
"возвращать только один результат (возможно, уникальный идентификатор "
"документа) &mdash; если он используется рядом с запросом XPath, возвращающим "
"несколько результатов, результат с одним значением будет выведен только в "
"первой выходной строке. Чтобы исправить это, можно воспользоваться полем "
"ключа и соединить результат с более простым запросом XPath. Например: "
"<placeholder-1/>"

#: xml2.xml:400(programlisting)
#, no-wrap
msgid ""
"SELECT t.*,i.doc_num FROM\n"
"  xpath_table('id', 'xml', 'test',\n"
"              '/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',\n"
"              'true')\n"
"    AS t(id int, line_num varchar(10), val1 int, val2 int, val3 int),\n"
"  xpath_table('id', 'xml', 'test', '/doc/@num', 'true')\n"
"    AS i(id int, doc_num varchar(10))\n"
"WHERE i.id=t.id AND i.id=1\n"
"ORDER BY doc_num, line_num;\n"
"\n"
" id | line_num | val1 | val2 | val3 | doc_num\n"
"----+----------+------+------+------+---------\n"
"  1 | L1       |    1 |    2 |    3 | C1\n"
"  1 | L2       |   11 |   22 |   33 | C1\n"
"(2 rows)"
msgstr ""
"SELECT t.*,i.doc_num FROM\n"
"  xpath_table('id', 'xml', 'test',\n"
"              '/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',\n"
"              'true')\n"
"    AS t(id int, line_num varchar(10), val1 int, val2 int, val3 int),\n"
"  xpath_table('id', 'xml', 'test', '/doc/@num', 'true')\n"
"    AS i(id int, doc_num varchar(10))\n"
"WHERE i.id=t.id AND i.id=1\n"
"ORDER BY doc_num, line_num;\n"
"\n"
" id | line_num | val1 | val2 | val3 | doc_num\n"
"----+----------+------+------+------+---------\n"
"  1 | L1       |    1 |    2 |    3 | C1\n"
"  1 | L2       |   11 |   22 |   33 | C1\n"
"(2 rows)"

#: xml2.xml:396(para)
msgid ""
"To get <literal>doc_num</literal> on every line, the solution is to use two "
"invocations of <function>xpath_table</function> and join the results: "
"<placeholder-1/>"
msgstr ""
"Чтобы получить <literal>doc_num</literal> в каждой строке, можно вызывать "
"<function>xpath_table</function> дважды и соединить результаты: "
"<placeholder-1/>"

#: xml2.xml:422(title)
msgid "XSLT Functions"
msgstr "Функции XSLT"

#: xml2.xml:424(para)
msgid "The following functions are available if libxslt is installed:"
msgstr "Если установлена libxslt, доступны следующие функции:"

#: xml2.xml:429(literal)
msgid "xslt_process"
msgstr "xslt_process"

#: xml2.xml:431(indexterm)
msgid "<primary>xslt_process</primary>"
msgstr "<primary>xslt_process</primary>"

#: xml2.xml:435(synopsis)
#, no-wrap
msgid "xslt_process(text document, text stylesheet, text paramlist) returns text"
msgstr "xslt_process(text document, text stylesheet, text paramlist) returns text"

#: xml2.xml:439(para)
msgid ""
"This function applies the XSL stylesheet to the document and returns the "
"transformed result. The <literal>paramlist</literal> is a list of parameter "
"assignments to be used in the transformation, specified in the form "
"<literal>a=1,b=2</literal>. Note that the parameter parsing is very simple-"
"minded: parameter values cannot contain commas!"
msgstr ""
"Эта функция применяет стиль XSL к документу и возвращает результат "
"преобразования. В <literal>paramlist</literal> передаётся список присвоений "
"значений параметрам, которые будут использоваться в преобразовании, в форме "
"<literal>a=1,b=2</literal>. Учтите, что разбор параметров выполнен очень "
"просто: значения параметров не могут содержать запятые!"

#: xml2.xml:448(para)
msgid ""
"There is also a two-parameter version of <function>xslt_process</function> "
"which does not pass any parameters to the transformation."
msgstr ""
"Есть также версия <function>xslt_process</function> с двумя аргументами, "
"которая не передаёт никакие параметры преобразованию."

#: xml2.xml:456(title)
msgid "Author"
msgstr "Автор"

#: xml2.xml:458(para)
msgid "John Gray <email>jgray@azuli.co.uk</email>"
msgstr "Джон Грей <email>jgray@azuli.co.uk</email>"

#: xml2.xml:462(para)
msgid ""
"Development of this module was sponsored by Torchbox Ltd. (www.torchbox."
"com). It has the same BSD license as PostgreSQL."
msgstr ""
"Разработку этого модуля спонсировала компания Torchbox Ltd. (www.torchbox."
"com). Этот модуль выпускается под той же лицензией BSD, что и PostgreSQL."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml2.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
