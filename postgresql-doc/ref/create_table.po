# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-21 15:23+0300\n"
"PO-Revision-Date: 2017-09-29 07:49+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:8(indexterm)
msgid "<primary>CREATE TABLE</primary>"
msgstr "<primary>CREATE TABLE</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:13(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE TABLE"
msgstr "CREATE TABLE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:14(manvolnum)
msgid "7"
msgstr "7"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:15(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:19(refname)
msgctxt "refname"
msgid "CREATE TABLE"
msgstr "CREATE TABLE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:20(refpurpose)
msgid "define a new table"
msgstr "создать таблицу"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:25(replaceable) ref/create_table.xml:37(replaceable)
#: ref/create_table.xml:48(replaceable) ref/create_table.xml:224(replaceable)
msgid "table_name"
msgstr "имя_таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:26(replaceable) ref/create_table.xml:32(replaceable)
#: ref/create_table.xml:39(replaceable) ref/create_table.xml:43(replaceable)
#: ref/create_table.xml:50(replaceable) ref/create_table.xml:54(replaceable)
#: ref/create_table.xml:77(replaceable) ref/create_table.xml:78(replaceable)
#: ref/create_table.xml:80(replaceable) ref/create_table.xml:101(replaceable)
#: ref/create_table.xml:379(replaceable) ref/create_table.xml:468(replaceable)
msgid "column_name"
msgstr "имя_столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:26(replaceable) ref/create_table.xml:388(replaceable)
msgid "data_type"
msgstr "тип_данных"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:26(replaceable) ref/create_table.xml:32(replaceable)
#: ref/create_table.xml:43(replaceable) ref/create_table.xml:54(replaceable)
#: ref/create_table.xml:400(replaceable)
msgid "collation"
msgstr "правило_сортировки"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:26(replaceable) ref/create_table.xml:39(replaceable)
#: ref/create_table.xml:50(replaceable) ref/create_table.xml:59(replaceable)
msgid "column_constraint"
msgstr "ограничение_столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:27(replaceable) ref/create_table.xml:40(replaceable)
#: ref/create_table.xml:51(replaceable) ref/create_table.xml:73(replaceable)
msgid "table_constraint"
msgstr "ограничение_таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:28(replaceable) ref/create_table.xml:504(replaceable)
msgid "source_table"
msgstr "исходная_таблица"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:28(replaceable) ref/create_table.xml:84(replaceable)
#: ref/create_table.xml:504(replaceable)
msgid "like_option"
msgstr "вариант_копирования"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:31(replaceable) ref/create_table.xml:49(replaceable)
#: ref/create_table.xml:254(replaceable) ref/create_table.xml:411(replaceable)
msgid "parent_table"
msgstr "таблица_родитель"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:32(replaceable) ref/create_table.xml:43(replaceable)
#: ref/create_table.xml:54(replaceable) ref/create_table.xml:64(replaceable)
#: ref/create_table.xml:76(replaceable) ref/create_table.xml:101(replaceable)
#: ref/create_table.xml:468(replaceable) ref/create_table.xml:622(replaceable)
msgid "expression"
msgstr "выражение"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:32(replaceable) ref/create_table.xml:43(replaceable)
#: ref/create_table.xml:54(replaceable) ref/create_table.xml:101(replaceable)
#: ref/create_table.xml:468(replaceable)
msgid "opclass"
msgstr "класс_операторов"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:33(replaceable) ref/create_table.xml:44(replaceable)
#: ref/create_table.xml:55(replaceable) ref/create_table.xml:96(replaceable)
#: ref/create_table.xml:979(replaceable)
msgid "storage_parameter"
msgstr "параметр_хранения"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:33(replaceable) ref/create_table.xml:44(replaceable)
#: ref/create_table.xml:55(replaceable) ref/create_table.xml:96(replaceable)
#: ref/create_table.xml:979(replaceable)
msgid "value"
msgstr "значение"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:35(replaceable) ref/create_table.xml:46(replaceable)
#: ref/create_table.xml:57(replaceable) ref/create_table.xml:97(replaceable)
#: ref/create_table.xml:1074(replaceable)
#: ref/create_table.xml:1087(replaceable)
msgid "tablespace_name"
msgstr "табл_пространство"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:38(replaceable) ref/create_table.xml:233(replaceable)
msgid "type_name"
msgstr "имя_типа"

#. +> REL_10
#: ref/create_table.xml:53(replaceable) ref/create_table.xml:88(replaceable)
#: ref/create_table.xml:254(replaceable)
msgid "partition_bound_spec"
msgstr "указание_границ_секции"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:59(phrase)
msgid "where <placeholder-1/> is:"
msgstr "Здесь <placeholder-1/>:"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:61(replaceable) ref/create_table.xml:75(replaceable)
#: ref/create_table.xml:584(replaceable)
msgid "constraint_name"
msgstr "имя_ограничения"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:65(replaceable) ref/create_table.xml:660(replaceable)
msgid "default_expr"
msgstr "выражение_по_умолчанию"

#. +> REL_10
#: ref/create_table.xml:66(replaceable) ref/create_table.xml:680(replaceable)
msgid "sequence_options"
msgstr "параметры_последовательности"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:67(replaceable) ref/create_table.xml:68(replaceable)
#: ref/create_table.xml:77(replaceable) ref/create_table.xml:78(replaceable)
#: ref/create_table.xml:79(replaceable) ref/create_table.xml:94(replaceable)
#: ref/create_table.xml:766(replaceable)
msgid "index_parameters"
msgstr "параметры_индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:69(replaceable) ref/create_table.xml:80(replaceable)
msgid "reftable"
msgstr "целевая_таблица"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:69(replaceable) ref/create_table.xml:80(replaceable)
msgid "refcolumn"
msgstr "целевой_столбец"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:70(replaceable) ref/create_table.xml:81(replaceable)
msgid "action"
msgstr "действие"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:73(phrase) ref/create_table.xml:84(phrase)
#: ref/create_table.xml:88(phrase)
msgid "and <placeholder-1/> is:"
msgstr "и <placeholder-1/>:"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:79(replaceable) ref/create_table.xml:766(replaceable)
msgid "index_method"
msgstr "метод_индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:79(replaceable) ref/create_table.xml:99(replaceable)
#: ref/create_table.xml:766(replaceable)
msgid "exclude_element"
msgstr "элемент_исключения"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:79(replaceable) ref/create_table.xml:766(replaceable)
msgid "operator"
msgstr "оператор"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:79(replaceable) ref/create_table.xml:766(replaceable)
msgid "predicate"
msgstr "предикат"

#. +> REL_10
#: ref/create_table.xml:90(replaceable) ref/create_table.xml:91(replaceable)
#: ref/create_table.xml:92(replaceable)
msgid "numeric_literal"
msgstr "числовая_константа"

#. +> REL_10
#: ref/create_table.xml:90(replaceable) ref/create_table.xml:91(replaceable)
#: ref/create_table.xml:92(replaceable)
msgid "string_literal"
msgstr "строковая_константа"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:94(literal)
msgid "UNIQUE"
msgstr "UNIQUE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:94(literal)
msgid "PRIMARY KEY"
msgstr "PRIMARY KEY"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:94(literal) ref/create_table.xml:99(literal)
msgid "EXCLUDE"
msgstr "EXCLUDE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:94(phrase)
msgid ""
"<placeholder-1/> in <placeholder-2/>, <placeholder-3/>, and <placeholder-4/> "
"constraints are:"
msgstr ""
"<placeholder-1/> в ограничениях <placeholder-2/>, <placeholder-3/> и "
"<placeholder-4/>:"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:99(phrase)
msgid "<placeholder-1/> in an <placeholder-2/> constraint is:"
msgstr "<placeholder-1/> в ограничении <placeholder-2/>:"

#. +> REL_10
#: ref/create_table.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-1/> ( [\n"
"  { <placeholder-2/> <placeholder-3/> [ COLLATE <placeholder-4/> ] [ <placeholder-5/> [ ... ] ]\n"
"    | <placeholder-6/>\n"
"    | LIKE <placeholder-7/> [ <placeholder-8/> ... ] }\n"
"    [, ... ]\n"
"] )\n"
"[ INHERITS ( <placeholder-9/> [, ... ] ) ]\n"
"[ PARTITION BY { RANGE | LIST } ( { <placeholder-10/> | ( <placeholder-11/> ) } [ COLLATE <placeholder-12/> ] [ <placeholder-13/> ] [, ... ] ) ]\n"
"[ WITH ( <placeholder-14/> [= <placeholder-15/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-16/> ]\n"
"\n"
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-17/>\n"
"    OF <placeholder-18/> [ (\n"
"  { <placeholder-19/> [ WITH OPTIONS ] [ <placeholder-20/> [ ... ] ]\n"
"    | <placeholder-21/> }\n"
"    [, ... ]\n"
") ]\n"
"[ PARTITION BY { RANGE | LIST } ( { <placeholder-22/> | ( <placeholder-23/> ) } [ COLLATE <placeholder-24/> ] [ <placeholder-25/> ] [, ... ] ) ]\n"
"[ WITH ( <placeholder-26/> [= <placeholder-27/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-28/> ]\n"
"\n"
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-29/>\n"
"    PARTITION OF <placeholder-30/> [ (\n"
"  { <placeholder-31/> [ WITH OPTIONS ] [ <placeholder-32/> [ ... ] ]\n"
"    | <placeholder-33/> }\n"
"    [, ... ]\n"
") ] FOR VALUES <placeholder-34/>\n"
"[ PARTITION BY { RANGE | LIST } ( { <placeholder-35/> | ( <placeholder-36/> ) } [ COLLATE <placeholder-37/> ] [ <placeholder-38/> ] [, ... ] ) ]\n"
"[ WITH ( <placeholder-39/> [= <placeholder-40/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-41/> ]\n"
"\n"
"<placeholder-42/>\n"
"\n"
"[ CONSTRAINT <placeholder-43/> ]\n"
"{ NOT NULL |\n"
"  NULL |\n"
"  CHECK ( <placeholder-44/> ) [ NO INHERIT ] |\n"
"  DEFAULT <placeholder-45/> |\n"
"  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <placeholder-46/> ) ] |\n"
"  UNIQUE <placeholder-47/> |\n"
"  PRIMARY KEY <placeholder-48/> |\n"
"  REFERENCES <placeholder-49/> [ ( <placeholder-50/> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n"
"    [ ON DELETE <placeholder-51/> ] [ ON UPDATE <placeholder-52/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-53/>\n"
"\n"
"[ CONSTRAINT <placeholder-54/> ]\n"
"{ CHECK ( <placeholder-55/> ) [ NO INHERIT ] |\n"
"  UNIQUE ( <placeholder-56/> [, ... ] ) <placeholder-57/> |\n"
"  PRIMARY KEY ( <placeholder-58/> [, ... ] ) <placeholder-59/> |\n"
"  EXCLUDE [ USING <placeholder-60/> ] ( <placeholder-61/> WITH <placeholder-62/> [, ... ] ) <placeholder-63/> [ WHERE ( <placeholder-64/> ) ] |\n"
"  FOREIGN KEY ( <placeholder-65/> [, ... ] ) REFERENCES <placeholder-66/> [ ( <placeholder-67/> [, ... ] ) ]\n"
"    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <placeholder-68/> ] [ ON UPDATE <placeholder-69/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-70/>\n"
"\n"
"{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | IDENTITY | INDEXES | STORAGE | COMMENTS | ALL }\n"
"\n"
"<placeholder-71/>\n"
"\n"
"IN ( { <placeholder-72/> | <placeholder-73/> | NULL } [, ...] ) |\n"
"FROM ( { <placeholder-74/> | <placeholder-75/> | MINVALUE | MAXVALUE } [, ...] )\n"
"  TO ( { <placeholder-76/> | <placeholder-77/> | MINVALUE | MAXVALUE } [, ...] )\n"
"\n"
"<placeholder-78/>\n"
"\n"
"[ WITH ( <placeholder-79/> [= <placeholder-80/>] [, ... ] ) ]\n"
"[ USING INDEX TABLESPACE <placeholder-81/> ]\n"
"\n"
"<placeholder-82/>\n"
"\n"
"{ <placeholder-83/> | ( <placeholder-84/> ) } [ <placeholder-85/> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]"
msgstr ""
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-1/> ( [\n"
"  { <placeholder-2/> <placeholder-3/> [ COLLATE <placeholder-4/> ] [ <placeholder-5/> [ ... ] ]\n"
"    | <placeholder-6/>\n"
"    | LIKE <placeholder-7/> [ <placeholder-8/> ... ] }\n"
"    [, ... ]\n"
"] )\n"
"[ INHERITS ( <placeholder-9/> [, ... ] ) ]\n"
"[ PARTITION BY { RANGE | LIST } ( { <placeholder-10/> | ( <placeholder-11/> ) } [ COLLATE <placeholder-12/> ] [ <placeholder-13/> ] [, ... ] ) ]\n"
"[ WITH ( <placeholder-14/> [= <placeholder-15/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-16/> ]\n"
"\n"
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-17/>\n"
"    OF <placeholder-18/> [ (\n"
"  { <placeholder-19/> [ WITH OPTIONS ] [ <placeholder-20/> [ ... ] ]\n"
"    | <placeholder-21/> }\n"
"    [, ... ]\n"
") ]\n"
"[ PARTITION BY { RANGE | LIST } ( { <placeholder-22/> | ( <placeholder-23/> ) } [ COLLATE <placeholder-24/> ] [ <placeholder-25/> ] [, ... ] ) ]\n"
"[ WITH ( <placeholder-26/> [= <placeholder-27/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-28/> ]\n"
"\n"
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-29/>\n"
"    PARTITION OF <placeholder-30/> [ (\n"
"  { <placeholder-31/> [ WITH OPTIONS ] [ <placeholder-32/> [ ... ] ]\n"
"    | <placeholder-33/> }\n"
"    [, ... ]\n"
") ] FOR VALUES <placeholder-34/>\n"
"[ PARTITION BY { RANGE | LIST } ( { <placeholder-35/> | ( <placeholder-36/> ) } [ COLLATE <placeholder-37/> ] [ <placeholder-38/> ] [, ... ] ) ]\n"
"[ WITH ( <placeholder-39/> [= <placeholder-40/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-41/> ]\n"
"\n"
"<placeholder-42/>\n"
"\n"
"[ CONSTRAINT <placeholder-43/> ]\n"
"{ NOT NULL |\n"
"  NULL |\n"
"  CHECK ( <placeholder-44/> ) [ NO INHERIT ] |\n"
"  DEFAULT <placeholder-45/> |\n"
"  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <placeholder-46/> ) ] |\n"
"  UNIQUE <placeholder-47/> |\n"
"  PRIMARY KEY <placeholder-48/> |\n"
"  REFERENCES <placeholder-49/> [ ( <placeholder-50/> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n"
"    [ ON DELETE <placeholder-51/> ] [ ON UPDATE <placeholder-52/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-53/>\n"
"\n"
"[ CONSTRAINT <placeholder-54/> ]\n"
"{ CHECK ( <placeholder-55/> ) [ NO INHERIT ] |\n"
"  UNIQUE ( <placeholder-56/> [, ... ] ) <placeholder-57/> |\n"
"  PRIMARY KEY ( <placeholder-58/> [, ... ] ) <placeholder-59/> |\n"
"  EXCLUDE [ USING <placeholder-60/> ] ( <placeholder-61/> WITH <placeholder-62/> [, ... ] ) <placeholder-63/> [ WHERE ( <placeholder-64/> ) ] |\n"
"  FOREIGN KEY ( <placeholder-65/> [, ... ] ) REFERENCES <placeholder-66/> [ ( <placeholder-67/> [, ... ] ) ]\n"
"    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <placeholder-68/> ] [ ON UPDATE <placeholder-69/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-70/>\n"
"\n"
"{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | IDENTITY | INDEXES | STORAGE | COMMENTS | ALL }\n"
"\n"
"<placeholder-71/>\n"
"\n"
"IN ( { <placeholder-72/> | <placeholder-73/> | NULL } [, ...] ) |\n"
"FROM ( { <placeholder-74/> | <placeholder-75/> | MINVALUE | MAXVALUE } [, ...] )\n"
"  TO ( { <placeholder-76/> | <placeholder-77/> | MINVALUE | MAXVALUE } [, ...] )\n"
"\n"
"<placeholder-78/>\n"
"\n"
"[ WITH ( <placeholder-79/> [= <placeholder-80/>] [, ... ] ) ]\n"
"[ USING INDEX TABLESPACE <placeholder-81/> ]\n"
"\n"
"<placeholder-82/>\n"
"\n"
"{ <placeholder-83/> | ( <placeholder-84/> ) } [ <placeholder-85/> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]"

#. +> REL9_6_3 REL9_6
#: ref/create_table.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-1/> ( [\n"
"  { <placeholder-2/> <placeholder-3/> [ COLLATE <placeholder-4/> ] [ <placeholder-5/> [ ... ] ]\n"
"    | <placeholder-6/>\n"
"    | LIKE <placeholder-7/> [ <placeholder-8/> ... ] }\n"
"    [, ... ]\n"
"] )\n"
"[ INHERITS ( <placeholder-9/> [, ... ] ) ]\n"
"[ WITH ( <placeholder-10/> [= <placeholder-11/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-12/> ]\n"
"\n"
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-13/>\n"
"    OF <placeholder-14/> [ (\n"
"  { <placeholder-15/> WITH OPTIONS [ <placeholder-16/> [ ... ] ]\n"
"    | <placeholder-17/> }\n"
"    [, ... ]\n"
") ]\n"
"[ WITH ( <placeholder-18/> [= <placeholder-19/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-20/> ]\n"
"\n"
"<placeholder-21/>\n"
"\n"
"[ CONSTRAINT <placeholder-22/> ]\n"
"{ NOT NULL |\n"
"  NULL |\n"
"  CHECK ( <placeholder-23/> ) [ NO INHERIT ] |\n"
"  DEFAULT <placeholder-24/> |\n"
"  UNIQUE <placeholder-25/> |\n"
"  PRIMARY KEY <placeholder-26/> |\n"
"  REFERENCES <placeholder-27/> [ ( <placeholder-28/> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n"
"    [ ON DELETE <placeholder-29/> ] [ ON UPDATE <placeholder-30/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-31/>\n"
"\n"
"[ CONSTRAINT <placeholder-32/> ]\n"
"{ CHECK ( <placeholder-33/> ) [ NO INHERIT ] |\n"
"  UNIQUE ( <placeholder-34/> [, ... ] ) <placeholder-35/> |\n"
"  PRIMARY KEY ( <placeholder-36/> [, ... ] ) <placeholder-37/> |\n"
"  EXCLUDE [ USING <placeholder-38/> ] ( <placeholder-39/> WITH <placeholder-40/> [, ... ] ) <placeholder-41/> [ WHERE ( <placeholder-42/> ) ] |\n"
"  FOREIGN KEY ( <placeholder-43/> [, ... ] ) REFERENCES <placeholder-44/> [ ( <placeholder-45/> [, ... ] ) ]\n"
"    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <placeholder-46/> ] [ ON UPDATE <placeholder-47/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-48/>\n"
"\n"
"{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }\n"
"\n"
"<placeholder-49/>\n"
"\n"
"[ WITH ( <placeholder-50/> [= <placeholder-51/>] [, ... ] ) ]\n"
"[ USING INDEX TABLESPACE <placeholder-52/> ]\n"
"\n"
"<placeholder-53/>\n"
"\n"
"{ <placeholder-54/> | ( <placeholder-55/> ) } [ <placeholder-56/> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]"
msgstr ""
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-1/> ( [\n"
"  { <placeholder-2/> <placeholder-3/> [ COLLATE <placeholder-4/> ] [ <placeholder-5/> [ ... ] ]\n"
"    | <placeholder-6/>\n"
"    | LIKE <placeholder-7/> [ <placeholder-8/> ... ] }\n"
"    [, ... ]\n"
"] )\n"
"[ INHERITS ( <placeholder-9/> [, ... ] ) ]\n"
"[ WITH ( <placeholder-10/> [= <placeholder-11/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-12/> ]\n"
"\n"
"CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <placeholder-13/>\n"
"    OF <placeholder-14/> [ (\n"
"  { <placeholder-15/> WITH OPTIONS [ <placeholder-16/> [ ... ] ]\n"
"    | <placeholder-17/> }\n"
"    [, ... ]\n"
") ]\n"
"[ WITH ( <placeholder-18/> [= <placeholder-19/>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]\n"
"[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n"
"[ TABLESPACE <placeholder-20/> ]\n"
"\n"
"<placeholder-21/>\n"
"\n"
"[ CONSTRAINT <placeholder-22/> ]\n"
"{ NOT NULL |\n"
"  NULL |\n"
"  CHECK ( <placeholder-23/> ) [ NO INHERIT ] |\n"
"  DEFAULT <placeholder-24/> |\n"
"  UNIQUE <placeholder-25/> |\n"
"  PRIMARY KEY <placeholder-26/> |\n"
"  REFERENCES <placeholder-27/> [ ( <placeholder-28/> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n"
"    [ ON DELETE <placeholder-29/> ] [ ON UPDATE <placeholder-30/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-31/>\n"
"\n"
"[ CONSTRAINT <placeholder-32/> ]\n"
"{ CHECK ( <placeholder-33/> ) [ NO INHERIT ] |\n"
"  UNIQUE ( <placeholder-34/> [, ... ] ) <placeholder-35/> |\n"
"  PRIMARY KEY ( <placeholder-36/> [, ... ] ) <placeholder-37/> |\n"
"  EXCLUDE [ USING <placeholder-38/> ] ( <placeholder-39/> WITH <placeholder-40/> [, ... ] ) <placeholder-41/> [ WHERE ( <placeholder-42/> ) ] |\n"
"  FOREIGN KEY ( <placeholder-43/> [, ... ] ) REFERENCES <placeholder-44/> [ ( <placeholder-45/> [, ... ] ) ]\n"
"    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <placeholder-46/> ] [ ON UPDATE <placeholder-47/> ] }\n"
"[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n"
"\n"
"<placeholder-48/>\n"
"\n"
"{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }\n"
"\n"
"<placeholder-49/>\n"
"\n"
"[ WITH ( <placeholder-50/> [= <placeholder-51/>] [, ... ] ) ]\n"
"[ USING INDEX TABLESPACE <placeholder-52/> ]\n"
"\n"
"<placeholder-53/>\n"
"\n"
"{ <placeholder-54/> | ( <placeholder-55/> ) } [ <placeholder-56/> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:107(title)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:109(para)
msgid ""
"<command>CREATE TABLE</command> will create a new, initially empty table in "
"the current database. The table will be owned by the user issuing the "
"command."
msgstr ""
"<command>CREATE TABLE</command> создаёт новую, изначально пустую таблицу в "
"текущей базе данных. Владельцем таблицы будет пользователь, выполнивший эту "
"команду."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:115(para)
msgid ""
"If a schema name is given (for example, <literal>CREATE TABLE myschema."
"mytable ...</literal>) then the table is created in the specified schema. "
"Otherwise it is created in the current schema. Temporary tables exist in a "
"special schema, so a schema name cannot be given when creating a temporary "
"table. The name of the table must be distinct from the name of any other "
"table, sequence, index, view, or foreign table in the same schema."
msgstr ""
"Если задано имя схемы (например, <literal>CREATE TABLE myschema.mytable ...</"
"literal>), таблица создаётся в указанной схеме, в противном случае — в "
"текущей. Временные таблицы существуют в специальной схеме, так что при "
"создании таких таблиц имя схемы задать нельзя. Имя таблицы должно отличаться "
"от имён других таблиц, последовательностей, индексов, представлений или "
"сторонних таблиц в этой схеме."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:125(para)
msgid ""
"<command>CREATE TABLE</command> also automatically creates a data type that "
"represents the composite type corresponding to one row of the table. "
"Therefore, tables cannot have the same name as any existing data type in the "
"same schema."
msgstr ""
"<command>CREATE TABLE</command> также автоматически создаёт составной тип "
"данных, соответствующий одной строке таблицы. Таким образом, имя таблицы не "
"может совпадать с именем существующего типа в этой же схеме."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:132(para)
msgid ""
"The optional constraint clauses specify constraints (tests) that new or "
"updated rows must satisfy for an insert or update operation to succeed. A "
"constraint is an SQL object that helps define the set of valid values in the "
"table in various ways."
msgstr ""
"Необязательные предложения ограничений задают ограничения (проверки), "
"которым должны удовлетворять добавляемые или изменяемые строки, чтобы "
"операция добавления или изменения была выполнена успешно. Ограничение "
"представляет собой SQL-объект, помогающий некоторым способом определить "
"множество допустимых значений в таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:139(para)
msgid ""
"There are two ways to define constraints: table constraints and column "
"constraints. A column constraint is defined as part of a column definition. "
"A table constraint definition is not tied to a particular column, and it can "
"encompass more than one column. Every column constraint can also be written "
"as a table constraint; a column constraint is only a notational convenience "
"for use when the constraint only affects one column."
msgstr ""
"Определить ограничения можно двумя способами: в виде ограничений таблицы и в "
"виде ограничений столбца. Ограничение столбца определяется как часть "
"определения столбца, а ограничение таблицы не привязывается к конкретному "
"столбцу и может задействовать несколько столбцов. Любые ограничения столбцов "
"можно также записать в виде ограничения таблицы, они введены просто для "
"удобства записи в случаях, когда ограничение затрагивает только один столбец."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:149(para)
msgid ""
"To be able to create a table, you must have <literal>USAGE</literal> "
"privilege on all column types or the type in the <literal>OF</literal> "
"clause, respectively."
msgstr ""
"Чтобы создать таблицу, необходимо иметь право <literal>USAGE</literal> для "
"типов всех столбцов или типа в предложении <literal>OF</literal>, "
"соответственно."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:157(title)
msgid "Parameters"
msgstr "Параметры"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:162(term)
msgid "<literal>TEMPORARY</literal> or <literal>TEMP</literal>"
msgstr "<literal>TEMPORARY</literal> или <literal>TEMP</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:164(para)
msgid ""
"If specified, the table is created as a temporary table. Temporary tables "
"are automatically dropped at the end of a session, or optionally at the end "
"of the current transaction (see <literal>ON COMMIT</literal> below). "
"Existing permanent tables with the same name are not visible to the current "
"session while the temporary table exists, unless they are referenced with "
"schema-qualified names. Any indexes created on a temporary table are "
"automatically temporary as well."
msgstr ""
"С таким указанием таблица создаётся как временная. Временные таблицы "
"автоматически удаляются в конце сеанса или могут удаляться в конце текущей "
"транзакции (см. описание <literal>ON COMMIT</literal> ниже). Существующая "
"постоянная таблица с тем же именем не будет видна в текущем сеансе, пока "
"существует временная, однако к ней можно обратиться, дополнив имя указанием "
"схемы. Все индексы, создаваемые для временной таблицы, так же автоматически "
"становятся временными."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:175(para)
msgid ""
"The <link linkend=\"autovacuum\">autovacuum daemon</link> cannot access and "
"therefore cannot vacuum or analyze temporary tables. For this reason, "
"appropriate vacuum and analyze operations should be performed via session "
"SQL commands. For example, if a temporary table is going to be used in "
"complex queries, it is wise to run <command>ANALYZE</command> on the "
"temporary table after it is populated."
msgstr ""
"<link linkend=\"autovacuum\">Демон автоочистки</link> не может прочитать и, "
"как следствие, сжимать и анализировать временные таблицы. По этой причине "
"соответствующие операции очистки и анализа следует выполнять, вызывая SQL-"
"команды в рамках сеанса. Например, если временную таблицу планируется "
"использовать в сложных запросах, будет разумным выполнить для неё "
"<command>ANALYZE</command> после того, как она будет наполнена."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:184(para)
msgid ""
"Optionally, <literal>GLOBAL</literal> or <literal>LOCAL</literal> can be "
"written before <literal>TEMPORARY</literal> or <literal>TEMP</literal>. This "
"presently makes no difference in <productname>PostgreSQL</productname> and "
"is deprecated; see <xref linkend=\"sql-createtable-compatibility\" endterm="
"\"sql-createtable-compatibility-title\"/>."
msgstr ""
"По желанию можно добавить указание <literal>GLOBAL</literal> или "
"<literal>LOCAL</literal> перед <literal>TEMPORARY</literal> или "
"<literal>TEMP</literal>. В настоящее время это не имеет значения для "
"<productname>PostgreSQL</productname> и считается устаревшей возможностью; "
"см. <xref remap=\"4\" linkend=\"sql-createtable-compatibility\" endterm="
"\"sql-createtable-compatibility-title\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:196(literal)
msgid "UNLOGGED"
msgstr "UNLOGGED"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:198(para)
msgid ""
"If specified, the table is created as an unlogged table. Data written to "
"unlogged tables is not written to the write-ahead log (see <xref linkend="
"\"wal\"/>), which makes them considerably faster than ordinary tables. "
"However, they are not crash-safe: an unlogged table is automatically "
"truncated after a crash or unclean shutdown. The contents of an unlogged "
"table are also not replicated to standby servers. Any indexes created on an "
"unlogged table are automatically unlogged as well."
msgstr ""
"С этим указанием таблица создаётся как нежурналируемая. Данные, записываемые "
"в нежурналируемые таблицы, не проходят через журнал предзаписи (см. <xref "
"remap=\"4\" linkend=\"wal\"/>), в результате чего такие таблицы работают "
"гораздо быстрее обычных. Однако, они не защищены от сбоя; при сбое или "
"аварийном отключении сервера нежурналируемая таблица автоматически "
"усекается. Кроме того, содержимое нежурналируемой таблицы не реплицируется "
"на ведомые серверы. Любые индексы, создаваемые для нежурналируемой таблицы, "
"автоматически становятся нежурналируемыми."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:212(literal)
msgid "IF NOT EXISTS"
msgstr "IF NOT EXISTS"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:214(para)
msgid ""
"Do not throw an error if a relation with the same name already exists. A "
"notice is issued in this case. Note that there is no guarantee that the "
"existing relation is anything like the one that would have been created."
msgstr ""
"Не считать ошибкой, если отношение с таким именем уже существует. В этом "
"случае будет выдано замечание. Заметьте, что нет никакой гарантии, что "
"существующее отношение как-то соотносится с тем, которое могло бы быть "
"создано."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:226(para)
msgid "The name (optionally schema-qualified) of the table to be created."
msgstr "Имя (возможно, дополненное схемой) создаваемой таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:233(literal)
msgid "OF <placeholder-1/>"
msgstr "OF <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:235(para)
msgid ""
"Creates a <firstterm>typed table</firstterm>, which takes its structure from "
"the specified composite type (name optionally schema-qualified). A typed "
"table is tied to its type; for example the table will be dropped if the type "
"is dropped (with <literal>DROP TYPE ... CASCADE</literal>)."
msgstr ""
"Создаёт <firstterm>типизированную таблицу</firstterm>, структура которой "
"определяется указанным составным типом (его имя может быть дополнено "
"схемой). Типизированная таблица привязана к породившему её типу; например, "
"при удалении типа (командой <literal>DROP TYPE ... CASCADE</literal>) будет "
"удалена и эта таблица."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:243(para)
msgid ""
"When a typed table is created, then the data types of the columns are "
"determined by the underlying composite type and are not specified by the "
"<literal>CREATE TABLE</literal> command. But the <literal>CREATE TABLE</"
"literal> command can add defaults and constraints to the table and can "
"specify storage parameters."
msgstr ""
"Когда создаётся типизированная таблица, типы данных её столбцов определяются "
"нижележащим составным типом, а не задаются командой <literal>CREATE TABLE</"
"literal>. Но <literal>CREATE TABLE</literal> может добавить в таблицу "
"значения по умолчанию и ограничения, а также задать параметры её хранения."

#. +> REL_10
#: ref/create_table.xml:254(literal)
msgid "PARTITION OF <placeholder-1/> FOR VALUES <placeholder-2/>"
msgstr "PARTITION OF <placeholder-1/> FOR VALUES <placeholder-2/>"

#. +> REL_10
#: ref/create_table.xml:256(para)
msgid ""
"Creates the table as a <firstterm>partition</firstterm> of the specified "
"parent table."
msgstr ""
"Создаёт таблицу как <firstterm>секцию</firstterm> указанной родительской "
"таблицы."

#. +> REL_10
#: ref/create_table.xml:261(para)
msgid ""
"The <replaceable class=\"parameter\">partition_bound_spec</replaceable> must "
"correspond to the partitioning method and partition key of the parent table, "
"and must not overlap with any existing partition of that parent. The form "
"with <literal>IN</literal> is used for list partitioning, while the form "
"with <literal>FROM</literal> and <literal>TO</literal> is used for range "
"partitioning."
msgstr ""
"Здесь <replaceable class=\"parameter\">указание_границ_секции</replaceable> "
"должно соответствовать методу и ключу секционирования родительской таблицы и "
"не должно конфликтовать с другой существующей секцией того же родителя. "
"Вариант указания с <literal>IN</literal> используется для секционирования по "
"спискам, а вариант с <literal>FROM</literal> и <literal>TO</literal> для "
"секционирования по диапазонам."

#. +> REL_10
#: ref/create_table.xml:270(para)
msgid ""
"Each of the values specified in the <replaceable class=\"parameter"
"\">partition_bound_spec</replaceable> is a literal, <literal>NULL</literal>, "
"<literal>MINVALUE</literal>, or <literal>MAXVALUE</literal>. Each literal "
"value must be either a numeric constant that is coercible to the "
"corresponding partition key column's type, or a string literal that is valid "
"input for that type."
msgstr ""
"В качестве значений, задаваемых в <replaceable class=\"parameter"
"\">указании_границ_секции</replaceable>, принимается буквальное значение, "
"<literal>NULL</literal> и <literal>MINVALUE</literal> или <literal>MAXVALUE</"
"literal>. Буквальным значением должна быть либо числовая константа, "
"приводимая к типу соответствующего столбца ключа разбиения, либо строковая "
"константа, представляющая допустимое входное значение для этого типа."

#. +> REL_10
#: ref/create_table.xml:279(para)
msgid ""
"When creating a list partition, <literal>NULL</literal> can be specified to "
"signify that the partition allows the partition key column to be null. "
"However, there cannot be more than one such list partition for a given "
"parent table. <literal>NULL</literal> cannot be specified for range "
"partitions."
msgstr ""
"При создании секции с разбиением по спискам возможно указать, что столбец "
"ключа разбиения может содержать NULL, включив в список секции <literal>NULL</"
"literal>. Однако для одной родительской таблицы может быть не больше одной "
"такой секции. Для диапазонных секций <literal>NULL</literal> задать нельзя."

#. +> REL_10
#: ref/create_table.xml:287(para)
msgid ""
"When creating a range partition, the lower bound specified with "
"<literal>FROM</literal> is an inclusive bound, whereas the upper bound "
"specified with <literal>TO</literal> is an exclusive bound. That is, the "
"values specified in the <literal>FROM</literal> list are valid values of the "
"corresponding partition key columns for this partition, whereas those in the "
"<literal>TO</literal> list are not. Note that this statement must be "
"understood according to the rules of row-wise comparison (<xref linkend="
"\"row-wise-comparison\"/>). For example, given <literal>PARTITION BY RANGE "
"(x,y)</literal>, a partition bound <literal>FROM (1, 2) TO (3, 4)</literal> "
"allows <literal>x=1</literal> with any <literal>y&gt;=2</literal>, "
"<literal>x=2</literal> with any non-null <literal>y</literal>, and "
"<literal>x=3</literal> with any <literal>y&lt;4</literal>."
msgstr ""
"При создании диапазонной секции нижняя граница, задаваемая во <literal>FROM</"
"literal>, включается в диапазон, а верхняя граница, задаваемая в "
"<literal>TO</literal> — исключается. То есть, значения, задаваемые в списке "
"<literal>FROM</literal>, являются допустимыми значениями соответствующих "
"столбцов ключа разбиения для этой секции, а значения в списке <literal>TO</"
"literal> — нет. Заметьте, что это утверждение должно восприниматься с учётом "
"правил сравнения строк таблицы (см. <xref remap=\"4\" linkend=\"row-wise-"
"comparison\"/>). Например, с разбиением <literal>PARTITION BY RANGE (x,y)</"
"literal>, секция с границами <literal>FROM (1, 2) TO (3, 4)</literal> примет "
"<literal>x=1</literal> с любым значением <literal>y&gt;=2</literal>, "
"<literal>x=2</literal> с любым <literal>y</literal>, отличным от NULL, и "
"<literal>x=3</literal> с любым <literal>y&lt;4</literal>."

#. +> REL_10
#: ref/create_table.xml:303(para)
msgid ""
"The special values <literal>MINVALUE</literal> and <literal>MAXVALUE</"
"literal> may be used when creating a range partition to indicate that there "
"is no lower or upper bound on the column's value. For example, a partition "
"defined using <literal>FROM (MINVALUE) TO (10)</literal> allows any values "
"less than 10, and a partition defined using <literal>FROM (10) TO "
"(MAXVALUE)</literal> allows any values greater than or equal to 10."
msgstr ""
"Специальные значения <literal>MINVALUE</literal> и <literal>MAXVALUE</"
"literal> могут использоваться при создании диапазонной секции для указания, "
"что нижняя или верхняя граница для значений столбца отсутствует. Например, "
"секция, определённая с указанием <literal>FROM (MINVALUE) TO (10)</literal>, "
"будет принимать любые значения меньше 10, а секция, определённая с указанием "
"<literal>FROM (10) TO (MAXVALUE)</literal>, — любые значения, которые больше "
"или равны 10."

#. +> REL_10
#: ref/create_table.xml:313(para)
msgid ""
"When creating a range partition involving more than one column, it can also "
"make sense to use <literal>MAXVALUE</literal> as part of the lower bound, "
"and <literal>MINVALUE</literal> as part of the upper bound. For example, a "
"partition defined using <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</"
"literal> allows any rows where the first partition key column is greater "
"than 0 and less than or equal to 10. Similarly, a partition defined using "
"<literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</literal> allows any rows "
"where the first partition key column starts with \"a\"."
msgstr ""
"При создании диапазонной секции с более чем одним столбцом может также иметь "
"смысл использовать <literal>MAXVALUE</literal> в определении нижней границы, "
"а <literal>MINVALUE</literal> — верхней. Например, секция, определённая с "
"указанием <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</literal>, будет "
"принимать любые строки, в которых первый столбец ключа разбиения больше 0 и "
"меньше или равен 10. Подобным образом, секция, определённая с указанием "
"<literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</literal>, будет принимать "
"строки, в которых первый столбец ключа разбиения начинается с \"a\"."

#. +> REL_10
#: ref/create_table.xml:325(para)
msgid ""
"Note that if <literal>MINVALUE</literal> or <literal>MAXVALUE</literal> is "
"used for one column of a partitioning bound, the same value must be used for "
"all subsequent columns. For example, <literal>(10, MINVALUE, 0)</literal> is "
"not a valid bound; you should write <literal>(10, MINVALUE, MINVALUE)</"
"literal>."
msgstr ""
"Заметьте, что если для одного столбца в границе секции задаётся "
"<literal>MINVALUE</literal> или <literal>MAXVALUE</literal>, то же значение "
"должно применяться и для всех последующих столбцов. Например, граница "
"<literal>(10, MINVALUE, 0)</literal> будет некорректной; допустимая граница: "
"<literal>(10, MINVALUE, MINVALUE)</literal>."

#. +> REL_10
#: ref/create_table.xml:332(para)
msgid ""
"Also note that some element types, such as <literal>timestamp</literal>, "
"have a notion of \"infinity\", which is just another value that can be "
"stored. This is different from <literal>MINVALUE</literal> and "
"<literal>MAXVALUE</literal>, which are not real values that can be stored, "
"but rather they are ways of saying that the value is unbounded. "
"<literal>MAXVALUE</literal> can be thought of as being greater than any "
"other value, including \"infinity\" and <literal>MINVALUE</literal> as being "
"less than any other value, including \"minus infinity\". Thus the range "
"<literal>FROM ('infinity') TO (MAXVALUE)</literal> is not an empty range; it "
"allows precisely one value to be stored &mdash; \"infinity\"."
msgstr ""
"Также заметьте, что для некоторых типов элементов, таких как "
"<literal>timestamp</literal>, наряду с другими значениями допускается "
"значение \"infinity\" (бесконечность). Оно отличается от вариантов "
"<literal>MINVALUE</literal> и <literal>MAXVALUE</literal>, которые на самом "
"деле не обозначают значения, которые можно сохранить, а просто говорят о "
"том, это значение не ограничено. <literal>MAXVALUE</literal> можно "
"воспринимать как значение, которое больше любого другого, включая "
"\"бесконечность\", а <literal>MINVALUE</literal> меньше любого другого "
"значения, включая \"минус бесконечность\". Таким образом, диапазон "
"<literal>FROM ('infinity') TO (MAXVALUE)</literal> не будет пустым, а будет "
"принимать ровно одно значение &mdash; \"infinity\"."

#. +> REL_10
#: ref/create_table.xml:345(para)
msgid ""
"A partition must have the same column names and types as the partitioned "
"table to which it belongs. If the parent is specified <literal>WITH OIDS</"
"literal> then all partitions must have OIDs; the parent's OID column will be "
"inherited by all partitions just like any other column. Modifications to the "
"column names or types of a partitioned table, or the addition or removal of "
"an OID column, will automatically propagate to all partitions. "
"<literal>CHECK</literal> constraints will be inherited automatically by "
"every partition, but an individual partition may specify additional "
"<literal>CHECK</literal> constraints; additional constraints with the same "
"name and condition as in the parent will be merged with the parent "
"constraint. Defaults may be specified separately for each partition."
msgstr ""
"В секции должны содержаться столбцы с теми же именами и типами, что и в "
"секционированной таблице, к которой она относится. Если родитель имеет "
"характеристику <literal>WITH OIDS</literal>, все секции должны иметь OID; "
"родительский столбец OID будет наследоваться всеми секциями, как и любой "
"другой столбец. Изменение имён или типов столбцов в секционируемой таблице, "
"или добавление или удаление столбца OID будет автоматически распространяться "
"во все секции. Ограничения <literal>CHECK</literal> будут наследоваться "
"автоматически всеми секциями, но для отдельных секций могут быть заданы "
"дополнительные ограничения <literal>CHECK</literal>; дополнительные "
"ограничения с теми же именами и условиями, как в родительской таблицы, будут "
"объединены с родительским ограничением. Также независимо для каждой секции "
"могут быть заданы значения по умолчанию."

#. +> REL_10
#: ref/create_table.xml:360(para)
msgid ""
"Rows inserted into a partitioned table will be automatically routed to the "
"correct partition. If no suitable partition exists, an error will occur. "
"Also, if updating a row in a given partition would require it to move to "
"another partition due to new partition key values, an error will occur."
msgstr ""
"Строки, добавляемые в секционированную таблицу, будут автоматически "
"перенаправляться в соответствующую секцию. Если подходящей секции не "
"найдётся, произойдёт ошибка. Также ошибка произойдёт, если при изменении "
"строки в определённой секции требуется переместить её в другую секцию из-за "
"изменения значений в ключе разбиения."

#. +> REL_10
#: ref/create_table.xml:368(para)
msgid ""
"Operations such as TRUNCATE which normally affect a table and all of its "
"inheritance children will cascade to all partitions, but may also be "
"performed on an individual partition. Note that dropping a partition with "
"<literal>DROP TABLE</literal> requires taking an <literal>ACCESS EXCLUSIVE</"
"literal> lock on the parent table."
msgstr ""
"Такие операции, как TRUNCATE, обычно затрагивают и саму таблицу, и каскадно "
"распространяются на все дочерние секции, но могут также выполняться в "
"отдельных секциях. Заметьте, что для удаления секции с помощью <literal>DROP "
"TABLE</literal> требуется установить блокировку <literal>ACCESS EXCLUSIVE</"
"literal> в родительской таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:381(para)
msgid "The name of a column to be created in the new table."
msgstr "Имя столбца, создаваемого в новой таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:390(para)
msgid ""
"The data type of the column. This can include array specifiers. For more "
"information on the data types supported by <productname>PostgreSQL</"
"productname>, refer to <xref linkend=\"datatype\"/>."
msgstr ""
"Тип данных столбца (может включать определение массива с этим типом). За "
"дополнительными сведениями о типах данных, которые поддерживает "
"<productname>PostgreSQL</productname>, обратитесь к <xref remap=\"3\" "
"linkend=\"datatype\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:400(literal)
msgid "COLLATE <placeholder-1/>"
msgstr "COLLATE <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:402(para)
msgid ""
"The <literal>COLLATE</literal> clause assigns a collation to the column "
"(which must be of a collatable data type). If not specified, the column data "
"type's default collation is used."
msgstr ""
"Предложение <literal>COLLATE</literal> назначает правило сортировки для "
"столбца (который должен иметь тип, поддерживающий сортировку). Если оно "
"отсутствует, используется правило сортировки по умолчанию, установленное для "
"типа данных столбца."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:411(literal)
msgid "INHERITS ( <placeholder-1/> [, ... ] )"
msgstr "INHERITS ( <placeholder-1/> [, ... ] )"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:413(para)
msgid ""
"The optional <literal>INHERITS</literal> clause specifies a list of tables "
"from which the new table automatically inherits all columns. Parent tables "
"can be plain tables or foreign tables."
msgstr ""
"Необязательное предложение <literal>INHERITS</literal> определяет список "
"таблиц, от которых новая таблица будет автоматически наследовать все "
"столбцы. Родительские таблицы могут быть обычными или сторонними таблицами."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:419(para)
msgid ""
"Use of <literal>INHERITS</literal> creates a persistent relationship between "
"the new child table and its parent table(s). Schema modifications to the "
"parent(s) normally propagate to children as well, and by default the data of "
"the child table is included in scans of the parent(s)."
msgstr ""
"При использовании <literal>INHERITS</literal> создаётся постоянная связь "
"дочерней таблицы с родительскими. Изменения схемы в родительских таблицах "
"обычно также отражаются в дочерних, и по умолчанию при чтении родительских "
"таблиц в результат включаются данные дочерней таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:427(para)
msgid ""
"If the same column name exists in more than one parent table, an error is "
"reported unless the data types of the columns match in each of the parent "
"tables. If there is no conflict, then the duplicate columns are merged to "
"form a single column in the new table. If the column name list of the new "
"table contains a column name that is also inherited, the data type must "
"likewise match the inherited column(s), and the column definitions are "
"merged into one. If the new table explicitly specifies a default value for "
"the column, this default overrides any defaults from inherited declarations "
"of the column. Otherwise, any parents that specify default values for the "
"column must all specify the same default, or an error will be reported."
msgstr ""
"Когда в нескольких родительских таблицах оказываются столбцы с одним именем, "
"происходит ошибка, за исключением случая, когда типы данных всех этих "
"столбцов в таблицах совпадают. В этом случае одноимённые столбцы "
"объединяются и формируют один столбец в новой таблице. Если имя столбца "
"новой таблицы совпадает с именем одного из унаследованных столбцов, их типы "
"так же должны совпадать, и в этом случае определения столбцов тоже сливаются "
"в одну. Если в новой таблице явно указывается значение по умолчанию для "
"нового столбца, это значение переопределяет любые значения по умолчанию, "
"унаследованные этим столбцом. В противном случае, если значения по умолчанию "
"определяются в разных родительских таблицах, эти определения должны "
"совпадать, иначе произойдёт ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:443(para)
msgid ""
"<literal>CHECK</literal> constraints are merged in essentially the same way "
"as columns: if multiple parent tables and/or the new table definition "
"contain identically-named <literal>CHECK</literal> constraints, these "
"constraints must all have the same check expression, or an error will be "
"reported. Constraints having the same name and expression will be merged "
"into one copy. A constraint marked <literal>NO INHERIT</literal> in a parent "
"will not be considered. Notice that an unnamed <literal>CHECK</literal> "
"constraint in the new table will never be merged, since a unique name will "
"always be chosen for it."
msgstr ""
"Ограничения <literal>CHECK</literal> объединяются вместе по сути так же, как "
"и столбцы: если несколько родительских таблиц и/или определение новой "
"таблицы содержат одноимённые ограничения <literal>CHECK</literal>, этим "
"ограничениям должны соответствовать одинаковые выражения проверки, в "
"противном случае произойдёт ошибка. В случае совпадения выражения, эти "
"ограничения с данным выражением объединяются в одно. При этом ограничения со "
"свойством <literal>NO INHERIT</literal> в родительской таблице исключаются "
"из рассмотрения. Заметьте, что безымянное ограничение <literal>CHECK</"
"literal> в новой таблице никогда не сливается с другими, так как для него "
"всегда выбирается уникальное имя."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:455(para)
msgid ""
"Column <literal>STORAGE</literal> settings are also copied from parent "
"tables."
msgstr ""
"Параметры <literal>STORAGE</literal> для столбца так же копируются из "
"родительских таблиц."

#. +> REL_10
#: ref/create_table.xml:459(para)
msgid ""
"If a column in the parent table is an identity column, that property is not "
"inherited. A column in the child table can be declared identity column if "
"desired."
msgstr ""
"Если столбец в родительской таблице является столбцом идентификации, это "
"свойство не наследуется. Если требуется, в дочерней таблице этот столбец "
"можно объявить столбцом идентификации."

#. +> REL_10
#: ref/create_table.xml:468(literal)
msgid ""
"PARTITION BY { RANGE | LIST } ( { <placeholder-1/> | ( <placeholder-2/> ) } "
"[ <placeholder-3/> ] [, ...] )"
msgstr ""
"PARTITION BY { RANGE | LIST } ( { <placeholder-1/> | ( <placeholder-2/> ) } "
"[ <placeholder-3/> ] [, ...] )"

#. +> REL_10
#: ref/create_table.xml:470(para)
msgid ""
"The optional <literal>PARTITION BY</literal> clause specifies a strategy of "
"partitioning the table. The table thus created is called a "
"<firstterm>partitioned</firstterm> table. The parenthesized list of columns "
"or expressions forms the <firstterm>partition key</firstterm> for the table. "
"When using range partitioning, the partition key can include multiple "
"columns or expressions (up to 32, but this limit can be altered when "
"building <productname>PostgreSQL</productname>), but for list partitioning, "
"the partition key must consist of a single column or expression. If no B-"
"tree operator class is specified when creating a partitioned table, the "
"default B-tree operator class for the datatype will be used. If there is "
"none, an error will be reported."
msgstr ""
"Необязательное предложение <literal>PARTITION BY</literal> задаёт стратегию "
"секционирования таблицы. Таблица, созданная с этим указанием, называется "
"<firstterm>секционируемой</firstterm> таблицей. Задаваемый в скобках список "
"столбцов или выражений формирует <firstterm>ключ разбиения</firstterm> "
"таблицы. Для разбиения по диапазонам ключ разбиения может включать несколько "
"столбцов или выражений (до 32, но этот предел можно изменить при сборке "
"<productname>PostgreSQL</productname>), но для разбиения по спискам ключ "
"разбиения должен состоять из одного столбца или выражения. Если при создании "
"секционируемой таблицы класс операторов B-дерева не указывается, будет "
"использоваться класс операторов B-дерева по умолчанию для данного типа "
"данных. Если такой класс операторов не находится, выдаётся ошибка."

#. +> REL_10
#: ref/create_table.xml:484(para)
msgid ""
"A partitioned table is divided into sub-tables (called partitions), which "
"are created using separate <literal>CREATE TABLE</literal> commands. The "
"partitioned table is itself empty. A data row inserted into the table is "
"routed to a partition based on the value of columns or expressions in the "
"partition key. If no existing partition matches the values in the new row, "
"an error will be reported."
msgstr ""
"Секционируемая таблица разделяется на подтаблицы (называемые секциями), "
"которые создаются отдельными командами <literal>CREATE TABLE</literal>. Сама "
"по себе секционируемая таблица не содержит данных. Строка данных, "
"вставляемая в эту таблицу, перенаправляется в секцию в зависимости от "
"значений столбцов или выражений в ключе разбиения. Если значениям в новой "
"строке не соответствует ни одна из существующих секций, возникает ошибка."

#. +> REL_10
#: ref/create_table.xml:493(para)
msgid ""
"Partitioned tables do not support <literal>UNIQUE</literal>, "
"<literal>PRIMARY KEY</literal>, <literal>EXCLUDE</literal>, or "
"<literal>FOREIGN KEY</literal> constraints; however, you can define these "
"constraints on individual partitions."
msgstr ""
"Секционируемые таблицы не поддерживают ограничения <literal>UNIQUE</"
"literal>, <literal>PRIMARY KEY</literal>, <literal>EXCLUDE</literal> и "
"<literal>FOREIGN KEY</literal>; однако вы можете определить эти ограничения "
"в отдельных секциях."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:504(literal)
msgid "LIKE <placeholder-1/> [ <placeholder-2/> ... ]"
msgstr "LIKE <placeholder-1/> [ <placeholder-2/> ... ]"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:506(para)
msgid ""
"The <literal>LIKE</literal> clause specifies a table from which the new "
"table automatically copies all column names, their data types, and their not-"
"null constraints."
msgstr ""
"Предложение <literal>LIKE</literal> определяет таблицу, из которой в новую "
"таблицу будут автоматически скопированы все имена столбцов, их типы данных и "
"их ограничения на NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:511(para)
msgid ""
"Unlike <literal>INHERITS</literal>, the new table and original table are "
"completely decoupled after creation is complete. Changes to the original "
"table will not be applied to the new table, and it is not possible to "
"include data of the new table in scans of the original table."
msgstr ""
"В отличие от <literal>INHERITS</literal>, новая и исходная таблица "
"становятся полностью независимыми после завершения создания. Изменения в "
"исходной таблице не отражаются в новой, а данные новой таблицы не включаются "
"в результат чтения исходной."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:518(para)
msgid ""
"Default expressions for the copied column definitions will be copied only if "
"<literal>INCLUDING DEFAULTS</literal> is specified. The default behavior is "
"to exclude default expressions, resulting in the copied columns in the new "
"table having null defaults. Note that copying defaults that call database-"
"modification functions, such as <function>nextval</function>, may create a "
"functional linkage between the original and new tables."
msgstr ""
"Выражения значений по умолчанию в определениях копируемых столбцов "
"переносятся в новую таблицу, только если дополнительно указано "
"<literal>INCLUDING DEFAULTS</literal>. Без этого указания выражения по "
"умолчанию не копируются, вследствие чего в новой таблице скопированные "
"столбцы получают значения по умолчанию NULL. Заметьте, что при копировании "
"выражений по умолчанию, которые вызывают функции, модифицирующие БД, как "
"например <function>nextval</function>, может образовываться функциональная "
"связь исходной таблицы с новой."

#. +> REL_10
#: ref/create_table.xml:527(para)
msgid ""
"Any identity specifications of copied column definitions will only be copied "
"if <literal>INCLUDING IDENTITY</literal> is specified. A new sequence is "
"created for each identity column of the new table, separate from the "
"sequences associated with the old table."
msgstr ""
"Характеристика идентификации в определении скопированного столбца будет "
"копироваться, только если в команде есть указание <literal>INCLUDING "
"IDENTITY</literal>. Для каждого столбца идентификации в новой таблице "
"создаётся новая последовательность, независящая от последовательностей, "
"связанных со старой таблицей."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:533(para)
msgid ""
"Not-null constraints are always copied to the new table. <literal>CHECK</"
"literal> constraints will be copied only if <literal>INCLUDING CONSTRAINTS</"
"literal> is specified. No distinction is made between column constraints and "
"table constraints."
msgstr ""
"Ограничения NULL копируются в новую таблицу всегда, а ограничения "
"<literal>CHECK</literal> копируются только при явном указании "
"<literal>INCLUDING CONSTRAINTS</literal>. Это в равной мере касается "
"ограничений как таблиц, так и столбцов."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:540(para)
msgid ""
"Indexes, <literal>PRIMARY KEY</literal>, <literal>UNIQUE</literal>, and "
"<literal>EXCLUDE</literal> constraints on the original table will be created "
"on the new table only if <literal>INCLUDING INDEXES</literal> is specified. "
"Names for the new indexes and constraints are chosen according to the "
"default rules, regardless of how the originals were named. (This behavior "
"avoids possible duplicate-name failures for the new indexes.)"
msgstr ""
"Индексы, свойство <literal>PRIMARY KEY</literal>, а также ограничения "
"<literal>UNIQUE</literal> и <literal>EXCLUDE</literal> копируются из "
"исходной таблицы в новую, только если явно указано <literal>INCLUDING "
"INDEXES</literal>. Имена для новых индексов и ограничений выбираются "
"согласно стандартным правилам, независимо от того, как назывались исходные. "
"(Это позволяет избежать ошибок с дублированием имён с новыми индексами.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:549(para)
msgid ""
"<literal>STORAGE</literal> settings for the copied column definitions will "
"be copied only if <literal>INCLUDING STORAGE</literal> is specified. The "
"default behavior is to exclude <literal>STORAGE</literal> settings, "
"resulting in the copied columns in the new table having type-specific "
"default settings. For more on <literal>STORAGE</literal> settings, see <xref "
"linkend=\"storage-toast\"/>."
msgstr ""
"Параметры <literal>STORAGE</literal> будут перенесены в определение "
"копируемых столбцов, только если явно указывается <literal>INCLUDING "
"STORAGE</literal>. По умолчанию параметры <literal>STORAGE</literal> "
"исключаются, вследствие чего скопированные столбцы в новой таблице получают "
"параметры по умолчанию, определённые соответствующим типом. Подробнее "
"параметры <literal>STORAGE</literal> описаны в <xref remap=\"6\" linkend="
"\"storage-toast\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:557(para)
msgid ""
"Comments for the copied columns, constraints, and indexes will be copied "
"only if <literal>INCLUDING COMMENTS</literal> is specified. The default "
"behavior is to exclude comments, resulting in the copied columns and "
"constraints in the new table having no comments."
msgstr ""
"Комментарии для скопированных столбцов, ограничений и индексов будут "
"копироваться, только если явно указано <literal>INCLUDING COMMENTS</"
"literal>. По умолчанию комментарии исключаются, вследствие чего "
"скопированные столбцы и ограничения в новой таблице оказываются без "
"комментариев."

#. +> REL_10
#: ref/create_table.xml:563(para)
msgid ""
"<literal>INCLUDING ALL</literal> is an abbreviated form of "
"<literal>INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING CONSTRAINTS "
"INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>."
msgstr ""
"Предложение <literal>INCLUDING ALL</literal> является сокращённой формой "
"развёрнутого предложения <literal>INCLUDING DEFAULTS INCLUDING IDENTITY "
"INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING "
"COMMENTS</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:567(para)
msgid ""
"Note that unlike <literal>INHERITS</literal>, columns and constraints copied "
"by <literal>LIKE</literal> are not merged with similarly named columns and "
"constraints. If the same name is specified explicitly or in another "
"<literal>LIKE</literal> clause, an error is signaled."
msgstr ""
"Заметьте, что в отличие от <literal>INHERITS</literal>, столбцы и "
"ограничения, копируемые командой <literal>LIKE</literal>, не объединяются с "
"одноимёнными столбцами и ограничениями. Если дублирующееся имя указывается "
"явно или возникает в другом предложении <literal>LIKE</literal>, происходит "
"ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:574(para)
msgid ""
"The <literal>LIKE</literal> clause can also be used to copy column "
"definitions from views, foreign tables, or composite types. Inapplicable "
"options (e.g., <literal>INCLUDING INDEXES</literal> from a view) are ignored."
msgstr ""
"Предложение <literal>LIKE</literal> может также применяться для копирования "
"определений столбцов из представлений, сторонних таблиц и составных типов. "
"Неприменимые параметры (например, <literal>INCLUDING INDEXES</literal> для "
"представления) при этом игнорируются."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:584(literal)
msgid "CONSTRAINT <placeholder-1/>"
msgstr "CONSTRAINT <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:586(para)
msgid ""
"An optional name for a column or table constraint. If the constraint is "
"violated, the constraint name is present in error messages, so constraint "
"names like <literal>col must be positive</literal> can be used to "
"communicate helpful constraint information to client applications. (Double-"
"quotes are needed to specify constraint names that contain spaces.) If a "
"constraint name is not specified, the system generates a name."
msgstr ""
"Необязательное имя столбца или ограничения таблицы. При нарушении "
"ограничения его имя будет выводиться в сообщении об ошибках, так что имена "
"ограничений вида <literal>столбец должен быть положительным</literal> могут "
"сообщить полезную информацию об ограничении клиентскому приложению. (Имена "
"ограничений, включающие пробелы, необходимо заключать в двойные кавычки.) "
"Если имя ограничения не указано, система генерирует имя автоматически."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:598(literal)
msgid "NOT NULL"
msgstr "NOT NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:600(para)
msgid "The column is not allowed to contain null values."
msgstr "Данный столбец не принимает значения NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:607(literal) ref/create_table.xml:1783(literal)
msgid "NULL"
msgstr "NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:609(para)
msgid "The column is allowed to contain null values. This is the default."
msgstr "Данный столбец может содержать значения NULL (по умолчанию)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:613(para)
msgid ""
"This clause is only provided for compatibility with non-standard SQL "
"databases. Its use is discouraged in new applications."
msgstr ""
"Это предложение предназначено только для совместимости с нестандартными "
"базами данных SQL. Использовать его в новых приложениях не рекомендуется."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:622(literal)
msgid "CHECK ( <placeholder-1/> ) [ NO INHERIT ]"
msgstr "CHECK ( <placeholder-1/> ) [ NO INHERIT ]"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:624(para)
msgid ""
"The <literal>CHECK</literal> clause specifies an expression producing a "
"Boolean result which new or updated rows must satisfy for an insert or "
"update operation to succeed. Expressions evaluating to TRUE or UNKNOWN "
"succeed. Should any row of an insert or update operation produce a FALSE "
"result, an error exception is raised and the insert or update does not alter "
"the database. A check constraint specified as a column constraint should "
"reference that column's value only, while an expression appearing in a table "
"constraint can reference multiple columns."
msgstr ""
"В ограничении <literal>CHECK</literal> задаётся выражение, возвращающее "
"булевский результат, по которому определяется, будет ли успешна операция "
"добавления или изменения для конкретных строк. Операция выполняется успешно, "
"если результат выражения равен TRUE или UNKNOWN. Если же для какой-нибудь "
"строки, задействованной в операции добавления или изменения, будет получен "
"результат FALSE, возникает ошибка, и эта операция не меняет ничего в базе "
"данных. Ограничение-проверка, заданное как ограничение столбца, должно "
"ссылаться только на значение самого столбца, тогда как ограничение на уровне "
"таблицы может ссылаться и на несколько столбцов."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:636(para)
msgid ""
"Currently, <literal>CHECK</literal> expressions cannot contain subqueries "
"nor refer to variables other than columns of the current row. The system "
"column <literal>tableoid</literal> may be referenced, but not any other "
"system column."
msgstr ""
"В настоящее время выражения <literal>CHECK</literal> не могут содержать "
"подзапросы или ссылаться на переменные, кроме как на столбцы текущей строки. "
"Также допустима ссылка на системный столбец <literal>tableoid</literal>, но "
"не на другие системные столбцы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:643(para)
msgid ""
"A constraint marked with <literal>NO INHERIT</literal> will not propagate to "
"child tables."
msgstr ""
"Ограничение с пометкой <literal>NO INHERIT</literal> не будет наследоваться "
"дочерними таблицами."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:648(para)
msgid ""
"When a table has multiple <literal>CHECK</literal> constraints, they will be "
"tested for each row in alphabetical order by name, after checking "
"<literal>NOT NULL</literal> constraints. (<productname>PostgreSQL</"
"productname> versions before 9.5 did not honor any particular firing order "
"for <literal>CHECK</literal> constraints.)"
msgstr ""
"Когда для таблицы задано несколько ограничений <literal>CHECK</literal>, они "
"будут проверяться для каждой строки в алфавитном порядке имён после проверки "
"ограничений <literal>NOT NULL</literal>. (До версии 9.5 в "
"<productname>PostgreSQL</productname> не было установлено никакого "
"определённого порядка обработки ограничений <literal>CHECK</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:659(literal)
msgid "DEFAULT <placeholder-1/>"
msgstr "DEFAULT <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:662(para)
msgid ""
"The <literal>DEFAULT</literal> clause assigns a default data value for the "
"column whose column definition it appears within. The value is any variable-"
"free expression (subqueries and cross-references to other columns in the "
"current table are not allowed). The data type of the default expression must "
"match the data type of the column."
msgstr ""
"Предложение <literal>DEFAULT</literal> задаёт значение по умолчанию для "
"столбца, в определении которого оно присутствует. Значение задаётся "
"выражением без переменных (подзапросы и перекрёстные ссылки на другие "
"столбцы текущей таблицы в нём не допускаются). Тип данных выражения, "
"задающего значение по умолчанию, должен соответствовать типу данных столбца."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:671(para)
msgid ""
"The default expression will be used in any insert operation that does not "
"specify a value for the column. If there is no default for a column, then "
"the default is null."
msgstr ""
"Это выражение будет использоваться во всех операциях добавления данных, в "
"которых не задаётся значение данного столбца. Если значение по умолчанию не "
"определено, таким значением будет NULL."

#. +> REL_10
#: ref/create_table.xml:680(literal)
msgid "GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <placeholder-1/> ) ]"
msgstr "GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <placeholder-1/> ) ]"

#. +> REL_10
#: ref/create_table.xml:682(para)
msgid ""
"This clause creates the column as an <firstterm>identity column</firstterm>. "
"It will have an implicit sequence attached to it and the column in new rows "
"will automatically have values from the sequence assigned to it."
msgstr ""
"С этим предложением столбец создаётся как <firstterm>столбец идентификации</"
"firstterm>. С ним будет связана неявная последовательность, из которой этот "
"столбец будет автоматически получать значения в новых строках."

#. +> REL_10
#: ref/create_table.xml:689(para)
msgid ""
"The clauses <literal>ALWAYS</literal> and <literal>BY DEFAULT</literal> "
"determine how the sequence value is given precedence over a user-specified "
"value in an <command>INSERT</command> statement. If <literal>ALWAYS</"
"literal> is specified, a user-specified value is only accepted if the "
"<command>INSERT</command> statement specifies <literal>OVERRIDING SYSTEM "
"VALUE</literal>. If <literal>BY DEFAULT</literal> is specified, then the "
"user-specified value takes precedence. See <xref linkend=\"sql-insert\"/> "
"for details. (In the <command>COPY</command> command, user-specified values "
"are always used regardless of this setting.)"
msgstr ""
"Предложения <literal>ALWAYS</literal> и <literal>BY DEFAULT</literal> "
"определяют, какой приоритет имеет заданное пользователем значение этого "
"столбца в команде <command>INSERT</command>. С предложением <literal>ALWAYS</"
"literal> пользовательское значение используется, только если в операторе "
"<command>INSERT</command> указано <literal>OVERRIDING SYSTEM VALUE</"
"literal>. С предложением <literal>BY DEFAULT</literal> пользовательскому "
"значению отдаётся предпочтение. За подробностями обратитесь к <xref remap="
"\"3\" linkend=\"sql-insert\"/>. (В команде <command>COPY</command> всегда "
"используются пользовательские значения, вне зависимости от значения этого "
"параметра.)"

#. +> REL_10
#: ref/create_table.xml:702(para)
msgid ""
"The optional <replaceable>sequence_options</replaceable> clause can be used "
"to override the options of the sequence. See <xref linkend=\"sql-"
"createsequence\"/> for details."
msgstr ""
"Используя необязательное предложение "
"<replaceable>параметры_последовательности</replaceable>, можно "
"переопределить свойства последовательности. За подробностями обратитесь к "
"<xref remap=\"3\" linkend=\"sql-createsequence\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:711(term)
msgid "<literal>UNIQUE</literal> (column constraint)"
msgstr "<literal>UNIQUE</literal> (ограничение столбца)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:712(term)
msgid ""
"<literal>UNIQUE ( <replaceable class=\"parameter\">column_name</replaceable> "
"[, ... ] )</literal> (table constraint)"
msgstr ""
"<literal>UNIQUE ( <replaceable class=\"parameter\">имя_столбца</replaceable> "
"[, ... ] )</literal> (ограничение таблицы)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:715(para)
msgid ""
"The <literal>UNIQUE</literal> constraint specifies that a group of one or "
"more columns of a table can contain only unique values. The behavior of the "
"unique table constraint is the same as that for column constraints, with the "
"additional capability to span multiple columns."
msgstr ""
"Ограничение <literal>UNIQUE</literal> определяет, что группа из одного или "
"нескольких столбцов таблицы может содержать только уникальные значения. "
"Ограничение уникальности для таблицы ведёт себя точно так же, как "
"ограничение для столбца, но может охватывать несколько столбцов."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:723(para)
msgid ""
"For the purpose of a unique constraint, null values are not considered equal."
msgstr ""
"При проверке ограничения уникальности значения NULL не считаются равными."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:728(para)
msgid ""
"Each unique table constraint must name a set of columns that is different "
"from the set of columns named by any other unique or primary key constraint "
"defined for the table. (Otherwise it would just be the same constraint "
"listed twice.)"
msgstr ""
"В каждом ограничении уникальности для таблицы должен задаваться набор "
"столбцов, отличный от набора любого другого ограничения уникальности или "
"первичного ключа в данной таблице. (Иначе это будет одно и то же "
"ограничение, определённое многократно.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:738(term)
msgid "<literal>PRIMARY KEY</literal> (column constraint)"
msgstr "<literal>PRIMARY KEY</literal> (ограничение столбца)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:739(term)
msgid ""
"<literal>PRIMARY KEY ( <replaceable class=\"parameter\">column_name</"
"replaceable> [, ... ] )</literal> (table constraint)"
msgstr ""
"<literal>PRIMARY KEY ( <replaceable class=\"parameter\">имя_столбца</"
"replaceable> [, ... ] )</literal> (ограничение таблицы)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:741(para)
msgid ""
"The <literal>PRIMARY KEY</literal> constraint specifies that a column or "
"columns of a table can contain only unique (non-duplicate), nonnull values. "
"Only one primary key can be specified for a table, whether as a column "
"constraint or a table constraint."
msgstr ""
"Ограничение <literal>PRIMARY KEY</literal> определяет, что столбец или "
"столбцы таблицы могут содержать только уникальные (без повторений) значения, "
"отличные от NULL. Для таблицы может быть задан только один первичный ключ, "
"будь то ограничение столбца или ограничение таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:748(para)
msgid ""
"The primary key constraint should name a set of columns that is different "
"from the set of columns named by any unique constraint defined for the same "
"table. (Otherwise, the unique constraint is redundant and will be discarded.)"
msgstr ""
"В определении первичного ключа должен задаваться набор столбцов, отличный от "
"набора любого другого ограничения уникальности, установленного для данной "
"таблицы. (В противном случае уникальное ограничение оказывается избыточным и "
"будет отброшено.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:755(para)
msgid ""
"<literal>PRIMARY KEY</literal> enforces the same data constraints as a "
"combination of <literal>UNIQUE</literal> and <literal>NOT NULL</literal>, "
"but identifying a set of columns as the primary key also provides metadata "
"about the design of the schema, since a primary key implies that other "
"tables can rely on this set of columns as a unique identifier for rows."
msgstr ""
"<literal>PRIMARY KEY</literal> устанавливает для данных те же ограничения, "
"что и сочетание <literal>UNIQUE</literal> и <literal>NOT NULL</literal>, но "
"образование первичного ключа из набора столбцов также добавляет метаданные о "
"конструкции схемы, так как первичный ключ подразумевает, что другие таблицы "
"могут ссылаться на этот набор столбцов, как на уникальный идентификатор "
"строк."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:766(literal)
msgid ""
"EXCLUDE [ USING <placeholder-1/> ] ( <placeholder-2/> WITH <placeholder-3/> "
"[, ... ] ) <placeholder-4/> [ WHERE ( <placeholder-5/> ) ]"
msgstr ""
"EXCLUDE [ USING <placeholder-1/> ] ( <placeholder-2/> WITH <placeholder-3/> "
"[, ... ] ) <placeholder-4/> [ WHERE ( <placeholder-5/> ) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:768(para)
msgid ""
"The <literal>EXCLUDE</literal> clause defines an exclusion constraint, which "
"guarantees that if any two rows are compared on the specified column(s) or "
"expression(s) using the specified operator(s), not all of these comparisons "
"will return <literal>TRUE</literal>. If all of the specified operators test "
"for equality, this is equivalent to a <literal>UNIQUE</literal> constraint, "
"although an ordinary unique constraint will be faster. However, exclusion "
"constraints can specify constraints that are more general than simple "
"equality. For example, you can specify a constraint that no two rows in the "
"table contain overlapping circles (see <xref linkend=\"datatype-geometric\"/"
">) by using the <literal>&amp;&amp;</literal> operator."
msgstr ""
"Предложение <literal>EXCLUDE</literal> определяет ограничение-исключение, "
"которое гарантирует, что для любых двух строк, сравниваемых по указанным "
"столбцам или выражениям с указанными операторами, результат не будет равен "
"<literal>TRUE</literal> для всех сравнений. Если все указанные операторы "
"проверяют равенство, это ограничение равносильно ограничению "
"<literal>UNIQUE</literal>, хотя обычное ограничение уникальности будет "
"работать быстрее. С другой стороны, в ограничениях-исключениях можно "
"задавать более общие условия, чем простое условие на равенство. Например, "
"можно задать ограничение, требующее, чтобы никакие две строки в таблице не "
"содержали пересекающихся кругов (см. <xref remap=\"4\" linkend=\"datatype-"
"geometric\"/>), применив оператор <literal>&amp;&amp;</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:784(para)
msgid ""
"Exclusion constraints are implemented using an index, so each specified "
"operator must be associated with an appropriate operator class (see <xref "
"linkend=\"indexes-opclass\"/>) for the index access method "
"<replaceable>index_method</replaceable>. The operators are required to be "
"commutative. Each <replaceable class=\"parameter\">exclude_element</"
"replaceable> can optionally specify an operator class and/or ordering "
"options; these are described fully under <xref linkend=\"sql-createindex\"/>."
msgstr ""
"Ограничения-исключения реализуются с помощью индексов, так что каждый "
"указанный в них оператор должен быть связан с соответствующим классом "
"операторов (см. <xref remap=\"4\" linkend=\"indexes-opclass\"/>) для "
"<replaceable>метода_индекса</replaceable>. Кроме того, операторы должны быть "
"коммутативными. В каждом <replaceable class=\"parameter"
"\">элементе_исключения</replaceable> можно дополнительно указать класс "
"оператора и/или параметры сортировки, подробно описанные в <xref remap=\"6\" "
"linkend=\"sql-createindex\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:797(para)
msgid ""
"The access method must support <literal>amgettuple</literal> (see <xref "
"linkend=\"indexam\"/>); at present this means <acronym>GIN</acronym> cannot "
"be used. Although it's allowed, there is little point in using B-tree or "
"hash indexes with an exclusion constraint, because this does nothing that an "
"ordinary unique constraint doesn't do better. So in practice the access "
"method will always be <acronym>GiST</acronym> or <acronym>SP-GiST</acronym>."
msgstr ""
"Метод индекса должен поддерживать <literal>amgettuple</literal> (см. <xref "
"remap=\"4\" linkend=\"indexam\"/>); в настоящее время это означает, что "
"метод <acronym>GIN</acronym> здесь применять нельзя. Хотя в ограничении-"
"исключении можно использовать B-деревья и хеш-индексы, в этом мало смысла, "
"так как такой подход ничем не лучше обычного ограничения уникальности. Так "
"что на практике методом индекса всегда будет <acronym>GiST</acronym> или "
"<acronym>SP-GiST</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:807(para)
msgid ""
"The <replaceable class=\"parameter\">predicate</replaceable> allows you to "
"specify an exclusion constraint on a subset of the table; internally this "
"creates a partial index. Note that parentheses are required around the "
"predicate."
msgstr ""
"Параметр <replaceable class=\"parameter\">предикат</replaceable> позволяет "
"указать ограничение-исключение для подмножества таблицы; внутри при этом "
"создаётся частичный индекс. Заметьте, что предикат необходимо заключить в "
"скобки."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:816(term)
msgid ""
"<literal>REFERENCES <replaceable class=\"parameter\">reftable</replaceable> "
"[ ( <replaceable class=\"parameter\">refcolumn</replaceable> ) ] [ MATCH "
"<replaceable class=\"parameter\">matchtype</replaceable> ] [ ON DELETE "
"<replaceable class=\"parameter\">action</replaceable> ] [ ON UPDATE "
"<replaceable class=\"parameter\">action</replaceable> ]</literal> (column "
"constraint)"
msgstr ""
"<literal>REFERENCES <replaceable class=\"parameter\">внешняя_таблица</"
"replaceable> [ ( <replaceable class=\"parameter\">внешний_столбец</"
"replaceable> ) ] [ MATCH <replaceable class=\"parameter\">тип_совпадения</"
"replaceable> ] [ ON DELETE <replaceable class=\"parameter\">действие</"
"replaceable> ] [ ON UPDATE <replaceable class=\"parameter\">действие</"
"replaceable> ]</literal> (ограничение столбца)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:818(term)
msgid ""
"<literal>FOREIGN KEY ( <replaceable class=\"parameter\">column_name</"
"replaceable> [, ... ] ) REFERENCES <replaceable class=\"parameter"
"\">reftable</replaceable> [ ( <replaceable class=\"parameter\">refcolumn</"
"replaceable> [, ... ] ) ] [ MATCH <replaceable class=\"parameter"
"\">matchtype</replaceable> ] [ ON DELETE <replaceable class=\"parameter"
"\">action</replaceable> ] [ ON UPDATE <replaceable class=\"parameter"
"\">action</replaceable> ]</literal> (table constraint)"
msgstr ""
"<literal>FOREIGN KEY ( <replaceable class=\"parameter\">имя_столбца</"
"replaceable> [, ... ] ) REFERENCES <replaceable class=\"parameter"
"\">внешняя_таблица</replaceable> [ ( <replaceable class=\"parameter"
"\">внешний_столбец</replaceable> [, ... ] ) ] [ MATCH <replaceable class="
"\"parameter\">тип_совпадения</replaceable> ] [ ON DELETE <replaceable class="
"\"parameter\">действие</replaceable> ] [ ON UPDATE <replaceable class="
"\"parameter\">действие</replaceable> ]</literal> (ограничение таблицы)"

#. +> REL_10
#: ref/create_table.xml:826(para)
msgid ""
"These clauses specify a foreign key constraint, which requires that a group "
"of one or more columns of the new table must only contain values that match "
"values in the referenced column(s) of some row of the referenced table. If "
"the <replaceable class=\"parameter\">refcolumn</replaceable> list is "
"omitted, the primary key of the <replaceable class=\"parameter\">reftable</"
"replaceable> is used. The referenced columns must be the columns of a non-"
"deferrable unique or primary key constraint in the referenced table. The "
"user must have <literal>REFERENCES</literal> permission on the referenced "
"table (either the whole table, or the specific referenced columns). Note "
"that foreign key constraints cannot be defined between temporary tables and "
"permanent tables."
msgstr ""
"Эти предложения определяют ограничение внешнего ключа, требующее, чтобы "
"группа из одного или нескольких столбцов новой таблицы содержала только "
"такие значения, которым соответствуют значения в заданных столбцах некоторой "
"строки во внешней таблице. Если список <replaceable class=\"parameter"
"\">целевых_столбцов</replaceable> опущен, в качестве него используется "
"первичный ключ <replaceable class=\"parameter\">целевой_таблицы</"
"replaceable>. В качестве целевых столбцов должны указываться столбцы "
"неоткладываемого уникального ограничения или первичного ключа во внешней "
"таблице. При этом пользователь должен иметь право <literal>REFERENCES</"
"literal> во внешней таблице (либо для всей таблицы, либо только для целевых "
"столбцов). Заметьте, что ограничения внешнего ключа, связывающие временные и "
"постоянные таблицы, определить нельзя."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:841(para)
msgid ""
"A value inserted into the referencing column(s) is matched against the "
"values of the referenced table and referenced columns using the given match "
"type. There are three match types: <literal>MATCH FULL</literal>, "
"<literal>MATCH PARTIAL</literal>, and <literal>MATCH SIMPLE</literal> (which "
"is the default). <literal>MATCH FULL</literal> will not allow one column of "
"a multicolumn foreign key to be null unless all foreign key columns are "
"null; if they are all null, the row is not required to have a match in the "
"referenced table. <literal>MATCH SIMPLE</literal> allows any of the foreign "
"key columns to be null; if any of them are null, the row is not required to "
"have a match in the referenced table. <literal>MATCH PARTIAL</literal> is "
"not yet implemented. (Of course, <literal>NOT NULL</literal> constraints can "
"be applied to the referencing column(s) to prevent these cases from arising.)"
msgstr ""
"Значения, вставляемые в ссылающиеся столбцы, сверяются со значениями во "
"внешних столбцах внешней таблицы с учётом заданного типа совпадения. "
"Возможны три типа совпадения: <literal>MATCH FULL</literal> (полное "
"совпадение), <literal>MATCH PARTIAL</literal> (частичное совпадение) и тип "
"по умолчанию, <literal>MATCH SIMPLE</literal> (простое совпадение). С "
"<literal>MATCH FULL</literal> ни один из столбцов составного внешнего ключа "
"не может содержать NULL, кроме случая, когда все внешние столбцы NULL; в "
"этом случае, строка может не иметь соответствия во внешней таблице. С "
"<literal>MATCH SIMPLE</literal> любой из столбцов внешнего ключа может "
"содержать NULL; при этом строка с NULL в одном из таких столбцов может не "
"иметь соответствия во внешней таблице. Тип <literal>MATCH PARTIAL</literal> "
"ещё не реализован. (Разумеется, чтобы вопросы со сравнением NULL не "
"возникали, к столбцам, ссылающимся на внешние, можно применить ограничения "
"<literal>NOT NULL</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:874(literal)
msgid "NO ACTION"
msgstr "NO ACTION"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:876(para)
msgid ""
"Produce an error indicating that the deletion or update would create a "
"foreign key constraint violation. If the constraint is deferred, this error "
"will be produced at constraint check time if there still exist any "
"referencing rows. This is the default action."
msgstr ""
"Выдать ошибку, показывающую, что при удалении или изменении записи "
"произойдёт нарушение ограничения внешнего ключа. Для отложенных ограничений "
"ошибка произойдёт в момент проверки ограничения, если строки, ссылающиеся на "
"эту запись, по-прежнему будут существовать. Этот вариант действия "
"подразумевается по умолчанию."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:887(literal)
msgid "RESTRICT"
msgstr "RESTRICT"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:889(para)
msgid ""
"Produce an error indicating that the deletion or update would create a "
"foreign key constraint violation. This is the same as <literal>NO ACTION</"
"literal> except that the check is not deferrable."
msgstr ""
"Выдать ошибку, показывающую, что при удалении или изменении записи "
"произойдёт нарушение ограничения внешнего ключа. Этот вариант подобен "
"<literal>NO ACTION</literal>, но эта проверка будет неоткладываемой."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:899(literal)
msgid "CASCADE"
msgstr "CASCADE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:901(para)
msgid ""
"Delete any rows referencing the deleted row, or update the values of the "
"referencing column(s) to the new values of the referenced columns, "
"respectively."
msgstr ""
"Удалить все строки, ссылающиеся на удаляемую запись, либо поменять значения "
"в ссылающихся столбцах на новые значения во внешних столбцах, в соответствии "
"с операцией."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:910(literal)
msgid "SET NULL"
msgstr "SET NULL"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:912(para)
msgid "Set the referencing column(s) to null."
msgstr "Установить ссылающиеся столбцы равными NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:919(literal)
msgid "SET DEFAULT"
msgstr "SET DEFAULT"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:921(para)
msgid ""
"Set the referencing column(s) to their default values. (There must be a row "
"in the referenced table matching the default values, if they are not null, "
"or the operation will fail.)"
msgstr ""
"Установить в ссылающихся столбцах значения по умолчанию. (Если эти значения "
"не равны NULL, во внешней таблице должна быть строка, соответствующая набору "
"значений по умолчанию; в противном случае операция завершится ошибкой.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:858(para)
msgid ""
"In addition, when the data in the referenced columns is changed, certain "
"actions are performed on the data in this table's columns. The <literal>ON "
"DELETE</literal> clause specifies the action to perform when a referenced "
"row in the referenced table is being deleted. Likewise, the <literal>ON "
"UPDATE</literal> clause specifies the action to perform when a referenced "
"column in the referenced table is being updated to a new value. If the row "
"is updated, but the referenced column is not actually changed, no action is "
"done. Referential actions other than the <literal>NO ACTION</literal> check "
"cannot be deferred, even if the constraint is declared deferrable. There are "
"the following possible actions for each clause: <placeholder-1/>"
msgstr ""
"Кроме того, при изменении значений во внешних столбцах с данными в столбцах "
"этой таблицы могут производиться определённые действия. Предложение "
"<literal>ON DELETE</literal> задаёт действие, производимое при удалении "
"некоторой строки во внешней таблице. Предложение <literal>ON UPDATE</"
"literal> подобным образом задаёт действие, производимое при изменении "
"значения в целевых столбцах внешней таблицы. Если строка изменена, но это "
"изменение не затронуло целевые столбцы, никакое действие не производится. "
"Ссылочные действия, кроме <literal>NO ACTION</literal>, нельзя сделать "
"откладываемыми, даже если ограничение объявлено как откладываемое. Для "
"каждого предложения возможные следующие варианты действий: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:931(para)
msgid ""
"If the referenced column(s) are changed frequently, it might be wise to add "
"an index to the referencing column(s) so that referential actions associated "
"with the foreign key constraint can be performed more efficiently."
msgstr ""
"Если внешние столбцы меняются часто, будет разумным добавить индекс для "
"ссылающихся столбцов, чтобы действия по обеспечению ссылочной целостности, "
"связанные с ограничением внешнего ключа, выполнялись более эффективно."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:941(literal)
msgid "DEFERRABLE"
msgstr "DEFERRABLE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:942(literal)
msgid "NOT DEFERRABLE"
msgstr "NOT DEFERRABLE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:944(para)
msgid ""
"This controls whether the constraint can be deferred. A constraint that is "
"not deferrable will be checked immediately after every command. Checking of "
"constraints that are deferrable can be postponed until the end of the "
"transaction (using the <xref linkend=\"sql-set-constraints\"/> command). "
"<literal>NOT DEFERRABLE</literal> is the default. Currently, only "
"<literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, <literal>EXCLUDE</"
"literal>, and <literal>REFERENCES</literal> (foreign key) constraints accept "
"this clause. <literal>NOT NULL</literal> and <literal>CHECK</literal> "
"constraints are not deferrable. Note that deferrable constraints cannot be "
"used as conflict arbitrators in an <command>INSERT</command> statement that "
"includes an <literal>ON CONFLICT DO UPDATE</literal> clause."
msgstr ""
"Это предложение определяет, может ли ограничение быть отложенным. "
"Неоткладываемое ограничение будет проверяться немедленно после каждой "
"команды. Проверка откладываемых ограничений может быть отложена до "
"завершения транзакции (обычно с помощью команды <xref linkend=\"sql-set-"
"constraints\"/>). По умолчанию подразумевается вариант <literal>NOT "
"DEFERRABLE</literal>. В настоящее время это предложение принимают только "
"ограничения <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, "
"<literal>EXCLUDE</literal> и <literal>REFERENCES</literal> (внешний ключ). "
"Ограничения <literal>NOT NULL</literal> и <literal>CHECK</literal> не могут "
"быть отложенными. Заметьте, что откладываемые ограничения не могут "
"применяться в качестве решающих при конфликте в операторе <command>INSERT</"
"command> с предложением <literal>ON CONFLICT DO UPDATE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:963(literal)
msgid "INITIALLY IMMEDIATE"
msgstr "INITIALLY IMMEDIATE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:964(literal)
msgid "INITIALLY DEFERRED"
msgstr "INITIALLY DEFERRED"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:966(para)
msgid ""
"If a constraint is deferrable, this clause specifies the default time to "
"check the constraint. If the constraint is <literal>INITIALLY IMMEDIATE</"
"literal>, it is checked after each statement. This is the default. If the "
"constraint is <literal>INITIALLY DEFERRED</literal>, it is checked only at "
"the end of the transaction. The constraint check time can be altered with "
"the <xref linkend=\"sql-set-constraints\"/> command."
msgstr ""
"Для откладываемых ограничений это предложение определяет, когда ограничение "
"должно проверяться по умолчанию. Ограничение с характеристикой "
"<literal>INITIALLY IMMEDIATE</literal> (подразумеваемой по умолчанию) "
"проверяется после каждого оператора. Ограничение <literal>INITIALLY "
"DEFERRED</literal>, напротив, проверяется только в конце транзакции. Время "
"проверки ограничения можно изменить явно с помощью команды <xref linkend="
"\"sql-set-constraints\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:979(literal)
msgid "WITH ( <placeholder-1/> [= <placeholder-2/>] [, ... ] )"
msgstr "WITH ( <placeholder-1/> [= <placeholder-2/>] [, ... ] )"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:981(para)
msgid ""
"This clause specifies optional storage parameters for a table or index; see "
"<xref linkend=\"sql-createtable-storage-parameters\" endterm=\"sql-"
"createtable-storage-parameters-title\"/> for more information. The "
"<literal>WITH</literal> clause for a table can also include "
"<literal>OIDS=TRUE</literal> (or just <literal>OIDS</literal>) to specify "
"that rows of the new table should have OIDs (object identifiers) assigned to "
"them, or <literal>OIDS=FALSE</literal> to specify that the rows should not "
"have OIDs. If <literal>OIDS</literal> is not specified, the default setting "
"depends upon the <xref linkend=\"guc-default-with-oids\"/> configuration "
"parameter. (If the new table inherits from any tables that have OIDs, then "
"<literal>OIDS=TRUE</literal> is forced even if the command says "
"<literal>OIDS=FALSE</literal>.)"
msgstr ""
"Это предложение определяет необязательные параметры хранения для таблицы или "
"индекса (за подробными сведениями о них обратитесь к <xref remap=\"3\" "
"linkend=\"sql-createtable-storage-parameters\" endterm=\"sql-createtable-"
"storage-parameters-title\"/>). Предложение <literal>WITH</literal> для "
"таблицы может также включать указание <literal>OIDS=TRUE</literal> (или "
"просто <literal>OIDS</literal>), устанавливающее, что каждая строка таблицы "
"должна иметь собственный OID (Object IDentifier, идентификатор объекта), или "
"указание <literal>OIDS=FALSE</literal>, устанавливающее, что строки не "
"содержат OID. Если указание <literal>OIDS</literal> отсутствует, значение "
"этого свойства по умолчанию зависит от конфигурационного параметра <xref "
"linkend=\"guc-default-with-oids\"/>. (Если новая таблица унаследована от "
"каких-либо таблиц, имеющих OID, свойство <literal>OIDS=TRUE</literal> "
"задаётся принудительно, даже если в команде явно написано "
"<literal>OIDS=FALSE</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:997(para)
msgid ""
"If <literal>OIDS=FALSE</literal> is specified or implied, the new table does "
"not store OIDs and no OID will be assigned for a row inserted into it. This "
"is generally considered worthwhile, since it will reduce OID consumption and "
"thereby postpone the wraparound of the 32-bit OID counter. Once the counter "
"wraps around, OIDs can no longer be assumed to be unique, which makes them "
"considerably less useful. In addition, excluding OIDs from a table reduces "
"the space required to store the table on disk by 4 bytes per row (on most "
"machines), slightly improving performance."
msgstr ""
"Если явно указано <literal>OIDS=FALSE</literal> или это подразумевается, в "
"новой таблице не будут храниться значения OID и новый OID не будет "
"генерироваться для каждой добавляемой в неё строки. Для обычных таблиц такое "
"поведение предпочтительнее, так как оно сокращает потребление OID и тем "
"самым откладывает наложение 32-битного счётчика OID. Как только происходит "
"наложение, значения OID больше нельзя считать уникальными, что делает их "
"значительно менее полезными. К тому же, исключение столбца OID из таблицы "
"сокращает объём, необходимый для хранения таблицы на диске, на 4 байта для "
"каждой строки (на большинстве платформ), что несколько улучшает "
"производительность."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1009(para)
msgid ""
"To remove OIDs from a table after it has been created, use <xref linkend="
"\"sql-altertable\"/>."
msgstr ""
"Для удаления данных OID из таблицы после её создания воспользуйтесь командой "
"<xref linkend=\"sql-altertable\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1017(literal)
msgid "WITH OIDS"
msgstr "WITH OIDS"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1018(literal)
msgid "WITHOUT OIDS"
msgstr "WITHOUT OIDS"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1020(para)
msgid ""
"These are obsolescent syntaxes equivalent to <literal>WITH (OIDS)</literal> "
"and <literal>WITH (OIDS=FALSE)</literal>, respectively. If you wish to give "
"both an <literal>OIDS</literal> setting and storage parameters, you must use "
"the <literal>WITH ( ... )</literal> syntax; see above."
msgstr ""
"Это устаревшее написание указаний <literal>WITH (OIDS)</literal> и "
"<literal>WITH (OIDS=FALSE)</literal>, соответственно. Если требуется "
"определить одновременно свойство <literal>OIDS</literal> и параметры "
"хранения, необходимо использовать синтаксис <literal>WITH ( ... )</literal>; "
"см. ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1030(literal)
msgid "ON COMMIT"
msgstr "ON COMMIT"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1039(literal)
msgid "PRESERVE ROWS"
msgstr "PRESERVE ROWS"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1041(para)
msgid ""
"No special action is taken at the ends of transactions. This is the default "
"behavior."
msgstr ""
"Никакое специальное действие в конце транзакции не выполняется. Это "
"поведение по умолчанию."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1049(literal)
msgid "DELETE ROWS"
msgstr "DELETE ROWS"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1051(para)
msgid ""
"All rows in the temporary table will be deleted at the end of each "
"transaction block. Essentially, an automatic <xref linkend=\"sql-truncate\"/"
"> is done at each commit."
msgstr ""
"Все строки в этой временной таблице будут удаляться в конце каждого блока "
"транзакции. По сути, при каждой фиксации транзакции будет автоматически "
"выполняться <xref linkend=\"sql-truncate\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1061(literal)
msgid "DROP"
msgstr "DROP"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1063(para)
msgid ""
"The temporary table will be dropped at the end of the current transaction "
"block."
msgstr ""
"Эта временная таблица будет удаляться в конце текущего блока транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1032(para)
msgid ""
"The behavior of temporary tables at the end of a transaction block can be "
"controlled using <literal>ON COMMIT</literal>. The three options are: "
"<placeholder-1/>"
msgstr ""
"Поведением временных таблиц в конце блока транзакции позволяет управлять "
"предложение <literal>ON COMMIT</literal>, которое принимает три параметра: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1074(literal)
msgid "TABLESPACE <placeholder-1/>"
msgstr "TABLESPACE <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1076(para)
msgid ""
"The <replaceable class=\"parameter\">tablespace_name</replaceable> is the "
"name of the tablespace in which the new table is to be created. If not "
"specified, <xref linkend=\"guc-default-tablespace\"/> is consulted, or <xref "
"linkend=\"guc-temp-tablespaces\"/> if the table is temporary."
msgstr ""
"Здесь <replaceable class=\"parameter\">табл_пространство</replaceable> — имя "
"табличного пространства, в котором будет создаваться новая таблица. Если оно "
"не указано, выбирается <xref linkend=\"guc-default-tablespace\"/> или <xref "
"linkend=\"guc-temp-tablespaces\"/>, если таблица временная."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1087(literal)
msgid "USING INDEX TABLESPACE <placeholder-1/>"
msgstr "USING INDEX TABLESPACE <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1089(para)
msgid ""
"This clause allows selection of the tablespace in which the index associated "
"with a <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, or "
"<literal>EXCLUDE</literal> constraint will be created. If not specified, "
"<xref linkend=\"guc-default-tablespace\"/> is consulted, or <xref linkend="
"\"guc-temp-tablespaces\"/> if the table is temporary."
msgstr ""
"Это предложение позволяет выбрать табличное пространство, в котором будут "
"создаваться индексы, связанные с ограничениями <literal>UNIQUE</literal>, "
"<literal>PRIMARY KEY</literal> или <literal>EXCLUDE</literal>. Если оно не "
"указано, выбирается <xref linkend=\"guc-default-tablespace\"/> или <xref "
"linkend=\"guc-temp-tablespaces\"/>, если таблица временная."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1103(title)
msgid "Storage Parameters"
msgstr "Параметры хранения"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1105(indexterm)
msgid "<primary>storage parameters</primary>"
msgstr "<primary>параметры хранения</primary>"

#. +> REL_10
#: ref/create_table.xml:1109(para)
msgid ""
"The <literal>WITH</literal> clause can specify <firstterm>storage "
"parameters</firstterm> for tables, and for indexes associated with a "
"<literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, or "
"<literal>EXCLUDE</literal> constraint. Storage parameters for indexes are "
"documented in <xref linkend=\"sql-createindex\"/>. The storage parameters "
"currently available for tables are listed below. For many of these "
"parameters, as shown, there is an additional parameter with the same name "
"prefixed with <literal>toast.</literal>, which controls the behavior of the "
"table's secondary <acronym>TOAST</acronym> table, if any (see <xref linkend="
"\"storage-toast\"/> for more information about TOAST). If a table parameter "
"value is set and the equivalent <literal>toast.</literal> parameter is not, "
"the TOAST table will use the table's parameter value. Specifying these "
"parameters for partitioned tables is not supported, but you may specify them "
"for individual leaf partitions."
msgstr ""
"Предложение <literal>WITH</literal> позволяет установить "
"<firstterm>параметры хранения</firstterm> для таблиц и индексов, связанных с "
"ограничениями <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal> и "
"<literal>EXCLUDE</literal>. Параметры хранения для индексов документированы "
"в <xref remap=\"6\" linkend=\"sql-createindex\"/>. Поддерживаемые в "
"настоящее время параметры хранения для таблиц перечислены ниже. Как "
"показано, для многих параметров существует дополнительный параметр с тем же "
"именем и префиксом <literal>toast.</literal>, который управляет поведением "
"вторичной таблицы <acronym>TOAST</acronym>, если она есть (за "
"дополнительными сведениями о TOAST обратитесь к <xref remap=\"3\" linkend="
"\"storage-toast\"/>). Если значение некоторого параметра задано для таблицы, "
"а значение равнозначного параметра <literal>toast.</literal> не определено, "
"для таблицы TOAST будет применяться значение параметра основной таблицы. "
"Возможность задания этих параметров для секционированных таблиц не "
"поддерживается, но вы можете задать их для отдельных конечных секций."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1131(term)
msgid "<literal>fillfactor</literal> (<type>integer</type>)"
msgstr "<literal>fillfactor</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1133(para)
msgid ""
"The fillfactor for a table is a percentage between 10 and 100. 100 (complete "
"packing) is the default. When a smaller fillfactor is specified, "
"<command>INSERT</command> operations pack table pages only to the indicated "
"percentage; the remaining space on each page is reserved for updating rows "
"on that page. This gives <command>UPDATE</command> a chance to place the "
"updated copy of a row on the same page as the original, which is more "
"efficient than placing it on a different page. For a table whose entries are "
"never updated, complete packing is the best choice, but in heavily updated "
"tables smaller fillfactors are appropriate. This parameter cannot be set for "
"TOAST tables."
msgstr ""
"Фактор заполнения для таблицы, задаваемый в процентах, от 10 до 100. "
"Значение по умолчанию — 100 (плотное заполнение). При меньшем факторе "
"заполнения операции <command>INSERT</command> упаковывают данные в страницы "
"только до заданного процента; оставшееся место резервируется для изменения "
"строк на этой странице. В результате <command>UPDATE</command> получает шанс "
"поместить изменённую копию строки в ту же страницу, что и исходную, что "
"гораздо эффективнее, чем размещать её на другой странице. Для таблиц, записи "
"в которых никогда не меняются, лучшим выбором будет плотное заполнение, но "
"для активно изменяемых таблиц лучше выбрать меньший фактор заполнения. Этот "
"параметр нельзя задать для таблиц TOAST."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1149(term)
msgid "<literal>parallel_workers</literal> (<type>integer</type>)"
msgstr "<literal>parallel_workers</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1151(para)
msgid ""
"This sets the number of workers that should be used to assist a parallel "
"scan of this table. If not set, the system will determine a value based on "
"the relation size. The actual number of workers chosen by the planner may be "
"less, for example due to the setting of <xref linkend=\"guc-max-worker-"
"processes\"/>."
msgstr ""
"Данный параметр задаёт число рабочих процессов, которые должны "
"задействоваться при параллельном сканировании таблицы. Если это значение не "
"задано, система будет определять его, исходя из размера отношения. "
"Фактическое число рабочих процессов может быть меньше, например, вследствие "
"ограничения <xref linkend=\"guc-max-worker-processes\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1162(term)
msgid ""
"<literal>autovacuum_enabled</literal>, <literal>toast.autovacuum_enabled</"
"literal> (<type>boolean</type>)"
msgstr ""
"<literal>autovacuum_enabled</literal>, <literal>toast.autovacuum_enabled</"
"literal> (<type>boolean</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1164(para)
msgid ""
"Enables or disables the autovacuum daemon for a particular table. If true, "
"the autovacuum daemon will perform automatic <command>VACUUM</command> and/"
"or <command>ANALYZE</command> operations on this table following the rules "
"discussed in <xref linkend=\"autovacuum\"/>. If false, this table will not "
"be autovacuumed, except to prevent transaction ID wraparound. See <xref "
"linkend=\"vacuum-for-wraparound\"/> for more about wraparound prevention. "
"Note that the autovacuum daemon does not run at all (except to prevent "
"transaction ID wraparound) if the <xref linkend=\"guc-autovacuum\"/> "
"parameter is false; setting individual tables' storage parameters does not "
"override that. Therefore there is seldom much point in explicitly setting "
"this storage parameter to <literal>true</literal>, only to <literal>false</"
"literal>."
msgstr ""
"Включает или отключает демон автоочистки для определённой таблицы. Со "
"значением true демон автоочистки будет автоматически выполнять операции "
"<command>VACUUM</command> и/или <command>ANALYZE</command> в этой таблице, "
"согласно правилам, описанным в <xref remap=\"6\" linkend=\"autovacuum\"/>. "
"Со значением false эта таблица не будет подвергаться автоочистке, если "
"только это не потребуется для предотвращения зацикливания идентификаторов "
"транзакций. Более подробно предотвращение зацикливания описывается в <xref "
"remap=\"6\" linkend=\"vacuum-for-wraparound\"/>. Заметьте, что демон "
"автоочистки не будет запускаться вовсе (если только это не потребуется для "
"предотвращения зацикливания), если параметр <xref linkend=\"guc-autovacuum\"/"
"> имеет значение false; это нельзя переопределить, установив параметры "
"хранения для отдельных таблиц. Таким образом, явно устанавливать для этого "
"параметра значение <literal>true</literal> практически не имеет смысла — "
"полезно только значение <literal>false</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1183(term)
msgid ""
"<literal>autovacuum_vacuum_threshold</literal>, <literal>toast."
"autovacuum_vacuum_threshold</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_vacuum_threshold</literal>, <literal>toast."
"autovacuum_vacuum_threshold</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1185(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-vacuum-threshold\"/> "
"parameter."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-vacuum-threshold\"/> для "
"таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1193(term)
msgid ""
"<literal>autovacuum_vacuum_scale_factor</literal>, <literal>toast."
"autovacuum_vacuum_scale_factor</literal> (<type>float4</type>)"
msgstr ""
"<literal>autovacuum_vacuum_scale_factor</literal>, <literal>toast."
"autovacuum_vacuum_scale_factor</literal> (<type>float4</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1195(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-vacuum-scale-factor\"/> "
"parameter."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-vacuum-scale-factor\"/> "
"для таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1203(term)
msgid "<literal>autovacuum_analyze_threshold</literal> (<type>integer</type>)"
msgstr "<literal>autovacuum_analyze_threshold</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1205(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-analyze-threshold\"/> "
"parameter."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-analyze-threshold\"/> для "
"таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1213(term)
msgid ""
"<literal>autovacuum_analyze_scale_factor</literal> (<type>float4</type>)"
msgstr ""
"<literal>autovacuum_analyze_scale_factor</literal> (<type>float4</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1215(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-analyze-scale-factor\"/> "
"parameter."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-analyze-scale-factor\"/> "
"для таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1223(term)
msgid ""
"<literal>autovacuum_vacuum_cost_delay</literal>, <literal>toast."
"autovacuum_vacuum_cost_delay</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_vacuum_cost_delay</literal>, <literal>toast."
"autovacuum_vacuum_cost_delay</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1225(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-vacuum-cost-delay\"/> "
"parameter."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-vacuum-cost-delay\"/> для "
"таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1233(term)
msgid ""
"<literal>autovacuum_vacuum_cost_limit</literal>, <literal>toast."
"autovacuum_vacuum_cost_limit</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_vacuum_cost_limit</literal>, <literal>toast."
"autovacuum_vacuum_cost_limit</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1235(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-vacuum-cost-limit\"/> "
"parameter."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-vacuum-cost-limit\"/> для "
"таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1243(term)
msgid ""
"<literal>autovacuum_freeze_min_age</literal>, <literal>toast."
"autovacuum_freeze_min_age</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_freeze_min_age</literal>, <literal>toast."
"autovacuum_freeze_min_age</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1245(para)
msgid ""
"Per-table value for <xref linkend=\"guc-vacuum-freeze-min-age\"/> parameter. "
"Note that autovacuum will ignore per-table "
"<literal>autovacuum_freeze_min_age</literal> parameters that are larger than "
"half the system-wide <xref linkend=\"guc-autovacuum-freeze-max-age\"/> "
"setting."
msgstr ""
"Значение параметра <xref linkend=\"guc-vacuum-freeze-min-age\"/> для "
"таблицы. Учтите, что система будет игнорировать установленные для таблиц "
"значения <literal>autovacuum_freeze_min_age</literal>, превышающие половину "
"системного <xref linkend=\"guc-autovacuum-freeze-max-age\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1256(term)
msgid ""
"<literal>autovacuum_freeze_max_age</literal>, <literal>toast."
"autovacuum_freeze_max_age</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_freeze_max_age</literal>, <literal>toast."
"autovacuum_freeze_max_age</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1258(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-freeze-max-age\"/> "
"parameter. Note that autovacuum will ignore per-table "
"<literal>autovacuum_freeze_max_age</literal> parameters that are larger than "
"the system-wide setting (it can only be set smaller)."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-freeze-max-age\"/> для "
"таблицы. Учтите, что система будет игнорировать установленные для таблиц "
"значения <literal>autovacuum_freeze_max_age</literal>, превышающие значение "
"системного параметра (они могут быть только меньше)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1268(term)
msgid ""
"<literal>autovacuum_freeze_table_age</literal>, <literal>toast."
"autovacuum_freeze_table_age</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_freeze_table_age</literal>, <literal>toast."
"autovacuum_freeze_table_age</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1270(para)
msgid ""
"Per-table value for <xref linkend=\"guc-vacuum-freeze-table-age\"/> "
"parameter."
msgstr ""
"Значение параметра <xref linkend=\"guc-vacuum-freeze-table-age\"/> для "
"таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1278(term)
msgid ""
"<literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast."
"autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast."
"autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1280(para)
msgid ""
"Per-table value for <xref linkend=\"guc-vacuum-multixact-freeze-min-age\"/> "
"parameter. Note that autovacuum will ignore per-table "
"<literal>autovacuum_multixact_freeze_min_age</literal> parameters that are "
"larger than half the system-wide <xref linkend=\"guc-autovacuum-multixact-"
"freeze-max-age\"/> setting."
msgstr ""
"Значение параметра <xref linkend=\"guc-vacuum-multixact-freeze-min-age\"/> "
"для таблицы. Учтите, что демон автоочистки будет игнорировать установленные "
"для таблиц значения <literal>autovacuum_multixact_freeze_min_age</literal>, "
"превышающие половину значения системного параметра <xref linkend=\"guc-"
"autovacuum-multixact-freeze-max-age\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1292(term)
msgid ""
"<literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast."
"autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast."
"autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1294(para)
msgid ""
"Per-table value for <xref linkend=\"guc-autovacuum-multixact-freeze-max-age"
"\"/> parameter. Note that autovacuum will ignore per-table "
"<literal>autovacuum_multixact_freeze_max_age</literal> parameters that are "
"larger than the system-wide setting (it can only be set smaller)."
msgstr ""
"Значение параметра <xref linkend=\"guc-autovacuum-multixact-freeze-max-age\"/"
"> для таблицы. Учтите, что система автоочистки будет игнорировать "
"установленные для таблиц параметры "
"<literal>autovacuum_multixact_freeze_max_age</literal>, превышающие "
"системный параметр (они могут быть только меньше)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1306(term)
msgid ""
"<literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast."
"autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)"
msgstr ""
"<literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast."
"autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1308(para)
msgid ""
"Per-table value for <xref linkend=\"guc-vacuum-multixact-freeze-table-age\"/"
"> parameter."
msgstr ""
"Значения параметра <xref linkend=\"guc-vacuum-multixact-freeze-table-age\"/> "
"для таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1316(term)
msgid ""
"<literal>log_autovacuum_min_duration</literal>, <literal>toast."
"log_autovacuum_min_duration</literal> (<type>integer</type>)"
msgstr ""
"<literal>log_autovacuum_min_duration</literal>, <literal>toast."
"log_autovacuum_min_duration</literal> (<type>integer</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1318(para)
msgid ""
"Per-table value for <xref linkend=\"guc-log-autovacuum-min-duration\"/> "
"parameter."
msgstr ""
"Значения параметра <xref linkend=\"guc-log-autovacuum-min-duration\"/> для "
"таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1326(term)
msgid "<literal>user_catalog_table</literal> (<type>boolean</type>)"
msgstr "<literal>user_catalog_table</literal> (<type>boolean</type>)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1328(para)
msgid ""
"Declare the table as an additional catalog table for purposes of logical "
"replication. See <xref linkend=\"logicaldecoding-capabilities\"/> for "
"details. This parameter cannot be set for TOAST tables."
msgstr ""
"Объявляет таблицу как дополнительную таблицу каталога, например для целей "
"логической репликации. За подробностями обратитесь к <xref remap=\"3\" "
"linkend=\"logicaldecoding-capabilities\"/>. Для таблиц TOAST этот параметр "
"задать нельзя."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1343(title)
msgid "Notes"
msgstr "Замечания"

#. +> REL_10
#: ref/create_table.xml:1345(para)
msgid ""
"Using OIDs in new applications is not recommended: where possible, using an "
"identity column or other sequence generator as the table's primary key is "
"preferred. However, if your application does make use of OIDs to identify "
"specific rows of a table, it is recommended to create a unique constraint on "
"the <structfield>oid</structfield> column of that table, to ensure that OIDs "
"in the table will indeed uniquely identify rows even after counter "
"wraparound. Avoid assuming that OIDs are unique across tables; if you need a "
"database-wide unique identifier, use the combination of "
"<structfield>tableoid</structfield> and row OID for the purpose."
msgstr ""
"Применять OID в новых приложениях не рекомендуется: по возможности лучше "
"использовать в качестве первичного ключа таблицы столбец идентификации или "
"другой генератор последовательности. Однако, если в вашем приложении для "
"идентификации строк применяется OID, рекомендуется создать уникальное "
"ограничение по столбцу <structfield>oid</structfield> в этой таблице, чтобы "
"значения OID в этой таблице на самом деле однозначно идентифицировали строки "
"даже после зацикливания счётчика. Также не стоит полагать, что значения OID "
"уникальны в разных таблицах; если вам требуется идентификатор, уникальный в "
"базе данных, воспользуйтесь для этого комбинацией <structfield>tableoid</"
"structfield> и OID строки."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1360(para)
msgid ""
"The use of <literal>OIDS=FALSE</literal> is not recommended for tables with "
"no primary key, since without either an OID or a unique data key, it is "
"difficult to identify specific rows."
msgstr ""
"Применять <literal>OIDS=FALSE</literal> не рекомендуется для таблиц без "
"первичного ключа, так как без OID или уникального ключа данных сложно "
"идентифицировать определённые строки."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1367(para)
msgid ""
"<productname>PostgreSQL</productname> automatically creates an index for "
"each unique constraint and primary key constraint to enforce uniqueness. "
"Thus, it is not necessary to create an index explicitly for primary key "
"columns. (See <xref linkend=\"sql-createindex\"/> for more information.)"
msgstr ""
"<productname>PostgreSQL</productname> автоматически создаёт индекс, "
"гарантирующий уникальность, для каждого ограничения уникальности и "
"ограничения первичного ключа. Поэтому явно создавать индекс для столбцов "
"первичного ключа не требуется. (За дополнительными сведениями обратитесь к "
"<xref remap=\"3\" linkend=\"sql-createindex\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1375(para)
msgid ""
"Unique constraints and primary keys are not inherited in the current "
"implementation. This makes the combination of inheritance and unique "
"constraints rather dysfunctional."
msgstr ""
"Ограничения уникальности и первичные ключи в текущей реализации не "
"наследуются. Вследствие этого ограничения уникальности довольно плохо "
"сочетаются с наследованием."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1381(para)
msgid ""
"A table cannot have more than 1600 columns. (In practice, the effective "
"limit is usually lower because of tuple-length constraints.)"
msgstr ""
"В таблице не может быть больше 1600 столбцов. (На практике фактический "
"предел обычно ниже из-за ограничения на длину записи.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1390(title)
msgid "Examples"
msgstr "Примеры"

#. +> REL_10
#: ref/create_table.xml:1396(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE films (\n"
"    code        char(5) CONSTRAINT firstkey PRIMARY KEY,\n"
"    title       varchar(40) NOT NULL,\n"
"    did         integer NOT NULL,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute\n"
");\n"
"\n"
"CREATE TABLE distributors (\n"
"     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n"
"     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')\n"
");"
msgstr ""
"CREATE TABLE films (\n"
"    code        char(5) CONSTRAINT firstkey PRIMARY KEY,\n"
"    title       varchar(40) NOT NULL,\n"
"    did         integer NOT NULL,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute\n"
");\n"
"\n"
"CREATE TABLE distributors (\n"
"     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n"
"     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1392(para)
msgid ""
"Create table <structname>films</structname> and table "
"<structname>distributors</structname>: <placeholder-1/>"
msgstr ""
"Создание таблицы <structname>films</structname> и таблицы "
"<structname>distributors</structname>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1416(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE array_int (\n"
"    vector  int[][]\n"
");"
msgstr ""
"CREATE TABLE array_int (\n"
"    vector  int[][]\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1413(para)
msgid "Create a table with a 2-dimensional array: <placeholder-1/>"
msgstr "Создание таблицы с двумерным массивом: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1428(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE films (\n"
"    code        char(5),\n"
"    title       varchar(40),\n"
"    did         integer,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute,\n"
"    CONSTRAINT production UNIQUE(date_prod)\n"
");"
msgstr ""
"CREATE TABLE films (\n"
"    code        char(5),\n"
"    title       varchar(40),\n"
"    did         integer,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute,\n"
"    CONSTRAINT production UNIQUE(date_prod)\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1423(para)
msgid ""
"Define a unique table constraint for the table <literal>films</literal>. "
"Unique table constraints can be defined on one or more columns of the table: "
"<placeholder-1/>"
msgstr ""
"Определение ограничения уникальности для таблицы <literal>films</literal>. "
"Ограничения уникальности могут быть определены для одного или нескольких "
"столбцов таблицы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1444(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    did     integer CHECK (did &gt; 100),\n"
"    name    varchar(40)\n"
");"
msgstr ""
"CREATE TABLE distributors (\n"
"    did     integer CHECK (did &gt; 100),\n"
"    name    varchar(40)\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1441(para)
msgid "Define a check column constraint: <placeholder-1/>"
msgstr "Определение ограничения-проверки для столбца: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1455(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40)\n"
"    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')\n"
");"
msgstr ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40)\n"
"    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1452(para)
msgid "Define a check table constraint: <placeholder-1/>"
msgstr "Определение ограничения-проверки для таблицы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1468(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE films (\n"
"    code        char(5),\n"
"    title       varchar(40),\n"
"    did         integer,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute,\n"
"    CONSTRAINT code_title PRIMARY KEY(code,title)\n"
");"
msgstr ""
"CREATE TABLE films (\n"
"    code        char(5),\n"
"    title       varchar(40),\n"
"    did         integer,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute,\n"
"    CONSTRAINT code_title PRIMARY KEY(code,title)\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1464(para)
msgid ""
"Define a primary key table constraint for the table <structname>films</"
"structname>: <placeholder-1/>"
msgstr ""
"Определение ограничения первичного ключа для таблицы <structname>films</"
"structname>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1487(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40),\n"
"    PRIMARY KEY(did)\n"
");\n"
"\n"
"CREATE TABLE distributors (\n"
"    did     integer PRIMARY KEY,\n"
"    name    varchar(40)\n"
");"
msgstr ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40),\n"
"    PRIMARY KEY(did)\n"
");\n"
"\n"
"CREATE TABLE distributors (\n"
"    did     integer PRIMARY KEY,\n"
"    name    varchar(40)\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1481(para)
msgid ""
"Define a primary key constraint for table <structname>distributors</"
"structname>. The following two examples are equivalent, the first using the "
"table constraint syntax, the second the column constraint syntax: "
"<placeholder-1/>"
msgstr ""
"Определение ограничения первичного ключа для таблицы "
"<structname>distributors</structname>. Следующие два примера равнозначны, но "
"в первом используется синтаксис ограничений для таблицы, а во втором — для "
"столбца: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1509(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    name      varchar(40) DEFAULT 'Luso Films',\n"
"    did       integer DEFAULT nextval('distributors_serial'),\n"
"    modtime   timestamp DEFAULT current_timestamp\n"
");"
msgstr ""
"CREATE TABLE distributors (\n"
"    name      varchar(40) DEFAULT 'Luso Films',\n"
"    did       integer DEFAULT nextval('distributors_serial'),\n"
"    modtime   timestamp DEFAULT current_timestamp\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1501(para)
msgid ""
"Assign a literal constant default value for the column <literal>name</"
"literal>, arrange for the default value of column <literal>did</literal> to "
"be generated by selecting the next value of a sequence object, and make the "
"default value of <literal>modtime</literal> be the time at which the row is "
"inserted: <placeholder-1/>"
msgstr ""
"Определение значений по умолчанию: для столбца <literal>name</literal> "
"значением по умолчанию будет строка, для столбца <literal>did</literal> — "
"следующее значение объекта последовательности, а для <literal>modtime</"
"literal> — время, когда была вставлена запись: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1523(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    did     integer CONSTRAINT no_null NOT NULL,\n"
"    name    varchar(40) NOT NULL\n"
");"
msgstr ""
"CREATE TABLE distributors (\n"
"    did     integer CONSTRAINT no_null NOT NULL,\n"
"    name    varchar(40) NOT NULL\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1518(para)
msgid ""
"Define two <literal>NOT NULL</literal> column constraints on the table "
"<classname>distributors</classname>, one of which is explicitly given a "
"name: <placeholder-1/>"
msgstr ""
"Определение двух ограничений <literal>NOT NULL</literal> для столбцов "
"таблицы <classname>distributors</classname>, при этом одному ограничению "
"даётся явное имя: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1534(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40) UNIQUE\n"
");"
msgstr ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40) UNIQUE\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1543(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40),\n"
"    UNIQUE(name)\n"
");"
msgstr ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40),\n"
"    UNIQUE(name)\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1531(para)
msgid ""
"Define a unique constraint for the <literal>name</literal> column: "
"<placeholder-1/> The same, specified as a table constraint: <placeholder-2/>"
msgstr ""
"Определение ограничения уникальности для столбца <literal>name</literal>: "
"<placeholder-1/> То же самое условие, но в виде ограничения таблицы: "
"<placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1556(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40),\n"
"    UNIQUE(name) WITH (fillfactor=70)\n"
")\n"
"WITH (fillfactor=70);"
msgstr ""
"CREATE TABLE distributors (\n"
"    did     integer,\n"
"    name    varchar(40),\n"
"    UNIQUE(name) WITH (fillfactor=70)\n"
")\n"
"WITH (fillfactor=70);"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1552(para)
msgid ""
"Create the same table, specifying 70% fill factor for both the table and its "
"unique index: <placeholder-1/>"
msgstr ""
"Создание такой же таблицы с фактором заполнения 70% для таблицы и её "
"уникального индекса: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1570(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE circles (\n"
"    c circle,\n"
"    EXCLUDE USING gist (c WITH &amp;&amp;)\n"
");"
msgstr ""
"CREATE TABLE circles (\n"
"    c circle,\n"
"    EXCLUDE USING gist (c WITH &amp;&amp;)\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1566(para)
msgid ""
"Create table <structname>circles</structname> with an exclusion constraint "
"that prevents any two circles from overlapping: <placeholder-1/>"
msgstr ""
"Создание таблицы <structname>circles</structname> с ограничением-"
"исключением, не допускающим пересечения двух кругов: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1581(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cinemas (\n"
"        id serial,\n"
"        name text,\n"
"        location text\n"
") TABLESPACE diskvol1;"
msgstr ""
"CREATE TABLE cinemas (\n"
"        id serial,\n"
"        name text,\n"
"        location text\n"
") TABLESPACE diskvol1;"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1578(para)
msgid ""
"Create table <structname>cinemas</structname> in tablespace "
"<structname>diskvol1</structname>: <placeholder-1/>"
msgstr ""
"Создание таблицы <structname>cinemas</structname> в табличном пространстве "
"<structname>diskvol1</structname>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1592(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE employee_type AS (name text, salary numeric);\n"
"\n"
"CREATE TABLE employees OF employee_type (\n"
"    PRIMARY KEY (name),\n"
"    salary WITH OPTIONS DEFAULT 1000\n"
");"
msgstr ""
"CREATE TYPE employee_type AS (name text, salary numeric);\n"
"\n"
"CREATE TABLE employees OF employee_type (\n"
"    PRIMARY KEY (name),\n"
"    salary WITH OPTIONS DEFAULT 1000\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1590(para)
msgid "Create a composite type and a typed table: <placeholder-1/>"
msgstr "Создание составного типа и типизированной таблицы: <placeholder-1/>"

#. +> REL_10
#: ref/create_table.xml:1603(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement (\n"
"    logdate         date not null,\n"
"    peaktemp        int,\n"
"    unitsales       int\n"
") PARTITION BY RANGE (logdate);"
msgstr ""
"CREATE TABLE measurement (\n"
"    logdate         date not null,\n"
"    peaktemp        int,\n"
"    unitsales       int\n"
") PARTITION BY RANGE (logdate);"

#. +> REL_10
#: ref/create_table.xml:1601(para)
msgid "Create a range partitioned table: <placeholder-1/>"
msgstr "Создание таблицы, секционируемой по диапазонам: <placeholder-1/>"

#. +> REL_10
#: ref/create_table.xml:1613(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement_year_month (\n"
"    logdate         date not null,\n"
"    peaktemp        int,\n"
"    unitsales       int\n"
") PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));"
msgstr ""
"CREATE TABLE measurement_year_month (\n"
"    logdate         date not null,\n"
"    peaktemp        int,\n"
"    unitsales       int\n"
") PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));"

#. +> REL_10
#: ref/create_table.xml:1611(para)
msgid ""
"Create a range partitioned table with multiple columns in the partition key: "
"<placeholder-1/>"
msgstr ""
"Создание таблицы, секционируемой по диапазонам, с ключом разбиения, "
"включающим несколько столбцов: <placeholder-1/>"

#. +> REL_10
#: ref/create_table.xml:1623(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cities (\n"
"    city_id      bigserial not null,\n"
"    name         text not null,\n"
"    population   bigint\n"
") PARTITION BY LIST (left(lower(name), 1));"
msgstr ""
"CREATE TABLE cities (\n"
"    city_id      bigserial not null,\n"
"    name         text not null,\n"
"    population   bigint\n"
") PARTITION BY LIST (left(lower(name), 1));"

#. +> REL_10
#: ref/create_table.xml:1621(para)
msgid "Create a list partitioned table: <placeholder-1/>"
msgstr "Создание таблицы, секционируемой по спискам: <placeholder-1/>"

#. +> REL_10
#: ref/create_table.xml:1633(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement_y2016m07\n"
"    PARTITION OF measurement (\n"
"    unitsales DEFAULT 0\n"
") FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');"
msgstr ""
"CREATE TABLE measurement_y2016m07\n"
"    PARTITION OF measurement (\n"
"    unitsales DEFAULT 0\n"
") FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');"

#. +> REL_10
#: ref/create_table.xml:1631(para)
msgid "Create partition of a range partitioned table: <placeholder-1/>"
msgstr ""
"Создание секции таблицы, секционируемой по диапазонам: <placeholder-1/>"

#. +> REL_10
#: ref/create_table.xml:1643(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement_ym_older\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);\n"
"\n"
"CREATE TABLE measurement_ym_y2016m11\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (2016, 11) TO (2016, 12);\n"
"\n"
"CREATE TABLE measurement_ym_y2016m12\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (2016, 12) TO (2017, 01);\n"
"\n"
"CREATE TABLE measurement_ym_y2017m01\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (2017, 01) TO (2017, 02);"
msgstr ""
"CREATE TABLE measurement_ym_older\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);\n"
"\n"
"CREATE TABLE measurement_ym_y2016m11\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (2016, 11) TO (2016, 12);\n"
"\n"
"CREATE TABLE measurement_ym_y2016m12\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (2016, 12) TO (2017, 01);\n"
"\n"
"CREATE TABLE measurement_ym_y2017m01\n"
"    PARTITION OF measurement_year_month\n"
"    FOR VALUES FROM (2017, 01) TO (2017, 02);"

#. +> REL_10
#: ref/create_table.xml:1640(para)
msgid ""
"Create a few partitions of a range partitioned table with multiple columns "
"in the partition key: <placeholder-1/>"
msgstr ""
"Создание нескольких секций для таблицы, секционируемой по диапазонам, с "
"ключом разбиения, включающим несколько столбцов: <placeholder-1/>"

#. +> REL_10
#: ref/create_table.xml:1663(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cities_ab\n"
"    PARTITION OF cities (\n"
"    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n"
") FOR VALUES IN ('a', 'b');"
msgstr ""
"CREATE TABLE cities_ab\n"
"    PARTITION OF cities (\n"
"    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n"
") FOR VALUES IN ('a', 'b');"

#. +> REL_10
#: ref/create_table.xml:1661(para)
msgid "Create partition of a list partitioned table: <placeholder-1/>"
msgstr "Создание секции таблицы, секционируемой по спискам: <placeholder-1/>"

#. +> REL_10
#: ref/create_table.xml:1673(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cities_ab\n"
"    PARTITION OF cities (\n"
"    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n"
") FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);\n"
"\n"
"CREATE TABLE cities_ab_10000_to_100000\n"
"    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);"
msgstr ""
"CREATE TABLE cities_ab\n"
"    PARTITION OF cities (\n"
"    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n"
") FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);\n"
"\n"
"CREATE TABLE cities_ab_10000_to_100000\n"
"    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);"

#. +> REL_10
#: ref/create_table.xml:1670(para)
msgid ""
"Create partition of a list partitioned table that is itself further "
"partitioned and then add a partition to it: <placeholder-1/>"
msgstr ""
"Создание секции таблицы, секционируемой по спискам (при этом сама секция "
"также создаётся секционируемой), и добавление секции в неё: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1685(title)
msgid "Compatibility"
msgstr "Совместимость"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1687(para)
msgid ""
"The <command>CREATE TABLE</command> command conforms to the <acronym>SQL</"
"acronym> standard, with exceptions listed below."
msgstr ""
"Команда <command>CREATE TABLE</command> соответствует стандарту "
"<acronym>SQL</acronym>, с описанными ниже исключениями."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1693(title)
msgid "Temporary Tables"
msgstr "Временные таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1695(para)
msgid ""
"Although the syntax of <literal>CREATE TEMPORARY TABLE</literal> resembles "
"that of the SQL standard, the effect is not the same. In the standard, "
"temporary tables are defined just once and automatically exist (starting "
"with empty contents) in every session that needs them. "
"<productname>PostgreSQL</productname> instead requires each session to issue "
"its own <literal>CREATE TEMPORARY TABLE</literal> command for each temporary "
"table to be used. This allows different sessions to use the same temporary "
"table name for different purposes, whereas the standard's approach "
"constrains all instances of a given temporary table name to have the same "
"table structure."
msgstr ""
"Хотя синтаксис <literal>CREATE TEMPORARY TABLE</literal> подобен "
"аналогичному в стандарте SQL, результат получается другим. В стандарте "
"временные таблицы определяются только один раз и существуют (изначально "
"пустые) в каждом сеансе, в котором они используются. "
"<productname>PostgreSQL</productname> вместо этого требует, чтобы каждый "
"сеанс выполнял собственную команду <literal>CREATE TEMPORARY TABLE</literal> "
"для каждой временной таблицы, которая будет использоваться. Это позволяет "
"использовать в разных сеансах таблицы с одинаковыми именами для разных "
"целей, тогда как при подходе, регламентированном стандартом, все экземпляры "
"временной таблицы с одним именем должны иметь одинаковую табличную структуру."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1709(para)
msgid ""
"The standard's definition of the behavior of temporary tables is widely "
"ignored. <productname>PostgreSQL</productname>'s behavior on this point is "
"similar to that of several other SQL databases."
msgstr ""
"Поведение временных таблиц, описанное в стандарте, в большинстве своём "
"игнорируют и другие СУБД, так что в этом отношении <productname>PostgreSQL</"
"productname> ведёт себя так же, как и ряд других СУБД."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1715(para)
msgid ""
"The SQL standard also distinguishes between global and local temporary "
"tables, where a local temporary table has a separate set of contents for "
"each SQL module within each session, though its definition is still shared "
"across sessions. Since <productname>PostgreSQL</productname> does not "
"support SQL modules, this distinction is not relevant in "
"<productname>PostgreSQL</productname>."
msgstr ""
"В стандарте SQL также разделяются глобальные и локальные временные таблицы — "
"в локальной временной таблице содержится отдельный набор данных для каждого "
"модуля SQL в отдельном сеансе, хотя её определение так же разделяется между "
"ними. Так как в <productname>PostgreSQL</productname> модули SQL не "
"поддерживаются, это различие в <productname>PostgreSQL</productname> не "
"существует."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1724(para)
msgid ""
"For compatibility's sake, <productname>PostgreSQL</productname> will accept "
"the <literal>GLOBAL</literal> and <literal>LOCAL</literal> keywords in a "
"temporary table declaration, but they currently have no effect. Use of these "
"keywords is discouraged, since future versions of <productname>PostgreSQL</"
"productname> might adopt a more standard-compliant interpretation of their "
"meaning."
msgstr ""
"Совместимости ради, <productname>PostgreSQL</productname> принимает ключевые "
"слова <literal>GLOBAL</literal> и <literal>LOCAL</literal> в объявлении "
"временной таблицы, но в настоящее время они никак не действуют. Использовать "
"их не рекомендуется, так как в будущих версиях <productname>PostgreSQL</"
"productname> может быть принята их интерпретация, более близкая к стандарту."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1733(para)
msgid ""
"The <literal>ON COMMIT</literal> clause for temporary tables also resembles "
"the SQL standard, but has some differences. If the <literal>ON COMMIT</"
"literal> clause is omitted, SQL specifies that the default behavior is "
"<literal>ON COMMIT DELETE ROWS</literal>. However, the default behavior in "
"<productname>PostgreSQL</productname> is <literal>ON COMMIT PRESERVE ROWS</"
"literal>. The <literal>ON COMMIT DROP</literal> option does not exist in SQL."
msgstr ""
"Предложение <literal>ON COMMIT</literal> для временных таблиц тоже подобно "
"описанному в стандарте SQL, но есть некоторые отличия. Если предложение "
"<literal>ON COMMIT</literal> опущено, в SQL подразумевается поведение "
"<literal>ON COMMIT DELETE ROWS</literal>. Однако в <productname>PostgreSQL</"
"productname> по умолчанию действует <literal>ON COMMIT PRESERVE ROWS</"
"literal>. Параметр <literal>ON COMMIT DROP</literal> в стандарте SQL "
"отсутствует."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1745(title)
msgid "Non-deferred Uniqueness Constraints"
msgstr "Неотложенные ограничения уникальности"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1747(para)
msgid ""
"When a <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> "
"constraint is not deferrable, <productname>PostgreSQL</productname> checks "
"for uniqueness immediately whenever a row is inserted or modified. The SQL "
"standard says that uniqueness should be enforced only at the end of the "
"statement; this makes a difference when, for example, a single command "
"updates multiple key values. To obtain standard-compliant behavior, declare "
"the constraint as <literal>DEFERRABLE</literal> but not deferred (i.e., "
"<literal>INITIALLY IMMEDIATE</literal>). Be aware that this can be "
"significantly slower than immediate uniqueness checking."
msgstr ""
"Когда ограничение <literal>UNIQUE</literal> или <literal>PRIMARY KEY</"
"literal> не является отложенным, <productname>PostgreSQL</productname> "
"проверяет уникальность непосредственно в момент добавления или изменения "
"строки. Стандарт SQL говорит, что уникальность должна обеспечиваться только "
"в конце оператора; это различие проявляется, например когда одна команда "
"изменяет множество ключевых значений. Чтобы получить поведение, оговоренное "
"стандартом, объявите ограничение как откладываемое (<literal>DEFERRABLE</"
"literal>), но не отложенное (т. е., <literal>INITIALLY IMMEDIATE</literal>). "
"Учтите, что этот вариант может быть значительно медленнее, чем немедленная "
"проверка ограничений."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1762(title)
msgid "Column Check Constraints"
msgstr "Ограничения-проверки для столбцов"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1764(para)
msgid ""
"The SQL standard says that <literal>CHECK</literal> column constraints can "
"only refer to the column they apply to; only <literal>CHECK</literal> table "
"constraints can refer to multiple columns. <productname>PostgreSQL</"
"productname> does not enforce this restriction; it treats column and table "
"check constraints alike."
msgstr ""
"Стандарт SQL говорит, что ограничение <literal>CHECK</literal>, определяемое "
"для столбца, может ссылаться только на столбец, с которым оно связано; "
"только ограничения <literal>CHECK</literal> для таблиц могут ссылаться на "
"несколько столбцов. В <productname>PostgreSQL</productname> этого "
"ограничения нет; он воспринимает ограничения-проверки для столбцов и таблиц "
"одинаково."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1774(title)
msgid "<literal>EXCLUDE</literal> Constraint"
msgstr "Ограничение <literal>EXCLUDE</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1776(para)
msgid ""
"The <literal>EXCLUDE</literal> constraint type is a <productname>PostgreSQL</"
"productname> extension."
msgstr ""
"Ограничения <literal>EXCLUDE</literal> являются расширением "
"<productname>PostgreSQL</productname>."

# #-#-#-#-#  -  #-#-#-#-#
# refragment
#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1783(quote)
msgid "Constraint"
msgstr "Ограничение"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1785(para)
msgid ""
"The <literal>NULL</literal> <quote>constraint</quote> (actually a non-"
"constraint) is a <productname>PostgreSQL</productname> extension to the SQL "
"standard that is included for compatibility with some other database systems "
"(and for symmetry with the <literal>NOT NULL</literal> constraint). Since it "
"is the default for any column, its presence is simply noise."
msgstr ""
"<quote>Ограничение</quote> <literal>NULL</literal> (на самом деле это не "
"ограничение) является расширением <productname>PostgreSQL</productname> "
"стандарта SQL, которое реализовано для совместимости с некоторыми другими "
"СУБД (и для симметрии с ограничением <literal>NOT NULL</literal>). Так как "
"это поведение по умолчанию для любого столбца, его присутствие не несёт "
"смысловой нагрузки."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1796(title)
msgid "Inheritance"
msgstr "Наследование"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1798(para)
msgid ""
"Multiple inheritance via the <literal>INHERITS</literal> clause is a "
"<productname>PostgreSQL</productname> language extension. SQL:1999 and later "
"define single inheritance using a different syntax and different semantics. "
"SQL:1999-style inheritance is not yet supported by <productname>PostgreSQL</"
"productname>."
msgstr ""
"Множественное наследование посредством <literal>INHERITS</literal> является "
"языковым расширением <productname>PostgreSQL</productname>. SQL:1999 и более "
"поздние стандарты определяют единичное наследование с другим синтаксисом и "
"смыслом. Наследование в стиле SQL:1999 пока ещё не поддерживается в "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1809(title)
msgid "Zero-column Tables"
msgstr "Таблицы с нулём столбцов"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1811(para)
msgid ""
"<productname>PostgreSQL</productname> allows a table of no columns to be "
"created (for example, <literal>CREATE TABLE foo();</literal>). This is an "
"extension from the SQL standard, which does not allow zero-column tables. "
"Zero-column tables are not in themselves very useful, but disallowing them "
"creates odd special cases for <command>ALTER TABLE DROP COLUMN</command>, so "
"it seems cleaner to ignore this spec restriction."
msgstr ""
"<productname>PostgreSQL</productname> позволяет создать таблицу без столбцов "
"(например, <literal>CREATE TABLE foo();</literal>). Это расширение стандарта "
"SQL, который не допускает таблицы с нулём столбцов. Таблицы с нулём столбцов "
"сами по себе не очень полезны, но если их запретить, возникают странные "
"особые ситуации с командой <command>ALTER TABLE DROP COLUMN</command>, так "
"что лучшим вариантом кажется игнорировать это требование стандарта."

#. +> REL_10
#: ref/create_table.xml:1822(title)
msgid "Multiple Identity Columns"
msgstr "Множество столбцов идентификации"

#. +> REL_10
#: ref/create_table.xml:1824(para)
msgid ""
"<productname>PostgreSQL</productname> allows a table to have more than one "
"identity column. The standard specifies that a table can have at most one "
"identity column. This is relaxed mainly to give more flexibility for doing "
"schema changes or migrations. Note that the <command>INSERT</command> "
"command supports only one override clause that applies to the entire "
"statement, so having multiple identity columns with different behaviors is "
"not well supported."
msgstr ""
"<productname>PostgreSQL</productname> позволяет иметь в таблице более одного "
"столбца идентификации. В стандарте же говорится, что в таблице может быть "
"максимум один столбец идентификации. Это ограничение ослаблено в основном "
"для большей гибкости при выполнении изменений в схеме или миграции. "
"Заметьте, что команда <command>INSERT</command> поддерживает только одно "
"предложение переопределения значения, применяемое ко всему оператору, так "
"что с несколькими столбцами идентификации различное поведение не "
"поддерживается должным образом."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1836(title)
msgid "<literal>LIKE</literal> Clause"
msgstr "Предложение <literal>LIKE</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1838(para)
msgid ""
"While a <literal>LIKE</literal> clause exists in the SQL standard, many of "
"the options that <productname>PostgreSQL</productname> accepts for it are "
"not in the standard, and some of the standard's options are not implemented "
"by <productname>PostgreSQL</productname>."
msgstr ""
"Хотя предложение <literal>LIKE</literal> описано в стандарте SQL, многие "
"варианты его использования, допустимые в <productname>PostgreSQL</"
"productname>, в стандарте не описаны, а некоторые предусмотренные в "
"стандарте возможности не реализованы в <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1847(title)
msgid "<literal>WITH</literal> Clause"
msgstr "Предложение <literal>WITH</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1849(para)
msgid ""
"The <literal>WITH</literal> clause is a <productname>PostgreSQL</"
"productname> extension; neither storage parameters nor OIDs are in the "
"standard."
msgstr ""
"Предложение <literal>WITH</literal> является расширением "
"<productname>PostgreSQL</productname>; в стандарте ни параметры хранения, ни "
"OID не оговариваются."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1856(title)
msgid "Tablespaces"
msgstr "Табличные пространства"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1858(para)
msgid ""
"The <productname>PostgreSQL</productname> concept of tablespaces is not part "
"of the standard. Hence, the clauses <literal>TABLESPACE</literal> and "
"<literal>USING INDEX TABLESPACE</literal> are extensions."
msgstr ""
"Концепция табличных пространств в <productname>PostgreSQL</productname> "
"отсутствует в стандарте. Как следствие, предложения <literal>TABLESPACE</"
"literal> и <literal>USING INDEX TABLESPACE</literal> являются расширениями."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1866(title)
msgid "Typed Tables"
msgstr "Типизированные таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1868(para)
msgid ""
"Typed tables implement a subset of the SQL standard. According to the "
"standard, a typed table has columns corresponding to the underlying "
"composite type as well as one other column that is the <quote>self-"
"referencing column</quote>. PostgreSQL does not support these self-"
"referencing columns explicitly, but the same effect can be had using the OID "
"feature."
msgstr ""
"Типизированные таблицы реализуют подмножество стандарта SQL. Согласно "
"стандарту, типизированная таблица содержит столбцы, соответствующие "
"нижележащему составному типу, и ещё один столбец, ссылающийся на себя. "
"PostgreSQL не поддерживает ссылающиеся на себя столбцы явно, но тот же "
"эффект можно получить, воспользовавшись OID."

#. +> REL_10
#: ref/create_table.xml:1879(title)
msgid "<literal>PARTITION BY</literal> Clause"
msgstr "Предложение <literal>PARTITION BY</literal>"

#. +> REL_10
#: ref/create_table.xml:1881(para)
msgid ""
"The <literal>PARTITION BY</literal> clause is a <productname>PostgreSQL</"
"productname> extension."
msgstr ""
"Предложение <literal>PARTITION BY</literal> является расширением "
"<productname>PostgreSQL</productname>."

#. +> REL_10
#: ref/create_table.xml:1888(title)
msgid "<literal>PARTITION OF</literal> Clause"
msgstr "Предложение <literal>PARTITION OF</literal>"

#. +> REL_10
#: ref/create_table.xml:1890(para)
msgid ""
"The <literal>PARTITION OF</literal> clause is a <productname>PostgreSQL</"
"productname> extension."
msgstr ""
"Предложение <literal>PARTITION OF</literal> является расширением "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:1900(title)
msgid "See Also"
msgstr "См. также"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_table.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: ref/create_table.xml:371(para)
msgid ""
"<literal>INCLUDING ALL</literal> is an abbreviated form of "
"<literal>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES "
"INCLUDING STORAGE INCLUDING COMMENTS</literal>."
msgstr ""
"Предложение <literal>INCLUDING ALL</literal> является сокращённой формой "
"развёрнутого предложения <literal>INCLUDING DEFAULTS INCLUDING CONSTRAINTS "
"INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</literal>."

#. +> REL9_6_3 REL9_6
#: ref/create_table.xml:603(para)
msgid ""
"These clauses specify a foreign key constraint, which requires that a group "
"of one or more columns of the new table must only contain values that match "
"values in the referenced column(s) of some row of the referenced table. If "
"the <replaceable class=\"parameter\">refcolumn</replaceable> list is "
"omitted, the primary key of the <replaceable class=\"parameter\">reftable</"
"replaceable> is used. The referenced columns must be the columns of a non-"
"deferrable unique or primary key constraint in the referenced table. Note "
"that foreign key constraints cannot be defined between temporary tables and "
"permanent tables."
msgstr ""
"Эти предложения определяют ограничение внешнего ключа, требующее, чтобы "
"указанная группа из одного или нескольких столбцов новой таблицы содержала "
"только такие значения, которым соответствуют значения в заданных внешних "
"столбцах некоторой строки во внешней таблице. Если список <replaceable class="
"\"parameter\">внешних_столбцов</replaceable> опущен, в качестве него "
"используется первичный ключ <replaceable class=\"parameter"
"\">внешней_таблицы</replaceable>. В качестве внешних столбцов должны "
"указываться столбцы неоткладываемого уникального ограничения или ограничение "
"первичного ключа во внешней таблице. Заметьте, что ограничения внешнего "
"ключа, связывающие временные и постоянные таблицы, определить нельзя."

#. +> REL9_6_3 REL9_6
#: ref/create_table.xml:884(para)
msgid ""
"The <literal>WITH</literal> clause can specify <firstterm>storage "
"parameters</firstterm> for tables, and for indexes associated with a "
"<literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, or "
"<literal>EXCLUDE</literal> constraint. Storage parameters for indexes are "
"documented in <xref linkend=\"sql-createindex\"/>. The storage parameters "
"currently available for tables are listed below. For many of these "
"parameters, as shown, there is an additional parameter with the same name "
"prefixed with <literal>toast.</literal>, which controls the behavior of the "
"table's secondary <acronym>TOAST</acronym> table, if any (see <xref linkend="
"\"storage-toast\"/> for more information about TOAST). If a table parameter "
"value is set and the equivalent <literal>toast.</literal> parameter is not, "
"the TOAST table will use the table's parameter value."
msgstr ""
"Предложение <literal>WITH</literal> позволяет установить "
"<firstterm>параметры хранения</firstterm> для таблиц и индексов, связанных с "
"ограничениями <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal> и "
"<literal>EXCLUDE</literal>. Параметры хранения для индексов документированы "
"в <xref remap=\"6\" linkend=\"sql-createindex\"/>. Поддерживаемые в "
"настоящее время параметры хранения для таблиц перечислены ниже. Как "
"показано, для каждого параметра существует дополнительный параметр с тем же "
"именем и префиксом <literal>toast.</literal>, который управляет поведением "
"вторичной таблицы <acronym>TOAST</acronym>, если она есть (за "
"дополнительными сведениями о TOAST обратитесь к <xref remap=\"3\" linkend="
"\"storage-toast\"/>). Если значение некоторого параметра задано для таблицы, "
"а значение равнозначного параметра <literal>toast.</literal> не определено, "
"для таблицы TOAST будет применяться значение параметра основной таблицы."

#. +> REL9_6_3 REL9_6
#: ref/create_table.xml:1118(para)
msgid ""
"Using OIDs in new applications is not recommended: where possible, using a "
"<literal>SERIAL</literal> or other sequence generator as the table's primary "
"key is preferred. However, if your application does make use of OIDs to "
"identify specific rows of a table, it is recommended to create a unique "
"constraint on the <structfield>oid</structfield> column of that table, to "
"ensure that OIDs in the table will indeed uniquely identify rows even after "
"counter wraparound. Avoid assuming that OIDs are unique across tables; if "
"you need a database-wide unique identifier, use the combination of "
"<structfield>tableoid</structfield> and row OID for the purpose."
msgstr ""
"Применять OID в новых приложениях не рекомендуется: по возможности лучше "
"использовать в качестве первичного ключа таблицы <literal>SERIAL</literal> "
"или другой генератор последовательности. Однако, если в вашем приложении для "
"идентификации строк применяется OID, рекомендуется создать уникальное "
"ограничение по столбцу <structfield>oid</structfield> в этой таблице, чтобы "
"значения OID в этой таблице на самом деле однозначно идентифицировали строки "
"даже после зацикливания счётчика. Также не стоит полагать, что значения OID "
"уникальны в разных таблицах; если вам требуется идентификатор, уникальный в "
"базе данных, воспользуйтесь для этого комбинацией <structfield>tableoid</"
"structfield> и OID строки."

#. +> REL9_6_3 REL9_6
#: ref/create_table.xml:1169(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE films (\n"
"    code        char(5) CONSTRAINT firstkey PRIMARY KEY,\n"
"    title       varchar(40) NOT NULL,\n"
"    did         integer NOT NULL,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute\n"
");\n"
"\n"
"CREATE TABLE distributors (\n"
"     did    integer PRIMARY KEY DEFAULT nextval('serial'),\n"
"     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')\n"
");"
msgstr ""
"CREATE TABLE films (\n"
"    code        char(5) CONSTRAINT firstkey PRIMARY KEY,\n"
"    title       varchar(40) NOT NULL,\n"
"    did         integer NOT NULL,\n"
"    date_prod   date,\n"
"    kind        varchar(10),\n"
"    len         interval hour to minute\n"
");\n"
"\n"
"CREATE TABLE distributors (\n"
"     did    integer PRIMARY KEY DEFAULT nextval('serial'),\n"
"     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')\n"
");"

#~ msgid ""
#~ "Writing <literal>UNBOUNDED</literal> in <literal>FROM</literal> signifies "
#~ "<literal>-infinity</literal> as the lower bound of the corresponding "
#~ "column, whereas when written in <literal>TO</literal>, it signifies "
#~ "<literal>+infinity</literal> as the upper bound. All items following an "
#~ "<literal>UNBOUNDED</literal> item within a <literal>FROM</literal> or "
#~ "<literal>TO</literal> list must also be <literal>UNBOUNDED</literal>."
#~ msgstr ""
#~ "Указание <literal>UNBOUNDED</literal> во <literal>FROM</literal> "
#~ "воспринимается как <literal>-infinity</literal> (минус бесконечность) в "
#~ "нижней границе соответствующего столбца, а в <literal>TO</literal> как "
#~ "<literal>+infinity</literal> (плюс бесконечность) в верхней границе. За "
#~ "<literal>UNBOUNDED</literal> в списке <literal>FROM</literal> или "
#~ "<literal>TO</literal> могут следовать также только элементы "
#~ "<literal>UNBOUNDED</literal>."

#~ msgid ""
#~ "When using range partitioning, a <literal>NOT NULL</literal> constraint "
#~ "is added to each non-expression column in the partition key."
#~ msgstr ""
#~ "Когда применяется диапазонное разбиение, для каждого столбца (не "
#~ "выражения) в ключе разбиения добавляется ограничение <literal>NOT NULL</"
#~ "literal>."

#~ msgid ""
#~ "Default expressions for the copied column definitions will only be copied "
#~ "if <literal>INCLUDING DEFAULTS</literal> is specified. Defaults that call "
#~ "database-modification functions, like <function>nextval</function>, "
#~ "create a linkage between the original and new tables. The default "
#~ "behavior is to exclude default expressions, resulting in the copied "
#~ "columns in the new table having null defaults."
#~ msgstr ""
#~ "Выражения значений по умолчанию в определениях копируемых столбцов "
#~ "переносятся в новую таблицу, если дополнительно указано "
#~ "<literal>INCLUDING DEFAULTS</literal>. Если такие выражения вызывают "
#~ "функции, модифицирующие БД, как например, <function>nextval</function>, "
#~ "при этом создаётся связь исходной таблицы с новой. Без явного указания "
#~ "такие выражения не переносятся, вследствие чего в новой таблице "
#~ "скопированные столбцы получают значения по умолчанию NULL."
