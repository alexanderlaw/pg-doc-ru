# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-10-02 10:32+0300\n"
"PO-Revision-Date: 2017-10-03 12:20+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:8(indexterm)
msgid "<primary>CREATE POLICY</primary>"
msgstr "<primary>CREATE POLICY</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:13(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE POLICY"
msgstr "CREATE POLICY"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:14(manvolnum)
msgid "7"
msgstr "7"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:15(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:19(refname)
msgctxt "refname"
msgid "CREATE POLICY"
msgstr "CREATE POLICY"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:20(refpurpose)
msgid "define a new row level security policy for a table"
msgstr "создать новую политику защиты на уровне строк для таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:25(replaceable) ref/create_policy.xml:102(replaceable)
msgid "name"
msgstr "имя"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:25(replaceable) ref/create_policy.xml:112(replaceable)
msgid "table_name"
msgstr "имя_таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:28(replaceable) ref/create_policy.xml:173(replaceable)
msgid "role_name"
msgstr "имя_роли"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:29(replaceable) ref/create_policy.xml:183(replaceable)
msgid "using_expression"
msgstr "выражение_USING"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:30(replaceable) ref/create_policy.xml:201(replaceable)
msgid "check_expression"
msgstr "выражение_CHECK"

#. +> REL_10
#: ref/create_policy.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE POLICY <placeholder-1/> ON <placeholder-2/>\n"
"    [ AS { PERMISSIVE | RESTRICTIVE } ]\n"
"    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n"
"    [ TO { <placeholder-3/> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n"
"    [ USING ( <placeholder-4/> ) ]\n"
"    [ WITH CHECK ( <placeholder-5/> ) ]"
msgstr ""
"CREATE POLICY <placeholder-1/> ON <placeholder-2/>\n"
"    [ AS { PERMISSIVE | RESTRICTIVE } ]\n"
"    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n"
"    [ TO { <placeholder-3/> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n"
"    [ USING ( <placeholder-4/> ) ]\n"
"    [ WITH CHECK ( <placeholder-5/> ) ]"

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE POLICY <placeholder-1/> ON <placeholder-2/>\n"
"    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n"
"    [ TO { <placeholder-3/> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n"
"    [ USING ( <placeholder-4/> ) ]\n"
"    [ WITH CHECK ( <placeholder-5/> ) ]"
msgstr ""
"CREATE POLICY <placeholder-1/> ON <placeholder-2/>\n"
"    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n"
"    [ TO { <placeholder-3/> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n"
"    [ USING ( <placeholder-4/> ) ]\n"
"    [ WITH CHECK ( <placeholder-5/> ) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:35(title)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:37(para)
msgid ""
"The <command>CREATE POLICY</command> command defines a new row-level "
"security policy for a table. Note that row-level security must be enabled on "
"the table (using <command>ALTER TABLE ... ENABLE ROW LEVEL SECURITY</"
"command>) in order for created policies to be applied."
msgstr ""
"Команда <command>CREATE POLICY</command> определяет для таблицы новую "
"политику защиты на уровне строк. Заметьте, что для таблицы должна быть "
"включена защита на уровне строк (using <command>ALTER TABLE ... ENABLE ROW "
"LEVEL SECURITY</command>), чтобы созданные политики действовали."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:44(para)
msgid ""
"A policy grants the permission to select, insert, update, or delete rows "
"that match the relevant policy expression. Existing table rows are checked "
"against the expression specified in <literal>USING</literal>, while new rows "
"that would be created via <literal>INSERT</literal> or <literal>UPDATE</"
"literal> are checked against the expression specified in <literal>WITH "
"CHECK</literal>. When a <literal>USING</literal> expression returns true for "
"a given row then that row is visible to the user, while if false or null is "
"returned then the row is not visible. When a <literal>WITH CHECK</literal> "
"expression returns true for a row then that row is inserted or updated, "
"while if false or null is returned then an error occurs."
msgstr ""
"Политика даёт разрешение на выборку, добавление, изменение или удаление "
"строк, удовлетворяющих соответствующему выражению политики. Существующие "
"строки таблицы проверяются по выражению, указанному в <literal>USING</"
"literal>, тогда как строки, которые могут быть созданы командами "
"<literal>INSERT</literal> или <literal>UPDATE</literal> проверяются по "
"выражению, указанному в <literal>WITH CHECK</literal>. Когда выражение "
"<literal>USING</literal> истинно для заданной строки, эта строка видна "
"пользователю, а если ложно или выдаёт NULL, строка не видна. Когда выражение "
"<literal>WITH CHECK</literal> истинно для заданной строки, эта строка "
"добавляется или изменяется, а если ложно или выдаёт NULL, происходит ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:58(para)
msgid ""
"For <command>INSERT</command> and <command>UPDATE</command> statements, "
"<literal>WITH CHECK</literal> expressions are enforced after "
"<literal>BEFORE</literal> triggers are fired, and before any actual data "
"modifications are made. Thus a <literal>BEFORE ROW</literal> trigger may "
"modify the data to be inserted, affecting the result of the security policy "
"check. <literal>WITH CHECK</literal> expressions are enforced before any "
"other constraints."
msgstr ""
"Для операторов <command>INSERT</command> и <command>UPDATE</command> "
"выражения <literal>WITH CHECK</literal> применяются после срабатывания "
"триггеров <literal>BEFORE</literal>, но до того, как будут собственно "
"модифицированы данные. Таким образом, триггер <literal>BEFORE ROW</literal> "
"может изменить данные, подлежащие добавлению, и повлиять на результат "
"условия политики защиты. Выражения <literal>WITH CHECK</literal> "
"обрабатываются до каких-либо других ограничений."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:68(para)
msgid ""
"Policy names are per-table. Therefore, one policy name can be used for many "
"different tables and have a definition for each table which is appropriate "
"to that table."
msgstr ""
"Имена политик задаются на уровне таблицы. Таким образом, одно имя политики "
"можно использовать в нескольких разных таблицах и в каждой дать отдельное, "
"подходящее этой таблице определение политики."

#. +> REL_10
#: ref/create_policy.xml:74(para)
msgid ""
"Policies can be applied for specific commands or for specific roles. The "
"default for newly created policies is that they apply for all commands and "
"roles, unless otherwise specified."
msgstr ""
"Политики могут применяться для определённых команд или для определённых "
"ролей. По умолчанию создаваемые политики применяются для всех команд и "
"ролей, если явно не задано другое."

#. +> REL_10
#: ref/create_policy.xml:80(para)
msgid ""
"For policies that can have both <literal>USING</literal> and <literal>WITH "
"CHECK</literal> expressions (<literal>ALL</literal> and <literal>UPDATE</"
"literal>), if no <literal>WITH CHECK</literal> expression is defined, then "
"the <literal>USING</literal> expression will be used both to determine which "
"rows are visible (normal <literal>USING</literal> case) and which new rows "
"will be allowed to be added (<literal>WITH CHECK</literal> case)."
msgstr ""
"Для политик, которые могут иметь и выражения <literal>USING</literal>, и "
"выражения <literal>WITH CHECK</literal> (<literal>ALL</literal> и "
"<literal>UPDATE</literal>), в случае отсутствия выражения <literal>WITH "
"CHECK</literal> выражение <literal>USING</literal> будет использоваться и "
"для определения видимости строк (обычное назначение <literal>USING</"
"literal>) и для определения, какие строки разрешено добавить (назначение "
"<literal>WITH CHECK</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:90(para)
msgid ""
"If row-level security is enabled for a table, but no applicable policies "
"exist, a <quote>default deny</quote> policy is assumed, so that no rows will "
"be visible or updatable."
msgstr ""
"Если для таблицы включена защита на уровне строк, но применимые политики "
"отсутствуют, предполагается политика <quote>запрета по умолчанию</quote>, "
"так что никакие строки нельзя будет увидеть или изменить."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:98(title)
msgid "Parameters"
msgstr "Параметры"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:104(para)
msgid ""
"The name of the policy to be created. This must be distinct from the name of "
"any other policy for the table."
msgstr ""
"Имя создаваемой политики. Оно должно отличаться от имён других политик для "
"этой таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:114(para)
msgid ""
"The name (optionally schema-qualified) of the table the policy applies to."
msgstr ""
"Имя (возможно, дополненное схемой) существующей таблицы (или представления), "
"к которой применяется эта политика."

#. +> REL_10
#: ref/create_policy.xml:122(literal)
msgid "PERMISSIVE"
msgstr "PERMISSIVE"

#. +> REL_10
#: ref/create_policy.xml:124(para)
msgid ""
"Specify that the policy is to be created as a permissive policy. All "
"permissive policies which are applicable to a given query will be combined "
"together using the Boolean <quote>OR</quote> operator. By creating "
"permissive policies, administrators can add to the set of records which can "
"be accessed. Policies are permissive by default."
msgstr ""
"Указывает, что создаваемая политика должна быть разрешительной. Все "
"разрешительные политики, которые применяются к данному запросу, будут "
"объединяться вместе логическим оператором <quote>ИЛИ</quote>. Создавая "
"разрешительные политики, администраторы могут расширять множество записей, к "
"которым можно обращаться. Политики являются разрешительными по умолчанию."

#. +> REL_10
#: ref/create_policy.xml:135(literal)
msgid "RESTRICTIVE"
msgstr "RESTRICTIVE"

#. +> REL_10
#: ref/create_policy.xml:137(para)
msgid ""
"Specify that the policy is to be created as a restrictive policy. All "
"restrictive policies which are applicable to a given query will be combined "
"together using the Boolean <quote>AND</quote> operator. By creating "
"restrictive policies, administrators can reduce the set of records which can "
"be accessed as all restrictive policies must be passed for each record."
msgstr ""
"Указывает, что создаваемая политика должна быть ограничительной. Все "
"ограничительные политики, которые применяются к данному запросу, будут "
"объединяться вместе логическим оператором <quote>И</quote>. Создавая "
"ограничительные политики, администраторы могут сократить множество записей, "
"к которым можно обращаться, так как для каждой записи должны удовлетворяться "
"все ограничительные политики."

#. +> REL_10
#: ref/create_policy.xml:146(para)
msgid ""
"Note that there needs to be at least one permissive policy to grant access "
"to records before restrictive policies can be usefully used to reduce that "
"access. If only restrictive policies exist, then no records will be "
"accessible. When a mix of permissive and restrictive policies are present, a "
"record is only accessible if at least one of the permissive policies passes, "
"in addition to all the restrictive policies."
msgstr ""
"Заметьте, что для получения доступа к записям должна быть определена минимум "
"одна разрешительная политика, и только в дополнение к ней могут быть "
"определены имеющие смысл ограничительные политики, ограничивающие доступ. "
"Если разрешительные политики отсутствуют, ни к каким записям обращаться "
"нельзя. Когда определены и разрешительные, и ограничительные политики, "
"запись будет доступна, если удовлетворяется минимум одна из разрешительных "
"политик и все ограничительные."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:159(replaceable)
msgid "command"
msgstr "команда"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:161(para)
msgid ""
"The command to which the policy applies. Valid options are <command>ALL</"
"command>, <command>SELECT</command>, <command>INSERT</command>, "
"<command>UPDATE</command>, and <command>DELETE</command>. <command>ALL</"
"command> is the default. See below for specifics regarding how these are "
"applied."
msgstr ""
"Команда, к которой применяется политика. Допустимые варианты: <command>ALL</"
"command>, <command>SELECT</command>, <command>INSERT</command>, "
"<command>UPDATE</command> и <command>DELETE</command>. <command>ALL</"
"command> (все) подразумевается по умолчанию. Особенности их применения "
"описаны ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:175(para)
msgid ""
"The role(s) to which the policy is to be applied. The default is "
"<literal>PUBLIC</literal>, which will apply the policy to all roles."
msgstr ""
"Роль (роли), к которой применяется политика. По умолчанию подразумевается "
"<literal>PUBLIC</literal>, то есть политика применяется ко всем ролям."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:185(para)
msgid ""
"Any <acronym>SQL</acronym> conditional expression (returning <type>boolean</"
"type>). The conditional expression cannot contain any aggregate or window "
"functions. This expression will be added to queries that refer to the table "
"if row level security is enabled. Rows for which the expression returns true "
"will be visible. Any rows for which the expression returns false or null "
"will not be visible to the user (in a <command>SELECT</command>), and will "
"not be available for modification (in an <command>UPDATE</command> or "
"<command>DELETE</command>). Such rows are silently suppressed; no error is "
"reported."
msgstr ""
"Произвольное условное выражение <acronym>SQL</acronym> (возвращающее "
"<type>boolean</type>). Это условное выражение не может содержать агрегатные "
"или оконные функции. Когда включена защита на уровне строк, оно добавляется "
"в запросы, обращающиеся к данной таблице, и в их результатах оказываются "
"видимыми только те строки, для которых оно выдаёт true. Все строки, для "
"которых это выражение возвращает false или NULL, не будут видны пользователю "
"(в запросе <command>SELECT</command>), и не будут доступны для модификации "
"(запросами <command>UPDATE</command> или <command>DELETE</command>). Такая "
"строка просто пропускается, ошибка при этом не выдаётся."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:203(para)
msgid ""
"Any <acronym>SQL</acronym> conditional expression (returning <type>boolean</"
"type>). The conditional expression cannot contain any aggregate or window "
"functions. This expression will be used in <command>INSERT</command> and "
"<command>UPDATE</command> queries against the table if row level security is "
"enabled. Only rows for which the expression evaluates to true will be "
"allowed. An error will be thrown if the expression evaluates to false or "
"null for any of the records inserted or any of the records that result from "
"the update. Note that the <replaceable class=\"parameter\">check_expression</"
"replaceable> is evaluated against the proposed new contents of the row, not "
"the original contents."
msgstr ""
"Произвольное условное выражение <acronym>SQL</acronym> (возвращающее "
"<type>boolean</type>). Это условное выражение не может содержать агрегатные "
"или оконные функции. Когда включена защита на уровне строк, оно применяется "
"в запросах <command>INSERT</command> и <command>UPDATE</command> к этой "
"таблице, так что в них принимаются только те строки, для которых оно выдаёт "
"true. Если это выражение выдаёт false или NULL для любой из добавляемых "
"записей или записей, получаемых при изменении, выдаётся ошибка. Заметьте, "
"что <replaceable class=\"parameter\">ограничение_проверки</replaceable> "
"вычисляется для предлагаемого нового содержимого строки, а не для "
"существующих данных."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:222(title)
msgid "Per-Command Policies"
msgstr "Политики по командам"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:227(literal)
msgid "ALL"
msgstr "ALL"

#. +> REL_10
#: ref/create_policy.xml:229(para)
msgid ""
"Using <literal>ALL</literal> for a policy means that it will apply to all "
"commands, regardless of the type of command. If an <literal>ALL</literal> "
"policy exists and more specific policies exist, then both the <literal>ALL</"
"literal> policy and the more specific policy (or policies) will be applied. "
"Additionally, <literal>ALL</literal> policies will be applied to both the "
"selection side of a query and the modification side, using the "
"<literal>USING</literal> expression for both cases if only a <literal>USING</"
"literal> expression has been defined."
msgstr ""
"Указание <literal>ALL</literal> для политики означает, что она применяется "
"ко всем командам, вне зависимости от типа. Если существует политика "
"<literal>ALL</literal> и другие более детализированные политики, тогда будет "
"применяться и политика <literal>ALL</literal>, и более детализированная "
"политика (или политики). Кроме того, политики <literal>ALL</literal> с "
"выражением <literal>USING</literal> будут применяться и к стороне выборки, и "
"к стороне изменения данных в запросе, если определено только выражение "
"<literal>USING</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:240(para)
msgid ""
"As an example, if an <literal>UPDATE</literal> is issued, then the "
"<literal>ALL</literal> policy will be applicable both to what the "
"<literal>UPDATE</literal> will be able to select as rows to be updated "
"(applying the <literal>USING</literal> expression), and to the resulting "
"updated rows, to check if they are permitted to be added to the table "
"(applying the <literal>WITH CHECK</literal> expression, if defined, and the "
"<literal>USING</literal> expression otherwise). If an <command>INSERT</"
"command> or <command>UPDATE</command> command attempts to add rows to the "
"table that do not pass the <literal>ALL</literal> policy's <literal>WITH "
"CHECK</literal> expression, the entire command will be aborted."
msgstr ""
"Например, когда выполняется <literal>UPDATE</literal>, политика "
"<literal>ALL</literal> будет фильтровать и строки, которые сможет прочитать "
"<literal>UPDATE</literal> для изменения (применяя выражение <literal>USING</"
"literal>), и окончательные изменённые строки, проверяя, можно ли записать их "
"в таблицу (применяя выражение <literal>WITH CHECK</literal>, если оно "
"определено, или <literal>USING</literal> в противном случае). Если команда "
"<command>INSERT</command> или <command>UPDATE</command> пытается добавить в "
"таблицу строки, не удовлетворяющие выражению <literal>WITH CHECK</literal> "
"политики <literal>ALL</literal>, вся команда будет прервана."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:258(literal)
msgid "SELECT"
msgstr "SELECT"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:260(para)
msgid ""
"Using <literal>SELECT</literal> for a policy means that it will apply to "
"<literal>SELECT</literal> queries and whenever <literal>SELECT</literal> "
"permissions are required on the relation the policy is defined for. The "
"result is that only those records from the relation that pass the "
"<literal>SELECT</literal> policy will be returned during a <literal>SELECT</"
"literal> query, and that queries that require <literal>SELECT</literal> "
"permissions, such as <literal>UPDATE</literal>, will also only see those "
"records that are allowed by the <literal>SELECT</literal> policy. A "
"<literal>SELECT</literal> policy cannot have a <literal>WITH CHECK</literal> "
"expression, as it only applies in cases where records are being retrieved "
"from the relation."
msgstr ""
"Указание <literal>SELECT</literal> для политики означает, что она "
"применяется к запросам <literal>SELECT</literal> и тогда, когда при "
"обращении к отношению, для которого определена политика, задействуется право "
"<literal>SELECT</literal>. В результате запрос <literal>SELECT</literal> "
"выдаст только те записи из отношения, которые удовлетворят политике "
"<literal>SELECT</literal>, и запрос, использующий право <literal>SELECT</"
"literal>, например, запрос <literal>UPDATE</literal>, увидит только записи, "
"разрешённые политикой <literal>SELECT</literal>. Для политики "
"<literal>SELECT</literal> не может задаваться выражение <literal>WITH CHECK</"
"literal>, так как оно действует только когда записи читаются из отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:278(literal)
msgid "INSERT"
msgstr "INSERT"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:280(para)
msgid ""
"Using <literal>INSERT</literal> for a policy means that it will apply to "
"<literal>INSERT</literal> commands. Rows being inserted that do not pass "
"this policy will result in a policy violation error, and the entire "
"<literal>INSERT</literal> command will be aborted. An <literal>INSERT</"
"literal> policy cannot have a <literal>USING</literal> expression, as it "
"only applies in cases where records are being added to the relation."
msgstr ""
"Указание <literal>INSERT</literal> для политики означает, что она "
"применяется к командам <literal>INSERT</literal>. Если вставляемые строки не "
"проходят проверку политики, выдаётся ошибка нарушения политики и вся команда "
"<literal>INSERT</literal> прерывается. Для политики <literal>INSERT</"
"literal> не может задаваться выражение <literal>USING</literal>, так как она "
"действует только когда в отношение добавляются записи."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:289(para)
msgid ""
"Note that <literal>INSERT</literal> with <literal>ON CONFLICT DO UPDATE</"
"literal> checks <literal>INSERT</literal> policies' <literal>WITH CHECK</"
"literal> expressions only for rows appended to the relation by the "
"<literal>INSERT</literal> path."
msgstr ""
"Заметьте, что <literal>INSERT</literal> с указанием <literal>ON CONFLICT DO "
"UPDATE</literal> проверяет выражения <literal>WITH CHECK</literal> политик "
"<literal>INSERT</literal> только для строк, добавляемых в отношение по пути "
"<literal>INSERT</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:299(literal)
msgid "UPDATE"
msgstr "UPDATE"

#. +> REL_10
#: ref/create_policy.xml:301(para)
msgid ""
"Using <literal>UPDATE</literal> for a policy means that it will apply to "
"<literal>UPDATE</literal>, <literal>SELECT FOR UPDATE</literal> and "
"<literal>SELECT FOR SHARE</literal> commands, as well as auxiliary "
"<literal>ON CONFLICT DO UPDATE</literal> clauses of <literal>INSERT</"
"literal> commands. Since <literal>UPDATE</literal> involves pulling an "
"existing record and replacing it with a new modified record, "
"<literal>UPDATE</literal> policies accept both a <literal>USING</literal> "
"expression and a <literal>WITH CHECK</literal> expression. The "
"<literal>USING</literal> expression determines which records the "
"<literal>UPDATE</literal> command will see to operate against, while the "
"<literal>WITH CHECK</literal> expression defines which modified rows are "
"allowed to be stored back into the relation."
msgstr ""
"Выбор типа <literal>UPDATE</literal> для политики означает, что она будет "
"применяться к командам <literal>UPDATE</literal>, <literal>SELECT FOR "
"UPDATE</literal> и <literal>SELECT FOR SHARE</literal>, а также к "
"дополнительным предложениям <literal>ON CONFLICT DO UPDATE</literal> команд "
"<literal>INSERT</literal>. Так как <literal>UPDATE</literal> подразумевает "
"извлечение существующей записи и замену её новой изменённой записью, "
"политики <literal>UPDATE</literal> принимают как выражение <literal>USING</"
"literal>, так и <literal>WITH CHECK</literal>. Выражение <literal>USING</"
"literal> определяет, какие записи команда <literal>UPDATE</literal> сможет "
"увидеть для последующего изменения, а выражение <literal>WITH CHECK</"
"literal> — какие изменённые строки сохранить в отношении."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:317(para)
msgid ""
"Any rows whose updated values do not pass the <literal>WITH CHECK</literal> "
"expression will cause an error, and the entire command will be aborted. If "
"only a <literal>USING</literal> clause is specified, then that clause will "
"be used for both <literal>USING</literal> and <literal>WITH CHECK</literal> "
"cases."
msgstr ""
"Если в какой-либо строке изменённые значения не будут удовлетворять "
"выражению <literal>WITH CHECK</literal>, произойдёт ошибка и вся команда "
"будет прервана. Если указывается только предложение <literal>USING</"
"literal>, его выражение будет применяться и в качестве <literal>USING</"
"literal>, и в качестве выражения <literal>WITH CHECK</literal>."

#. +> REL_10
#: ref/create_policy.xml:325(para)
msgid ""
"Typically an <literal>UPDATE</literal> command also needs to read data from "
"columns in the relation being updated (e.g., in a <literal>WHERE</literal> "
"clause or a <literal>RETURNING</literal> clause, or in an expression on the "
"right hand side of the <literal>SET</literal> clause). In this case, "
"<literal>SELECT</literal> rights are also required on the relation being "
"updated, and the appropriate <literal>SELECT</literal> or <literal>ALL</"
"literal> policies will be applied in addition to the <literal>UPDATE</"
"literal> policies. Thus the user must have access to the row(s) being "
"updated through a <literal>SELECT</literal> or <literal>ALL</literal> policy "
"in addition to being granted permission to update the row(s) via an "
"<literal>UPDATE</literal> or <literal>ALL</literal> policy."
msgstr ""
"Обычно команде <literal>UPDATE</literal> также нужно прочитать данные из "
"столбцов подлежащего изменению отношения (например, в предложении "
"<literal>WHERE</literal> или <literal>RETURNING</literal> либо в выражении в "
"правой части предложения <literal>SET</literal>). В этом случае также "
"требуется иметь права <literal>SELECT</literal> в изменяемом отношении и в "
"дополнение к политикам <literal>UPDATE</literal> будут применяться "
"соответствующие политики <literal>SELECT</literal> или <literal>ALL</"
"literal>. Таким образом, помимо того, что пользователю должны разрешать "
"изменение строк политики <literal>UPDATE</literal> или <literal>ALL</"
"literal>, ему также должны разрешать доступ к изменяемым строкам политики "
"<literal>SELECT</literal> или <literal>ALL</literal>."

#. +> REL_10
#: ref/create_policy.xml:341(para)
msgid ""
"When an <literal>INSERT</literal> command has an auxiliary <literal>ON "
"CONFLICT DO UPDATE</literal> clause, if the <literal>UPDATE</literal> path "
"is taken, the row to be updated is first checked against the <literal>USING</"
"literal> expressions of any <literal>UPDATE</literal> policies, and then the "
"new updated row is checked against the <literal>WITH CHECK</literal> "
"expressions. Note, however, that unlike a standalone <literal>UPDATE</"
"literal> command, if the existing row does not pass the <literal>USING</"
"literal> expressions, an error will be thrown (the <literal>UPDATE</literal> "
"path will <emphasis>never</emphasis> be silently avoided)."
msgstr ""
"Когда для команды <literal>INSERT</literal> задано вспомогательное "
"предложение <literal>ON CONFLICT DO UPDATE</literal>, если выбирается путь "
"<literal>UPDATE</literal>, строка, подлежащая изменению, сначала проверяется "
"по выражениям <literal>USING</literal> всех политик <literal>UPDATE</"
"literal>, а затем изменённая строка ещё раз проверяется по выражениям "
"<literal>WITH CHECK</literal>. Заметьте, однако, что в отличие от отдельной "
"команды <literal>UPDATE</literal>, если существующая строка не удовлетворяет "
"выражениям <literal>USING</literal>, будет выдана ошибка (путь "
"<literal>UPDATE</literal> <emphasis>никогда</emphasis> не пропускается "
"неявно)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:358(literal)
msgid "DELETE"
msgstr "DELETE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:360(para)
msgid ""
"Using <literal>DELETE</literal> for a policy means that it will apply to "
"<literal>DELETE</literal> commands. Only rows that pass this policy will be "
"seen by a <literal>DELETE</literal> command. There can be rows that are "
"visible through a <literal>SELECT</literal> that are not available for "
"deletion, if they do not pass the <literal>USING</literal> expression for "
"the <literal>DELETE</literal> policy."
msgstr ""
"Указание <literal>DELETE</literal> для политики означает, что она "
"применяется к командам <literal>DELETE</literal>. Команда <literal>DELETE</"
"literal> будет видеть только те строки, которые позволит эта политика. При "
"этом строки могут быть видны через <literal>SELECT</literal>, но удалить их "
"будет нельзя, если они не удовлетворяют выражению <literal>USING</literal> "
"политики <literal>DELETE</literal>."

#. +> REL_10
#: ref/create_policy.xml:370(para)
msgid ""
"In most cases a <literal>DELETE</literal> command also needs to read data "
"from columns in the relation that it is deleting from (e.g., in a "
"<literal>WHERE</literal> clause or a <literal>RETURNING</literal> clause). "
"In this case, <literal>SELECT</literal> rights are also required on the "
"relation, and the appropriate <literal>SELECT</literal> or <literal>ALL</"
"literal> policies will be applied in addition to the <literal>DELETE</"
"literal> policies. Thus the user must have access to the row(s) being "
"deleted through a <literal>SELECT</literal> or <literal>ALL</literal> policy "
"in addition to being granted permission to delete the row(s) via a "
"<literal>DELETE</literal> or <literal>ALL</literal> policy."
msgstr ""
"В большинстве случаев команде <literal>DELETE</literal> также нужно "
"прочитать данные из столбцов в отношении, из которого осуществляется "
"удаление (например, в предложении <literal>WHERE</literal> или "
"<literal>RETURNING</literal>). В таких случаях необходимо также иметь право "
"<literal>SELECT</literal> для этого отношения, и в дополнение к политикам "
"<literal>DELETE</literal> будут применятся соответствующие политики "
"<literal>SELECT</literal> или <literal>ALL</literal>. Таким образом, "
"пользователь должен получить доступ к удаляемым строкам через политики "
"<literal>SELECT</literal> или <literal>ALL</literal>, помимо того что "
"удаление этих строк ему должны разрешить политики <literal>DELETE</literal> "
"или <literal>ALL</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:385(para)
msgid ""
"A <literal>DELETE</literal> policy cannot have a <literal>WITH CHECK</"
"literal> expression, as it only applies in cases where records are being "
"deleted from the relation, so that there is no new row to check."
msgstr ""
"Для политики <literal>DELETE</literal> не может задаваться выражение "
"<literal>WITH CHECK</literal>, так как она применяется только тогда, когда "
"записи удаляются из отношения, а в этом случае новые строки, подлежащие "
"проверке, отсутствуют."

#. +> REL_10
#: ref/create_policy.xml:398(title)
msgid "Application of Multiple Policies"
msgstr "Применение нескольких политик"

#. +> REL_10
#: ref/create_policy.xml:400(para)
msgid ""
"When multiple policies of different command types apply to the same command "
"(for example, <literal>SELECT</literal> and <literal>UPDATE</literal> "
"policies applied to an <literal>UPDATE</literal> command), then the user "
"must have both types of permissions (for example, permission to select rows "
"from the relation as well as permission to update them). Thus the "
"expressions for one type of policy are combined with the expressions for the "
"other type of policy using the <literal>AND</literal> operator."
msgstr ""
"Когда к одной команде применяются несколько политик для различных типов "
"команд (как например, политики <literal>SELECT</literal> и <literal>UPDATE</"
"literal> применяются к команде <literal>UPDATE</literal>), пользователь "
"должен иметь разрешения всех этих типов (например, разрешение для выборки "
"строк из отношения, а также разрешение на их изменение). Таким образом, "
"выражения для одного типа политики комбинируются с выражениями для другого "
"типа операцией <literal>И</literal>."

#. +> REL_10
#: ref/create_policy.xml:410(para)
msgid ""
"When multiple policies of the same command type apply to the same command, "
"then there must be at least one <literal>PERMISSIVE</literal> policy "
"granting access to the relation, and all of the <literal>RESTRICTIVE</"
"literal> policies must pass. Thus all the <literal>PERMISSIVE</literal> "
"policy expressions are combined using <literal>OR</literal>, all the "
"<literal>RESTRICTIVE</literal> policy expressions are combined using "
"<literal>AND</literal>, and the results are combined using <literal>AND</"
"literal>. If there are no <literal>PERMISSIVE</literal> policies, then "
"access is denied."
msgstr ""
"Когда к одной команде применяются несколько политик для одного типа команды, "
"доступ к отношению должна дать как минимум одна разрешительная "
"(<literal>PERMISSIVE</literal>) политика, а также должны удовлетворяться все "
"ограничительные (<literal>RESTRICTIVE</literal>) политики. Таким образом "
"выражения всех политик <literal>PERMISSIVE</literal> объединяются операцией "
"<literal>ИЛИ</literal>, выражения всех политик <literal>RESTRICTIVE</"
"literal> объединяются операцией <literal>И</literal>, а полученные "
"результаты объединяются операцией <literal>И</literal>. Если политики "
"<literal>PERMISSIVE</literal> отсутствуют, доступ запрещается."

#. +> REL_10
#: ref/create_policy.xml:422(para)
msgid ""
"Note that, for the purposes of combining multiple policies, <literal>ALL</"
"literal> policies are treated as having the same type as whichever other "
"type of policy is being applied."
msgstr ""
"Заметьте, что при объединении нескольких политик, политики <literal>ALL</"
"literal> применяются как политики каждого применимого в данном случае типа."

#. +> REL_10
#: ref/create_policy.xml:434(programlisting)
#, no-wrap
msgid ""
"<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 1\n"
"AND\n"
"<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 2\n"
"AND\n"
"...\n"
"AND\n"
"(\n"
"  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 1\n"
"  OR\n"
"  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 2\n"
"  OR\n"
"  ...\n"
")\n"
"AND\n"
"<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 1\n"
"AND\n"
"<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 2\n"
"AND\n"
"...\n"
"AND\n"
"(\n"
"  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 1\n"
"  OR\n"
"  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 2\n"
"  OR\n"
"  ...\n"
")"
msgstr ""
"<replaceable>выражение</replaceable> from RESTRICTIVE SELECT/ALL policy 1\n"
"AND\n"
"<replaceable>выражение</replaceable> from RESTRICTIVE SELECT/ALL policy 2\n"
"AND\n"
"...\n"
"AND\n"
"(\n"
"  <replaceable>выражение</replaceable> from PERMISSIVE SELECT/ALL policy 1\n"
"  OR\n"
"  <replaceable>выражение</replaceable> from PERMISSIVE SELECT/ALL policy 2\n"
"  OR\n"
"  ...\n"
")\n"
"AND\n"
"<replaceable>выражение</replaceable> from RESTRICTIVE UPDATE/ALL policy 1\n"
"AND\n"
"<replaceable>выражение</replaceable> from RESTRICTIVE UPDATE/ALL policy 2\n"
"AND\n"
"...\n"
"AND\n"
"(\n"
"  <replaceable>выражение</replaceable> from PERMISSIVE UPDATE/ALL policy 1\n"
"  OR\n"
"  <replaceable>выражение</replaceable> from PERMISSIVE UPDATE/ALL policy 2\n"
"  OR\n"
"  ...\n"
")"

#. +> REL_10
#: ref/create_policy.xml:428(para)
msgid ""
"For example, in an <literal>UPDATE</literal> command requiring both "
"<literal>SELECT</literal> and <literal>UPDATE</literal> permissions, if "
"there are multiple applicable policies of each type, they will be combined "
"as follows: <placeholder-1/>"
msgstr ""
"Например, в команде <literal>UPDATE</literal>, требующей разрешений и для "
"<literal>SELECT</literal>, и для <literal>UPDATE</literal>, в случае "
"существования нескольких применимых политик каждого типа они будут "
"объединяться следующим образом: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:469(title)
msgid "Notes"
msgstr "Замечания"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:471(para)
msgid "You must be the owner of a table to create or change policies for it."
msgstr ""
"Чтобы создать или изменить политики для таблицы, нужно быть её владельцем."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:475(para)
msgid ""
"While policies will be applied for explicit queries against tables in the "
"database, they are not applied when the system is performing internal "
"referential integrity checks or validating constraints. This means there are "
"indirect ways to determine that a given value exists. An example of this is "
"attempting to insert a duplicate value into a column that is a primary key "
"or has a unique constraint. If the insert fails then the user can infer that "
"the value already exists. (This example assumes that the user is permitted "
"by policy to insert records which they are not allowed to see.) Another "
"example is where a user is allowed to insert into a table which references "
"another, otherwise hidden table. Existence can be determined by the user "
"inserting values into the referencing table, where success would indicate "
"that the value exists in the referenced table. These issues can be addressed "
"by carefully crafting policies to prevent users from being able to insert, "
"delete, or update records at all which might possibly indicate a value they "
"are not otherwise able to see, or by using generated values (e.g., surrogate "
"keys) instead of keys with external meanings."
msgstr ""
"Хотя политики применяются к явно выполняемым запросам к таблицам БД, они не "
"применяются, когда система выполняет внутренние проверки ссылочной "
"целостности или проверяет ограничения. Это означает, что существуют "
"косвенные пути проверить существование заданного значения. Например, можно "
"попытаться вставить повторяющееся значение в столбец, образующий первичный "
"ключ или имеющую ограничение уникальности. Если при этом произойдёт ошибка, "
"пользователь может заключить, что это значение уже существует. (В данном "
"случае предполагается, что политика разрешает пользователю вставлять записи, "
"которые он может не видеть.) Подобный приём также возможен, если "
"пользователь может вставлять записи в таблицу, которая ссылается на другую, "
"иным образом не видимую. Существование значения можно определить, вставив "
"его в подчинённую таблицу, при этом успешный результат операции будет "
"признаком того, что это значение есть в главной таблице. Эти изъяны можно "
"устранить, либо тщательно разработав политики, которые вовсе не позволят "
"пользователям выполнять операции добавления, изменения и удаления, по "
"результатам которых можно узнать о значениях в таблицах, не видимых иным "
"образом, либо используя генерируемые значения (например, суррогатные ключи)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:494(para)
msgid ""
"Generally, the system will enforce filter conditions imposed using security "
"policies prior to qualifications that appear in user queries, in order to "
"prevent inadvertent exposure of the protected data to user-defined functions "
"which might not be trustworthy. However, functions and operators marked by "
"the system (or the system administrator) as <literal>LEAKPROOF</literal> may "
"be evaluated before policy expressions, as they are assumed to be "
"trustworthy."
msgstr ""
"Вообще система будет применять фильтры, устанавливаемые политиками "
"безопасности, до условий в запросах пользователя, чтобы предотвратить "
"нежелательную утечку защищаемых данных через пользовательские функции, "
"которые могут быть недоверенными. Однако функции и операторы, помеченные "
"системой (или системным администратором) как <literal>LEAKPROOF</literal> "
"(герметичные) могут вычисляться до условий политики, так как они считаются "
"доверенными."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:504(para)
msgid ""
"Since policy expressions are added to the user's query directly, they will "
"be run with the rights of the user running the overall query. Therefore, "
"users who are using a given policy must be able to access any tables or "
"functions referenced in the expression or they will simply receive a "
"permission denied error when attempting to query the table that has row-"
"level security enabled. This does not change how views work, however. As "
"with normal queries and views, permission checks and policies for the tables "
"which are referenced by a view will use the view owner's rights and any "
"policies which apply to the view owner."
msgstr ""
"Так как выражения политики добавляются непосредственно в запрос "
"пользователя, они выполняются с правами пользователя, запускающего исходный "
"запрос. Таким образом, пользователи, на которых распространяется заданная "
"политика, должны иметь права для обращения ко всем таблицам и функциям, "
"задействованным в выражении, иначе им просто будет отказано в доступе при "
"попытке обращения к целевой таблице (если для неё включена защита на уровне "
"строк). Однако это не влияет на работу представлений — как и с обычными "
"запросами и представлениями, проверки разрешений и политики для нижележащих "
"таблиц представления будут выполняться с правами владельца представления, и "
"при этом будут действовать политики, распространяющиеся на этого владельца."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:517(para)
msgid ""
"Additional discussion and practical examples can be found in <xref linkend="
"\"ddl-rowsecurity\"/>."
msgstr ""
"Дополнительное описание и практические примеры можно найти в <xref remap="
"\"6\" linkend=\"ddl-rowsecurity\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:525(title)
msgid "Compatibility"
msgstr "Совместимость"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:527(para)
msgid ""
"<command>CREATE POLICY</command> is a <productname>PostgreSQL</productname> "
"extension."
msgstr ""
"<command>CREATE POLICY</command> является расширением "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:534(title)
msgid "See Also"
msgstr "См. также"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_policy.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:73(para)
msgid ""
"Policies can be applied for specific commands or for specific roles. The "
"default for newly created policies is that they apply for all commands and "
"roles, unless otherwise specified. If multiple policies apply to a given "
"statement, they will be combined using OR (although <literal>ON CONFLICT DO "
"UPDATE</literal> and <literal>INSERT</literal> policies are not combined in "
"this way, but rather enforced as noted at each stage of <literal>ON "
"CONFLICT</literal> execution)."
msgstr ""
"Политики можно применять к определённым командам или избранным ролям. По "
"умолчанию создаваемые политики применяются ко всем командам и ролям, если "
"нет других указаний. Если к заданному оператору применяются несколько "
"политик, они будут объединены логическим сложением (хотя политики "
"<literal>ON CONFLICT DO UPDATE</literal> и <literal>INSERT</literal> таким "
"образом не складываются, а применяются как отмечено на каждой стадии "
"выполнения <literal>ON CONFLICT</literal>)."

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:82(para)
msgid ""
"For commands that can have both <literal>USING</literal> and <literal>WITH "
"CHECK</literal> policies (<literal>ALL</literal> and <literal>UPDATE</"
"literal>), if no <literal>WITH CHECK</literal> policy is defined, then the "
"<literal>USING</literal> policy will be used both for which rows are visible "
"(normal <literal>USING</literal> case) and for which rows will be allowed to "
"be added (<literal>WITH CHECK</literal> case)."
msgstr ""
"Для команд, допускающих наличие политик <literal>USING</literal> и "
"<literal>WITH CHECK</literal> (<literal>ALL</literal> и <literal>UPDATE</"
"literal>), в отсутствие политики <literal>WITH CHECK</literal> политика "
"<literal>USING</literal> будет определять и видимость строк (обычное "
"предназначение <literal>USING</literal>), и разрешение на добавление строк "
"(предназначение <literal>WITH CHECK</literal>)."

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:194(para)
msgid ""
"Using <literal>ALL</literal> for a policy means that it will apply to all "
"commands, regardless of the type of command. If an <literal>ALL</literal> "
"policy exists and more specific policies exist, then both the <literal>ALL</"
"literal> policy and the more specific policy (or policies) will be combined "
"using OR, as usual for overlapping policies. Additionally, <literal>ALL</"
"literal> policies will be applied to both the selection side of a query and "
"the modification side, using the <literal>USING</literal> expression for "
"both cases if only a <literal>USING</literal> expression has been defined."
msgstr ""
"Указание <literal>ALL</literal> для политики означает, что она применяется "
"ко всем командам, вне зависимости от типа. Если существует политика "
"<literal>ALL</literal> и другие более детализированные политики, тогда и "
"политика <literal>ALL</literal>, и более детализированная политика (или "
"политики) объединяются логическим сложением, как обычно при наложении "
"политик. Кроме того, политики <literal>ALL</literal> с выражением "
"<literal>USING</literal> будут применяться и к стороне выборки, и к стороне "
"изменения данных в запросе, если определено только выражение <literal>USING</"
"literal>."

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:267(para)
msgid ""
"Using <literal>UPDATE</literal> for a policy means that it will apply to "
"<literal>UPDATE</literal> commands (or auxiliary <literal>ON CONFLICT DO "
"UPDATE</literal> clauses of <literal>INSERT</literal> commands). Since "
"<literal>UPDATE</literal> involves pulling an existing record and then "
"making changes to some portion (but possibly not all) of the record, "
"<literal>UPDATE</literal> policies accept both a <literal>USING</literal> "
"expression and a <literal>WITH CHECK</literal> expression. The "
"<literal>USING</literal> expression determines which records the "
"<literal>UPDATE</literal> command will see to operate against, while the "
"<literal>WITH CHECK</literal> expression defines which modified rows are "
"allowed to be stored back into the relation."
msgstr ""
"Указание <literal>UPDATE</literal> для политики означает, что она "
"применяется к командам <literal>UPDATE</literal> (или дополнительным "
"предложениям <literal>ON CONFLICT DO UPDATE</literal> команд "
"<literal>INSERT</literal>). Так как действие <literal>UPDATE</literal> "
"подразумевает извлечение существующей записи и последующее изменение в ней "
"полей (возможно, не всех), политики <literal>UPDATE</literal> принимают и "
"выражение <literal>USING</literal>, и выражение <literal>WITH CHECK</"
"literal>. Выражение <literal>USING</literal> определяет, какие строки будет "
"обрабатывать команда <literal>UPDATE</literal>, тогда как выражение "
"<literal>WITH CHECK</literal> определяет, какие изменённые строки можно "
"снова записать в отношение."

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:282(para)
msgid ""
"When an <literal>UPDATE</literal> command is used with a <literal>WHERE</"
"literal> clause or a <literal>RETURNING</literal> clause, <literal>SELECT</"
"literal> rights are also required on the relation being updated and the "
"appropriate <literal>SELECT</literal> and <literal>ALL</literal> policies "
"will be combined (using OR for any overlapping <literal>SELECT</literal> "
"related policies found) with the <literal>USING</literal> clause of the "
"<literal>UPDATE</literal> policy using AND. Therefore, in order for a user "
"to be able to <literal>UPDATE</literal> specific rows, the user must have "
"access to the row(s) through a <literal>SELECT</literal> or <literal>ALL</"
"literal> policy and the row(s) must pass the <literal>UPDATE</literal> "
"policy's <literal>USING</literal> expression."
msgstr ""
"Когда выполняется команда <literal>UPDATE</literal> с предложением "
"<literal>WHERE</literal> или <literal>RETURNING</literal>, для обращения к "
"целевому отношению также требуются права <literal>SELECT</literal>, так что "
"соответствующие политики <literal>SELECT</literal> и <literal>ALL</literal> "
"будут объединены (логическим сложением всех найденных связанных политик "
"<literal>SELECT</literal>), а затем совмещены (логическим умножением) с "
"предложением <literal>USING</literal> политики <literal>UPDATE</literal>. "
"Таким образом, чтобы пользователь мог изменять определённые строки (выполняя "
"<literal>UPDATE</literal>), ему должен быть разрешён доступ к ним политикой "
"<literal>SELECT</literal> или <literal>ALL</literal> и эти строки должны "
"удовлетворять выражению <literal>USING</literal> политики <literal>UPDATE</"
"literal>."

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:306(para)
msgid ""
"Note, however, that <literal>INSERT</literal> with <literal>ON CONFLICT DO "
"UPDATE</literal> requires that an <literal>UPDATE</literal> policy "
"<literal>USING</literal> expression always be enforced as a <literal>WITH "
"CHECK</literal> expression. This <literal>UPDATE</literal> policy must "
"always pass when the <literal>UPDATE</literal> path is taken. Any existing "
"row that necessitates that the <literal>UPDATE</literal> path be taken must "
"pass the (<literal>UPDATE</literal> or <literal>ALL</literal>) "
"<literal>USING</literal> qualifications (combined using OR), which are "
"always enforced as <literal>WITH CHECK</literal> options in this context. "
"(The <literal>UPDATE</literal> path will <emphasis>never</emphasis> be "
"silently avoided; an error will be thrown instead.) Finally, the final row "
"appended to the relation must pass any <literal>WITH CHECK</literal> options "
"that a conventional <literal>UPDATE</literal> is required to pass."
msgstr ""
"Заметьте однако, что <literal>INSERT</literal> с <literal>ON CONFLICT DO "
"UPDATE</literal> требует, чтобы выражение <literal>USING</literal> политики "
"<literal>UPDATE</literal> всегда действовало как выражение <literal>WITH "
"CHECK</literal>. Эта политика <literal>UPDATE</literal> должна всегда "
"выполняться, когда выбирается путь <literal>UPDATE</literal>. Любая "
"существующая строка, из-за которой выбирается путь <literal>UPDATE</"
"literal>, должна удовлетворять проверкам (политик <literal>UPDATE</literal> "
"или <literal>ALL</literal>) <literal>USING</literal> (объединённым "
"логическим сложением), которые всегда действуют как <literal>WITH CHECK</"
"literal> в данном контексте. (Путь <literal>UPDATE</literal> "
"<emphasis>никогда</emphasis> не игнорируется, так что в случае невыполнения "
"условия выдаётся ошибка.) Наконец, окончательная строка, добавляемая в "
"отношение, должна проходить все проверки <literal>WITH CHECK</literal>, "
"которые должны быть пройдены и при обычном <literal>UPDATE</literal>."

#. +> REL9_6_3 REL9_6
#: ref/create_policy.xml:339(para)
msgid ""
"When a <literal>DELETE</literal> command is used with a <literal>WHERE</"
"literal> clause or a <literal>RETURNING</literal> clause, <literal>SELECT</"
"literal> rights are also required on the relation being updated and the "
"appropriate <literal>SELECT</literal> and <literal>ALL</literal> policies "
"will be combined (using OR for any overlapping <literal>SELECT</literal> "
"related policies found) with the <literal>USING</literal> clause of the "
"<literal>DELETE</literal> policy using AND. Therefore, in order for a user "
"to be able to <literal>DELETE</literal> specific rows, the user must have "
"access to the row(s) through a <literal>SELECT</literal> or <literal>ALL</"
"literal> policy and the row(s) must pass the <literal>DELETE</literal> "
"policy's <literal>USING</literal> expression."
msgstr ""
"Когда выполняется команда <literal>DELETE</literal> с предложением "
"<literal>WHERE</literal> или <literal>RETURNING</literal>, для обращения к "
"целевому отношению также требуются права <literal>SELECT</literal>, так что "
"соответствующие политики <literal>SELECT</literal> и <literal>ALL</literal> "
"будут объединены (логическим сложением всех найденных связанных политик "
"<literal>SELECT</literal>), а затем совмещены (логическим умножением) с "
"предложением <literal>USING</literal> политики <literal>DELETE</literal>. "
"Таким образом, чтобы пользователь мог удалить определённые строки (выполняя "
"<literal>DELETE</literal>), ему должен быть разрешён доступ к ним политикой "
"<literal>SELECT</literal> или <literal>ALL</literal> и эти строки должны "
"удовлетворять выражению <literal>USING</literal> политики <literal>DELETE</"
"literal>."
