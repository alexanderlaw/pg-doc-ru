# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ref/create_opclass.xml:8(indexterm)
msgid "<primary>CREATE OPERATOR CLASS</primary>"
msgstr "<primary>CREATE OPERATOR CLASS</primary>"

#: ref/create_opclass.xml:13(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE OPERATOR CLASS"
msgstr "CREATE OPERATOR CLASS"

#: ref/create_opclass.xml:14(manvolnum)
msgid "7"
msgstr "7"

#: ref/create_opclass.xml:15(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#: ref/create_opclass.xml:19(refname)
msgctxt "refname"
msgid "CREATE OPERATOR CLASS"
msgstr "CREATE OPERATOR CLASS"

#: ref/create_opclass.xml:20(refpurpose)
msgid "define a new operator class"
msgstr "создать класс операторов"

#: ref/create_opclass.xml:25(replaceable)
#: ref/create_opclass.xml:90(replaceable)
msgid "name"
msgstr "имя"

#: ref/create_opclass.xml:25(replaceable)
#: ref/create_opclass.xml:111(replaceable)
msgid "data_type"
msgstr "тип_данных"

#: ref/create_opclass.xml:26(replaceable)
#: ref/create_opclass.xml:120(replaceable)
msgid "index_method"
msgstr "метод_индекса"

#: ref/create_opclass.xml:26(replaceable)
#: ref/create_opclass.xml:129(replaceable)
msgid "family_name"
msgstr "имя_семейства"

#: ref/create_opclass.xml:27(replaceable)
#: ref/create_opclass.xml:140(replaceable)
msgid "strategy_number"
msgstr "номер_стратегии"

#: ref/create_opclass.xml:27(replaceable)
#: ref/create_opclass.xml:150(replaceable)
msgid "operator_name"
msgstr "имя_оператора"

#: ref/create_opclass.xml:27(replaceable)
#: ref/create_opclass.xml:28(replaceable)
#: ref/create_opclass.xml:160(replaceable)
msgid "op_type"
msgstr "тип_операнда"

#: ref/create_opclass.xml:27(replaceable)
#: ref/create_opclass.xml:186(replaceable)
msgid "sort_family_name"
msgstr "семейство_сортировки"

#: ref/create_opclass.xml:28(replaceable)
#: ref/create_opclass.xml:202(replaceable)
msgid "support_number"
msgstr "номер_опорной_функции"

#: ref/create_opclass.xml:28(replaceable)
#: ref/create_opclass.xml:212(replaceable)
msgid "function_name"
msgstr "имя_функции"

#: ref/create_opclass.xml:28(replaceable)
#: ref/create_opclass.xml:222(replaceable)
msgid "argument_type"
msgstr "тип_аргумента"

#: ref/create_opclass.xml:29(replaceable)
#: ref/create_opclass.xml:231(replaceable)
msgid "storage_type"
msgstr "тип_хранения"

#: ref/create_opclass.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE OPERATOR CLASS <placeholder-1/> [ DEFAULT ] FOR TYPE <placeholder-2/>\n"
"  USING <placeholder-3/> [ FAMILY <placeholder-4/> ] AS\n"
"  {  OPERATOR <placeholder-5/> <placeholder-6/> [ ( <placeholder-7/>, <placeholder-8/> ) ] [ FOR SEARCH | FOR ORDER BY <placeholder-9/> ]\n"
"   | FUNCTION <placeholder-10/> [ ( <placeholder-11/> [ , <placeholder-12/> ] ) ] <placeholder-13/> ( <placeholder-14/> [, ...] )\n"
"   | STORAGE <placeholder-15/>\n"
"  } [, ... ]"
msgstr ""
"CREATE OPERATOR CLASS <placeholder-1/> [ DEFAULT ] FOR TYPE <placeholder-2/>\n"
"  USING <placeholder-3/> [ FAMILY <placeholder-4/> ] AS\n"
"  {  OPERATOR <placeholder-5/> <placeholder-6/> [ ( <placeholder-7/>, <placeholder-8/> ) ] [ FOR SEARCH | FOR ORDER BY <placeholder-9/> ]\n"
"   | FUNCTION <placeholder-10/> [ ( <placeholder-11/> [ , <placeholder-12/> ] ) ] <placeholder-13/> ( <placeholder-14/> [, ...] )\n"
"   | STORAGE <placeholder-15/>\n"
"  } [, ... ]"

#: ref/create_opclass.xml:35(title)
msgid "Description"
msgstr "Описание"

#: ref/create_opclass.xml:37(para)
msgid ""
"<command>CREATE OPERATOR CLASS</command> creates a new operator class. An "
"operator class defines how a particular data type can be used with an index. "
"The operator class specifies that certain operators will fill particular "
"roles or <quote>strategies</quote> for this data type and this index method. "
"The operator class also specifies the support procedures to be used by the "
"index method when the operator class is selected for an index column. All "
"the operators and functions used by an operator class must be defined before "
"the operator class can be created."
msgstr ""
"<command>CREATE OPERATOR CLASS</command> создаёт класс операторов. Класс "
"операторов устанавливает, как данный тип будет использоваться в индексе, "
"определяя, какие операторы исполняют конкретные роли или <quote>стратегии</"
"quote> для этого типа данных и метода индекса. Также класс операторов "
"определяет вспомогательные процедуры, которые будет задействовать метод "
"индекса в случае выбора данного класса для столбца индекса. Все операторы и "
"функции, используемые классом операторов, должны существовать до создания "
"этого класса."

#: ref/create_opclass.xml:49(para)
msgid ""
"If a schema name is given then the operator class is created in the "
"specified schema. Otherwise it is created in the current schema. Two "
"operator classes in the same schema can have the same name only if they are "
"for different index methods."
msgstr ""
"Если указывается имя схемы, класс операторов создаётся в указанной схеме, в "
"противном случае — в текущей. Два класса операторов в одной схеме могут "
"иметь одинаковые имена, только если они предназначены для разных методов "
"индекса."

#: ref/create_opclass.xml:56(para)
msgid ""
"The user who defines an operator class becomes its owner. Presently, the "
"creating user must be a superuser. (This restriction is made because an "
"erroneous operator class definition could confuse or even crash the server.)"
msgstr ""
"Владельцем класса операторов становится пользователь, создавший его. В "
"настоящее время создавать классы операторов могут только суперпользователи. "
"(Это ограничение введено потому, что ошибочное определение класса может "
"вызвать нарушения или даже сбой в работе сервера.)"

#: ref/create_opclass.xml:63(para)
msgid ""
"<command>CREATE OPERATOR CLASS</command> does not presently check whether "
"the operator class definition includes all the operators and functions "
"required by the index method, nor whether the operators and functions form a "
"self-consistent set. It is the user's responsibility to define a valid "
"operator class."
msgstr ""
"<command>CREATE OPERATOR CLASS</command> в настоящее время не проверяет, "
"включает ли определение класса операторов все операторы и функции, требуемые "
"для метода индекса, и образуют ли они целостный набор. Ответственность за "
"правильность определения класса операторов лежит на пользователе."

#: ref/create_opclass.xml:71(para)
msgid ""
"Related operator classes can be grouped into <firstterm>operator families</"
"firstterm>. To add a new operator class to an existing family, specify the "
"<literal>FAMILY</literal> option in <command>CREATE OPERATOR CLASS</"
"command>. Without this option, the new class is placed into a family named "
"the same as the new class (creating that family if it doesn't already exist)."
msgstr ""
"Связанные классы операторов могут быть сгруппированы в <firstterm>семейства "
"операторов</firstterm>. Чтобы поместить класс в существующее семейство, "
"добавьте параметр <literal>FAMILY</literal> в <command>CREATE OPERATOR "
"CLASS</command>. Без этого параметра новый класс помещается в семейство, "
"имеющее то же имя, что и класс (если такое семейство не существует, оно "
"создаётся)."

#: ref/create_opclass.xml:80(para)
msgid "Refer to <xref linkend=\"xindex\"/> for further information."
msgstr ""
"За дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"xindex"
"\"/>."

#: ref/create_opclass.xml:86(title)
msgid "Parameters"
msgstr "Параметры"

#: ref/create_opclass.xml:92(para)
msgid ""
"The name of the operator class to be created. The name can be schema-"
"qualified."
msgstr "Имя создаваемого класса операторов, возможно, дополненное схемой."

#: ref/create_opclass.xml:100(literal)
msgid "DEFAULT"
msgstr "DEFAULT"

#: ref/create_opclass.xml:102(para)
msgid ""
"If present, the operator class will become the default operator class for "
"its data type. At most one operator class can be the default for a specific "
"data type and index method."
msgstr ""
"Если присутствует это указание, класс операторов становится классом по "
"умолчанию для своего типа данных. Для определённого типа данных и метода "
"индекса можно определить не больше одного класса операторов по умолчанию."

#: ref/create_opclass.xml:113(para)
msgid "The column data type that this operator class is for."
msgstr "Тип данных столбца, для которого предназначен этот класс операторов."

#: ref/create_opclass.xml:122(para)
msgid "The name of the index method this operator class is for."
msgstr ""
"Имя индексного метода, для которого предназначен этот класс операторов."

#: ref/create_opclass.xml:131(para)
msgid ""
"The name of the existing operator family to add this operator class to. If "
"not specified, a family named the same as the operator class is used "
"(creating it, if it doesn't already exist)."
msgstr ""
"Имя существующего семейства операторов, в которое будет добавлен этот класс. "
"Если не указано, подразумевается семейство с тем же именем, что и класс "
"(если такое семейство не существует, оно создаётся)."

#: ref/create_opclass.xml:142(para)
msgid ""
"The index method's strategy number for an operator associated with the "
"operator class."
msgstr ""
"Номер стратегии индексного метода для оператора, связанного с данным классом "
"операторов."

#: ref/create_opclass.xml:152(para)
msgid ""
"The name (optionally schema-qualified) of an operator associated with the "
"operator class."
msgstr ""
"Имя (возможно, дополненное схемой) оператора, связанного с данным классом "
"операторов."

#: ref/create_opclass.xml:162(para)
msgid ""
"In an <literal>OPERATOR</literal> clause, the operand data type(s) of the "
"operator, or <literal>NONE</literal> to signify a left-unary or right-unary "
"operator. The operand data types can be omitted in the normal case where "
"they are the same as the operator class's data type."
msgstr ""
"В предложении <literal>OPERATOR</literal> это тип данных операнда, либо "
"ключевое слово <literal>NONE</literal>, характеризующее левый унарный или "
"правый унарный оператор. Типы операндов обычно можно опустить, когда они "
"совпадают с типом данных класса операторов."

#: ref/create_opclass.xml:170(para)
msgid ""
"In a <literal>FUNCTION</literal> clause, the operand data type(s) the "
"function is intended to support, if different from the input data type(s) of "
"the function (for B-tree comparison functions and hash functions) or the "
"class's data type (for B-tree sort support functions and all functions in "
"GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, "
"and so <replaceable class=\"parameter\">op_type</replaceable> need not be "
"specified in <literal>FUNCTION</literal> clauses, except for the case of a B-"
"tree sort support function that is meant to support cross-data-type "
"comparisons."
msgstr ""
"В предложении <literal>FUNCTION</literal> это тип данных операнда, который "
"должна поддерживать эта функция, если он отличается от входного типа данных "
"функции (для функций сравнения в B-деревьях и хеш-функций) или типа данных "
"класса (для функций поддержки сортировки в B-деревьях и всех функций в "
"классах операторов GiST, SP-GiST, GIN и BRIN). Обычно предполагаемые по "
"умолчанию типы оказываются верными, так что <replaceable class=\"parameter"
"\">тип_операнда</replaceable> указывать в <literal>FUNCTION</literal> не "
"нужно, кроме функций сортировки B-дерева, предназначенных для сравнений "
"разных типов данных."

#: ref/create_opclass.xml:188(para)
msgid ""
"The name (optionally schema-qualified) of an existing <literal>btree</"
"literal> operator family that describes the sort ordering associated with an "
"ordering operator."
msgstr ""
"Имя (возможно, дополненное схемой) существующего семейства операторов "
"<literal>btree</literal>, описывающего порядок сортировки, связанный с "
"оператором сортировки."

#: ref/create_opclass.xml:194(para)
msgid ""
"If neither <literal>FOR SEARCH</literal> nor <literal>FOR ORDER BY</literal> "
"is specified, <literal>FOR SEARCH</literal> is the default."
msgstr ""
"Если не указано ни <literal>FOR SEARCH</literal> (для поиска), ни "
"<literal>FOR ORDER BY</literal> (для сортировки), подразумевается "
"<literal>FOR SEARCH</literal>."

#: ref/create_opclass.xml:204(para)
msgid ""
"The index method's support procedure number for a function associated with "
"the operator class."
msgstr ""
"Номер опорной процедуры индексного метода для функции, связанной с данным "
"классом операторов."

#: ref/create_opclass.xml:214(para)
msgid ""
"The name (optionally schema-qualified) of a function that is an index method "
"support procedure for the operator class."
msgstr ""
"Имя (возможно, дополненное схемой) функции, которая является опорной "
"процедурой индексного метода для данного класса операторов."

#: ref/create_opclass.xml:224(para)
msgid "The parameter data type(s) of the function."
msgstr "Тип данных параметра функции."

#: ref/create_opclass.xml:233(para)
msgid ""
"The data type actually stored in the index. Normally this is the same as the "
"column data type, but some index methods (currently GiST, GIN and BRIN) "
"allow it to be different. The <literal>STORAGE</literal> clause must be "
"omitted unless the index method allows a different type to be used."
msgstr ""
"Тип данных, фактически сохраняемых в индексе. Обычно это тип данных столбца, "
"но некоторые методы индекса (в настоящее время, GiST, GIN и BRIN) могут "
"работать с отличным от него типом. Предложение <literal>STORAGE</literal> "
"может присутствовать, только если метод индекса позволяет использовать "
"другой тип данных."

#: ref/create_opclass.xml:244(para)
msgid ""
"The <literal>OPERATOR</literal>, <literal>FUNCTION</literal>, and "
"<literal>STORAGE</literal> clauses can appear in any order."
msgstr ""
"Предложения <literal>OPERATOR</literal>, <literal>FUNCTION</literal> и "
"<literal>STORAGE</literal> могут указываться в любом порядке."

#: ref/create_opclass.xml:251(title)
msgid "Notes"
msgstr "Замечания"

#: ref/create_opclass.xml:253(para)
msgid ""
"Because the index machinery does not check access permissions on functions "
"before using them, including a function or operator in an operator class is "
"tantamount to granting public execute permission on it. This is usually not "
"an issue for the sorts of functions that are useful in an operator class."
msgstr ""
"Так как механизмы индексов не проверяют права доступа к функциям, прежде чем "
"вызывать их, включение функций или операторов в класс операторов по сути "
"даёт всем право на выполнение их. Обычно это не проблема для таких функций, "
"какие бывают полезны в классе операторов."

#: ref/create_opclass.xml:261(para)
msgid ""
"The operators should not be defined by SQL functions. A SQL function is "
"likely to be inlined into the calling query, which will prevent the "
"optimizer from recognizing that the query matches an index."
msgstr ""
"Операторы не должны реализовываться в функциях на языке SQL. SQL-функция "
"вероятнее всего будет встроена в вызывающий запрос, что помешает "
"оптимизатору понять, что этот запрос соответствует индексу."

#: ref/create_opclass.xml:267(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.4, the <literal>OPERATOR</"
"literal> clause could include a <literal>RECHECK</literal> option. This is "
"no longer supported because whether an index operator is <quote>lossy</"
"quote> is now determined on-the-fly at run time. This allows efficient "
"handling of cases where an operator might or might not be lossy."
msgstr ""
"До <productname>PostgreSQL</productname> 8.4 предложение <literal>OPERATOR</"
"literal> могло включать указание <literal>RECHECK</literal>. Теперь это не "
"поддерживается, так как оператор индекса может быть <quote>неточным</quote> "
"и это определяется на ходу в момент выполнения. Это позволяет эффективно "
"справляться с ситуациями, когда оператор может быть или не быть неточным."

#: ref/create_opclass.xml:277(title)
msgid "Examples"
msgstr "Примеры"

#: ref/create_opclass.xml:279(para)
msgid ""
"The following example command defines a GiST index operator class for the "
"data type <literal>_int4</literal> (array of <type>int4</type>). See the "
"<xref linkend=\"intarray\"/> module for the complete example."
msgstr ""
"Команда в следующем примере определяет класс операторов индекса GiST для "
"типа данных <literal>_int4</literal> (массива из <type>int4</type>). Полный "
"пример приведён в модуле <xref linkend=\"intarray\"/>."

#: ref/create_opclass.xml:285(programlisting)
#, no-wrap
msgid ""
"CREATE OPERATOR CLASS gist__int_ops\n"
"    DEFAULT FOR TYPE _int4 USING gist AS\n"
"        OPERATOR        3       &amp;&amp;,\n"
"        OPERATOR        6       = (anyarray, anyarray),\n"
"        OPERATOR        7       @&gt;,\n"
"        OPERATOR        8       &lt;@,\n"
"        OPERATOR        20      @@ (_int4, query_int),\n"
"        FUNCTION        1       g_int_consistent (internal, _int4, smallint, oid, internal),\n"
"        FUNCTION        2       g_int_union (internal, internal),\n"
"        FUNCTION        3       g_int_compress (internal),\n"
"        FUNCTION        4       g_int_decompress (internal),\n"
"        FUNCTION        5       g_int_penalty (internal, internal, internal),\n"
"        FUNCTION        6       g_int_picksplit (internal, internal),\n"
"        FUNCTION        7       g_int_same (_int4, _int4, internal);"
msgstr ""
"CREATE OPERATOR CLASS gist__int_ops\n"
"    DEFAULT FOR TYPE _int4 USING gist AS\n"
"        OPERATOR        3       &amp;&amp;,\n"
"        OPERATOR        6       = (anyarray, anyarray),\n"
"        OPERATOR        7       @&gt;,\n"
"        OPERATOR        8       &lt;@,\n"
"        OPERATOR        20      @@ (_int4, query_int),\n"
"        FUNCTION        1       g_int_consistent (internal, _int4, smallint, oid, internal),\n"
"        FUNCTION        2       g_int_union (internal, internal),\n"
"        FUNCTION        3       g_int_compress (internal),\n"
"        FUNCTION        4       g_int_decompress (internal),\n"
"        FUNCTION        5       g_int_penalty (internal, internal, internal),\n"
"        FUNCTION        6       g_int_picksplit (internal, internal),\n"
"        FUNCTION        7       g_int_same (_int4, _int4, internal);"

#: ref/create_opclass.xml:304(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ref/create_opclass.xml:306(para)
msgid ""
"<command>CREATE OPERATOR CLASS</command> is a <productname>PostgreSQL</"
"productname> extension. There is no <command>CREATE OPERATOR CLASS</command> "
"statement in the SQL standard."
msgstr ""
"<command>CREATE OPERATOR CLASS</command> является расширением "
"<productname>PostgreSQL</productname>. Команда <command>CREATE OPERATOR "
"CLASS</command> отсутствует в стандарте SQL."

#: ref/create_opclass.xml:315(title)
msgid "See Also"
msgstr "См. также"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ref/create_opclass.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
