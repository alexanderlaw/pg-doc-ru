# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:14+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:8(indexterm)
msgid "<primary>CREATE INDEX</primary>"
msgstr "<primary>CREATE INDEX</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:13(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE INDEX"
msgstr "CREATE INDEX"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:14(manvolnum)
msgid "7"
msgstr "7"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:15(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:19(refname)
msgctxt "refname"
msgid "CREATE INDEX"
msgstr "CREATE INDEX"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:20(refpurpose)
msgid "define a new index"
msgstr "создать индекс"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:25(replaceable) ref/create_index.xml:143(replaceable)
msgid "name"
msgstr "имя"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:25(replaceable) ref/create_index.xml:156(replaceable)
msgid "table_name"
msgstr "имя_таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:25(replaceable) ref/create_index.xml:165(replaceable)
msgid "method"
msgstr "метод"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:26(replaceable) ref/create_index.xml:178(replaceable)
msgid "column_name"
msgstr "имя_столбца"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:26(replaceable) ref/create_index.xml:187(replaceable)
msgid "expression"
msgstr "выражение"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:26(replaceable) ref/create_index.xml:199(replaceable)
msgid "collation"
msgstr "правило_сортировки"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:26(replaceable) ref/create_index.xml:212(replaceable)
msgid "opclass"
msgstr "класс_операторов"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:27(replaceable) ref/create_index.xml:259(replaceable)
msgid "storage_parameter"
msgstr "параметр_хранения"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:27(replaceable)
msgid "value"
msgstr "значение"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:28(replaceable) ref/create_index.xml:270(replaceable)
msgid "tablespace_name"
msgstr "табл_пространство"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:29(replaceable) ref/create_index.xml:282(replaceable)
msgid "predicate"
msgstr "предикат"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <placeholder-1/> ] ON <placeholder-2/> [ USING <placeholder-3/> ]\n"
"    ( { <placeholder-4/> | ( <placeholder-5/> ) } [ COLLATE <placeholder-6/> ] [ <placeholder-7/> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )\n"
"    [ WITH ( <placeholder-8/> = <placeholder-9/> [, ... ] ) ]\n"
"    [ TABLESPACE <placeholder-10/> ]\n"
"    [ WHERE <placeholder-11/> ]"
msgstr ""
"CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <placeholder-1/> ] ON <placeholder-2/> [ USING <placeholder-3/> ]\n"
"    ( { <placeholder-4/> | ( <placeholder-5/> ) } [ COLLATE <placeholder-6/> ] [ <placeholder-7/> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )\n"
"    [ WITH ( <placeholder-8/> = <placeholder-9/> [, ... ] ) ]\n"
"    [ TABLESPACE <placeholder-10/> ]\n"
"    [ WHERE <placeholder-11/> ]"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:34(title)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:36(para)
msgid ""
"<command>CREATE INDEX</command> constructs an index on the specified "
"column(s) of the specified relation, which can be a table or a materialized "
"view. Indexes are primarily used to enhance database performance (though "
"inappropriate use can result in slower performance)."
msgstr ""
"<command>CREATE INDEX</command> создаёт индексы по указанному столбцу(ам) "
"заданного отношения, которым может быть таблица или материализованное "
"представление. Индексы применяются в первую очередь для оптимизации "
"производительности базы данных (хотя при неправильном использовании возможен "
"и противоположный эффект)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:43(para)
msgid ""
"The key field(s) for the index are specified as column names, or "
"alternatively as expressions written in parentheses. Multiple fields can be "
"specified if the index method supports multicolumn indexes."
msgstr ""
"Ключевое поле для индекса задаётся как имя столбца или выражение, "
"заключённое в скобки. Если метод индекса поддерживает составные индексы, "
"допускается указание нескольких полей."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:50(para)
msgid ""
"An index field can be an expression computed from the values of one or more "
"columns of the table row. This feature can be used to obtain fast access to "
"data based on some transformation of the basic data. For example, an index "
"computed on <literal>upper(col)</literal> would allow the clause "
"<literal>WHERE upper(col) = 'JIM'</literal> to use an index."
msgstr ""
"Поле индекса может быть выражением, вычисляемым из значений одного или "
"нескольких столбцов в строке таблицы. Это может быть полезно для получения "
"быстрого доступа к данным по некоторому преобразованию исходных значений. "
"Например, индекс, построенный по выражению <literal>upper(col)</literal>, "
"позволит использовать поиск по индексу в предложении <literal>WHERE "
"upper(col) = 'JIM'</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:59(para)
msgid ""
"<productname>PostgreSQL</productname> provides the index methods B-tree, "
"hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index "
"methods, but that is fairly complicated."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет следующие методы "
"индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Пользователи могут "
"определить и собственные методы индексов, но это довольно сложная задача."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:65(para)
msgid ""
"When the <literal>WHERE</literal> clause is present, a <firstterm>partial "
"index</firstterm> is created. A partial index is an index that contains "
"entries for only a portion of a table, usually a portion that is more useful "
"for indexing than the rest of the table. For example, if you have a table "
"that contains both billed and unbilled orders where the unbilled orders take "
"up a small fraction of the total table and yet that is an often used "
"section, you can improve performance by creating an index on just that "
"portion. Another possible application is to use <literal>WHERE</literal> "
"with <literal>UNIQUE</literal> to enforce uniqueness over a subset of a "
"table. See <xref linkend=\"indexes-partial\"/> for more discussion."
msgstr ""
"Если в команде присутствует предложение <literal>WHERE</literal>, она "
"создаёт <firstterm>частичный индекс</firstterm>. Такой индекс содержит "
"записи только для части таблицы, обычно более полезной для индексации, чем "
"остальная таблица. Например, если таблица содержит информацию об оплаченных "
"и неоплаченных счетах, при этом последних сравнительно немного, но именно "
"эта часть таблицы наиболее востребована, то увеличить быстродействие можно, "
"создав индекс только по этой части. Ещё одно возможное применение "
"<literal>WHERE</literal> — добавив <literal>UNIQUE</literal>, обеспечить "
"уникальность в подмножестве таблицы. Подробнее это рассматривается в <xref "
"remap=\"6\" linkend=\"indexes-partial\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:79(para)
msgid ""
"The expression used in the <literal>WHERE</literal> clause can refer only to "
"columns of the underlying table, but it can use all columns, not just the "
"ones being indexed. Presently, subqueries and aggregate expressions are also "
"forbidden in <literal>WHERE</literal>. The same restrictions apply to index "
"fields that are expressions."
msgstr ""
"Выражение в предложении <literal>WHERE</literal> может ссылаться только на "
"столбцы нижележащей таблицы, но не обязательно ограничиваться теми, по "
"которым строится индекс. В настоящее время в <literal>WHERE</literal> также "
"нельзя использовать подзапросы и агрегатные выражения. Это же ограничение "
"распространяется и на выражения в полях индексов."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:87(para)
msgid ""
"All functions and operators used in an index definition must be "
"<quote>immutable</quote>, that is, their results must depend only on their "
"arguments and never on any outside influence (such as the contents of "
"another table or the current time). This restriction ensures that the "
"behavior of the index is well-defined. To use a user-defined function in an "
"index expression or <literal>WHERE</literal> clause, remember to mark the "
"function immutable when you create it."
msgstr ""
"Все функции и операторы, используемые в определении индекса, должны быть "
"<quote>постоянными</quote>, то есть, их результаты должны зависеть только от "
"аргументов, но не от внешних факторов (например, содержимого другой таблицы "
"или текущего времени). Это ограничение обеспечивает определённость поведения "
"индекса. Чтобы использовать в выражении индекса или в предложении "
"<literal>WHERE</literal> собственную функцию, не забудьте пометить её при "
"создании как постоянную (IMMUTABLE)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:99(title)
msgid "Parameters"
msgstr "Параметры"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:103(literal)
msgid "UNIQUE"
msgstr "UNIQUE"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:105(para)
msgid ""
"Causes the system to check for duplicate values in the table when the index "
"is created (if data already exist) and each time data is added. Attempts to "
"insert or update data which would result in duplicate entries will generate "
"an error."
msgstr ""
"Указывает, что система должна контролировать повторяющиеся значения в "
"таблице при создании индекса (если в таблице уже есть данные) и при каждом "
"добавлении данных. Попытки вставить или изменить данные, при которых будет "
"нарушена уникальность индекса, будут завершаться ошибкой."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:116(literal)
msgid "CONCURRENTLY"
msgstr "CONCURRENTLY"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:118(para)
msgid ""
"When this option is used, <productname>PostgreSQL</productname> will build "
"the index without taking any locks that prevent concurrent inserts, updates, "
"or deletes on the table; whereas a standard index build locks out writes "
"(but not reads) on the table until it's done. There are several caveats to "
"be aware of when using this option &mdash; see <xref linkend=\"sql-"
"createindex-concurrently\" endterm=\"sql-createindex-concurrently-title\"/>."
msgstr ""
"С этим указанием <productname>PostgreSQL</productname> построит индекс, не "
"устанавливая никаких блокировок, которые бы предотвращали добавление, "
"изменение или удаление записей в таблице; тогда как по умолчанию операция "
"построения индекса блокирует запись (но не чтение) в таблице до своего "
"завершения. При создании индекса в параллельном режиме есть ряд "
"особенностей, о которых следует знать &mdash; см. <xref remap=\"4\" linkend="
"\"sql-createindex-concurrently\" endterm=\"sql-createindex-concurrently-title"
"\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:131(literal)
msgid "IF NOT EXISTS"
msgstr "IF NOT EXISTS"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:133(para)
msgid ""
"Do not throw an error if a relation with the same name already exists. A "
"notice is issued in this case. Note that there is no guarantee that the "
"existing index is anything like the one that would have been created. Index "
"name is required when <literal>IF NOT EXISTS</literal> is specified."
msgstr ""
"Не считать ошибкой, если индекс с таким именем уже существует. В этом случае "
"будет выдано замечание. Заметьте, что нет никакой гарантии, что существующий "
"индекс как-то соотносится с тем, который мог бы быть создан. Имя индекса "
"является обязательным, когда указывается <literal>IF NOT EXISTS</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:145(para)
msgid ""
"The name of the index to be created. No schema name can be included here; "
"the index is always created in the same schema as its parent table. If the "
"name is omitted, <productname>PostgreSQL</productname> chooses a suitable "
"name based on the parent table's name and the indexed column name(s)."
msgstr ""
"Имя создаваемого индекса. Указание схемы при этом не допускается; индекс "
"всегда относится к той же схеме, что и родительская таблица. Если имя "
"опущено, <productname>PostgreSQL</productname> формирует подходящее имя по "
"имени родительской таблицы и именам индексируемых столбцов."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:158(para)
msgid "The name (possibly schema-qualified) of the table to be indexed."
msgstr "Имя (возможно, дополненное схемой) индексируемой таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:167(para)
msgid ""
"The name of the index method to be used. Choices are <literal>btree</"
"literal>, <literal>hash</literal>, <literal>gist</literal>, <literal>spgist</"
"literal>, <literal>gin</literal>, and <literal>brin</literal>. The default "
"method is <literal>btree</literal>."
msgstr ""
"Имя применяемого метода индекса. Возможные варианты: <literal>btree</"
"literal>, <literal>hash</literal>, <literal>gist</literal>, <literal>spgist</"
"literal>, <literal>gin</literal> и <literal>brin</literal>. По умолчанию "
"подразумевается метод <literal>btree</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:180(para)
msgid "The name of a column of the table."
msgstr "Имя столбца таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:189(para)
msgid ""
"An expression based on one or more columns of the table. The expression "
"usually must be written with surrounding parentheses, as shown in the "
"syntax. However, the parentheses can be omitted if the expression has the "
"form of a function call."
msgstr ""
"Выражение с одним или несколькими столбцами таблицы. Обычно выражение должно "
"записываться в скобках, как показано в синтаксисе команды. Однако скобки "
"можно опустить, если выражение записано в виде вызова функции."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:201(para)
msgid ""
"The name of the collation to use for the index. By default, the index uses "
"the collation declared for the column to be indexed or the result collation "
"of the expression to be indexed. Indexes with non-default collations can be "
"useful for queries that involve expressions using non-default collations."
msgstr ""
"Имя правила сортировки, применяемого для индекса. По умолчанию используется "
"правило сортировки, заданное для индексируемого столбца, либо полученное для "
"результата выражения индекса. Индексы с нестандартными правилами сортировки "
"могут быть полезны для запросов, включающих выражения с такими правилами."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:214(para)
msgid "The name of an operator class. See below for details."
msgstr "Имя класса операторов. Подробнее об этом ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:221(literal)
msgid "ASC"
msgstr "ASC"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:223(para)
msgid "Specifies ascending sort order (which is the default)."
msgstr ""
"Указывает порядок сортировки по возрастанию (подразумевается по умолчанию)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:230(literal)
msgid "DESC"
msgstr "DESC"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:232(para)
msgid "Specifies descending sort order."
msgstr "Указывает порядок сортировки по убыванию."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:239(literal)
msgid "NULLS FIRST"
msgstr "NULLS FIRST"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:241(para)
msgid ""
"Specifies that nulls sort before non-nulls. This is the default when "
"<literal>DESC</literal> is specified."
msgstr ""
"Указывает, что значения NULL после сортировки оказываются перед остальными. "
"Это поведение по умолчанию с порядком сортировки <literal>DESC</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:249(literal)
msgid "NULLS LAST"
msgstr "NULLS LAST"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:251(para)
msgid ""
"Specifies that nulls sort after non-nulls. This is the default when "
"<literal>DESC</literal> is not specified."
msgstr ""
"Указывает, что значения NULL после сортировки оказываются после остальных. "
"Это поведение по умолчанию с порядком сортировки <literal>ASC</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:261(para)
msgid ""
"The name of an index-method-specific storage parameter. See <xref linkend="
"\"sql-createindex-storage-parameters\" endterm=\"sql-createindex-storage-"
"parameters-title\"/> for details."
msgstr ""
"Имя специфичного для индекса параметра хранения. За подробностями обратитесь "
"к <xref remap=\"3\" linkend=\"sql-createindex-storage-parameters\" endterm="
"\"sql-createindex-storage-parameters-title\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:272(para)
msgid ""
"The tablespace in which to create the index. If not specified, <xref linkend="
"\"guc-default-tablespace\"/> is consulted, or <xref linkend=\"guc-temp-"
"tablespaces\"/> for indexes on temporary tables."
msgstr ""
"Табличное пространство, в котором будет создан индекс. Если не определено, "
"выбирается <xref linkend=\"guc-default-tablespace\"/>, либо <xref linkend="
"\"guc-temp-tablespaces\"/>, при создании индекса временной таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:284(para)
msgid "The constraint expression for a partial index."
msgstr "Выражение ограничения для частичного индекса."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:293(title)
msgid "Index Storage Parameters"
msgstr "Параметры хранения индекса"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:295(para)
msgid ""
"The optional <literal>WITH</literal> clause specifies <firstterm>storage "
"parameters</firstterm> for the index. Each index method has its own set of "
"allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods "
"all accept this parameter:"
msgstr ""
"Необязательное предложение <literal>WITH</literal> определяет "
"<firstterm>параметры хранения</firstterm> для индекса. У каждого метода "
"индекса есть свой набор допустимых параметров хранения. Следующий параметр "
"принимают методы B-дерево, хеш, GiST и SP-GiST:"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:304(literal)
msgid "fillfactor"
msgstr "fillfactor"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:306(para)
msgid ""
"The fillfactor for an index is a percentage that determines how full the "
"index method will try to pack index pages. For B-trees, leaf pages are "
"filled to this percentage during initial index build, and also when "
"extending the index at the right (adding new largest key values). If pages "
"subsequently become completely full, they will be split, leading to gradual "
"degradation in the index's efficiency. B-trees use a default fillfactor of "
"90, but any integer value from 10 to 100 can be selected. If the table is "
"static then fillfactor 100 is best to minimize the index's physical size, "
"but for heavily updated tables a smaller fillfactor is better to minimize "
"the need for page splits. The other index methods use fillfactor in "
"different but roughly analogous ways; the default fillfactor varies between "
"methods."
msgstr ""
"Фактор заполнения для индекса определяет в процентном отношении, насколько "
"плотно метод индекса будет заполнять страницы индекса. Для B-деревьев "
"концевые страницы заполняются до этого процента при начальном построении "
"индекса и позже, при расширении индекса вправо (добавлении новых наибольших "
"значений ключа). Если страницы впоследствии оказываются заполненными "
"полностью, они будут разделены, что приводит к постепенному снижению "
"эффективности индекса. Для B-деревьев по умолчанию используется фактор "
"заполнения 90, но его можно поменять на любое целое значение от 10 до 100. "
"Фактор заполнения, равный 100, полезен для статических таблиц и помогает "
"уменьшить физический размер таблицы, но для интенсивно изменяемых таблиц "
"лучше использовать меньшее значение, чтобы разделять страницы приходилось "
"реже. С другими методами индекса фактор заполнения действует по-другому, но "
"примерно в том же ключе; значение фактора заполнения по умолчанию для разных "
"методов разное."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:325(para)
msgid "GiST indexes additionally accept this parameter:"
msgstr "Индексы GiST дополнительно принимают этот параметр:"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:331(literal)
msgid "buffering"
msgstr "buffering"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:333(para)
msgid ""
"Determines whether the buffering build technique described in <xref linkend="
"\"gist-buffering-build\"/> is used to build the index. With <literal>OFF</"
"literal> it is disabled, with <literal>ON</literal> it is enabled, and with "
"<literal>AUTO</literal> it is initially disabled, but turned on on-the-fly "
"once the index size reaches <xref linkend=\"guc-effective-cache-size\"/>. "
"The default is <literal>AUTO</literal>."
msgstr ""
"Определяет, будет ли при построении индекса использоваться буферизация, "
"описанная в <xref remap=\"6\" linkend=\"gist-buffering-build\"/>. Со "
"значением <literal>OFF</literal> она отключена, с <literal>ON</literal> — "
"включена, а с <literal>AUTO</literal> — отключена вначале, но может затем "
"включиться на ходу, как только размер индекса достигнет значения <xref "
"linkend=\"guc-effective-cache-size\"/>. По умолчанию подразумевается "
"<literal>AUTO</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:344(para)
msgid "GIN indexes accept different parameters:"
msgstr "Индексы GIN принимают другие параметры:"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:350(literal)
msgid "fastupdate"
msgstr "fastupdate"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:352(para)
msgid ""
"This setting controls usage of the fast update technique described in <xref "
"linkend=\"gin-fast-update\"/>. It is a Boolean parameter: <literal>ON</"
"literal> enables fast update, <literal>OFF</literal> disables it. "
"(Alternative spellings of <literal>ON</literal> and <literal>OFF</literal> "
"are allowed as described in <xref linkend=\"config-setting\"/>.) The default "
"is <literal>ON</literal>."
msgstr ""
"Этот параметр управляет механизмом быстрого обновления, описанным в <xref "
"remap=\"6\" linkend=\"gin-fast-update\"/>. Он имеет логическое значение: "
"<literal>ON</literal> включает быстрое обновление, <literal>OFF</literal> "
"отключает его. (Другие возможные написания <literal>ON</literal> и "
"<literal>OFF</literal> перечислены в <xref remap=\"6\" linkend=\"config-"
"setting\"/>.) Значение по умолчанию — <literal>ON</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:362(para)
msgid ""
"Turning <literal>fastupdate</literal> off via <command>ALTER INDEX</command> "
"prevents future insertions from going into the list of pending index "
"entries, but does not in itself flush previous entries. You might want to "
"<command>VACUUM</command> the table or call "
"<function>gin_clean_pending_list</function> function afterward to ensure the "
"pending list is emptied."
msgstr ""
"Выключение <literal>fastupdate</literal> в <command>ALTER INDEX</command> "
"предотвращает помещение добавляемых в дальнейшем строк в список записей, "
"ожидающих индексации, но записи, добавленные в этот список ранее, в нём "
"остаются. Чтобы очистить очередь операций, надо затем выполнить "
"<command>VACUUM</command> для этой таблицы или вызвать функцию "
"<function>gin_clean_pending_list</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:375(literal)
msgid "gin_pending_list_limit"
msgstr "gin_pending_list_limit"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:377(para)
msgid ""
"Custom <xref linkend=\"guc-gin-pending-list-limit\"/> parameter. This value "
"is specified in kilobytes."
msgstr ""
"Пользовательский параметр <xref linkend=\"guc-gin-pending-list-limit\"/>. "
"Его значение задаётся в килобайтах."

#. +> REL_10
#: ref/create_index.xml:385(para)
msgid "<acronym>BRIN</acronym> indexes accept different parameters:"
msgstr "Индексы <acronym>BRIN</acronym> принимают другие параметры:"

#. +> REL9_6_3 REL9_6
#: ref/create_index.xml:385(para)
msgid "<acronym>BRIN</acronym> indexes accept a different parameter:"
msgstr "Индексы <acronym>BRIN</acronym> принимают другой параметр:"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:391(literal)
msgid "pages_per_range"
msgstr "pages_per_range"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:393(para)
msgid ""
"Defines the number of table blocks that make up one block range for each "
"entry of a <acronym>BRIN</acronym> index (see <xref linkend=\"brin-intro\"/> "
"for more details). The default is <literal>128</literal>."
msgstr ""
"Определяет, сколько блоков таблицы образуют зону блоков для каждой записи в "
"индексе <acronym>BRIN</acronym> (за подробностями обратитесь к <xref remap="
"\"3\" linkend=\"brin-intro\"/>). Значение по умолчанию — <literal>128</"
"literal>."

#. +> REL_10
#: ref/create_index.xml:402(literal)
msgid "autosummarize"
msgstr "autosummarize"

#. +> REL_10
#: ref/create_index.xml:404(para)
msgid ""
"Defines whether a summarization run is invoked for the previous page range "
"whenever an insertion is detected on the next one."
msgstr ""
"Определяет, нужно ли вычислять сводное значение для зоны предыдущей "
"страницы, когда происходит добавление на следующей странице."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:414(title)
msgid "Building Indexes Concurrently"
msgstr "Параллельное построение индексов"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:416(indexterm)
msgid "<primary>index</primary> <secondary>building concurrently</secondary>"
msgstr ""
"<primary>индекс</primary> <secondary>параллельное построение</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:421(para)
msgid ""
"Creating an index can interfere with regular operation of a database. "
"Normally <productname>PostgreSQL</productname> locks the table to be indexed "
"against writes and performs the entire index build with a single scan of the "
"table. Other transactions can still read the table, but if they try to "
"insert, update, or delete rows in the table they will block until the index "
"build is finished. This could have a severe effect if the system is a live "
"production database. Very large tables can take many hours to be indexed, "
"and even for smaller tables, an index build can lock out writers for periods "
"that are unacceptably long for a production system."
msgstr ""
"Создание индекса может мешать обычной работе с базой данных. Обычно "
"<productname>PostgreSQL</productname> блокирует индексируемую таблицу от "
"записи и выполняет всю операцию построения индекса за одно сканирование "
"таблицы. Другие транзакции могут продолжать читать таблицу, но при попытке "
"вставить, изменить или удалить строки в таблице они будут заблокированы до "
"завершения построения индекса. Это может оказать нежелательное влияние на "
"работу производственной базы данных. Индексация очень больших таблиц может "
"занимать много часов, и даже для маленьких таблиц построение индекса может "
"заблокировать записывающие процессы на время, неприемлемое для "
"производственной системы."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:433(para)
msgid ""
"<productname>PostgreSQL</productname> supports building indexes without "
"locking out writes. This method is invoked by specifying the "
"<literal>CONCURRENTLY</literal> option of <command>CREATE INDEX</command>. "
"When this option is used, <productname>PostgreSQL</productname> must perform "
"two scans of the table, and in addition it must wait for all existing "
"transactions that could potentially modify or use the index to terminate. "
"Thus this method requires more total work than a standard index build and "
"takes significantly longer to complete. However, since it allows normal "
"operations to continue while the index is built, this method is useful for "
"adding new indexes in a production environment. Of course, the extra CPU and "
"I/O load imposed by the index creation might slow other operations."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает построение индексов без "
"блокировки записи. Этот метод выбирается указанием <literal>CONCURRENTLY</"
"literal> команды <command>CREATE INDEX</command>. Когда он используется, "
"<productname>PostgreSQL</productname> должен выполнить два сканирования "
"таблицы, а кроме того, должен дождаться завершения всех существующих "
"транзакций, которые потенциально могут модифицировать и использовать этот "
"индекс. Таким образом, эта процедура требует проделать в сумме больше "
"действий и выполняется значительно дольше, чем обычное построение индекса. "
"Однако благодаря тому, что этот метод позволяет продолжать обычную работу с "
"базой во время построения индекса, он оказывается полезным в "
"производственной среде. Хотя разумеется, дополнительная нагрузка на "
"процессор и подсистему ввода/вывода, создаваемая при построении индекса, "
"может привести к замедлению других операций."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:448(para)
msgid ""
"In a concurrent index build, the index is actually entered into the system "
"catalogs in one transaction, then two table scans occur in two more "
"transactions. Before each table scan, the index build must wait for existing "
"transactions that have modified the table to terminate. After the second "
"scan, the index build must wait for any transactions that have a snapshot "
"(see <xref linkend=\"mvcc\"/>) predating the second scan to terminate. Then "
"finally the index can be marked ready for use, and the <command>CREATE "
"INDEX</command> command terminates. Even then, however, the index may not be "
"immediately usable for queries: in the worst case, it cannot be used as long "
"as transactions exist that predate the start of the index build."
msgstr ""
"При параллельном построении индекса он попадает в системный каталог в одной "
"транзакции, затем ещё два сканирования таблицы выполняются в двух других "
"транзакциях. Перед каждым сканированием таблицы процедура построения индекса "
"должна ждать завершения текущих транзакций, модифицировавших эту таблицу. "
"После второго сканирования также необходимо дожидаться завершения всех "
"транзакций, получивших снимок (см. <xref remap=\"4\" linkend=\"mvcc\"/>) "
"перед вторым сканированием. Наконец индекс может быть помечен как готовый к "
"использованию, после чего команда <command>CREATE INDEX</command> "
"завершается. Однако даже тогда индекс может быть не готов немедленно к "
"применению в запросах: в худшем случае он не будет использоваться, пока "
"существуют транзакции, начатые до начала построения индекса."

#. +> REL_10
#: ref/create_index.xml:470(programlisting)
#, no-wrap
msgid ""
"postgres=# \\d tab\n"
"       Table \"public.tab\"\n"
" Column |  Type   | Collation | Nullable | Default \n"
"--------+---------+-----------+----------+---------\n"
" col    | integer |           |          | \n"
"Indexes:\n"
"    \"idx\" btree (col) INVALID"
msgstr ""
"postgres=# \\d tab\n"
"       Table \"public.tab\"\n"
" Column |  Type   | Collation | Nullable | Default \n"
"--------+---------+-----------+----------+---------\n"
" col    | integer |           |          | \n"
"Indexes:\n"
"    \"idx\" btree (col) INVALID"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:462(para)
msgid ""
"If a problem arises while scanning the table, such as a deadlock or a "
"uniqueness violation in a unique index, the <command>CREATE INDEX</command> "
"command will fail but leave behind an <quote>invalid</quote> index. This "
"index will be ignored for querying purposes because it might be incomplete; "
"however it will still consume update overhead. The <application>psql</"
"application> <command>\\d</command> command will report such an index as "
"<literal>INVALID</literal>: <placeholder-1/> The recommended recovery method "
"in such cases is to drop the index and try again to perform <command>CREATE "
"INDEX CONCURRENTLY</command>. (Another possibility is to rebuild the index "
"with <command>REINDEX</command>. However, since <command>REINDEX</command> "
"does not support concurrent builds, this option is unlikely to seem "
"attractive.)"
msgstr ""
"Если при сканировании таблицы возникает проблема, например взаимоблокировка "
"или нарушение уникальности в уникальном индексе, команда <command>CREATE "
"INDEX</command> завершится ошибкой, но оставит после себя <quote>нерабочий</"
"quote> индекс. Этот индекс будет игнорироваться при чтении данных, так как "
"он может быть неполным; однако с ним могут быть связаны дополнительные "
"операции при изменениях. В <application>psql</application> встроенная "
"команда <command>\\d</command> помечает такой индекс как <literal>INVALID</"
"literal>: <placeholder-1/> Рекомендуемый в таких случаях способ исправления "
"ситуации — удалить индекс и затем попытаться снова выполнить <command>CREATE "
"INDEX CONCURRENTLY</command>. (Кроме того, можно перестроить его с помощью "
"команды <command>REINDEX</command>. Но так как <command>REINDEX</command> не "
"поддерживает параллельный режим, вряд ли этот вариант будет желательным.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:488(para)
msgid ""
"Another caveat when building a unique index concurrently is that the "
"uniqueness constraint is already being enforced against other transactions "
"when the second table scan begins. This means that constraint violations "
"could be reported in other queries prior to the index becoming available for "
"use, or even in cases where the index build eventually fails. Also, if a "
"failure does occur in the second scan, the <quote>invalid</quote> index "
"continues to enforce its uniqueness constraint afterwards."
msgstr ""
"Ещё одна сложность, с которой можно столкнуться при параллельном построении "
"уникального индекса, заключается в том, что ограничение уникальности уже "
"влияет на другие транзакции, когда второе сканирование таблицы только "
"начинается. Это значит, что нарушения ограничения могут проявляться в других "
"запросах до того, как индекс становится доступным для использования и даже "
"тогда, когда создать индекс в итоге не удаётся. Кроме того, если при втором "
"сканировании происходит ошибка, <quote>нерабочий</quote> индекс оставляет в "
"силе своё ограничение уникальности и дальше."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:498(para)
msgid ""
"Concurrent builds of expression indexes and partial indexes are supported. "
"Errors occurring in the evaluation of these expressions could cause behavior "
"similar to that described above for unique constraint violations."
msgstr ""
"Метод параллельного построения поддерживает также индексы выражений и "
"частичные индексы. Ошибки, произошедшие при вычислении этих выражений, могут "
"привести к такому же поведению, как в вышеописанных случаях с нарушением "
"ограничений уникальности."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:504(para)
msgid ""
"Regular index builds permit other regular index builds on the same table to "
"occur in parallel, but only one concurrent index build can occur on a table "
"at a time. In both cases, no other types of schema modification on the table "
"are allowed meanwhile. Another difference is that a regular <command>CREATE "
"INDEX</command> command can be performed within a transaction block, but "
"<command>CREATE INDEX CONCURRENTLY</command> cannot."
msgstr ""
"Обычное построение индекса допускает одновременное построение других "
"индексов обычным методом, но параллельное построение в один момент времени "
"допускается только одно. В обоих случаях, никакие изменения типов в схеме "
"таблицы в это время не разрешаются. Другое отличие состоит в том, что в "
"блоке транзакции может быть выполнена обычная команда <command>CREATE INDEX</"
"command>, но не <command>CREATE INDEX CONCURRENTLY</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:516(title)
msgid "Notes"
msgstr "Замечания"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:518(para)
msgid ""
"See <xref linkend=\"indexes\"/> for information about when indexes can be "
"used, when they are not used, and in which particular situations they can be "
"useful."
msgstr ""
"Информацию о том, когда могут применяться, и когда не применяются индексы, и "
"в каких конкретных ситуациях они могут быть полезны, можно найти в <xref "
"remap=\"6\" linkend=\"indexes\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:524(para)
msgid ""
"Currently, only the B-tree, GiST, GIN, and BRIN index methods support "
"multicolumn indexes. Up to 32 fields can be specified by default. (This "
"limit can be altered when building <productname>PostgreSQL</productname>.) "
"Only B-tree currently supports unique indexes."
msgstr ""
"В настоящее время составные индексы поддерживаются только методами B-дерево, "
"GiST, GIN и BRIN. По умолчанию такой индекс может включать до 32 полей. "
"(Этот предел можно изменить, пересобрав <productname>PostgreSQL</"
"productname>.) Уникальные индексы поддерживает только B-дерево."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:532(para)
msgid ""
"An <firstterm>operator class</firstterm> can be specified for each column of "
"an index. The operator class identifies the operators to be used by the "
"index for that column. For example, a B-tree index on four-byte integers "
"would use the <literal>int4_ops</literal> class; this operator class "
"includes comparison functions for four-byte integers. In practice the "
"default operator class for the column's data type is usually sufficient. The "
"main point of having operator classes is that for some data types, there "
"could be more than one meaningful ordering. For example, we might want to "
"sort a complex-number data type either by absolute value or by real part. We "
"could do this by defining two operator classes for the data type and then "
"selecting the proper class when making an index. More information about "
"operator classes is in <xref linkend=\"indexes-opclass\"/> and in <xref "
"linkend=\"xindex\"/>."
msgstr ""
"Для каждого столбца индекса можно задать <firstterm>класс операторов</"
"firstterm>. Этот класс определяет, какие операторы будут использоваться "
"индексом для этого столбца. Например, индекс-B-дерево по четырёхбайтовым "
"целым будет использовать класс <literal>int4_ops</literal>; этот класс "
"операторов включает функции сравнения для таких значений. На практике обычно "
"достаточно использовать класс операторов по умолчанию для типа данных "
"столбца. Существование классов операторов объясняется в первую очередь тем, "
"что для некоторых типов данных можно предложить более одного осмысленного "
"порядка сортировки. Например, может возникнуть желание отсортировать "
"комплексные числа как по абсолютному значению, так и по вещественной части. "
"Это можно сделать, определив два класса операторов для типа данных и выбрав "
"подходящий класс при создании индекса. За дополнительными сведениями о "
"классах операторов обратитесь к <xref remap=\"3\" linkend=\"indexes-opclass"
"\"/> и <xref remap=\"3\" linkend=\"xindex\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:549(para)
msgid ""
"For index methods that support ordered scans (currently, only B-tree), the "
"optional clauses <literal>ASC</literal>, <literal>DESC</literal>, "
"<literal>NULLS FIRST</literal>, and/or <literal>NULLS LAST</literal> can be "
"specified to modify the sort ordering of the index. Since an ordered index "
"can be scanned either forward or backward, it is not normally useful to "
"create a single-column <literal>DESC</literal> index &mdash; that sort "
"ordering is already available with a regular index. The value of these "
"options is that multicolumn indexes can be created that match the sort "
"ordering requested by a mixed-ordering query, such as <literal>SELECT ... "
"ORDER BY x ASC, y DESC</literal>. The <literal>NULLS</literal> options are "
"useful if you need to support <quote>nulls sort low</quote> behavior, rather "
"than the default <quote>nulls sort high</quote>, in queries that depend on "
"indexes to avoid sorting steps."
msgstr ""
"Для методов индекса, поддерживающих сканирование по порядку (в настоящее "
"время это поддерживает только B-дерево), можно изменить порядок сортировки "
"индекса, добавив необязательные предложения <literal>ASC</literal>, "
"<literal>DESC</literal>, <literal>NULLS FIRST</literal> или <literal>NULLS "
"LAST</literal>. Так как упорядоченный индекс можно сканировать вперёд или "
"назад, обычно не имеет смысла создавать индекс по убыванию (<literal>DESC</"
"literal>) для одного столбца &mdash; этот порядок сортировки можно получить "
"и с обычным индексом. Эти параметры имеют смысл при создании составных "
"индексов так, что они будут соответствовать порядку сортировки, указанному в "
"запросе со смешанным порядком, например <literal>SELECT ... ORDER BY x ASC, "
"y DESC</literal>. Параметры <literal>NULLS</literal> полезны, когда "
"требуется реализовать поведение <quote>NULL внизу</quote>, изменив "
"стандартное <quote>NULL вверху</quote>, в запросах, зависящих от индексов, "
"чтобы избежать дополнительной сортировки."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:564(para)
msgid ""
"For most index methods, the speed of creating an index is dependent on the "
"setting of <xref linkend=\"guc-maintenance-work-mem\"/>. Larger values will "
"reduce the time needed for index creation, so long as you don't make it "
"larger than the amount of memory really available, which would drive the "
"machine into swapping."
msgstr ""
"Для большинства методов индексов скорость создания индекса зависит от "
"значения <xref linkend=\"guc-maintenance-work-mem\"/>. Чем больше это "
"значение, тем меньше времени требуется для создания индекса (если только "
"заданное значение не превышает объём действительно доступной памяти, что "
"влечёт за собой использование подкачки)."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:572(para)
msgid "Use <xref linkend=\"sql-dropindex\"/> to remove an index."
msgstr "Для удаления индекса применяется <xref linkend=\"sql-dropindex\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:577(para)
msgid ""
"Prior releases of <productname>PostgreSQL</productname> also had an R-tree "
"index method. This method has been removed because it had no significant "
"advantages over the GiST method. If <literal>USING rtree</literal> is "
"specified, <command>CREATE INDEX</command> will interpret it as "
"<literal>USING gist</literal>, to simplify conversion of old databases to "
"GiST."
msgstr ""
"В предыдущих выпусках <productname>PostgreSQL</productname> также "
"поддерживался метод индекса R-дерево. Сейчас он отсутствует, так как он не "
"даёт значительных преимуществ по сравнению с GiST. Указание <literal>USING "
"rtree</literal> команда <command>CREATE INDEX</command> будет "
"интерпретировать как <literal>USING gist</literal>, для упрощения перевода "
"старых баз на GiST."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:588(title)
msgid "Examples"
msgstr "Примеры"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:593(programlisting)
#, no-wrap
msgid "CREATE UNIQUE INDEX title_idx ON films (title);"
msgstr "CREATE UNIQUE INDEX title_idx ON films (title);"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:590(para)
msgid ""
"To create a B-tree index on the column <literal>title</literal> in the table "
"<literal>films</literal>: <placeholder-1/>"
msgstr ""
"Создание индекса-B-дерева по столбцу <literal>title</literal> в таблице "
"<literal>films</literal>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:601(programlisting)
#, no-wrap
msgid "CREATE INDEX ON films ((lower(title)));"
msgstr "CREATE INDEX ON films ((lower(title)));"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:598(para)
msgid ""
"To create an index on the expression <literal>lower(title)</literal>, "
"allowing efficient case-insensitive searches: <placeholder-1/> (In this "
"example we have chosen to omit the index name, so the system will choose a "
"name, typically <literal>films_lower_idx</literal>.)"
msgstr ""
"Создание индекса по выражению <literal>lower(title)</literal>, позволяющего "
"эффективно выполнять регистронезависимый поиск: <placeholder-1/> (В этом "
"примере мы решили опустить имя индекса, чтобы имя выбрала система, например "
"<literal>films_lower_idx</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:610(programlisting)
#, no-wrap
msgid "CREATE INDEX title_idx_german ON films (title COLLATE \"de_DE\");"
msgstr "CREATE INDEX title_idx_german ON films (title COLLATE \"de_DE\");"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:608(para)
msgid "To create an index with non-default collation: <placeholder-1/>"
msgstr "Создание индекса с нестандартным правилом сортировки: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:617(programlisting)
#, no-wrap
msgid "CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);"
msgstr "CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:615(para)
msgid ""
"To create an index with non-default sort ordering of nulls: <placeholder-1/>"
msgstr ""
"Создание индекса с нестандартным порядком значений NULL: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:624(programlisting)
#, no-wrap
msgid "CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);"
msgstr "CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:622(para)
msgid "To create an index with non-default fill factor: <placeholder-1/>"
msgstr "Создание индекса с нестандартным фактором заполнения: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:631(programlisting)
#, no-wrap
msgid "CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);"
msgstr "CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:629(para)
msgid ""
"To create a <acronym>GIN</acronym> index with fast updates disabled: "
"<placeholder-1/>"
msgstr ""
"Создание индекса <acronym>GIN</acronym> с отключённым механизмом быстрого "
"обновления: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:640(programlisting)
#, no-wrap
msgid "CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;"
msgstr "CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:636(para)
msgid ""
"To create an index on the column <literal>code</literal> in the table "
"<literal>films</literal> and have the index reside in the tablespace "
"<literal>indexspace</literal>: <placeholder-1/>"
msgstr ""
"Создание индекса по столбцу <literal>code</literal> в таблице "
"<literal>films</literal> и размещение его в табличном пространстве "
"<literal>indexspace</literal>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:649(programlisting)
#, no-wrap
msgid ""
"CREATE INDEX pointloc\n"
"    ON points USING gist (box(location,location));\n"
"SELECT * FROM points\n"
"    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;"
msgstr ""
"CREATE INDEX pointloc\n"
"    ON points USING gist (box(location,location));\n"
"SELECT * FROM points\n"
"    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:645(para)
msgid ""
"To create a GiST index on a point attribute so that we can efficiently use "
"box operators on the result of the conversion function: <placeholder-1/>"
msgstr ""
"Создание индекса GiST по координатам точек, позволяющего эффективно "
"использовать операторы box с результатом функции преобразования: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:659(programlisting)
#, no-wrap
msgid "CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);"
msgstr "CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:657(para)
msgid ""
"To create an index without locking out writes to the table: <placeholder-1/>"
msgstr "Создание индекса без блокировки записи в таблицу: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:666(title)
msgid "Compatibility"
msgstr "Совместимость"

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:668(para)
msgid ""
"<command>CREATE INDEX</command> is a <productname>PostgreSQL</productname> "
"language extension. There are no provisions for indexes in the SQL standard."
msgstr ""
"<command>CREATE INDEX</command> является языковым расширением "
"<productname>PostgreSQL</productname>. Средства обеспечения индексов в "
"стандарте SQL не описаны."

#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:676(title)
msgid "See Also"
msgstr "См. также"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: ref/create_index.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: ref/create_index.xml:460(programlisting)
#, no-wrap
msgid ""
"postgres=# \\d tab\n"
"       Table \"public.tab\"\n"
" Column |  Type   | Modifiers \n"
"--------+---------+-----------\n"
" col    | integer | \n"
"Indexes:\n"
"    \"idx\" btree (col) INVALID"
msgstr ""
"postgres=# \\d tab\n"
"       Table \"public.tab\"\n"
" Column |  Type   | Modifiers \n"
"--------+---------+-----------\n"
" col    | integer | \n"
"Indexes:\n"
"    \"idx\" btree (col) INVALID"

#. +> REL9_6_3 REL9_6
#: ref/create_index.xml:515(para)
msgid ""
"Hash index operations are not presently WAL-logged, so hash indexes might "
"need to be rebuilt with <command>REINDEX</command> after a database crash if "
"there were unwritten changes. Also, changes to hash indexes are not "
"replicated over streaming or file-based replication after the initial base "
"backup, so they give wrong answers to queries that subsequently use them. "
"Hash indexes are also not properly restored during point-in-time recovery. "
"For these reasons, hash index use is presently discouraged."
msgstr ""
"Операции с хеш-индексами в настоящее время не проходят через WAL, так что "
"после аварийной остановки базы данных может потребоваться перестроить хеш-"
"индексы командой <command>REINDEX</command>. Кроме того, изменения в хеш-"
"индексах после начальной копии не переносятся при потоковой или файловой "
"репликации, так что в последующих запросах они будут давать неправильные "
"ответы. Также хеш-индексы не приходят в должное состояние при восстановлении "
"на момент времени. По этим причинам настоятельно рекомендуется не "
"использовать их."

#~ msgid ""
#~ "For most index methods, the speed of creating an index is dependent on "
#~ "the setting of <xref linkend=\"guc-maintenance-work-mem\"/>. Larger "
#~ "values will reduce the time needed for index creation, so long as you "
#~ "don't make it larger than the amount of memory really available, which "
#~ "would drive the machine into swapping. For hash indexes, the value of "
#~ "<xref linkend=\"guc-effective-cache-size\"/> is also relevant to index "
#~ "creation time: <productname>PostgreSQL</productname> will use one of two "
#~ "different hash index creation methods depending on whether the estimated "
#~ "index size is more or less than <varname>effective_cache_size</varname>. "
#~ "For best results, make sure that this parameter is also set to something "
#~ "reflective of available memory, and be careful that the sum of "
#~ "<varname>maintenance_work_mem</varname> and "
#~ "<varname>effective_cache_size</varname> is less than the machine's RAM "
#~ "less whatever space is needed by other programs."
#~ msgstr ""
#~ "Для большинства методов индексов скорость создания индекса зависит от "
#~ "значения <xref linkend=\"guc-maintenance-work-mem\"/>. При увеличении "
#~ "этого значения индекс будет создаваться быстрее, пока оно не превысит "
#~ "действительно доступный объём памяти, что приведёт к использованию "
#~ "подкачки. Для хеш-индексов значение <xref linkend=\"guc-effective-cache-"
#~ "size\"/> также влияет на время создания индекса: <productname>PostgreSQL</"
#~ "productname> будет использовать один из двух различных методов создания "
#~ "индекса, в зависимости от того, больше или меньше оцениваемый размер "
#~ "индекса, чем <varname>effective_cache_size</varname>. Для наилучших "
#~ "результатов этот параметр нужно устанавливать в зависимости от объёма "
#~ "свободной памяти, но так, чтобы сумма <varname>maintenance_work_mem</"
#~ "varname> и <varname>effective_cache_size</varname> была меньше объёма ОЗУ "
#~ "за вычетом объёма, необходимого другим программам."
