# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ref/create_cast.xml:5(indexterm)
msgid "<primary>CREATE CAST</primary>"
msgstr "<primary>CREATE CAST</primary>"

#: ref/create_cast.xml:10(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE CAST"
msgstr "CREATE CAST"

#: ref/create_cast.xml:11(manvolnum)
msgid "7"
msgstr "7"

#: ref/create_cast.xml:12(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#: ref/create_cast.xml:16(refname)
msgctxt "refname"
msgid "CREATE CAST"
msgstr "CREATE CAST"

#: ref/create_cast.xml:17(refpurpose)
msgid "define a new cast"
msgstr "создать приведение"

#: ref/create_cast.xml:22(replaceable) ref/create_cast.xml:26(replaceable)
#: ref/create_cast.xml:30(replaceable) ref/create_cast.xml:176(replaceable)
msgid "source_type"
msgstr "исходный_тип"

#: ref/create_cast.xml:22(replaceable) ref/create_cast.xml:26(replaceable)
#: ref/create_cast.xml:30(replaceable) ref/create_cast.xml:186(replaceable)
msgid "target_type"
msgstr "целевой_тип"

#: ref/create_cast.xml:23(replaceable)
msgid "function_name"
msgstr "имя_функции"

#: ref/create_cast.xml:23(replaceable)
msgid "argument_type"
msgstr "тип_аргумента"

#: ref/create_cast.xml:21(synopsis)
#, no-wrap
msgid ""
"CREATE CAST (<placeholder-1/> AS <placeholder-2/>)\n"
"    WITH FUNCTION <placeholder-3/> (<placeholder-4/> [, ...])\n"
"    [ AS ASSIGNMENT | AS IMPLICIT ]\n"
"\n"
"CREATE CAST (<placeholder-5/> AS <placeholder-6/>)\n"
"    WITHOUT FUNCTION\n"
"    [ AS ASSIGNMENT | AS IMPLICIT ]\n"
"\n"
"CREATE CAST (<placeholder-7/> AS <placeholder-8/>)\n"
"    WITH INOUT\n"
"    [ AS ASSIGNMENT | AS IMPLICIT ]"
msgstr ""
"CREATE CAST (<placeholder-1/> AS <placeholder-2/>)\n"
"    WITH FUNCTION <placeholder-3/> (<placeholder-4/> [, ...])\n"
"    [ AS ASSIGNMENT | AS IMPLICIT ]\n"
"\n"
"CREATE CAST (<placeholder-5/> AS <placeholder-6/>)\n"
"    WITHOUT FUNCTION\n"
"    [ AS ASSIGNMENT | AS IMPLICIT ]\n"
"\n"
"CREATE CAST (<placeholder-7/> AS <placeholder-8/>)\n"
"    WITH INOUT\n"
"    [ AS ASSIGNMENT | AS IMPLICIT ]"

#: ref/create_cast.xml:37(title)
msgid "Description"
msgstr "Описание"

#: ref/create_cast.xml:43(programlisting)
#, no-wrap
msgid "SELECT CAST(42 AS float8);"
msgstr "SELECT CAST(42 AS float8);"

#: ref/create_cast.xml:39(para)
msgid ""
"<command>CREATE CAST</command> defines a new cast. A cast specifies how to "
"perform a conversion between two data types. For example, <placeholder-1/> "
"converts the integer constant 42 to type <type>float8</type> by invoking a "
"previously specified function, in this case <literal>float8(int4)</literal>. "
"(If no suitable cast has been defined, the conversion fails.)"
msgstr ""
"<command>CREATE CAST</command> создаёт новое приведение. Приведение "
"определяет, как выполнить преобразование из одного типа в другой. Например, "
"<placeholder-1/> преобразует целочисленную константу 42 к типу <type>float8</"
"type>, вызывая ранее определённую функцию, в данном случае "
"<literal>float8(int4)</literal>. (Если подходящее приведение не определено, "
"возникнет ошибка преобразования.)"

#: ref/create_cast.xml:52(para)
msgid ""
"Two types can be <firstterm>binary coercible</firstterm>, which means that "
"the conversion can be performed <quote>for free</quote> without invoking any "
"function. This requires that corresponding values use the same internal "
"representation. For instance, the types <type>text</type> and <type>varchar</"
"type> are binary coercible both ways. Binary coercibility is not necessarily "
"a symmetric relationship. For example, the cast from <type>xml</type> to "
"<type>text</type> can be performed for free in the present implementation, "
"but the reverse direction requires a function that performs at least a "
"syntax check. (Two types that are binary coercible both ways are also "
"referred to as binary compatible.)"
msgstr ""
"Два типа могут быть <firstterm>двоично-сводимыми</firstterm>; это означает, "
"что преобразование может быть выполнено <quote>бесплатно</quote>, без вызова "
"какой-либо функции. Для этого требуется, чтобы соответствующие значения "
"имели одинаковое внутреннее представление. Например, типы <type>text</type> "
"и <type>varchar</type> двоично-сводимые в обе стороны. Отношение двоичной "
"сводимости не обязательно симметрично. Например, приведение типа <type>xml</"
"type> к типу <type>text</type> в текущей реализации можно выполнить "
"бесплатно, но для преобразования в обратном направлении требуется функция, "
"выполняющая как минимум синтаксическую проверку. (Два типа, двоично-сводимые "
"в обе стороны, также называются двоично-совместимыми.)"

#: ref/create_cast.xml:67(para)
msgid ""
"You can define a cast as an <firstterm>I/O conversion cast</firstterm> by "
"using the <literal>WITH INOUT</literal> syntax. An I/O conversion cast is "
"performed by invoking the output function of the source data type, and "
"passing the resulting string to the input function of the target data type. "
"In many common cases, this feature avoids the need to write a separate cast "
"function for conversion. An I/O conversion cast acts the same as a regular "
"function-based cast; only the implementation is different."
msgstr ""
"Приведение можно определить как <firstterm>преобразование ввода/вывода</"
"firstterm>, используя указание <literal>WITH INOUT</literal>. В этом случае "
"для приведения одного типа к другому вызывается функция вывода исходного "
"типа данных, а выданная ей строка передаётся функции ввода целевого типа. Во "
"многих случаях эта возможность избавляет от необходимости писать для "
"преобразования всех типов отдельные функции приведения. Преобразование ввода/"
"вывода работает так же, как и обычное приведение с функцией; отличается "
"только реализация."

#: ref/create_cast.xml:77(para)
msgid ""
"By default, a cast can be invoked only by an explicit cast request, that is "
"an explicit <literal>CAST(<replaceable>x</replaceable> AS "
"<replaceable>typename</replaceable>)</literal> or <replaceable>x</"
"replaceable><literal>::</literal><replaceable>typename</replaceable> "
"construct."
msgstr ""
"По умолчанию, приведение можно вызвать, только записав его явно, то есть "
"применив конструкцию <literal>CAST(<replaceable>x</replaceable> AS "
"<replaceable>имя_типа</replaceable>)</literal> или <replaceable>x</"
"replaceable><literal>::</literal><replaceable>имя_типа</replaceable>."

#: ref/create_cast.xml:90(programlisting)
#, no-wrap
msgid "INSERT INTO foo (f1) VALUES (42);"
msgstr "INSERT INTO foo (f1) VALUES (42);"

#: ref/create_cast.xml:85(para)
msgid ""
"If the cast is marked <literal>AS ASSIGNMENT</literal> then it can be "
"invoked implicitly when assigning a value to a column of the target data "
"type. For example, supposing that <literal>foo.f1</literal> is a column of "
"type <type>text</type>, then: <placeholder-1/> will be allowed if the cast "
"from type <type>integer</type> to type <type>text</type> is marked "
"<literal>AS ASSIGNMENT</literal>, otherwise not. (We generally use the term "
"<firstterm>assignment cast</firstterm> to describe this kind of cast.)"
msgstr ""
"Если приведение помечено <literal>AS ASSIGNMENT</literal>, его можно "
"вызывать неявно, присваивая значение столбцу с целевым типом данных. "
"Например, если <literal>foo.f1</literal> — столбец типа <type>text</type>, "
"то команда: <placeholder-1/> будет допустимой, если приведение типа "
"<type>integer</type> к <type>text</type> помечено <literal>AS ASSIGNMENT</"
"literal>, и не будет в противном случае. (Для описания такого типа "
"приведений мы обычно используем термин <firstterm>приведение присваивания</"
"firstterm>.)"

#: ref/create_cast.xml:105(programlisting)
#, no-wrap
msgid "SELECT 2 + 4.0;"
msgstr "SELECT 2 + 4.0;"

#: ref/create_cast.xml:116(programlisting)
#, no-wrap
msgid "SELECT CAST ( 2 AS numeric ) + 4.0;"
msgstr "SELECT CAST ( 2 AS numeric ) + 4.0;"

#: ref/create_cast.xml:99(para)
msgid ""
"If the cast is marked <literal>AS IMPLICIT</literal> then it can be invoked "
"implicitly in any context, whether assignment or internally in an "
"expression. (We generally use the term <firstterm>implicit cast</firstterm> "
"to describe this kind of cast.) For example, consider this query: "
"<placeholder-1/> The parser initially marks the constants as being of type "
"<type>integer</type> and <type>numeric</type> respectively. There is no "
"<type>integer</type> <literal>+</literal> <type>numeric</type> operator in "
"the system catalogs, but there is a <type>numeric</type> <literal>+</"
"literal> <type>numeric</type> operator. The query will therefore succeed if "
"a cast from <type>integer</type> to <type>numeric</type> is available and is "
"marked <literal>AS IMPLICIT</literal> &mdash; which in fact it is. The "
"parser will apply the implicit cast and resolve the query as if it had been "
"written <placeholder-2/>"
msgstr ""
"Если приведение помечено <literal>AS IMPLICIT</literal>, оно будет "
"вызываться неявно в любом контексте, будь то присваивание или внутреннее "
"преобразование в выражении. (Обычно мы называет приведение такого типа "
"<firstterm>неявным приведением</firstterm>.) Например, рассмотрите этот "
"запрос: <placeholder-1/> При разборе запроса константам сначала назначаются "
"типы <type>integer</type> и <type>numeric</type>. Однако в системных "
"каталогах нет оператора <type>integer</type> <literal>+</literal> "
"<type>numeric</type>, хотя есть оператор <type>numeric</type> <literal>+</"
"literal> <type>numeric</type>. Таким образом, запрос выполнится успешно, "
"если существует преобразование типа <type>integer</type> к <type>numeric</"
"type> с пометкой <literal>AS IMPLICIT</literal> &mdash; и на самом деле это "
"так. Анализатор запроса применит неявное приведение и запрос будет "
"обработан, как если бы он был записан в виде <placeholder-2/>"

#: ref/create_cast.xml:121(para)
msgid ""
"Now, the catalogs also provide a cast from <type>numeric</type> to "
"<type>integer</type>. If that cast were marked <literal>AS IMPLICIT</"
"literal> &mdash; which it is not &mdash; then the parser would be faced with "
"choosing between the above interpretation and the alternative of casting the "
"<type>numeric</type> constant to <type>integer</type> and applying the "
"<type>integer</type> <literal>+</literal> <type>integer</type> operator. "
"Lacking any knowledge of which choice to prefer, it would give up and "
"declare the query ambiguous. The fact that only one of the two casts is "
"implicit is the way in which we teach the parser to prefer resolution of a "
"mixed <type>numeric</type>-and-<type>integer</type> expression as "
"<type>numeric</type>; there is no built-in knowledge about that."
msgstr ""
"Системные каталоги также содержат приведение типа <type>numeric</type> к "
"<type>integer</type>. Если бы это приведение тоже было бы помечено "
"<literal>AS IMPLICIT</literal> (на самом деле это не так), анализатору "
"запроса пришлось бы выбирать между предыдущим вариантом и приведением "
"константы <type>numeric</type> к типу <type>integer</type> с последующим "
"применением оператора <type>integer</type> <literal>+</literal> "
"<type>integer</type>. Не имея возможности выбрать лучший вариант, анализатор "
"бы не смог разрешить запрос и объявил бы его неоднозначным. Именно благодаря "
"тому, что только одно из двух приведений сделано неявным, анализатор "
"приходит к пониманию, что предпочитаемым является преобразование выражения "
"<type>numeric</type>-и-<type>integer</type> в <type>numeric</type>; "
"отдельного встроенного знания об этом нет."

#: ref/create_cast.xml:135(para)
msgid ""
"It is wise to be conservative about marking casts as implicit. An "
"overabundance of implicit casting paths can cause <productname>PostgreSQL</"
"productname> to choose surprising interpretations of commands, or to be "
"unable to resolve commands at all because there are multiple possible "
"interpretations. A good rule of thumb is to make a cast implicitly invokable "
"only for information-preserving transformations between types in the same "
"general type category. For example, the cast from <type>int2</type> to "
"<type>int4</type> can reasonably be implicit, but the cast from "
"<type>float8</type> to <type>int4</type> should probably be assignment-only. "
"Cross-type-category casts, such as <type>text</type> to <type>int4</type>, "
"are best made explicit-only."
msgstr ""
"Определяя, объявлять ли приведения неявными, разумно проявлять консерватизм. "
"При чрезмерном количестве способов неявного приведения "
"<productname>PostgreSQL</productname> может выбирать неожиданные "
"интерпретации команд, или вовсе не сможет выполнить команды из-за наличия "
"множества возможных интерпретаций. Как правило, следует делать приведение "
"неявно вызываемым только для преобразований, сохраняющих информацию, между "
"типами в одной общей категории типов. Например, приведение <type>int2</type> "
"к <type>int4</type> разумно сделать неявным, но приведение <type>float8</"
"type> к <type>int4</type>, возможно, лучше сделать только приведением "
"присваивания. Приведения типов разных категорий, например, <type>text</type> "
"к <type>int4</type>, лучше делать только явными."

#: ref/create_cast.xml:151(para)
msgid ""
"Sometimes it is necessary for usability or standards-compliance reasons to "
"provide multiple implicit casts among a set of types, resulting in ambiguity "
"that cannot be avoided as above. The parser has a fallback heuristic based "
"on <firstterm>type categories</firstterm> and <firstterm>preferred types</"
"firstterm> that can help to provide desired behavior in such cases. See "
"<xref linkend=\"sql-createtype\"/> for more information."
msgstr ""
"Иногда ради удобства или соответствия стандартам требуется ввести множество "
"неявных преобразований для нескольких типов, что приводит к неизбежной "
"неоднозначности. Чтобы анализатор запроса мог обеспечить желаемое поведение "
"в таких случаях, он дополнительно принимает во внимание <firstterm>категории "
"типов</firstterm> и <firstterm>предпочитаемые типы</firstterm>. Подробнее "
"это описано в <xref remap=\"6\" linkend=\"sql-createtype\"/>."

#: ref/create_cast.xml:162(para)
msgid ""
"To be able to create a cast, you must own the source or the target data type "
"and have <literal>USAGE</literal> privilege on the other type. To create a "
"binary-coercible cast, you must be superuser. (This restriction is made "
"because an erroneous binary-coercible cast conversion can easily crash the "
"server.)"
msgstr ""
"Чтобы создать приведение, необходимо быть владельцем одного (исходного или "
"целевого) типа и иметь право <literal>USAGE</literal> для другого типа. "
"Создать двоично-сводимое приведение могут только суперпользователи. (Это "
"ограничение введено потому, что преобразование данных с ошибочным двоичным "
"сведением может легко вызывать сбой сервера.)"

#: ref/create_cast.xml:172(title)
msgid "Parameters"
msgstr "Параметры"

#: ref/create_cast.xml:179(para)
msgid "The name of the source data type of the cast."
msgstr "Имя исходного типа данных для приведения."

#: ref/create_cast.xml:189(para)
msgid "The name of the target data type of the cast."
msgstr "Имя целевого типа данных для приведения."

#: ref/create_cast.xml:196(term)
msgid ""
"<replaceable>function_name</replaceable>(<replaceable>argument_type</"
"replaceable> [, ...])"
msgstr ""
"<replaceable>имя_функции</replaceable>(<replaceable>тип_аргумента</"
"replaceable> [, ...])"

#: ref/create_cast.xml:199(para)
msgid ""
"The function used to perform the cast. The function name can be schema-"
"qualified. If it is not, the function will be looked up in the schema search "
"path. The function's result data type must match the target type of the "
"cast. Its arguments are discussed below."
msgstr ""
"Функция, вызываемая для выполнения приведения. Имя функции может быть "
"дополнено схемой, в противном случае для поиска функции просматривается путь "
"поиска. Тип данных результата должен соответствовать целевому типу "
"приведения. Аргументы функции рассматриваются ниже."

#: ref/create_cast.xml:209(literal)
msgid "WITHOUT FUNCTION"
msgstr "WITHOUT FUNCTION"

#: ref/create_cast.xml:212(para)
msgid ""
"Indicates that the source type is binary-coercible to the target type, so no "
"function is required to perform the cast."
msgstr ""
"Обозначает, что исходный тип сводится к целевому на двоичном уровне, так что "
"функция для приведения не требуется."

#: ref/create_cast.xml:220(literal)
msgid "WITH INOUT"
msgstr "WITH INOUT"

#: ref/create_cast.xml:223(para)
msgid ""
"Indicates that the cast is an I/O conversion cast, performed by invoking the "
"output function of the source data type, and passing the resulting string to "
"the input function of the target data type."
msgstr ""
"Обозначает, что приведение выполняется как преобразование ввода/вывода, то "
"есть вызывается функция вывода исходного типа данных, а её результат-строка "
"передаётся функции ввода целевого типа."

#: ref/create_cast.xml:232(literal)
msgid "AS ASSIGNMENT"
msgstr "AS ASSIGNMENT"

#: ref/create_cast.xml:235(para)
msgid ""
"Indicates that the cast can be invoked implicitly in assignment contexts."
msgstr ""
"Обозначает, что приведение может вызываться неявно в контексте присваивания."

#: ref/create_cast.xml:243(literal)
msgid "AS IMPLICIT"
msgstr "AS IMPLICIT"

#: ref/create_cast.xml:246(para)
msgid "Indicates that the cast can be invoked implicitly in any context."
msgstr "Обозначает, что приведение может вызываться неявно в любом контексте."

#: ref/create_cast.xml:253(para)
msgid ""
"Cast implementation functions can have one to three arguments. The first "
"argument type must be identical to or binary-coercible from the cast's "
"source type. The second argument, if present, must be type <type>integer</"
"type>; it receives the type modifier associated with the destination type, "
"or <literal>-1</literal> if there is none. The third argument, if present, "
"must be type <type>boolean</type>; it receives <literal>true</literal> if "
"the cast is an explicit cast, <literal>false</literal> otherwise. "
"(Bizarrely, the SQL standard demands different behaviors for explicit and "
"implicit casts in some cases. This argument is supplied for functions that "
"must implement such casts. It is not recommended that you design your own "
"data types so that this matters.)"
msgstr ""
"Функции, реализующие приведение, могут иметь от одного до трёх аргументов. "
"Тип первого аргумента должен быть идентичен или двоично-сводимым к исходному "
"типу приведения. Второй аргумент, если он есть, должен иметь тип "
"<type>integer</type>; в нём передаётся модификатор типа, связанный с целевым "
"типом, или <literal>-1</literal>, если он отсутствует. Третий аргумент, если "
"он есть, должен иметь тип <type>boolean</type>; в нём передаётся "
"<literal>true</literal>, если приведение выполняется явно, либо "
"<literal>false</literal> в противном случае. (Это довольно экстравагантно, "
"но стандарт SQL предусматривает разное поведение для явного и неявного "
"приведения в некоторых случаях. Этот аргумент предназначен для функций, "
"которые должны реализовывать такие приведения. Однако создавать собственные "
"типы данных, для которых это имело бы значение, не рекомендуется.)"

#: ref/create_cast.xml:268(para)
msgid ""
"The return type of a cast function must be identical to or binary-coercible "
"to the cast's target type."
msgstr ""
"Возвращаемый тип функции приведения должен быть идентичным или двоично-"
"сводимым к целевому типу приведения."

#: ref/create_cast.xml:273(para)
msgid ""
"Ordinarily a cast must have different source and target data types. However, "
"it is allowed to declare a cast with identical source and target types if it "
"has a cast implementation function with more than one argument. This is used "
"to represent type-specific length coercion functions in the system catalogs. "
"The named function is used to coerce a value of the type to the type "
"modifier value given by its second argument."
msgstr ""
"Обычно исходный и целевой типы в приведении различаются, однако можно "
"объявить приведение одного типа к такому же, если функция, реализующая "
"преобразование, имеет более одного аргумента. Это используется для "
"представления в системных каталогах функций, сводящих разные длины типов. "
"Реализующая такое приведение функция будет сводить значение типа к значению "
"с определённым модификатором, заданному вторым аргументом."

#: ref/create_cast.xml:283(para)
msgid ""
"When a cast has different source and target types and a function that takes "
"more than one argument, it supports converting from one type to another and "
"applying a length coercion in a single step. When no such entry is "
"available, coercion to a type that uses a type modifier involves two cast "
"steps, one to convert between data types and a second to apply the modifier."
msgstr ""
"Когда исходный и целевой типы приведения различаются и функция принимает "
"более одного аргумента, преобразование типа из одного в другой и сведение к "
"нужной длине может выполняться за один шаг. Если же соответствующей записи "
"не находится, приведение к типу с определённым модификатором выполняется в "
"два этапа: сначала выполняется преобразование типа, а затем применяется "
"модификатор типа."

#: ref/create_cast.xml:292(para)
msgid ""
"A cast to or from a domain type currently has no effect. Casting to or from "
"a domain uses the casts associated with its underlying type."
msgstr ""
"Приведение типа домена или к типу домена в настоящее время не "
"осуществляется. При попытке выполнить такое приведение вместо него "
"выполняется приведение, связанное с базовым типом домена."

#: ref/create_cast.xml:300(title)
msgid "Notes"
msgstr "Замечания"

#: ref/create_cast.xml:302(para)
msgid "Use <xref linkend=\"sql-dropcast\"/> to remove user-defined casts."
msgstr ""
"Для удаления приведений, созданных пользователем, применяется <xref linkend="
"\"sql-dropcast\"/>."

#: ref/create_cast.xml:306(para)
msgid ""
"Remember that if you want to be able to convert types both ways you need to "
"declare casts both ways explicitly."
msgstr ""
"Помните, что когда требуется преобразовывать типы в обе стороны, необходимо "
"явно описать два приведения."

#: ref/create_cast.xml:311(indexterm)
msgid "<primary>cast</primary> <secondary>I/O conversion</secondary>"
msgstr ""
"<primary>приведение</primary> <secondary>преобразование ввода/вывода</"
"secondary>"

#: ref/create_cast.xml:316(para)
msgid ""
"It is normally not necessary to create casts between user-defined types and "
"the standard string types (<type>text</type>, <type>varchar</type>, and "
"<type>char(<replaceable>n</replaceable>)</type>, as well as user-defined "
"types that are defined to be in the string category). "
"<productname>PostgreSQL</productname> provides automatic I/O conversion "
"casts for that. The automatic casts to string types are treated as "
"assignment casts, while the automatic casts from string types are explicit-"
"only. You can override this behavior by declaring your own cast to replace "
"an automatic cast, but usually the only reason to do so is if you want the "
"conversion to be more easily invokable than the standard assignment-only or "
"explicit-only setting. Another possible reason is that you want the "
"conversion to behave differently from the type's I/O function; but that is "
"sufficiently surprising that you should think twice about whether it's a "
"good idea. (A small number of the built-in types do indeed have different "
"behaviors for conversions, mostly because of requirements of the SQL "
"standard.)"
msgstr ""
"Обычно не требуется создавать приведения между пользовательскими типами и "
"стандартными строковыми типами (<type>text</type>, <type>varchar</type> и "
"<type>char(<replaceable>n</replaceable>)</type>, а также пользовательскими "
"типами, относящимися к категории строковых). Для них "
"<productname>PostgreSQL</productname> предоставляет автоматическое "
"преобразование ввода/вывода. Автоматические приведения к строковым типам "
"считаются приведениями присваивания, а автоматические приведения строковых "
"типов к другим могут быть только явными. Это поведение можно переопределить, "
"создав собственное приведение, заменяющее автоматическое, но обычно это "
"нужно, только чтобы сделать вызов более удобным, чем стандартное только "
"присваивание или явное указание. Возможен и другой повод для такого "
"переопределения — желание создать приведение, работающее не так, как функция "
"ввода/вывода типа; но это настолько удивительно, что следует дважды "
"подумать, хороша ли эта идея. (На самом деле у небольшого количества "
"встроенных типов имеются подобные специфические приведения, в основном из-за "
"требований стандарта SQL.)"

#: ref/create_cast.xml:335(para)
msgid ""
"While not required, it is recommended that you continue to follow this old "
"convention of naming cast implementation functions after the target data "
"type. Many users are used to being able to cast data types using a function-"
"style notation, that is <replaceable>typename</replaceable>(<replaceable>x</"
"replaceable>). This notation is in fact nothing more nor less than a call of "
"the cast implementation function; it is not specially treated as a cast. If "
"your conversion functions are not named to support this convention then you "
"will have surprised users. Since <productname>PostgreSQL</productname> "
"allows overloading of the same function name with different argument types, "
"there is no difficulty in having multiple conversion functions from "
"different types that all use the target type's name."
msgstr ""
"Хотя это и не обязательно, но рекомендуется следовать старому соглашению "
"называть функции, реализующие приведение, по целевому типу данных. Многие "
"привыкли выполнять преобразование типов данных, записывая его в стиле "
"функций, т. е. <replaceable>имя_типа</replaceable>(<replaceable>x</"
"replaceable>). Эта запись на самом деле ни больше ни меньше как просто вызов "
"функции, реализующей приведение; такой вызов не воспринимается как именно "
"приведение. Если называть функции, не следуя этому соглашению, это может "
"оказаться неожиданным для пользователей. Так как <productname>PostgreSQL</"
"productname> позволяет перегружать одно и то же имя функции с разными типами "
"аргументов, ничто не мешает создать множество функций приведения разных "
"типов к одному, названных по имени этого целевого типа."

#: ref/create_cast.xml:351(para)
msgid ""
"Actually the preceding paragraph is an oversimplification: there are two "
"cases in which a function-call construct will be treated as a cast request "
"without having matched it to an actual function. If a function call "
"<replaceable>name</replaceable>(<replaceable>x</replaceable>) does not "
"exactly match any existing function, but <replaceable>name</replaceable> is "
"the name of a data type and <structname>pg_cast</structname> provides a "
"binary-coercible cast to this type from the type of <replaceable>x</"
"replaceable>, then the call will be construed as a binary-coercible cast. "
"This exception is made so that binary-coercible casts can be invoked using "
"functional syntax, even though they lack any function. Likewise, if there is "
"no <structname>pg_cast</structname> entry but the cast would be to or from a "
"string type, the call will be construed as an I/O conversion cast. This "
"exception allows I/O conversion casts to be invoked using functional syntax."
msgstr ""
"Вообще говоря, в предыдущем абзаце допущено некоторое упрощение: есть два "
"случая, когда конструкция с вызовом функции исполняется как приведение, без "
"сопоставления с фактической функцией. Если вызову функции <replaceable>имя</"
"replaceable>(<replaceable>x</replaceable>) в точности не соответствует "
"существующая функция, но имеется тип данных <replaceable>имя</replaceable> и "
"в <structname>pg_cast</structname> есть двоично-сводимое приведение типа "
"<replaceable>x</replaceable> к этому типу, такой вызов будет воспринят как "
"приведение. Это исключение введено, чтобы двоично-сводимое приведение можно "
"было вызывать, используя синтаксис функций, несмотря на то, что никакой "
"функции преобразования у него нет. Аналогично, если запись приведения в "
"<structname>pg_cast</structname> отсутствует, но в случае приведения это "
"было бы преобразование в/из строкового типа, такой вызов будет выполнен как "
"преобразование ввода/вывода. Это исключение позволяет вызывать "
"преобразование ввода/вывода, используя синтаксис вызова функции."

#: ref/create_cast.xml:370(para)
msgid ""
"There is also an exception to the exception: I/O conversion casts from "
"composite types to string types cannot be invoked using functional syntax, "
"but must be written in explicit cast syntax (either <literal>CAST</literal> "
"or <literal>::</literal> notation). This exception was added because after "
"the introduction of automatically-provided I/O conversion casts, it was "
"found too easy to accidentally invoke such a cast when a function or column "
"reference was intended."
msgstr ""
"Но есть исключение и из этого исключения: преобразование ввода/вывода из "
"составных типов в строковые нельзя вызвать в виде функции, его необходимо "
"записать как явное приведение (используя <literal>CAST</literal> или запись "
"<literal>::</literal>). Это исключение было добавлено, потому что после "
"введения автоматически предоставляемых преобразований ввода/вывода, "
"оказалось слишком легко случайно вызвать такое приведение, тогда как имелась "
"в виду ссылка на столбец или функцию."

#: ref/create_cast.xml:384(title)
msgid "Examples"
msgstr "Примеры"

#: ref/create_cast.xml:389(programlisting)
#, no-wrap
msgid "CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;"
msgstr "CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;"

#: ref/create_cast.xml:386(para)
msgid ""
"To create an assignment cast from type <type>bigint</type> to type "
"<type>int4</type> using the function <literal>int4(bigint)</literal>: "
"<placeholder-1/> (This cast is already predefined in the system.)"
msgstr ""
"Создание приведения присваивания типа <type>bigint</type> к типу <type>int4</"
"type> с помощью функции <literal>int4(bigint)</literal>: <placeholder-1/> "
"(Это приведение уже предопределено в системе.)"

#: ref/create_cast.xml:397(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ref/create_cast.xml:399(para)
msgid ""
"The <command>CREATE CAST</command> command conforms to the <acronym>SQL</"
"acronym> standard, except that SQL does not make provisions for binary-"
"coercible types or extra arguments to implementation functions. <literal>AS "
"IMPLICIT</literal> is a <productname>PostgreSQL</productname> extension, too."
msgstr ""
"Команда <command>CREATE CAST</command> соответствует стандарту <acronym>SQL</"
"acronym>, за исключением того, что в стандарте ничего не говорится о двоично-"
"сводимых типах и дополнительных аргументах реализующих функций. Указание "
"<literal>AS IMPLICIT</literal> тоже является расширением "
"<productname>PostgreSQL</productname>."

#: ref/create_cast.xml:411(title)
msgid "See Also"
msgstr "См. также"

#: ref/create_cast.xml:413(para)
msgid ""
"<xref linkend=\"sql-createfunction\"/>, <xref linkend=\"sql-createtype\"/>, "
"<xref linkend=\"sql-dropcast\"/>"
msgstr ""
"<xref linkend=\"sql-createfunction\"/>, <xref linkend=\"sql-createtype\"/>, "
"<xref linkend=\"sql-dropcast\"/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ref/create_cast.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
