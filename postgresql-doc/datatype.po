# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-18 10:07+0300\n"
"PO-Revision-Date: 2017-09-28 16:29+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:5(title) datatype.xml:33(title)
msgid "Data Types"
msgstr "Типы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:7(indexterm)
msgid "<primary>data type</primary>"
msgstr "<primary>тип данных</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:11(indexterm)
msgid "<primary>type</primary> <see>data type</see>"
msgstr "<primary>тип</primary> <see>тип данных</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:16(para)
msgid ""
"<productname>PostgreSQL</productname> has a rich set of native data types "
"available to users. Users can add new types to <productname>PostgreSQL</"
"productname> using the <xref linkend=\"sql-createtype\"/> command."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет пользователям богатый "
"ассортимент встроенных типов данных. Кроме того, пользователи могут "
"создавать свои типы в <productname>PostgreSQL</productname>, используя "
"команду <xref linkend=\"sql-createtype\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:23(para)
msgid ""
"<xref linkend=\"datatype-table\"/> shows all the built-in general-purpose "
"data types. Most of the alternative names listed in the <quote>Aliases</"
"quote> column are the names used internally by <productname>PostgreSQL</"
"productname> for historical reasons. In addition, some internally used or "
"deprecated types are available, but are not listed here."
msgstr ""
"<xref linkend=\"datatype-table\"/> содержит все встроенные типы данных "
"общего пользования. Многие из альтернативных имён, приведённых в столбце "
"<quote>Псевдонимы</quote>, используются внутри <productname>PostgreSQL</"
"productname> по историческим причинам. В этот список не включены некоторые "
"устаревшие типы и типы для внутреннего применения."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:37(entry) datatype.xml:349(entry) datatype.xml:947(entry)
#: datatype.xml:1045(entry) datatype.xml:1238(entry) datatype.xml:1281(entry)
#: datatype.xml:1588(entry) datatype.xml:2862(entry) datatype.xml:3100(entry)
#: datatype.xml:3426(entry) datatype.xml:4481(entry) datatype.xml:4755(entry)
msgid "Name"
msgstr "Имя"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:38(entry)
msgid "Aliases"
msgstr "Псевдонимы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:39(entry) datatype.xml:351(entry) datatype.xml:949(entry)
#: datatype.xml:1046(entry) datatype.xml:1240(entry) datatype.xml:1283(entry)
#: datatype.xml:1399(entry) datatype.xml:1490(entry) datatype.xml:1590(entry)
#: datatype.xml:1773(entry) datatype.xml:1894(entry) datatype.xml:1956(entry)
#: datatype.xml:2134(entry) datatype.xml:2236(entry) datatype.xml:2710(entry)
#: datatype.xml:2864(entry) datatype.xml:3102(entry) datatype.xml:3428(entry)
#: datatype.xml:4483(entry) datatype.xml:4756(entry)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:45(type) datatype.xml:370(type)
msgid "bigint"
msgstr "bigint"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:46(type)
msgid "int8"
msgstr "int8"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:47(entry)
msgid "signed eight-byte integer"
msgstr "знаковое целое из 8 байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:51(type) datatype.xml:417(type)
msgid "bigserial"
msgstr "bigserial"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:52(type)
msgid "serial8"
msgstr "serial8"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:53(entry)
msgid "autoincrementing eight-byte integer"
msgstr "восьмибайтное целое с автоувеличением"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:57(replaceable) datatype.xml:63(replaceable)
#: datatype.xml:87(replaceable) datatype.xml:88(replaceable)
#: datatype.xml:93(replaceable) datatype.xml:94(replaceable)
msgid "n"
msgstr "n"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:57(type)
msgid "bit [ (<placeholder-1/>) ]"
msgstr "bit [ (<placeholder-1/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:59(entry)
msgid "fixed-length bit string"
msgstr "битовая строка фиксированной длины"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:63(type)
msgid "bit varying [ (<placeholder-1/>) ]"
msgstr "bit varying [ (<placeholder-1/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:64(type)
msgid "varbit"
msgstr "varbit"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:65(entry)
msgid "variable-length bit string"
msgstr "битовая строка переменной длины"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:69(type) datatype.xml:2869(type)
msgid "boolean"
msgstr "boolean"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:70(type)
msgid "bool"
msgstr "bool"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:71(entry)
msgid "logical Boolean (true/false)"
msgstr "логическое значение (true/false)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:75(type) datatype.xml:3126(type)
msgid "box"
msgstr "box"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:77(entry)
msgid "rectangular box on a plane"
msgstr "прямоугольник в плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:81(type) datatype.xml:1288(type)
msgid "bytea"
msgstr "bytea"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:83(entry)
msgid "binary data (<quote>byte array</quote>)"
msgstr "двоичные данные (<quote>массив байт</quote>)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:87(type)
msgid "character [ (<placeholder-1/>) ]"
msgstr "character [ (<placeholder-1/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:88(type)
msgid "char [ (<placeholder-1/>) ]"
msgstr "char [ (<placeholder-1/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:89(entry)
msgid "fixed-length character string"
msgstr "символьная строка фиксированной длины"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:93(type)
msgid "character varying [ (<placeholder-1/>) ]"
msgstr "character varying [ (<placeholder-1/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:94(type)
msgid "varchar [ (<placeholder-1/>) ]"
msgstr "varchar [ (<placeholder-1/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:95(entry) datatype.xml:241(entry)
msgid "variable-length character string"
msgstr "символьная строка переменной длины"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:99(type) datatype.xml:3434(type) datatype.xml:3507(type)
#: datatype.xml:3540(type)
msgid "cidr"
msgstr "cidr"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:101(entry)
msgid "IPv4 or IPv6 network address"
msgstr "сетевой адрес IPv4 или IPv6"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:105(type) datatype.xml:3150(type)
msgid "circle"
msgstr "circle"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:107(entry)
msgid "circle on a plane"
msgstr "круг в плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:111(type) datatype.xml:1614(type)
msgid "date"
msgstr "date"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:113(entry)
msgid "calendar date (year, month, day)"
msgstr "календарная дата (год, месяц, день)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:117(type) datatype.xml:396(type)
msgid "double precision"
msgstr "double precision"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:118(type)
msgid "float8"
msgstr "float8"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:119(entry)
msgid "double precision floating-point number (8 bytes)"
msgstr "число двойной точности с плавающей точкой (8 байт)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:123(type) datatype.xml:3440(type) datatype.xml:3470(type)
msgid "inet"
msgstr "inet"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:125(entry)
msgid "IPv4 or IPv6 host address"
msgstr "адрес узла IPv4 или IPv6"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:129(type) datatype.xml:364(type)
msgctxt "type"
msgid "integer"
msgstr "integer"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:130(entry)
msgid "<type>int</type>, <type>int4</type>"
msgstr "<type>int</type>, <type>int4</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:131(entry)
msgid "signed four-byte integer"
msgstr "знаковое четырёхбайтное целое"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:135(replaceable) datatype.xml:1638(replaceable)
msgid "fields"
msgstr "поля"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:135(replaceable) datatype.xml:183(replaceable)
#: datatype.xml:185(replaceable) datatype.xml:245(replaceable)
#: datatype.xml:251(replaceable) datatype.xml:257(replaceable)
#: datatype.xml:263(replaceable) datatype.xml:1598(replaceable)
#: datatype.xml:1606(replaceable) datatype.xml:1622(replaceable)
#: datatype.xml:1630(replaceable) datatype.xml:1638(replaceable)
msgid "p"
msgstr "p"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:135(type) datatype.xml:1638(type)
msgid "interval [ <placeholder-1/> ] [ (<placeholder-2/>) ]"
msgstr "interval [ <placeholder-1/> ] [ (<placeholder-2/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:137(entry)
msgid "time span"
msgstr "интервал времени"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:141(type)
msgid "json"
msgstr "json"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:143(entry)
msgid "textual JSON data"
msgstr "текстовые данные JSON"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:147(type)
msgid "jsonb"
msgstr "jsonb"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:149(entry)
msgid "binary JSON data, decomposed"
msgstr "двоичные данные JSON, разобранные"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:153(type) datatype.xml:3114(type)
msgid "line"
msgstr "line"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:155(entry)
msgid "infinite line on a plane"
msgstr "прямая в плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:159(type) datatype.xml:3120(type)
msgid "lseg"
msgstr "lseg"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:161(entry)
msgid "line segment on a plane"
msgstr "отрезок в плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:165(type) datatype.xml:3446(type) datatype.xml:3650(type)
msgid "macaddr"
msgstr "macaddr"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:167(entry)
msgid "MAC (Media Access Control) address"
msgstr "MAC-адрес"

#. +> REL_10
#: datatype.xml:171(type) datatype.xml:3452(type) datatype.xml:3700(type)
msgid "macaddr8"
msgstr "macaddr8"

#. +> REL9_6_3 REL9_6
#: datatype.xml:171(type)
msgctxt "type"
msgid "money"
msgstr "money"

#. +> REL_10
#: datatype.xml:173(entry)
msgid "MAC (Media Access Control) address (EUI-64 format)"
msgstr "Адрес MAC (Media Access Control) (в формате EUI-64)"

#. +> REL_10
#: datatype.xml:177(type) datatype.xml:955(type)
msgid "money"
msgstr "money"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:179(entry) datatype.xml:957(entry)
msgid "currency amount"
msgstr "денежная сумма"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:184(replaceable) datatype.xml:186(replaceable)
msgid "s"
msgstr "s"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:183(type)
msgid "numeric [ (<placeholder-1/>, <placeholder-2/>) ]"
msgstr "numeric [ (<placeholder-1/>, <placeholder-2/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:185(type)
msgid "decimal [ (<placeholder-1/>, <placeholder-2/>) ]"
msgstr "decimal [ (<placeholder-1/>, <placeholder-2/>) ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:187(entry)
msgid "exact numeric of selectable precision"
msgstr "вещественное число заданной точности"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:191(type) datatype.xml:3132(type) datatype.xml:3138(type)
msgid "path"
msgstr "path"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:193(entry)
msgid "geometric path on a plane"
msgstr "геометрический путь в плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:197(type)
msgid "pg_lsn"
msgstr "pg_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:199(entry)
msgid "<productname>PostgreSQL</productname> Log Sequence Number"
msgstr "Последовательный номер в журнале <productname>PostgreSQL</productname>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:203(type) datatype.xml:3108(type)
msgid "point"
msgstr "point"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:205(entry)
msgid "geometric point on a plane"
msgstr "геометрическая точка в плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:209(type) datatype.xml:3144(type)
msgid "polygon"
msgstr "polygon"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:211(entry)
msgid "closed geometric path on a plane"
msgstr "замкнутый геометрический путь в плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:215(type) datatype.xml:390(type)
msgid "real"
msgstr "real"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:216(type)
msgid "float4"
msgstr "float4"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:217(entry)
msgid "single precision floating-point number (4 bytes)"
msgstr "число одинарной точности с плавающей точкой (4 байта)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:221(type) datatype.xml:358(type)
msgid "smallint"
msgstr "smallint"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:222(type)
msgid "int2"
msgstr "int2"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:223(entry)
msgid "signed two-byte integer"
msgstr "знаковое двухбайтное целое"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:227(type) datatype.xml:403(type)
msgid "smallserial"
msgstr "smallserial"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:228(type)
msgid "serial2"
msgstr "serial2"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:229(entry)
msgid "autoincrementing two-byte integer"
msgstr "двухбайтное целое с автоувеличением"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:233(type) datatype.xml:410(type)
msgid "serial"
msgstr "serial"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:234(type)
msgid "serial4"
msgstr "serial4"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:235(entry)
msgid "autoincrementing four-byte integer"
msgstr "четырёхбайтное целое с автоувеличением"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:239(type) datatype.xml:1059(type)
msgid "text"
msgstr "text"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:245(type) datatype.xml:1622(type)
msgid "time [ (<placeholder-1/>) ] [ without time zone ]"
msgstr "time [ (<placeholder-1/>) ] [ without time zone ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:247(entry)
msgid "time of day (no time zone)"
msgstr "время суток (без часового пояса)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:251(type) datatype.xml:1630(type)
msgid "time [ (<placeholder-1/>) ] with time zone"
msgstr "time [ (<placeholder-1/>) ] with time zone"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:252(type)
msgid "timetz"
msgstr "timetz"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:253(entry)
msgid "time of day, including time zone"
msgstr "время суток с учётом часового пояса"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:257(type) datatype.xml:1598(type)
msgid "timestamp [ (<placeholder-1/>) ] [ without time zone ]"
msgstr "timestamp [ (<placeholder-1/>) ] [ without time zone ]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:259(entry)
msgid "date and time (no time zone)"
msgstr "дата и время (без часового пояса)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:263(type) datatype.xml:1606(type)
msgid "timestamp [ (<placeholder-1/>) ] with time zone"
msgstr "timestamp [ (<placeholder-1/>) ] with time zone"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:264(type)
msgid "timestamptz"
msgstr "timestamptz"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:265(entry)
msgid "date and time, including time zone"
msgstr "дата и время с учётом часового пояса"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:269(type) datatype.xml:3985(type)
msgid "tsquery"
msgstr "tsquery"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:271(entry)
msgid "text search query"
msgstr "запрос текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:275(type) datatype.xml:3875(type)
msgid "tsvector"
msgstr "tsvector"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:277(entry)
msgid "text search document"
msgstr "документ для текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:281(type)
msgid "txid_snapshot"
msgstr "txid_snapshot"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:283(entry)
msgid "user-level transaction ID snapshot"
msgstr "снимок идентификатора транзакций"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:287(type)
msgid "uuid"
msgstr "uuid"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:289(entry)
msgid "universally unique identifier"
msgstr "универсальный уникальный идентификатор"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:293(type)
msgid "xml"
msgstr "xml"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:295(entry)
msgid "XML data"
msgstr "XML-данные"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:302(title)
msgid "Compatibility"
msgstr "Совместимость"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:303(para)
msgid ""
"The following types (or spellings thereof) are specified by <acronym>SQL</"
"acronym>: <type>bigint</type>, <type>bit</type>, <type>bit varying</type>, "
"<type>boolean</type>, <type>char</type>, <type>character varying</type>, "
"<type>character</type>, <type>varchar</type>, <type>date</type>, "
"<type>double precision</type>, <type>integer</type>, <type>interval</type>, "
"<type>numeric</type>, <type>decimal</type>, <type>real</type>, "
"<type>smallint</type>, <type>time</type> (with or without time zone), "
"<type>timestamp</type> (with or without time zone), <type>xml</type>."
msgstr ""
"В стандарте <acronym>SQL</acronym> описаны следующие типы (или их имена): "
"<type>bigint</type>, <type>bit</type>, <type>bit varying</type>, "
"<type>boolean</type>, <type>char</type>, <type>character varying</type>, "
"<type>character</type>, <type>varchar</type>, <type>date</type>, "
"<type>double precision</type>, <type>integer</type>, <type>interval</type>, "
"<type>numeric</type>, <type>decimal</type>, <type>real</type>, "
"<type>smallint</type>, <type>time</type> (с часовым поясом и без), "
"<type>timestamp</type> (с часовым поясом и без), <type>xml</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:317(para)
msgid ""
"Each data type has an external representation determined by its input and "
"output functions. Many of the built-in types have obvious external formats. "
"However, several types are either unique to <productname>PostgreSQL</"
"productname>, such as geometric paths, or have several possible formats, "
"such as the date and time types. Some of the input and output functions are "
"not invertible, i.e., the result of an output function might lose accuracy "
"when compared to the original input."
msgstr ""
"Каждый тип данных имеет внутреннее представление, скрытое функциями ввода и "
"вывода. При этом многие встроенные типы стандартны и имеют очевидные внешние "
"форматы. Однако есть типы, уникальные для <productname>PostgreSQL</"
"productname>, например геометрические пути, и есть типы, которые могут иметь "
"разные форматы, например, дата и время. Некоторые функции ввода и вывода не "
"являются в точности обратными друг к другу, то есть результат функции вывода "
"может не совпадать со входным значением из-за потери точности."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:330(title) datatype.xml:345(title)
msgid "Numeric Types"
msgstr "Числовые типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:332(indexterm)
msgid "<primary>data type</primary> <secondary>numeric</secondary>"
msgstr "<primary>тип данных</primary> <secondary>numeric</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:337(para)
msgid ""
"Numeric types consist of two-, four-, and eight-byte integers, four- and "
"eight-byte floating-point numbers, and selectable-precision decimals. <xref "
"linkend=\"datatype-numeric-table\"/> lists the available types."
msgstr ""
"Числовые типы включают двух-, четырёх- и восьмибайтные целые, четырёх- и "
"восьмибайтные числа с плавающей точкой, а также десятичные числа с "
"задаваемой точностью. Все эти типы перечислены в <xref remap=\"6\" linkend="
"\"datatype-numeric-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:350(entry) datatype.xml:948(entry) datatype.xml:1239(entry)
#: datatype.xml:1282(entry) datatype.xml:1589(entry) datatype.xml:2863(entry)
#: datatype.xml:3101(entry) datatype.xml:3427(entry)
msgid "Storage Size"
msgstr "Размер"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:352(entry) datatype.xml:950(entry)
msgid "Range"
msgstr "Диапазон"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:359(entry) datatype.xml:404(entry)
msgid "2 bytes"
msgstr "2 байта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:360(entry)
msgid "small-range integer"
msgstr "целое в небольшом диапазоне"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:361(entry)
msgid "-32768 to +32767"
msgstr "-32768 .. +32767"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:365(entry) datatype.xml:391(entry) datatype.xml:411(entry)
#: datatype.xml:1615(entry)
msgid "4 bytes"
msgstr "4 байта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:366(entry)
msgid "typical choice for integer"
msgstr "типичный выбор для целых чисел"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:367(entry)
msgid "-2147483648 to +2147483647"
msgstr "-2147483648 .. +2147483647"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:371(entry) datatype.xml:397(entry) datatype.xml:418(entry)
#: datatype.xml:956(entry) datatype.xml:1599(entry) datatype.xml:1607(entry)
#: datatype.xml:1623(entry) datatype.xml:3453(entry)
msgid "8 bytes"
msgstr "8 байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:372(entry)
msgid "large-range integer"
msgstr "целое в большом диапазоне"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:373(entry)
msgid "-9223372036854775808 to +9223372036854775807"
msgstr "-9223372036854775808 .. 9223372036854775807"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:377(type)
msgid "decimal"
msgstr "decimal"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:378(entry) datatype.xml:384(entry)
msgid "variable"
msgstr "переменный"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:379(entry) datatype.xml:385(entry)
msgid "user-specified precision, exact"
msgstr "вещественное число с указанной точностью"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:380(entry) datatype.xml:386(entry)
msgid ""
"up to 131072 digits before the decimal point; up to 16383 digits after the "
"decimal point"
msgstr "до 131072 цифр до десятичной точки и до 16383 &mdash; после"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:383(type)
msgid "numeric"
msgstr "numeric"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:392(entry) datatype.xml:398(entry)
msgid "variable-precision, inexact"
msgstr "вещественное число с переменной точностью"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:393(entry)
msgid "6 decimal digits precision"
msgstr "точность в пределах 6 десятичных цифр"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:399(entry)
msgid "15 decimal digits precision"
msgstr "точность в пределах 15 десятичных цифр"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:405(entry)
msgid "small autoincrementing integer"
msgstr "небольшое целое с автоувеличением"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:406(entry)
msgid "1 to 32767"
msgstr "1 .. 32767"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:412(entry)
msgid "autoincrementing integer"
msgstr "целое с автоувеличением"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:413(entry)
msgid "1 to 2147483647"
msgstr "1 .. 2147483647"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:419(entry)
msgid "large autoincrementing integer"
msgstr "большое целое с автоувеличением"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:420(entry)
msgid "1 to 9223372036854775807"
msgstr "1 .. 9223372036854775807"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:426(para)
msgid ""
"The syntax of constants for the numeric types is described in <xref linkend="
"\"sql-syntax-constants\"/>. The numeric types have a full set of "
"corresponding arithmetic operators and functions. Refer to <xref linkend="
"\"functions\"/> for more information. The following sections describe the "
"types in detail."
msgstr ""
"Синтаксис констант числовых типов описан в <xref remap=\"6\" linkend=\"sql-"
"syntax-constants\"/>. Для этих типов определён полный набор соответствующих "
"арифметических операторов и функций. За дополнительными сведениями "
"обратитесь к <xref remap=\"3\" linkend=\"functions\"/>. Подробнее эти типы "
"описаны в следующих разделах."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:435(title)
msgid "Integer Types"
msgstr "Целочисленные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:437(indexterm)
msgid "<primary>integer</primary>"
msgstr "<primary>integer</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:441(indexterm)
msgid "<primary>smallint</primary>"
msgstr "<primary>smallint</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:445(indexterm)
msgid "<primary>bigint</primary>"
msgstr "<primary>bigint</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:449(indexterm)
msgid "<primary>int4</primary> <see>integer</see>"
msgstr "<primary>int4</primary> <see>integer</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:454(indexterm)
msgid "<primary>int2</primary> <see>smallint</see>"
msgstr "<primary>int2</primary> <see>smallint</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:459(indexterm)
msgid "<primary>int8</primary> <see>bigint</see>"
msgstr "<primary>int8</primary> <see>bigint</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:464(para)
msgid ""
"The types <type>smallint</type>, <type>integer</type>, and <type>bigint</"
"type> store whole numbers, that is, numbers without fractional components, "
"of various ranges. Attempts to store values outside of the allowed range "
"will result in an error."
msgstr ""
"Типы <type>smallint</type>, <type>integer</type> и <type>bigint</type> "
"хранят целые числа, то есть числа без дробной части, имеющие разные "
"допустимые диапазоны. Попытка сохранить значение, выходящее за рамки "
"диапазона, приведёт к ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:471(para)
msgid ""
"The type <type>integer</type> is the common choice, as it offers the best "
"balance between range, storage size, and performance. The <type>smallint</"
"type> type is generally only used if disk space is at a premium. The "
"<type>bigint</type> type is designed to be used when the range of the "
"<type>integer</type> type is insufficient."
msgstr ""
"Чаще всего используется тип <type>integer</type>, как наиболее "
"сбалансированный выбор ширины диапазона, размера и быстродействия. Тип "
"<type>smallint</type> обычно применяется, только когда крайне важно "
"уменьшить размер данных на диске. Тип <type>bigint</type> предназначен для "
"тех случаев, когда числа не умещаются в диапазон типа <type>integer</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:479(para)
msgid ""
"<acronym>SQL</acronym> only specifies the integer types <type>integer</type> "
"(or <type>int</type>), <type>smallint</type>, and <type>bigint</type>. The "
"type names <type>int2</type>, <type>int4</type>, and <type>int8</type> are "
"extensions, which are also used by some other <acronym>SQL</acronym> "
"database systems."
msgstr ""
"В <acronym>SQL</acronym> определены только типы <type>integer</type> (или "
"<type>int</type>), <type>smallint</type> и <type>bigint</type>. Имена типов "
"<type>int2</type>, <type>int4</type> и <type>int8</type> выходят за рамки "
"стандарта, хотя могут работать и в некоторых других СУБД."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:491(title)
msgid "Arbitrary Precision Numbers"
msgstr "Числа с произвольной точностью"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:493(indexterm)
msgid "<primary>numeric (data type)</primary>"
msgstr "<primary>numeric (тип данных)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:497(indexterm)
msgid "<primary>arbitrary precision numbers</primary>"
msgstr "<primary>числа с произвольной точностью</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:501(indexterm)
msgid "<primary>decimal</primary> <see>numeric</see>"
msgstr "<primary>decimal</primary> <see>numeric</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:506(para)
msgid ""
"The type <type>numeric</type> can store numbers with a very large number of "
"digits. It is especially recommended for storing monetary amounts and other "
"quantities where exactness is required. Calculations with <type>numeric</"
"type> values yield exact results where possible, e.g. addition, subtraction, "
"multiplication. However, calculations on <type>numeric</type> values are "
"very slow compared to the integer types, or to the floating-point types "
"described in the next section."
msgstr ""
"Тип <type>numeric</type> позволяет хранить числа с очень большим количеством "
"цифр. Он особенно рекомендуется для хранения денежных сумм и других величин, "
"где важна точность. Вычисления с типом <type>numeric</type> дают точные "
"результаты, где это возможно, например, при сложении, вычитании и умножении. "
"Однако операции со значениями <type>numeric</type> выполняются гораздо "
"медленнее, чем с целыми числами или с типами с плавающей точкой, описанными "
"в следующем разделе."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:517(para)
msgid ""
"We use the following terms below: The <firstterm>scale</firstterm> of a "
"<type>numeric</type> is the count of decimal digits in the fractional part, "
"to the right of the decimal point. The <firstterm>precision</firstterm> of a "
"<type>numeric</type> is the total count of significant digits in the whole "
"number, that is, the number of digits to both sides of the decimal point. So "
"the number 23.5141 has a precision of 6 and a scale of 4. Integers can be "
"considered to have a scale of zero."
msgstr ""
"Ниже мы используем следующие термины: <firstterm>масштаб</firstterm> "
"значения <type>numeric</type> определяет количество десятичных цифр в "
"дробной части, справа от десятичной точки, а <firstterm>точность</firstterm> "
"&mdash; общее количество значимых цифр в числе, т. е. количество цифр по обе "
"стороны десятичной точки. Например, число 23.5141 имеет точность 6 и масштаб "
"4. Целочисленные значения можно считать числами с масштабом 0."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:534(programlisting)
#, no-wrap
msgid "NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)"
msgstr "NUMERIC(<replaceable>точность</replaceable>, <replaceable>масштаб</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:539(programlisting)
#, no-wrap
msgid "NUMERIC(<replaceable>precision</replaceable>)"
msgstr "NUMERIC(<replaceable>точность</replaceable>)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:543(programlisting)
#, no-wrap
msgid "NUMERIC"
msgstr "NUMERIC"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:529(para)
msgid ""
"Both the maximum precision and the maximum scale of a <type>numeric</type> "
"column can be configured. To declare a column of type <type>numeric</type> "
"use the syntax: <placeholder-1/> The precision must be positive, the scale "
"zero or positive. Alternatively: <placeholder-2/> selects a scale of 0. "
"Specifying: <placeholder-3/> without any precision or scale creates a column "
"in which numeric values of any precision and scale can be stored, up to the "
"implementation limit on precision. A column of this kind will not coerce "
"input values to any particular scale, whereas <type>numeric</type> columns "
"with a declared scale will coerce input values to that scale. (The "
"<acronym>SQL</acronym> standard requires a default scale of 0, i.e., "
"coercion to integer precision. We find this a bit useless. If you're "
"concerned about portability, always specify the precision and scale "
"explicitly.)"
msgstr ""
"Для столбца типа <type>numeric</type> можно настроить и максимальную "
"точность, и максимальный масштаб. Столбец типа <type>numeric</type> "
"объявляется следующим образом: <placeholder-1/> Точность должна быть "
"положительной, а масштаб положительным или равным нулю. Альтернативный "
"вариант <placeholder-2/> устанавливает масштаб 0. Форма: <placeholder-3/> "
"без указания точности и масштаба создаёт столбец, в котором можно сохранять "
"числовые значения любой точности и масштаба в пределах, поддерживаемых "
"системой. В столбце этого типа входные значения не будут приводиться к "
"какому-либо масштабу, тогда как в столбцах <type>numeric</type> с явно "
"заданным масштабом значения подгоняются под этот масштаб. (Стандарт "
"<acronym>SQL</acronym> утверждает, что по умолчанию должен устанавливаться "
"масштаб 0, т. е. значения должны приводиться к целым числам. Однако мы "
"считаем это не очень полезным. Если для вас важна переносимость, всегда "
"указывайте точность и масштаб явно.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:559(para)
msgid ""
"The maximum allowed precision when explicitly specified in the type "
"declaration is 1000; <type>NUMERIC</type> without a specified precision is "
"subject to the limits described in <xref linkend=\"datatype-numeric-table\"/"
">."
msgstr ""
"Максимально допустимая точность, которую можно указать в объявлении типа, "
"равна 1000; если же использовать <type>NUMERIC</type> без указания точности, "
"действуют ограничения, описанные в <xref remap=\"6\" linkend=\"datatype-"
"numeric-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:567(para)
msgid ""
"If the scale of a value to be stored is greater than the declared scale of "
"the column, the system will round the value to the specified number of "
"fractional digits. Then, if the number of digits to the left of the decimal "
"point exceeds the declared precision minus the declared scale, an error is "
"raised."
msgstr ""
"Если масштаб значения, которое нужно сохранить, превышает объявленный "
"масштаб столбца, система округлит его до заданного количества цифр после "
"точки. Если же после этого количество цифр слева в сумме с масштабом "
"превысит объявленную точность, произойдёт ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:575(para)
msgid ""
"Numeric values are physically stored without any extra leading or trailing "
"zeroes. Thus, the declared precision and scale of a column are maximums, not "
"fixed allocations. (In this sense the <type>numeric</type> type is more akin "
"to <type>varchar(<replaceable>n</replaceable>)</type> than to "
"<type>char(<replaceable>n</replaceable>)</type>.) The actual storage "
"requirement is two bytes for each group of four decimal digits, plus three "
"to eight bytes overhead."
msgstr ""
"Числовые значения физически хранятся без каких-либо дополняющих нулей слева "
"или справа. Таким образом, объявляемые точность и масштаб столбца определяют "
"максимальный, а не фиксированный размер хранения. (В этом смысле тип "
"<type>numeric</type> больше похож на тип <type>varchar(<replaceable>n</"
"replaceable>)</type>, чем на <type>char(<replaceable>n</replaceable>)</"
"type>.) Действительный размер хранения такого значения складывается из двух "
"байт для каждой группы из четырёх цифр и дополнительных трёх-восьми байт."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:585(indexterm)
msgid "<primary>NaN</primary> <see>not a number</see>"
msgstr "<primary>NaN</primary> <see>не число</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:590(indexterm)
msgid ""
"<primary>not a number</primary> <secondary>numeric (data type)</secondary>"
msgstr ""
"<primary>не число</primary> <secondary>numeric (тип данных)</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:595(para)
msgid ""
"In addition to ordinary numeric values, the <type>numeric</type> type allows "
"the special value <literal>NaN</literal>, meaning <quote>not-a-number</"
"quote>. Any operation on <literal>NaN</literal> yields another <literal>NaN</"
"literal>. When writing this value as a constant in an SQL command, you must "
"put quotes around it, for example <literal>UPDATE table SET x = 'NaN'</"
"literal>. On input, the string <literal>NaN</literal> is recognized in a "
"case-insensitive manner."
msgstr ""
"Помимо обычных чисел тип <type>numeric</type> позволяет сохранить "
"специальное значение <literal>NaN</literal>, что означает <quote>not-a-"
"number</quote> (не число). Любая операция c <literal>NaN</literal> выдаёт в "
"результате тоже <literal>NaN</literal>. Записывая это значение в виде "
"константы в команде SQL, его нужно заключать в апострофы, например так: "
"<literal>UPDATE table SET x = 'NaN'</literal>. Регистр символов в строке "
"<literal>NaN</literal> не важен."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:606(para)
msgid ""
"In most implementations of the <quote>not-a-number</quote> concept, "
"<literal>NaN</literal> is not considered equal to any other numeric value "
"(including <literal>NaN</literal>). In order to allow <type>numeric</type> "
"values to be sorted and used in tree-based indexes, <productname>PostgreSQL</"
"productname> treats <literal>NaN</literal> values as equal, and greater than "
"all non-<literal>NaN</literal> values."
msgstr ""
"В большинстве реализаций <quote>не-число</quote> (<literal>NaN</literal>) "
"считается не равным любому другому значению (в том числе и самому "
"<literal>NaN</literal>). Чтобы значения <type>numeric</type> можно было "
"сортировать и использовать в древовидных индексах, <productname>PostgreSQL</"
"productname> считает, что значения <literal>NaN</literal> равны друг другу и "
"при этом больше любых числовых значений (не <literal>NaN</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:617(para)
msgid ""
"The types <type>decimal</type> and <type>numeric</type> are equivalent. Both "
"types are part of the <acronym>SQL</acronym> standard."
msgstr ""
"Типы <type>decimal</type> и <type>numeric</type> равнозначны. Оба эти типа "
"описаны в стандарте <acronym>SQL</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:629(programlisting)
#, no-wrap
msgid ""
"SELECT x,\n"
"  round(x::numeric) AS num_round,\n"
"  round(x::double precision) AS dbl_round\n"
"FROM generate_series(-3.5, 3.5, 1) as x;\n"
"  x   | num_round | dbl_round\n"
"------+-----------+-----------\n"
" -3.5 |        -4 |        -4\n"
" -2.5 |        -3 |        -2\n"
" -1.5 |        -2 |        -2\n"
" -0.5 |        -1 |        -0\n"
"  0.5 |         1 |         0\n"
"  1.5 |         2 |         2\n"
"  2.5 |         3 |         2\n"
"  3.5 |         4 |         4\n"
"(8 rows)"
msgstr ""
"SELECT x,\n"
"  round(x::numeric) AS num_round,\n"
"  round(x::double precision) AS dbl_round\n"
"FROM generate_series(-3.5, 3.5, 1) as x;\n"
"  x   | num_round | dbl_round\n"
"------+-----------+-----------\n"
" -3.5 |        -4 |        -4\n"
" -2.5 |        -3 |        -2\n"
" -1.5 |        -2 |        -2\n"
" -0.5 |        -1 |        -0\n"
"  0.5 |         1 |         0\n"
"  1.5 |         2 |         2\n"
"  2.5 |         3 |         2\n"
"  3.5 |         4 |         4\n"
"(8 rows)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:623(para)
msgid ""
"When rounding values, the <type>numeric</type> type rounds ties away from "
"zero, while (on most machines) the <type>real</type> and <type>double "
"precision</type> types round ties to the nearest even number. For example: "
"<placeholder-1/>"
msgstr ""
"При округлении значений тип <type>numeric</type> выдаёт число, большее по "
"модулю, тогда как (на большинстве платформ) типы <type>real</type> и "
"<type>double precision</type> выдают ближайшее чётное число. Например: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:651(title)
msgid "Floating-Point Types"
msgstr "Типы с плавающей точкой"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:653(indexterm)
msgid "<primary>real</primary>"
msgstr "<primary>real</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:657(indexterm)
msgid "<primary>double precision</primary>"
msgstr "<primary>double precision</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:661(indexterm)
msgid "<primary>float4</primary> <see>real</see>"
msgstr "<primary>float4</primary> <see>real</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:666(indexterm)
msgid "<primary>float8</primary> <see>double precision</see>"
msgstr "<primary>float8</primary> <see>double precision</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:671(indexterm)
msgid "<primary>floating point</primary>"
msgstr "<primary>floating point</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:675(para)
msgid ""
"The data types <type>real</type> and <type>double precision</type> are "
"inexact, variable-precision numeric types. In practice, these types are "
"usually implementations of <acronym>IEEE</acronym> Standard 754 for Binary "
"Floating-Point Arithmetic (single and double precision, respectively), to "
"the extent that the underlying processor, operating system, and compiler "
"support it."
msgstr ""
"Типы данных <type>real</type> и <type>double precision</type> хранят "
"приближённые числовые значения с переменной точностью. На практике эти типы "
"обычно реализуют Стандарт <acronym>IEEE</acronym> 754 для двоичной "
"арифметики с плавающей точкой (с одинарной и двойной точностью "
"соответственно), в той мере, в какой его поддерживают процессор, "
"операционная система и компилятор."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:695(para)
msgid ""
"If you require exact storage and calculations (such as for monetary "
"amounts), use the <type>numeric</type> type instead."
msgstr ""
"Если вам нужна точность при хранении и вычислениях (например, для денежных "
"сумм), используйте вместо этого тип <type>numeric</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:702(para)
msgid ""
"If you want to do complicated calculations with these types for anything "
"important, especially if you rely on certain behavior in boundary cases "
"(infinity, underflow), you should evaluate the implementation carefully."
msgstr ""
"Если вы хотите выполнять с этими типами сложные вычисления, имеющие большую "
"важность, тщательно изучите реализацию операций в вашей среде и особенно "
"поведение в крайних случаях (бесконечность, антипереполнение)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:711(para)
msgid ""
"Comparing two floating-point values for equality might not always work as "
"expected."
msgstr ""
"Проверка равенства двух чисел с плавающей точкой может не всегда давать "
"ожидаемый результат."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:685(para)
msgid ""
"Inexact means that some values cannot be converted exactly to the internal "
"format and are stored as approximations, so that storing and retrieving a "
"value might show slight discrepancies. Managing these errors and how they "
"propagate through calculations is the subject of an entire branch of "
"mathematics and computer science and will not be discussed here, except for "
"the following points: <placeholder-1/>"
msgstr ""
"Неточность здесь выражается в том, что некоторые значения, которые нельзя "
"преобразовать во внутренний формат, сохраняются приближённо, так что "
"полученное значение может несколько отличаться от записанного. Управление "
"подобными ошибками и их распространение в процессе вычислений является "
"предметом изучения целого раздела математики и компьютерной науки, и здесь "
"не рассматривается. Мы отметим только следующее: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:719(para)
msgid ""
"On most platforms, the <type>real</type> type has a range of at least 1E-37 "
"to 1E+37 with a precision of at least 6 decimal digits. The <type>double "
"precision</type> type typically has a range of around 1E-307 to 1E+308 with "
"a precision of at least 15 digits. Values that are too large or too small "
"will cause an error. Rounding might take place if the precision of an input "
"number is too high. Numbers too close to zero that are not representable as "
"distinct from zero will cause an underflow error."
msgstr ""
"На большинстве платформ тип <type>real</type> может сохранить значения в "
"пределах от 1E-37 до 1E+37 с точностью не меньше 6 десятичных цифр. Тип "
"<type>double precision</type> предлагает диапазон значений от 1E-307 до 1E"
"+308 и точностью не меньше 15 цифр. Попытка сохранить слишком большие или "
"слишком маленькие значения приведёт к ошибке. Если точность вводимого числа "
"слишком велика, оно будет округлено. При попытке сохранить число, близкое к "
"0, но непредставимое как отличное от 0, произойдёт ошибка антипереполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:731(para)
msgid ""
"The <xref linkend=\"guc-extra-float-digits\"/> setting controls the number "
"of extra significant digits included when a floating point value is "
"converted to text for output. With the default value of <literal>0</"
"literal>, the output is the same on every platform supported by PostgreSQL. "
"Increasing it will produce output that more accurately represents the stored "
"value, but may be unportable."
msgstr ""
"Параметр <xref linkend=\"guc-extra-float-digits\"/> определяет количество "
"дополнительных значащих цифр при преобразовании значения с плавающей точкой "
"в текст для вывода. Со значением по умолчанию (<literal>0</literal>) вывод "
"будет одинаковым на всех платформах, поддерживаемых PostgreSQL. При его "
"увеличении выводимое значение числа будет более точно представлять хранимое, "
"но от этого может пострадать переносимость."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:741(indexterm)
msgid "<primary>not a number</primary> <secondary>double precision</secondary>"
msgstr "<primary>не число</primary> <secondary>double precision</secondary>"

#. +> REL_10
#: datatype.xml:746(para)
msgid ""
"In addition to ordinary numeric values, the floating-point types have "
"several special values: <literallayout>\n"
"<literal>Infinity</literal>\n"
"<literal>-Infinity</literal>\n"
"<literal>NaN</literal>\n"
"</literallayout> These represent the IEEE 754 special values "
"<quote>infinity</quote>, <quote>negative infinity</quote>, and <quote>not-a-"
"number</quote>, respectively. (On a machine whose floating-point arithmetic "
"does not follow IEEE 754, these values will probably not work as expected.) "
"When writing these values as constants in an SQL command, you must put "
"quotes around them, for example <literal>UPDATE table SET x = '-Infinity'</"
"literal>. On input, these strings are recognized in a case-insensitive "
"manner."
msgstr ""
"В дополнение к обычным числовым значениям типы с плавающей точкой могут "
"содержать следующие специальные значения: <literallayout>\n"
"<literal>Infinity</literal>\n"
"<literal>-Infinity</literal>\n"
"<literal>NaN</literal>\n"
"</literallayout> Они представляют особые значения, описанные в IEEE 754, "
"соответственно <quote>бесконечность</quote>, <quote>минус бесконечность</"
"quote> и <quote>не число</quote>. (На компьютерах, где арифметика с "
"плавающей точкой не соответствует стандарту IEEE 754, эти значения, "
"вероятно, не будут работать должным образом.) Записывая эти значения в виде "
"констант в команде SQL, их нужно заключать в апострофы, например так: "
"<literal>UPDATE table SET x = '-Infinity'</literal>. Регистр символов в этих "
"строках не важен."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:765(para)
msgid ""
"IEEE754 specifies that <literal>NaN</literal> should not compare equal to "
"any other floating-point value (including <literal>NaN</literal>). In order "
"to allow floating-point values to be sorted and used in tree-based indexes, "
"<productname>PostgreSQL</productname> treats <literal>NaN</literal> values "
"as equal, and greater than all non-<literal>NaN</literal> values."
msgstr ""
"Согласно IEEE754, <literal>NaN</literal> не должно считаться равным любому "
"другому значению с плавающей точкой (в том числе и самому <literal>NaN</"
"literal>). Чтобы значения с плавающей точкой можно было сортировать и "
"использовать в древовидных индексах, <productname>PostgreSQL</productname> "
"считает, что значения <literal>NaN</literal> равны друг другу, и при этом "
"больше любых числовых значений (не <literal>NaN</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:775(para)
msgid ""
"<productname>PostgreSQL</productname> also supports the SQL-standard "
"notations <type>float</type> and <type>float(<replaceable>p</replaceable>)</"
"type> for specifying inexact numeric types. Here, <replaceable>p</"
"replaceable> specifies the minimum acceptable precision in <emphasis>binary</"
"emphasis> digits. <productname>PostgreSQL</productname> accepts "
"<type>float(1)</type> to <type>float(24)</type> as selecting the <type>real</"
"type> type, while <type>float(25)</type> to <type>float(53)</type> select "
"<type>double precision</type>. Values of <replaceable>p</replaceable> "
"outside the allowed range draw an error. <type>float</type> with no "
"precision specified is taken to mean <type>double precision</type>."
msgstr ""
"<productname>PostgreSQL</productname> также поддерживает форматы "
"<type>float</type> и <type>float(<replaceable>p</replaceable>)</type>, "
"оговорённые в стандарте SQL, для указания неточных числовых типов. Здесь "
"<replaceable>p</replaceable> определяет минимально допустимую точность в "
"<emphasis>двоичных</emphasis> цифрах. <productname>PostgreSQL</productname> "
"воспринимает запись от <type>float(1)</type> до <type>float(24)</type> как "
"выбор типа <type>real</type>, а запись от <type>float(25)</type> до "
"<type>float(53)</type> как выбор типа <type>double precision</type>. "
"Значения <replaceable>p</replaceable> вне допустимого диапазона вызывают "
"ошибку. Если <type>float</type> указывается без точности, подразумевается "
"тип <type>double precision</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:792(para)
msgid ""
"The assumption that <type>real</type> and <type>double precision</type> have "
"exactly 24 and 53 bits in the mantissa respectively is correct for IEEE-"
"standard floating point implementations. On non-IEEE platforms it might be "
"off a little, but for simplicity the same ranges of <replaceable>p</"
"replaceable> are used on all platforms."
msgstr ""
"Предположение, что типы <type>real</type> и <type>double precision</type> "
"имеют в мантиссе 24 и 53 бита соответственно, справедливо для всех "
"реализаций плавающей точки по стандарту IEEE. На платформах, не "
"поддерживающих IEEE, размер мантиссы может несколько отличаться, но для "
"простоты диапазоны <replaceable>p</replaceable> везде считаются одинаковыми."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:805(title)
msgid "Serial Types"
msgstr "Последовательные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:807(indexterm)
msgid "<primary>smallserial</primary>"
msgstr "<primary>smallserial</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:811(indexterm)
msgid "<primary>serial</primary>"
msgstr "<primary>serial</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:815(indexterm)
msgid "<primary>bigserial</primary>"
msgstr "<primary>bigserial</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:819(indexterm)
msgid "<primary>serial2</primary>"
msgstr "<primary>serial2</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:823(indexterm)
msgid "<primary>serial4</primary>"
msgstr "<primary>serial4</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:827(indexterm)
msgid "<primary>serial8</primary>"
msgstr "<primary>serial8</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:831(indexterm)
msgid "<primary>auto-increment</primary> <see>serial</see>"
msgstr "<primary>auto-increment</primary> <see>serial</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:836(indexterm)
msgid "<primary>sequence</primary> <secondary>and serial type</secondary>"
msgstr "<primary>sequence</primary> <secondary>и тип serial</secondary>"

#. +> REL_10
#: datatype.xml:842(para)
msgid ""
"This section describes a PostgreSQL-specific way to create an "
"autoincrementing column. Another way is to use the SQL-standard identity "
"column feature, described at <xref linkend=\"sql-createtable\"/>."
msgstr ""
"В этом разделе описывается специфичный для PostgreSQL способ создания "
"столбца с автоувеличением. Другой способ, соответствующий стандарту SQL, "
"заключается в использовании столбцов идентификации и рассматривается в "
"описании <xref linkend=\"sql-createtable\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:857(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE <replaceable class=\"parameter\">tablename</replaceable> (\n"
"    <replaceable class=\"parameter\">colname</replaceable> SERIAL\n"
");"
msgstr ""
"CREATE TABLE <replaceable class=\"parameter\">имя_таблицы</replaceable> (\n"
"    <replaceable class=\"parameter\">имя_столбца</replaceable> SERIAL\n"
");"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:865(programlisting)
#, no-wrap
msgid ""
"CREATE SEQUENCE <replaceable class=\"parameter\">tablename</replaceable>_<replaceable class=\"parameter\">colname</replaceable>_seq;\n"
"CREATE TABLE <replaceable class=\"parameter\">tablename</replaceable> (\n"
"    <replaceable class=\"parameter\">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class=\"parameter\">tablename</replaceable>_<replaceable class=\"parameter\">colname</replaceable>_seq')\n"
");\n"
"ALTER SEQUENCE <replaceable class=\"parameter\">tablename</replaceable>_<replaceable class=\"parameter\">colname</replaceable>_seq OWNED BY <replaceable class=\"parameter\">tablename</replaceable>.<replaceable class=\"parameter\">colname</replaceable>;"
msgstr ""
"CREATE SEQUENCE <replaceable class=\"parameter\">имя_таблицы</replaceable>_<replaceable class=\"parameter\">имя_столбца</replaceable>_seq;\n"
"CREATE TABLE <replaceable class=\"parameter\">имя_таблицы</replaceable> (\n"
"    <replaceable class=\"parameter\">имя_столбца</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class=\"parameter\">имя_таблицы</replaceable>_<replaceable class=\"parameter\">имя_столбца</replaceable>_seq')\n"
");\n"
"ALTER SEQUENCE <replaceable class=\"parameter\">имя_таблицы</replaceable>_<replaceable class=\"parameter\">имя_столбца</replaceable>_seq OWNED BY <replaceable class=\"parameter\">имя_таблицы</replaceable>.<replaceable class=\"parameter\">имя_столбца</replaceable>;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:849(para)
msgid ""
"The data types <type>smallserial</type>, <type>serial</type> and "
"<type>bigserial</type> are not true types, but merely a notational "
"convenience for creating unique identifier columns (similar to the "
"<literal>AUTO_INCREMENT</literal> property supported by some other "
"databases). In the current implementation, specifying: <placeholder-1/> is "
"equivalent to specifying: <placeholder-2/> Thus, we have created an integer "
"column and arranged for its default values to be assigned from a sequence "
"generator. A <literal>NOT NULL</literal> constraint is applied to ensure "
"that a null value cannot be inserted. (In most cases you would also want to "
"attach a <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> "
"constraint to prevent duplicate values from being inserted by accident, but "
"this is not automatic.) Lastly, the sequence is marked as <quote>owned by</"
"quote> the column, so that it will be dropped if the column or table is "
"dropped."
msgstr ""
"Типы данных <type>smallserial</type>, <type>serial</type> и <type>bigserial</"
"type> не являются настоящими типами, а представляют собой просто удобное "
"средство для создания столбцов с уникальными идентификаторами (подобное "
"свойству <literal>AUTO_INCREMENT</literal> в некоторых СУБД). В текущей "
"реализации запись: <placeholder-1/> равнозначна следующим командам: "
"<placeholder-2/> То есть при определении такого типа создаётся целочисленный "
"столбец со значением по умолчанию, извлекаемым из генератора "
"последовательности. Чтобы в столбец нельзя было вставить NULL, в его "
"определение добавляется ограничение <literal>NOT NULL</literal>. (Во многих "
"случаях также имеет смысл добавить для этого столбца ограничения "
"<literal>UNIQUE</literal> или <literal>PRIMARY KEY</literal> для защиты от "
"ошибочного добавления дублирующихся значений, но автоматически это не "
"происходит.) Последняя команда определяет, что последовательность "
"<quote>принадлежит</quote> столбцу, так что она будет удалена при удалении "
"столбца или таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:884(para)
msgid ""
"Because <type>smallserial</type>, <type>serial</type> and <type>bigserial</"
"type> are implemented using sequences, there may be \"holes\" or gaps in the "
"sequence of values which appears in the column, even if no rows are ever "
"deleted. A value allocated from the sequence is still \"used up\" even if a "
"row containing that value is never successfully inserted into the table "
"column. This may happen, for example, if the inserting transaction rolls "
"back. See <literal>nextval()</literal> in <xref linkend=\"functions-sequence"
"\"/> for details."
msgstr ""
"Так как типы <type>smallserial</type>, <type>serial</type> и "
"<type>bigserial</type> реализованы через последовательности, в числовом ряду "
"значений столбца могут образовываться пропуски (или \"дыры\"), даже если "
"никакие строки не удалялись. Значение, выделенное из последовательности, "
"считается \"задействованным\", даже если строку с этим значением не удалось "
"вставить в таблицу. Это может произойти, например, при откате транзакции, "
"добавляющей данные. См. описание <literal>nextval()</literal> в <xref remap="
"\"6\" linkend=\"functions-sequence\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:897(para)
msgid ""
"To insert the next value of the sequence into the <type>serial</type> "
"column, specify that the <type>serial</type> column should be assigned its "
"default value. This can be done either by excluding the column from the list "
"of columns in the <command>INSERT</command> statement, or through the use of "
"the <literal>DEFAULT</literal> key word."
msgstr ""
"Чтобы вставить в столбец <type>serial</type> следующее значение "
"последовательности, ему нужно присвоить значение по умолчанию. Это можно "
"сделать, либо исключив его из списка столбцов в операторе <command>INSERT</"
"command>, либо с помощью ключевого слова <literal>DEFAULT</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:906(para)
msgid ""
"The type names <type>serial</type> and <type>serial4</type> are equivalent: "
"both create <type>integer</type> columns. The type names <type>bigserial</"
"type> and <type>serial8</type> work the same way, except that they create a "
"<type>bigint</type> column. <type>bigserial</type> should be used if you "
"anticipate the use of more than 2<superscript>31</superscript> identifiers "
"over the lifetime of the table. The type names <type>smallserial</type> and "
"<type>serial2</type> also work the same way, except that they create a "
"<type>smallint</type> column."
msgstr ""
"Имена типов <type>serial</type> и <type>serial4</type> равнозначны: они "
"создают столбцы <type>integer</type>. Так же являются синонимами имена "
"<type>bigserial</type> и <type>serial8</type>, но они создают столбцы "
"<type>bigint</type>. Тип <type>bigserial</type> следует использовать, если "
"за всё время жизни таблицы планируется использовать больше чем "
"2<superscript>31</superscript> значений. И наконец, синонимами являются "
"имена типов <type>smallserial</type> и <type>serial2</type>, но они создают "
"столбец <type>smallint</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:918(para)
msgid ""
"The sequence created for a <type>serial</type> column is automatically "
"dropped when the owning column is dropped. You can drop the sequence without "
"dropping the column, but this will force removal of the column default "
"expression."
msgstr ""
"Последовательность, созданная для столбца <type>serial</type>, автоматически "
"удаляется при удалении связанного столбца. Последовательность можно удалить "
"и отдельно от столбца, но при этом также будет удалено определение значения "
"по умолчанию."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:928(title) datatype.xml:943(title)
msgid "Monetary Types"
msgstr "Денежные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:930(para)
msgid ""
"The <type>money</type> type stores a currency amount with a fixed fractional "
"precision; see <xref linkend=\"datatype-money-table\"/>. The fractional "
"precision is determined by the database's <xref linkend=\"guc-lc-monetary\"/"
"> setting. The range shown in the table assumes there are two fractional "
"digits. Input is accepted in a variety of formats, including integer and "
"floating-point literals, as well as typical currency formatting, such as "
"<literal>'$1,000.00'</literal>. Output is generally in the latter form but "
"depends on the locale."
msgstr ""
"Тип <type>money</type> хранит денежную сумму с фиксированной дробной частью; "
"см. <xref remap=\"4\" linkend=\"datatype-money-table\"/>. Точность дробной "
"части определяется на уровне базы данных параметром <xref linkend=\"guc-lc-"
"monetary\"/>. Для диапазона, показанного в таблице, предполагается, что "
"число содержит два знака после запятой. Входные данные могут быть записаны "
"по-разному, в том числе в виде целых и дробных чисел, а также в виде строки "
"в денежном формате, например <literal>'$1,000.00'</literal>. Выводятся эти "
"значения обычно в денежном формате, зависящем от региональных стандартов."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:958(entry)
msgid "-92233720368547758.08 to +92233720368547758.07"
msgstr "-92233720368547&zwsp;758.08 .. +92233720368547&zwsp;758.07"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:964(para)
msgid ""
"Since the output of this data type is locale-sensitive, it might not work to "
"load <type>money</type> data into a database that has a different setting of "
"<varname>lc_monetary</varname>. To avoid problems, before restoring a dump "
"into a new database make sure <varname>lc_monetary</varname> has the same or "
"equivalent value as in the database that was dumped."
msgstr ""
"Так как выводимые значения этого типа зависят от региональных стандартов, "
"попытка загрузить данные типа <type>money</type> в базу данных с другим "
"параметром <varname>lc_monetary</varname> может быть неудачной. Во избежание "
"подобных проблем, прежде чем восстанавливать копию в новую базу данных, "
"убедитесь в том, что параметр <varname>lc_monetary</varname> в этой базе "
"данных имеет то же значение, что и в исходной."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:978(programlisting)
#, no-wrap
msgid "SELECT '12.34'::float8::numeric::money;"
msgstr "SELECT '12.34'::float8::numeric::money;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:972(para)
msgid ""
"Values of the <type>numeric</type>, <type>int</type>, and <type>bigint</"
"type> data types can be cast to <type>money</type>. Conversion from the "
"<type>real</type> and <type>double precision</type> data types can be done "
"by casting to <type>numeric</type> first, for example: <placeholder-1/> "
"However, this is not recommended. Floating point numbers should not be used "
"to handle money due to the potential for rounding errors."
msgstr ""
"Значения типов <type>numeric</type>, <type>int</type> и <type>bigint</type> "
"можно привести к типу <type>money</type>. Преобразования типов <type>real</"
"type> и <type>double precision</type> так же возможны через тип "
"<type>numeric</type>, например: <placeholder-1/> Однако использовать числа с "
"плавающей точкой для денежных сумм не рекомендуется из-за возможных ошибок "
"округления."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:989(programlisting)
#, no-wrap
msgid "SELECT '52093.89'::money::numeric::float8;"
msgstr "SELECT '52093.89'::money::numeric::float8;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:985(para)
msgid ""
"A <type>money</type> value can be cast to <type>numeric</type> without loss "
"of precision. Conversion to other types could potentially lose precision, "
"and must also be done in two stages: <placeholder-1/>"
msgstr ""
"Значение <type>money</type> можно привести к типу <type>numeric</type> без "
"потери точности. Преобразование в другие типы может быть неточным и также "
"должно выполняться в два этапа: <placeholder-1/>"

#. +> REL_10 REL9_6
#: datatype.xml:994(para)
msgid ""
"Division of a <type>money</type> value by an integer value is performed with "
"truncation of the fractional part towards zero. To get a rounded result, "
"divide by a floating-point value, or cast the <type>money</type> value to "
"<type>numeric</type> before dividing and back to <type>money</type> "
"afterwards. (The latter is preferable to avoid risking precision loss.) When "
"a <type>money</type> value is divided by another <type>money</type> value, "
"the result is <type>double precision</type> (i.e., a pure number, not "
"money); the currency units cancel each other out in the division."
msgstr ""
"При делении значения типа <type>money</type> на целое число выполняется "
"отбрасывание дробной части и получается целое, ближайшее к нулю. Чтобы "
"получить результат с округлением, выполните деление значения с плавающей "
"точкой или приведите значение типа <type>money</type> к <type>numeric</type> "
"до деления, а затем приведите результат к типу <type>money</type>. "
"(Последний вариант предпочтительнее, так как исключает риск потери "
"точности.) Когда значение <type>money</type> делится на другое значение "
"<type>money</type>, результатом будет значение типа <type>double precision</"
"type> (то есть просто число, не денежная величина); денежные единицы "
"измерения при делении сокращаются."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1008(title) datatype.xml:1041(title)
msgid "Character Types"
msgstr "Символьные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1010(indexterm)
msgid "<primary>character string</primary> <secondary>data types</secondary>"
msgstr ""
"<primary>символьная строка</primary> <secondary>типы данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1015(indexterm)
msgid "<primary>string</primary> <see>character string</see>"
msgstr "<primary>строка</primary> <see>символьная строка</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1020(indexterm)
msgid "<primary>character</primary>"
msgstr "<primary>character</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1024(indexterm)
msgid "<primary>character varying</primary>"
msgstr "<primary>character varying</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1028(indexterm)
msgid "<primary>text</primary>"
msgstr "<primary>text</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1032(indexterm)
msgid "<primary>char</primary>"
msgstr "<primary>char</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1036(indexterm)
msgid "<primary>varchar</primary>"
msgstr "<primary>varchar</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1051(entry)
msgid ""
"<type>character varying(<replaceable>n</replaceable>)</type>, "
"<type>varchar(<replaceable>n</replaceable>)</type>"
msgstr ""
"<type>character varying(<replaceable>n</replaceable>)</type>, "
"<type>varchar(<replaceable>n</replaceable>)</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1052(entry)
msgid "variable-length with limit"
msgstr "строка ограниченной переменной длины"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1055(entry)
msgid ""
"<type>character(<replaceable>n</replaceable>)</type>, "
"<type>char(<replaceable>n</replaceable>)</type>"
msgstr ""
"<type>character(<replaceable>n</replaceable>)</type>, "
"<type>char(<replaceable>n</replaceable>)</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1056(entry)
msgid "fixed-length, blank padded"
msgstr "строка фиксированной длины, дополненная пробелами"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1060(entry)
msgid "variable unlimited length"
msgstr "строка неограниченной переменной длины"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1066(para)
msgid ""
"<xref linkend=\"datatype-character-table\"/> shows the general-purpose "
"character types available in <productname>PostgreSQL</productname>."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-character-table\"/> перечислены "
"символьные типы общего назначения, доступные в <productname>PostgreSQL</"
"productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1072(para)
msgid ""
"<acronym>SQL</acronym> defines two primary character types: <type>character "
"varying(<replaceable>n</replaceable>)</type> and "
"<type>character(<replaceable>n</replaceable>)</type>, where <replaceable>n</"
"replaceable> is a positive integer. Both of these types can store strings up "
"to <replaceable>n</replaceable> characters (not bytes) in length. An attempt "
"to store a longer string into a column of these types will result in an "
"error, unless the excess characters are all spaces, in which case the string "
"will be truncated to the maximum length. (This somewhat bizarre exception is "
"required by the <acronym>SQL</acronym> standard.) If the string to be stored "
"is shorter than the declared length, values of type <type>character</type> "
"will be space-padded; values of type <type>character varying</type> will "
"simply store the shorter string."
msgstr ""
"<acronym>SQL</acronym> определяет два основных символьных типа: "
"<type>character varying(<replaceable>n</replaceable>)</type> и "
"<type>character(<replaceable>n</replaceable>)</type>, где <replaceable>n</"
"replaceable> &mdash; положительное число. Оба эти типа могут хранить "
"текстовые строки длиной до <replaceable>n</replaceable> символов (не байт). "
"Попытка сохранить в столбце такого типа более длинную строку приведёт к "
"ошибке, если только все лишние символы не являются пробелами (тогда они "
"будут усечены до максимально допустимой длины). (Это несколько странное "
"исключение продиктовано стандартом <acronym>SQL</acronym>.) Если длина "
"сохраняемой строки оказывается меньше объявленной, значения типа "
"<type>character</type> будут дополнятся пробелами; а тип <type>character "
"varying</type> просто сохранит короткую строку."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1089(para)
msgid ""
"If one explicitly casts a value to <type>character varying(<replaceable>n</"
"replaceable>)</type> or <type>character(<replaceable>n</replaceable>)</"
"type>, then an over-length value will be truncated to <replaceable>n</"
"replaceable> characters without raising an error. (This too is required by "
"the <acronym>SQL</acronym> standard.)"
msgstr ""
"При попытке явно привести значение к типу <type>character "
"varying(<replaceable>n</replaceable>)</type> или "
"<type>character(<replaceable>n</replaceable>)</type>, часть строки, "
"выходящая за границу в <replaceable>n</replaceable> символов, удаляется, не "
"вызывая ошибки. (Это также продиктовано стандартом <acronym>SQL</acronym>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1098(para)
msgid ""
"The notations <type>varchar(<replaceable>n</replaceable>)</type> and "
"<type>char(<replaceable>n</replaceable>)</type> are aliases for "
"<type>character varying(<replaceable>n</replaceable>)</type> and "
"<type>character(<replaceable>n</replaceable>)</type>, respectively. "
"<type>character</type> without length specifier is equivalent to "
"<type>character(1)</type>. If <type>character varying</type> is used without "
"length specifier, the type accepts strings of any size. The latter is a "
"<productname>PostgreSQL</productname> extension."
msgstr ""
"Записи <type>varchar(<replaceable>n</replaceable>)</type> и "
"<type>char(<replaceable>n</replaceable>)</type> являются синонимами "
"<type>character varying(<replaceable>n</replaceable>)</type> и "
"<type>character(<replaceable>n</replaceable>)</type>, соответственно. Записи "
"<type>character</type> без указания длины соответствует <type>character(1)</"
"type>. Если же длина не указывается для <type>character varying</type>, этот "
"тип будет принимать строки любого размера. Это поведение является "
"расширением <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1109(para)
msgid ""
"In addition, <productname>PostgreSQL</productname> provides the <type>text</"
"type> type, which stores strings of any length. Although the type "
"<type>text</type> is not in the <acronym>SQL</acronym> standard, several "
"other SQL database management systems have it as well."
msgstr ""
"Помимо этого, <productname>PostgreSQL</productname> предлагает тип "
"<type>text</type>, в котором можно хранить строки произвольной длины. Хотя "
"тип <type>text</type> не описан в стандарте <acronym>SQL</acronym>, его "
"поддерживают и некоторые другие СУБД SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1117(para)
msgid ""
"Values of type <type>character</type> are physically padded with spaces to "
"the specified width <replaceable>n</replaceable>, and are stored and "
"displayed that way. However, trailing spaces are treated as semantically "
"insignificant and disregarded when comparing two values of type "
"<type>character</type>. In collations where whitespace is significant, this "
"behavior can produce unexpected results; for example <command>SELECT 'a '::"
"CHAR(2) collate \"C\" &lt; E'a\\n'::CHAR(2)</command> returns true, even "
"though <literal>C</literal> locale would consider a space to be greater than "
"a newline. Trailing spaces are removed when converting a <type>character</"
"type> value to one of the other string types. Note that trailing spaces "
"<emphasis>are</emphasis> semantically significant in <type>character "
"varying</type> and <type>text</type> values, and when using pattern "
"matching, that is <literal>LIKE</literal> and regular expressions."
msgstr ""
"Значения типа <type>character</type> физически дополняются пробелами до "
"<replaceable>n</replaceable> символов и хранятся, а затем отображаются в "
"таком виде. Однако при сравнении двух значений типа <type>character</type> "
"дополняющие пробелы считаются незначащими и игнорируются. С правилами "
"сортировки, где пробельные символы являются значащими, это поведение может "
"приводить к неожиданным результатам, например <command>SELECT 'a '::CHAR(2) "
"collate \"C\" &lt; E'a\\n'::CHAR(2)</command> вернёт true (условие будет "
"истинным), хотя в локали C символ пробела считается больше символа новой "
"строки. При приведении значения <type>character</type> к другому символьному "
"типу дополняющие пробелы отбрасываются. Заметьте, что эти пробелы "
"<emphasis>несут</emphasis> смысловую нагрузку в типах <type>character "
"varying</type> и <type>text</type> и в проверках по шаблонам, то есть в "
"<literal>LIKE</literal> и регулярных выражениях."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1135(para)
msgid ""
"The storage requirement for a short string (up to 126 bytes) is 1 byte plus "
"the actual string, which includes the space padding in the case of "
"<type>character</type>. Longer strings have 4 bytes of overhead instead of "
"1. Long strings are compressed by the system automatically, so the physical "
"requirement on disk might be less. Very long values are also stored in "
"background tables so that they do not interfere with rapid access to shorter "
"column values. In any case, the longest possible character string that can "
"be stored is about 1 GB. (The maximum value that will be allowed for "
"<replaceable>n</replaceable> in the data type declaration is less than that. "
"It wouldn't be useful to change this because with multibyte character "
"encodings the number of characters and bytes can be quite different. If you "
"desire to store long strings with no specific upper limit, use <type>text</"
"type> or <type>character varying</type> without a length specifier, rather "
"than making up an arbitrary length limit.)"
msgstr ""
"Для хранения короткой строки (до 126 байт) требуется дополнительный 1 байт "
"плюс размер самой строки, включая дополняющие пробелы для типа "
"<type>character</type>. Для строк длиннее требуется не 1, а 4 дополнительных "
"байта. Система может автоматически сжимать длинные строки, так что "
"физический размер на диске может быть меньше. Очень длинные текстовые строки "
"переносятся в отдельные таблицы, чтобы они не замедляли работу с другими "
"столбцами. В любом случае, максимально возможный размер строки составляет "
"около 1 ГБ. (Допустимое значение <replaceable>n</replaceable> в объявлении "
"типа данных меньше этого числа. Это объясняется тем, что в зависимости от "
"кодировки каждый символ может занимать несколько байт. Если вы желаете "
"сохранять строки без определённого предела длины, используйте типы "
"<type>text</type> или <type>character varying</type> без указания длины, а "
"не задавайте какое-либо большое максимальное значение.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1154(para)
msgid ""
"There is no performance difference among these three types, apart from "
"increased storage space when using the blank-padded type, and a few extra "
"CPU cycles to check the length when storing into a length-constrained "
"column. While <type>character(<replaceable>n</replaceable>)</type> has "
"performance advantages in some other database systems, there is no such "
"advantage in <productname>PostgreSQL</productname>; in fact "
"<type>character(<replaceable>n</replaceable>)</type> is usually the slowest "
"of the three because of its additional storage costs. In most situations "
"<type>text</type> or <type>character varying</type> should be used instead."
msgstr ""
"По быстродействию эти три типа практически не отличаются друг от друга, не "
"считая большего размера хранения для типа с дополняющими пробелами и "
"нескольких машинных операций для проверки длины при сохранении строк в "
"столбце с ограниченной длиной. Хотя в некоторых СУБД тип "
"<type>character(<replaceable>n</replaceable>)</type> работает быстрее "
"других, в <productname>PostgreSQL</productname> это не так; на деле "
"<type>character(<replaceable>n</replaceable>)</type> обычно оказывается "
"медленнее остальных типов из-за большего размера данных и более медленной "
"сортировки. В большинстве случаев вместо него лучше применять <type>text</"
"type> или <type>character varying</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1169(para)
msgid ""
"Refer to <xref linkend=\"sql-syntax-strings\"/> for information about the "
"syntax of string literals, and to <xref linkend=\"functions\"/> for "
"information about available operators and functions. The database character "
"set determines the character set used to store textual values; for more "
"information on character set support, refer to <xref linkend=\"multibyte\"/>."
msgstr ""
"Подробнее синтаксис текстовых строк описан в <xref remap=\"6\" linkend=\"sql-"
"syntax-strings\"/>, а доступные операторы и функции перечисляются в <xref "
"remap=\"6\" linkend=\"functions\"/>. Кодировка, используемая для хранения "
"текстовых строк, определяется набором символов, выбранным для базы данных. "
"Подробнее это описано в <xref remap=\"6\" linkend=\"multibyte\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1179(title)
msgid "Using the Character Types"
msgstr "Использование символьных типов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1181(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test1 (a character(4));\n"
"INSERT INTO test1 VALUES ('ok');\n"
"SELECT a, char_length(a) FROM test1; -- <co id=\"co.datatype-char\"></co>\n"
"<computeroutput>\n"
"  a   | char_length\n"
"------+-------------\n"
" ok   |           2\n"
"</computeroutput>\n"
"\n"
"CREATE TABLE test2 (b varchar(5));\n"
"INSERT INTO test2 VALUES ('ok');\n"
"INSERT INTO test2 VALUES ('good      ');\n"
"INSERT INTO test2 VALUES ('too long');\n"
"<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>\n"
"INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation\n"
"SELECT b, char_length(b) FROM test2;\n"
"<computeroutput>\n"
"   b   | char_length\n"
"-------+-------------\n"
" ok    |           2\n"
" good  |           5\n"
" too l |           5\n"
"</computeroutput>"
msgstr ""
"CREATE TABLE test1 (a character(4));\n"
"INSERT INTO test1 VALUES ('ok');\n"
"SELECT a, char_length(a) FROM test1; -- <co id=\"co.datatype-char\"></co>\n"
"<computeroutput>\n"
"  a   | char_length\n"
"------+-------------\n"
" ok   |           2\n"
"</computeroutput>\n"
"\n"
"CREATE TABLE test2 (b varchar(5));\n"
"INSERT INTO test2 VALUES ('ok');\n"
"INSERT INTO test2 VALUES ('good      ');\n"
"INSERT INTO test2 VALUES ('too long');\n"
"<computeroutput>ОШИБКА:  значение не умещается в тип character varying(5)</computeroutput>\n"
"INSERT INTO test2 VALUES ('too long'::varchar(5)); -- явное усечение\n"
"SELECT b, char_length(b) FROM test2;\n"
"<computeroutput>\n"
"   b   | char_length\n"
"-------+-------------\n"
" ok    |           2\n"
" good  |           5\n"
" too l |           5\n"
"</computeroutput>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1208(para)
msgid ""
"The <function>char_length</function> function is discussed in <xref linkend="
"\"functions-string\"/>."
msgstr ""
"Функция <function>char_length</function> рассматривается в <xref remap=\"6\" "
"linkend=\"functions-string\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1216(para)
msgid ""
"There are two other fixed-length character types in <productname>PostgreSQL</"
"productname>, shown in <xref linkend=\"datatype-character-special-table\"/>. "
"The <type>name</type> type exists <emphasis>only</emphasis> for the storage "
"of identifiers in the internal system catalogs and is not intended for use "
"by the general user. Its length is currently defined as 64 bytes (63 usable "
"characters plus terminator) but should be referenced using the constant "
"<symbol>NAMEDATALEN</symbol> in <literal>C</literal> source code. The length "
"is set at compile time (and is therefore adjustable for special uses); the "
"default maximum length might change in a future release. The type <type>"
"\"char\"</type> (note the quotes) is different from <type>char(1)</type> in "
"that it only uses one byte of storage. It is internally used in the system "
"catalogs as a simplistic enumeration type."
msgstr ""
"В <productname>PostgreSQL</productname> есть ещё два символьных типа "
"фиксированной длины, приведённые в <xref remap=\"6\" linkend=\"datatype-"
"character-special-table\"/>. Тип <type>name</type> создан <emphasis>только</"
"emphasis> для хранения идентификаторов во внутренних системных таблицах и не "
"предназначен для обычного применения пользователями. В настоящее время его "
"длина составляет 64 байта (63 ASCII-символа плюс конечный знак), но в "
"исходном коде <literal>C</literal> она задаётся константой "
"<symbol>NAMEDATALEN</symbol>. Эта константа определяется во время компиляции "
"(и её можно менять в особых случаях), а кроме того, максимальная длина по "
"умолчанию может быть увеличена в следующих версиях. Тип <type>\"char\"</"
"type> (обратите внимание на кавычки) отличается от <type>char(1)</type> тем, "
"что он фактически хранится в одном байте. Он используется во внутренних "
"системных таблицах для простых перечислений."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1234(title)
msgid "Special Character Types"
msgstr "Специальные символьные типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1245(type)
msgid "\"char\""
msgstr "\"char\""

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1246(entry) datatype.xml:2870(entry)
msgid "1 byte"
msgstr "1 байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1247(entry)
msgid "single-byte internal type"
msgstr "внутренний однобайтный тип"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1250(type)
msgid "name"
msgstr "name"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1251(entry)
msgid "64 bytes"
msgstr "64 байта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1252(entry)
msgid "internal type for object names"
msgstr "внутренний тип для имён объектов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1261(title) datatype.xml:1277(title)
msgid "Binary Data Types"
msgstr "Двоичные типы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1263(indexterm)
msgid "<primary>binary data</primary>"
msgstr "<primary>двоичные данные</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1267(indexterm)
msgid "<primary>bytea</primary>"
msgstr "<primary>bytea</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1271(para)
msgid ""
"The <type>bytea</type> data type allows storage of binary strings; see <xref "
"linkend=\"datatype-binary-table\"/>."
msgstr ""
"Для хранения двоичных данных предназначен тип <type>bytea</type>; см. <xref "
"remap=\"4\" linkend=\"datatype-binary-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1289(entry)
msgid "1 or 4 bytes plus the actual binary string"
msgstr "1 или 4 байта плюс сама двоичная строка"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1290(entry)
msgid "variable-length binary string"
msgstr "двоичная строка переменной длины"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1296(para)
msgid ""
"A binary string is a sequence of octets (or bytes). Binary strings are "
"distinguished from character strings in two ways. First, binary strings "
"specifically allow storing octets of value zero and other <quote>non-"
"printable</quote> octets (usually, octets outside the range 32 to 126). "
"Character strings disallow zero octets, and also disallow any other octet "
"values and sequences of octet values that are invalid according to the "
"database's selected character set encoding. Second, operations on binary "
"strings process the actual bytes, whereas the processing of character "
"strings depends on locale settings. In short, binary strings are appropriate "
"for storing data that the programmer thinks of as <quote>raw bytes</quote>, "
"whereas character strings are appropriate for storing text."
msgstr ""
"Двоичные строки представляют собой последовательность октетов (байт) и имеют "
"два отличия от текстовых строк. Во-первых, в двоичных строках можно хранить "
"байты с кодом 0 и другими <quote>непечатаемыми</quote> значениями (обычно "
"это значения вне диапазона 32..126). В текстовых строках нельзя сохранять "
"нулевые байты, а также значения и последовательности значений, не "
"соответствующие выбранной кодировке базы данных. Во-вторых, в операциях с "
"двоичными строками обрабатываются байты в чистом виде, тогда как текстовые "
"строки обрабатываются в зависимости от языковых стандартов. То есть, "
"двоичные строки больше подходят для данных, которые программист видит как "
"<quote>просто байты</quote>, а символьные строки &mdash; для хранения текста."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1312(para)
msgid ""
"The <type>bytea</type> type supports two external formats for input and "
"output: <productname>PostgreSQL</productname>'s historical <quote>escape</"
"quote> format, and <quote>hex</quote> format. Both of these are always "
"accepted on input. The output format depends on the configuration parameter "
"<xref linkend=\"guc-bytea-output\"/>; the default is hex. (Note that the hex "
"format was introduced in <productname>PostgreSQL</productname> 9.0; earlier "
"versions and some tools don't understand it.)"
msgstr ""
"Тип <type>bytea</type> поддерживает два внешних формата ввода и вывода: "
"традиционный для <productname>PostgreSQL</productname> формат "
"<quote>спецпоследовательностей</quote> и <quote>шестнадцатеричный</quote>. "
"Входные данные принимаются в обоих форматах, а формат выходных данных "
"зависит от параметра конфигурации <xref linkend=\"guc-bytea-output\"/>; по "
"умолчанию выбран шестнадцатеричный. (Заметьте, что шестнадцатеричный формат "
"был введён в <productname>PostgreSQL</productname> 9.0; в ранних версиях и "
"некоторых программах он не будет работать.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1323(para)
msgid ""
"The <acronym>SQL</acronym> standard defines a different binary string type, "
"called <type>BLOB</type> or <type>BINARY LARGE OBJECT</type>. The input "
"format is different from <type>bytea</type>, but the provided functions and "
"operators are mostly the same."
msgstr ""
"Стандарт <acronym>SQL</acronym> определяет другой тип двоичных данных, "
"<type>BLOB</type> (<type>BINARY LARGE OBJECT</type>, большой двоичный "
"объект). Его входной формат отличается от форматов <type>bytea</type>, но "
"функции и операторы в основном те же."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1332(title)
msgid "<type>bytea</type> Hex Format"
msgstr "Шестнадцатеричный формат <type>bytea</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1334(para)
msgid ""
"The <quote>hex</quote> format encodes binary data as 2 hexadecimal digits "
"per byte, most significant nibble first. The entire string is preceded by "
"the sequence <literal>\\x</literal> (to distinguish it from the escape "
"format). In some contexts, the initial backslash may need to be escaped by "
"doubling it, in the same cases in which backslashes have to be doubled in "
"escape format; details appear below. The hexadecimal digits can be either "
"upper or lower case, and whitespace is permitted between digit pairs (but "
"not within a digit pair nor in the starting <literal>\\x</literal> "
"sequence). The hex format is compatible with a wide range of external "
"applications and protocols, and it tends to be faster to convert than the "
"escape format, so its use is preferred."
msgstr ""
"В <quote>шестнадцатеричном</quote> формате двоичные данные кодируются двумя "
"шестнадцатеричными цифрами на байт, при этом первая цифра соответствует "
"старшим 4 битам. К полученной строке добавляется префикс <literal>\\x</"
"literal> (чтобы она отличалась от формата спецпоследовательности). В "
"некоторых контекстах обратную косую черту нужно выделить, продублировав её, "
"в тех же случаях это нужно сделать для формата спецпоследовательности; "
"подробнее это описано ниже. Шестнадцатеричные цифры могут быть в любом "
"регистре, а между парами цифр допускаются пробельные символы (но не внутри "
"пары и не в начале последовательности <literal>\\x</literal>). Этот формат "
"совместим со множеством внешних приложений и протоколов, к тому же обычно "
"преобразуется быстрее, поэтому предпочтительнее использовать его."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1352(programlisting)
#, no-wrap
msgid "SELECT E'\\\\xDEADBEEF';"
msgstr "SELECT E'\\\\xDEADBEEF';"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1350(para)
msgid "Example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1359(title)
msgid "<type>bytea</type> Escape Format"
msgstr "Формат спецпоследовательностей <type>bytea</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1361(para)
msgid ""
"The <quote>escape</quote> format is the traditional <productname>PostgreSQL</"
"productname> format for the <type>bytea</type> type. It takes the approach "
"of representing a binary string as a sequence of ASCII characters, while "
"converting those bytes that cannot be represented as an ASCII character into "
"special escape sequences. If, from the point of view of the application, "
"representing bytes as characters makes sense, then this representation can "
"be convenient. But in practice it is usually confusing because it fuzzes up "
"the distinction between binary strings and character strings, and also the "
"particular escape mechanism that was chosen is somewhat unwieldy. So this "
"format should probably be avoided for most new applications."
msgstr ""
"Формат <quote>спецпоследовательностей</quote> традиционно использовался в "
"<productname>PostgreSQL</productname> для значений типа <type>bytea</type>. "
"В нём двоичная строка представляется в виде последовательности ASCII-"
"символов, а байты, непредставимые в виде ASCII-символов, передаются в виде "
"спецпоследовательностей. Этот формат может быть удобен, если с точки зрения "
"приложения представление байт в виде символов имеет смысл. Но на практике "
"это обычно создаёт путаницу, так как двоичные и символьные строки могут "
"выглядеть одинаково, а кроме того выбранный механизм спецпоследовательностей "
"довольно неуклюж. Поэтому в новых приложениях этот формат обычно не стоит "
"использовать."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1377(para)
msgid ""
"When entering <type>bytea</type> values in escape format, octets of certain "
"values <emphasis>must</emphasis> be escaped, while all octet values "
"<emphasis>can</emphasis> be escaped. In general, to escape an octet, convert "
"it into its three-digit octal value and precede it by a backslash (or two "
"backslashes, if writing the value as a literal using escape string syntax). "
"Backslash itself (octet value 92) can alternatively be represented by double "
"backslashes. <xref linkend=\"datatype-binary-sqlesc\"/> shows the characters "
"that must be escaped, and gives the alternative escape sequences where "
"applicable."
msgstr ""
"Передавая значения <type>bytea</type> в формате спецпоследовательности, "
"байты с определёнными значениями <emphasis>необходимо</emphasis> записывать "
"специальным образом, хотя так <emphasis>можно</emphasis> записывать и все "
"значения. В общем виде для этого значение байта нужно преобразовать в "
"трёхзначное восьмеричное число и добавить перед ним обратную косую черту (и "
"продублировать её, если значение записывается в текстовой спецстроке). Саму "
"обратную косую черту (символ с кодом 92) можно записать в виде двух таких "
"символов. В <xref remap=\"6\" linkend=\"datatype-binary-sqlesc\"/> "
"перечислены символы, которые нужно записывать спецпоследовательностями, и "
"приведены альтернативные варианты записи там, где они возможны."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1394(title)
msgid "<type>bytea</type> Literal Escaped Octets"
msgstr "Спецпоследовательности записи значений <type>bytea</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1398(entry) datatype.xml:1489(entry)
msgid "Decimal Octet Value"
msgstr "Десятичное значение байта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1400(entry)
msgid "Escaped Input Representation"
msgstr ""
"Спецпоследова-\n"
"тельность ввода"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1401(entry) datatype.xml:1492(entry) datatype.xml:1772(entry)
#: datatype.xml:1893(entry) datatype.xml:1955(entry) datatype.xml:2237(entry)
#: datatype.xml:2709(entry)
msgid "Example"
msgstr "Пример"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1402(entry)
msgid "Output Representation"
msgstr "Выводимое представление"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1408(entry)
msgid "0"
msgstr "0"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1409(entry)
msgid "zero octet"
msgstr "нулевой байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1410(literal)
msgid "E'\\\\000'"
msgstr "E'\\\\000'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1411(literal)
msgid "SELECT E'\\\\000'::bytea;"
msgstr "SELECT E'\\\\000'::bytea;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1412(literal)
msgid "\\000"
msgstr "\\000"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1416(entry)
msgid "39"
msgstr "39"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1417(entry)
msgid "single quote"
msgstr "апостроф"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1418(entry)
msgid "<literal>''''</literal> or <literal>E'\\\\047'</literal>"
msgstr "<literal>''''</literal> или <literal>E'\\\\047'</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1419(literal)
msgid "SELECT E'\\''::bytea;"
msgstr "SELECT E'\\''::bytea;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1420(literal)
msgid "'"
msgstr "'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1424(entry) datatype.xml:1500(entry)
msgid "92"
msgstr "92"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1425(entry) datatype.xml:1501(entry)
msgid "backslash"
msgstr "обратная косая черта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1426(entry)
msgid "<literal>E'\\\\\\\\'</literal> or <literal>E'\\\\134'</literal>"
msgstr "<literal>E'\\\\\\\\'</literal> или <literal>E'\\\\134'</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1427(literal)
msgid "SELECT E'\\\\\\\\'::bytea;"
msgstr "SELECT E'\\\\\\\\'::bytea;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1428(literal) datatype.xml:1502(literal)
#: datatype.xml:1504(literal)
msgid "\\\\"
msgstr "\\\\"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1432(entry) datatype.xml:1508(entry)
msgid "0 to 31 and 127 to 255"
msgstr "от 0 до 31 и от 127 до 255"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1433(entry) datatype.xml:1509(entry)
msgid "<quote>non-printable</quote> octets"
msgstr "<quote>непечатаемые</quote> байты"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1434(entry)
msgid "<literal>E'\\\\<replaceable>xxx'</replaceable></literal> (octal value)"
msgstr ""
"<literal>E'\\\\<replaceable>xxx'</replaceable></literal> (значение байта)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1435(literal) datatype.xml:1511(literal)
msgid "SELECT E'\\\\001'::bytea;"
msgstr "SELECT E'\\\\001'::bytea;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1436(literal) datatype.xml:1512(literal)
msgid "\\001"
msgstr "\\001"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1443(para)
msgid ""
"The requirement to escape <emphasis>non-printable</emphasis> octets varies "
"depending on locale settings. In some instances you can get away with "
"leaving them unescaped. Note that the result in each of the examples in "
"<xref linkend=\"datatype-binary-sqlesc\"/> was exactly one octet in length, "
"even though the output representation is sometimes more than one character."
msgstr ""
"Набор <emphasis>непечатаемых</emphasis> символов, которые нужно записывать "
"спецпоследовательностями, определяется языковыми стандартами. В некоторых "
"случаях можно оставить в буквальном виде и другие символы. Заметьте, что во "
"всех примерах в <xref remap=\"6\" linkend=\"datatype-binary-sqlesc\"/> "
"задаётся значение ровно одного байта, хотя выходное представление может "
"состоять из нескольких символов."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1452(para)
msgid ""
"The reason multiple backslashes are required, as shown in <xref linkend="
"\"datatype-binary-sqlesc\"/>, is that an input string written as a string "
"literal must pass through two parse phases in the <productname>PostgreSQL</"
"productname> server. The first backslash of each pair is interpreted as an "
"escape character by the string-literal parser (assuming escape string syntax "
"is used) and is therefore consumed, leaving the second backslash of the "
"pair. (Dollar-quoted strings can be used to avoid this level of escaping.) "
"The remaining backslash is then recognized by the <type>bytea</type> input "
"function as starting either a three digit octal value or escaping another "
"backslash. For example, a string literal passed to the server as "
"<literal>E'\\\\001'</literal> becomes <literal>\\001</literal> after passing "
"through the escape string parser. The <literal>\\001</literal> is then sent "
"to the <type>bytea</type> input function, where it is converted to a single "
"octet with a decimal value of 1. Note that the single-quote character is not "
"treated specially by <type>bytea</type>, so it follows the normal rules for "
"string literals. (See also <xref linkend=\"sql-syntax-strings\"/>.)"
msgstr ""
"Необходимость дублирования обратных косых черт в записи "
"спецпоследовательностей, показанного в <xref remap=\"6\" linkend=\"datatype-"
"binary-sqlesc\"/>, объясняется тем, что строковая константа должна пройти "
"два этапа разбора на сервере <productname>PostgreSQL</productname>. Первая "
"обратная косая черта из каждой пары воспринимается анализатором строки как "
"спецсимвол (если используется синтаксис спецпоследовательностей) и таким "
"образом пропускается, оставляя только вторую косую черту. (Для избавления от "
"этой вложенности можно использовать строки в долларах.) Оставшаяся обратная "
"косая черта затем распознаётся функцией ввода <type>bytea</type> как "
"спецсимвол, предваряющий трёхзначное восьмеричное значение или следующий "
"спецсимвол. Например, переданная серверу строковая константа <literal>E'\\"
"\\001'</literal> преобразуется в <literal>\\001</literal>, проходя через "
"анализатор спецстрок. Затем строка <literal>\\001</literal> передаётся "
"функции ввода типа <type>bytea</type>, где она преобразуется в один байт с "
"десятичным значением 1. Заметьте, что символ апостроф для функции ввода "
"<type>bytea</type> не отличается от остальных, поэтому он записывается как "
"обычно принято в строках. (См. также <xref remap=\"4\" linkend=\"sql-syntax-"
"strings\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1474(para)
msgid ""
"<type>Bytea</type> octets are sometimes escaped when output. In general, "
"each <quote>non-printable</quote> octet is converted into its equivalent "
"three-digit octal value and preceded by one backslash. Most "
"<quote>printable</quote> octets are represented by their standard "
"representation in the client character set. The octet with decimal value 92 "
"(backslash) is doubled in the output. Details are in <xref linkend="
"\"datatype-binary-resesc\"/>."
msgstr ""
"Данные <type>bytea</type> иногда выводятся также в спецпоследовательностях. "
"При этом каждый <quote>непечатаемый</quote> байт представляется в виде "
"трёхзначного восьмеричного значения после обратной косой черты. Большинство "
"<quote>печатаемых</quote> байт представляются обычными символами из "
"клиентского набора символов. Байт с десятичным кодом 92 (обратная косая "
"черта) при выводе дублируется. Это иллюстрирует <xref linkend=\"datatype-"
"binary-resesc\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1485(title)
msgid "<type>bytea</type> Output Escaped Octets"
msgstr "Спецпоследовательности выходных значений <type>bytea</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1491(entry)
msgid "Escaped Output Representation"
msgstr "Спецпоследовательность вывода"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1493(entry)
msgid "Output Result"
msgstr "Выводимый результат"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1503(literal)
msgid "SELECT E'\\\\134'::bytea;"
msgstr "SELECT E'\\\\134'::bytea;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1510(entry)
msgid "<literal>\\<replaceable>xxx</replaceable></literal> (octal value)"
msgstr "<literal>\\<replaceable>xxx</replaceable></literal> (значение байта)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1516(entry)
msgid "32 to 126"
msgstr "от 32 до 126"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1517(entry)
msgid "<quote>printable</quote> octets"
msgstr "<quote>печатаемые</quote> байты"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1518(entry)
msgid "client character set representation"
msgstr "представление из клиентского набора символов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1519(literal)
msgid "SELECT E'\\\\176'::bytea;"
msgstr "SELECT E'\\\\176'::bytea;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1520(literal)
msgid "~"
msgstr "~"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1527(para)
msgid ""
"Depending on the front end to <productname>PostgreSQL</productname> you use, "
"you might have additional work to do in terms of escaping and unescaping "
"<type>bytea</type> strings. For example, you might also have to escape line "
"feeds and carriage returns if your interface automatically translates these."
msgstr ""
"В зависимости от применяемой клиентской библиотеки <productname>PostgreSQL</"
"productname>, для преобразования значений <type>bytea</type> в спецстроки и "
"обратно могут потребоваться дополнительные действия. Например, если "
"приложение сохраняет в строках символы перевода строк, возможно их также "
"нужно будет представить спецпоследовательностями."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1539(title) datatype.xml:1584(title)
msgid "Date/Time Types"
msgstr "Типы даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1541(indexterm) datatype.xml:1758(indexterm)
msgid "<primary>date</primary>"
msgstr "<primary>date</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1544(indexterm) datatype.xml:1855(indexterm)
msgid "<primary>time</primary>"
msgstr "<primary>time</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1547(indexterm) datatype.xml:1858(indexterm)
msgid "<primary>time without time zone</primary>"
msgstr "<primary>time without time zone</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1550(indexterm) datatype.xml:1861(indexterm)
msgid "<primary>time with time zone</primary>"
msgstr "<primary>time with time zone</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1553(indexterm) datatype.xml:2005(indexterm)
msgid "<primary>timestamp</primary>"
msgstr "<primary>timestamp</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1556(indexterm)
msgid "<primary>timestamptz</primary>"
msgstr "<primary>timestamptz</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1559(indexterm) datatype.xml:2009(indexterm)
msgid "<primary>timestamp with time zone</primary>"
msgstr "<primary>timestamp with time zone</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1562(indexterm) datatype.xml:2013(indexterm)
msgid "<primary>timestamp without time zone</primary>"
msgstr "<primary>timestamp without time zone</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1565(indexterm) datatype.xml:2536(indexterm)
msgid "<primary>interval</primary>"
msgstr "<primary>interval</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1568(indexterm)
msgid "<primary>time span</primary>"
msgstr "<primary>time span</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1572(para)
msgid ""
"<productname>PostgreSQL</productname> supports the full set of <acronym>SQL</"
"acronym> date and time types, shown in <xref linkend=\"datatype-datetime-"
"table\"/>. The operations available on these data types are described in "
"<xref linkend=\"functions-datetime\"/>. Dates are counted according to the "
"Gregorian calendar, even in years before that calendar was introduced (see "
"<xref linkend=\"datetime-units-history\"/> for more information)."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает полный набор типов даты и "
"времени <acronym>SQL</acronym>, показанный в <xref remap=\"6\" linkend="
"\"datatype-datetime-table\"/>. Операции, возможные с этими типами данных, "
"описаны в <xref remap=\"6\" linkend=\"functions-datetime\"/>. Все даты "
"считаются по Григорианскому календарю, даже для времени до его введения (за "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"datetime-"
"units-history\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1591(entry)
msgid "Low Value"
msgstr "Наименьшее значение"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1592(entry)
msgid "High Value"
msgstr "Наибольшее значение"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1593(entry)
msgid "Resolution"
msgstr "Точность"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1600(entry)
msgid "both date and time (no time zone)"
msgstr "дата и время (без часового пояса)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1601(entry) datatype.xml:1609(entry) datatype.xml:1617(entry)
msgid "4713 BC"
msgstr "4713 до н. э."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1602(entry) datatype.xml:1610(entry)
msgid "294276 AD"
msgstr "294276 н. э."

#. +> REL_10
#: datatype.xml:1603(entry) datatype.xml:1611(entry) datatype.xml:1627(entry)
#: datatype.xml:1635(entry) datatype.xml:1643(entry)
msgid "1 microsecond"
msgstr "1 микросекунда"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1608(entry)
msgid "both date and time, with time zone"
msgstr "дата и время (с часовым поясом)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1616(entry)
msgid "date (no time of day)"
msgstr "дата (без времени суток)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1618(entry)
msgid "5874897 AD"
msgstr "5874897 н. э."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1619(entry)
msgid "1 day"
msgstr "1 день"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1624(entry)
msgid "time of day (no date)"
msgstr "время суток (без даты)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1625(entry)
msgid "00:00:00"
msgstr "00:00:00"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1626(entry)
msgid "24:00:00"
msgstr "24:00:00"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1631(entry)
msgid "12 bytes"
msgstr "12 байт"

#. +> REL_10
#: datatype.xml:1632(entry)
msgid "time of day (no date), with time zone"
msgstr "время дня (без даты), с часовым поясом"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1633(entry)
msgid "00:00:00+1459"
msgstr "00:00:00+1459"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1634(entry)
msgid "24:00:00-1459"
msgstr "24:00:00-1459"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1639(entry) datatype.xml:3109(entry)
msgid "16 bytes"
msgstr "16 байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1640(entry)
msgid "time interval"
msgstr "временной интервал"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1641(entry)
msgid "-178000000 years"
msgstr "-178000000 лет"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1642(entry)
msgid "178000000 years"
msgstr "178000000 лет"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1650(para)
msgid ""
"The SQL standard requires that writing just <type>timestamp</type> be "
"equivalent to <type>timestamp without time zone</type>, and "
"<productname>PostgreSQL</productname> honors that behavior. "
"<type>timestamptz</type> is accepted as an abbreviation for <type>timestamp "
"with time zone</type>; this is a <productname>PostgreSQL</productname> "
"extension."
msgstr ""
"Стандарт SQL требует, чтобы тип <type>timestamp</type> подразумевал "
"<type>timestamp without time zone</type> (время без часового пояса), и "
"<productname>PostgreSQL</productname> следует этому. Для краткости "
"<type>timestamp with time zone</type> можно записать как <type>timestamptz</"
"type>; это расширение <productname>PostgreSQL</productname>."

#. +> REL_10
#: datatype.xml:1660(para)
msgid ""
"<type>time</type>, <type>timestamp</type>, and <type>interval</type> accept "
"an optional precision value <replaceable>p</replaceable> which specifies the "
"number of fractional digits retained in the seconds field. By default, there "
"is no explicit bound on precision. The allowed range of <replaceable>p</"
"replaceable> is from 0 to 6."
msgstr ""
"Типы <type>time</type>, <type>timestamp</type> и <type>interval</type> "
"принимают необязательное значение точности <replaceable>p</replaceable>, "
"определяющее, сколько знаков после запятой должно сохраняться в секундах. По "
"умолчанию точность не ограничивается. Допустимые значения <replaceable>p</"
"replaceable> лежат в интервале от 0 до 6."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1669(para)
msgid ""
"The <type>interval</type> type has an additional option, which is to "
"restrict the set of stored fields by writing one of these phrases: "
"<literallayout class=\"monospaced\">\n"
"YEAR\n"
"MONTH\n"
"DAY\n"
"HOUR\n"
"MINUTE\n"
"SECOND\n"
"YEAR TO MONTH\n"
"DAY TO HOUR\n"
"DAY TO MINUTE\n"
"DAY TO SECOND\n"
"HOUR TO MINUTE\n"
"HOUR TO SECOND\n"
"MINUTE TO SECOND\n"
"</literallayout> Note that if both <replaceable>fields</replaceable> and "
"<replaceable>p</replaceable> are specified, the <replaceable>fields</"
"replaceable> must include <literal>SECOND</literal>, since the precision "
"applies only to the seconds."
msgstr ""
"Тип <type>interval</type> дополнительно позволяет ограничить набор "
"сохраняемых поле следующими фразами: <literallayout class=\"monospaced\">\n"
"YEAR\n"
"MONTH\n"
"DAY\n"
"HOUR\n"
"MINUTE\n"
"SECOND\n"
"YEAR TO MONTH\n"
"DAY TO HOUR\n"
"DAY TO MINUTE\n"
"DAY TO SECOND\n"
"HOUR TO MINUTE\n"
"HOUR TO SECOND\n"
"MINUTE TO SECOND\n"
"</literallayout> Заметьте, что если указаны и <replaceable>поля</"
"replaceable>, и точность <replaceable>p</replaceable>, указание "
"<replaceable>поля</replaceable> должно включать <literal>SECOND</literal>, "
"так как точность применима только к секундам."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1693(para)
msgid ""
"The type <type>time with time zone</type> is defined by the SQL standard, "
"but the definition exhibits properties which lead to questionable "
"usefulness. In most cases, a combination of <type>date</type>, <type>time</"
"type>, <type>timestamp without time zone</type>, and <type>timestamp with "
"time zone</type> should provide a complete range of date/time functionality "
"required by any application."
msgstr ""
"Тип <type>time with time zone</type> определён стандартом SQL, но в его "
"определении описаны свойства сомнительной ценности. В большинстве случаев "
"сочетание типов <type>date</type>, <type>time</type>, <type>timestamp "
"without time zone</type> и <type>timestamp with time zone</type> "
"удовлетворяет все потребности в функционале дат/времени, возникающие в "
"приложениях."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1703(para)
msgid ""
"The types <type>abstime</type> and <type>reltime</type> are lower precision "
"types which are used internally. You are discouraged from using these types "
"in applications; these internal types might disappear in a future release."
msgstr ""
"Типы <type>abstime</type> и <type>reltime</type> имеют меньшую точность и "
"предназначены для внутреннего использования. Эти типы не рекомендуется "
"использовать в обычных приложениях; их может не быть в будущих версиях."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1712(title)
msgid "Date/Time Input"
msgstr "Ввод даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1714(para)
msgid ""
"Date and time input is accepted in almost any reasonable format, including "
"ISO 8601, <acronym>SQL</acronym>-compatible, traditional "
"<productname>POSTGRES</productname>, and others. For some formats, ordering "
"of day, month, and year in date input is ambiguous and there is support for "
"specifying the expected ordering of these fields. Set the <xref linkend="
"\"guc-datestyle\"/> parameter to <literal>MDY</literal> to select month-day-"
"year interpretation, <literal>DMY</literal> to select day-month-year "
"interpretation, or <literal>YMD</literal> to select year-month-day "
"interpretation."
msgstr ""
"Значения даты и времени принимаются практически в любом разумном формате, "
"включая ISO 8601, <acronym>SQL</acronym>-совместимый, традиционный формат "
"<productname>POSTGRES</productname> и другие. В некоторых форматах порядок "
"даты, месяца и года во вводимой дате неоднозначен и поэтому поддерживается "
"явное определение формата. Для этого предназначен параметр <xref linkend="
"\"guc-datestyle\"/>. Когда он имеет значение <literal>MDY</literal>, "
"выбирается интерпретация месяц-день-год, значению <literal>DMY</literal> "
"соответствует день-месяц-год, а <literal>YMD</literal> &mdash; год-месяц-"
"день."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1726(para)
msgid ""
"<productname>PostgreSQL</productname> is more flexible in handling date/time "
"input than the <acronym>SQL</acronym> standard requires. See <xref linkend="
"\"datetime-appendix\"/> for the exact parsing rules of date/time input and "
"for the recognized text fields including months, days of the week, and time "
"zones."
msgstr ""
"<productname>PostgreSQL</productname> обрабатывает вводимые значения даты/"
"времени более гибко, чем того требует стандарт <acronym>SQL</acronym>. "
"Точные правила разбора даты/времени и распознаваемые текстовые поля, в том "
"числе названия месяцев, дней недели и часовых поясов описаны в <xref remap="
"\"6\" linkend=\"datetime-appendix\"/>."

#. +> REL_10
#: datatype.xml:1736(para)
msgid ""
"Remember that any date or time literal input needs to be enclosed in single "
"quotes, like text strings. Refer to <xref linkend=\"sql-syntax-constants-"
"generic\"/> for more information. <acronym>SQL</acronym> requires the "
"following syntax <synopsis>\n"
"<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] "
"'<replaceable>value</replaceable>'\n"
"</synopsis> where <replaceable>p</replaceable> is an optional precision "
"specification giving the number of fractional digits in the seconds field. "
"Precision can be specified for <type>time</type>, <type>timestamp</type>, "
"and <type>interval</type> types, and can range from 0 to 6. If no precision "
"is specified in a constant specification, it defaults to the precision of "
"the literal value (but not more than 6 digits)."
msgstr ""
"Помните, что любые вводимые значения даты и времени нужно заключать в "
"апострофы, как текстовые строки. За дополнительной информацией обратитесь к "
"<xref remap=\"3\" linkend=\"sql-syntax-constants-generic\"/>. <acronym>SQL</"
"acronym> предусматривает следующий синтаксис: <synopsis>\n"
"<replaceable>тип</replaceable> [ (<replaceable>p</replaceable>) ] "
"'<replaceable>значение</replaceable>'\n"
"</synopsis> Здесь <replaceable>p</replaceable> &mdash; необязательное "
"указание точности, определяющее число знаков после точки в секундах. "
"Точность может быть определена для типов <type>time</type>, <type>timestamp</"
"type> и <type>interval</type> в интервале от 0 до 6. Если в определении "
"константы точность не указана, она считается равной точности значения в "
"строке (но не больше 6 цифр)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1756(title)
msgid "Dates"
msgstr "Даты"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1762(para)
msgid ""
"<xref linkend=\"datatype-datetime-date-table\"/> shows some possible inputs "
"for the <type>date</type> type."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-datetime-date-table\"/> приведены "
"некоторые допустимые значения типа <type>date</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1768(title)
msgid "Date Input"
msgstr "Вводимые даты"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1778(entry)
msgid "1999-01-08"
msgstr "1999-01-08"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1779(entry)
msgid "ISO 8601; January 8 in any mode (recommended format)"
msgstr "ISO 8601; 8 января в любом режиме (рекомендуемый формат)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1783(entry)
msgid "January 8, 1999"
msgstr "January 8, 1999"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1784(entry)
msgid "unambiguous in any <varname>datestyle</varname> input mode"
msgstr "воспринимается однозначно в любом режиме <varname>datestyle</varname>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1787(entry)
msgid "1/8/1999"
msgstr "1/8/1999"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1788(entry)
msgid ""
"January 8 in <literal>MDY</literal> mode; August 1 in <literal>DMY</literal> "
"mode"
msgstr ""
"8 января в режиме <literal>MDY</literal> и 1 августа в режиме <literal>DMY</"
"literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1792(entry)
msgid "1/18/1999"
msgstr "1/18/1999"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1793(entry)
msgid "January 18 in <literal>MDY</literal> mode; rejected in other modes"
msgstr ""
"18 января в режиме <literal>MDY</literal>; недопустимая дата в других режимах"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1797(entry)
msgid "01/02/03"
msgstr "01/02/03"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1798(entry)
msgid ""
"January 2, 2003 in <literal>MDY</literal> mode; February 1, 2003 in "
"<literal>DMY</literal> mode; February 3, 2001 in <literal>YMD</literal> mode"
msgstr ""
"2 января 2003 г. в режиме <literal>MDY</literal>; 1 февраля 2003 г. в режиме "
"<literal>DMY</literal> и 3 февраля 2001 г. в режиме <literal>YMD</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1804(entry)
msgid "1999-Jan-08"
msgstr "1999-Jan-08"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1805(entry) datatype.xml:1809(entry) datatype.xml:1813(entry)
msgid "January 8 in any mode"
msgstr "8 января в любом режиме"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1808(entry)
msgid "Jan-08-1999"
msgstr "Jan-08-1999"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1812(entry)
msgid "08-Jan-1999"
msgstr "08-Jan-1999"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1816(entry)
msgid "99-Jan-08"
msgstr "99-Jan-08"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1817(entry)
msgid "January 8 in <literal>YMD</literal> mode, else error"
msgstr "8 января в режиме <literal>YMD</literal>; ошибка в других режимах"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1820(entry)
msgid "08-Jan-99"
msgstr "08-Jan-99"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1821(entry) datatype.xml:1825(entry)
msgid "January 8, except error in <literal>YMD</literal> mode"
msgstr "8 января; ошибка в режиме <literal>YMD</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1824(entry)
msgid "Jan-08-99"
msgstr "Jan-08-99"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1828(entry)
msgid "19990108"
msgstr "19990108"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1829(entry) datatype.xml:1833(entry)
msgid "ISO 8601; January 8, 1999 in any mode"
msgstr "ISO 8601; 8 января 1999 в любом режиме"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1832(entry)
msgid "990108"
msgstr "990108"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1836(entry)
msgid "1999.008"
msgstr "1999.008"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1837(entry)
msgid "year and day of year"
msgstr "год и день года"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1840(entry)
msgid "J2451187"
msgstr "J2451187"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1841(entry)
msgid "Julian date"
msgstr "дата по юлианскому календарю"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1844(entry)
msgid "January 8, 99 BC"
msgstr "January 8, 99 BC"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1845(entry)
msgid "year 99 BC"
msgstr "99 до н. э."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1853(title)
msgid "Times"
msgstr "Время"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1865(para)
msgid ""
"The time-of-day types are <type>time [ (<replaceable>p</replaceable>) ] "
"without time zone</type> and <type>time [ (<replaceable>p</replaceable>) ] "
"with time zone</type>. <type>time</type> alone is equivalent to <type>time "
"without time zone</type>."
msgstr ""
"Для хранения времени суток без даты предназначены типы <type>time "
"[ (<replaceable>p</replaceable>) ] without time zone</type> и <type>time "
"[ (<replaceable>p</replaceable>) ] with time zone</type>. Тип <type>time</"
"type> без уточнения эквивалентен типу <type>time without time zone</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1873(para)
msgid ""
"Valid input for these types consists of a time of day followed by an "
"optional time zone. (See <xref linkend=\"datatype-datetime-time-table\"/> "
"and <xref linkend=\"datatype-timezone-table\"/>.) If a time zone is "
"specified in the input for <type>time without time zone</type>, it is "
"silently ignored. You can also specify a date but it will be ignored, except "
"when you use a time zone name that involves a daylight-savings rule, such as "
"<literal>America/New_York</literal>. In this case specifying the date is "
"required in order to determine whether standard or daylight-savings time "
"applies. The appropriate time zone offset is recorded in the <type>time with "
"time zone</type> value."
msgstr ""
"Допустимые вводимые значения этих типов состоят из записи времени суток и "
"необязательного указания часового пояса. (См. <xref remap=\"4\" linkend="
"\"datatype-datetime-time-table\"/> и <xref remap=\"4\" linkend=\"datatype-"
"timezone-table\"/>.) Если в значении для типа <type>time without time zone</"
"type> указывается часовой пояс, он просто игнорируется. Так же будет "
"игнорироваться дата, если её указать, за исключением случаев, когда в "
"указанном часовом поясе принят переход на летнее время, например "
"<literal>America/New_York</literal>. В данном случае указать дату "
"необходимо, чтобы система могла определить, применяется ли обычное или "
"летнее время. Соответствующее смещение часового пояса записывается в "
"значении <type>time with time zone</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1889(title)
msgid "Time Input"
msgstr "Вводимое время"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1899(literal)
msgid "04:05:06.789"
msgstr "04:05:06.789"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1900(entry) datatype.xml:1904(entry) datatype.xml:1908(entry)
#: datatype.xml:1912(entry) datatype.xml:1924(entry) datatype.xml:1928(entry)
#: datatype.xml:1932(entry) datatype.xml:1936(entry)
msgid "ISO 8601"
msgstr "ISO 8601"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1903(literal)
msgid "04:05:06"
msgstr "04:05:06"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1907(literal)
msgid "04:05"
msgstr "04:05"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1911(literal)
msgid "040506"
msgstr "040506"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1915(literal)
msgid "04:05 AM"
msgstr "04:05 AM"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1916(entry)
msgid "same as 04:05; AM does not affect value"
msgstr "то же, что и 04:05; AM не меняет значение времени"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1919(literal)
msgid "04:05 PM"
msgstr "04:05 PM"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1920(entry)
msgid "same as 16:05; input hour must be &lt;= 12"
msgstr "то же, что и 16:05; часы должны быть &lt;= 12"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1923(literal)
msgid "04:05:06.789-8"
msgstr "04:05:06.789-8"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1927(literal)
msgid "04:05:06-08:00"
msgstr "04:05:06-08:00"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1931(literal)
msgid "04:05-08:00"
msgstr "04:05-08:00"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1935(literal)
msgid "040506-08"
msgstr "040506-08"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1939(literal)
msgid "04:05:06 PST"
msgstr "04:05:06 PST"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1940(entry)
msgid "time zone specified by abbreviation"
msgstr "часовой пояс задаётся аббревиатурой"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1943(literal)
msgid "2003-04-12 04:05:06 America/New_York"
msgstr "2003-04-12 04:05:06 America/New_York"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1944(entry)
msgid "time zone specified by full name"
msgstr "часовой пояс задаётся полным названием"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1951(title)
msgid "Time Zone Input"
msgstr "Вводимый часовой пояс"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1961(literal)
msgid "PST"
msgstr "PST"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1962(entry)
msgid "Abbreviation (for Pacific Standard Time)"
msgstr "аббревиатура (Pacific Standard Time, Стандартное тихоокеанское время)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1965(literal)
msgid "America/New_York"
msgstr "America/New_York"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1966(entry)
msgid "Full time zone name"
msgstr "полное название часового пояса"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1969(literal)
msgid "PST8PDT"
msgstr "PST8PDT"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1970(entry)
msgid "POSIX-style time zone specification"
msgstr "указание часового пояса в стиле POSIX"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1973(literal)
msgid "-8:00"
msgstr "-8:00"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1974(entry) datatype.xml:1978(entry) datatype.xml:1982(entry)
msgid "ISO-8601 offset for PST"
msgstr "смещение часового пояса PST по ISO-8601"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1977(literal)
msgid "-800"
msgstr "-800"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1981(literal)
msgid "-8"
msgstr "-8"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1985(literal)
msgid "zulu"
msgstr "zulu"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1986(entry)
msgid "Military abbreviation for UTC"
msgstr "принятое у военных сокращение UTC"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1989(literal)
msgid "z"
msgstr "z"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1990(entry)
msgid "Short form of <literal>zulu</literal>"
msgstr "краткая форма <literal>zulu</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:1996(para)
msgid ""
"Refer to <xref linkend=\"datatype-timezones\"/> for more information on how "
"to specify time zones."
msgstr ""
"Подробнее узнать о том, как указывается часовой пояс, можно в <xref remap="
"\"6\" linkend=\"datatype-timezones\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2003(title)
msgid "Time Stamps"
msgstr "Даты и время"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2025(programlisting)
#, no-wrap
msgid "1999-01-08 04:05:06"
msgstr "1999-01-08 04:05:06"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2029(programlisting)
#, no-wrap
msgid "1999-01-08 04:05:06 -8:00"
msgstr "1999-01-08 04:05:06 -8:00"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2035(programlisting)
#, no-wrap
msgid "January 8 04:05:06 1999 PST"
msgstr "January 8 04:05:06 1999 PST"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2017(para)
msgid ""
"Valid input for the time stamp types consists of the concatenation of a date "
"and a time, followed by an optional time zone, followed by an optional "
"<literal>AD</literal> or <literal>BC</literal>. (Alternatively, <literal>AD</"
"literal>/<literal>BC</literal> can appear before the time zone, but this is "
"not the preferred ordering.) Thus: <placeholder-1/> and: <placeholder-2/> "
"are valid values, which follow the <acronym>ISO</acronym> 8601 standard. In "
"addition, the common format: <placeholder-3/> is supported."
msgstr ""
"Допустимые значения типов timestamp состоят из записи даты и времени, после "
"которого может указываться часовой пояс и необязательное уточнение "
"<literal>AD</literal> или <literal>BC</literal>, определяющее эпоху до нашей "
"эры и нашу эру соответственно. (<literal>AD</literal>/<literal>BC</literal> "
"можно указать и перед часовым поясом, но предпочтительнее первый вариант.) "
"Таким образом: <placeholder-1/> и <placeholder-2/> допустимые варианты, "
"соответствующие стандарту <acronym>ISO</acronym> 8601. В дополнение к этому "
"поддерживается распространённый формат: <placeholder-3/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2048(programlisting)
#, no-wrap
msgid "TIMESTAMP '2004-10-19 10:23:54'"
msgstr "TIMESTAMP '2004-10-19 10:23:54'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2052(programlisting)
#, no-wrap
msgid "TIMESTAMP '2004-10-19 10:23:54+02'"
msgstr "TIMESTAMP '2004-10-19 10:23:54+02'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2061(programlisting)
#, no-wrap
msgid "TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'"
msgstr "TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2041(para)
msgid ""
"The <acronym>SQL</acronym> standard differentiates <type>timestamp without "
"time zone</type> and <type>timestamp with time zone</type> literals by the "
"presence of a <quote>+</quote> or <quote>-</quote> symbol and time zone "
"offset after the time. Hence, according to the standard, <placeholder-1/> is "
"a <type>timestamp without time zone</type>, while <placeholder-2/> is a "
"<type>timestamp with time zone</type>. <productname>PostgreSQL</productname> "
"never examines the content of a literal string before determining its type, "
"and therefore will treat both of the above as <type>timestamp without time "
"zone</type>. To ensure that a literal is treated as <type>timestamp with "
"time zone</type>, give it the correct explicit type: <placeholder-3/> In a "
"literal that has been determined to be <type>timestamp without time zone</"
"type>, <productname>PostgreSQL</productname> will silently ignore any time "
"zone indication. That is, the resulting value is derived from the date/time "
"fields in the input value, and is not adjusted for time zone."
msgstr ""
"Стандарт <acronym>SQL</acronym> различает константы типов <type>timestamp "
"without time zone</type> и <type>timestamp with time zone</type> по знаку "
"<quote>+</quote> или <quote>-</quote> и смещению часового пояса, "
"добавленному после времени. Следовательно, согласно стандарту, записи "
"<placeholder-1/> должен соответствовать тип <type>timestamp without time "
"zone</type>, а <placeholder-2/> тип <type>timestamp with time zone</type>. "
"<productname>PostgreSQL</productname> никогда не анализирует содержимое "
"текстовой строки, чтобы определить тип значения, и поэтому обе записи будут "
"обработаны как значения типа <type>timestamp without time zone</type>. Чтобы "
"текстовая константа обрабатывалась как <type>timestamp with time zone</"
"type>, укажите этот тип явно: <placeholder-3/> В константе типа "
"<type>timestamp without time zone</type> <productname>PostgreSQL</"
"productname> просто игнорирует часовой пояс. То есть результирующее значение "
"вычисляется только из полей даты/времени и не подстраивается под указанный "
"часовой пояс."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2070(para)
msgid ""
"For <type>timestamp with time zone</type>, the internally stored value is "
"always in UTC (Universal Coordinated Time, traditionally known as Greenwich "
"Mean Time, <acronym>GMT</acronym>). An input value that has an explicit time "
"zone specified is converted to UTC using the appropriate offset for that "
"time zone. If no time zone is stated in the input string, then it is assumed "
"to be in the time zone indicated by the system's <xref linkend=\"guc-timezone"
"\"/> parameter, and is converted to UTC using the offset for the "
"<varname>timezone</varname> zone."
msgstr ""
"Значения <type>timestamp with time zone</type> внутри всегда хранятся в UTC "
"(Universal Coordinated Time, Всемирное скоординированное время или время по "
"Гринвичу, <acronym>GMT</acronym>). Вводимое значение, в котором явно указан "
"часовой пояс, переводится в UTC с учётом смещения данного часового пояса. "
"Если во входной строке не указан часовой пояс, подразумевается часовой пояс, "
"заданный системным параметром <xref linkend=\"guc-timezone\"/> и время так "
"же пересчитывается в UTC со смещением <varname>timezone</varname>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2082(para)
msgid ""
"When a <type>timestamp with time zone</type> value is output, it is always "
"converted from UTC to the current <varname>timezone</varname> zone, and "
"displayed as local time in that zone. To see the time in another time zone, "
"either change <varname>timezone</varname> or use the <literal>AT TIME ZONE</"
"literal> construct (see <xref linkend=\"functions-datetime-zoneconvert\"/>)."
msgstr ""
"Когда значение <type>timestamp with time zone</type> выводится, оно всегда "
"преобразуется из UTC в текущий часовой пояс <varname>timezone</varname> и "
"отображается как локальное время. Чтобы получить время для другого часового "
"пояса, нужно либо изменить <varname>timezone</varname>, либо воспользоваться "
"конструкцией <literal>AT TIME ZONE</literal> (см. <xref remap=\"4\" linkend="
"\"functions-datetime-zoneconvert\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2091(para)
msgid ""
"Conversions between <type>timestamp without time zone</type> and "
"<type>timestamp with time zone</type> normally assume that the "
"<type>timestamp without time zone</type> value should be taken or given as "
"<varname>timezone</varname> local time. A different time zone can be "
"specified for the conversion using <literal>AT TIME ZONE</literal>."
msgstr ""
"В преобразованиях между <type>timestamp without time zone</type> и "
"<type>timestamp with time zone</type> обычно предполагается, что значение "
"<type>timestamp without time zone</type> содержит местное время (для "
"часового пояса <varname>timezone</varname>). Другой часовой пояс для "
"преобразования можно задать с помощью <literal>AT TIME ZONE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2101(title)
msgid "Special Values"
msgstr "Специальные значения"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2103(indexterm)
msgid "<primary>time</primary> <secondary>constants</secondary>"
msgstr "<primary>время</primary> <secondary>константы</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2108(indexterm)
msgid "<primary>date</primary> <secondary>constants</secondary>"
msgstr "<primary>дата</primary> <secondary>константы</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2113(para)
msgid ""
"<productname>PostgreSQL</productname> supports several special date/time "
"input values for convenience, as shown in <xref linkend=\"datatype-datetime-"
"special-table\"/>. The values <literal>infinity</literal> and <literal>-"
"infinity</literal> are specially represented inside the system and will be "
"displayed unchanged; but the others are simply notational shorthands that "
"will be converted to ordinary date/time values when read. (In particular, "
"<literal>now</literal> and related strings are converted to a specific time "
"value as soon as they are read.) All of these values need to be enclosed in "
"single quotes when used as constants in SQL commands."
msgstr ""
"<productname>PostgreSQL</productname> для удобства поддерживает несколько "
"специальных значений даты/времени, перечисленных в <xref remap=\"6\" linkend="
"\"datatype-datetime-special-table\"/>. Значения <literal>infinity</literal> "
"и <literal>-infinity</literal> имеют особое представление в системе и они "
"отображаются в том же виде, тогда как другие варианты при чтении "
"преобразуются в значения даты/времени. (В частности, <literal>now</literal> "
"и подобные строки преобразуются в актуальные значения времени в момент "
"чтения.) Чтобы использовать эти значения в качестве констант в командах SQL, "
"их нужно заключать в апострофы."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2128(title)
msgid "Special Date/Time Inputs"
msgstr "Специальные значения даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2132(entry)
msgid "Input String"
msgstr "Вводимая строка"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2133(entry)
msgid "Valid Types"
msgstr "Допустимые типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2139(literal)
msgid "epoch"
msgstr "epoch"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2140(entry) datatype.xml:2145(entry) datatype.xml:2150(entry)
#: datatype.xml:2160(entry) datatype.xml:2165(entry) datatype.xml:2170(entry)
msgid "<type>date</type>, <type>timestamp</type>"
msgstr "<type>date</type>, <type>timestamp</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2141(entry)
msgid "1970-01-01 00:00:00+00 (Unix system time zero)"
msgstr "1970-01-01 00:00:00+00 (точка отсчёта времени в Unix)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2144(literal)
msgid "infinity"
msgstr "infinity"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2146(entry)
msgid "later than all other time stamps"
msgstr "время после максимальной допустимой даты"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2149(literal)
msgid "-infinity"
msgstr "-infinity"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2151(entry)
msgid "earlier than all other time stamps"
msgstr "время до минимальной допустимой даты"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2154(literal)
msgid "now"
msgstr "now"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2155(entry)
msgid "<type>date</type>, <type>time</type>, <type>timestamp</type>"
msgstr "<type>date</type>, <type>time</type>, <type>timestamp</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2156(entry)
msgid "current transaction's start time"
msgstr "время начала текущей транзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2159(literal)
msgid "today"
msgstr "today"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2161(entry)
msgid "midnight today"
msgstr "время начала текущих суток"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2164(literal)
msgid "tomorrow"
msgstr "tomorrow"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2166(entry)
msgid "midnight tomorrow"
msgstr "время начала следующих суток"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2169(literal)
msgid "yesterday"
msgstr "yesterday"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2171(entry)
msgid "midnight yesterday"
msgstr "время начала предыдущих суток"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2174(literal)
msgid "allballs"
msgstr "allballs"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2175(type)
msgid "time"
msgstr "time"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2176(entry)
msgid "00:00:00.00 UTC"
msgstr "00:00:00.00 UTC"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2182(para)
msgid ""
"The following <acronym>SQL</acronym>-compatible functions can also be used "
"to obtain the current time value for the corresponding data type: "
"<literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>, "
"<literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>, "
"<literal>LOCALTIMESTAMP</literal>. The latter four accept an optional "
"subsecond precision specification. (See <xref linkend=\"functions-datetime-"
"current\"/>.) Note that these are SQL functions and are <emphasis>not</"
"emphasis> recognized in data input strings."
msgstr ""
"Для получения текущей даты/времени соответствующего типа можно также "
"использовать следующие <acronym>SQL</acronym>-совместимые функции: "
"<literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>, "
"<literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal> и "
"<literal>LOCALTIMESTAMP</literal>. Последние четыре функции принимают "
"необязательное указание точности. (См. <xref remap=\"4\" linkend=\"functions-"
"datetime-current\"/>.) Заметьте, что во входных строках эти SQL-функции "
"<emphasis>не</emphasis> распознаются."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2198(title)
msgid "Date/Time Output"
msgstr "Вывод даты/времени"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2200(indexterm)
msgid ""
"<primary>date</primary> <secondary>output format</secondary> "
"<seealso>formatting</seealso>"
msgstr ""
"<primary>дата</primary> <secondary>формат вывода</secondary> "
"<seealso>форматирование</seealso>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2206(indexterm)
msgid ""
"<primary>time</primary> <secondary>output format</secondary> "
"<seealso>formatting</seealso>"
msgstr ""
"<primary>время</primary> <secondary>формат вывода</secondary> "
"<seealso>форматирование</seealso>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2212(para)
msgid ""
"The output format of the date/time types can be set to one of the four "
"styles ISO 8601, <acronym>SQL</acronym> (Ingres), traditional "
"<productname>POSTGRES</productname> (Unix <application>date</application> "
"format), or German. The default is the <acronym>ISO</acronym> format. (The "
"<acronym>SQL</acronym> standard requires the use of the ISO 8601 format. The "
"name of the <quote>SQL</quote> output format is a historical accident.) "
"<xref linkend=\"datatype-datetime-output-table\"/> shows examples of each "
"output style. The output of the <type>date</type> and <type>time</type> "
"types is generally only the date or time part in accordance with the given "
"examples. However, the <productname>POSTGRES</productname> style outputs "
"date-only values in <acronym>ISO</acronym> format."
msgstr ""
"В качестве выходного формата типов даты/времени можно использовать один из "
"четырёх стилей: ISO 8601, <acronym>SQL</acronym> (Ingres), традиционный "
"формат <productname>POSTGRES</productname> (формат <application>date</"
"application> в Unix) или German. По умолчанию выбран формат <acronym>ISO</"
"acronym>. (Стандарт <acronym>SQL</acronym> требует, чтобы использовался "
"именно ISO 8601. Другой формат называется <quote>SQL</quote> исключительно "
"по историческим причинам.) Примеры всех стилей вывода перечислены в <xref "
"remap=\"6\" linkend=\"datatype-datetime-output-table\"/>. Вообще со "
"значениями типов <type>date</type> и <type>time</type> выводилась бы только "
"часть даты или времени из показанных примеров, но со стилем "
"<productname>POSTGRES</productname> значение даты без времени выводится в "
"формате <acronym>ISO</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2231(title)
msgid "Date/Time Output Styles"
msgstr "Стили вывода даты/время"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2235(entry) datatype.xml:2792(entry)
msgid "Style Specification"
msgstr "Стиль"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2242(literal)
msgid "ISO"
msgstr "ISO"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2243(entry)
msgid "ISO 8601, SQL standard"
msgstr "ISO 8601, стандарт SQL"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2244(literal)
msgid "1997-12-17 07:37:16-08"
msgstr "1997-12-17 07:37:16-08"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2247(literal)
msgid "SQL"
msgstr "SQL"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2248(entry)
msgid "traditional style"
msgstr "традиционный стиль"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2249(literal) datatype.xml:2303(literal)
msgid "12/17/1997 07:37:16.00 PST"
msgstr "12/17/1997 07:37:16.00 PST"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2252(literal)
msgid "Postgres"
msgstr "Postgres"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2253(entry)
msgid "original style"
msgstr "изначальный стиль"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2254(literal)
msgid "Wed Dec 17 07:37:16 1997 PST"
msgstr "Wed Dec 17 07:37:16 1997 PST"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2257(literal)
msgid "German"
msgstr "German"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2258(entry)
msgid "regional style"
msgstr "региональный стиль"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2259(literal)
msgid "17.12.1997 07:37:16.00 PST"
msgstr "17.12.1997 07:37:16.00 PST"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2266(para)
msgid ""
"ISO 8601 specifies the use of uppercase letter <literal>T</literal> to "
"separate the date and time. <productname>PostgreSQL</productname> accepts "
"that format on input, but on output it uses a space rather than <literal>T</"
"literal>, as shown above. This is for readability and for consistency with "
"RFC 3339 as well as some other database systems."
msgstr ""
"ISO 8601 указывает, что дата должна отделяться от времени буквой <literal>T</"
"literal> в верхнем регистре. <productname>PostgreSQL</productname> принимает "
"этот формат при вводе, но при выводе вставляет вместо <literal>T</literal> "
"пробел, как показано выше. Это сделано для улучшения читаемости и для "
"совместимости с RFC 3339 и другими СУБД."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2275(para)
msgid ""
"In the <acronym>SQL</acronym> and POSTGRES styles, day appears before month "
"if DMY field ordering has been specified, otherwise month appears before "
"day. (See <xref linkend=\"datatype-datetime-input\"/> for how this setting "
"also affects interpretation of input values.) <xref linkend=\"datatype-"
"datetime-output2-table\"/> shows examples."
msgstr ""
"В стилях <acronym>SQL</acronym> и POSTGRES день выводится перед месяцем, "
"если установлен порядок DMY, а в противном случае месяц выводится перед "
"днём. (Как этот параметр также влияет на интерпретацию входных значений, "
"описано в <xref remap=\"6\" linkend=\"datatype-datetime-input\"/>) "
"Соответствующие примеры показаны в <xref remap=\"6\" linkend=\"datatype-"
"datetime-output2-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2285(title)
msgid "Date Order Conventions"
msgstr "Соглашения о порядке компонентов даты"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2289(entry)
msgid "<varname>datestyle</varname> Setting"
msgstr "Параметр <varname>datestyle</varname>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2290(entry)
msgid "Input Ordering"
msgstr "Порядок при вводе"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2291(entry)
msgid "Example Output"
msgstr "Пример вывода"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2296(literal)
msgid "SQL, DMY"
msgstr "SQL, DMY"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2297(entry) datatype.xml:2307(entry)
msgid ""
"<replaceable>day</replaceable>/<replaceable>month</replaceable>/"
"<replaceable>year</replaceable>"
msgstr ""
"<replaceable>день</replaceable>/<replaceable>месяц</replaceable>/"
"<replaceable>год</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2298(literal)
msgid "17/12/1997 15:37:16.00 CET"
msgstr "17/12/1997 15:37:16.00 CET"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2301(literal)
msgid "SQL, MDY"
msgstr "SQL, MDY"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2302(entry)
msgid ""
"<replaceable>month</replaceable>/<replaceable>day</replaceable>/"
"<replaceable>year</replaceable>"
msgstr ""
"<replaceable>месяц</replaceable>/<replaceable>день</replaceable>/"
"<replaceable>год</replaceable>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2306(literal)
msgid "Postgres, DMY"
msgstr "Postgres, DMY"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2308(literal)
msgid "Wed 17 Dec 07:37:16 1997 PST"
msgstr "Wed 17 Dec 07:37:16 1997 PST"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2314(para)
msgid ""
"The date/time style can be selected by the user using the <command>SET "
"datestyle</command> command, the <xref linkend=\"guc-datestyle\"/> parameter "
"in the <filename>postgresql.conf</filename> configuration file, or the "
"<envar>PGDATESTYLE</envar> environment variable on the server or client."
msgstr ""
"Стиль даты/времени пользователь может выбрать с помощью команды <command>SET "
"datestyle</command>, параметра <xref linkend=\"guc-datestyle\"/> в файле "
"конфигурации <filename>postgresql.conf</filename> или переменной окружения "
"<envar>PGDATESTYLE</envar> на сервере или клиенте."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2323(para)
msgid ""
"The formatting function <function>to_char</function> (see <xref linkend="
"\"functions-formatting\"/>) is also available as a more flexible way to "
"format date/time output."
msgstr ""
"Для большей гибкости при форматировании выводимой даты/времени можно "
"использовать функцию <function>to_char</function> (см. <xref remap=\"4\" "
"linkend=\"functions-formatting\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2331(title)
msgid "Time Zones"
msgstr "Часовые пояса"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2333(indexterm)
msgid "<primary>time zone</primary>"
msgstr "<primary>часовой пояс</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2337(para)
msgid ""
"Time zones, and time-zone conventions, are influenced by political "
"decisions, not just earth geometry. Time zones around the world became "
"somewhat standardized during the 1900s, but continue to be prone to "
"arbitrary changes, particularly with respect to daylight-savings rules. "
"<productname>PostgreSQL</productname> uses the widely-used IANA (Olson) time "
"zone database for information about historical time zone rules. For times in "
"the future, the assumption is that the latest known rules for a given time "
"zone will continue to be observed indefinitely far into the future."
msgstr ""
"Часовые пояса и правила их применения определяются, как вы знаете, не только "
"по географическим, но и по политическим соображениям. Часовые пояса во всём "
"мире были более-менее стандартизированы в начале прошлого века, но они "
"продолжают претерпевать изменения, в частности это касается перехода на "
"летнее время. Для расчёта времени в прошлом <productname>PostgreSQL</"
"productname> получает исторические сведения о правилах часовых поясов из "
"распространённой базы данных IANA (Olson). Для будущего времени "
"предполагается, что в заданном часовом поясе будут продолжать действовать "
"последние принятые правила."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2358(para)
msgid ""
"Although the <type>date</type> type cannot have an associated time zone, the "
"<type>time</type> type can. Time zones in the real world have little meaning "
"unless associated with a date as well as a time, since the offset can vary "
"through the year with daylight-saving time boundaries."
msgstr ""
"Хотя для типа <type>date</type> часовой пояс указать нельзя, это можно "
"сделать для типа <type>time</type>. В реальности это не очень полезно, так "
"как без даты нельзя точно определить смещение при переходе на летнее время."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2370(para)
msgid ""
"The default time zone is specified as a constant numeric offset from "
"<acronym>UTC</acronym>. It is therefore impossible to adapt to daylight-"
"saving time when doing date/time arithmetic across <acronym>DST</acronym> "
"boundaries."
msgstr ""
"По умолчанию часовой пояс задаётся постоянным смещением от <acronym>UTC</"
"acronym>. Это также не позволяет учесть летнее время при арифметических "
"операций с датами, пересекающими границы летнего времени."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2350(para)
msgid ""
"<productname>PostgreSQL</productname> endeavors to be compatible with the "
"<acronym>SQL</acronym> standard definitions for typical usage. However, the "
"<acronym>SQL</acronym> standard has an odd mix of date and time types and "
"capabilities. Two obvious problems are: <placeholder-1/>"
msgstr ""
"<productname>PostgreSQL</productname> стремится к совместимости со "
"стандартом <acronym>SQL</acronym> в наиболее типичных случаях. Однако "
"стандарт <acronym>SQL</acronym> допускает некоторые странности при "
"смешивании типов даты и времени. Две очевидные проблемы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2381(para)
msgid ""
"To address these difficulties, we recommend using date/time types that "
"contain both date and time when using time zones. We do <emphasis>not</"
"emphasis> recommend using the type <type>time with time zone</type> (though "
"it is supported by <productname>PostgreSQL</productname> for legacy "
"applications and for compliance with the <acronym>SQL</acronym> standard). "
"<productname>PostgreSQL</productname> assumes your local time zone for any "
"type containing only date or time."
msgstr ""
"Поэтому мы советуем использовать часовой пояс с типами, включающими и время, "
"и дату. Мы <emphasis>не</emphasis> рекомендуем использовать тип <type>time "
"with time zone</type> (хотя <productname>PostgreSQL</productname> "
"поддерживает его для старых приложений и совместимости со стандартом "
"<acronym>SQL</acronym>). Для типов, включающих только дату или только время, "
"в <productname>PostgreSQL</productname> предполагается местный часовой пояс."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2392(para)
msgid ""
"All timezone-aware dates and times are stored internally in <acronym>UTC</"
"acronym>. They are converted to local time in the zone specified by the "
"<xref linkend=\"guc-timezone\"/> configuration parameter before being "
"displayed to the client."
msgstr ""
"Все значения даты и времени с часовым поясом представляются внутри в "
"<acronym>UTC</acronym>, а при передаче клиентскому приложению они "
"переводятся в местное время, при этом часовой пояс по умолчанию определяется "
"параметром конфигурации <xref linkend=\"guc-timezone\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2404(para)
msgid ""
"A full time zone name, for example <literal>America/New_York</literal>. The "
"recognized time zone names are listed in the <literal>pg_timezone_names</"
"literal> view (see <xref linkend=\"view-pg-timezone-names\"/>). "
"<productname>PostgreSQL</productname> uses the widely-used IANA time zone "
"data for this purpose, so the same time zone names are also recognized by "
"much other software."
msgstr ""
"Полное название часового пояса, например <literal>America/New_York</"
"literal>. Все допустимые названия перечислены в представлении "
"<literal>pg_timezone_names</literal> (см. <xref remap=\"4\" linkend=\"view-"
"pg-timezone-names\"/>). Определения часовых поясов <productname>PostgreSQL</"
"productname> берёт из широко распространённой базы IANA, так что имена "
"часовых поясов PostgreSQL будут воспринимать и многие другие приложения."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2415(para)
msgid ""
"A time zone abbreviation, for example <literal>PST</literal>. Such a "
"specification merely defines a particular offset from UTC, in contrast to "
"full time zone names which can imply a set of daylight savings transition-"
"date rules as well. The recognized abbreviations are listed in the "
"<literal>pg_timezone_abbrevs</literal> view (see <xref linkend=\"view-pg-"
"timezone-abbrevs\"/>). You cannot set the configuration parameters <xref "
"linkend=\"guc-timezone\"/> or <xref linkend=\"guc-log-timezone\"/> to a time "
"zone abbreviation, but you can use abbreviations in date/time input values "
"and with the <literal>AT TIME ZONE</literal> operator."
msgstr ""
"Аббревиатура часового пояса, например <literal>PST</literal>. Такое "
"определение просто задаёт смещение от UTC, в отличие от полных названий "
"поясов, которые кроме того подразумевают и правила перехода на летнее время. "
"Распознаваемые аббревиатуры перечислены в представлении "
"<literal>pg_timezone_abbrevs</literal> (см. <xref remap=\"4\" linkend=\"view-"
"pg-timezone-abbrevs\"/>). Аббревиатуры можно использовать во вводимых "
"значениях даты/времени и в операторе <literal>AT TIME ZONE</literal>, но не "
"в параметрах конфигурации <xref linkend=\"guc-timezone\"/> и <xref linkend="
"\"guc-log-timezone\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2430(para)
msgid ""
"In addition to the timezone names and abbreviations, "
"<productname>PostgreSQL</productname> will accept POSIX-style time zone "
"specifications of the form <replaceable>STD</"
"replaceable><replaceable>offset</replaceable> or <replaceable>STD</"
"replaceable><replaceable>offset</replaceable><replaceable>DST</replaceable>, "
"where <replaceable>STD</replaceable> is a zone abbreviation, "
"<replaceable>offset</replaceable> is a numeric offset in hours west from "
"UTC, and <replaceable>DST</replaceable> is an optional daylight-savings zone "
"abbreviation, assumed to stand for one hour ahead of the given offset. For "
"example, if <literal>EST5EDT</literal> were not already a recognized zone "
"name, it would be accepted and would be functionally equivalent to United "
"States East Coast time. In this syntax, a zone abbreviation can be a string "
"of letters, or an arbitrary string surrounded by angle brackets "
"(<literal>&lt;&gt;</literal>). When a daylight-savings zone abbreviation is "
"present, it is assumed to be used according to the same daylight-savings "
"transition rules used in the IANA time zone database's <filename>posixrules</"
"filename> entry. In a standard <productname>PostgreSQL</productname> "
"installation, <filename>posixrules</filename> is the same as <literal>US/"
"Eastern</literal>, so that POSIX-style time zone specifications follow USA "
"daylight-savings rules. If needed, you can adjust this behavior by replacing "
"the <filename>posixrules</filename> file."
msgstr ""
"В дополнение к полным названиям и аббревиатурам часовых поясов "
"<productname>PostgreSQL</productname> принимает указания часового пояса в "
"стиле POSIX: <replaceable>STD</replaceable><replaceable>смещение</"
"replaceable> или <replaceable>STD</replaceable><replaceable>смещение</"
"replaceable><replaceable>DST</replaceable>, где <replaceable>STD</"
"replaceable> &mdash; аббревиатура пояса, <replaceable>смещение</replaceable> "
"&mdash; разница с UTC, а <replaceable>DST</replaceable> &mdash; "
"необязательное дополнение, обозначающее летнее время и добавляющее к "
"смещению ещё один час. Например, если бы обозначение <literal>EST5EDT</"
"literal> не являлось названием часового пояса, оно всё равно было бы "
"воспринято и функционально соответствовало бы поясу североамериканского "
"восточного времени. При такой записи аббревиатура пояса может быть набором "
"букв или обычной строкой, заключённой в угловые скобки ((<literal>&lt;&gt;</"
"literal>). Когда представлено название пояса с летним временем, при "
"пересчёте времени будут использоваться правила перехода на летнее время, "
"описанные в базе данных IANA в файле <filename>posixrules</filename>. В "
"стандартной инсталляции <productname>PostgreSQL</productname> файл "
"<filename>posixrules</filename> соответствует описанию <literal>US/Eastern</"
"literal>, так что для указаний часовых поясов в стиле POSIX применяются "
"правила перехода на летнее время, принятые в США. При необходимости это "
"можно изменить, заменив файл <filename>posixrules</filename>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2399(para)
msgid ""
"<productname>PostgreSQL</productname> allows you to specify time zones in "
"three different forms: <placeholder-1/> In short, this is the difference "
"between abbreviations and full names: abbreviations represent a specific "
"offset from UTC, whereas many of the full names imply a local daylight-"
"savings time rule, and so have two possible UTC offsets. As an example, "
"<literal>2014-06-04 12:00 America/New_York</literal> represents noon local "
"time in New York, which for this particular date was Eastern Daylight Time "
"(UTC-4). So <literal>2014-06-04 12:00 EDT</literal> specifies that same time "
"instant. But <literal>2014-06-04 12:00 EST</literal> specifies noon Eastern "
"Standard Time (UTC-5), regardless of whether daylight savings was nominally "
"in effect on that date."
msgstr ""
"<productname>PostgreSQL</productname> позволяет задать часовой пояс тремя "
"способами: <placeholder-1/> Вкратце, различие между аббревиатурами и полными "
"названиями заключаются в следующем: аббревиатуры представляют определённый "
"сдвиг от UTC, а полное название подразумевает ещё и местное правило по "
"переходу на летнее время, то есть, возможно, два сдвига от UTC. Например, "
"<literal>2014-06-04 12:00 America/New_York</literal> представляет полдень по "
"местному времени в Нью-Йорк, что для данного дня было бы летним восточным "
"временем (EDT или UTC-4). Так что <literal>2014-06-04 12:00 EDT</literal> "
"обозначает тот же момент времени. Но <literal>2014-06-04 12:00 EST</literal> "
"задаёт стандартное восточное время (UTC-5), не зависящее о того, действовало "
"ли летнее время в этот день."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2468(para)
msgid ""
"To complicate matters, some jurisdictions have used the same timezone "
"abbreviation to mean different UTC offsets at different times; for example, "
"in Moscow <literal>MSK</literal> has meant UTC+3 in some years and UTC+4 in "
"others. <application>PostgreSQL</application> interprets such abbreviations "
"according to whatever they meant (or had most recently meant) on the "
"specified date; but, as with the <literal>EST</literal> example above, this "
"is not necessarily the same as local civil time on that date."
msgstr ""
"Мало того, в некоторых юрисдикциях одна и та же аббревиатура часового пояса "
"означала разные сдвиги UTC в разное время; например, аббревиатура "
"московского времени <literal>MSK</literal> несколько лет означала UTC+3, а "
"затем стала означать UTC+4. <application>PostgreSQL</application> "
"обрабатывает такие аббревиатуры в соответствии с их значениями на заданную "
"дату, но, как и с примером выше <literal>EST</literal>, это не обязательно "
"будет соответствовать местному гражданскому времени в этот день."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2478(para)
msgid ""
"One should be wary that the POSIX-style time zone feature can lead to "
"silently accepting bogus input, since there is no check on the "
"reasonableness of the zone abbreviations. For example, <literal>SET TIMEZONE "
"TO FOOBAR0</literal> will work, leaving the system effectively using a "
"rather peculiar abbreviation for UTC. Another issue to keep in mind is that "
"in POSIX time zone names, positive offsets are used for locations "
"<emphasis>west</emphasis> of Greenwich. Everywhere else, "
"<productname>PostgreSQL</productname> follows the ISO-8601 convention that "
"positive timezone offsets are <emphasis>east</emphasis> of Greenwich."
msgstr ""
"При этом следует использовать возможность указания часового пояса в стиле "
"POSIX с осторожностью, так как при этом могут быть приняты заведомо неверные "
"данные, потому что разумность аббревиатуры никак не проверяется. Например, "
"команда <literal>SET TIMEZONE TO FOOBAR0</literal> будет работать и система "
"примет эту довольно оригинальную аббревиатуру для UTC. Также следует "
"учитывать, что в названиях часовых поясов POSIX положительные смещения "
"соответствуют сдвигу <emphasis>к западу</emphasis> Гринвича. Во всех "
"остальных формах <productname>PostgreSQL</productname> следует соглашению "
"ISO-8601, по которому положительным смещениям соответствует сдвиг "
"<emphasis>к востоку</emphasis> от Гринвича."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2491(para)
msgid ""
"In all cases, timezone names and abbreviations are recognized case-"
"insensitively. (This is a change from <productname>PostgreSQL</productname> "
"versions prior to 8.2, which were case-sensitive in some contexts but not "
"others.)"
msgstr ""
"Независимо от формы, регистр в названиях и аббревиатурах часовых поясов не "
"важен. (В <productname>PostgreSQL</productname> до версии 8.2 он где-то имел "
"значение, а где-то нет.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2498(para)
msgid ""
"Neither timezone names nor abbreviations are hard-wired into the server; "
"they are obtained from configuration files stored under <filename>.../share/"
"timezone/</filename> and <filename>.../share/timezonesets/</filename> of the "
"installation directory (see <xref linkend=\"datetime-config-files\"/>)."
msgstr ""
"Ни названия, ни аббревиатуры часовых поясов, не зашиты в самом сервере; они "
"считываются из файлов конфигурации, находящихся в путях <filename>.../share/"
"timezone/</filename> и <filename>.../share/timezonesets/</filename> "
"относительно каталога установки (см. <xref remap=\"4\" linkend=\"datetime-"
"config-files\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2514(para)
msgid ""
"The <acronym>SQL</acronym> command <command>SET TIME ZONE</command> sets the "
"time zone for the session. This is an alternative spelling of <command>SET "
"TIMEZONE TO</command> with a more SQL-spec-compatible syntax."
msgstr ""
"Часовой пояс для текущего сеанса можно установить с помощью <acronym>SQL</"
"acronym>-команды <command>SET TIME ZONE</command>. Это альтернативная запись "
"команды <command>SET TIMEZONE TO</command>, более соответствующая SQL-"
"стандарту."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2522(para)
msgid ""
"The <envar>PGTZ</envar> environment variable is used by <application>libpq</"
"application> clients to send a <command>SET TIME ZONE</command> command to "
"the server upon connection."
msgstr ""
"Если установлена переменная окружения <envar>PGTZ</envar>, клиенты "
"<application>libpq</application> используют её значение, выполняя при "
"подключении к серверу команду <command>SET TIME ZONE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2506(para)
msgid ""
"The <xref linkend=\"guc-timezone\"/> configuration parameter can be set in "
"the file <filename>postgresql.conf</filename>, or in any of the other "
"standard ways described in <xref linkend=\"runtime-config\"/>. There are "
"also some special ways to set it: <placeholder-1/>"
msgstr ""
"Параметр конфигурации <xref linkend=\"guc-timezone\"/> можно установить в "
"<filename>postgresql.conf</filename> или любым другим стандартным способом, "
"описанным в <xref remap=\"6\" linkend=\"runtime-config\"/>. Часовой пояс "
"может быть также определён следующими специальными способами: <placeholder-1/"
">"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2534(title) datatype.xml:2705(title)
msgid "Interval Input"
msgstr "Ввод интервалов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2540(para)
msgid ""
"<type>interval</type> values can be written using the following verbose "
"syntax: <synopsis>\n"
"<optional>@</optional> <replaceable>quantity</replaceable> "
"<replaceable>unit</replaceable> <optional><replaceable>quantity</"
"replaceable> <replaceable>unit</replaceable>...</optional> "
"<optional><replaceable>direction</replaceable></optional>\n"
"</synopsis> where <replaceable>quantity</replaceable> is a number (possibly "
"signed); <replaceable>unit</replaceable> is <literal>microsecond</literal>, "
"<literal>millisecond</literal>, <literal>second</literal>, <literal>minute</"
"literal>, <literal>hour</literal>, <literal>day</literal>, <literal>week</"
"literal>, <literal>month</literal>, <literal>year</literal>, "
"<literal>decade</literal>, <literal>century</literal>, <literal>millennium</"
"literal>, or abbreviations or plurals of these units; "
"<replaceable>direction</replaceable> can be <literal>ago</literal> or empty. "
"The at sign (<literal>@</literal>) is optional noise. The amounts of the "
"different units are implicitly added with appropriate sign accounting. "
"<literal>ago</literal> negates all the fields. This syntax is also used for "
"interval output, if <xref linkend=\"guc-intervalstyle\"/> is set to "
"<literal>postgres_verbose</literal>."
msgstr ""
"Значения типа <type>interval</type> могут быть записаны в следующей "
"расширенной форме: <synopsis>\n"
"<optional>@</optional> <replaceable>количество</replaceable> "
"<replaceable>единица</replaceable> <optional><replaceable>количество</"
"replaceable> <replaceable>единица</replaceable>...</optional> "
"<optional><replaceable>направление</replaceable></optional>\n"
"</synopsis> где <replaceable>количество</replaceable> &mdash; это число "
"(возможно, со знаком); <replaceable>единица </replaceable> &mdash; одно из "
"значений: <literal>microsecond</literal>, <literal>millisecond</literal>, "
"<literal>second</literal>, <literal>minute</literal>, <literal>hour</"
"literal>, <literal>day</literal>, <literal>week</literal>, <literal>month</"
"literal>, <literal>year</literal>, <literal>decade</literal>, "
"<literal>century</literal>, <literal>millennium</literal> (которые "
"обозначают соответственно микросекунды, миллисекунды, секунды, минуты, часы, "
"дни, недели, месяцы, годы, десятилетия, века и тысячелетия), либо эти же "
"слова во множественном числе, либо их сокращения; <replaceable>направление</"
"replaceable> может принимать значение <literal>ago</literal> (назад) или "
"быть пустым. Знак <literal>@</literal> является необязательным. Все заданные "
"величины различных единиц суммируются вместе с учётом знака чисел. Указание "
"<literal>ago</literal> меняет знак всех полей на противоположный. Этот "
"синтаксис также используется при выводе интервала, если параметр <xref "
"linkend=\"guc-intervalstyle\"/> имеет значение <literal>postgres_verbose</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2564(para)
msgid ""
"Quantities of days, hours, minutes, and seconds can be specified without "
"explicit unit markings. For example, <literal>'1 12:59:10'</literal> is read "
"the same as <literal>'1 day 12 hours 59 min 10 sec'</literal>. Also, a "
"combination of years and months can be specified with a dash; for example "
"<literal>'200-10'</literal> is read the same as <literal>'200 years 10 "
"months'</literal>. (These shorter forms are in fact the only ones allowed by "
"the <acronym>SQL</acronym> standard, and are used for output when "
"<varname>IntervalStyle</varname> is set to <literal>sql_standard</literal>.)"
msgstr ""
"Количества дней, часов, минут и секунд можно определить, не указывая явно "
"соответствующие единицы. Например, запись <literal>'1 12:59:10'</literal> "
"равнозначна <literal>'1 day 12 hours 59 min 10 sec'</literal>. Сочетание "
"года и месяца также можно записать через минус; например <literal>'200-10'</"
"literal> означает то, же что и <literal>'200 years 10 months'</literal>. (На "
"самом деле только эти краткие формы разрешены стандартом <acronym>SQL</"
"acronym> и они используются при выводе, когда <varname>IntervalStyle</"
"varname> имеет значение <literal>sql_standard</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2575(para)
msgid ""
"Interval values can also be written as ISO 8601 time intervals, using either "
"the <quote>format with designators</quote> of the standard's section 4.4.3.2 "
"or the <quote>alternative format</quote> of section 4.4.3.3. The format with "
"designators looks like this: <synopsis>\n"
"P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> "
"<optional> <replaceable>quantity</replaceable> <replaceable>unit</"
"replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</"
"replaceable> <replaceable>unit</replaceable> ...</optional></optional>\n"
"</synopsis> The string must start with a <literal>P</literal>, and may "
"include a <literal>T</literal> that introduces the time-of-day units. The "
"available unit abbreviations are given in <xref linkend=\"datatype-interval-"
"iso8601-units\"/>. Units may be omitted, and may be specified in any order, "
"but units smaller than a day must appear after <literal>T</literal>. In "
"particular, the meaning of <literal>M</literal> depends on whether it is "
"before or after <literal>T</literal>."
msgstr ""
"Интервалы можно также записывать в виде, определённом в ISO 8601, либо в "
"<quote>формате с кодами</quote>, описанном в разделе 4.4.3.2 этого "
"стандарта, либо в <quote>альтернативном формате</quote>, описанном в разделе "
"4.4.3.3. Формат с кодами выглядит так: <synopsis>\n"
"P <replaceable>количество</replaceable> <replaceable>единица</replaceable> "
"<optional> <replaceable>количество</replaceable> <replaceable>единица</"
"replaceable> ...</optional> <optional> T <optional> <replaceable>количество</"
"replaceable> <replaceable>единица</replaceable> ...</optional></optional>\n"
"</synopsis> Строка должна начинаться с символа <literal>P</literal> и может "
"включать также <literal>T</literal> перед временем суток. Допустимые коды "
"единиц перечислены в <xref remap=\"6\" linkend=\"datatype-interval-iso8601-"
"units\"/>. Коды единиц можно опустить или указать в любом порядке, но "
"компоненты времени суток должны идти после символа <literal>T</literal>. В "
"частности, значение кода <literal>M</literal> зависит от того, располагается "
"ли он до или после <literal>T</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2594(title)
msgid "ISO 8601 Interval Unit Abbreviations"
msgstr "Коды единиц временных интервалов ISO 8601"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2598(entry)
msgid "Abbreviation"
msgstr "Код"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2599(entry)
msgid "Meaning"
msgstr "Значение"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2604(entry)
msgid "Y"
msgstr "Y"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2605(entry)
msgid "Years"
msgstr "годы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2608(entry) datatype.xml:2624(entry)
msgid "M"
msgstr "M"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2609(entry)
msgid "Months (in the date part)"
msgstr "месяцы (в дате)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2612(entry)
msgid "W"
msgstr "W"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2613(entry)
msgid "Weeks"
msgstr "недели"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2616(entry)
msgid "D"
msgstr "D"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2617(entry)
msgid "Days"
msgstr "дни"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2620(entry)
msgid "H"
msgstr "H"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2621(entry)
msgid "Hours"
msgstr "часы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2625(entry)
msgid "Minutes (in the time part)"
msgstr "минуты (во времени)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2628(entry)
msgid "S"
msgstr "S"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2629(entry)
msgid "Seconds"
msgstr "секунды"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2635(para)
msgid ""
"In the alternative format: <synopsis>\n"
"P <optional> <replaceable>years</replaceable>-<replaceable>months</"
"replaceable>-<replaceable>days</replaceable> </optional> <optional> T "
"<replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:"
"<replaceable>seconds</replaceable> </optional>\n"
"</synopsis> the string must begin with <literal>P</literal>, and a "
"<literal>T</literal> separates the date and time parts of the interval. The "
"values are given as numbers similar to ISO 8601 dates."
msgstr ""
"В альтернативном формате: <synopsis>\n"
"P <optional> <replaceable>год</replaceable>-<replaceable>месяц</replaceable>-"
"<replaceable>день</replaceable> </optional> <optional> T <replaceable>часы</"
"replaceable>:<replaceable>минуты</replaceable>:<replaceable>секунды</"
"replaceable> </optional>\n"
"</synopsis> строка должна начинаться с <literal>P</literal>, а <literal>T</"
"literal> разделяет компоненты даты и времени. Значения выражаются числами "
"так же, как и в датах ISO 8601."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2645(para)
msgid ""
"When writing an interval constant with a <replaceable>fields</replaceable> "
"specification, or when assigning a string to an interval column that was "
"defined with a <replaceable>fields</replaceable> specification, the "
"interpretation of unmarked quantities depends on the <replaceable>fields</"
"replaceable>. For example <literal>INTERVAL '1' YEAR</literal> is read as 1 "
"year, whereas <literal>INTERVAL '1'</literal> means 1 second. Also, field "
"values <quote>to the right</quote> of the least significant field allowed by "
"the <replaceable>fields</replaceable> specification are silently discarded. "
"For example, writing <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</"
"literal> results in dropping the seconds field, but not the day field."
msgstr ""
"При записи интервальной константы с указанием <replaceable>полей</"
"replaceable> или присвоении столбцу типа interval строки с "
"<replaceable>полями</replaceable>, интерпретация непомеченных величин "
"зависит от <replaceable>полей</replaceable>. Например, <literal>INTERVAL '1' "
"YEAR</literal> воспринимается как 1 год, а <literal>INTERVAL '1'</literal> "
"&mdash; как 1 секунда. Кроме того, значения <quote>справа</quote> от "
"меньшего значащего поля, заданного в определении <replaceable>полей</"
"replaceable>, просто отбрасываются. Например, в записи <literal>INTERVAL '1 "
"day 2:03:04' HOUR TO MINUTE</literal> будут отброшены секунды, но не день."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2658(para)
msgid ""
"According to the <acronym>SQL</acronym> standard all fields of an interval "
"value must have the same sign, so a leading negative sign applies to all "
"fields; for example the negative sign in the interval literal <literal>'-1 "
"2:03:04'</literal> applies to both the days and hour/minute/second parts. "
"<productname>PostgreSQL</productname> allows the fields to have different "
"signs, and traditionally treats each field in the textual representation as "
"independently signed, so that the hour/minute/second part is considered "
"positive in this example. If <varname>IntervalStyle</varname> is set to "
"<literal>sql_standard</literal> then a leading sign is considered to apply "
"to all fields (but only if no additional signs appear). Otherwise the "
"traditional <productname>PostgreSQL</productname> interpretation is used. To "
"avoid ambiguity, it's recommended to attach an explicit sign to each field "
"if any field is negative."
msgstr ""
"Согласно стандарту <acronym>SQL</acronym>, все компоненты значения interval "
"должны быть одного знака, и ведущий минус применяется ко всем компонентам; "
"например, минус в записи <literal>'-1 2:03:04'</literal> применяется и к "
"дню, и к часам/минутам/секундам. <productname>PostgreSQL</productname> "
"позволяет задавать для разных компонентов разные знаки и традиционно "
"обрабатывает знак каждого компонента в текстовом представлении отдельно от "
"других, так что в данном случае часы/минуты/секунды будут считаться "
"положительными. Если параметр <varname>IntervalStyle</varname> имеет "
"значение <literal>sql_standard</literal>, ведущий знак применяется ко всем "
"компонентам (но только если они не содержат знаки явно). В противном случае "
"действуют традиционные правила <productname>PostgreSQL</productname>. Во "
"избежание неоднозначности рекомендуется добавлять знак к каждому компоненту "
"с отрицательным значением."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2674(para)
msgid ""
"Internally <type>interval</type> values are stored as months, days, and "
"seconds. This is done because the number of days in a month varies, and a "
"day can have 23 or 25 hours if a daylight savings time adjustment is "
"involved. The months and days fields are integers while the seconds field "
"can store fractions. Because intervals are usually created from constant "
"strings or <type>timestamp</type> subtraction, this storage method works "
"well in most cases. Functions <function>justify_days</function> and "
"<function>justify_hours</function> are available for adjusting days and "
"hours that overflow their normal ranges."
msgstr ""
"Тип <type>interval</type> представлен внутри в виде отдельных значений "
"месяцев, дней и секунд. Это объясняется тем, что число дней в месяце может "
"быть разным, а в сутках может быть и 23, и 25 часов в дни перехода на летнее/"
"зимнее время. Значения месяцев и дней представлены целыми числами, а число "
"секунд может быть дробным. Так как интервалы обычно получаются из строковых "
"констант или при вычитании типов <type>timestamp</type>, этот способ "
"хранения эффективен в большинстве случаев. Для корректировки числа дней и "
"часов, когда они выходят за обычные границы, в <productname>PostgreSQL</"
"productname> есть специальные функции <function>justify_days</function> и "
"<function>justify_hours</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2687(para)
msgid ""
"In the verbose input format, and in some fields of the more compact input "
"formats, field values can have fractional parts; for example <literal>'1.5 "
"week'</literal> or <literal>'01:02:03.45'</literal>. Such input is converted "
"to the appropriate number of months, days, and seconds for storage. When "
"this would result in a fractional number of months or days, the fraction is "
"added to the lower-order fields using the conversion factors 1 month = 30 "
"days and 1 day = 24 hours. For example, <literal>'1.5 month'</literal> "
"becomes 1 month and 15 days. Only seconds will ever be shown as fractional "
"on output."
msgstr ""
"В расширенном формате ввода и в некоторых полях более компактных форматов "
"значения компонентов могут иметь дробные части, например <literal>'1.5 "
"week'</literal> или <literal>'01:02:03.45'</literal>. Такое значение при "
"сохранении пересчитывается в соответствующее число месяцев, дней и секунд. "
"Когда при этом остаётся дробная часть в месяцах или в днях, она переносится "
"в младший компонент с допущением, что 1 месяц = 30 дней, а 1 день = 24 часа. "
"Например, значение <literal>'1.5 month'</literal> будет преобразовано в 1 "
"месяц и 15 дней. В виде дробного числа хранятся и выводятся только секунды."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2699(para)
msgid ""
"<xref linkend=\"datatype-interval-input-examples\"/> shows some examples of "
"valid <type>interval</type> input."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-interval-input-examples\"/> показано "
"несколько примеров допустимых вводимых значений типа <type>interval</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2715(entry) datatype.xml:2801(entry)
msgid "1-2"
msgstr "1-2"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2716(entry)
msgid "SQL standard format: 1 year 2 months"
msgstr "Стандартный формат SQL: 1 год и 2 месяца"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2719(entry) datatype.xml:2802(entry)
msgid "3 4:05:06"
msgstr "3 4:05:06"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2720(entry)
msgid "SQL standard format: 3 days 4 hours 5 minutes 6 seconds"
msgstr "Стандартный формат SQL: 3 дня 4 часа 5 минут 6 секунд"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2723(entry)
msgid "1 year 2 months 3 days 4 hours 5 minutes 6 seconds"
msgstr "1 year 2 months 3 days 4 hours 5 minutes 6 seconds"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2724(entry)
msgid ""
"Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 "
"seconds"
msgstr ""
"Традиционный формат Postgres: 1 год 2 месяца 3 дня 4 часа 5 минут 6 секунд"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2727(entry)
msgid "P1Y2M3DT4H5M6S"
msgstr "P1Y2M3DT4H5M6S"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2728(entry)
msgid "ISO 8601 <quote>format with designators</quote>: same meaning as above"
msgstr "<quote>Формат с кодами</quote> ISO 8601: то же значение, что и выше"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2731(entry)
msgid "P0001-02-03T04:05:06"
msgstr "P0001-02-03T04:05:06"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2732(entry)
msgid "ISO 8601 <quote>alternative format</quote>: same meaning as above"
msgstr ""
"<quote>Альтернативный формат</quote> ISO 8601: то же значение, что и выше"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2741(title)
msgid "Interval Output"
msgstr "Вывод интервалов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2743(indexterm)
msgid ""
"<primary>interval</primary> <secondary>output format</secondary> "
"<seealso>formatting</seealso>"
msgstr ""
"<primary>интервал</primary> <secondary>формат вывода</secondary> "
"<seealso>форматирование</seealso>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2749(para)
msgid ""
"The output format of the interval type can be set to one of the four styles "
"<literal>sql_standard</literal>, <literal>postgres</literal>, "
"<literal>postgres_verbose</literal>, or <literal>iso_8601</literal>, using "
"the command <literal>SET intervalstyle</literal>. The default is the "
"<literal>postgres</literal> format. <xref linkend=\"interval-style-output-"
"table\"/> shows examples of each output style."
msgstr ""
"Формат вывода типа interval может определяться одним из четырёх стилей: "
"<literal>sql_standard</literal>, <literal>postgres</literal>, "
"<literal>postgres_verbose</literal> и <literal>iso_8601</literal>. Выбрать "
"нужный стиль позволяет команда <literal>SET intervalstyle</literal> (по "
"умолчанию выбран <literal>postgres</literal>). Примеры форматов разных "
"стилей показаны в <xref remap=\"6\" linkend=\"interval-style-output-table\"/"
">."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2759(para)
msgid ""
"The <literal>sql_standard</literal> style produces output that conforms to "
"the SQL standard's specification for interval literal strings, if the "
"interval value meets the standard's restrictions (either year-month only or "
"day-time only, with no mixing of positive and negative components). "
"Otherwise the output looks like a standard year-month literal string "
"followed by a day-time literal string, with explicit signs added to "
"disambiguate mixed-sign intervals."
msgstr ""
"Стиль <literal>sql_standard</literal> выдаёт результат, соответствующий "
"стандарту SQL, если значение интервала удовлетворяет ограничениям стандарта "
"(и содержит либо только год и месяц, либо только день и время, и при этом "
"все его компоненты одного знака). В противном случае выводится год-месяц, за "
"которым идёт дата-время, а в компоненты для однозначности явно добавляются "
"знаки."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2769(para)
msgid ""
"The output of the <literal>postgres</literal> style matches the output of "
"<productname>PostgreSQL</productname> releases prior to 8.4 when the <xref "
"linkend=\"guc-datestyle\"/> parameter was set to <literal>ISO</literal>."
msgstr ""
"Вывод в стиле <literal>postgres</literal> соответствует формату, который был "
"принят в <productname>PostgreSQL</productname> до версии 8.4, когда параметр "
"<xref linkend=\"guc-datestyle\"/> имел значение <literal>ISO</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2775(para)
msgid ""
"The output of the <literal>postgres_verbose</literal> style matches the "
"output of <productname>PostgreSQL</productname> releases prior to 8.4 when "
"the <varname>DateStyle</varname> parameter was set to non-<literal>ISO</"
"literal> output."
msgstr ""
"Вывод в стиле <literal>postgres_verbose</literal> соответствует формату, "
"который был принят в <productname>PostgreSQL</productname> до версии 8.4, "
"когда значением параметром <varname>DateStyle</varname> было не "
"<literal>ISO</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2781(para)
msgid ""
"The output of the <literal>iso_8601</literal> style matches the "
"<quote>format with designators</quote> described in section 4.4.3.2 of the "
"ISO 8601 standard."
msgstr ""
"Вывод в стиле <literal>iso_8601</literal> соответствует <quote>формату с "
"кодами</quote> описанному в разделе 4.4.3.2 формата ISO 8601."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2788(title)
msgid "Interval Output Style Examples"
msgstr "Примеры стилей вывода интервалов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2793(entry)
msgid "Year-Month Interval"
msgstr "Интервал год-месяц"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2794(entry)
msgid "Day-Time Interval"
msgstr "Интервал день-время"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2795(entry)
msgid "Mixed Interval"
msgstr "Смешанный интервал"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2800(literal)
msgid "sql_standard"
msgstr "sql_standard"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2803(entry)
msgid "-1-2 +3 -4:05:06"
msgstr "-1-2 +3 -4:05:06"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2806(literal)
msgid "postgres"
msgstr "postgres"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2807(entry)
msgid "1 year 2 mons"
msgstr "1 year 2 mons"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2808(entry)
msgid "3 days 04:05:06"
msgstr "3 days 04:05:06"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2809(entry)
msgid "-1 year -2 mons +3 days -04:05:06"
msgstr "-1 year -2 mons +3 days -04:05:06"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2812(literal)
msgid "postgres_verbose"
msgstr "postgres_verbose"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2813(entry)
msgid "@ 1 year 2 mons"
msgstr "@ 1 year 2 mons"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2814(entry)
msgid "@ 3 days 4 hours 5 mins 6 secs"
msgstr "@ 3 days 4 hours 5 mins 6 secs"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2815(entry)
msgid "@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago"
msgstr "@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2818(literal)
msgid "iso_8601"
msgstr "iso_8601"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2819(entry)
msgid "P1Y2M"
msgstr "P1Y2M"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2820(entry)
msgid "P3DT4H5M6S"
msgstr "P3DT4H5M6S"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2821(entry)
msgid "P-1Y-2M3DT-4H-5M-6S"
msgstr "P-1Y-2M3DT-4H-5M-6S"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2832(title)
msgid "Boolean Type"
msgstr "Логический тип"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2834(indexterm)
msgid "<primary>Boolean</primary> <secondary>data type</secondary>"
msgstr "<primary>логический</primary> <secondary>тип данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2839(indexterm)
msgid "<primary>true</primary>"
msgstr "<primary>true</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2843(indexterm)
msgid "<primary>false</primary>"
msgstr "<primary>false</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2847(para)
msgid ""
"<productname>PostgreSQL</productname> provides the standard <acronym>SQL</"
"acronym> type <type>boolean</type>; see <xref linkend=\"datatype-boolean-"
"table\"/>. The <type>boolean</type> type can have several states: "
"<quote>true</quote>, <quote>false</quote>, and a third state, "
"<quote>unknown</quote>, which is represented by the <acronym>SQL</acronym> "
"null value."
msgstr ""
"В <productname>PostgreSQL</productname> есть стандартный <acronym>SQL</"
"acronym>-тип <type>boolean</type>; см. <xref remap=\"4\" linkend=\"datatype-"
"boolean-table\"/>. Тип <type>boolean</type> может иметь следующие состояния: "
"<quote>true</quote>, <quote>false</quote> и третье состояние, "
"<quote>unknown</quote>, которое представляется <acronym>SQL</acronym>-"
"значением NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2858(title)
msgid "Boolean Data Type"
msgstr "Логический тип данных"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2871(entry)
msgid "state of true or false"
msgstr "состояние: истина или ложь"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2880(literal)
msgid "TRUE"
msgstr "TRUE"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2881(literal)
msgid "'t'"
msgstr "'t'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2882(literal)
msgid "'true'"
msgstr "'true'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2883(literal)
msgid "'y'"
msgstr "'y'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2884(literal)
msgid "'yes'"
msgstr "'yes'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2885(literal)
msgid "'on'"
msgstr "'on'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2886(literal)
msgid "'1'"
msgstr "'1'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2891(literal)
msgid "FALSE"
msgstr "FALSE"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2892(literal)
msgid "'f'"
msgstr "'f'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2893(literal)
msgid "'false'"
msgstr "'false'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2894(literal)
msgid "'n'"
msgstr "'n'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2895(literal)
msgid "'no'"
msgstr "'no'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2896(literal)
msgid "'off'"
msgstr "'off'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2897(literal)
msgid "'0'"
msgstr "'0'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2877(para)
msgid ""
"Valid literal values for the <quote>true</quote> state are: <placeholder-1/> "
"For the <quote>false</quote> state, the following values can be used: "
"<placeholder-2/> Leading or trailing whitespace is ignored, and case does "
"not matter. The key words <literal>TRUE</literal> and <literal>FALSE</"
"literal> are the preferred (<acronym>SQL</acronym>-compliant) usage."
msgstr ""
"Состояние <quote>true</quote> может задаваться следующими значениями: "
"<placeholder-1/> Для состояния <quote>false</quote> можно использовать "
"следующие варианты: <placeholder-2/> При этом пробелы в начале и конце "
"строки игнорируются, и регистр так же не имеет значения. Предпочтительными "
"(совместимыми с <acronym>SQL</acronym>) являются варианты <literal>TRUE</"
"literal> и <literal>FALSE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2905(para)
msgid ""
"<xref linkend=\"datatype-boolean-example\"/> shows that <type>boolean</type> "
"values are output using the letters <literal>t</literal> and <literal>f</"
"literal>."
msgstr ""
"<xref linkend=\"datatype-boolean-example\"/> показывает, что значения типа "
"<type>boolean</type> при выводе представляются буквами <literal>t</literal> "
"и <literal>f</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2912(title)
msgid "Using the <type>boolean</type> Type"
msgstr "Использование типа <type>boolean</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2914(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test1 (a boolean, b text);\n"
"INSERT INTO test1 VALUES (TRUE, 'sic est');\n"
"INSERT INTO test1 VALUES (FALSE, 'non est');\n"
"SELECT * FROM test1;\n"
" a |    b\n"
"---+---------\n"
" t | sic est\n"
" f | non est\n"
"\n"
"SELECT * FROM test1 WHERE a;\n"
" a |    b\n"
"---+---------\n"
" t | sic est"
msgstr ""
"CREATE TABLE test1 (a boolean, b text);\n"
"INSERT INTO test1 VALUES (TRUE, 'sic est');\n"
"INSERT INTO test1 VALUES (FALSE, 'non est');\n"
"SELECT * FROM test1;\n"
" a |    b\n"
"---+---------\n"
" t | sic est\n"
" f | non est\n"
"\n"
"SELECT * FROM test1 WHERE a;\n"
" a |    b\n"
"---+---------\n"
" t | sic est"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2933(title)
msgid "Enumerated Types"
msgstr "Типы перечислений"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2935(indexterm)
msgid "<primary>data type</primary> <secondary>enumerated (enum)</secondary>"
msgstr ""
"<primary>тип данных</primary> <secondary>перечисление (enum)</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2940(indexterm)
msgid "<primary>enumerated types</primary>"
msgstr "<primary>типы перечислений</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2944(para)
msgid ""
"Enumerated (enum) types are data types that comprise a static, ordered set "
"of values. They are equivalent to the <type>enum</type> types supported in a "
"number of programming languages. An example of an enum type might be the "
"days of the week, or a set of status values for a piece of data."
msgstr ""
"Типы перечислений (enum) определяют статический упорядоченный набор "
"значений, так же как и типы <type>enum</type>, существующие в ряде языков "
"программирования. В качестве перечисления можно привести дни недели или "
"набор состояний."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2954(title)
msgid "Declaration of Enumerated Types"
msgstr "Объявление перечислений"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2961(programlisting)
#, no-wrap
msgid "CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');"
msgstr "CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2967(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');\n"
"CREATE TABLE person (\n"
"    name text,\n"
"    current_mood mood\n"
");\n"
"INSERT INTO person VALUES ('Moe', 'happy');\n"
"SELECT * FROM person WHERE current_mood = 'happy';\n"
" name | current_mood \n"
"------+--------------\n"
" Moe  | happy\n"
"(1 row)"
msgstr ""
"CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');\n"
"CREATE TABLE person (\n"
"    name text,\n"
"    current_mood mood\n"
");\n"
"INSERT INTO person VALUES ('Moe', 'happy');\n"
"SELECT * FROM person WHERE current_mood = 'happy';\n"
" name | current_mood \n"
"------+--------------\n"
" Moe  | happy\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2956(para)
msgid ""
"Enum types are created using the <xref linkend=\"sql-createtype\"/> command, "
"for example: <placeholder-1/> Once created, the enum type can be used in "
"table and function definitions much like any other type: <placeholder-2/>"
msgstr ""
"Тип перечислений создаются с помощью команды <xref linkend=\"sql-createtype"
"\"/>, например так: <placeholder-1/> Созданные типы enum можно использовать "
"в определениях таблиц и функций, как и любые другие: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2984(title)
msgid "Ordering"
msgstr "Порядок"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2992(programlisting)
#, no-wrap
msgid ""
"INSERT INTO person VALUES ('Larry', 'sad');\n"
"INSERT INTO person VALUES ('Curly', 'ok');\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad';\n"
" name  | current_mood \n"
"-------+--------------\n"
" Moe   | happy\n"
" Curly | ok\n"
"(2 rows)\n"
"\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad' ORDER BY current_mood;\n"
" name  | current_mood \n"
"-------+--------------\n"
" Curly | ok\n"
" Moe   | happy\n"
"(2 rows)\n"
"\n"
"SELECT name\n"
"FROM person\n"
"WHERE current_mood = (SELECT MIN(current_mood) FROM person);\n"
" name  \n"
"-------\n"
" Larry\n"
"(1 row)"
msgstr ""
"INSERT INTO person VALUES ('Larry', 'sad');\n"
"INSERT INTO person VALUES ('Curly', 'ok');\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad';\n"
" name  | current_mood \n"
"-------+--------------\n"
" Moe   | happy\n"
" Curly | ok\n"
"(2 rows)\n"
"\n"
"SELECT * FROM person WHERE current_mood &gt; 'sad' ORDER BY current_mood;\n"
" name  | current_mood \n"
"-------+--------------\n"
" Curly | ok\n"
" Moe   | happy\n"
"(2 rows)\n"
"\n"
"SELECT name\n"
"FROM person\n"
"WHERE current_mood = (SELECT MIN(current_mood) FROM person);\n"
" name  \n"
"-------\n"
" Larry\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:2986(para)
msgid ""
"The ordering of the values in an enum type is the order in which the values "
"were listed when the type was created. All standard comparison operators and "
"related aggregate functions are supported for enums. For example: "
"<placeholder-1/>"
msgstr ""
"Порядок значений в перечислении определяется последовательностью, в которой "
"были указаны значения при создании типа. Перечисления поддерживаются всеми "
"стандартными операторами сравнения и связанными агрегатными функциями. "
"Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3021(title)
msgid "Type Safety"
msgstr "Безопасность типа"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3027(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');\n"
"CREATE TABLE holidays (\n"
"    num_weeks integer,\n"
"    happiness happiness\n"
");\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');\n"
"ERROR:  invalid input value for enum happiness: \"sad\"\n"
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood = holidays.happiness;\n"
"ERROR:  operator does not exist: mood = happiness"
msgstr ""
"CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');\n"
"CREATE TABLE holidays (\n"
"    num_weeks integer,\n"
"    happiness happiness\n"
");\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');\n"
"INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');\n"
"ОШИБКА:  неверное значение для перечисления happiness: \"sad\"\n"
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood = holidays.happiness;\n"
"ОШИБКА:  оператор не существует: mood = happiness"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3023(para)
msgid ""
"Each enumerated data type is separate and cannot be compared with other "
"enumerated types. See this example: <placeholder-1/>"
msgstr ""
"Все типы перечислений считаются уникальными и поэтому значения разных типов "
"нельзя сравнивать. Взгляните на этот пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3048(programlisting)
#, no-wrap
msgid ""
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood::text = holidays.happiness::text;\n"
" name | num_weeks \n"
"------+-----------\n"
" Moe  |         4\n"
"(1 row)"
msgstr ""
"SELECT person.name, holidays.num_weeks FROM person, holidays\n"
"  WHERE person.current_mood::text = holidays.happiness::text;\n"
" name | num_weeks \n"
"------+-----------\n"
" Moe  |         4\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3044(para)
msgid ""
"If you really need to do something like that, you can either write a custom "
"operator or add explicit casts to your query: <placeholder-1/>"
msgstr ""
"Если вам действительно нужно сделать что-то подобное, вы можете либо "
"реализовать собственный оператор, либо явно преобразовать типы в запросе: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3061(title)
msgid "Implementation Details"
msgstr "Тонкости реализации"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3063(para)
msgid ""
"An enum value occupies four bytes on disk. The length of an enum value's "
"textual label is limited by the <symbol>NAMEDATALEN</symbol> setting "
"compiled into <productname>PostgreSQL</productname>; in standard builds this "
"means at most 63 bytes."
msgstr ""
"Значение enum занимает на диске 4 байта. Длина текстовой метки значения "
"ограничена параметром компиляции <symbol>NAMEDATALEN</symbol>; в стандартных "
"сборках <productname>PostgreSQL</productname> он ограничивает длину 63 "
"байтами."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3070(para)
msgid ""
"Enum labels are case sensitive, so <type>'happy'</type> is not the same as "
"<type>'HAPPY'</type>. White space in the labels is significant too."
msgstr ""
"В метках значений регистр имеет значение, т. е. <type>'happy'</type> и "
"<type>'HAPPY'</type> &mdash; не одно и то же. Также в метках имеют значение "
"пробелы."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3076(para)
msgid ""
"The translations from internal enum values to textual labels are kept in the "
"system catalog <link linkend=\"catalog-pg-enum\"><structname>pg_enum</"
"structname></link>. Querying this catalog directly can be useful."
msgstr ""
"Сопоставления внутренних значений enum с текстовыми метками хранятся в "
"системном каталоге <link linkend=\"catalog-pg-enum\"><structname>pg_enum</"
"structname></link>. Он может быть полезен в ряде случаев."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3087(title) datatype.xml:3096(title)
msgid "Geometric Types"
msgstr "Геометрические типы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3089(para)
msgid ""
"Geometric data types represent two-dimensional spatial objects. <xref "
"linkend=\"datatype-geo-table\"/> shows the geometric types available in "
"<productname>PostgreSQL</productname>."
msgstr ""
"Геометрические типы данных представляют объекты в двумерном пространстве. "
"Все существующие в <productname>PostgreSQL</productname> геометрические типы "
"перечислены в <xref remap=\"6\" linkend=\"datatype-geo-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3103(entry)
msgid "Representation"
msgstr "Представление"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3110(entry)
msgid "Point on a plane"
msgstr "Точка на плоскости"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3111(entry)
msgid "(x,y)"
msgstr "(x,y)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3115(entry) datatype.xml:3121(entry) datatype.xml:3127(entry)
msgid "32 bytes"
msgstr "32 байта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3116(entry)
msgid "Infinite line"
msgstr "Бесконечная прямая"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3117(entry)
msgid "{A,B,C}"
msgstr "{A,B,C}"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3122(entry)
msgid "Finite line segment"
msgstr "Отрезок"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3123(entry) datatype.xml:3129(entry)
msgid "((x1,y1),(x2,y2))"
msgstr "((x1,y1),(x2,y2))"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3128(entry)
msgid "Rectangular box"
msgstr "Прямоугольник"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3133(entry) datatype.xml:3139(entry)
msgid "16+16n bytes"
msgstr "16+16n байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3134(entry)
msgid "Closed path (similar to polygon)"
msgstr "Закрытый путь (подобный многоугольнику)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3135(entry) datatype.xml:3147(entry)
msgid "((x1,y1),...)"
msgstr "((x1,y1),...)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3140(entry)
msgid "Open path"
msgstr "Открытый путь"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3141(entry)
msgid "[(x1,y1),...]"
msgstr "[(x1,y1),...]"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3145(entry)
msgid "40+16n bytes"
msgstr "40+16n байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3146(entry)
msgid "Polygon (similar to closed path)"
msgstr "Многоугольник (подобный закрытому пути)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3151(entry)
msgid "24 bytes"
msgstr "24 байта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3152(entry)
msgid "Circle"
msgstr "Окружность"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3153(entry)
msgid "&lt;(x,y),r&gt; (center point and radius)"
msgstr "&lt;(x,y),r&gt; (центр окружности и радиус)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3159(para)
msgid ""
"A rich set of functions and operators is available to perform various "
"geometric operations such as scaling, translation, rotation, and determining "
"intersections. They are explained in <xref linkend=\"functions-geometry\"/>."
msgstr ""
"Для выполнения различных геометрических операций, в частности "
"масштабирования, вращения и определения пересечений, "
"<productname>PostgreSQL</productname> предлагает богатый набор функций и "
"операторов. Они рассматриваются в <xref remap=\"6\" linkend=\"functions-"
"geometry\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3166(title)
msgid "Points"
msgstr "Точки"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3168(indexterm)
msgid "<primary>point</primary>"
msgstr "<primary>точка</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3172(para)
msgid ""
"Points are the fundamental two-dimensional building block for geometric "
"types. Values of type <type>point</type> are specified using either of the "
"following syntaxes: <synopsis>\n"
"( <replaceable>x</replaceable> , <replaceable>y</replaceable> )\n"
"  <replaceable>x</replaceable> , <replaceable>y</replaceable>\n"
"</synopsis> where <replaceable>x</replaceable> and <replaceable>y</"
"replaceable> are the respective coordinates, as floating-point numbers."
msgstr ""
"Точки &mdash; это основной элемент, на базе которого строятся все остальные "
"геометрические типы. Значения типа <type>point</type> записываются в одном "
"из двух форматов: <synopsis>\n"
"( <replaceable>x</replaceable> , <replaceable>y</replaceable> )\n"
"  <replaceable>x</replaceable> , <replaceable>y</replaceable>\n"
"</synopsis> где <replaceable>x</replaceable> и <replaceable>y</replaceable> "
"&mdash; координаты точки на плоскости, выраженные числами с плавающей точкой."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3186(para)
msgid "Points are output using the first syntax."
msgstr "Выводятся точки в первом формате."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3192(title)
msgid "Lines"
msgstr "Прямые"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3194(indexterm)
msgid "<primary>line</primary>"
msgstr "<primary>прямая</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3198(para)
msgid ""
"Lines are represented by the linear equation <replaceable>A</replaceable>x + "
"<replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0, where "
"<replaceable>A</replaceable> and <replaceable>B</replaceable> are not both "
"zero. Values of type <type>line</type> are input and output in the following "
"form: <synopsis>\n"
"{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, "
"<replaceable>C</replaceable> }\n"
"</synopsis> Alternatively, any of the following forms can be used for input: "
"<synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> and <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> are two different points on the "
"line."
msgstr ""
"Прямые представляются линейным уравнением <replaceable>A</replaceable>x + "
"<replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0, где "
"<replaceable>A</replaceable> и <replaceable>B</replaceable> не равны 0. "
"Значения типа <type>line</type> вводятся и выводятся в следующем виде: "
"<synopsis>\n"
"{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, "
"<replaceable>C</replaceable> }\n"
"</synopsis> Кроме того, для ввода может использоваться любая из этих форм: "
"<synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> &mdash; две различные точки на "
"данной прямой."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3225(title)
msgid "Line Segments"
msgstr "Отрезки"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3227(indexterm)
msgid "<primary>lseg</primary>"
msgstr "<primary>lseg</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3231(indexterm)
msgid "<primary>line segment</primary>"
msgstr "<primary>отрезок</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3235(para)
msgid ""
"Line segments are represented by pairs of points that are the endpoints of "
"the segment. Values of type <type>lseg</type> are specified using any of the "
"following syntaxes: <synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> and <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> are the end points of the line "
"segment."
msgstr ""
"Отрезок представляется парой точек, определяющих концы отрезка. Значения "
"типа <type>lseg</type> записываются в одной из следующих форм: <synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> &mdash; концы отрезка."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3254(para)
msgid "Line segments are output using the first syntax."
msgstr "Выводятся отрезки в первом формате."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3260(title)
msgid "Boxes"
msgstr "Прямоугольники"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3262(indexterm)
msgid "<primary>box (data type)</primary>"
msgstr "<primary>box (тип данных)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3266(indexterm)
msgid "<primary>rectangle</primary>"
msgstr "<primary>прямоугольник</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3270(para)
msgid ""
"Boxes are represented by pairs of points that are opposite corners of the "
"box. Values of type <type>box</type> are specified using any of the "
"following syntaxes: <synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> and <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> are any two opposite corners of the "
"box."
msgstr ""
"Прямоугольник представляется двумя точками, находящимися в противоположных "
"его углах. Значения типа <type>box</type> записываются в одной из следующих "
"форм: <synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , "
"( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   "
"<replaceable>x2</replaceable> , <replaceable>y2</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x1</replaceable>,<replaceable>y1</"
"replaceable>)</literal> и <literal>(<replaceable>x2</replaceable>,"
"<replaceable>y2</replaceable>)</literal> &mdash; противоположные углы "
"прямоугольника."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3289(para)
msgid "Boxes are output using the second syntax."
msgstr "Выводятся прямоугольники во второй форме."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3293(para)
msgid ""
"Any two opposite corners can be supplied on input, but the values will be "
"reordered as needed to store the upper right and lower left corners, in that "
"order."
msgstr ""
"Во вводимом значении могут быть указаны любые два противоположных угла, но "
"затем они будут упорядочены, так что внутри сохранятся правый верхний и "
"левый нижний углы, в таком порядке."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3301(title)
msgid "Paths"
msgstr "Пути"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3303(indexterm)
msgid "<primary>path (data type)</primary>"
msgstr "<primary>path (тип данных)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3307(para)
msgid ""
"Paths are represented by lists of connected points. Paths can be "
"<firstterm>open</firstterm>, where the first and last points in the list are "
"considered not connected, or <firstterm>closed</firstterm>, where the first "
"and last points are considered connected."
msgstr ""
"Пути представляют собой списки соединённых точек. Пути могут быть "
"<firstterm>закрытыми</firstterm>, когда подразумевается, что первая и "
"последняя точка в списке соединены, или <firstterm>открытыми</firstterm>, в "
"противном случае."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3315(para)
msgid ""
"Values of type <type>path</type> are specified using any of the following "
"syntaxes: <synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> where the points are the end points of the line segments "
"comprising the path. Square brackets (<literal>[]</literal>) indicate an "
"open path, while parentheses (<literal>()</literal>) indicate a closed path. "
"When the outermost parentheses are omitted, as in the third through fifth "
"syntaxes, a closed path is assumed."
msgstr ""
"Значения типа <type>path</type> записываются в одной из следующих форм: "
"<synopsis>\n"
"[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> где точки задают узлы сегментов, составляющих путь. Квадратные "
"скобки (<literal>[]</literal>) указывают, что путь открытый, а круглые "
"(<literal>()</literal>) &mdash; закрытый. Когда внешние скобки опускаются, "
"как в показанных выше последних трёх формах, считается, что путь закрытый."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3334(para)
msgid "Paths are output using the first or second syntax, as appropriate."
msgstr "Пути выводятся в первой или второй форме, в соответствии с типом."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3340(title)
msgid "Polygons"
msgstr "Многоугольники"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3342(indexterm)
msgid "<primary>polygon</primary>"
msgstr "<primary>многоугольник</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3346(para)
msgid ""
"Polygons are represented by lists of points (the vertexes of the polygon). "
"Polygons are very similar to closed paths, but are stored differently and "
"have their own set of support routines."
msgstr ""
"Многоугольники представляются списками точек (вершин). Многоугольники похожи "
"на закрытые пути, но хранятся в другом виде и для работы с ними предназначен "
"отдельный набор функций."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3352(para)
msgid ""
"Values of type <type>polygon</type> are specified using any of the following "
"syntaxes: <synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> where the points are the end points of the line segments "
"comprising the boundary of the polygon."
msgstr ""
"Значения типа <type>polygon</type> записываются в одной из следующих форм: "
"<synopsis>\n"
"( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , "
"( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )\n"
"  ( <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable> )\n"
"    <replaceable>x1</replaceable> , <replaceable>y1</"
"replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</"
"replaceable>\n"
"</synopsis> где точки задают узлы сегментов, образующих границу "
"многоугольника."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3367(para)
msgid "Polygons are output using the first syntax."
msgstr "Выводятся многоугольники в первом формате."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3373(title)
msgid "Circles"
msgstr "Окружности"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3375(indexterm)
msgid "<primary>circle</primary>"
msgstr "<primary>круг</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3379(para)
msgid ""
"Circles are represented by a center point and radius. Values of type "
"<type>circle</type> are specified using any of the following syntaxes: "
"<synopsis>\n"
"&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> &gt;\n"
"( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> )\n"
"  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable>\n"
"    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , "
"<replaceable>r</replaceable>\n"
"</synopsis> where <literal>(<replaceable>x</replaceable>,<replaceable>y</"
"replaceable>)</literal> is the center point and <replaceable>r</replaceable> "
"is the radius of the circle."
msgstr ""
"Окружности задаются координатами центра и радиусом. Значения типа "
"<type>circle</type> записываются в одном из следующих форматов: <synopsis>\n"
"&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> &gt;\n"
"( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable> )\n"
"  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , "
"<replaceable>r</replaceable>\n"
"    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , "
"<replaceable>r</replaceable>\n"
"</synopsis> где <literal>(<replaceable>x</replaceable>,<replaceable>y</"
"replaceable>)</literal> &mdash; центр окружности, а <replaceable>r</"
"replaceable> &mdash; её радиус."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3397(para)
msgid "Circles are output using the first syntax."
msgstr "Выводятся окружности в первом формате."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3405(title) datatype.xml:3422(title)
msgid "Network Address Types"
msgstr "Типы, описывающие сетевые адреса"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3407(indexterm)
msgid "<primary>network</primary> <secondary>data types</secondary>"
msgstr "<primary>сетевые адреса</primary> <secondary>типы данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3412(para)
msgid ""
"<productname>PostgreSQL</productname> offers data types to store IPv4, IPv6, "
"and MAC addresses, as shown in <xref linkend=\"datatype-net-types-table\"/>. "
"It is better to use these types instead of plain text types to store network "
"addresses, because these types offer input error checking and specialized "
"operators and functions (see <xref linkend=\"functions-net\"/>)."
msgstr ""
"<productname>PostgreSQL</productname> предлагает типы данных для хранения "
"адресов IPv4, IPv6 и MAC, показанные в <xref remap=\"6\" linkend=\"datatype-"
"net-types-table\"/>. Для хранения сетевых адресов лучше использовать эти "
"типы, а не простые текстовые строки, так как <productname>PostgreSQL</"
"productname> проверяет вводимые значения данных типов и предоставляет "
"специализированные операторы и функции для работы с ними (см. <xref remap="
"\"4\" linkend=\"functions-net\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3435(entry) datatype.xml:3441(entry)
msgid "7 or 19 bytes"
msgstr "7 или 19 байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3436(entry)
msgid "IPv4 and IPv6 networks"
msgstr "Сети IPv4 и IPv6"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3442(entry)
msgid "IPv4 and IPv6 hosts and networks"
msgstr "Узлы и сети IPv4 и IPv6"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3447(entry)
msgid "6 bytes"
msgstr "6 байт"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3448(entry)
msgid "MAC addresses"
msgstr "MAC-адреса"

#. +> REL_10
#: datatype.xml:3454(entry)
msgid "MAC addresses (EUI-64 format)"
msgstr "MAC-адреса (в формате EUI-64)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3461(para)
msgid ""
"When sorting <type>inet</type> or <type>cidr</type> data types, IPv4 "
"addresses will always sort before IPv6 addresses, including IPv4 addresses "
"encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::"
"ffff:10.4.3.2."
msgstr ""
"При сортировке типов <type>inet</type> и <type>cidr</type>, адреса IPv4 "
"всегда идут до адресов IPv6, в том числе адреса IPv4, включённые в IPv6 или "
"сопоставленные с ними, например ::10.2.3.4 или ::ffff:10.4.3.2."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3472(indexterm)
msgid "<primary>inet (data type)</primary>"
msgstr "<primary>inet (тип данных)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3476(para)
msgid ""
"The <type>inet</type> type holds an IPv4 or IPv6 host address, and "
"optionally its subnet, all in one field. The subnet is represented by the "
"number of network address bits present in the host address (the "
"<quote>netmask</quote>). If the netmask is 32 and the address is IPv4, then "
"the value does not indicate a subnet, only a single host. In IPv6, the "
"address length is 128 bits, so 128 bits specify a unique host address. Note "
"that if you want to accept only networks, you should use the <type>cidr</"
"type> type rather than <type>inet</type>."
msgstr ""
"Тип <type>inet</type> содержит IPv4- или IPv6-адрес узла и может также "
"содержать его подсеть, всё в одном поле. Подсеть представляется числом бит, "
"определяющих адрес сети в адресе узла (или <quote>маску сети</quote>). Если "
"маска сети равна 32 для адреса IPv4, такое значение представляет не подсеть, "
"а определённый узел. Адреса IPv6 имеют длину 128 бит, поэтому уникальный "
"адрес узла задаётся с маской 128 бит. Заметьте, что когда нужно, чтобы "
"принимались только адреса сетей, следует использовать тип <type>cidr</type>, "
"а не <type>inet</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3489(para)
msgid ""
"The input format for this type is <replaceable class=\"parameter\">address/"
"y</replaceable> where <replaceable class=\"parameter\">address</replaceable> "
"is an IPv4 or IPv6 address and <replaceable class=\"parameter\">y</"
"replaceable> is the number of bits in the netmask. If the <replaceable class="
"\"parameter\">/y</replaceable> portion is missing, the netmask is 32 for "
"IPv4 and 128 for IPv6, so the value represents just a single host. On "
"display, the <replaceable class=\"parameter\">/y</replaceable> portion is "
"suppressed if the netmask specifies a single host."
msgstr ""
"Вводимые значения такого типа должны иметь формат <replaceable class="
"\"parameter\">IP-адрес/y</replaceable>, где <replaceable class=\"parameter"
"\">IP-адрес</replaceable> &mdash; адрес IPv4 или IPv6, а <replaceable class="
"\"parameter\">y</replaceable> &mdash; число бит в маске сети. Если компонент "
"<replaceable class=\"parameter\">/y</replaceable> отсутствует, маска сети "
"считается равной 32 для IPv4 и 128 для IPv6, так что это значение будет "
"представлять один узел. При выводе компонент <replaceable class=\"parameter"
"\">/y</replaceable> опускается, если сетевой адрес определяет адрес одного "
"узла."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3509(indexterm)
msgid "<primary>cidr</primary>"
msgstr "<primary>cidr</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3513(para)
msgid ""
"The <type>cidr</type> type holds an IPv4 or IPv6 network specification. "
"Input and output formats follow Classless Internet Domain Routing "
"conventions. The format for specifying networks is <replaceable class="
"\"parameter\">address/y</replaceable> where <replaceable class=\"parameter"
"\">address</replaceable> is the network represented as an IPv4 or IPv6 "
"address, and <replaceable class=\"parameter\">y</replaceable> is the number "
"of bits in the netmask. If <replaceable class=\"parameter\">y</replaceable> "
"is omitted, it is calculated using assumptions from the older classful "
"network numbering system, except it will be at least large enough to include "
"all of the octets written in the input. It is an error to specify a network "
"address that has bits set to the right of the specified netmask."
msgstr ""
"Тип <type>cidr</type> содержит определение сети IPv4 или IPv6. Входные и "
"выходные форматы соответствуют соглашениям CIDR (Classless Internet Domain "
"Routing, Бесклассовая межсетевая адресация). Определение сети записывается в "
"формате <replaceable class=\"parameter\">IP-адрес/y</replaceable>, где "
"<replaceable class=\"parameter\">IP-адрес</replaceable> &mdash; адрес сети "
"IPv4 или IPv6, а <replaceable class=\"parameter\">y</replaceable> &mdash; "
"число бит в маске сети. Если <replaceable class=\"parameter\">y</"
"replaceable> не указывается, это значение вычисляется по старой классовой "
"схеме нумерации сетей, но при этом оно может быть увеличено, чтобы в него "
"вошли все байты введённого адреса. Если в сетевом адресе справа от маски "
"сети окажутся биты со значением 1, он будет считаться ошибочным."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3529(para)
msgid "<xref linkend=\"datatype-net-cidr-table\"/> shows some examples."
msgstr ""
"В <xref remap=\"6\" linkend=\"datatype-net-cidr-table\"/> показаны несколько "
"примеров адресов."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3534(title)
msgid "<type>cidr</type> Type Input Examples"
msgstr "Примеры допустимых значений типа <type>cidr</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3538(entry)
msgid "<type>cidr</type> Input"
msgstr "Вводимое значение <type>cidr</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3539(entry)
msgid "<type>cidr</type> Output"
msgstr "Выводимое значение <type>cidr</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3540(function)
msgid "abbrev(<placeholder-1/>)"
msgstr "abbrev(<placeholder-1/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3545(entry) datatype.xml:3546(entry) datatype.xml:3547(entry)
msgid "192.168.100.128/25"
msgstr "192.168.100.128/25"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3550(entry)
msgid "192.168/24"
msgstr "192.168/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3551(entry) datatype.xml:3566(entry)
msgid "192.168.0.0/24"
msgstr "192.168.0.0/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3552(entry) datatype.xml:3567(entry)
msgid "192.168.0/24"
msgstr "192.168.0/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3555(entry)
msgid "192.168/25"
msgstr "192.168/25"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3556(entry) datatype.xml:3557(entry)
msgid "192.168.0.0/25"
msgstr "192.168.0.0/25"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3560(entry)
msgid "192.168.1"
msgstr "192.168.1"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3561(entry)
msgid "192.168.1.0/24"
msgstr "192.168.1.0/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3562(entry)
msgid "192.168.1/24"
msgstr "192.168.1/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3565(entry)
msgid "192.168"
msgstr "192.168"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3570(entry)
msgid "128.1"
msgstr "128.1"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3571(entry)
msgid "128.1.0.0/16"
msgstr "128.1.0.0/16"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3572(entry)
msgid "128.1/16"
msgstr "128.1/16"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3575(entry)
msgid "128"
msgstr "128"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3576(entry)
msgid "128.0.0.0/16"
msgstr "128.0.0.0/16"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3577(entry)
msgid "128.0/16"
msgstr "128.0/16"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3580(entry)
msgid "128.1.2"
msgstr "128.1.2"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3581(entry)
msgid "128.1.2.0/24"
msgstr "128.1.2.0/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3582(entry)
msgid "128.1.2/24"
msgstr "128.1.2/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3585(entry)
msgid "10.1.2"
msgstr "10.1.2"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3586(entry)
msgid "10.1.2.0/24"
msgstr "10.1.2.0/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3587(entry)
msgid "10.1.2/24"
msgstr "10.1.2/24"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3590(entry)
msgid "10.1"
msgstr "10.1"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3591(entry)
msgid "10.1.0.0/16"
msgstr "10.1.0.0/16"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3592(entry)
msgid "10.1/16"
msgstr "10.1/16"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3595(entry)
msgid "10"
msgstr "10"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3596(entry)
msgid "10.0.0.0/8"
msgstr "10.0.0.0/8"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3597(entry)
msgid "10/8"
msgstr "10/8"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3600(entry) datatype.xml:3601(entry) datatype.xml:3602(entry)
msgid "10.1.2.3/32"
msgstr "10.1.2.3/32"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3605(entry) datatype.xml:3606(entry) datatype.xml:3607(entry)
msgid "2001:4f8:3:ba::/64"
msgstr "2001:4f8:3:ba::/64"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3610(entry) datatype.xml:3611(entry)
msgid "2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128"
msgstr "2001:4f8:3:ba:2e0:81ff:fe22:&zwsp;d1f1/128"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3612(entry)
msgid "2001:4f8:3:ba:2e0:81ff:fe22:d1f1"
msgstr "2001:4f8:3:ba:2e0:81ff:fe22:&zwsp;d1f1"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3615(entry) datatype.xml:3616(entry)
msgid "::ffff:1.2.3.0/120"
msgstr "::ffff:1.2.3.0/120"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3617(entry)
msgid "::ffff:1.2.3/120"
msgstr "::ffff:1.2.3/120"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3620(entry) datatype.xml:3621(entry) datatype.xml:3622(entry)
msgid "::ffff:1.2.3.0/128"
msgstr "::ffff:1.2.3.0/128"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3630(title)
msgid "<type>inet</type> vs. <type>cidr</type>"
msgstr "Различия <type>inet</type> и <type>cidr</type>"

#. +> REL_10
#: datatype.xml:3632(para)
msgid ""
"The essential difference between <type>inet</type> and <type>cidr</type> "
"data types is that <type>inet</type> accepts values with nonzero bits to the "
"right of the netmask, whereas <type>cidr</type> does not. For example, "
"<literal>192.168.0.1/24</literal> is valid for <type>inet</type> but not for "
"<type>cidr</type>."
msgstr ""
"Существенным различием типов данных <type>inet</type> и <type>cidr</type> "
"является то, что <type>inet</type> принимает значения с ненулевыми битами "
"справа от маски сети, а <type>cidr</type> &mdash; нет. Например, значение "
"<literal>192.168.0.1/24</literal> является допустимым для типа <type>inet</"
"type>, но не для <type>cidr</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3641(para)
msgid ""
"If you do not like the output format for <type>inet</type> or <type>cidr</"
"type> values, try the functions <function>host</function>, <function>text</"
"function>, and <function>abbrev</function>."
msgstr ""
"Если вас не устраивает выходной формат значений <type>inet</type> или "
"<type>cidr</type>, попробуйте функции <function>host</function>, "
"<function>text</function> и <function>abbrev</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3652(indexterm)
msgid "<primary>macaddr (data type)</primary>"
msgstr "<primary>macaddr (тип данных)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3656(indexterm)
msgid "<primary>MAC address</primary> <see>macaddr</see>"
msgstr "<primary>MAC-адрес</primary> <see>macaddr</see>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3668(literal)
msgid "'08:00:2b:01:02:03'"
msgstr "'08:00:2b:01:02:03'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3669(literal)
msgid "'08-00-2b-01-02-03'"
msgstr "'08-00-2b-01-02-03'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3670(literal)
msgid "'08002b:010203'"
msgstr "'08002b:010203'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3671(literal)
msgid "'08002b-010203'"
msgstr "'08002b-010203'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3672(literal)
msgid "'0800.2b01.0203'"
msgstr "'0800.2b01.0203'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3673(literal)
msgid "'0800-2b01-0203'"
msgstr "'0800-2b01-0203'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3674(literal)
msgid "'08002b010203'"
msgstr "'08002b010203'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3661(para)
msgid ""
"The <type>macaddr</type> type stores MAC addresses, known for example from "
"Ethernet card hardware addresses (although MAC addresses are used for other "
"purposes as well). Input is accepted in the following formats: "
"<placeholder-1/> These examples would all specify the same address. Upper "
"and lower case is accepted for the digits <literal>a</literal> through "
"<literal>f</literal>. Output is always in the first of the forms shown."
msgstr ""
"Тип <type>macaddr</type> предназначен для хранения MAC-адреса, примером "
"которого является адрес сетевой платы Ethernet (хотя MAC-адреса применяются "
"и для других целей). Вводимые значения могут задаваться в следующих "
"форматах: <placeholder-1/> Все эти примеры определяют один и тот же адрес. "
"Шестнадцатеричные цифры от <literal>a</literal> до <literal>f</literal> "
"могут быть и в нижнем, и в верхнем регистре. Выводятся MAC-адреса всегда в "
"первой форме."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3683(para)
msgid ""
"IEEE Std 802-2001 specifies the second shown form (with hyphens) as the "
"canonical form for MAC addresses, and specifies the first form (with colons) "
"as the bit-reversed notation, so that 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. "
"This convention is widely ignored nowadays, and it is relevant only for "
"obsolete network protocols (such as Token Ring). PostgreSQL makes no "
"provisions for bit reversal, and all accepted formats use the canonical LSB "
"order."
msgstr ""
"Стандарт IEEE 802-2001 считает канонической формой MAC-адресов вторую (с "
"минусами), а в первой (с двоеточиями) предполагает обратный порядок бит, так "
"что 08-00-2b-01-02-03 = 01:00:4D:08:04:0C. В настоящее время этому "
"соглашению практически никто не следует, и уместно оно было только для "
"устаревших сетевых протоколов (таких как Token Ring). PostgreSQL не меняет "
"порядок бит и во всех принимаемых форматах подразумевается традиционный "
"порядок LSB."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3694(para)
msgid "The remaining five input formats are not part of any standard."
msgstr "Последние пять входных форматов не описаны ни в каком стандарте."

#. +> REL_10
#: datatype.xml:3702(indexterm)
msgid "<primary>macaddr8 (data type)</primary>"
msgstr "<primary>macaddr8 (тип данных)</primary>"

#. +> REL_10
#: datatype.xml:3706(indexterm)
msgid "<primary>MAC address (EUI-64 format)</primary> <see>macaddr</see>"
msgstr "<primary>MAC-адрес (в формате EUI-64)</primary> <see>macaddr</see>"

#. +> REL_10
#: datatype.xml:3734(literal)
msgid "'08:00:2b:01:02:03:04:05'"
msgstr "'08:00:2b:01:02:03:04:05'"

#. +> REL_10
#: datatype.xml:3735(literal)
msgid "'08-00-2b-01-02-03-04-05'"
msgstr "'08-00-2b-01-02-03-04-05'"

#. +> REL_10
#: datatype.xml:3736(literal)
msgid "'08002b:0102030405'"
msgstr "'08002b:0102030405'"

#. +> REL_10
#: datatype.xml:3737(literal)
msgid "'08002b-0102030405'"
msgstr "'08002b-0102030405'"

#. +> REL_10
#: datatype.xml:3738(literal)
msgid "'0800.2b01.0203.0405'"
msgstr "'0800.2b01.0203.0405'"

#. +> REL_10
#: datatype.xml:3739(literal)
msgid "'0800-2b01-0203-0405'"
msgstr "'0800-2b01-0203-0405'"

#. +> REL_10
#: datatype.xml:3740(literal)
msgid "'08002b01:02030405'"
msgstr "'08002b01:02030405'"

#. +> REL_10
#: datatype.xml:3741(literal)
msgid "'08002b0102030405'"
msgstr "'08002b0102030405'"

#. +> REL_10
#: datatype.xml:3756(programlisting)
#, no-wrap
msgid ""
"SELECT macaddr8_set7bit('08:00:2b:01:02:03');\n"
"<computeroutput>\n"
"    macaddr8_set7bit     \n"
"-------------------------\n"
" 0a:00:2b:ff:fe:01:02:03\n"
"(1 row)\n"
"</computeroutput>"
msgstr ""
"SELECT macaddr8_set7bit('08:00:2b:01:02:03');\n"
"<computeroutput>\n"
"    macaddr8_set7bit     \n"
"-------------------------\n"
" 0a:00:2b:ff:fe:01:02:03\n"
"(1 row)\n"
"</computeroutput>"

#. +> REL_10
#: datatype.xml:3711(para)
msgid ""
"The <type>macaddr8</type> type stores MAC addresses in EUI-64 format, known "
"for example from Ethernet card hardware addresses (although MAC addresses "
"are used for other purposes as well). This type can accept both 6 and 8 byte "
"length MAC addresses and stores them in 8 byte length format. MAC addresses "
"given in 6 byte format will be stored in 8 byte length format with the 4th "
"and 5th bytes set to FF and FE, respectively. Note that IPv6 uses a modified "
"EUI-64 format where the 7th bit should be set to one after the conversion "
"from EUI-48. The function <function>macaddr8_set7bit</function> is provided "
"to make this change. Generally speaking, any input which is comprised of "
"pairs of hex digits (on byte boundaries), optionally separated consistently "
"by one of <literal>':'</literal>, <literal>'-'</literal> or <literal>'.'</"
"literal>, is accepted. The number of hex digits must be either 16 (8 bytes) "
"or 12 (6 bytes). Leading and trailing whitespace is ignored. The following "
"are examples of input formats that are accepted: <placeholder-1/> These "
"examples would all specify the same address. Upper and lower case is "
"accepted for the digits <literal>a</literal> through <literal>f</literal>. "
"Output is always in the first of the forms shown. The last six input formats "
"that are mentioned above are not part of any standard. To convert a "
"traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to "
"be included as the host portion of an IPv6 address, use "
"<function>macaddr8_set7bit</function> as shown: <placeholder-2/>"
msgstr ""
"Тип <type>macaddr8</type> хранит MAC-адреса в формате EUI-64, применяющиеся, "
"например, для аппаратных адресов плат Ethernet (хотя MAC-адреса используются "
"и для других целей). Этот тип может принять и 6-байтовые, и 8-байтовые "
"адреса MAC и сохраняет их в 8 байтах. MAC-адреса, заданные в 6-байтовом "
"формате, хранятся в формате 8 байт, а 4-ый и 5-ый байт содержат FF и FE, "
"соответственно. Заметьте, что для IPv6 используется модифицированный формат "
"EUI-64, в котором 7-ой бит должен быть установлен в 1 после преобразования "
"из EUI-48. Для выполнения этого изменения предоставляется функция "
"<function>macaddr8_set7bit</function>. Вообще говоря, этот тип принимает "
"любые строки, состоящие из пар шестнадцатеричных цифр (выровненных по "
"границам байт), которые могут согласованно разделяться одинаковыми символами "
"<literal>':'</literal>, <literal>'-'</literal> или <literal>'.'</literal>. "
"Шестнадцатеричных цифр должно быть либо 16 (8 байт), либо 12 (6 байт). "
"Ведущие и замыкающие пробелы игнорируются. Ниже показаны примеры допустимых "
"входных строк: <placeholder-1/> Во всех этих примерах задаётся один и тот же "
"адрес. Для цифр с <literal>a</literal> по <literal>f</literal> принимаются "
"буквы и в верхнем, и в нижнем регистре. Вывод всегда представляется в первом "
"из показанных форматов. Последние шесть входных форматов, показанных выше, "
"не являются стандартизированными. Чтобы преобразовать традиционный 48-битный "
"MAC-адрес в формате EUI-48 в модифицированный формат EUI-64 для включения в "
"состав адреса IPv6 в качестве адреса узла, используйте функцию "
"<function>macaddr8_set7bit</function>: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3773(title)
msgid "Bit String Types"
msgstr "Битовые строки"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3775(indexterm)
msgid "<primary>bit string</primary> <secondary>data type</secondary>"
msgstr "<primary>битовая строка</primary> <secondary>тип данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3780(para)
msgid ""
"Bit strings are strings of 1's and 0's. They can be used to store or "
"visualize bit masks. There are two SQL bit types: <type>bit(<replaceable>n</"
"replaceable>)</type> and <type>bit varying(<replaceable>n</replaceable>)</"
"type>, where <replaceable>n</replaceable> is a positive integer."
msgstr ""
"Битовые строки представляют собой последовательности из 1 и 0. Их можно "
"использовать для хранения или отображения битовых масок. В SQL есть два "
"битовых типа: <type>bit(<replaceable>n</replaceable>)</type> и <type>bit "
"varying(<replaceable>n</replaceable>)</type>, где <replaceable>n</"
"replaceable> &mdash; положительное целое число."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3788(para)
msgid ""
"<type>bit</type> type data must match the length <replaceable>n</"
"replaceable> exactly; it is an error to attempt to store shorter or longer "
"bit strings. <type>bit varying</type> data is of variable length up to the "
"maximum length <replaceable>n</replaceable>; longer strings will be "
"rejected. Writing <type>bit</type> without a length is equivalent to "
"<literal>bit(1)</literal>, while <type>bit varying</type> without a length "
"specification means unlimited length."
msgstr ""
"Длина значения типа <type>bit</type> должна в точности равняться "
"<replaceable>n</replaceable>; при попытке сохранить данные длиннее или "
"короче произойдёт ошибка. Данные типа <type>bit varying</type> могут иметь "
"переменную длину, но не превышающую <replaceable>n</replaceable>; строки "
"большей длины не будут приняты. Запись <type>bit</type> без указания длины "
"равнозначна записи <literal>bit(1)</literal>, тогда как <type>bit varying</"
"type> без указания длины подразумевает строку неограниченной длины."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3800(para)
msgid ""
"If one explicitly casts a bit-string value to <type>bit(<replaceable>n</"
"replaceable>)</type>, it will be truncated or zero-padded on the right to be "
"exactly <replaceable>n</replaceable> bits, without raising an error. "
"Similarly, if one explicitly casts a bit-string value to <type>bit "
"varying(<replaceable>n</replaceable>)</type>, it will be truncated on the "
"right if it is more than <replaceable>n</replaceable> bits."
msgstr ""
"При попытке привести значение битовой строки к типу "
"<type>bit(<replaceable>n</replaceable>)</type>, оно будет усечено или "
"дополнено нулями справа до длины ровно <replaceable>n</replaceable> бит, "
"ошибки при этом не будет. Подобным образом, если явно привести значение "
"битовой строки к типу <type>bit varying(<replaceable>n</replaceable>)</"
"type>, она будет усечена справа, если её длина превышает <replaceable>n</"
"replaceable> бит."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3811(para)
msgid ""
"Refer to <xref linkend=\"sql-syntax-bit-strings\"/> for information about "
"the syntax of bit string constants. Bit-logical operators and string "
"manipulation functions are available; see <xref linkend=\"functions-bitstring"
"\"/>."
msgstr ""
"Синтаксис констант битовых строк описан в <xref remap=\"6\" linkend=\"sql-"
"syntax-bit-strings\"/>, а все доступные битовые операторы и функции "
"перечислены в <xref remap=\"6\" linkend=\"functions-bitstring\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3820(title)
msgid "Using the Bit String Types"
msgstr "Использование битовых строк"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3822(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test (a BIT(3), b BIT VARYING(5));\n"
"INSERT INTO test VALUES (B'101', B'00');\n"
"INSERT INTO test VALUES (B'10', B'101');\n"
"<computeroutput>\n"
"ERROR:  bit string length 2 does not match type bit(3)\n"
"</computeroutput>\n"
"INSERT INTO test VALUES (B'10'::bit(3), B'101');\n"
"SELECT * FROM test;\n"
"<computeroutput>\n"
"  a  |  b\n"
"-----+-----\n"
" 101 | 00\n"
" 100 | 101\n"
"</computeroutput>"
msgstr ""
"CREATE TABLE test (a BIT(3), b BIT VARYING(5));\n"
"INSERT INTO test VALUES (B'101', B'00');\n"
"INSERT INTO test VALUES (B'10', B'101');\n"
"<computeroutput>\n"
"ОШИБКА:  длина битовой строки (2) не соответствует типу bit(3)\n"
"</computeroutput>\n"
"INSERT INTO test VALUES (B'10'::bit(3), B'101');\n"
"SELECT * FROM test;\n"
"<computeroutput>\n"
"  a  |  b\n"
"-----+-----\n"
" 101 | 00\n"
" 100 | 101\n"
"</computeroutput>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3840(para)
msgid ""
"A bit string value requires 1 byte for each group of 8 bits, plus 5 or 8 "
"bytes overhead depending on the length of the string (but long values may be "
"compressed or moved out-of-line, as explained in <xref linkend=\"datatype-"
"character\"/> for character strings)."
msgstr ""
"Для хранения битовой строки используется по 1 байту для каждой группы из 8 "
"бит, плюс 5 или 8 байт дополнительно в зависимости от длины строки (но "
"длинные строки могут быть сжаты или вынесены отдельно, как описано в <xref "
"remap=\"6\" linkend=\"datatype-character\"/> применительно к символьным "
"строкам)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3849(title)
msgid "Text Search Types"
msgstr "Типы, предназначенные для текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3851(indexterm)
msgid "<primary>full text search</primary> <secondary>data types</secondary>"
msgstr ""
"<primary>полнотекстовый поиск</primary> <secondary>типы данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3856(indexterm)
msgid "<primary>text search</primary> <secondary>data types</secondary>"
msgstr "<primary>текстовый поиск</primary> <secondary>типы данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3861(para)
msgid ""
"<productname>PostgreSQL</productname> provides two data types that are "
"designed to support full text search, which is the activity of searching "
"through a collection of natural-language <firstterm>documents</firstterm> to "
"locate those that best match a <firstterm>query</firstterm>. The "
"<type>tsvector</type> type represents a document in a form optimized for "
"text search; the <type>tsquery</type> type similarly represents a text "
"query. <xref linkend=\"textsearch\"/> provides a detailed explanation of "
"this facility, and <xref linkend=\"functions-textsearch\"/> summarizes the "
"related functions and operators."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет два типа данных для "
"поддержки полнотекстового поиска. Текстовым поиском называется операция "
"анализа набора <firstterm>документов</firstterm> с текстом на естественном "
"языке, в результате которой находятся фрагменты, наиболее соответствующие "
"<firstterm>запросу</firstterm>. Тип <type>tsvector</type> представляет "
"документ в виде, оптимизированном для текстового поиска, а <type>tsquery</"
"type> представляет запрос текстового поиска в подобном виде. Более подробно "
"это описывается в <xref remap=\"6\" linkend=\"textsearch\"/>, а все "
"связанные функции и операторы перечислены в <xref remap=\"6\" linkend="
"\"functions-textsearch\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3877(indexterm)
msgid "<primary>tsvector (data type)</primary>"
msgstr "<primary>tsvector (тип данных)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3889(programlisting)
#, no-wrap
msgid ""
"SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;\n"
"                      tsvector\n"
"----------------------------------------------------\n"
" 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'"
msgstr ""
"SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;\n"
"                      tsvector\n"
"----------------------------------------------------\n"
" 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3899(programlisting)
#, no-wrap
msgid ""
"SELECT $$the lexeme '    ' contains spaces$$::tsvector;\n"
"                 tsvector                  \n"
"-------------------------------------------\n"
" '    ' 'contains' 'lexeme' 'spaces' 'the'"
msgstr ""
"SELECT $$the lexeme '    ' contains spaces$$::tsvector;\n"
"                 tsvector                  \n"
"-------------------------------------------\n"
" '    ' 'contains' 'lexeme' 'spaces' 'the'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3910(programlisting)
#, no-wrap
msgid ""
"SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;\n"
"                    tsvector                    \n"
"------------------------------------------------\n"
" 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'"
msgstr ""
"SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;\n"
"                    tsvector                    \n"
"------------------------------------------------\n"
" 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3920(programlisting)
#, no-wrap
msgid ""
"SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;\n"
"                                  tsvector\n"
"-------------------------------------------------------------------------------\n"
" 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4"
msgstr ""
"SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11\n"
"  rat:12'::tsvector;\n"
"                                  tsvector\n"
"---------------------------------------------------------------------------\n"
" 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12\n"
"  'sat':4"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3881(para)
msgid ""
"A <type>tsvector</type> value is a sorted list of distinct "
"<firstterm>lexemes</firstterm>, which are words that have been "
"<firstterm>normalized</firstterm> to merge different variants of the same "
"word (see <xref linkend=\"textsearch\"/> for details). Sorting and duplicate-"
"elimination are done automatically during input, as shown in this example: "
"<placeholder-1/> To represent lexemes containing whitespace or punctuation, "
"surround them with quotes: <placeholder-2/> (We use dollar-quoted string "
"literals in this example and the next one to avoid the confusion of having "
"to double quote marks within the literals.) Embedded quotes and backslashes "
"must be doubled: <placeholder-3/> Optionally, integer <firstterm>positions</"
"firstterm> can be attached to lexemes: <placeholder-4/> A position normally "
"indicates the source word's location in the document. Positional information "
"can be used for <firstterm>proximity ranking</firstterm>. Position values "
"can range from 1 to 16383; larger numbers are silently set to 16383. "
"Duplicate positions for the same lexeme are discarded."
msgstr ""
"Значение типа <type>tsvector</type> содержит отсортированный список "
"неповторяющихся <firstterm>лексем</firstterm>, т. е. слов, "
"<firstterm>нормализованных</firstterm> так, что все словоформы сводятся к "
"одной (подробнее это описано в <xref remap=\"6\" linkend=\"textsearch\"/>). "
"Сортировка и исключение повторяющихся слов производится автоматически при "
"вводе значения, как показано в этом примере: <placeholder-1/> Для "
"представления в виде лексем пробелов или знаков препинания их нужно "
"заключить в апострофы: <placeholder-2/> (В данном и следующих примерах мы "
"используем строку в долларах, чтобы не дублировать все апострофы в таких "
"строках.) При этом включаемый апостроф или обратную косую черту нужно "
"продублировать: <placeholder-3/> Также для лексем можно указать их "
"целочисленные <firstterm>позиции</firstterm>: <placeholder-4/> Позиция "
"обычно указывает положение исходного слова в документе. Информация о "
"расположении слов затем может использоваться для <firstterm>оценки близости</"
"firstterm>. Позиция может задаваться числом от 1 до 16383; большие значения "
"просто заменяются на 16383. Если для одной лексемы дважды указывается одно "
"положение, такое повторение отбрасывается."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3940(programlisting)
#, no-wrap
msgid ""
"SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;\n"
"          tsvector          \n"
"----------------------------\n"
" 'a':1A 'cat':5 'fat':2B,4C"
msgstr ""
"SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;\n"
"          tsvector          \n"
"----------------------------\n"
" 'a':1A 'cat':5 'fat':2B,4C"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3934(para)
msgid ""
"Lexemes that have positions can further be labeled with a <firstterm>weight</"
"firstterm>, which can be <literal>A</literal>, <literal>B</literal>, "
"<literal>C</literal>, or <literal>D</literal>. <literal>D</literal> is the "
"default and hence is not shown on output: <placeholder-1/> Weights are "
"typically used to reflect document structure, for example by marking title "
"words differently from body words. Text search ranking functions can assign "
"different priorities to the different weight markers."
msgstr ""
"Лексемам, для которых заданы позиции, также можно назначить <firstterm>вес</"
"firstterm>, выраженный буквами <literal>A</literal>, <literal>B</literal>, "
"<literal>C</literal> или <literal>D</literal>. Вес <literal>D</literal> "
"подразумевается по умолчанию и поэтому он не показывается при выводе: "
"<placeholder-1/> Веса обычно применяются для отражения структуры документа, "
"например для придания особого значения словам в заголовке по сравнению со "
"словами в обычном тексте. Назначенным весам можно сопоставить числовые "
"приоритеты в функциях ранжирования результатов."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3959(programlisting)
#, no-wrap
msgid ""
"SELECT 'The Fat Rats'::tsvector;\n"
"      tsvector      \n"
"--------------------\n"
" 'Fat' 'Rats' 'The'"
msgstr ""
"SELECT 'The Fat Rats'::tsvector;\n"
"      tsvector      \n"
"--------------------\n"
" 'Fat' 'Rats' 'The'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3972(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector('english', 'The Fat Rats');\n"
"   to_tsvector   \n"
"-----------------\n"
" 'fat':2 'rat':3"
msgstr ""
"SELECT to_tsvector('english', 'The Fat Rats');\n"
"   to_tsvector   \n"
"-----------------\n"
" 'fat':2 'rat':3"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3953(para)
msgid ""
"It is important to understand that the <type>tsvector</type> type itself "
"does not perform any word normalization; it assumes the words it is given "
"are normalized appropriately for the application. For example, "
"<placeholder-1/> For most English-text-searching applications the above "
"words would be considered non-normalized, but <type>tsvector</type> doesn't "
"care. Raw document text should usually be passed through "
"<function>to_tsvector</function> to normalize the words appropriately for "
"searching: <placeholder-2/> Again, see <xref linkend=\"textsearch\"/> for "
"more detail."
msgstr ""
"Важно понимать, что тип <type>tsvector</type> сам по себе не выполняет "
"нормализацию слов; предполагается, что в сохраняемом значении слова уже "
"нормализованы приложением. Например: <placeholder-1/> Для большинства "
"англоязычных приложений приведённые выше слова будут считаться "
"ненормализованными, но для <type>tsvector</type> это не важно. Поэтому "
"исходный документ обычно следует обработать функцией <function>to_tsvector</"
"function>, нормализующей слова для поиска: <placeholder-2/> И это подробнее "
"описано в <xref remap=\"6\" linkend=\"textsearch\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3987(indexterm)
msgid "<primary>tsquery (data type)</primary>"
msgstr "<primary>tsquery (тип данных)</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:3991(para)
msgid ""
"A <type>tsquery</type> value stores lexemes that are to be searched for, and "
"can combine them using the Boolean operators <literal>&amp;</literal> (AND), "
"<literal>|</literal> (OR), and <literal>!</literal> (NOT), as well as the "
"phrase search operator <literal>&lt;-&gt;</literal> (FOLLOWED BY). There is "
"also a variant <literal>&lt;<replaceable>N</replaceable>&gt;</literal> of "
"the FOLLOWED BY operator, where <replaceable>N</replaceable> is an integer "
"constant that specifies the distance between the two lexemes being searched "
"for. <literal>&lt;-&gt;</literal> is equivalent to <literal>&lt;1&gt;</"
"literal>."
msgstr ""
"Значение <type>tsquery</type> содержит искомые лексемы, объединяемые "
"логическими операторами <literal>&amp;</literal> (И), <literal>|</literal> "
"(ИЛИ) и <literal>!</literal> (НЕ), а также оператором поиска фраз "
"<literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ). Также допускается вариация "
"оператора ПРЕДШЕСТВУЕТ вида <literal>&lt;<replaceable>N</replaceable>&gt;</"
"literal>, где <replaceable>N</replaceable> — целочисленная константа, "
"задающая расстояние между двумя искомыми лексемами. Запись оператора "
"<literal>&lt;-&gt;</literal> равнозначна <literal>&lt;1&gt;</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4003(para)
msgid ""
"Parentheses can be used to enforce grouping of these operators. In the "
"absence of parentheses, <literal>!</literal> (NOT) binds most tightly, "
"<literal>&lt;-&gt;</literal> (FOLLOWED BY) next most tightly, then "
"<literal>&amp;</literal> (AND), with <literal>|</literal> (OR) binding the "
"least tightly."
msgstr ""
"Для группировки операторов могут использоваться скобки. Без скобок эти "
"операторы имеют разные приоритеты, в порядке убывания: <literal>!</literal> "
"(НЕ), <literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ), <literal>&amp;</literal> "
"(И) и <literal>|</literal> (ИЛИ)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4014(programlisting)
#, no-wrap
msgid ""
"SELECT 'fat &amp; rat'::tsquery;\n"
"    tsquery    \n"
"---------------\n"
" 'fat' &amp; 'rat'\n"
"\n"
"SELECT 'fat &amp; (rat | cat)'::tsquery;\n"
"          tsquery          \n"
"---------------------------\n"
" 'fat' &amp; ( 'rat' | 'cat' )\n"
"\n"
"SELECT 'fat &amp; rat &amp; ! cat'::tsquery;\n"
"        tsquery         \n"
"------------------------\n"
" 'fat' &amp; 'rat' &amp; !'cat'"
msgstr ""
"SELECT 'fat &amp; rat'::tsquery;\n"
"    tsquery    \n"
"---------------\n"
" 'fat' &amp; 'rat'\n"
"\n"
"SELECT 'fat &amp; (rat | cat)'::tsquery;\n"
"          tsquery          \n"
"---------------------------\n"
" 'fat' &amp; ( 'rat' | 'cat' )\n"
"\n"
"SELECT 'fat &amp; rat &amp; ! cat'::tsquery;\n"
"        tsquery         \n"
"------------------------\n"
" 'fat' &amp; 'rat' &amp; !'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4011(para)
msgid "Here are some examples: <placeholder-1/>"
msgstr "Несколько примеров: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4037(programlisting)
#, no-wrap
msgid ""
"SELECT 'fat:ab &amp; cat'::tsquery;\n"
"    tsquery\n"
"------------------\n"
" 'fat':AB &amp; 'cat'"
msgstr ""
"SELECT 'fat:ab &amp; cat'::tsquery;\n"
"    tsquery\n"
"------------------\n"
" 'fat':AB &amp; 'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4032(para)
msgid ""
"Optionally, lexemes in a <type>tsquery</type> can be labeled with one or "
"more weight letters, which restricts them to match only <type>tsvector</"
"type> lexemes with one of those weights: <placeholder-1/>"
msgstr ""
"Лексемам в <type>tsquery</type> можно дополнительно сопоставить буквы весов, "
"при этом они будут соответствовать только тем лексемам в <type>tsvector</"
"type>, которые имеют какой-либо из этих весов: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4048(programlisting)
#, no-wrap
msgid ""
"SELECT 'super:*'::tsquery;\n"
"  tsquery  \n"
"-----------\n"
" 'super':*"
msgstr ""
"SELECT 'super:*'::tsquery;\n"
"  tsquery  \n"
"-----------\n"
" 'super':*"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4045(para)
msgid ""
"Also, lexemes in a <type>tsquery</type> can be labeled with <literal>*</"
"literal> to specify prefix matching: <placeholder-1/> This query will match "
"any word in a <type>tsvector</type> that begins with <quote>super</quote>."
msgstr ""
"Кроме того, в лексемах <type>tsquery</type> можно использовать знак "
"<literal>*</literal> для поиска по префиксу: <placeholder-1/> Этот запрос "
"найдёт все слова в <type>tsvector</type>, начинающиеся с приставки "
"<quote>super</quote>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4065(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsquery('Fat:ab &amp; Cats');\n"
"    to_tsquery    \n"
"------------------\n"
" 'fat':AB &amp; 'cat'"
msgstr ""
"SELECT to_tsquery('Fat:ab &amp; Cats');\n"
"    to_tsquery    \n"
"------------------\n"
" 'fat':AB &amp; 'cat'"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4075(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );\n"
" ?column?\n"
"----------\n"
" t"
msgstr ""
"SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );\n"
" ?column?\n"
"----------\n"
" t"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4082(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );\n"
"  to_tsvector  | to_tsquery\n"
"---------------+------------\n"
" 'postgradu':1 | 'postgr':*"
msgstr ""
"SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );\n"
"  to_tsvector  | to_tsquery\n"
"---------------+------------\n"
" 'postgradu':1 | 'postgr':*"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4058(para)
msgid ""
"Quoting rules for lexemes are the same as described previously for lexemes "
"in <type>tsvector</type>; and, as with <type>tsvector</type>, any required "
"normalization of words must be done before converting to the <type>tsquery</"
"type> type. The <function>to_tsquery</function> function is convenient for "
"performing such normalization: <placeholder-1/> Note that "
"<function>to_tsquery</function> will process prefixes in the same way as "
"other words, which means this comparison returns true: <placeholder-2/> "
"because <literal>postgres</literal> gets stemmed to <literal>postgr</"
"literal>: <placeholder-3/> which will match the stemmed form of "
"<literal>postgraduate</literal>."
msgstr ""
"Апострофы в лексемах этого типа можно использовать так же, как и в лексемах "
"в <type>tsvector</type>; и так же, как и для типа <type>tsvector</type>, "
"необходимая нормализация слова должна выполняться до приведения значения к "
"типу <type>tsquery</type>. Для такой нормализации удобно использовать "
"функцию <function>to_tsquery</function>: <placeholder-1/> Заметьте, что "
"функция <function>to_tsquery</function> будет обрабатывать префиксы подобно "
"другим словам, поэтому следующее сравнение возвращает true: <placeholder-2/> "
"так как <literal>postgres</literal> преобразуется стеммером в "
"<literal>postgr</literal>: <placeholder-3/> и эта приставка находится в "
"преобразованной форме слова <literal>postgraduate</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4096(title)
msgid "<acronym>UUID</acronym> Type"
msgstr "Тип <acronym>UUID</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4098(indexterm)
msgid "<primary>UUID</primary>"
msgstr "<primary>UUID</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4106(indexterm)
msgid "<primary>GUID</primary>"
msgstr "<primary>GUID</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4102(para)
msgid ""
"The data type <type>uuid</type> stores Universally Unique Identifiers (UUID) "
"as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards. (Some "
"systems refer to this data type as a globally unique identifier, or GUID,"
"<placeholder-1/> instead.) This identifier is a 128-bit quantity that is "
"generated by an algorithm chosen to make it very unlikely that the same "
"identifier will be generated by anyone else in the known universe using the "
"same algorithm. Therefore, for distributed systems, these identifiers "
"provide a better uniqueness guarantee than sequence generators, which are "
"only unique within a single database."
msgstr ""
"Тип данных <type>uuid</type> сохраняет универсальные уникальные "
"идентификаторы (Universally Unique Identifiers, UUID), определённые в RFC "
"4122, ISO/IEC 9834-8:2005 и связанных стандартах. (В некоторых системах это "
"называется <placeholder-1/>GUID, глобальным уникальным идентификатором.) "
"Этот идентификатор представляет собой 128-битное значение, генерируемое "
"специальным алгоритмом, практически гарантирующим, что этим же алгоритмом "
"оно не будет получено больше нигде в мире. Таким образом, эти идентификаторы "
"будут уникальными и в распределённых системах, а не только в единственной "
"базе данных, как значения генераторов последовательностей."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4121(programlisting)
#, no-wrap
msgid "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"
msgstr "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4129(programlisting)
#, no-wrap
msgid ""
"A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n"
"{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}\n"
"a0eebc999c0b4ef8bb6d6bb9bd380a11\n"
"a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n"
"{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}"
msgstr ""
"A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11\n"
"{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}\n"
"a0eebc999c0b4ef8bb6d6bb9bd380a11\n"
"a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11\n"
"{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4115(para)
msgid ""
"A UUID is written as a sequence of lower-case hexadecimal digits, in several "
"groups separated by hyphens, specifically a group of 8 digits followed by "
"three groups of 4 digits followed by a group of 12 digits, for a total of 32 "
"digits representing the 128 bits. An example of a UUID in this standard form "
"is: <placeholder-1/> <productname>PostgreSQL</productname> also accepts the "
"following alternative forms for input: use of upper-case digits, the "
"standard format surrounded by braces, omitting some or all hyphens, adding a "
"hyphen after any group of four digits. Examples are: <placeholder-2/> Output "
"is always in the standard form."
msgstr ""
"UUID записывается в виде последовательности шестнадцатеричных цифр в нижнем "
"регистре, разделённых знаками минуса на несколько групп, в таком порядке: "
"группа из 8 цифр, за ней три группы из 4 цифр и, наконец, группа из 12 цифр, "
"что в сумме составляет 32 цифры и представляет 128 бит. Пример UUID в этом "
"стандартном виде: <placeholder-1/> <productname>PostgreSQL</productname> "
"также принимает альтернативные варианты: цифры в верхнем регистре, "
"стандартную запись, заключённую в фигурные скобки, запись без минусов или с "
"минусами, разделяющими любые группы из четырёх цифр. Например: "
"<placeholder-2/> Выводится значение этого типа всегда в стандартном виде."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4139(para)
msgid ""
"<productname>PostgreSQL</productname> provides storage and comparison "
"functions for UUIDs, but the core database does not include any function for "
"generating UUIDs, because no single algorithm is well suited for every "
"application. The <xref linkend=\"uuid-ossp\"/> module provides functions "
"that implement several standard algorithms. The <xref linkend=\"pgcrypto\"/> "
"module also provides a generation function for random UUIDs. Alternatively, "
"UUIDs could be generated by client applications or other libraries invoked "
"through a server-side function."
msgstr ""
"В <productname>PostgreSQL</productname> встроены функции хранения и "
"сравнения идентификаторов UUID, но нет внутренней функции генерирования "
"UUID, потому что не существует какого-то единственного алгоритма, "
"подходящего для всех приложений. Сгенерировать UUID можно с помощью "
"дополнительного модуля <xref linkend=\"uuid-ossp\"/>, в котором реализованы "
"несколько стандартных алгоритмов, а можно воспользоваться модулем <xref "
"linkend=\"pgcrypto\"/>, где тоже есть функция генерирования случайных UUID. "
"Кроме того, можно сделать это в клиентском приложении или в другой "
"библиотеке, подключённой на стороне сервера."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4154(title)
msgid "<acronym>XML</acronym> Type"
msgstr "Тип <acronym>XML</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4156(indexterm)
msgid "<primary>XML</primary>"
msgstr "<primary>XML</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4160(para)
msgid ""
"The <type>xml</type> data type can be used to store XML data. Its advantage "
"over storing XML data in a <type>text</type> field is that it checks the "
"input values for well-formedness, and there are support functions to perform "
"type-safe operations on it; see <xref linkend=\"functions-xml\"/>. Use of "
"this data type requires the installation to have been built with "
"<command>configure --with-libxml</command>."
msgstr ""
"Тип <type>xml</type> предназначен для хранения XML-данных. Его преимущество "
"по сравнению с обычным типом <type>text</type> в том, что он проверяет "
"вводимые значения на допустимость по правилам XML и для работы с ним есть "
"типобезопасные функции; см. <xref remap=\"4\" linkend=\"functions-xml\"/>. "
"Для использования этого типа дистрибутив должен быть скомпилирован в "
"конфигурации <command>configure --with-libxml</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4170(para)
msgid ""
"The <type>xml</type> type can store well-formed <quote>documents</quote>, as "
"defined by the XML standard, as well as <quote>content</quote> fragments, "
"which are defined by the production <literal>XMLDecl? content</literal> in "
"the XML standard. Roughly, this means that content fragments can have more "
"than one top-level element or character node. The expression "
"<literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal> can be "
"used to evaluate whether a particular <type>xml</type> value is a full "
"document or only a content fragment."
msgstr ""
"Тип <type>xml</type> может сохранять правильно оформленные <quote>документы</"
"quote>, в соответствии со стандартом XML, а также фрагменты "
"<quote>содержимого</quote>, описанные как <literal>содержимое</literal> "
"элементов в стандарте XML. Другими словами, это означает, что фрагменты "
"содержимого могут содержать несколько элементов верхнего уровня или "
"текстовых узлов. Определить, является ли определённое значение типа "
"<type>xml</type> полным документом или фрагментом содержимого, позволяет "
"выражение <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4183(title)
msgid "Creating XML Values"
msgstr "Создание XML-значений"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4187(indexterm)
msgid "<primary>xmlparse</primary>"
msgstr "<primary>xmlparse</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4184(para)
msgid ""
"To produce a value of type <type>xml</type> from character data, use the "
"function <function>xmlparse</function>:<placeholder-1/> <synopsis>\n"
"XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)\n"
"</synopsis> Examples: <placeholder-2/> While this is the only way to convert "
"character strings into XML values according to the SQL standard, the "
"PostgreSQL-specific syntaxes: <placeholder-3/> can also be used."
msgstr ""
"Чтобы получить значение типа <type>xml</type> из текстовой строки, "
"используйте функцию <function>xmlparse</function>:<placeholder-1/> "
"<synopsis>\n"
"XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)\n"
"</synopsis> Примеры: <placeholder-2/> Хотя в стандарте SQL описан только "
"один способ преобразования текстовых строк в XML-значения, специфический "
"синтаксис PostgreSQL: <placeholder-3/> тоже допустим."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4209(indexterm)
msgid "<primary>DTD</primary>"
msgstr "<primary>DTD</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4206(para)
msgid ""
"The <type>xml</type> type does not validate input values against a document "
"type declaration (DTD),<placeholder-1/> even when the input value specifies "
"a DTD. There is also currently no built-in support for validating against "
"other XML schema languages such as XML Schema."
msgstr ""
"Тип <type>xml</type> не проверяет вводимые значения по схеме DTD (Document "
"Type Declaration, Объявления типа документа),<placeholder-1/> даже если в "
"них присутствуют ссылка на DTD. В настоящее время в <productname>PostgreSQL</"
"productname> также нет встроенной поддержки других разновидностей схем, "
"например XML Schema."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4218(indexterm)
msgid "<primary>xmlserialize</primary>"
msgstr "<primary>xmlserialize</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4215(para)
msgid ""
"The inverse operation, producing a character string value from <type>xml</"
"type>, uses the function <function>xmlserialize</function>:<placeholder-1/> "
"<synopsis>\n"
"XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS "
"<replaceable>type</replaceable> )\n"
"</synopsis> <replaceable>type</replaceable> can be <type>character</type>, "
"<type>character varying</type>, or <type>text</type> (or an alias for one of "
"those). Again, according to the SQL standard, this is the only way to "
"convert between type <type>xml</type> and character types, but PostgreSQL "
"also allows you to simply cast the value."
msgstr ""
"Обратная операция, получение текстовой строки из <type>xml</type>, "
"выполняется с помощью функции <function>xmlserialize</function>:"
"<placeholder-1/> <synopsis>\n"
"XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>значение</replaceable> AS "
"<replaceable>тип</replaceable> )\n"
"</synopsis> Здесь допустимый <replaceable>тип</replaceable> &mdash; "
"<type>character</type>, <type>character varying</type> или <type>text</type> "
"(или их псевдонимы). И в данном случае стандарт SQL предусматривает только "
"один способ преобразования <type>xml</type> в тип текстовых строк, но "
"PostgreSQL позволяет просто привести значение к нужному типу."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4236(indexterm)
msgid "<primary>XML option</primary>"
msgstr "<primary>XML option</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4230(para)
msgid ""
"When a character string value is cast to or from type <type>xml</type> "
"without going through <type>XMLPARSE</type> or <type>XMLSERIALIZE</type>, "
"respectively, the choice of <literal>DOCUMENT</literal> versus "
"<literal>CONTENT</literal> is determined by the <quote>XML option</quote> "
"<placeholder-1/> session configuration parameter, which can be set using the "
"standard command: <synopsis>\n"
"SET XML OPTION { DOCUMENT | CONTENT };\n"
"</synopsis> or the more PostgreSQL-like syntax <synopsis>\n"
"SET xmloption TO { DOCUMENT | CONTENT };\n"
"</synopsis> The default is <literal>CONTENT</literal>, so all forms of XML "
"data are allowed."
msgstr ""
"При преобразовании текстовой строки в тип <type>xml</type> или наоборот без "
"использования функций <type>XMLPARSE</type> и <type>XMLSERIALIZE</type>, "
"выбор режима <literal>DOCUMENT</literal> или <literal>CONTENT</literal> "
"определяется параметром конфигурации сеанса <quote>XML option</"
"quote><placeholder-1/>, установить который можно следующей стандартной "
"командой: <synopsis>\n"
"SET XML OPTION { DOCUMENT | CONTENT };\n"
"</synopsis> или такой командой в духе PostgreSQL:<synopsis>\n"
"SET xmloption TO { DOCUMENT | CONTENT };\n"
"</synopsis> По умолчанию этот параметр имеет значение <literal>CONTENT</"
"literal>, так что допускаются все формы XML-данных."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4251(para)
msgid ""
"With the default XML option setting, you cannot directly cast character "
"strings to type <type>xml</type> if they contain a document type "
"declaration, because the definition of XML content fragment does not accept "
"them. If you need to do that, either use <literal>XMLPARSE</literal> or "
"change the XML option."
msgstr ""
"Когда параметр XML option имеет значение по умолчанию, текстовые строки "
"нельзя напрямую привести к типу <type>xml</type>, если они содержат "
"объявление типа документа, так как такие объявления не допускаются во "
"фрагментах. Для выполнения преобразования в таких случаях следует "
"использовать <literal>XMLPARSE</literal> или изменить параметр XML option."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4263(title)
msgid "Encoding Handling"
msgstr "Обработка кодировки"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4264(para)
msgid ""
"Care must be taken when dealing with multiple character encodings on the "
"client, server, and in the XML data passed through them. When using the text "
"mode to pass queries to the server and query results to the client (which is "
"the normal mode), PostgreSQL converts all character data passed between the "
"client and the server and vice versa to the character encoding of the "
"respective end; see <xref linkend=\"multibyte\"/>. This includes string "
"representations of XML values, such as in the above examples. This would "
"ordinarily mean that encoding declarations contained in XML data can become "
"invalid as the character data is converted to other encodings while "
"traveling between client and server, because the embedded encoding "
"declaration is not changed. To cope with this behavior, encoding "
"declarations contained in character strings presented for input to the "
"<type>xml</type> type are <emphasis>ignored</emphasis>, and content is "
"assumed to be in the current server encoding. Consequently, for correct "
"processing, character strings of XML data must be sent from the client in "
"the current client encoding. It is the responsibility of the client to "
"either convert documents to the current client encoding before sending them "
"to the server, or to adjust the client encoding appropriately. On output, "
"values of type <type>xml</type> will not have an encoding declaration, and "
"clients should assume all data is in the current client encoding."
msgstr ""
"Если на стороне сервера и клиента и в XML-данных используются разные "
"кодировки символов, с этим могут возникать проблемы. Когда запросы "
"передаются на сервер, а их результаты возвращаются клиенту в обычном "
"текстовом режиме, PostgreSQL преобразует все передаваемые текстовые данные в "
"кодировку для соответствующей стороны; см. <xref remap=\"4\" linkend="
"\"multibyte\"/>. В том числе это происходит и со строковыми представлениями "
"XML-данных, подобными тем, что показаны в предыдущих примерах. Обычно это "
"означает, что объявления кодировки, содержащиеся в XML-данных, могут не "
"соответствовать действительности, когда текстовая строка преобразуется из "
"одной кодировки в другую при передаче данных между клиентом и сервером, так "
"как подобные включённые в данные объявления не будут изменены автоматически. "
"Для решения этой проблемы объявления кодировки, содержащиеся в текстовых "
"строках, вводимых в тип <type>xml</type>, просто <emphasis>игнорируются</"
"emphasis> и предполагается, что XML-содержимое представлено в текущей "
"кодировке сервера. Как следствие, для правильной обработки таких строк с XML-"
"данными клиент должен передавать их в своей текущей кодировке. Для сервера "
"не важно, будет ли клиент для этого преобразовывать документы в свою "
"кодировку, или изменит её, прежде чем передавать ему данные. При выводе "
"значения типа <type>xml</type> не содержат объявления кодировки, а клиент "
"должен предполагать, что все данные поступают в его текущей кодировке."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4291(para)
msgid ""
"When using binary mode to pass query parameters to the server and query "
"results back to the client, no encoding conversion is performed, so the "
"situation is different. In this case, an encoding declaration in the XML "
"data will be observed, and if it is absent, the data will be assumed to be "
"in UTF-8 (as required by the XML standard; note that PostgreSQL does not "
"support UTF-16). On output, data will have an encoding declaration "
"specifying the client encoding, unless the client encoding is UTF-8, in "
"which case it will be omitted."
msgstr ""
"Если параметры запроса передаются на сервер и он возвращает результаты "
"клиенту в двоичном режиме, кодировка символов не преобразуется, так что "
"возникает другая ситуация. В этом случае объявление кодировки в XML "
"принимается во внимание, а если его нет, то предполагается, что данные "
"закодированы в UTF-8 (это соответствует стандарту XML; заметьте, что "
"PostgreSQL не поддерживает UTF-16). При выводе в данные будет добавлено "
"объявление кодировки, выбранной на стороне клиента (но если это UTF-8, "
"объявление будет опущено)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4303(para)
msgid ""
"Needless to say, processing XML data with PostgreSQL will be less error-"
"prone and more efficient if the XML data encoding, client encoding, and "
"server encoding are the same. Since XML data is internally processed in "
"UTF-8, computations will be most efficient if the server encoding is also "
"UTF-8."
msgstr ""
"Само собой, XML-данные в PostgreSQL будут обрабатываться гораздо "
"эффективнее, когда и в XML-данных, и на стороне клиента, и на стороне "
"сервера используется одна кодировка. Так как внутри XML-данные "
"представляются в UTF-8, оптимальный вариант, когда на сервере также выбрана "
"кодировка UTF-8."

#. +> REL_10
#: datatype.xml:4312(para)
msgid ""
"Some XML-related functions may not work at all on non-ASCII data when the "
"server encoding is not UTF-8. This is known to be an issue for "
"<function>xmltable()</function> and <function>xpath()</function> in "
"particular."
msgstr ""
"Некоторые XML-функции могут вовсе не работать с данными не-ASCII, если "
"кодировка сервера не UTF-8. В частности, это известная особенность функций "
"<function>xmltable()</function> и <function>xpath()</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4321(title)
msgid "Accessing XML Values"
msgstr "Обращение к XML-значениям"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4323(para)
msgid ""
"The <type>xml</type> data type is unusual in that it does not provide any "
"comparison operators. This is because there is no well-defined and "
"universally useful comparison algorithm for XML data. One consequence of "
"this is that you cannot retrieve rows by comparing an <type>xml</type> "
"column against a search value. XML values should therefore typically be "
"accompanied by a separate key field such as an ID. An alternative solution "
"for comparing XML values is to convert them to character strings first, but "
"note that character string comparison has little to do with a useful XML "
"comparison method."
msgstr ""
"Тип <type>xml</type> отличается от других тем, что для него не определены "
"никакие операторы сравнения, так как чётко определённого и универсального "
"алгоритма сравнения XML-данных не существует. Одно из следствий этого "
"&mdash; нельзя отфильтровать строки таблицы, сравнив столбец <type>xml</"
"type> с искомым значением. Поэтому обычно XML-значения должны дополняться "
"отдельным ключевым полем, например ID. Можно также сравнивать XML-значения, "
"преобразовав их сначала в текстовые строки, но заметьте, что с учётом "
"специфики XML-данных этот метод практически бесполезен."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4336(para)
msgid ""
"Since there are no comparison operators for the <type>xml</type> data type, "
"it is not possible to create an index directly on a column of this type. If "
"speedy searches in XML data are desired, possible workarounds include "
"casting the expression to a character string type and indexing that, or "
"indexing an XPath expression. Of course, the actual query would have to be "
"adjusted to search by the indexed expression."
msgstr ""
"Из-за отсутствия операторов сравнения для типа <type>xml</type>, для столбца "
"этого типа также нельзя создать индекс. Поэтому, когда требуется быстрый "
"поиск в XML данных, обойти это ограничение можно, приведя данные к типу "
"текстовой строки и проиндексировав эти строки, либо проиндексировав "
"выражение XPath. Конечно сам запрос при этом следует изменить, чтобы поиск "
"выполнялся по индексированному выражению."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4346(para)
msgid ""
"The text-search functionality in PostgreSQL can also be used to speed up "
"full-document searches of XML data. The necessary preprocessing support is, "
"however, not yet available in the PostgreSQL distribution."
msgstr ""
"Для ускорения поиска в XML-данных также можно использовать функции "
"полнотекстового поиска в PostgreSQL. Однако это требует определённой "
"подготовки данных, что дистрибутив PostgreSQL пока не поддерживает."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4364(title) datatype.xml:4477(title)
msgid "Object Identifier Types"
msgstr "Идентификаторы объектов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4366(indexterm)
msgid "<primary>object identifier</primary> <secondary>data type</secondary>"
msgstr ""
"<primary>идентификатор объекта</primary> <secondary>тип данных</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4371(indexterm)
msgid "<primary>oid</primary>"
msgstr "<primary>oid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4375(indexterm)
msgid "<primary>regproc</primary>"
msgstr "<primary>regproc</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4379(indexterm)
msgid "<primary>regprocedure</primary>"
msgstr "<primary>regprocedure</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4383(indexterm)
msgid "<primary>regoper</primary>"
msgstr "<primary>regoper</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4387(indexterm)
msgid "<primary>regoperator</primary>"
msgstr "<primary>regoperator</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4391(indexterm)
msgid "<primary>regclass</primary>"
msgstr "<primary>regclass</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4395(indexterm)
msgid "<primary>regtype</primary>"
msgstr "<primary>regtype</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4399(indexterm)
msgid "<primary>regconfig</primary>"
msgstr "<primary>regconfig</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4403(indexterm)
msgid "<primary>regdictionary</primary>"
msgstr "<primary>regdictionary</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4407(indexterm)
msgid "<primary>xid</primary>"
msgstr "<primary>xid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4411(indexterm)
msgid "<primary>cid</primary>"
msgstr "<primary>cid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4415(indexterm)
msgid "<primary>tid</primary>"
msgstr "<primary>tid</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4419(para)
msgid ""
"Object identifiers (OIDs) are used internally by <productname>PostgreSQL</"
"productname> as primary keys for various system tables. OIDs are not added "
"to user-created tables, unless <literal>WITH OIDS</literal> is specified "
"when the table is created, or the <xref linkend=\"guc-default-with-oids\"/> "
"configuration variable is enabled. Type <type>oid</type> represents an "
"object identifier. There are also several alias types for <type>oid</type>: "
"<type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, "
"<type>regoperator</type>, <type>regclass</type>, <type>regtype</type>, "
"<type>regrole</type>, <type>regnamespace</type>, <type>regconfig</type>, and "
"<type>regdictionary</type>. <xref linkend=\"datatype-oid-table\"/> shows an "
"overview."
msgstr ""
"Идентификатор объекта (Object Identifier, OID) используется внутри "
"<productname>PostgreSQL</productname> в качестве первичного ключа различных "
"системных таблиц. В пользовательские таблицы столбец OID добавляется, только "
"если при создании таблицы указывается <literal>WITH OIDS</literal> или "
"включён параметр конфигурации <xref linkend=\"guc-default-with-oids\"/>. "
"Идентификатор объекта представляется в типе <type>oid</type>. Также для типа "
"<type>oid</type> определены следующие псевдонимы: <type>regproc</type>, "
"<type>regprocedure</type>, <type>regoper</type>, <type>regoperator</type>, "
"<type>regclass</type>, <type>regtype</type>, <type>regrole</type>, "
"<type>regnamespace</type>, <type>regconfig</type> и <type>regdictionary</"
"type>. Обзор этих типов приведён в <xref remap=\"6\" linkend=\"datatype-oid-"
"table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4434(para)
msgid ""
"The <type>oid</type> type is currently implemented as an unsigned four-byte "
"integer. Therefore, it is not large enough to provide database-wide "
"uniqueness in large databases, or even in large individual tables. So, using "
"a user-created table's OID column as a primary key is discouraged. OIDs are "
"best used only for references to system tables."
msgstr ""
"В настоящее время тип <type>oid</type> реализован как четырёхбайтное целое. "
"Таким образом оно может быть недостаточно большим для обеспечения "
"уникальности в базе данных или даже в отдельных больших таблицах. Поэтому в "
"пользовательских таблицах использовать столбец типа OID в качестве "
"первичного ключа не рекомендуется. Лучше всего ограничить применение этого "
"типа обращениями к системным таблицам."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4443(para)
msgid ""
"The <type>oid</type> type itself has few operations beyond comparison. It "
"can be cast to integer, however, and then manipulated using the standard "
"integer operators. (Beware of possible signed-versus-unsigned confusion if "
"you do this.)"
msgstr ""
"Для самого типа <type>oid</type> помимо сравнения определены всего несколько "
"операторов. Однако его можно привести к целому и затем задействовать в "
"обычных целочисленных вычислениях. (При этом следует опасаться путаницы со "
"знаковыми/беззнаковыми значениями.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4458(programlisting)
#, no-wrap
msgid "SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;"
msgstr "SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4462(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM pg_attribute\n"
"  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');"
msgstr ""
"SELECT * FROM pg_attribute\n"
"  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4450(para)
msgid ""
"The OID alias types have no operations of their own except for specialized "
"input and output routines. These routines are able to accept and display "
"symbolic names for system objects, rather than the raw numeric value that "
"type <type>oid</type> would use. The alias types allow simplified lookup of "
"OID values for objects. For example, to examine the "
"<structname>pg_attribute</structname> rows related to a table "
"<literal>mytable</literal>, one could write: <placeholder-1/> rather than: "
"<placeholder-2/> While that doesn't look all that bad by itself, it's still "
"oversimplified. A far more complicated sub-select would be needed to select "
"the right OID if there are multiple tables named <literal>mytable</literal> "
"in different schemas. The <type>regclass</type> input converter handles the "
"table lookup according to the schema path setting, and so it does the "
"<quote>right thing</quote> automatically. Similarly, casting a table's OID "
"to <type>regclass</type> is handy for symbolic display of a numeric OID."
msgstr ""
"Типы-псевдонимы OID сами по себе не вводят новых операций и отличаются "
"только специализированными функциями ввода/вывода. Эти функции могут "
"принимать и выводить не просто числовые значения, как тип <type>oid</type>, "
"а символические имена системных объектов. Эти типы позволяют упростить поиск "
"объектов по значениям OID. Например, чтобы выбрать из "
"<structname>pg_attribute</structname> строки, относящиеся к таблице "
"<literal>mytable</literal>, можно написать: <placeholder-1/> вместо: "
"<placeholder-2/> Хотя второй вариант выглядит не таким уж плохим, но это "
"лишь очень простой запрос. Если же потребуется выбрать правильный OID, когда "
"таблица <literal>mytable</literal> есть в нескольких схемах, вложенный "
"подзапрос будет гораздо сложнее. Преобразователь вводимого значения типа "
"<type>regclass</type> находит таблицу согласно заданному пути поиска схем, "
"так что он делает <quote>всё правильно</quote> автоматически. Аналогично, "
"приведя идентификатор таблицы к типу <type>regclass</type>, можно получить "
"символическое представление числового кода."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4482(entry)
msgid "References"
msgstr "Ссылки"

# msgid "References"
# msgstr "Применяется"
#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4484(entry)
msgid "Value Example"
msgstr "Пример значения"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4491(type)
msgid "oid"
msgstr "oid"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4492(entry)
msgctxt "entry"
msgid "any"
msgstr "any"

# msgid "any"
# msgstr "везде"
#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4493(entry)
msgid "numeric object identifier"
msgstr "числовой идентификатор объекта"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4494(literal)
msgid "564182"
msgstr "564182"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4498(type)
msgid "regproc"
msgstr "regproc"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4499(structname) datatype.xml:4506(structname)
msgid "pg_proc"
msgstr "pg_proc"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4500(entry)
msgid "function name"
msgstr "имя функции"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4501(literal)
msgid "sum"
msgstr "sum"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4505(type)
msgid "regprocedure"
msgstr "regprocedure"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4507(entry)
msgid "function with argument types"
msgstr "функция с типами аргументов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4508(literal)
msgid "sum(int4)"
msgstr "sum(int4)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4512(type)
msgid "regoper"
msgstr "regoper"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4513(structname) datatype.xml:4520(structname)
msgid "pg_operator"
msgstr "pg_operator"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4514(entry)
msgid "operator name"
msgstr "имя оператора"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4515(literal)
msgid "+"
msgstr "+"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4519(type)
msgid "regoperator"
msgstr "regoperator"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4521(entry)
msgid "operator with argument types"
msgstr "оператор с типами аргументов"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4522(entry)
msgid ""
"<literal>*(integer,integer)</literal> or <literal>-(NONE,integer)</literal>"
msgstr ""
"<literal>*(integer,integer)</literal> или <literal>-(NONE,integer)</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4526(type)
msgid "regclass"
msgstr "regclass"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4527(structname)
msgid "pg_class"
msgstr "pg_class"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4528(entry)
msgid "relation name"
msgstr "имя отношения"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4529(literal)
msgctxt "literal"
msgid "pg_type"
msgstr "pg_type"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4533(type)
msgid "regtype"
msgstr "regtype"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4534(structname)
msgctxt "structname"
msgid "pg_type"
msgstr "pg_type"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4535(entry)
msgid "data type name"
msgstr "имя типа данных"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4536(literal)
msgctxt "literal"
msgid "integer"
msgstr "integer"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4540(type)
msgid "regrole"
msgstr "regrole"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4541(structname)
msgid "pg_authid"
msgstr "pg_authid"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4542(entry)
msgid "role name"
msgstr "имя роли"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4543(literal)
msgid "smithee"
msgstr "smithee"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4547(type)
msgid "regnamespace"
msgstr "regnamespace"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4548(structname)
msgid "pg_namespace"
msgstr "pg_namespace"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4549(entry)
msgid "namespace name"
msgstr "пространство имён"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4550(literal)
msgid "pg_catalog"
msgstr "pg_catalog"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4554(type)
msgid "regconfig"
msgstr "regconfig"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4555(structname)
msgid "pg_ts_config"
msgstr "pg_ts_config"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4556(entry)
msgid "text search configuration"
msgstr "конфигурация текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4557(literal)
msgid "english"
msgstr "english"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4561(type)
msgid "regdictionary"
msgstr "regdictionary"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4562(structname)
msgid "pg_ts_dict"
msgstr "pg_ts_dict"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4563(entry)
msgid "text search dictionary"
msgstr "словарь текстового поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4564(literal)
msgid "simple"
msgstr "simple"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4570(para)
msgid ""
"All of the OID alias types for objects grouped by namespace accept schema-"
"qualified names, and will display schema-qualified names on output if the "
"object would not be found in the current search path without being "
"qualified. The <type>regproc</type> and <type>regoper</type> alias types "
"will only accept input names that are unique (not overloaded), so they are "
"of limited use; for most uses <type>regprocedure</type> or "
"<type>regoperator</type> are more appropriate. For <type>regoperator</type>, "
"unary operators are identified by writing <literal>NONE</literal> for the "
"unused operand."
msgstr ""
"Все типы псевдонимов OID для объектов, сгруппированных в пространство имён, "
"принимают имена, дополненные именем схемы, и выводят имена со схемой, если "
"данный объект нельзя будет найти в текущем пути поиска без имени схемы. Типы "
"<type>regproc</type> и <type>regoper</type> принимают только уникальные "
"вводимые имена (не перегруженные), что ограничивает их применимость; в "
"большинстве случаев лучше использовать <type>regprocedure</type> или "
"<type>regoperator</type>. Для типа <type>regoperator</type> в записи "
"унарного оператора неиспользуемый операнд заменяется словом <literal>NONE</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4583(para)
msgid ""
"An additional property of most of the OID alias types is the creation of "
"dependencies. If a constant of one of these types appears in a stored "
"expression (such as a column default expression or view), it creates a "
"dependency on the referenced object. For example, if a column has a default "
"expression <literal>nextval('my_seq'::regclass)</literal>, "
"<productname>PostgreSQL</productname> understands that the default "
"expression depends on the sequence <literal>my_seq</literal>; the system "
"will not let the sequence be dropped without first removing the default "
"expression. <type>regrole</type> is the only exception for the property. "
"Constants of this type are not allowed in such expressions."
msgstr ""
"Дополнительным свойством большинства типов псевдонимов OID является "
"образование зависимостей. Когда в сохранённом выражении фигурирует константа "
"одного из этих типов (например, в представлении или в значении столбца по "
"умолчанию), это создаёт зависимость от целевого объекта. Например, если "
"значение по умолчанию определяется выражением <literal>nextval('my_seq'::"
"regclass)</literal>, <productname>PostgreSQL</productname> понимает, что это "
"выражение зависит от последовательности <literal>my_seq</literal>, и не "
"позволит удалить последовательность раньше, чем будет удалено это выражение. "
"Единственным ограничением является тип <type>regrole</type>. Константы этого "
"типа в таких выражениях не допускаются."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4599(para)
msgid ""
"The OID alias types do not completely follow transaction isolation rules. "
"The planner also treats them as simple constants, which may result in sub-"
"optimal planning."
msgstr ""
"Типы псевдонимов OID не полностью следуют правилам изоляции транзакций. "
"Планировщик тоже воспринимает их как простые константы, что может привести к "
"неоптимальному планированию запросов."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4606(para)
msgid ""
"Another identifier type used by the system is <type>xid</type>, or "
"transaction (abbreviated <abbrev>xact</abbrev>) identifier. This is the data "
"type of the system columns <structfield>xmin</structfield> and "
"<structfield>xmax</structfield>. Transaction identifiers are 32-bit "
"quantities."
msgstr ""
"Есть ещё один тип системных идентификаторов, <type>xid</type>, "
"представляющий идентификатор транзакции (сокращённо <abbrev>xact</abbrev>). "
"Этот тип имеют системные столбцы <structfield>xmin</structfield> и "
"<structfield>xmax</structfield>. Идентификаторы транзакций определяются 32-"
"битными числами."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4612(para)
msgid ""
"A third identifier type used by the system is <type>cid</type>, or command "
"identifier. This is the data type of the system columns <structfield>cmin</"
"structfield> and <structfield>cmax</structfield>. Command identifiers are "
"also 32-bit quantities."
msgstr ""
"Третий тип идентификаторов, используемых в системе, &mdash; <type>cid</"
"type>, идентификатор команды (command identifier). Этот тип данных имеют "
"системные столбцы <structfield>cmin</structfield> и <structfield>cmax</"
"structfield>. Идентификаторы команд &mdash; это тоже 32-битные числа."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4618(para)
msgid ""
"A final identifier type used by the system is <type>tid</type>, or tuple "
"identifier (row identifier). This is the data type of the system column "
"<structfield>ctid</structfield>. A tuple ID is a pair (block number, tuple "
"index within block) that identifies the physical location of the row within "
"its table."
msgstr ""
"И наконец, последний тип системных идентификаторов &mdash; <type>tid</type>, "
"идентификатор строки/кортежа (tuple identifier). Этот тип данных имеет "
"системный столбец <structfield>ctid</structfield>. Идентификатор кортежа "
"представляет собой пару (из номера блока и индекса кортежа в блоке), "
"идентифицирующую физическое расположение строки в таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4626(para)
msgid ""
"(The system columns are further explained in <xref linkend=\"ddl-system-"
"columns\"/>.)"
msgstr ""
"(Подробнее о системных столбцах рассказывается в <xref remap=\"6\" linkend="
"\"ddl-system-columns\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4633(acronym)
msgid "pg_lsn Type"
msgstr "Тип pg_lsn"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4635(indexterm)
msgid "<primary>pg_lsn</primary>"
msgstr "<primary>pg_lsn</primary>"

#. +> REL_10
#: datatype.xml:4639(para)
msgid ""
"The <type>pg_lsn</type> data type can be used to store LSN (Log Sequence "
"Number) data which is a pointer to a location in the WAL. This type is a "
"representation of <type>XLogRecPtr</type> and an internal system type of "
"<productname>PostgreSQL</productname>."
msgstr ""
"Тип данных <type>pg_lsn</type> может применяться для хранения значения LSN "
"(последовательный номер в журнале, Log Sequence Number), которое "
"представляет собой указатель на позицию в журнале WAL. Этот тип содержит "
"<type>XLogRecPtr</type> и является внутренним системным типом "
"<productname>PostgreSQL</productname>."

#. +> REL_10
#: datatype.xml:4646(para)
msgid ""
"Internally, an LSN is a 64-bit integer, representing a byte position in the "
"write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 "
"digits each, separated by a slash; for example, <literal>16/B374D848</"
"literal>. The <type>pg_lsn</type> type supports the standard comparison "
"operators, like <literal>=</literal> and <literal>&gt;</literal>. Two LSNs "
"can be subtracted using the <literal>-</literal> operator; the result is the "
"number of bytes separating those write-ahead log locations."
msgstr ""
"Технически LSN &mdash; это 64-битное целое, представляющее байтовое смещение "
"в потоке журнала предзаписи. Он выводится в виде двух шестнадцатеричных "
"чисел до 8 цифр каждое, через косую черту, например: <literal>16/B374D848</"
"literal>. Тип <type>pg_lsn</type> поддерживает стандартные операторы "
"сравнения, такие как <literal>=</literal> и <literal>&gt;</literal>. Можно "
"также вычесть один LSN из другого с помощью оператора <literal>-</literal>; "
"результатом будет число байт между этими двумя позициями в журнале "
"предзаписи."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4659(title) datatype.xml:4751(title)
msgid "Pseudo-Types"
msgstr "Псевдотипы"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4661(indexterm)
msgid "<primary>record</primary>"
msgstr "<primary>record</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4665(indexterm)
msgid "<primary>any</primary>"
msgstr "<primary>any</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4669(indexterm)
msgid "<primary>anyelement</primary>"
msgstr "<primary>anyelement</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4673(indexterm)
msgid "<primary>anyarray</primary>"
msgstr "<primary>anyarray</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4677(indexterm)
msgid "<primary>anynonarray</primary>"
msgstr "<primary>anynonarray</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4681(indexterm)
msgid "<primary>anyenum</primary>"
msgstr "<primary>anyenum</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4685(indexterm)
msgid "<primary>anyrange</primary>"
msgstr "<primary>anyrange</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4689(indexterm)
msgid "<primary>void</primary>"
msgstr "<primary>void</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4693(indexterm)
msgid "<primary>trigger</primary>"
msgstr "<primary>trigger</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4697(indexterm)
msgid "<primary>event_trigger</primary>"
msgstr "<primary>event_trigger</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4701(indexterm)
msgid "<primary>pg_ddl_command</primary>"
msgstr "<primary>pg_ddl_command</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4705(indexterm)
msgid "<primary>language_handler</primary>"
msgstr "<primary>language_handler</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4709(indexterm)
msgid "<primary>fdw_handler</primary>"
msgstr "<primary>fdw_handler</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4713(indexterm)
msgid "<primary>index_am_handler</primary>"
msgstr "<primary>index_am_handler</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4717(indexterm)
msgid "<primary>tsm_handler</primary>"
msgstr "<primary>tsm_handler</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4721(indexterm)
msgid "<primary>cstring</primary>"
msgstr "<primary>cstring</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4725(indexterm)
msgid "<primary>internal</primary>"
msgstr "<primary>internal</primary>"

#. +> REL_10
#: datatype.xml:4729(indexterm)
msgid "<primary>unknown</primary>"
msgstr "<primary>unknown</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4733(indexterm)
msgid "<primary>opaque</primary>"
msgstr "<primary>opaque</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4737(para)
msgid ""
"The <productname>PostgreSQL</productname> type system contains a number of "
"special-purpose entries that are collectively called <firstterm>pseudo-"
"types</firstterm>. A pseudo-type cannot be used as a column data type, but "
"it can be used to declare a function's argument or result type. Each of the "
"available pseudo-types is useful in situations where a function's behavior "
"does not correspond to simply taking or returning a value of a specific "
"<acronym>SQL</acronym> data type. <xref linkend=\"datatype-pseudotypes-table"
"\"/> lists the existing pseudo-types."
msgstr ""
"В систему типов <productname>PostgreSQL</productname> включены несколько "
"специальных элементов, которые в совокупности называются "
"<firstterm>псевдотипами</firstterm>. Псевдотип нельзя использовать в "
"качестве типа данных столбца, но можно объявить функцию с аргументом или "
"результатом такого типа. Каждый из существующих псевдотипов полезен в "
"ситуациях, когда характер функции не позволяет просто получить или вернуть "
"определённый тип данных <acronym>SQL</acronym>. Все существующие псевдотипы "
"перечислены в <xref remap=\"6\" linkend=\"datatype-pseudotypes-table\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4762(type)
msgctxt "type"
msgid "any"
msgstr "any"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4763(entry)
msgid "Indicates that a function accepts any input data type."
msgstr "Указывает, что функция принимает любой вводимый тип данных."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4767(type)
msgid "anyelement"
msgstr "anyelement"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4768(entry)
msgid ""
"Indicates that a function accepts any data type (see <xref linkend=\"extend-"
"types-polymorphic\"/>)."
msgstr ""
"Указывает, что функция принимает любой тип данных (см. <xref remap=\"4\" "
"linkend=\"extend-types-polymorphic\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4773(type)
msgid "anyarray"
msgstr "anyarray"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4774(entry)
msgid ""
"Indicates that a function accepts any array data type (see <xref linkend="
"\"extend-types-polymorphic\"/>)."
msgstr ""
"Указывает, что функция принимает любой тип массива (см. <xref remap=\"4\" "
"linkend=\"extend-types-polymorphic\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4779(type)
msgid "anynonarray"
msgstr "anynonarray"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4780(entry)
msgid ""
"Indicates that a function accepts any non-array data type (see <xref linkend="
"\"extend-types-polymorphic\"/>)."
msgstr ""
"Указывает, что функция принимает любой тип данных, кроме массивов (см. <xref "
"remap=\"4\" linkend=\"extend-types-polymorphic\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4785(type)
msgid "anyenum"
msgstr "anyenum"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4786(entry)
msgid ""
"Indicates that a function accepts any enum data type (see <xref linkend="
"\"extend-types-polymorphic\"/> and <xref linkend=\"datatype-enum\"/>)."
msgstr ""
"Указывает, что функция принимает любое перечисление (см. <xref remap=\"4\" "
"linkend=\"extend-types-polymorphic\"/> и <xref remap=\"4\" linkend="
"\"datatype-enum\"/>)."

#. +> REL9_6_3 REL9_6
#: datatype.xml:4786(entry)
msgid "An obsolete type name that formerly served all the above purposes."
msgstr ""
"Устаревший тип, который раньше использовался во всех вышеперечисленных "
"случаях."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4792(type)
msgid "anyrange"
msgstr "anyrange"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4793(entry)
msgid ""
"Indicates that a function accepts any range data type (see <xref linkend="
"\"extend-types-polymorphic\"/> and <xref linkend=\"rangetypes\"/>)."
msgstr ""
"Указывает, что функция принимает любой диапазонный тип данных (см. <xref "
"remap=\"4\" linkend=\"extend-types-polymorphic\"/> и <xref remap=\"4\" "
"linkend=\"rangetypes\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4799(type)
msgid "cstring"
msgstr "cstring"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4800(entry)
msgid ""
"Indicates that a function accepts or returns a null-terminated C string."
msgstr "Указывает, что функция принимает или возвращает строку в стиле C."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4804(type)
msgid "internal"
msgstr "internal"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4805(entry)
msgid ""
"Indicates that a function accepts or returns a server-internal data type."
msgstr ""
"Указывает, что функция принимает или возвращает внутренний серверный тип "
"данных."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4810(type)
msgid "language_handler"
msgstr "language_handler"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4811(entry)
msgid ""
"A procedural language call handler is declared to return "
"<type>language_handler</type>."
msgstr ""
"Обработчик процедурного языка объявляется как возвращающий тип "
"<type>language_handler</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4815(type)
msgid "fdw_handler"
msgstr "fdw_handler"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4816(entry)
msgid ""
"A foreign-data wrapper handler is declared to return <type>fdw_handler</"
"type>."
msgstr ""
"Обработчик обёртки сторонних данных объявляется как возвращающий тип "
"<type>fdw_handler</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4820(type)
msgid "index_am_handler"
msgstr "index_am_handler"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4821(entry)
msgid ""
"An index access method handler is declared to return <type>index_am_handler</"
"type>."
msgstr ""
"Обработчик метода доступа индекса объявляется как возвращающий тип "
"<type>index_am_handler</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4825(type)
msgid "tsm_handler"
msgstr "tsm_handler"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4826(entry)
msgid ""
"A tablesample method handler is declared to return <type>tsm_handler</type>."
msgstr ""
"Обработчик метода выборки из таблицы объявляется как возвращающий тип "
"<type>tsm_handler</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4830(type)
msgid "record"
msgstr "record"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4831(entry)
msgid "Identifies a function taking or returning an unspecified row type."
msgstr ""
"Указывает, что функция принимает или возвращает неопределённый тип строки."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4835(type)
msgid "trigger"
msgstr "trigger"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4836(entry)
msgid "A trigger function is declared to return <type>trigger.</type>"
msgstr ""
"Триггерная функция объявляется как возвращающая тип <type>trigger</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4840(type)
msgid "event_trigger"
msgstr "event_trigger"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4841(entry)
msgid ""
"An event trigger function is declared to return <type>event_trigger.</type>"
msgstr ""
"Функция событийного триггера объявляется как возвращающая тип "
"<type>event_trigger</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4845(type)
msgid "pg_ddl_command"
msgstr "pg_ddl_command"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4846(entry)
msgid ""
"Identifies a representation of DDL commands that is available to event "
"triggers."
msgstr "Обозначает представление команд DDL, доступное событийным триггерам."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4850(type)
msgid "void"
msgstr "void"

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4851(entry)
msgid "Indicates that a function returns no value."
msgstr "Указывает, что функция не возвращает значение."

#. +> REL_10
#: datatype.xml:4855(type)
msgid "unknown"
msgstr "unknown"

#. +> REL_10
#: datatype.xml:4856(entry)
msgid ""
"Identifies a not-yet-resolved type, e.g. of an undecorated string literal."
msgstr ""
"Обозначает ещё не распознанный тип, то есть раскрытое строковое значение."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4861(type)
msgid "opaque"
msgstr "opaque"

#. +> REL_10
#: datatype.xml:4862(entry)
msgid "An obsolete type name that formerly served many of the above purposes."
msgstr ""
"Устаревший тип, который раньше использовался во многих вышеперечисленных "
"случаях."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4869(para)
msgid ""
"Functions coded in C (whether built-in or dynamically loaded) can be "
"declared to accept or return any of these pseudo data types. It is up to the "
"function author to ensure that the function will behave safely when a pseudo-"
"type is used as an argument type."
msgstr ""
"Функции, написанные на языке C (встроенные или динамически загружаемые), "
"могут быть объявлены с параметрами или результатами любого из этих типов. "
"Ответственность за безопасное поведение функции с аргументами таких типов "
"ложится на разработчика функции."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4876(para)
msgid ""
"Functions coded in procedural languages can use pseudo-types only as allowed "
"by their implementation languages. At present most procedural languages "
"forbid use of a pseudo-type as an argument type, and allow only <type>void</"
"type> and <type>record</type> as a result type (plus <type>trigger</type> or "
"<type>event_trigger</type> when the function is used as a trigger or event "
"trigger). Some also support polymorphic functions using the types "
"<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, "
"<type>anyenum</type>, and <type>anyrange</type>."
msgstr ""
"Функции, написанные на процедурных языках, могут использовать псевдотипы, "
"только если это позволяет соответствующий язык. В настоящее время "
"большинство процедурных языков запрещают использовать псевдотипы в качестве "
"типа аргумента и позволяют использовать для результатов только типы "
"<type>void</type> и <type>record</type> (и <type>trigger</type> или "
"<type>event_trigger</type>, когда функция реализует триггер или событийный "
"триггер). Некоторые языки также поддерживают полиморфные функции с типами "
"<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, "
"<type>anyenum</type> и <type>anyrange</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:4888(para)
msgid ""
"The <type>internal</type> pseudo-type is used to declare functions that are "
"meant only to be called internally by the database system, and not by direct "
"invocation in an <acronym>SQL</acronym> query. If a function has at least "
"one <type>internal</type>-type argument then it cannot be called from "
"<acronym>SQL</acronym>. To preserve the type safety of this restriction it "
"is important to follow this coding rule: do not create any function that is "
"declared to return <type>internal</type> unless it has at least one "
"<type>internal</type> argument."
msgstr ""
"Псевдотип <type>internal</type> используется в объявлениях функций, "
"предназначенных только для внутреннего использования в СУБД, но не для "
"прямого вызова в запросах <acronym>SQL</acronym>. Если у функции есть как "
"хотя бы один аргумент типа <type>internal</type>, её нельзя будет вызывать "
"из <acronym>SQL</acronym>. Чтобы сохранить типобезопасность при таком "
"ограничении, следуйте важному правилу: не создавайте функцию, возвращающую "
"результат типа <type>internal</type>, если у неё нет ни одного аргумента "
"<type>internal</type>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: datatype.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: datatype.xml:740(para)
msgid ""
"In addition to ordinary numeric values, the floating-point types have "
"several special values: <literallayout>\n"
"<literal>Infinity</literal>\n"
"<literal>-Infinity</literal>\n"
"<literal>NaN</literal>\n"
"</literallayout> These represent the IEEE 754 special values "
"<quote>infinity</quote>, <quote>negative infinity</quote>, and <quote>not-a-"
"number</quote>, respectively. (On a machine whose floating-point arithmetic "
"does not follow IEEE 754, these values will probably not work as expected.) "
"When writing these values as constants in an SQL command, you must put "
"quotes around them, for example <literal>UPDATE table SET x = 'Infinity'</"
"literal>. On input, these strings are recognized in a case-insensitive "
"manner."
msgstr ""
"В дополнение к обычным числовым значениям типы с плавающей точкой могут "
"содержать следующие специальные значения: <literallayout>\n"
"<literal>Infinity</literal>\n"
"<literal>-Infinity</literal>\n"
"<literal>NaN</literal>\n"
"</literallayout> Они представляют особые значения, описанные в IEEE 754, "
"соответственно <quote>бесконечность</quote>, <quote>минус бесконечность</"
"quote> и <quote>не число</quote>. (На компьютерах, где арифметика с "
"плавающей точкой не соответствует стандарту IEEE 754, эти значения, "
"вероятно, не будут работать должным образом.) Записывая эти значения в виде "
"констант в команде SQL, их нужно заключать в апострофы, например так: "
"<literal>UPDATE table SET x = 'Infinity'</literal>. Регистр символов в этих "
"строках не важен."

#. +> REL9_6_3 REL9_6
#: datatype.xml:941(entry)
msgctxt "entry"
msgid "money"
msgstr "money"

#. +> REL9_6_3
#: datatype.xml:980(para)
msgid ""
"When a <type>money</type> value is divided by another <type>money</type> "
"value, the result is <type>double precision</type> (i.e., a pure number, not "
"money); the currency units cancel each other out in the division."
msgstr ""
"При делении значения типа <type>money</type> на другое значение <type>money</"
"type> получается результат типа <type>double precision</type> (т. е. обычное "
"число, не денежная сумма); денежные единицы при делении сокращаются."

#. +> REL9_6_3 REL9_6
#: datatype.xml:1584(entry) datatype.xml:1592(entry) datatype.xml:1608(entry)
#: datatype.xml:1616(entry) datatype.xml:1624(entry)
msgid "1 microsecond / 14 digits"
msgstr "1 микросекунда / 14 цифр"

#. +> REL9_6_3 REL9_6
#: datatype.xml:1613(entry)
msgid "times of day only, with time zone"
msgstr "только время суток (с часовым поясом)"

#. +> REL9_6_3 REL9_6
#: datatype.xml:1641(para)
msgid ""
"<type>time</type>, <type>timestamp</type>, and <type>interval</type> accept "
"an optional precision value <replaceable>p</replaceable> which specifies the "
"number of fractional digits retained in the seconds field. By default, there "
"is no explicit bound on precision. The allowed range of <replaceable>p</"
"replaceable> is from 0 to 6 for the <type>timestamp</type> and "
"<type>interval</type> types."
msgstr ""
"Типы <type>time</type>, <type>timestamp</type> и <type>interval</type> "
"принимают необязательное значение точности <replaceable>p</replaceable>, "
"определяющее, сколько знаков после запятой должно сохраняться в секундах. По "
"умолчанию точность не ограничивается. Для типов <type>timestamp</type> и "
"<type>interval</type> <replaceable>p</replaceable> может принимать значения "
"от 0 до 6."

#. +> REL9_6_3 REL9_6
#: datatype.xml:1652(para)
msgid ""
"When <type>timestamp</type> values are stored as eight-byte integers "
"(currently the default), microsecond precision is available over the full "
"range of values. When <type>timestamp</type> values are stored as double "
"precision floating-point numbers instead (a deprecated compile-time option), "
"the effective limit of precision might be less than 6. <type>timestamp</"
"type> values are stored as seconds before or after midnight 2000-01-01. When "
"<type>timestamp</type> values are implemented using floating-point numbers, "
"microsecond precision is achieved for dates within a few years of "
"2000-01-01, but the precision degrades for dates further away. Note that "
"using floating-point datetimes allows a larger range of <type>timestamp</"
"type> values to be represented than shown above: from 4713 BC up to 5874897 "
"AD."
msgstr ""
"Когда значения <type>timestamp</type> хранятся в восьмибайтных целых (сейчас "
"по умолчанию это так), на всём интервале значений обеспечивается точность в "
"микросекундах. Если же значения этого типа сохраняются в числах двойной "
"точности с плавающей точкой (устаревший вариант компиляции), фактический "
"предел точности может быть меньше 6. Значения <type>timestamp</type> "
"сохраняются в секундах до или после полуночи 1 января 2000 г. Когда при этом "
"используются числа с плавающей точкой, микросекундная точность достигается "
"для дат в пределах нескольких лет от этой даты, а при удалении от неё "
"точность теряется. Однако заметьте, что даты в числах с плавающей точкой "
"позволяют представить больший диапазон <type>timestamp</type>, чем было "
"показано выше: от 4713 до н. э. до 5874897 н. э."

#. +> REL9_6_3 REL9_6
#: datatype.xml:1668(para)
msgid ""
"The same compile-time option also determines whether <type>time</type> and "
"<type>interval</type> values are stored as floating-point numbers or eight-"
"byte integers. In the floating-point case, large <type>interval</type> "
"values degrade in precision as the size of the interval increases."
msgstr ""
"В зависимости от того же варианта компиляции, типы <type>time</type> и "
"<type>interval</type> могут сохраняться в виде чисел с плавающей точкой или "
"в восьмибайтных целых. В случае с плавающей точкой при больших значениях "
"<type>interval</type> точность уменьшается."

#. +> REL9_6_3 REL9_6
#: datatype.xml:1677(para)
msgid ""
"For the <type>time</type> types, the allowed range of <replaceable>p</"
"replaceable> is from 0 to 6 when eight-byte integer storage is used, or from "
"0 to 10 when floating-point storage is used."
msgstr ""
"Для типа <type>time</type> <replaceable>p</replaceable> может принимать "
"значения от 0 до 6 при хранении типа в восьмибайтном целом и от 0 до 10 при "
"хранении в числе с плавающей точкой."

#. +> REL9_6_3 REL9_6
#: datatype.xml:1750(para)
msgid ""
"Remember that any date or time literal input needs to be enclosed in single "
"quotes, like text strings. Refer to <xref linkend=\"sql-syntax-constants-"
"generic\"/> for more information. <acronym>SQL</acronym> requires the "
"following syntax <synopsis>\n"
"<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] "
"'<replaceable>value</replaceable>'\n"
"</synopsis> where <replaceable>p</replaceable> is an optional precision "
"specification giving the number of fractional digits in the seconds field. "
"Precision can be specified for <type>time</type>, <type>timestamp</type>, "
"and <type>interval</type> types. The allowed values are mentioned above. If "
"no precision is specified in a constant specification, it defaults to the "
"precision of the literal value."
msgstr ""
"Помните, что любые вводимые значения даты и времени нужно заключать в "
"апострофы, как текстовые строки. За дополнительной информацией обратитесь к "
"<xref remap=\"3\" linkend=\"sql-syntax-constants-generic\"/>. <acronym>SQL</"
"acronym> предусматривает следующий синтаксис: <synopsis>\n"
"<replaceable>тип</replaceable> [ (<replaceable>p</replaceable>) ] "
"'<replaceable>значение</replaceable>'\n"
"</synopsis>Здесь <replaceable>p</replaceable> &mdash; необязательное "
"указание точности, определяющее число знаков после точки в секундах. "
"Точность может быть определена для типов <type>time</type>, <type>timestamp</"
"type> и <type>interval</type> в пределах, описанных выше. Если в определении "
"константы точность не указана, она считается равной точности значения в "
"строке."

#. +> REL9_6_3 REL9_6
#: datatype.xml:3639(para)
msgid ""
"The essential difference between <type>inet</type> and <type>cidr</type> "
"data types is that <type>inet</type> accepts values with nonzero bits to the "
"right of the netmask, whereas <type>cidr</type> does not."
msgstr ""
"Существенным различием типов данных <type>inet</type> и <type>cidr</type> "
"является то, что <type>inet</type> принимает значения с ненулевыми битами "
"справа от маски сети, а <type>cidr</type> &mdash; нет."

#. +> REL9_6_3 REL9_6
#: datatype.xml:4246(para)
msgid ""
"Some XML-related functions may not work at all on non-ASCII data when the "
"server encoding is not UTF-8. This is known to be an issue for "
"<function>xpath()</function> in particular."
msgstr ""
"Некоторые XML-функции могут вовсе не работать с данными не-ASCII, если "
"кодировка сервера &mdash; не UTF-8. В частности, это известная особенность "
"функции <function>xpath()</function>."

#. +> REL9_6_3 REL9_6
#: datatype.xml:4573(para)
msgid ""
"The <type>pg_lsn</type> data type can be used to store LSN (Log Sequence "
"Number) data which is a pointer to a location in the XLOG. This type is a "
"representation of <type>XLogRecPtr</type> and an internal system type of "
"<productname>PostgreSQL</productname>."
msgstr ""
"Тип данных <type>pg_lsn</type> может применяться для хранения значения LSN "
"(последовательный номер в журнале, Log Sequence Number), которое "
"представляет собой указатель на позицию в журнале транзакций (XLOG). Этот "
"тип содержит <type>XLogRecPtr</type> и является внутренним системным типом "
"<productname>PostgreSQL</productname>."

#. +> REL9_6_3 REL9_6
#: datatype.xml:4580(para)
msgid ""
"Internally, an LSN is a 64-bit integer, representing a byte position in the "
"write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 "
"digits each, separated by a slash; for example, <literal>16/B374D848</"
"literal>. The <type>pg_lsn</type> type supports the standard comparison "
"operators, like <literal>=</literal> and <literal>&gt;</literal>. Two LSNs "
"can be subtracted using the <literal>-</literal> operator; the result is the "
"number of bytes separating those write-ahead log positions."
msgstr ""
"Технически LSN &mdash; это 64-битное целое, представляющее байтовое смещение "
"в потоке журнала предзаписи. Он выводится в виде двух шестнадцатеричных "
"чисел до 8 цифр каждое, через косую черту, например: <literal>16/B374D848</"
"literal>. Тип <type>pg_lsn</type> поддерживает стандартные операторы "
"сравнения, такие как <literal>=</literal> и <literal>&gt;</literal>. Можно "
"также вычесть один LSN из другого с помощью оператора <literal>-</literal>; "
"результатом будет число байт между этими двумя позициями в журнале "
"предзаписи."

#~ msgid ""
#~ "Here are some examples: <placeholder-1/> The last example demonstrates "
#~ "that <type>tsquery</type> sometimes rearranges nested operators into a "
#~ "logically equivalent formulation."
#~ msgstr ""
#~ "Несколько примеров: <placeholder-1/> Последний пример показывает, что "
#~ "<type>tsquery</type> иногда переставляет вложенные операторы, получая "
#~ "логически равнозначную формулировку."

#~ msgid ""
#~ "SELECT to_tsquery('postgres:*');\n"
#~ " to_tsquery \n"
#~ "------------\n"
#~ " 'postgr':*\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT to_tsquery('postgres:*');\n"
#~ " to_tsquery \n"
#~ "------------\n"
#~ " 'postgr':*\n"
#~ "(1 row)"
