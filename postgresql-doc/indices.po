# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: indices.xml:5(title)
msgid "Indexes"
msgstr "Индексы"

#: indices.xml:7(indexterm)
msgid "<primary>index</primary>"
msgstr "<primary>индекс</primary>"

#: indices.xml:11(para)
msgid ""
"Indexes are a common way to enhance database performance. An index allows "
"the database server to find and retrieve specific rows much faster than it "
"could do without an index. But indexes also add overhead to the database "
"system as a whole, so they should be used sensibly."
msgstr ""
"Индексы &mdash; это традиционное средство увеличения производительности БД. "
"Используя индекс, сервер баз данных может находить и извлекать нужные строки "
"гораздо быстрее, чем без него. Однако с индексами связана дополнительная "
"нагрузка на СУБД в целом, поэтому применять их следует обдуманно."

#: indices.xml:21(title)
msgid "Introduction"
msgstr "Введение"

#: indices.xml:25(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test1 (\n"
"    id integer,\n"
"    content varchar\n"
");"
msgstr ""
"CREATE TABLE test1 (\n"
"    id integer,\n"
"    content varchar\n"
");"

#: indices.xml:32(programlisting)
#, no-wrap
msgid "SELECT content FROM test1 WHERE id = <replaceable>constant</replaceable>;"
msgstr "SELECT content FROM test1 WHERE id = <replaceable>константа</replaceable>;"

#: indices.xml:23(para)
msgid ""
"Suppose we have a table similar to this: <placeholder-1/> and the "
"application issues many queries of the form: <placeholder-2/> With no "
"advance preparation, the system would have to scan the entire "
"<structname>test1</structname> table, row by row, to find all matching "
"entries. If there are many rows in <structname>test1</structname> and only a "
"few rows (perhaps zero or one) that would be returned by such a query, this "
"is clearly an inefficient method. But if the system has been instructed to "
"maintain an index on the <structfield>id</structfield> column, it can use a "
"more efficient method for locating matching rows. For instance, it might "
"only have to walk a few levels deep into a search tree."
msgstr ""
"Предположим, что у нас есть такая таблица: <placeholder-1/> и приложение "
"выполняет много подобных запросов: <placeholder-2/> Если система не будет "
"заранее подготовлена, ей придётся сканировать всю таблицу <structname>test1</"
"structname>, строку за строкой, чтобы найти все подходящие записи. Когда "
"таблица <structname>test1</structname> содержит большое количество записей, "
"а этот запрос должен вернуть всего несколько (возможно, одну или ноль), "
"такое сканирование, очевидно, неэффективно. Но если создать в системе индекс "
"по полю <structfield>id</structfield>, она сможет находить строки гораздо "
"быстрее. Возможно, для этого ей понадобится опуститься всего на несколько "
"уровней в дереве поиска."

#: indices.xml:46(para)
msgid ""
"A similar approach is used in most non-fiction books: terms and concepts "
"that are frequently looked up by readers are collected in an alphabetic "
"index at the end of the book. The interested reader can scan the index "
"relatively quickly and flip to the appropriate page(s), rather than having "
"to read the entire book to find the material of interest. Just as it is the "
"task of the author to anticipate the items that readers are likely to look "
"up, it is the task of the database programmer to foresee which indexes will "
"be useful."
msgstr ""
"Подобный подход часто используется в технической литературе: термины и "
"понятия, которые могут представлять интерес, собираются в алфавитном "
"указателе в конце книги. Читатель может просмотреть этот указатель довольно "
"быстро и затем перейти сразу к соответствующей странице, вместо того, чтобы "
"пролистывать всю книгу в поисках нужного материала. Так же, как задача "
"автора предугадать, что именно будут искать в книге читатели, задача "
"программиста баз данных &mdash; заранее определить, какие индексы будут "
"полезны."

#: indices.xml:61(programlisting)
#, no-wrap
msgid "CREATE INDEX test1_id_index ON test1 (id);"
msgstr "CREATE INDEX test1_id_index ON test1 (id);"

#: indices.xml:58(para)
msgid ""
"The following command can be used to create an index on the <structfield>id</"
"structfield> column, as discussed: <placeholder-1/> The name "
"<structname>test1_id_index</structname> can be chosen freely, but you should "
"pick something that enables you to remember later what the index was for."
msgstr ""
"Создать индекс для столбца <structfield>id</structfield> рассмотренной ранее "
"таблицы можно с помощью следующей команды: <placeholder-1/> Имя индекса "
"<structname>test1_id_index</structname> может быть произвольным, главное, "
"чтобы оно позволяло понять, для чего этот индекс."

#: indices.xml:69(para)
msgid ""
"To remove an index, use the <command>DROP INDEX</command> command. Indexes "
"can be added to and removed from tables at any time."
msgstr ""
"Для удаления индекса используется команда <command>DROP INDEX</command>. "
"Добавлять и удалять индексы можно в любое время."

#: indices.xml:74(para)
msgid ""
"Once an index is created, no further intervention is required: the system "
"will update the index when the table is modified, and it will use the index "
"in queries when it thinks doing so would be more efficient than a sequential "
"table scan. But you might have to run the <command>ANALYZE</command> command "
"regularly to update statistics to allow the query planner to make educated "
"decisions. See <xref linkend=\"performance-tips\"/> for information about "
"how to find out whether an index is used and when and why the planner might "
"choose <emphasis>not</emphasis> to use an index."
msgstr ""
"Когда индекс создан, никакие дополнительные действия не требуются: система "
"сама будет обновлять его при изменении данных в таблице и сама будет "
"использовать его в запросах, где, по её мнению, это будет эффективнее, чем "
"сканирование всей таблицы. Вам, возможно, придётся только периодически "
"запускать команду <command>ANALYZE</command> для обновления статистических "
"данных, на основе которых планировщик запросов принимает решения. В <xref "
"remap=\"6\" linkend=\"performance-tips\"/> вы можете узнать, как определить, "
"используется ли определённый индекс и при каких условиях планировщик может "
"решить <emphasis>не</emphasis> использовать его."

#: indices.xml:86(para)
msgid ""
"Indexes can also benefit <command>UPDATE</command> and <command>DELETE</"
"command> commands with search conditions. Indexes can moreover be used in "
"join searches. Thus, an index defined on a column that is part of a join "
"condition can also significantly speed up queries with joins."
msgstr ""
"Индексы могут быть полезны также при выполнении команд <command>UPDATE</"
"command> и <command>DELETE</command> с условиями поиска. Кроме того, они "
"могут применяться в поиске с соединением. То есть, индекс, определённый для "
"столбца, участвующего в условии соединения, может значительно ускорить "
"запросы с JOIN."

#: indices.xml:94(para)
msgid ""
"Creating an index on a large table can take a long time. By default, "
"<productname>PostgreSQL</productname> allows reads (<command>SELECT</"
"command> statements) to occur on the table in parallel with index creation, "
"but writes (<command>INSERT</command>, <command>UPDATE</command>, "
"<command>DELETE</command>) are blocked until the index build is finished. In "
"production environments this is often unacceptable. It is possible to allow "
"writes to occur in parallel with index creation, but there are several "
"caveats to be aware of &mdash; for more information see <xref linkend=\"sql-"
"createindex-concurrently\" endterm=\"sql-createindex-concurrently-title\"/>."
msgstr ""
"Создание индекса для большой таблицы может занимать много времени. По "
"умолчанию <productname>PostgreSQL</productname> позволяет параллельно с "
"созданием индекса выполнять чтение (операторы <command>SELECT</command>) "
"таблицы, но операции записи (<command>INSERT</command>, <command>UPDATE</"
"command> и <command>DELETE</command>) блокируются до окончания построения "
"индекса. Для производственной среды это ограничение часто бывает "
"неприемлемым. Хотя есть возможность разрешить запись параллельно с созданием "
"индексов, при этом нужно учитывать ряд оговорок &mdash; они описаны в "
"подразделе <xref linkend=\"sql-createindex-concurrently\" endterm=\"sql-"
"createindex-concurrently-title\"/>."

#: indices.xml:106(para)
msgid ""
"After an index is created, the system has to keep it synchronized with the "
"table. This adds overhead to data manipulation operations. Therefore indexes "
"that are seldom or never used in queries should be removed."
msgstr ""
"После создания индекса система должна поддерживать его в состоянии, "
"соответствующем данным таблицы. С этим связаны неизбежные накладные расходы "
"при изменении данных. Таким образом, индексы, которые используются в "
"запросах редко или вообще никогда, должны быть удалены."

#: indices.xml:116(title)
msgid "Index Types"
msgstr "Типы индексов"

#: indices.xml:118(para)
msgid ""
"<productname>PostgreSQL</productname> provides several index types: B-tree, "
"Hash, GiST, SP-GiST, GIN and BRIN. Each index type uses a different "
"algorithm that is best suited to different types of queries. By default, the "
"<command>CREATE INDEX</command> command creates B-tree indexes, which fit "
"the most common situations."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает несколько типов индексов: "
"B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Для разных типов индексов "
"применяются разные алгоритмы, ориентированные на определённые типы запросов. "
"По умолчанию команда <command>CREATE INDEX</command> создаёт индексы типа B-"
"дерево, эффективные в большинстве случаев."

#: indices.xml:128(indexterm)
msgid "<primary>index</primary> <secondary>B-tree</secondary>"
msgstr "<primary>индекс</primary> <secondary>B-дерево</secondary>"

#: indices.xml:132(indexterm)
msgid "<primary>B-tree</primary> <see>index</see>"
msgstr "<primary>B-дерево</primary> <see>индекс</see>"

#: indices.xml:143(literal) indices.xml:360(literal)
msgid "&lt;"
msgstr "&lt;"

#: indices.xml:144(literal) indices.xml:361(literal)
msgid "&lt;="
msgstr "&lt;="

#: indices.xml:145(literal) indices.xml:326(literal) indices.xml:362(literal)
msgid "="
msgstr "="

#: indices.xml:146(literal) indices.xml:363(literal)
msgid "&gt;="
msgstr "&gt;="

#: indices.xml:147(literal) indices.xml:364(literal)
msgid "&gt;"
msgstr "&gt;"

#: indices.xml:127(para)
msgid ""
"<placeholder-1/> <placeholder-2/> B-trees can handle equality and range "
"queries on data that can be sorted into some ordering. In particular, the "
"<productname>PostgreSQL</productname> query planner will consider using a B-"
"tree index whenever an indexed column is involved in a comparison using one "
"of these operators: <placeholder-3/> Constructs equivalent to combinations "
"of these operators, such as <literal>BETWEEN</literal> and <literal>IN</"
"literal>, can also be implemented with a B-tree index search. Also, an "
"<literal>IS NULL</literal> or <literal>IS NOT NULL</literal> condition on an "
"index column can be used with a B-tree index."
msgstr ""
"<placeholder-1/> <placeholder-2/> B-деревья могут работать в условиях на "
"равенство и в проверках диапазонов с данными, которые можно отсортировать в "
"некотором порядке. Точнее, планировщик запросов <productname>PostgreSQL</"
"productname> может задействовать индекс-B-дерево, когда индексируемый "
"столбец участвует в сравнении с одним из следующих операторов: "
"<placeholder-3/> При обработке конструкций, представимых как сочетание этих "
"операторов, например <literal>BETWEEN</literal> и <literal>IN</literal>, так "
"же может выполняться поиск по индексу-B-дереву. Кроме того, такие индексы "
"могут использоваться и в условиях <literal>IS NULL</literal> и <literal>IS "
"NOT NULL</literal> по индексированным столбцам."

#: indices.xml:156(para)
msgid ""
"The optimizer can also use a B-tree index for queries involving the pattern "
"matching operators <literal>LIKE</literal> and <literal>~</literal> "
"<emphasis>if</emphasis> the pattern is a constant and is anchored to the "
"beginning of the string &mdash; for example, <literal>col LIKE 'foo%'</"
"literal> or <literal>col ~ '^foo'</literal>, but not <literal>col LIKE "
"'%bar'</literal>. However, if your database does not use the C locale you "
"will need to create the index with a special operator class to support "
"indexing of pattern-matching queries; see <xref linkend=\"indexes-opclass\"/"
"> below. It is also possible to use B-tree indexes for <literal>ILIKE</"
"literal> and <literal>~*</literal>, but only if the pattern starts with non-"
"alphabetic characters, i.e., characters that are not affected by upper/lower "
"case conversion."
msgstr ""
"Также оптимизатор может использовать эти индексы в запросах с операторами "
"сравнения по шаблону <literal>LIKE</literal> и <literal>~</literal>, "
"<emphasis>если</emphasis> этот шаблон определяется константой и он привязан "
"к началу строки &mdash; например, <literal>col LIKE 'foo%'</literal> или "
"<literal>col ~ '^foo'</literal>, но не <literal>col LIKE '%bar'</literal>. "
"Но если ваша база данных использует не локаль C, для поддержки "
"индексирования запросов с шаблонами вам потребуется создать индекс со "
"специальным классом операторов; см. <xref remap=\"4\" linkend=\"indexes-"
"opclass\"/>. Индексы-B-деревья можно использовать и для <literal>ILIKE</"
"literal> и <literal>~*</literal>, но только если шаблон начинается не с "
"алфавитных символов, то есть символов, не подверженных преобразованию "
"регистра."

#: indices.xml:172(para)
msgid ""
"B-tree indexes can also be used to retrieve data in sorted order. This is "
"not always faster than a simple scan and sort, but it is often helpful."
msgstr ""
"B-деревья могут также применяться для получения данных, отсортированных по "
"порядку. Это не всегда быстрее простого сканирования и сортировки, но иногда "
"бывает полезно."

#: indices.xml:179(indexterm)
msgid "<primary>index</primary> <secondary>hash</secondary>"
msgstr "<primary>индекс</primary> <secondary>по хешу</secondary>"

#: indices.xml:183(indexterm)
msgid "<primary>hash</primary> <see>index</see>"
msgstr "<primary>хеш</primary> <see>индекс</see>"

#: indices.xml:178(para)
msgid ""
"<placeholder-1/> <placeholder-2/> Hash indexes can only handle simple "
"equality comparisons. The query planner will consider using a hash index "
"whenever an indexed column is involved in a comparison using the <literal>=</"
"literal> operator. The following command is used to create a hash index: "
"<synopsis>\n"
"CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</"
"replaceable> USING HASH (<replaceable>column</replaceable>);\n"
"</synopsis>"
msgstr ""
"<placeholder-1/> <placeholder-2/> Хеш-индексы работают только с простыми "
"условиями равенства. Планировщик запросов может применить хеш-индекс, только "
"если индексируемый столбец участвует в сравнении с оператором <literal>=</"
"literal>. Создать такой индекс можно следующей командой: <synopsis>\n"
"CREATE INDEX <replaceable>имя</replaceable> ON <replaceable>таблица</"
"replaceable> USING HASH (<replaceable>столбец</replaceable>);\n"
"</synopsis>"

#: indices.xml:198(para)
msgid ""
"Hash index operations are not presently WAL-logged, so hash indexes might "
"need to be rebuilt with <command>REINDEX</command> after a database crash if "
"there were unwritten changes. Also, changes to hash indexes are not "
"replicated over streaming or file-based replication after the initial base "
"backup, so they give wrong answers to queries that subsequently use them. "
"For these reasons, hash index use is presently discouraged."
msgstr ""
"Операции с хеш-индексами в настоящее время не проходят через WAL, так что "
"после аварийной остановки базы данных может потребоваться перестроить хеш-"
"индексы командой <command>REINDEX</command>. Кроме того, изменения в хеш-"
"индексах после начальной копии не переносятся при потоковой или файловой "
"репликации, так что в последующих запросах они будут давать неправильные "
"ответы. По этим причинам настоятельно рекомендуется не использовать их."

#: indices.xml:210(indexterm)
msgid "<primary>index</primary> <secondary>GiST</secondary>"
msgstr "<primary>индекс</primary> <secondary>GiST</secondary>"

#: indices.xml:214(indexterm)
msgid "<primary>GiST</primary> <see>index</see>"
msgstr "<primary>GiST</primary> <see>индекс</see>"

#: indices.xml:228(literal) indices.xml:282(literal)
msgid "&lt;&lt;"
msgstr "&lt;&lt;"

#: indices.xml:229(literal)
msgid "&amp;&lt;"
msgstr "&amp;&lt;"

#: indices.xml:230(literal)
msgid "&amp;&gt;"
msgstr "&amp;&gt;"

#: indices.xml:231(literal) indices.xml:283(literal)
msgid "&gt;&gt;"
msgstr "&gt;&gt;"

#: indices.xml:232(literal)
msgid "&lt;&lt;|"
msgstr "&lt;&lt;|"

#: indices.xml:233(literal)
msgid "&amp;&lt;|"
msgstr "&amp;&lt;|"

#: indices.xml:234(literal)
msgid "|&amp;&gt;"
msgstr "|&amp;&gt;"

#: indices.xml:235(literal)
msgid "|&gt;&gt;"
msgstr "|&gt;&gt;"

#: indices.xml:236(literal) indices.xml:325(literal)
msgid "@&gt;"
msgstr "@&gt;"

#: indices.xml:237(literal) indices.xml:285(literal) indices.xml:324(literal)
msgid "&lt;@"
msgstr "&lt;@"

#: indices.xml:238(literal) indices.xml:284(literal)
msgid "~="
msgstr "~="

#: indices.xml:239(literal) indices.xml:327(literal)
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#: indices.xml:209(para)
msgid ""
"<placeholder-1/> <placeholder-2/> GiST indexes are not a single kind of "
"index, but rather an infrastructure within which many different indexing "
"strategies can be implemented. Accordingly, the particular operators with "
"which a GiST index can be used vary depending on the indexing strategy (the "
"<firstterm>operator class</firstterm>). As an example, the standard "
"distribution of <productname>PostgreSQL</productname> includes GiST operator "
"classes for several two-dimensional geometric data types, which support "
"indexed queries using these operators: <placeholder-3/> (See <xref linkend="
"\"functions-geometry\"/> for the meaning of these operators.) The GiST "
"operator classes included in the standard distribution are documented in "
"<xref linkend=\"gist-builtin-opclasses-table\"/>. Many other GiST operator "
"classes are available in the <literal>contrib</literal> collection or as "
"separate projects. For more information see <xref linkend=\"gist\"/>."
msgstr ""
"<placeholder-1/> <placeholder-2/> GiST-индексы представляют собой не просто "
"разновидность индексов, а инфраструктуру, позволяющую реализовать много "
"разных стратегий индексирования. Как следствие, GiST-индексы могут "
"применяться с разными операторами, в зависимости от стратегии индексирования "
"(<firstterm>класса операторов</firstterm>). Например, стандартный "
"дистрибутив <productname>PostgreSQL</productname> включает классы операторов "
"GiST для нескольких двумерных типов геометрических данных, что позволяет "
"применять индексы в запросах с операторами: <placeholder-3/> (Эти операторы "
"описаны в <xref remap=\"6\" linkend=\"functions-geometry\"/>.) Классы "
"операторов GiST, включённые в стандартный дистрибутив, описаны в <xref remap="
"\"6\" linkend=\"gist-builtin-opclasses-table\"/>. В коллекции "
"<literal>contrib</literal> можно найти и другие классы операторов GiST, "
"реализованные как отдельные проекты. За дополнительными сведениями "
"обратитесь к <xref remap=\"3\" linkend=\"gist\"/>."

#: indices.xml:251(para)
msgid ""
"GiST indexes are also capable of optimizing <quote>nearest-neighbor</quote> "
"searches, such as <placeholder-1/> which finds the ten places closest to a "
"given target point. The ability to do this is again dependent on the "
"particular operator class being used. In <xref linkend=\"gist-builtin-"
"opclasses-table\"/>, operators that can be used in this way are listed in "
"the column <quote>Ordering Operators</quote>."
msgstr ""
"GiST-индексы также могут оптимизировать поиск <quote>ближайшего соседа</"
"quote>, например такой: <placeholder-1/> который возвращает десять "
"расположений, ближайших к заданной точке. Возможность такого применения "
"индекса опять же зависит от класса используемого оператора. Операторы, "
"которые можно использовать таким образом, перечислены в <xref remap=\"6\" "
"linkend=\"gist-builtin-opclasses-table\"/>, в столбце <quote>Операторы "
"сортировки</quote>."

#: indices.xml:265(indexterm)
msgid "<primary>index</primary> <secondary>SP-GiST</secondary>"
msgstr "<primary>индекс</primary> <secondary>SP-GiST</secondary>"

#: indices.xml:269(indexterm)
msgid "<primary>SP-GiST</primary> <see>index</see>"
msgstr "<primary>SP-GiST</primary> <see>индекс</see>"

#: indices.xml:286(literal)
msgid "&lt;^"
msgstr "&lt;^"

#: indices.xml:287(literal)
msgid "&gt;^"
msgstr "&gt;^"

#: indices.xml:264(para)
msgid ""
"<placeholder-1/> <placeholder-2/> SP-GiST indexes, like GiST indexes, offer "
"an infrastructure that supports various kinds of searches. SP-GiST permits "
"implementation of a wide range of different non-balanced disk-based data "
"structures, such as quadtrees, k-d trees, and radix trees (tries). As an "
"example, the standard distribution of <productname>PostgreSQL</productname> "
"includes SP-GiST operator classes for two-dimensional points, which support "
"indexed queries using these operators: <placeholder-3/> (See <xref linkend="
"\"functions-geometry\"/> for the meaning of these operators.) The SP-GiST "
"operator classes included in the standard distribution are documented in "
"<xref linkend=\"spgist-builtin-opclasses-table\"/>. For more information see "
"<xref linkend=\"spgist\"/>."
msgstr ""
"<placeholder-1/> <placeholder-2/> Индексы SP-GiST, как и GiST, предоставляют "
"инфраструктуру, поддерживающие различные типы поиска. SP-GiST позволяет "
"организовывать на диске самые разные несбалансированные структуры данных, "
"такие как деревья квадрантов, k-мерные и префиксные деревья. Например, "
"стандартный дистрибутив <productname>PostgreSQL</productname> включает "
"классы операторов SP-GiST для точек в двумерном пространстве, что позволяет "
"применять индексы в запросах с операторами: <placeholder-3/> (Эти операторы "
"описаны в <xref remap=\"6\" linkend=\"functions-geometry\"/>.) Классы "
"операторов SP-GiST, включённые в стандартный дистрибутив, описаны в <xref "
"remap=\"6\" linkend=\"spgist-builtin-opclasses-table\"/>. За дополнительными "
"сведениями обратитесь к <xref remap=\"3\" linkend=\"spgist\"/>."

#: indices.xml:298(indexterm)
msgid "<primary>index</primary> <secondary>GIN</secondary>"
msgstr "<primary>индекс</primary> <secondary>GIN</secondary>"

#: indices.xml:302(indexterm)
msgid "<primary>GIN</primary> <see>index</see>"
msgstr "<primary>GIN</primary> <see>индекс</see>"

#: indices.xml:297(para)
msgid ""
"<placeholder-1/> <placeholder-2/> GIN indexes are <quote>inverted indexes</"
"quote> which are appropriate for data values that contain multiple component "
"values, such as arrays. An inverted index contains a separate entry for each "
"component value, and can efficiently handle queries that test for the "
"presence of specific component values."
msgstr ""
"<placeholder-1/> <placeholder-2/> GIN-индексы представляют собой "
"<quote>инвертированные индексы</quote>, в которых могут содержаться значения "
"с несколькими ключами, например массивы. Инвертированный индекс содержит "
"отдельный элемент для значения каждого компонента, и может эффективно "
"работать в запросах, проверяющих присутствие определённых значений "
"компонентов."

#: indices.xml:313(para)
msgid ""
"Like GiST and SP-GiST, GIN can support many different user-defined indexing "
"strategies, and the particular operators with which a GIN index can be used "
"vary depending on the indexing strategy. As an example, the standard "
"distribution of <productname>PostgreSQL</productname> includes GIN operator "
"classes for one-dimensional arrays, which support indexed queries using "
"these operators: <placeholder-1/> (See <xref linkend=\"functions-array\"/> "
"for the meaning of these operators.) The GIN operator classes included in "
"the standard distribution are documented in <xref linkend=\"gin-builtin-"
"opclasses-table\"/>. Many other GIN operator classes are available in the "
"<literal>contrib</literal> collection or as separate projects. For more "
"information see <xref linkend=\"gin\"/>."
msgstr ""
"Подобно GiST и SP-GiST, индексы GIN могут поддерживать различные "
"определённые пользователем стратегии и в зависимости от них могут "
"применяться с разными операторами. Например, стандартный дистрибутив "
"<productname>PostgreSQL</productname> включает классы операторов GIN для "
"одномерных массивов, что позволяет применять индексы в запросах с "
"операторами: <placeholder-1/> (Эти операторы описаны в <xref remap=\"6\" "
"linkend=\"functions-array\"/>.) Классы операторов GIN, включённые в "
"стандартный дистрибутив, описаны в <xref remap=\"6\" linkend=\"gin-builtin-"
"opclasses-table\"/>. В коллекции <literal>contrib</literal> можно найти и "
"другие классы операторов GIN, реализованные как отдельные проекты. За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"gin\"/>."

#: indices.xml:340(indexterm)
msgid "<primary>index</primary> <secondary>BRIN</secondary>"
msgstr "<primary>индекс</primary> <secondary>BRIN</secondary>"

#: indices.xml:344(indexterm)
msgid "<primary>BRIN</primary> <see>index</see>"
msgstr "<primary>BRIN</primary> <see>индекс</see>"

#: indices.xml:339(para)
msgid ""
"<placeholder-1/> <placeholder-2/> BRIN indexes (a shorthand for Block Range "
"INdexes) store summaries about the values stored in consecutive physical "
"block ranges of a table. Like GiST, SP-GiST and GIN, BRIN can support many "
"different indexing strategies, and the particular operators with which a "
"BRIN index can be used vary depending on the indexing strategy. For data "
"types that have a linear sort order, the indexed data corresponds to the "
"minimum and maximum values of the values in the column for each block range. "
"This supports indexed queries using these operators: <placeholder-3/> The "
"BRIN operator classes included in the standard distribution are documented "
"in <xref linkend=\"brin-builtin-opclasses-table\"/>. For more information "
"see <xref linkend=\"brin\"/>."
msgstr ""
"<placeholder-1/> <placeholder-2/> BRIN-индексы (сокращение от Block Range "
"INdexes, Индексы зон блоков) хранят обобщённые сведения о значениях, "
"находящихся в физически последовательно расположенных блоках таблицы. "
"Подобно GiST, SP-GiST и GIN, индексы BRIN могут поддерживать определённые "
"пользователем стратегии, и в зависимости от них применяться с разными "
"операторами. Для типов данных, имеющих линейный порядок сортировки, записям "
"в индексе соответствуют минимальные и максимальные значения данных в столбце "
"для каждой зоны блоков. Это позволяет поддерживать запросы со следующими "
"операторами: <placeholder-3/> Классы операторов BRIN, включённые в "
"стандартный дистрибутив, описаны в <xref remap=\"6\" linkend=\"brin-builtin-"
"opclasses-table\"/>. За дополнительными сведениями обратитесь к <xref remap="
"\"3\" linkend=\"brin\"/>."

#: indices.xml:375(title)
msgid "Multicolumn Indexes"
msgstr "Составные индексы"

#: indices.xml:377(indexterm)
msgid "<primary>index</primary> <secondary>multicolumn</secondary>"
msgstr "<primary>индекс</primary> <secondary>составной</secondary>"

#: indices.xml:385(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test2 (\n"
"  major int,\n"
"  minor int,\n"
"  name varchar\n"
");"
msgstr ""
"CREATE TABLE test2 (\n"
"  major int,\n"
"  minor int,\n"
"  name varchar\n"
");"

#: indices.xml:394(programlisting)
#, no-wrap
msgid "SELECT name FROM test2 WHERE major = <replaceable>constant</replaceable> AND minor = <replaceable>constant</replaceable>;"
msgstr "SELECT name FROM test2 WHERE major = <replaceable>константа</replaceable> AND minor = <replaceable>константа</replaceable>;"

#: indices.xml:400(programlisting)
#, no-wrap
msgid "CREATE INDEX test2_mm_idx ON test2 (major, minor);"
msgstr "CREATE INDEX test2_mm_idx ON test2 (major, minor);"

#: indices.xml:382(para)
msgid ""
"An index can be defined on more than one column of a table. For example, if "
"you have a table of this form: <placeholder-1/> (say, you keep your "
"<filename class=\"directory\">/dev</filename> directory in a database...) "
"and you frequently issue queries like: <placeholder-2/> then it might be "
"appropriate to define an index on the columns <structfield>major</"
"structfield> and <structfield>minor</structfield> together, e.g.: "
"<placeholder-3/>"
msgstr ""
"Индексы можно создавать и по нескольким столбцам таблицы. Например, если у "
"вас есть таблица: <placeholder-1/> (предположим, что вы поместили в неё "
"содержимое каталога <filename class=\"directory\">/dev</filename>) и вы "
"часто выполняете запросы вида: <placeholder-2/> тогда имеет смысл определить "
"индекс, покрывающий оба столбца <structfield>major</structfield> и "
"<structfield>minor</structfield>. Например: <placeholder-3/>"

#: indices.xml:405(para)
msgid ""
"Currently, only the B-tree, GiST, GIN, and BRIN index types support "
"multicolumn indexes. Up to 32 columns can be specified. (This limit can be "
"altered when building <productname>PostgreSQL</productname>; see the file "
"<filename>pg_config_manual.h</filename>.)"
msgstr ""
"В настоящее время составными могут быть только индексы типов B-дерево, GiST, "
"GIN и BRIN. Число столбцов в индексе ограничивается 32. (Этот предел можно "
"изменить при компиляции <productname>PostgreSQL</productname>; см. файл "
"<filename>pg_config_manual.h</filename>.)"

#: indices.xml:413(para)
msgid ""
"A multicolumn B-tree index can be used with query conditions that involve "
"any subset of the index's columns, but the index is most efficient when "
"there are constraints on the leading (leftmost) columns. The exact rule is "
"that equality constraints on leading columns, plus any inequality "
"constraints on the first column that does not have an equality constraint, "
"will be used to limit the portion of the index that is scanned. Constraints "
"on columns to the right of these columns are checked in the index, so they "
"save visits to the table proper, but they do not reduce the portion of the "
"index that has to be scanned. For example, given an index on <literal>(a, b, "
"c)</literal> and a query condition <literal>WHERE a = 5 AND b &gt;= 42 AND c "
"&lt; 77</literal>, the index would have to be scanned from the first entry "
"with <literal>a</literal> = 5 and <literal>b</literal> = 42 up through the "
"last entry with <literal>a</literal> = 5. Index entries with <literal>c</"
"literal> &gt;= 77 would be skipped, but they'd still have to be scanned "
"through. This index could in principle be used for queries that have "
"constraints on <literal>b</literal> and/or <literal>c</literal> with no "
"constraint on <literal>a</literal> &mdash; but the entire index would have "
"to be scanned, so in most cases the planner would prefer a sequential table "
"scan over using the index."
msgstr ""
"Составной индекс-B-дерево может применяться в условиях с любым подмножеством "
"столбцов индекса, но наиболее эффективен он при ограничениях по ведущим "
"(левым) столбцам. Точное правило состоит в том, что сканируемая область "
"индекса определяется условиями равенства с ведущими столбцами и условиями "
"неравенства с первым столбцом, не участвующим в условии равенства. "
"Ограничения столбцов правее них также проверяются по индексу, так что "
"обращение к таблице откладывается, но на размер сканируемой области индекса "
"это уже не влияет. Например, если есть индекс по столбцам <literal>(a, b, "
"c)</literal> и условие <literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</"
"literal>, индекс будет сканироваться от первой записи <literal>a</literal> = "
"5 и <literal>b</literal> = 42 до последней с <literal>a</literal> = 5. "
"Записи индекса, в которых <literal>c</literal> &gt;= 77, не будут "
"учитываться, но, тем не менее, будут просканированы. Этот индекс в принципе "
"может использоваться в запросах с ограничениями по <literal>b</literal> и/"
"или <literal>c</literal>, без ограничений столбца <literal>a</literal>, но "
"при этом будет просканирован весь индекс, так что в большинстве случаев "
"планировщик предпочтёт использованию индекса полное сканирование таблицы."

#: indices.xml:435(para)
msgid ""
"A multicolumn GiST index can be used with query conditions that involve any "
"subset of the index's columns. Conditions on additional columns restrict the "
"entries returned by the index, but the condition on the first column is the "
"most important one for determining how much of the index needs to be "
"scanned. A GiST index will be relatively ineffective if its first column has "
"only a few distinct values, even if there are many distinct values in "
"additional columns."
msgstr ""
"Составной индекс GiST может применяться в условиях с любым подмножеством "
"столбцов индекса. Условия с дополнительными столбцами ограничивают записи, "
"возвращаемые индексом, но в первую очередь сканируемая область индекса "
"определяется ограничением первого столбца. GiST-индекс будет относительно "
"малоэффективен, когда первый его столбец содержит только несколько "
"различающихся значений, даже если дополнительные столбцы дают множество "
"различных значений."

#: indices.xml:445(para)
msgid ""
"A multicolumn GIN index can be used with query conditions that involve any "
"subset of the index's columns. Unlike B-tree or GiST, index search "
"effectiveness is the same regardless of which index column(s) the query "
"conditions use."
msgstr ""
"Составной индекс GIN может применяться в условиях с любым подмножеством "
"столбцов индекса. В отличие от индексов GiST или B-деревьев, эффективность "
"поиска по нему не меняется в зависимости от того, какие из его столбцов "
"используются в условиях запроса."

#: indices.xml:452(para)
msgid ""
"A multicolumn BRIN index can be used with query conditions that involve any "
"subset of the index's columns. Like GIN and unlike B-tree or GiST, index "
"search effectiveness is the same regardless of which index column(s) the "
"query conditions use. The only reason to have multiple BRIN indexes instead "
"of one multicolumn BRIN index on a single table is to have a different "
"<literal>pages_per_range</literal> storage parameter."
msgstr ""
"Составной индекс BRIN может применяться в условиях запроса с любым "
"подмножеством столбцов индекса. Подобно индексу GIN и в отличие от B-"
"деревьев или GiST, эффективность поиска по нему не меняется в зависимости от "
"того, какие из его столбцов используются в условиях запроса. Единственное, "
"зачем в одной таблице могут потребоваться несколько индексов BRIN вместо "
"одного составного индекса — это затем, чтобы применялись разные параметры "
"хранения <literal>pages_per_range</literal>."

#: indices.xml:461(para)
msgid ""
"Of course, each column must be used with operators appropriate to the index "
"type; clauses that involve other operators will not be considered."
msgstr ""
"При этом, разумеется, каждый столбец должен использоваться с операторами, "
"соответствующими типу индекса; ограничения с другими операторами "
"рассматриваться не будут."

#: indices.xml:466(para)
msgid ""
"Multicolumn indexes should be used sparingly. In most situations, an index "
"on a single column is sufficient and saves space and time. Indexes with more "
"than three columns are unlikely to be helpful unless the usage of the table "
"is extremely stylized. See also <xref linkend=\"indexes-bitmap-scans\"/> and "
"<xref linkend=\"indexes-index-only-scans\"/> for some discussion of the "
"merits of different index configurations."
msgstr ""
"Составные индексы следует использовать обдуманно. В большинстве случаев "
"индекс по одному столбцу будет работать достаточно хорошо и сэкономит время "
"и место. Индексы по более чём трём столбцам вряд ли будут полезными, если "
"только таблица не используется крайне однообразно. Описание достоинств "
"различных конфигураций индексов можно найти в <xref remap=\"6\" linkend="
"\"indexes-bitmap-scans\"/> и <xref remap=\"6\" linkend=\"indexes-index-only-"
"scans\"/>."

#: indices.xml:479(title)
msgid "Indexes and <literal>ORDER BY</literal>"
msgstr "Индексы и предложения <literal>ORDER BY</literal>"

#: indices.xml:481(indexterm)
msgid ""
"<primary>index</primary> <secondary>and <literal>ORDER BY</literal></"
"secondary>"
msgstr ""
"<primary>индекс</primary> <secondary>и <literal>ORDER BY</literal></"
"secondary>"

#: indices.xml:486(para)
msgid ""
"In addition to simply finding the rows to be returned by a query, an index "
"may be able to deliver them in a specific sorted order. This allows a "
"query's <literal>ORDER BY</literal> specification to be honored without a "
"separate sorting step. Of the index types currently supported by "
"<productname>PostgreSQL</productname>, only B-tree can produce sorted output "
"&mdash; the other index types return matching rows in an unspecified, "
"implementation-dependent order."
msgstr ""
"Помимо простого поиска строк для выдачи в результате запроса, индексы также "
"могут применяться для сортировки строк в определённом порядке. Это позволяет "
"учесть предложение <literal>ORDER BY</literal> в запросе, не выполняя "
"сортировку дополнительно. Из всех типов индексов, которые поддерживает "
"<productname>PostgreSQL</productname>, сортировать данные могут только B-"
"деревья &mdash; индексы других типов возвращают строки в неопределённом, "
"зависящем от реализации порядке."

#: indices.xml:496(para)
msgid ""
"The planner will consider satisfying an <literal>ORDER BY</literal> "
"specification either by scanning an available index that matches the "
"specification, or by scanning the table in physical order and doing an "
"explicit sort. For a query that requires scanning a large fraction of the "
"table, an explicit sort is likely to be faster than using an index because "
"it requires less disk I/O due to following a sequential access pattern. "
"Indexes are more useful when only a few rows need be fetched. An important "
"special case is <literal>ORDER BY</literal> in combination with "
"<literal>LIMIT</literal> <replaceable>n</replaceable>: an explicit sort will "
"have to process all the data to identify the first <replaceable>n</"
"replaceable> rows, but if there is an index matching the <literal>ORDER BY</"
"literal>, the first <replaceable>n</replaceable> rows can be retrieved "
"directly, without scanning the remainder at all."
msgstr ""
"Планировщик может выполнить указание <literal>ORDER BY</literal>, либо "
"просканировав существующий индекс, подходящий этому указанию, либо "
"просканировав таблицу в физическом порядке и выполнив сортировку явно. Для "
"запроса, требующего сканирования большой части таблицы, явная сортировка "
"скорее всего будет быстрее, чем применение индекса, так как при "
"последовательном чтении она потребует меньше операций ввода/вывода. Важный "
"особый случай представляет <literal>ORDER BY</literal> в сочетании с "
"<literal>LIMIT</literal> <replaceable>n</replaceable>: при явной сортировке "
"системе потребуется обработать все данные, чтобы выбрать первые "
"<replaceable>n</replaceable> строк, но при наличии индекса, соответствующего "
"столбцам в <literal>ORDER BY</literal>, первые <replaceable>n</replaceable> "
"строк можно получить сразу, не просматривая остальные вовсе."

#: indices.xml:512(para)
msgid ""
"By default, B-tree indexes store their entries in ascending order with nulls "
"last. This means that a forward scan of an index on column <literal>x</"
"literal> produces output satisfying <literal>ORDER BY x</literal> (or more "
"verbosely, <literal>ORDER BY x ASC NULLS LAST</literal>). The index can also "
"be scanned backward, producing output satisfying <literal>ORDER BY x DESC</"
"literal> (or more verbosely, <literal>ORDER BY x DESC NULLS FIRST</literal>, "
"since <literal>NULLS FIRST</literal> is the default for <literal>ORDER BY "
"DESC</literal>)."
msgstr ""
"По умолчанию элементы B-дерева хранятся в порядке возрастания, при этом "
"значения NULL идут в конце. Это означает, что при прямом сканировании "
"индекса по столбцу <literal>x</literal> порядок оказывается соответствующим "
"указанию <literal>ORDER BY x</literal> (или точнее, <literal>ORDER BY x ASC "
"NULLS LAST</literal>). Индекс также может сканироваться в обратную сторону, "
"и тогда порядок соответствует указанию <literal>ORDER BY x DESC</literal> "
"(или точнее, <literal>ORDER BY x DESC NULLS FIRST</literal>, так как для "
"<literal>ORDER BY DESC</literal> подразумевается <literal>NULLS FIRST</"
"literal>)."

#: indices.xml:527(programlisting)
#, no-wrap
msgid ""
"CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);\n"
"CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);"
msgstr ""
"CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);\n"
"CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);"

#: indices.xml:523(para)
msgid ""
"You can adjust the ordering of a B-tree index by including the options "
"<literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS FIRST</"
"literal>, and/or <literal>NULLS LAST</literal> when creating the index; for "
"example: <placeholder-1/> An index stored in ascending order with nulls "
"first can satisfy either <literal>ORDER BY x ASC NULLS FIRST</literal> or "
"<literal>ORDER BY x DESC NULLS LAST</literal> depending on which direction "
"it is scanned in."
msgstr ""
"Вы можете изменить порядок сортировки элементов B-дерева, добавив уточнения "
"<literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS FIRST</"
"literal> и/или <literal>NULLS LAST</literal> при создании индекса; например: "
"<placeholder-1/> Индекс, в котором элементы хранятся в порядке возрастания и "
"значения NULL идут первыми, может удовлетворять указаниям <literal>ORDER BY "
"x ASC NULLS FIRST</literal> или <literal>ORDER BY x DESC NULLS LAST</"
"literal>, в зависимости от направления просмотра."

#: indices.xml:537(para)
msgid ""
"You might wonder why bother providing all four options, when two options "
"together with the possibility of backward scan would cover all the variants "
"of <literal>ORDER BY</literal>. In single-column indexes the options are "
"indeed redundant, but in multicolumn indexes they can be useful. Consider a "
"two-column index on <literal>(x, y)</literal>: this can satisfy "
"<literal>ORDER BY x, y</literal> if we scan forward, or <literal>ORDER BY x "
"DESC, y DESC</literal> if we scan backward. But it might be that the "
"application frequently needs to use <literal>ORDER BY x ASC, y DESC</"
"literal>. There is no way to get that ordering from a plain index, but it is "
"possible if the index is defined as <literal>(x ASC, y DESC)</literal> or "
"<literal>(x DESC, y ASC)</literal>."
msgstr ""
"У вас может возникнуть вопрос, зачем нужны все четыре варианта при создании "
"индексов, когда и два варианта с учётом обратного просмотра покрывают все "
"виды <literal>ORDER BY</literal>. Для индексов по одному столбцу это и в "
"самом деле излишне, но для индексов по многим столбцам это может быть "
"полезно. Рассмотрим индекс по двум столбцам <literal>(x, y)</literal>: он "
"может удовлетворять указанию <literal>ORDER BY x, y</literal> при прямом "
"сканировании или <literal>ORDER BY x DESC, y DESC</literal> при обратном. Но "
"вполне возможно, что приложение будет часто выполнять <literal>ORDER BY x "
"ASC, y DESC</literal>. В этом случае получить такую сортировку от простого "
"индекса нельзя, но можно получить подходящий индекс, определив его как "
"<literal>(x ASC, y DESC)</literal> или <literal>(x DESC, y ASC)</literal>."

#: indices.xml:551(para)
msgid ""
"Obviously, indexes with non-default sort orderings are a fairly specialized "
"feature, but sometimes they can produce tremendous speedups for certain "
"queries. Whether it's worth maintaining such an index depends on how often "
"you use queries that require a special sort ordering."
msgstr ""
"Очевидно, что индексы с нестандартными правилами сортировки весьма "
"специфичны, но иногда они могут кардинально ускорить определённые запросы. "
"Стоит ли вводить такие индексы, зависит от того, как часто выполняются "
"запросы с необычным порядком сортировки."

#: indices.xml:562(title)
msgid "Combining Multiple Indexes"
msgstr "Объединение нескольких индексов"

#: indices.xml:564(indexterm)
msgid ""
"<primary>index</primary> <secondary>combining multiple indexes</secondary>"
msgstr ""
"<primary>индекс</primary> <secondary>объединение нескольких индексов</"
"secondary>"

#: indices.xml:569(indexterm)
msgid "<primary>bitmap scan</primary>"
msgstr "<primary>сканирование по битовой карте</primary>"

#: indices.xml:573(para)
msgid ""
"A single index scan can only use query clauses that use the index's columns "
"with operators of its operator class and are joined with <literal>AND</"
"literal>. For example, given an index on <literal>(a, b)</literal> a query "
"condition like <literal>WHERE a = 5 AND b = 6</literal> could use the index, "
"but a query like <literal>WHERE a = 5 OR b = 6</literal> could not directly "
"use the index."
msgstr ""
"При простом сканировании индекса могут обрабатываться только те предложения "
"в запросе, в которых применяются операторы его класса и объединяет их "
"<literal>AND</literal>. Например, для индекса <literal>(a, b)</literal> "
"условие запроса <literal>WHERE a = 5 AND b = 6</literal> сможет использовать "
"этот индекс, а запрос <literal>WHERE a = 5 OR b = 6</literal> &mdash; нет."

#: indices.xml:582(para)
msgid ""
"Fortunately, <productname>PostgreSQL</productname> has the ability to "
"combine multiple indexes (including multiple uses of the same index) to "
"handle cases that cannot be implemented by single index scans. The system "
"can form <literal>AND</literal> and <literal>OR</literal> conditions across "
"several index scans. For example, a query like <literal>WHERE x = 42 OR x = "
"47 OR x = 53 OR x = 99</literal> could be broken down into four separate "
"scans of an index on <literal>x</literal>, each scan using one of the query "
"clauses. The results of these scans are then ORed together to produce the "
"result. Another example is that if we have separate indexes on <literal>x</"
"literal> and <literal>y</literal>, one possible implementation of a query "
"like <literal>WHERE x = 5 AND y = 6</literal> is to use each index with the "
"appropriate query clause and then AND together the index results to identify "
"the result rows."
msgstr ""
"К счастью, <productname>PostgreSQL</productname> способен соединять "
"несколько индексов (и в том числе многократно применять один индекс) и "
"охватывать также случаи, когда сканирования одного индекса недостаточно. "
"Система может сформировать условия <literal>AND</literal> и <literal>OR</"
"literal> за несколько проходов индекса. Например, запрос <literal>WHERE x = "
"42 OR x = 47 OR x = 53 OR x = 99</literal> можно разбить на четыре "
"сканирования индекса по <literal>x</literal>, по сканированию для каждой "
"части условия. Затем результаты этих сканирований будут логически сложены "
"(OR) вместе и дадут конечный результат. Другой пример &mdash; если у нас "
"есть отдельные индексы по <literal>x</literal> и <literal>y</literal>, "
"запрос <literal>WHERE x = 5 AND y = 6</literal> можно выполнить, применив "
"индексы для соответствующих частей запроса, а затем вычислив логическое "
"произведение (AND) для найденных строк, которое и станет конечным "
"результатом."

#: indices.xml:598(para)
msgid ""
"To combine multiple indexes, the system scans each needed index and prepares "
"a <firstterm>bitmap</firstterm> in memory giving the locations of table rows "
"that are reported as matching that index's conditions. The bitmaps are then "
"ANDed and ORed together as needed by the query. Finally, the actual table "
"rows are visited and returned. The table rows are visited in physical order, "
"because that is how the bitmap is laid out; this means that any ordering of "
"the original indexes is lost, and so a separate sort step will be needed if "
"the query has an <literal>ORDER BY</literal> clause. For this reason, and "
"because each additional index scan adds extra time, the planner will "
"sometimes choose to use a simple index scan even though additional indexes "
"are available that could have been used as well."
msgstr ""
"Выполняя объединение нескольких индексов, система сканирует все необходимые "
"индексы и создаёт в памяти <firstterm>битовую карту</firstterm> расположения "
"строк таблицы, которые удовлетворяют условиям каждого индекса. Затем битовые "
"карты объединяются операциями AND и OR, как того требуют условия в запросе. "
"Наконец система обращается к соответствующим отмеченным строкам таблицы и "
"возвращает их данные. Строки таблицы просматриваются в физическом порядке, "
"как они представлены в битовой карте; это означает, что порядок сортировки "
"индексов при этом теряется и в запросах с предложением <literal>ORDER BY</"
"literal> сортировка будет выполняться отдельно. По этой причине, а также "
"потому, что каждое сканирование индекса занимает дополнительное время, "
"планировщик иногда выбирает простое сканирование индекса, несмотря на то, "
"что можно было бы подключить и дополнительные индексы."

#: indices.xml:613(para)
msgid ""
"In all but the simplest applications, there are various combinations of "
"indexes that might be useful, and the database developer must make trade-"
"offs to decide which indexes to provide. Sometimes multicolumn indexes are "
"best, but sometimes it's better to create separate indexes and rely on the "
"index-combination feature. For example, if your workload includes a mix of "
"queries that sometimes involve only column <literal>x</literal>, sometimes "
"only column <literal>y</literal>, and sometimes both columns, you might "
"choose to create two separate indexes on <literal>x</literal> and "
"<literal>y</literal>, relying on index combination to process the queries "
"that use both columns. You could also create a multicolumn index on "
"<literal>(x, y)</literal>. This index would typically be more efficient than "
"index combination for queries involving both columns, but as discussed in "
"<xref linkend=\"indexes-multicolumn\"/>, it would be almost useless for "
"queries involving only <literal>y</literal>, so it should not be the only "
"index. A combination of the multicolumn index and a separate index on "
"<literal>y</literal> would serve reasonably well. For queries involving only "
"<literal>x</literal>, the multicolumn index could be used, though it would "
"be larger and hence slower than an index on <literal>x</literal> alone. The "
"last alternative is to create all three indexes, but this is probably only "
"reasonable if the table is searched much more often than it is updated and "
"all three types of query are common. If one of the types of query is much "
"less common than the others, you'd probably settle for creating just the two "
"indexes that best match the common types."
msgstr ""
"В большинстве приложений (кроме самых простых) полезными могут оказаться "
"различные комбинации индексов, поэтому разработчик баз данных, определяя "
"набор индексов, должен искать компромиссное решение. Иногда оказываются "
"хороши составные индексы, а иногда лучше создать отдельные индексы и "
"положиться на возможности объединения индексов. Например, если типичную "
"нагрузку составляют запросы иногда с условием только по столбцу <literal>x</"
"literal>, иногда только по <literal>y</literal>, а иногда по обоим столбцам, "
"вы можете ограничиться двумя отдельными индексами по <literal>x</literal> и "
"<literal>y</literal>, рассчитывая на то, что при обработке условий с обоими "
"столбцами эти индексы будут объединяться. С другой стороны, вы можете "
"создать один составной индекс по <literal>(x, y)</literal>. Этот индекс "
"скорее всего будет работать эффективнее, чем объединение индексов, в "
"запросах с двумя столбцами, но как говорилось в <xref remap=\"6\" linkend="
"\"indexes-multicolumn\"/>, он будет практически бесполезен для запросов с "
"ограничениями только по <literal>y</literal>, так что одного этого индекса "
"будет недостаточно. Выигрышным в этом случае может быть сочетание составного "
"индекса с отдельным индексом по <literal>y</literal>. В запросах, где "
"задействуется только <literal>x</literal>, может применяться составной "
"индекс, хотя он будет больше и, следовательно, медленнее индекса по одному "
"<literal>x</literal>. Наконец, можно создать все три индекса, но это будет "
"оправдано, только если данные в таблице изменяются гораздо реже, чем "
"выполняется поиск в таблице, при этом частота запросов этих трёх типов "
"примерно одинакова. Если запросы какого-то одного типа выполняются гораздо "
"реже других, возможно лучше будет оставить только два индекса, "
"соответствующих наиболее частым запросам."

#: indices.xml:644(title)
msgid "Unique Indexes"
msgstr "Уникальные индексы"

#: indices.xml:646(indexterm)
msgid "<primary>index</primary> <secondary>unique</secondary>"
msgstr "<primary>индекс</primary> <secondary>уникальный</secondary>"

#: indices.xml:651(para)
msgid ""
"Indexes can also be used to enforce uniqueness of a column's value, or the "
"uniqueness of the combined values of more than one column. <synopsis>\n"
"CREATE UNIQUE INDEX <replaceable>name</replaceable> ON <replaceable>table</"
"replaceable> (<replaceable>column</replaceable> <optional>, ...</"
"optional>);\n"
"</synopsis> Currently, only B-tree indexes can be declared unique."
msgstr ""
"Индексы также могут обеспечивать уникальность значения в столбце или "
"уникальность сочетания значений в нескольких столбцах. <synopsis>\n"
"CREATE UNIQUE INDEX <replaceable>имя</replaceable> ON <replaceable>таблица</"
"replaceable> (<replaceable>столбец</replaceable> <optional>, ...</"
"optional>);\n"
"</synopsis> В настоящее время уникальными могут быть только индексы-B-"
"деревья."

#: indices.xml:660(para)
msgid ""
"When an index is declared unique, multiple table rows with equal indexed "
"values are not allowed. Null values are not considered equal. A multicolumn "
"unique index will only reject cases where all indexed columns are equal in "
"multiple rows."
msgstr ""
"Если индекс создаётся как уникальный, в таблицу нельзя будет добавить "
"несколько строк с одинаковыми значениями ключа индекса. При этом значения "
"NULL считаются не равными друг другу. Составной уникальный индекс не "
"принимает только те строки, в которых все индексируемые столбцы содержат "
"одинаковые значения."

#: indices.xml:667(para)
msgid ""
"<productname>PostgreSQL</productname> automatically creates a unique index "
"when a unique constraint or primary key is defined for a table. The index "
"covers the columns that make up the primary key or unique constraint (a "
"multicolumn index, if appropriate), and is the mechanism that enforces the "
"constraint."
msgstr ""
"Когда для таблицы определяется ограничение уникальности или первичный ключ, "
"<productname>PostgreSQL</productname> автоматически создаёт уникальный "
"индекс по всем столбцам, составляющим это ограничение или первичный ключ "
"(индекс может быть составным). Такой индекс и является механизмом, который "
"обеспечивает выполнение ограничения."

#: indices.xml:676(para)
msgid ""
"There's no need to manually create indexes on unique columns; doing so would "
"just duplicate the automatically-created index."
msgstr ""
"Для уникальных столбцов не нужно вручную создавать отдельные индексы — они "
"просто продублируют индексы, созданные автоматически."

#: indices.xml:686(title)
msgid "Indexes on Expressions"
msgstr "Индексы по выражениям"

#: indices.xml:688(indexterm)
msgid ""
"<primary>index</primary> <secondary sortas=\"expressions\">on expressions</"
"secondary>"
msgstr ""
"<primary>индекс</primary> <secondary sortas=\"expressions\">по выражению</"
"secondary>"

#: indices.xml:693(para)
msgid ""
"An index column need not be just a column of the underlying table, but can "
"be a function or scalar expression computed from one or more columns of the "
"table. This feature is useful to obtain fast access to tables based on the "
"results of computations."
msgstr ""
"Индекс можно создать не только по столбцу нижележащей таблицы, но и по "
"функции или скалярному выражению с одним или несколькими столбцами таблицы. "
"Это позволяет быстро находить данные в таблице по результатам вычислений."

#: indices.xml:703(programlisting)
#, no-wrap
msgid "SELECT * FROM test1 WHERE lower(col1) = 'value';"
msgstr "SELECT * FROM test1 WHERE lower(col1) = 'value';"

#: indices.xml:709(programlisting)
#, no-wrap
msgid "CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));"
msgstr "CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));"

#: indices.xml:700(para)
msgid ""
"For example, a common way to do case-insensitive comparisons is to use the "
"<function>lower</function> function: <placeholder-1/> This query can use an "
"index if one has been defined on the result of the <literal>lower(col1)</"
"literal> function: <placeholder-2/>"
msgstr ""
"Например, для сравнений без учёта регистра символов часто используется "
"функция <function>lower</function>: <placeholder-1/> Этот запрос сможет "
"использовать индекс, определённый для результата функции "
"<literal>lower(col1)</literal> так: <placeholder-2/>"

#: indices.xml:714(para)
msgid ""
"If we were to declare this index <literal>UNIQUE</literal>, it would prevent "
"creation of rows whose <literal>col1</literal> values differ only in case, "
"as well as rows whose <literal>col1</literal> values are actually identical. "
"Thus, indexes on expressions can be used to enforce constraints that are not "
"definable as simple unique constraints."
msgstr ""
"Если мы объявим этот индекс уникальным (<literal>UNIQUE</literal>), он не "
"даст добавить строки, в которых значения <literal>col1</literal> различаются "
"только регистром, как и те, в которых значения <literal>col1</literal> "
"действительно одинаковые. Таким образом, индексы по выражениям можно "
"использовать ещё и для обеспечения ограничений, которые нельзя записать как "
"простые ограничения уникальности."

#: indices.xml:724(programlisting)
#, no-wrap
msgid "SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';"
msgstr "SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';"

#: indices.xml:728(programlisting)
#, no-wrap
msgid "CREATE INDEX people_names ON people ((first_name || ' ' || last_name));"
msgstr "CREATE INDEX people_names ON people ((first_name || ' ' || last_name));"

#: indices.xml:722(para)
msgid ""
"As another example, if one often does queries like: <placeholder-1/> then it "
"might be worth creating an index like this: <placeholder-2/>"
msgstr ""
"Если же часто выполняются запросы вида: <placeholder-1/> тогда, возможно, "
"стоит создать такой индекс: <placeholder-2/>"

#: indices.xml:733(para)
msgid ""
"The syntax of the <command>CREATE INDEX</command> command normally requires "
"writing parentheses around index expressions, as shown in the second "
"example. The parentheses can be omitted when the expression is just a "
"function call, as in the first example."
msgstr ""
"Синтаксис команды <command>CREATE INDEX</command> обычно требует заключать "
"индексные выражения в скобки, как показано во втором примере. Если же "
"выражение представляет собой просто вызов функции, как в первом примере, "
"дополнительные скобки можно опустить."

#: indices.xml:740(para)
msgid ""
"Index expressions are relatively expensive to maintain, because the derived "
"expression(s) must be computed for each row upon insertion and whenever it "
"is updated. However, the index expressions are <emphasis>not</emphasis> "
"recomputed during an indexed search, since they are already stored in the "
"index. In both examples above, the system sees the query as just "
"<literal>WHERE indexedcolumn = 'constant'</literal> and so the speed of the "
"search is equivalent to any other simple index query. Thus, indexes on "
"expressions are useful when retrieval speed is more important than insertion "
"and update speed."
msgstr ""
"Поддержка индексируемых выражений обходится довольно дорого, так как эти "
"выражения должны вычисляться при добавлении каждой строки и при каждом "
"последующем изменении. Однако при поиске по индексу индексируемое выражение "
"<emphasis>не</emphasis> вычисляется повторно, так как его результат уже "
"сохранён в индексе. В рассмотренных выше случаях система видит запрос как "
"<literal>WHERE столбец_индекса = 'константа'</literal> и поэтому поиск "
"выполняется так же быстро, как и с простым индексом. Таким образом, индексы "
"по выражениям могут быть полезны, когда скорость извлечения данных гораздо "
"важнее скорости добавления и изменения."

#: indices.xml:755(title)
msgid "Partial Indexes"
msgstr "Частичные индексы"

#: indices.xml:757(indexterm)
msgid "<primary>index</primary> <secondary>partial</secondary>"
msgstr "<primary>индекс</primary> <secondary>частичный</secondary>"

#: indices.xml:762(para)
msgid ""
"A <firstterm>partial index</firstterm> is an index built over a subset of a "
"table; the subset is defined by a conditional expression (called the "
"<firstterm>predicate</firstterm> of the partial index). The index contains "
"entries only for those table rows that satisfy the predicate. Partial "
"indexes are a specialized feature, but there are several situations in which "
"they are useful."
msgstr ""
"<firstterm>Частичный индекс</firstterm> &mdash; это индекс, который строится "
"по подмножеству строк таблицы, определяемому условным выражением (оно "
"называется <firstterm>предикатом</firstterm> частичного индекса). Такой "
"индекс содержит записи только для строк, удовлетворяющих предикату. "
"Частичные индексы довольно специфичны, но в ряде ситуаций они могут быть "
"очень полезны."

#: indices.xml:771(para)
msgid ""
"One major reason for using a partial index is to avoid indexing common "
"values. Since a query searching for a common value (one that accounts for "
"more than a few percent of all the table rows) will not use the index "
"anyway, there is no point in keeping those rows in the index at all. This "
"reduces the size of the index, which will speed up those queries that do use "
"the index. It will also speed up many table update operations because the "
"index does not need to be updated in all cases. <xref linkend=\"indexes-"
"partial-ex1\"/> shows a possible application of this idea."
msgstr ""
"Частичные индексы могут быть полезны, во-первых, тем, что позволяют избежать "
"индексирования распространённых значений. Так как при поиске "
"распространённого значения (такого, которое содержится в значительном "
"проценте всех строк) индекс всё равно не будет использоваться, хранить эти "
"строки в индексе нет смысла. Исключив их из индекса, можно уменьшить его "
"размер, а значит и ускорить запросы, использующие этот индекс. Это также "
"может ускорить операции изменения данных в таблице, так как индекс будет "
"обновляться не всегда. Возможное применение этой идеи проиллюстрировано в "
"<xref remap=\"6\" linkend=\"indexes-partial-ex1\"/>."

#: indices.xml:784(title)
msgid "Setting up a Partial Index to Exclude Common Values"
msgstr "Настройка частичного индекса, исключающего распространённые значения"

#: indices.xml:786(para)
msgid ""
"Suppose you are storing web server access logs in a database. Most accesses "
"originate from the IP address range of your organization but some are from "
"elsewhere (say, employees on dial-up connections). If your searches by IP "
"are primarily for outside accesses, you probably do not need to index the IP "
"range that corresponds to your organization's subnet."
msgstr ""
"Предположим, что вы храните в базе данных журнал обращений к корпоративному "
"сайту. Большая часть обращений будет происходить из диапазона IP-адресов "
"вашей компании, а остальные могут быть откуда угодно (например, к нему могут "
"подключаться внешние сотрудники с динамическими IP). Если при поиске по IP "
"вас обычно интересуют внешние подключения, IP-диапазон внутренней сети "
"компании можно не включать в индекс."

#: indices.xml:797(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE access_log (\n"
"    url varchar,\n"
"    client_ip inet,\n"
"    ...\n"
");"
msgstr ""
"CREATE TABLE access_log (\n"
"    url varchar,\n"
"    client_ip inet,\n"
"    ...\n"
");"

#: indices.xml:795(para)
msgid "Assume a table like this: <placeholder-1/>"
msgstr "Пусть у вас есть такая таблица: <placeholder-1/>"

#: indices.xml:809(programlisting)
#, no-wrap
msgid ""
"CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)\n"
"WHERE NOT (client_ip &gt; inet '192.168.100.0' AND\n"
"           client_ip &lt; inet '192.168.100.255');"
msgstr ""
"CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)\n"
"WHERE NOT (client_ip &gt; inet '192.168.100.0' AND\n"
"           client_ip &lt; inet '192.168.100.255');"

#: indices.xml:806(para)
msgid ""
"To create a partial index that suits our example, use a command such as "
"this: <placeholder-1/>"
msgstr ""
"Создать частичный индекс для нашего примера можно так: <placeholder-1/>"

#: indices.xml:818(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"FROM access_log\n"
"WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';"
msgstr ""
"SELECT *\n"
"FROM access_log\n"
"WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';"

#: indices.xml:824(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"FROM access_log\n"
"WHERE client_ip = inet '192.168.100.23';"
msgstr ""
"SELECT *\n"
"FROM access_log\n"
"WHERE client_ip = inet '192.168.100.23';"

#: indices.xml:816(para)
msgid ""
"A typical query that can use this index would be: <placeholder-1/> A query "
"that cannot use this index is: <placeholder-2/>"
msgstr ""
"Так будет выглядеть типичный запрос, использующий этот индекс: "
"<placeholder-1/> А следующий запрос не будет использовать этот индекс: "
"<placeholder-2/>"

#: indices.xml:831(para)
msgid ""
"Observe that this kind of partial index requires that the common values be "
"predetermined, so such partial indexes are best used for data distributions "
"that do not change. The indexes can be recreated occasionally to adjust for "
"new data distributions, but this adds maintenance effort."
msgstr ""
"Заметьте, что при таком определении частичного индекса необходимо, чтобы "
"распространённые значения были известны заранее, так что такие индексы лучше "
"использовать, когда распределение данных не меняется. Хотя такие индексы "
"можно пересоздавать время от времени, подстраиваясь под новое распределение, "
"это значительно усложняет поддержку."

#: indices.xml:840(para)
msgid ""
"Another possible use for a partial index is to exclude values from the index "
"that the typical query workload is not interested in; this is shown in <xref "
"linkend=\"indexes-partial-ex2\"/>. This results in the same advantages as "
"listed above, but it prevents the <quote>uninteresting</quote> values from "
"being accessed via that index, even if an index scan might be profitable in "
"that case. Obviously, setting up partial indexes for this kind of scenario "
"will require a lot of care and experimentation."
msgstr ""
"Во-вторых, частичные индексы могут быть полезны тем, что позволяют исключить "
"из индекса значения, которые обычно не представляют интереса; это "
"проиллюстрировано в <xref remap=\"6\" linkend=\"indexes-partial-ex2\"/>. При "
"этом вы получаете те же преимущества, что и в предыдущем случае, но система "
"не сможет извлечь <quote>неинтересные</quote> значения по этому индексу, "
"даже если сканирование индекса может быть эффективным. Очевидно, настройка "
"частичных индексов в таких случаях требует тщательного анализа и "
"тестирования."

#: indices.xml:853(title)
msgid "Setting up a Partial Index to Exclude Uninteresting Values"
msgstr "Настройка частичного индекса, исключающего неинтересные значения"

#: indices.xml:861(programlisting)
#, no-wrap
msgid ""
"CREATE INDEX orders_unbilled_index ON orders (order_nr)\n"
"    WHERE billed is not true;"
msgstr ""
"CREATE INDEX orders_unbilled_index ON orders (order_nr)\n"
"    WHERE billed is not true;"

#: indices.xml:855(para)
msgid ""
"If you have a table that contains both billed and unbilled orders, where the "
"unbilled orders take up a small fraction of the total table and yet those "
"are the most-accessed rows, you can improve performance by creating an index "
"on just the unbilled rows. The command to create the index would look like "
"this: <placeholder-1/>"
msgstr ""
"Если у вас есть таблица, в которой хранятся и оплаченные, и неоплаченные "
"счета, и при этом неоплаченные счета составляют только небольшую часть всей "
"таблицы, но представляют наибольший интерес, производительность запросов "
"можно увеличить, создав индекс только по неоплаченным счетам. Сделать это "
"можно следующей командой: <placeholder-1/>"

#: indices.xml:869(programlisting)
#, no-wrap
msgid "SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;"
msgstr "SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;"

#: indices.xml:874(programlisting)
#, no-wrap
msgid "SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;"
msgstr "SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;"

#: indices.xml:867(para)
msgid ""
"A possible query to use this index would be: <placeholder-1/> However, the "
"index can also be used in queries that do not involve <structfield>order_nr</"
"structfield> at all, e.g.: <placeholder-2/> This is not as efficient as a "
"partial index on the <structfield>amount</structfield> column would be, "
"since the system has to scan the entire index. Yet, if there are relatively "
"few unbilled orders, using this partial index just to find the unbilled "
"orders could be a win."
msgstr ""
"Этот индекс будет применяться, например в таком запросе: <placeholder-1/> "
"Однако он также может применяться в запросах, где <structfield>order_nr</"
"structfield> вообще не используется, например: <placeholder-2/> Конечно, он "
"будет не так эффективен, как мог бы быть частичный индекс по столбцу "
"<structfield>amount</structfield>, так как системе придётся сканировать его "
"целиком. Тем не менее, если неоплаченных счетов сравнительно мало, выиграть "
"при поиске неоплаченного счёта можно и с таким частичным индексом."

#: indices.xml:886(programlisting)
#, no-wrap
msgid "SELECT * FROM orders WHERE order_nr = 3501;"
msgstr "SELECT * FROM orders WHERE order_nr = 3501;"

#: indices.xml:884(para)
msgid ""
"Note that this query cannot use this index: <placeholder-1/> The order 3501 "
"might be among the billed or unbilled orders."
msgstr ""
"Заметьте, что в таком запросе этот индекс не будет использоваться: "
"<placeholder-1/> Счёт с номером 3501 может оказаться, как в числе "
"неоплаченных, так и оплаченных."

#: indices.xml:894(para)
msgid ""
"<xref linkend=\"indexes-partial-ex2\"/> also illustrates that the indexed "
"column and the column used in the predicate do not need to match. "
"<productname>PostgreSQL</productname> supports partial indexes with "
"arbitrary predicates, so long as only columns of the table being indexed are "
"involved. However, keep in mind that the predicate must match the conditions "
"used in the queries that are supposed to benefit from the index. To be "
"precise, a partial index can be used in a query only if the system can "
"recognize that the <literal>WHERE</literal> condition of the query "
"mathematically implies the predicate of the index. <productname>PostgreSQL</"
"productname> does not have a sophisticated theorem prover that can recognize "
"mathematically equivalent expressions that are written in different forms. "
"(Not only is such a general theorem prover extremely difficult to create, it "
"would probably be too slow to be of any real use.) The system can recognize "
"simple inequality implications, for example <quote>x &lt; 1</quote> implies "
"<quote>x &lt; 2</quote>; otherwise the predicate condition must exactly "
"match part of the query's <literal>WHERE</literal> condition or the index "
"will not be recognized as usable. Matching takes place at query planning "
"time, not at run time. As a result, parameterized query clauses do not work "
"with a partial index. For example a prepared query with a parameter might "
"specify <quote>x &lt; ?</quote> which will never imply <quote>x &lt; 2</"
"quote> for all possible values of the parameter."
msgstr ""
"<xref linkend=\"indexes-partial-ex2\"/> также показывает, что индексируемый "
"столбец не обязательно должен совпадать со столбцом, используемым в "
"предикате. <productname>PostgreSQL</productname> поддерживает частичные "
"индексы с произвольными предикатами &mdash; главное, чтобы в них "
"фигурировали только столбцы индексируемой таблицы. Однако не забывайте, что "
"предикат должен соответствовать условиям запросов, для оптимизации которых "
"предназначается данный индекс. Точнее, частичный индекс будет применяться в "
"запросе, только если система сможет понять, что условие <literal>WHERE</"
"literal> данного запроса математически сводится к предикату индекса. Но "
"учтите, что <productname>PostgreSQL</productname> не умеет доказывать "
"математические утверждения об эквивалентности выражений, записанных в разных "
"формах. (Составить программу для таких доказательств крайне сложно, и если "
"даже это удастся, скорость её будет неприемлема для применения на практике.) "
"Система может выявить только самые простые следствия с неравенствами; "
"например, понять, что из <quote>x &lt; 1</quote> следует <quote>x &lt; 2</"
"quote>; во всех остальных случаях условие предиката должно точно совпадать с "
"условием в предложении <literal>WHERE</literal>, иначе индекс будет "
"считаться неподходящим. Сопоставление условий происходит во время "
"планирования запросов, а не во время выполнения. Как следствие, запросы с "
"параметрами не будут работать с частичными индексами. Например, условие с "
"параметром <quote>x &lt; ?</quote> в подготовленном запросе никогда не будет "
"сведено к <quote>x &lt; 2</quote> при всех возможных значениях параметра."

#: indices.xml:922(para)
msgid ""
"A third possible use for partial indexes does not require the index to be "
"used in queries at all. The idea here is to create a unique index over a "
"subset of a table, as in <xref linkend=\"indexes-partial-ex3\"/>. This "
"enforces uniqueness among the rows that satisfy the index predicate, without "
"constraining those that do not."
msgstr ""
"Третье возможное применение частичных индексов вообще не связано с "
"использованием индекса в запросах. Идея заключается в том, чтобы создать "
"уникальный индекс по подмножеству строк таблицы, как в <xref remap=\"6\" "
"linkend=\"indexes-partial-ex3\"/>. Это обеспечит уникальность среди строк, "
"удовлетворяющих условию предиката, но никак не будет ограничивать остальные."

#: indices.xml:932(title)
msgid "Setting up a Partial Unique Index"
msgstr "Настройка частичного уникального индекса"

#: indices.xml:939(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE tests (\n"
"    subject text,\n"
"    target text,\n"
"    success boolean,\n"
"    ...\n"
");\n"
"\n"
"CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)\n"
"    WHERE success;"
msgstr ""
"CREATE TABLE tests (\n"
"    subject text,\n"
"    target text,\n"
"    success boolean,\n"
"    ...\n"
");\n"
"\n"
"CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)\n"
"    WHERE success;"

#: indices.xml:934(para)
msgid ""
"Suppose that we have a table describing test outcomes. We wish to ensure "
"that there is only one <quote>successful</quote> entry for a given subject "
"and target combination, but there might be any number of "
"<quote>unsuccessful</quote> entries. Here is one way to do it: "
"<placeholder-1/> This is a particularly efficient approach when there are "
"few successful tests and many unsuccessful ones."
msgstr ""
"Предположим, что у нас есть таблица с результатами теста. Мы хотим, чтобы "
"для каждого сочетания предмета и целевой темы была только одна запись об "
"успешном результате, а неудачных попыток могло быть много. Вот как можно "
"этого добиться: <placeholder-1/> Это подход будет особенно эффективным, "
"когда неудачных попыток будет намного больше, чем удачных."

#: indices.xml:955(para)
msgid ""
"Finally, a partial index can also be used to override the system's query "
"plan choices. Also, data sets with peculiar distributions might cause the "
"system to use an index when it really should not. In that case the index can "
"be set up so that it is not available for the offending query. Normally, "
"<productname>PostgreSQL</productname> makes reasonable choices about index "
"usage (e.g., it avoids them when retrieving common values, so the earlier "
"example really only saves index size, it is not required to avoid index "
"usage), and grossly incorrect plan choices are cause for a bug report."
msgstr ""
"Наконец, с помощью частичных индексов можно также переопределять выбираемый "
"системой план запроса. Возможно, что для данных с неудачным распределением "
"система решит использовать индекс, тогда как на самом деле это неэффективно. "
"В этом случае индекс можно настроить так, чтобы в подобных запросах он не "
"работал. Обычно <productname>PostgreSQL</productname> принимает разумные "
"решения относительно применения индексов (т. е. старается не использовать их "
"для получения распространённых значений, так что частичный индекс в "
"вышеприведённом примере помог только уменьшить размер индекса, для отказа от "
"использования индекса он не требовался), поэтому крайне неэффективный план "
"может быть поводом для сообщения об ошибке."

#: indices.xml:968(para)
msgid ""
"Keep in mind that setting up a partial index indicates that you know at "
"least as much as the query planner knows, in particular you know when an "
"index might be profitable. Forming this knowledge requires experience and "
"understanding of how indexes in <productname>PostgreSQL</productname> work. "
"In most cases, the advantage of a partial index over a regular index will be "
"minimal."
msgstr ""
"Помните, что настраивая частичный индекс, вы тем самым заявляете, что знаете "
"о данных гораздо больше, чем планировщик запросов. В частности, вы знаете, "
"когда такой индекс может быть полезен. Это знание обязательно должно "
"подкрепляться опытом и пониманием того, как работают индексы в "
"<productname>PostgreSQL</productname>. В большинстве случаев преимущества "
"частичных индексов по сравнению с обычными будут минимальными."

#: indices.xml:977(para)
msgid ""
"More information about partial indexes can be found in <xref linkend="
"\"ston89b\"/>, <xref linkend=\"olson93\"/>, and <xref linkend=\"seshadri95\"/"
">."
msgstr ""
"Узнать о частичных индексах больше можно в следующих источниках: <xref "
"linkend=\"ston89b\"/>, <xref linkend=\"olson93\"/> и <xref linkend="
"\"seshadri95\"/>."

#: indices.xml:986(title)
msgid "Operator Classes and Operator Families"
msgstr "Семейства и классы операторов"

#: indices.xml:988(indexterm)
msgid "<primary>operator class</primary>"
msgstr "<primary>класс операторов</primary>"

#: indices.xml:992(indexterm)
msgid "<primary>operator family</primary>"
msgstr "<primary>семейство операторов</primary>"

#: indices.xml:996(para)
msgid ""
"An index definition can specify an <firstterm>operator class</firstterm> for "
"each column of an index. <synopsis>\n"
"CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</"
"replaceable> (<replaceable>column</replaceable> <replaceable>opclass</"
"replaceable> <optional><replaceable>sort options</replaceable></optional> "
"<optional>, ...</optional>);\n"
"</synopsis> The operator class identifies the operators to be used by the "
"index for that column. For example, a B-tree index on the type <type>int4</"
"type> would use the <literal>int4_ops</literal> class; this operator class "
"includes comparison functions for values of type <type>int4</type>. In "
"practice the default operator class for the column's data type is usually "
"sufficient. The main reason for having operator classes is that for some "
"data types, there could be more than one meaningful index behavior. For "
"example, we might want to sort a complex-number data type either by absolute "
"value or by real part. We could do this by defining two operator classes for "
"the data type and then selecting the proper class when making an index. The "
"operator class determines the basic sort ordering (which can then be "
"modified by adding sort options <literal>COLLATE</literal>, <literal>ASC</"
"literal>/<literal>DESC</literal> and/or <literal>NULLS FIRST</literal>/"
"<literal>NULLS LAST</literal>)."
msgstr ""
"В определении индекса можно указать <firstterm>класс операторов</firstterm> "
"для каждого столбца индекса. <synopsis>\n"
"CREATE INDEX <replaceable>имя</replaceable> ON <replaceable>таблица</"
"replaceable> (<replaceable>столбец</replaceable> "
"<replaceable>класс_операторов</replaceable> <optional><replaceable>параметры "
"сортировки</replaceable></optional> <optional>, ...</optional>);\n"
"</synopsis> Класс операторов определяет, какие операторы будет использовать "
"индекс для этого столбца. Например, индекс-B-дерево по столбцу <type>int4</"
"type> будет использовать класс <literal>int4_ops</literal>; этот класс "
"операторов включает операции со значениями типа <type>int4</type>. На "
"практике часто достаточно принять класс операторов, назначенный для типа "
"столбца классом по умолчанию. Однако для некоторых типов данных могут иметь "
"смысл несколько разных вариантов индексирования и реализовать их как раз "
"позволяют разные классы операторов. Например, комплексные числа можно "
"сортировать как по вещественной части, так и по модулю. Получить два "
"варианта индексов для них можно, определив два класса операторов для данного "
"типа и выбрав соответствующий класс при создании индекса. Выбранный класс "
"операторов задаст основной порядок сортировки данных (его можно уточнить, "
"добавив параметры <literal>COLLATE</literal>, <literal>ASC</literal>/"
"<literal>DESC</literal> и/или <literal>NULLS FIRST</literal>/<literal>NULLS "
"LAST</literal>)."

#: indices.xml:1038(programlisting)
#, no-wrap
msgid "CREATE INDEX test_index ON test_table (col varchar_pattern_ops);"
msgstr "CREATE INDEX test_index ON test_table (col varchar_pattern_ops);"

#: indices.xml:1024(para)
msgid ""
"The operator classes <literal>text_pattern_ops</literal>, "
"<literal>varchar_pattern_ops</literal>, and <literal>bpchar_pattern_ops</"
"literal> support B-tree indexes on the types <type>text</type>, "
"<type>varchar</type>, and <type>char</type> respectively. The difference "
"from the default operator classes is that the values are compared strictly "
"character by character rather than according to the locale-specific "
"collation rules. This makes these operator classes suitable for use by "
"queries involving pattern matching expressions (<literal>LIKE</literal> or "
"POSIX regular expressions) when the database does not use the standard "
"<quote>C</quote> locale. As an example, you might index a <type>varchar</"
"type> column like this: <placeholder-1/> Note that you should also create an "
"index with the default operator class if you want queries involving ordinary "
"<literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal>, "
"or <literal>&gt;=</literal> comparisons to use an index. Such queries cannot "
"use the <literal><replaceable>xxx</replaceable>_pattern_ops</literal> "
"operator classes. (Ordinary equality comparisons can use these operator "
"classes, however.) It is possible to create multiple indexes on the same "
"column with different operator classes. If you do use the C locale, you do "
"not need the <literal><replaceable>xxx</replaceable>_pattern_ops</literal> "
"operator classes, because an index with the default operator class is usable "
"for pattern-matching queries in the C locale."
msgstr ""
"Классы операторов <literal>text_pattern_ops</literal>, "
"<literal>varchar_pattern_ops</literal> и <literal>bpchar_pattern_ops</"
"literal> поддерживают индексы-B-деревья для типов <type>text</type>, "
"<type>varchar</type> и <type>char</type>, соответственно. От стандартных "
"классов операторов они отличаются тем, что сравнивают значения по символам, "
"не применяя правила сортировки, определённые локалью. Благодаря этому они "
"подходят для запросов с поиском по шаблону (с <literal>LIKE</literal> и "
"регулярными выражениями POSIX), когда локаль базы данных не стандартная "
"<quote>C</quote>. Например, вы можете проиндексировать столбец "
"<type>varchar</type> так: <placeholder-1/> Заметьте, что при этом также "
"следует создать индекс с классом операторов по умолчанию, если вы хотите "
"ускорить запросы с обычными сравнениями <literal>&lt;</literal>, "
"<literal>&lt;=</literal>, <literal>&gt;</literal> и <literal>&gt;=</literal> "
"за счёт применения индексов. Классы операторов <literal><replaceable>xxx</"
"replaceable>_pattern_ops</literal> не подходят для таких сравнений. (Однако "
"для проверки равенств эти классы операторов вполне пригодны.) В подобных "
"случаях для одного столбца можно создать несколько индексов с разными "
"классами операторов. Если же вы используете локаль C, классы операторов "
"<literal><replaceable>xxx</replaceable>_pattern_ops</literal> вам не нужны, "
"так как для поиска по шаблону в локали C будет достаточно индексов с классом "
"операторов по умолчанию."

#: indices.xml:1019(para)
msgid ""
"There are also some built-in operator classes besides the default ones: "
"<placeholder-1/>"
msgstr ""
"Помимо классов операторов по умолчанию есть ещё несколько встроенных: "
"<placeholder-1/>"

#: indices.xml:1061(programlisting)
#, no-wrap
msgid ""
"SELECT am.amname AS index_method,\n"
"       opc.opcname AS opclass_name,\n"
"       opc.opcintype::regtype AS indexed_type,\n"
"       opc.opcdefault AS is_default\n"
"    FROM pg_am am, pg_opclass opc\n"
"    WHERE opc.opcmethod = am.oid\n"
"    ORDER BY index_method, opclass_name;"
msgstr ""
"SELECT am.amname AS index_method,\n"
"       opc.opcname AS opclass_name,\n"
"       opc.opcintype::regtype AS indexed_type,\n"
"       opc.opcdefault AS is_default\n"
"    FROM pg_am am, pg_opclass opc\n"
"    WHERE opc.opcmethod = am.oid\n"
"    ORDER BY index_method, opclass_name;"

#: indices.xml:1058(para)
msgid ""
"The following query shows all defined operator classes: <placeholder-1/>"
msgstr ""
"Следующий запрос выводит список всех существующих классов операторов: "
"<placeholder-1/>"

#: indices.xml:1072(para)
msgid ""
"An operator class is actually just a subset of a larger structure called an "
"<firstterm>operator family</firstterm>. In cases where several data types "
"have similar behaviors, it is frequently useful to define cross-data-type "
"operators and allow these to work with indexes. To do this, the operator "
"classes for each of the types must be grouped into the same operator family. "
"The cross-type operators are members of the family, but are not associated "
"with any single class within the family."
msgstr ""
"Класс операторов на самом деле является всего лишь подмножеством большой "
"структуры, называемой <firstterm>семейством операторов</firstterm>. В "
"случаях, когда несколько типов данных ведут себя одинаково, часто имеет "
"смысл определить операторы так, чтобы они могли использоваться с индексами "
"сразу нескольких типов. Сделать это можно, сгруппировав классы операторов "
"для этих типов в одном семействе операторов. Такие многоцелевые операторы, "
"являясь членами семейства, не будут связаны с каким-либо одним его классом."

#: indices.xml:1085(programlisting)
#, no-wrap
msgid ""
"SELECT am.amname AS index_method,\n"
"       opc.opcname AS opclass_name,\n"
"       opf.opfname AS opfamily_name,\n"
"       opc.opcintype::regtype AS indexed_type,\n"
"       opc.opcdefault AS is_default\n"
"    FROM pg_am am, pg_opclass opc, pg_opfamily opf\n"
"    WHERE opc.opcmethod = am.oid AND\n"
"          opc.opcfamily = opf.oid\n"
"    ORDER BY index_method, opclass_name;"
msgstr ""
"SELECT am.amname AS index_method,\n"
"       opc.opcname AS opclass_name,\n"
"       opf.opfname AS opfamily_name,\n"
"       opc.opcintype::regtype AS indexed_type,\n"
"       opc.opcdefault AS is_default\n"
"    FROM pg_am am, pg_opclass opc, pg_opfamily opf\n"
"    WHERE opc.opcmethod = am.oid AND\n"
"          opc.opcfamily = opf.oid\n"
"    ORDER BY index_method, opclass_name;"

#: indices.xml:1082(para)
msgid ""
"This expanded version of the previous query shows the operator family each "
"operator class belongs to: <placeholder-1/>"
msgstr ""
"Расширенная версия предыдущего запроса показывает семью операторов, к "
"которой принадлежит каждый класс операторов: <placeholder-1/>"

#: indices.xml:1101(programlisting)
#, no-wrap
msgid ""
"SELECT am.amname AS index_method,\n"
"       opf.opfname AS opfamily_name,\n"
"       amop.amopopr::regoperator AS opfamily_operator\n"
"    FROM pg_am am, pg_opfamily opf, pg_amop amop\n"
"    WHERE opf.opfmethod = am.oid AND\n"
"          amop.amopfamily = opf.oid\n"
"    ORDER BY index_method, opfamily_name, opfamily_operator;"
msgstr ""
"SELECT am.amname AS index_method,\n"
"       opf.opfname AS opfamily_name,\n"
"       amop.amopopr::regoperator AS opfamily_operator\n"
"    FROM pg_am am, pg_opfamily opf, pg_amop amop\n"
"    WHERE opf.opfmethod = am.oid AND\n"
"          amop.amopfamily = opf.oid\n"
"    ORDER BY index_method, opfamily_name, opfamily_operator;"

#: indices.xml:1098(para)
msgid ""
"This query shows all defined operator families and all the operators "
"included in each family: <placeholder-1/>"
msgstr ""
"Этот запрос выводит все существующие семейства операторов и все операторы, "
"включённые в эти семейства: <placeholder-1/>"

#: indices.xml:1115(title)
msgid "Indexes and Collations"
msgstr "Индексы и правила сортировки"

#: indices.xml:1117(para)
msgid ""
"An index can support only one collation per index column. If multiple "
"collations are of interest, multiple indexes may be needed."
msgstr ""
"Один индекс может поддерживать только одно правило сортировки для "
"индексируемого столбца. Поэтому при необходимости применять разные правила "
"сортировки могут потребоваться несколько индексов."

#: indices.xml:1124(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test1c (\n"
"    id integer,\n"
"    content varchar COLLATE \"x\"\n"
");\n"
"\n"
"CREATE INDEX test1c_content_index ON test1c (content);"
msgstr ""
"CREATE TABLE test1c (\n"
"    id integer,\n"
"    content varchar COLLATE \"x\"\n"
");\n"
"\n"
"CREATE INDEX test1c_content_index ON test1c (content);"

#: indices.xml:1134(programlisting)
#, no-wrap
msgid "SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable>;"
msgstr "SELECT * FROM test1c WHERE content &gt; <replaceable>константа</replaceable>;"

#: indices.xml:1140(programlisting)
#, no-wrap
msgid "SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable> COLLATE \"y\";"
msgstr "SELECT * FROM test1c WHERE content &gt; <replaceable>константа</replaceable> COLLATE \"y\";"

#: indices.xml:1145(programlisting)
#, no-wrap
msgid "CREATE INDEX test1c_content_y_index ON test1c (content COLLATE \"y\");"
msgstr "CREATE INDEX test1c_content_y_index ON test1c (content COLLATE \"y\");"

#: indices.xml:1122(para)
msgid ""
"Consider these statements: <placeholder-1/> The index automatically uses the "
"collation of the underlying column. So a query of the form <placeholder-2/> "
"could use the index, because the comparison will by default use the "
"collation of the column. However, this index cannot accelerate queries that "
"involve some other collation. So if queries of the form, say, <placeholder-3/"
"> are also of interest, an additional index could be created that supports "
"the <literal>\"y\"</literal> collation, like this: <placeholder-4/>"
msgstr ""
"Рассмотрим следующие операторы: <placeholder-1/> Этот индекс автоматически "
"использует правило сортировки нижележащего столбца. И запрос вида "
"<placeholder-2/> сможет использовать этот индекс, так как при сравнении по "
"умолчанию будет действовать правило сортировки столбца. Однако этот индекс "
"не поможет ускорить запросы с каким-либо другим правилом сортировки. "
"Поэтому, если интерес представляют также и запросы вроде <placeholder-3/> "
"для них можно создать дополнительный индекс, поддерживающий правило "
"сортировки <literal>\"y\"</literal>, примерно так: <placeholder-4/>"

#: indices.xml:1153(title)
msgid "Index-Only Scans"
msgstr "Сканирование только индекса"

#: indices.xml:1155(indexterm)
msgid "<primary>index</primary> <secondary>index-only scans</secondary>"
msgstr ""
"<primary>индекс</primary> <secondary>сканирование только индекса</secondary>"

#: indices.xml:1159(indexterm)
msgid "<primary>index-only scan</primary>"
msgstr "<primary>сканирование только индекса</primary>"

#: indices.xml:1163(para)
msgid ""
"All indexes in <productname>PostgreSQL</productname> are "
"<firstterm>secondary</firstterm> indexes, meaning that each index is stored "
"separately from the table's main data area (which is called the table's "
"<firstterm>heap</firstterm> in <productname>PostgreSQL</productname> "
"terminology). This means that in an ordinary index scan, each row retrieval "
"requires fetching data from both the index and the heap. Furthermore, while "
"the index entries that match a given indexable <literal>WHERE</literal> "
"condition are usually close together in the index, the table rows they "
"reference might be anywhere in the heap. The heap-access portion of an index "
"scan thus involves a lot of random access into the heap, which can be slow, "
"particularly on traditional rotating media. (As described in <xref linkend="
"\"indexes-bitmap-scans\"/>, bitmap scans try to alleviate this cost by doing "
"the heap accesses in sorted order, but that only goes so far.)"
msgstr ""
"Все индексы в <productname>PostgreSQL</productname> являются "
"<firstterm>вторичными</firstterm>, что значит, что каждый индекс хранится "
"вне области основных данных таблицы (которая в терминологии "
"<productname>PostgreSQL</productname> называется <firstterm>кучей</"
"firstterm> таблицы). Это значит, что при обычном сканировании индекса для "
"извлечения каждой строки необходимо прочитать данные и из индекса, и из "
"кучи. Более того, тогда как элементы индекса, соответствующие заданному "
"условию <literal>WHERE</literal>, обычно находятся в индексе рядом, строки "
"таблицы могут располагаться в куче произвольным образом. Таким образом, "
"обращение к куче при поиске по индексу влечёт множество операций "
"произвольного чтения кучи, которые могут обойтись недёшево, особенно на "
"традиционных вращающихся носителях. (Как описано в <xref remap=\"6\" linkend="
"\"indexes-bitmap-scans\"/>, сканирование по битовой карте пытается снизить "
"стоимость этих операций, упорядочивая доступ к куче, но не более того.)"

#: indices.xml:1189(para)
msgid ""
"The index type must support index-only scans. B-tree indexes always do. GiST "
"and SP-GiST indexes support index-only scans for some operator classes but "
"not others. Other index types have no support. The underlying requirement is "
"that the index must physically store, or else be able to reconstruct, the "
"original data value for each index entry. As a counterexample, GIN indexes "
"cannot support index-only scans because each index entry typically holds "
"only part of the original data value."
msgstr ""
"Тип индекса должен поддерживать сканирование только индекса. Индексы-B-"
"деревья поддерживают его всегда. Индексы GiST и SP-GiST могут поддерживать "
"его с одними классами операторов и не поддерживать с другими. Другие индексы "
"такое сканирование не поддерживают. Суть нижележащего требования в том, что "
"индекс должен физически хранить или каким-то образом восстанавливать "
"исходное значение данных для каждого элемента индекса. В качестве "
"контрпримера, индексы GIN неспособны поддерживать сканирование только "
"индекса, так как в элементах индекса обычно хранится только часть исходного "
"значения данных."

#: indices.xml:1207(programlisting)
#, no-wrap
msgid ""
"SELECT x, y FROM tab WHERE x = 'key';\n"
"SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;"
msgstr ""
"SELECT x, y FROM tab WHERE x = 'key';\n"
"SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;"

#: indices.xml:1212(programlisting)
#, no-wrap
msgid ""
"SELECT x, z FROM tab WHERE x = 'key';\n"
"SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;"
msgstr ""
"SELECT x, z FROM tab WHERE x = 'key';\n"
"SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;"

#: indices.xml:1202(para)
msgid ""
"The query must reference only columns stored in the index. For example, "
"given an index on columns <literal>x</literal> and <literal>y</literal> of a "
"table that also has a column <literal>z</literal>, these queries could use "
"index-only scans: <placeholder-1/> but these queries could not: "
"<placeholder-2/> (Expression indexes and partial indexes complicate this "
"rule, as discussed below.)"
msgstr ""
"Запрос должен обращаться только к столбцам, сохранённым в индексе. Например, "
"если в таблице построен индекс по столбцам <literal>x</literal> и "
"<literal>y</literal>, и в ней есть также столбец <literal>z</literal>, такие "
"запросы будут использовать сканирование только индекса: <placeholder-1/> А "
"эти запросы не будут: <placeholder-2/> (Индексы по выражениям и частичные "
"индексы усложняют это правило, как описано ниже.)"

#: indices.xml:1179(para)
msgid ""
"To solve this performance problem, <productname>PostgreSQL</productname> "
"supports <firstterm>index-only scans</firstterm>, which can answer queries "
"from an index alone without any heap access. The basic idea is to return "
"values directly out of each index entry instead of consulting the associated "
"heap entry. There are two fundamental restrictions on when this method can "
"be used: <placeholder-1/>"
msgstr ""
"Чтобы решить эту проблему с производительностью, <productname>PostgreSQL</"
"productname> поддерживает <firstterm>сканирование только индекса</"
"firstterm>, при котором результат запроса может быть получен из самого "
"индекса, без обращения к куче. Основная идея такого сканирования в том, "
"чтобы выдавать значения непосредственно из элемента индекса, и не обращаться "
"к соответствующей записи в куче. Для применения этого метода есть два "
"фундаментальных ограничения: <placeholder-1/>"

#: indices.xml:1223(para)
msgid ""
"If these two fundamental requirements are met, then all the data values "
"required by the query are available from the index, so an index-only scan is "
"physically possible. But there is an additional requirement for any table "
"scan in <productname>PostgreSQL</productname>: it must verify that each "
"retrieved row be <quote>visible</quote> to the query's MVCC snapshot, as "
"discussed in <xref linkend=\"mvcc\"/>. Visibility information is not stored "
"in index entries, only in heap entries; so at first glance it would seem "
"that every row retrieval would require a heap access anyway. And this is "
"indeed the case, if the table row has been modified recently. However, for "
"seldom-changing data there is a way around this problem. "
"<productname>PostgreSQL</productname> tracks, for each page in a table's "
"heap, whether all rows stored in that page are old enough to be visible to "
"all current and future transactions. This information is stored in a bit in "
"the table's <firstterm>visibility map</firstterm>. An index-only scan, after "
"finding a candidate index entry, checks the visibility map bit for the "
"corresponding heap page. If it's set, the row is known visible and so the "
"data can be returned with no further work. If it's not set, the heap entry "
"must be visited to find out whether it's visible, so no performance "
"advantage is gained over a standard index scan. Even in the successful case, "
"this approach trades visibility map accesses for heap accesses; but since "
"the visibility map is four orders of magnitude smaller than the heap it "
"describes, far less physical I/O is needed to access it. In most situations "
"the visibility map remains cached in memory all the time."
msgstr ""
"Если два этих фундаментальных ограничения выполняются, то все данные, "
"требуемые для выполнения запроса, содержатся в индексе, так что сканирование "
"только по индексу физически возможно. Но в <productname>PostgreSQL</"
"productname> существует и ещё одно требование для сканирования таблицы: "
"необходимо убедиться, что все возвращаемые строки <quote>видны</quote> в "
"снимке MVCC запроса, как описано в <xref remap=\"6\" linkend=\"mvcc\"/>. "
"Информация о видимости хранится не в элементах индекса, а только в куче; "
"поэтому на первый взгляд может показаться, что для получения данных каждой "
"строки всё равно необходимо обращаться к куче. И это в самом деле так, если "
"в таблице недавно произошли изменения. Однако для редко меняющихся данных "
"есть возможность обойти эту проблему. <productname>PostgreSQL</productname> "
"отслеживает для каждой страницы в куче таблицы, являются ли все строки в "
"этой странице достаточно старыми, чтобы их видели все текущие и будущие "
"транзакции. Это отражается в битах в <firstterm>карте видимости</firstterm> "
"таблицы. Процедура сканирования только индекса, найдя потенциально "
"подходящую запись в индексе, проверяет бит в карте видимости для "
"соответствующей страницы в куче. Если он установлен, значит эта строка "
"видна, и данные могут быть возвращены сразу. В противном случае придётся "
"посетить запись строки в куче и проверить, видима ли она, так что никакого "
"выигрыша по сравнению с обычным сканированием индекса не будет. И даже в "
"благоприятном случае обращение к кучи не исключается совсем, а заменяется "
"обращением к карте видимости; но так как карта видимости на четыре порядка "
"меньше соответствующей ей области кучи, для работы с ней требуется много "
"меньше операций физического ввода/вывода. В большинстве ситуаций карта "
"видимости просто всё время находится в памяти."

#: indices.xml:1249(para)
msgid ""
"In short, while an index-only scan is possible given the two fundamental "
"requirements, it will be a win only if a significant fraction of the table's "
"heap pages have their all-visible map bits set. But tables in which a large "
"fraction of the rows are unchanging are common enough to make this type of "
"scan very useful in practice."
msgstr ""
"Таким образом, тогда как сканирование только по индексу возможно лишь при "
"выполнении двух фундаментальных требований, оно даст выигрыш, только если "
"для значительной части страниц в куче таблицы установлены биты полной "
"видимости. Но таблицы, в которых меняется лишь небольшая часть строк, "
"встречаются достаточно часто, чтобы этот тип сканирования был весьма полезен "
"на практике."

#: indices.xml:1263(programlisting)
#, no-wrap
msgid "SELECT y FROM tab WHERE x = 'key';"
msgstr "SELECT y FROM tab WHERE x = 'key';"

#: indices.xml:1257(para)
msgid ""
"To make effective use of the index-only scan feature, you might choose to "
"create indexes in which only the leading columns are meant to match "
"<literal>WHERE</literal> clauses, while the trailing columns hold "
"<quote>payload</quote> data to be returned by a query. For example, if you "
"commonly run queries like <placeholder-1/> the traditional approach to "
"speeding up such queries would be to create an index on <literal>x</literal> "
"only. However, an index on <literal>(x, y)</literal> would offer the "
"possibility of implementing this query as an index-only scan. As previously "
"discussed, such an index would be larger and hence more expensive than an "
"index on <literal>x</literal> alone, so this is attractive only if the table "
"is known to be mostly static. Note it's important that the index be declared "
"on <literal>(x, y)</literal> not <literal>(y, x)</literal>, as for most "
"index types (particularly B-trees) searches that do not constrain the "
"leading index columns are not very efficient."
msgstr ""
"Чтобы эффективно применять возможность сканирования только индекса, можно "
"создать индексы, в которых только первые столбцы будут соответствовать "
"предложениям <literal>WHERE</literal>, а остальные столбцы будут содержать "
"полезные данные, возвращаемые запросом. Например, если вы часто выполняете "
"запросы вида: <placeholder-1/> при традиционном подходе к ускорению таких "
"запросов можно было бы создать индекс только по <literal>x</literal>. Однако "
"индекс по <literal>(x, y)</literal> дал бы возможность выполнения этого "
"запроса со сканированием только индекса. Как говорилось ранее, такой индекс "
"был бы объёмнее и дороже в обслуживании, чем индекс только по <literal>x</"
"literal>, так что этот вариант предпочтителен, только для таблиц в основном "
"статических. Заметьте, что в объявлении индекса важно указать столбцы "
"<literal>(x, y)</literal>, а не <literal>(y, x)</literal>, так как для "
"большинства типов индексов (а именно, B-деревьев) поиск, при котором не "
"ограничиваются значения ведущих столбцов индекса, не будет эффективным."

#: indices.xml:1281(programlisting)
#, no-wrap
msgid "SELECT f(x) FROM tab WHERE f(x) &lt; 1;"
msgstr "SELECT f(x) FROM tab WHERE f(x) &lt; 1;"

#: indices.xml:1277(para)
msgid ""
"In principle, index-only scans can be used with expression indexes. For "
"example, given an index on <literal>f(x)</literal> where <literal>x</"
"literal> is a table column, it should be possible to execute <placeholder-1/"
"> as an index-only scan; and this is very attractive if <literal>f()</"
"literal> is an expensive-to-compute function. However, "
"<productname>PostgreSQL</productname>'s planner is currently not very smart "
"about such cases. It considers a query to be potentially executable by index-"
"only scan only when all <emphasis>columns</emphasis> needed by the query are "
"available from the index. In this example, <literal>x</literal> is not "
"needed except in the context <literal>f(x)</literal>, but the planner does "
"not notice that and concludes that an index-only scan is not possible. If an "
"index-only scan seems sufficiently worthwhile, this can be worked around by "
"declaring the index to be on <literal>(f(x), x)</literal>, where the second "
"column is not expected to be used in practice but is just there to convince "
"the planner that an index-only scan is possible. An additional caveat, if "
"the goal is to avoid recalculating <literal>f(x)</literal>, is that the "
"planner won't necessarily match uses of <literal>f(x)</literal> that aren't "
"in indexable <literal>WHERE</literal> clauses to the index column. It will "
"usually get this right in simple queries such as shown above, but not in "
"queries that involve joins. These deficiencies may be remedied in future "
"versions of <productname>PostgreSQL</productname>."
msgstr ""
"В принципе сканирование только индекса может применяться и с индексами по "
"выражениям. Например, при наличии индекса по <literal>f(x)</literal>, где "
"<literal>x</literal> — столбец таблицы, должно быть возможно выполнить "
"<placeholder-1/> как сканирование только индекса; и это очень заманчиво, "
"если <literal>f()</literal> — сложная для вычисления функция. Однако "
"планировщик <productname>PostgreSQL</productname> в настоящее время может "
"вести себя не очень разумно. Он считает, что запрос может выполняться со "
"сканированием только по индексу, только когда из индекса могут быть получены "
"все <emphasis>столбцы</emphasis>, требующиеся для запроса. В этом примере "
"<literal>x</literal> фигурирует только в контексте <literal>f(x)</literal>, "
"но планировщик не замечает этого и решает, что сканирование только по "
"индексу невозможно. Если сканирование только по индексу заслуживает того, "
"эту проблему можно обойти, объявив индекс по <literal>(f(x), x)</literal>, "
"где второй столбец может не использоваться на практике, но нужен для того, "
"чтобы убедить планировщик, что сканирование только по индексу возможно. Если "
"это делается ради того, чтобы избежать вычислений <literal>f(x)</literal>, "
"надо также заметить, что планировщик не обязательно свяжет с использованием "
"индекса упоминания <literal>f(x)</literal>, фигурирующие не в индексируемых "
"предложениях <literal>WHERE</literal> со столбцом индекса. Обычно он это "
"делает правильно в простых запросах, вроде показанного выше, но не в "
"запросах с соединениями. Эти недостатки могут быть устранены в будущих "
"версиях <productname>PostgreSQL</productname>."

#: indices.xml:1307(programlisting)
#, no-wrap
msgid ""
"CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)\n"
"    WHERE success;"
msgstr ""
"CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)\n"
"    WHERE success;"

#: indices.xml:1313(programlisting)
#, no-wrap
msgid "SELECT target FROM tests WHERE subject = 'some-subject' AND success;"
msgstr "SELECT target FROM tests WHERE subject = 'some-subject' AND success;"

#: indices.xml:1304(para)
msgid ""
"Partial indexes also have interesting interactions with index-only scans. "
"Consider the partial index shown in <xref linkend=\"indexes-partial-ex3\"/>: "
"<placeholder-1/> In principle, we could do an index-only scan on this index "
"to satisfy a query like <placeholder-2/> But there's a problem: the "
"<literal>WHERE</literal> clause refers to <literal>success</literal> which "
"is not available as a result column of the index. Nonetheless, an index-only "
"scan is possible because the plan does not need to recheck that part of the "
"<literal>WHERE</literal> clause at run time: all entries found in the index "
"necessarily have <literal>success = true</literal> so this need not be "
"explicitly checked in the plan. <productname>PostgreSQL</productname> "
"versions 9.6 and later will recognize such cases and allow index-only scans "
"to be generated, but older versions will not."
msgstr ""
"С использованием частичных индексов при сканировании только по индексу тоже "
"связаны интересные особенности. Предположим, что у нас есть частичный "
"индекс, показанный в <xref remap=\"6\" linkend=\"indexes-partial-ex3\"/>: "
"<placeholder-1/> В принципе с ним мы можем произвести сканирование только по "
"индексу при выполнении запроса <placeholder-2/> Но есть одна проблема: "
"предложение <literal>WHERE</literal> обращается к столбцу <literal>success</"
"literal>, который отсутствует в результирующих столбцах индекса. Тем не "
"менее, сканирование только индекса возможно, так как плану не нужно "
"перепроверять эту часть предложения <literal>WHERE</literal> во время "
"выполнения: у всех записей, найденных в индексе, значение <literal>success = "
"true</literal>, так что в плане его не нужно проверять явно. "
"<productname>PostgreSQL</productname> версий 9.6 и новее распознает такую "
"ситуацию и сможет произвести сканирование только по индексу, но старые "
"версии неспособны на это."

#: indices.xml:1330(title)
msgid "Examining Index Usage"
msgstr "Контроль использования индексов"

#: indices.xml:1332(indexterm)
msgid "<primary>index</primary> <secondary>examining usage</secondary>"
msgstr ""
"<primary>индексы</primary> <secondary>контроль использования</secondary>"

#: indices.xml:1337(para)
msgid ""
"Although indexes in <productname>PostgreSQL</productname> do not need "
"maintenance or tuning, it is still important to check which indexes are "
"actually used by the real-life query workload. Examining index usage for an "
"individual query is done with the <xref linkend=\"sql-explain\"/> command; "
"its application for this purpose is illustrated in <xref linkend=\"using-"
"explain\"/>. It is also possible to gather overall statistics about index "
"usage in a running server, as described in <xref linkend=\"monitoring-stats"
"\"/>."
msgstr ""
"Хотя индексы в <productname>PostgreSQL</productname> не требуют какого-либо "
"обслуживания или настройки, это не избавляет от необходимости проверять, как "
"и какие индексы используются на самом деле в реальных условиях. Узнать, как "
"отдельный запрос использует индексы, можно с помощью команды <xref linkend="
"\"sql-explain\"/>; её применение для этих целей описывается в <xref remap="
"\"6\" linkend=\"using-explain\"/>. Также возможно собрать общую статистику "
"об использовании индексов на работающем сервере, как описано в <xref remap="
"\"6\" linkend=\"monitoring-stats\"/>."

#: indices.xml:1349(para)
msgid ""
"It is difficult to formulate a general procedure for determining which "
"indexes to create. There are a number of typical cases that have been shown "
"in the examples throughout the previous sections. A good deal of "
"experimentation is often necessary. The rest of this section gives some tips "
"for that:"
msgstr ""
"Вывести универсальную формулу, определяющую, какие индексы нужно создавать, "
"довольно сложно, если вообще возможно. В предыдущих разделах рассматривались "
"некоторые типовые ситуации, иллюстрирующие подходы к этому вопросу. Часто "
"найти ответ на него помогают эксперименты. Ниже приведены ещё несколько "
"советов:"

#: indices.xml:1359(para)
msgid ""
"Always run <xref linkend=\"sql-analyze\"/> first. This command collects "
"statistics about the distribution of the values in the table. This "
"information is required to estimate the number of rows returned by a query, "
"which is needed by the planner to assign realistic costs to each possible "
"query plan. In absence of any real statistics, some default values are "
"assumed, which are almost certain to be inaccurate. Examining an "
"application's index usage without having run <command>ANALYZE</command> is "
"therefore a lost cause. See <xref linkend=\"vacuum-for-statistics\"/> and "
"<xref linkend=\"autovacuum\"/> for more information."
msgstr ""
"Всегда начинайте исследование с <xref linkend=\"sql-analyze\"/>. Эта команда "
"собирает статистические данные о распределении значений в таблице, которые "
"необходимы для оценивания числа строк, возвращаемых запросов. А это число, в "
"свою очередь, нужно планировщику, чтобы оценить реальные затраты для "
"всевозможных планов выполнения запроса. Не имея реальной статистики, "
"планировщик будет вынужден принять некоторые значения по умолчанию, которые "
"почти наверняка не будут соответствовать действительности. Поэтому понять, "
"как индекс используется приложением без предварительного запуска "
"<command>ANALYZE</command>, практически невозможно. Подробнее это "
"рассматривается в <xref remap=\"6\" linkend=\"vacuum-for-statistics\"/> и "
"<xref remap=\"6\" linkend=\"autovacuum\"/>."

#: indices.xml:1376(para)
msgid ""
"Use real data for experimentation. Using test data for setting up indexes "
"will tell you what indexes you need for the test data, but that is all."
msgstr ""
"Используйте в экспериментах реальные данные. Анализируя работу системы с "
"тестовыми данными, вы поймёте, какие индексы нужны для тестовых данных, но "
"не более того."

#: indices.xml:1382(para)
msgid ""
"It is especially fatal to use very small test data sets. While selecting "
"1000 out of 100000 rows could be a candidate for an index, selecting 1 out "
"of 100 rows will hardly be, because the 100 rows probably fit within a "
"single disk page, and there is no plan that can beat sequentially fetching 1 "
"disk page."
msgstr ""
"Особенно сильно искажают картину очень маленькие наборы тестовых данных. "
"Тогда как для извлечения 1000 строк из 100000 может быть применён индекс, "
"для выбора 1 из 100 он вряд ли потребуется, так как 100 строк скорее всего "
"уместятся в одну страницу данных на диске и никакой другой план не будет "
"лучше обычного сканирования 1 страницы."

#: indices.xml:1390(para)
msgid ""
"Also be careful when making up test data, which is often unavoidable when "
"the application is not yet in production. Values that are very similar, "
"completely random, or inserted in sorted order will skew the statistics away "
"from the distribution that real data would have."
msgstr ""
"Тем не менее, пока приложение не эксплуатируется, создавать какие-то "
"тестовые данные всё равно нужно, и это нужно делать обдуманно. Если вы "
"наполняете базу данных очень близкими, или наоборот, случайными значениями, "
"либо добавляете строки в отсортированном порядке, вы получите совсем не ту "
"статистику распределения, что дадут реальные данные."

#: indices.xml:1400(para)
msgid ""
"When indexes are not used, it can be useful for testing to force their use. "
"There are run-time parameters that can turn off various plan types (see "
"<xref linkend=\"runtime-config-query-enable\"/>). For instance, turning off "
"sequential scans (<varname>enable_seqscan</varname>) and nested-loop joins "
"(<varname>enable_nestloop</varname>), which are the most basic plans, will "
"force the system to use a different plan. If the system still chooses a "
"sequential scan or nested-loop join then there is probably a more "
"fundamental reason why the index is not being used; for example, the query "
"condition does not match the index. (What kind of query can use what kind of "
"index is explained in the previous sections.)"
msgstr ""
"Когда индексы не используются, ради тестирования может быть полезно "
"подключить их принудительно. Для этого можно воспользоваться параметрами "
"выполнения, позволяющими выключать различные типы планов (см. <xref remap="
"\"4\" linkend=\"runtime-config-query-enable\"/>). Например, выключив "
"наиболее простые планы: последовательное сканирование "
"(<varname>enable_seqscan</varname>) и соединения с вложенными циклами "
"(<varname>enable_nestloop</varname>), вы сможете заставить систему выбрать "
"другой план. Если же система продолжает выполнять сканирование или "
"соединение с вложенными циклами, вероятно, у неё есть более серьёзная "
"причина не использовать индекс; например, индекс может не соответствовать "
"условию запроса. (Какие индексы работают в запросах разных типов, "
"обсуждалось в предыдущих разделах.)"

#: indices.xml:1417(para)
msgid ""
"If forcing index usage does use the index, then there are two possibilities: "
"Either the system is right and using the index is indeed not appropriate, or "
"the cost estimates of the query plans are not reflecting reality. So you "
"should time your query with and without indexes. The <command>EXPLAIN "
"ANALYZE</command> command can be useful here."
msgstr ""
"Если система начинает использовать индекс только под принуждением, тому "
"может быть две причины: либо система права и применять индекс в самом деле "
"неэффективно, либо оценка стоимости применения индекса не соответствует "
"действительности. В этом случае вам следует замерить время выполнения "
"запроса с индексами и без них. В анализе этой ситуации может быть полезна "
"команда <command>EXPLAIN ANALYZE</command>."

#: indices.xml:1428(para)
msgid ""
"If it turns out that the cost estimates are wrong, there are, again, two "
"possibilities. The total cost is computed from the per-row costs of each "
"plan node times the selectivity estimate of the plan node. The costs "
"estimated for the plan nodes can be adjusted via run-time parameters "
"(described in <xref linkend=\"runtime-config-query-constants\"/>). An "
"inaccurate selectivity estimate is due to insufficient statistics. It might "
"be possible to improve this by tuning the statistics-gathering parameters "
"(see <xref linkend=\"sql-altertable\"/>)."
msgstr ""
"Если выясняется, что оценка стоимости неверна, это может иметь тоже два "
"объяснения. Общая стоимость вычисляется как произведение цены каждого узла "
"плана для одной строки и оценки избирательности узла плана. Цены узлов при "
"необходимости можно изменить параметрами выполнения (описанными в <xref "
"remap=\"6\" linkend=\"runtime-config-query-constants\"/>). С другой стороны, "
"оценка избирательности может быть неточной из-за некачественной статистики. "
"Улучшить её можно, настроив параметры сбора статистики (см. <xref remap="
"\"4\" linkend=\"sql-altertable\"/>)."

#: indices.xml:1441(para)
msgid ""
"If you do not succeed in adjusting the costs to be more appropriate, then "
"you might have to resort to forcing index usage explicitly. You might also "
"want to contact the <productname>PostgreSQL</productname> developers to "
"examine the issue."
msgstr ""
"Если ваши попытки скорректировать стоимость планов не увенчаются успехом, "
"возможно вам останется только явно заставить систему использовать нужный "
"индекс. Вероятно, имеет смысл также связаться с разработчиками "
"<productname>PostgreSQL</productname>, чтобы прояснить ситуацию."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: indices.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
