# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:14+0300\n"
"PO-Revision-Date: 2017-08-04 13:57+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:5(title)
msgid "How the Planner Uses Statistics"
msgstr "Как планировщик использует статистику"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:7(para)
msgid ""
"This chapter builds on the material covered in <xref linkend=\"using-explain"
"\"/> and <xref linkend=\"planner-stats\"/> to show some additional details "
"about how the planner uses the system statistics to estimate the number of "
"rows each part of a query might return. This is a significant part of the "
"planning process, providing much of the raw material for cost calculation."
msgstr ""
"Данная глава основана на материалах, рассмотренных ранее (см. <xref remap="
"\"4\" linkend=\"using-explain\"/> и <xref remap=\"4\" linkend=\"planner-stats"
"\"/>), и подробнее рассказывает о том, как планировщик использует статистику "
"для определения количества строк, которое может вернуть каждая часть "
"запроса. Это важная составляющая процесса создания плана запроса, "
"предоставляющая большую часть исходного материала для расчёта стоимости."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:16(para)
msgid ""
"The intent of this chapter is not to document the code in detail, but to "
"present an overview of how it works. This will perhaps ease the learning "
"curve for someone who subsequently wishes to read the code."
msgstr ""
"Целью данной главы является не подробное документирование кода, а общее "
"описание его работы. Возможно, это поможет тем, кто пожелает в дальнейшем "
"ознакомиться с кодом."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:24(title)
msgid "Row Estimation Examples"
msgstr "Примеры оценки количества строк"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:26(indexterm)
msgid "<primary>row estimation</primary> <secondary>planner</secondary>"
msgstr ""
"<primary>Оценка количества строк</primary> <secondary> планировщик</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:31(para)
msgid ""
"The examples shown below use tables in the <productname>PostgreSQL</"
"productname> regression test database. The outputs shown are taken from "
"version 8.3. The behavior of earlier (or later) versions might vary. Note "
"also that since <command>ANALYZE</command> uses random sampling while "
"producing statistics, the results will change slightly after any new "
"<command>ANALYZE</command>."
msgstr ""
"В приведённых ниже примерах используются таблицы базы данных регрессионного "
"тестирования <productname>PostgreSQL</productname>. Приведённые листинги "
"получены в версии 8.3. Поведение более ранних (или поздних) версий может "
"отличаться. Заметьте также, что поскольку команда <command>ANALYZE</command> "
"использует случайную выборку при формировании статистики, после любого "
"нового выполнения команды <command>ANALYZE</command> результаты "
"незначительно изменятся."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:44(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:57(programlisting)
#, no-wrap
msgid ""
"SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';\n"
"\n"
" relpages | reltuples\n"
"----------+-----------\n"
"      358 |     10000"
msgstr ""
"SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';\n"
"\n"
" relpages | reltuples\n"
"----------+-----------\n"
"      358 |     10000"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:41(para)
msgid ""
"Let's start with a very simple query: <placeholder-1/> How the planner "
"determines the cardinality of <structname>tenk1</structname> is covered in "
"<xref linkend=\"planner-stats\"/>, but is repeated here for completeness. "
"The number of pages and rows is looked up in <structname>pg_class</"
"structname>: <placeholder-2/> These numbers are current as of the last "
"<command>VACUUM</command> or <command>ANALYZE</command> on the table. The "
"planner then fetches the actual current number of pages in the table (this "
"is a cheap operation, not requiring a table scan). If that is different from "
"<structfield>relpages</structfield> then <structfield>reltuples</"
"structfield> is scaled accordingly to arrive at a current number-of-rows "
"estimate. In the example above, the value of <structfield>relpages</"
"structfield> is up-to-date so the rows estimate is the same as "
"<structfield>reltuples</structfield>."
msgstr ""
"Давайте начнём с очень простого запроса: <placeholder-1/> Как планировщик "
"определяет мощность <structname>tenk1</structname>, рассматривается выше "
"(см. <xref remap=\"4\" linkend=\"planner-stats\"/>), но для полноты здесь "
"говорится об этом ещё раз. Количество страниц и строк берётся в "
"<structname>pg_class</structname>: <placeholder-2/>Это текущие цифры, "
"полученные при последнем выполнении команд <command>VACUUM</command> или "
"<command>ANALYZE</command>, применённых к этой таблице. Затем планировщик "
"выполняет выборку фактического текущего числа страниц в таблице (это "
"недорогая операция, для которой не требуется сканирование таблицы). Если оно "
"отличается от <structfield>relpages</structfield>, то "
"<structfield>reltuples</structfield> изменяется для того, чтобы привести это "
"значение к текущей оценке количества строк. В показанном выше примере "
"значение <structfield>relpages</structfield> является актуальным, поэтому "
"количество строк берётся равным <structfield>reltuples</structfield>."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:80(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:102(programlisting)
#, no-wrap
msgid ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='unique1';\n"
"\n"
"                   histogram_bounds\n"
"------------------------------------------------------\n"
" {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}"
msgstr ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='unique1';\n"
"\n"
"                   histogram_bounds\n"
"------------------------------------------------------\n"
" {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:119(programlisting)
#, no-wrap
msgid ""
"selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets\n"
"            = (1 + (1000 - 993)/(1997 - 993))/10\n"
"            = 0.100697"
msgstr ""
"selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets\n"
"            = (1 + (1000 - 993)/(1997 - 993))/10\n"
"            = 0.100697"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:130(programlisting)
#, no-wrap
msgid ""
"rows = rel_cardinality * selectivity\n"
"     = 10000 * 0.100697\n"
"     = 1007  (rounding off)"
msgstr ""
"rows = rel_cardinality * selectivity\n"
"     = 10000 * 0.100697\n"
"     = 1007  (округлённо)"

#. +> REL_10
#: planstats.xml:76(para)
msgid ""
"Let's move on to an example with a range condition in its <literal>WHERE</"
"literal> clause: <placeholder-1/> The planner examines the <literal>WHERE</"
"literal> clause condition and looks up the selectivity function for the "
"operator <literal>&lt;</literal> in <structname>pg_operator</structname>. "
"This is held in the column <structfield>oprrest</structfield>, and the entry "
"in this case is <function>scalarltsel</function>. The <function>scalarltsel</"
"function> function retrieves the histogram for <structfield>unique1</"
"structfield> from <structname>pg_statistic</structname>. For manual queries "
"it is more convenient to look in the simpler <structname>pg_stats</"
"structname> view: <placeholder-2/> Next the fraction of the histogram "
"occupied by <quote>&lt; 1000</quote> is worked out. This is the selectivity. "
"The histogram divides the range into equal frequency buckets, so all we have "
"to do is locate the bucket that our value is in and count <emphasis>part</"
"emphasis> of it and <emphasis>all</emphasis> of the ones before. The value "
"1000 is clearly in the second bucket (993-1997). Assuming a linear "
"distribution of values inside each bucket, we can calculate the selectivity "
"as: <placeholder-3/> that is, one whole bucket plus a linear fraction of the "
"second, divided by the number of buckets. The estimated number of rows can "
"now be calculated as the product of the selectivity and the cardinality of "
"<structname>tenk1</structname>: <placeholder-4/>"
msgstr ""
"Давайте обратимся к примеру с диапазонным условием в предложении "
"<literal>WHERE</literal>: <placeholder-1/> Планировщик рассматривает условие "
"предложения <literal>WHERE</literal> и находит в справочнике функцию "
"избирательности для оператора <literal>&lt;</literal> в "
"<structname>pg_operator</structname>. Это значение содержится в столбце "
"<structfield>oprrest</structfield>, и в данном случае значением является "
"<function>scalarltsel</function>. Функция <function>scalarltsel</function> "
"извлекает гистограмму для <structfield>unique1</structfield> из "
"<structname>pg_statistic</structname>. Для вводимых вручную запросов удобнее "
"просматривать более простое представление <structname>pg_stats</structname>: "
"<placeholder-2/> Затем обрабатывается часть гистограммы, которая "
"соответствует условию <quote>&lt; 1000</quote>. Таким образом и определяется "
"избирательность. Гистограмма делит диапазон на равные частотные группы, "
"поэтому нужно лишь определить группу, содержащую наше значение, и подсчитать "
"её <emphasis> долю </emphasis> и <emphasis> долю групп</emphasis>, "
"предшествующих данной. Очевидно, что значение 1000 находится во второй "
"группе (993-1997). Если предположить, что внутри каждой группы распределение "
"значений линейное, мы можем вычислить избирательность следующим образом: "
"<placeholder-3/> т. е. сумма элементов одной целой группы и пропорциональной "
"части элементов второй, делённая на число групп. Теперь примерное число "
"строк может быть рассчитано как произведение избирательности и мощности "
"<structname>tenk1</structname>: <placeholder-4/>"

#. +> REL9_6_3 REL9_6
#: planstats.xml:76(para)
msgid ""
"Let's move on to an example with a range condition in its <literal>WHERE</"
"literal> clause: <placeholder-1/> The planner examines the <literal>WHERE</"
"literal> clause condition and looks up the selectivity function for the "
"operator <literal>&lt;</literal> in <structname>pg_operator</structname>. "
"This is held in the column <structfield>oprrest</structfield>, and the entry "
"in this case is <function>scalarltsel</function>. The <function>scalarltsel</"
"function> function retrieves the histogram for <structfield>unique1</"
"structfield> from <structname>pg_statistics</structname>. For manual queries "
"it is more convenient to look in the simpler <structname>pg_stats</"
"structname> view: <placeholder-2/> Next the fraction of the histogram "
"occupied by <quote>&lt; 1000</quote> is worked out. This is the selectivity. "
"The histogram divides the range into equal frequency buckets, so all we have "
"to do is locate the bucket that our value is in and count <emphasis>part</"
"emphasis> of it and <emphasis>all</emphasis> of the ones before. The value "
"1000 is clearly in the second bucket (993-1997). Assuming a linear "
"distribution of values inside each bucket, we can calculate the selectivity "
"as: <placeholder-3/> that is, one whole bucket plus a linear fraction of the "
"second, divided by the number of buckets. The estimated number of rows can "
"now be calculated as the product of the selectivity and the cardinality of "
"<structname>tenk1</structname>: <placeholder-4/>"
msgstr ""
"Давайте обратимся к примеру с диапазонным условием в предложении "
"<literal>WHERE</literal>: <placeholder-1/> Планировщик рассматривает условие "
"предложения <literal>WHERE</literal> и находит в справочнике функцию "
"избирательности для оператора <literal>&lt;</literal> в "
"<structname>pg_operator</structname>. Это значение содержится в столбце "
"<structfield>oprrest</structfield>, и в данном случае значением является "
"<function>scalarltsel</function>. Функция <function>scalarltsel</function> "
"извлекает гистограмму для <structfield>unique1</structfield> из "
"<structname>pg_statistics</structname>. Для вводимых вручную запросов "
"удобнее просматривать более простое представление <structname>pg_stats</"
"structname>: <placeholder-2/> Затем обрабатывается часть гистограммы, "
"которая соответствует условию <quote>&lt; 1000</quote>. Таким образом и "
"определяется избирательность. Гистограмма делит диапазон на равные частотные "
"группы, поэтому нужно лишь определить группу, содержащую наше значение, и "
"подсчитать её <emphasis> долю </emphasis> и <emphasis> долю групп</"
"emphasis>, предшествующих данной. Очевидно, что значение 1000 находится во "
"второй группе (993-1997). Если предположить, что внутри каждой группы "
"распределение значений линейное, мы можем вычислить избирательность "
"следующим образом: <placeholder-3/> т. е. сумма элементов одной целой группы "
"и пропорциональной части элементов второй, делённая на число групп. Теперь "
"примерное число строк может быть рассчитано как произведение избирательности "
"и мощности <structname>tenk1</structname>: <placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:141(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)\n"
"   Filter: (stringu1 = 'CRAAAA'::name)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)\n"
"   Filter: (stringu1 = 'CRAAAA'::name)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:158(programlisting)
#, no-wrap
msgid ""
"SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"null_frac         | 0\n"
"n_distinct        | 676\n"
"most_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}\n"
"most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}"
msgstr ""
"SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"null_frac         | 0\n"
"n_distinct        | 676\n"
"most_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}\n"
"most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:173(programlisting)
#, no-wrap
msgid ""
"selectivity = mcf[3]\n"
"            = 0.003"
msgstr ""
"selectivity = mcf[3]\n"
"            = 0.003"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:181(programlisting)
#, no-wrap
msgid ""
"rows = 10000 * 0.003\n"
"     = 30"
msgstr ""
"rows = 10000 * 0.003\n"
"     = 30"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:137(para)
msgid ""
"Next let's consider an example with an equality condition in its "
"<literal>WHERE</literal> clause: <placeholder-1/> Again the planner examines "
"the <literal>WHERE</literal> clause condition and looks up the selectivity "
"function for <literal>=</literal>, which is <function>eqsel</function>. For "
"equality estimation the histogram is not useful; instead the list of "
"<firstterm>most common values</firstterm> (<acronym>MCV</acronym>s) is used "
"to determine the selectivity. Let's have a look at the MCVs, with some "
"additional columns that will be useful later: <placeholder-2/> Since "
"<literal>CRAAAA</literal> appears in the list of MCVs, the selectivity is "
"merely the corresponding entry in the list of most common frequencies "
"(<acronym>MCF</acronym>s): <placeholder-3/> As before, the estimated number "
"of rows is just the product of this with the cardinality of "
"<structname>tenk1</structname>: <placeholder-4/>"
msgstr ""
"Далее, давайте рассмотрим пример с условием на равенство в предложении "
"<literal>WHERE</literal>: <placeholder-1/> Планировщик вновь проверяет "
"условие в предложении <literal>WHERE</literal> и определяет функцию "
"избирательности для <literal>=</literal>, и этой функцией является "
"<function>eqsel</function>. Для оценки равенства гистограмма бесполезна, "
"вместо неё для оценки избирательности используется список "
"<firstterm>наиболее распространённых значений</firstterm> (Most Commom "
"Values, <acronym>MCV</acronym>). Давайте рассмотрим MCV и соответствующие "
"дополнительные столбцы, которые пригодятся позже: <placeholder-2/> Так как "
"значение <literal>CRAAAA</literal> оказалось в списке MCV, избирательность "
"будет определяться просто соответствующим элементом в списке частот наиболее "
"распространённых значений (Most Common Frequencies, MCF): <placeholder-3/> "
"Как и в предыдущем примере, оценка числа строк берётся как произведение "
"мощности и избирательности <structname>tenk1</structname>: <placeholder-4/>"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:191(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)\n"
"   Filter: (stringu1 = 'xxx'::name)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)\n"
"   Filter: (stringu1 = 'xxx'::name)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:206(programlisting)
#, no-wrap
msgid ""
"selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)\n"
"            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +\n"
"                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)\n"
"            = 0.0014559"
msgstr ""
"selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)\n"
"            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +\n"
"                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)\n"
"            = 0.0014559"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:222(programlisting)
#, no-wrap
msgid ""
"rows = 10000 * 0.0014559\n"
"     = 15  (rounding off)"
msgstr ""
"rows = 10000 * 0.0014559\n"
"     = 15  (округлённо)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:187(para)
msgid ""
"Now consider the same query, but with a constant that is not in the "
"<acronym>MCV</acronym> list: <placeholder-1/> This is quite a different "
"problem: how to estimate the selectivity when the value is <emphasis>not</"
"emphasis> in the <acronym>MCV</acronym> list. The approach is to use the "
"fact that the value is not in the list, combined with the knowledge of the "
"frequencies for all of the <acronym>MCV</acronym>s: <placeholder-2/> That "
"is, add up all the frequencies for the <acronym>MCV</acronym>s and subtract "
"them from one, then divide by the number of <emphasis>other</emphasis> "
"distinct values. This amounts to assuming that the fraction of the column "
"that is not any of the MCVs is evenly distributed among all the other "
"distinct values. Notice that there are no null values so we don't have to "
"worry about those (otherwise we'd subtract the null fraction from the "
"numerator as well). The estimated number of rows is then calculated as "
"usual: <placeholder-3/>"
msgstr ""
"Теперь рассмотрим тот же самый запрос, но с константой, которой нет в списке "
"<acronym>MCV</acronym>: <placeholder-1/> Это совершенно другая задача — как "
"оценить избирательность значения, которого <emphasis>нет</emphasis> в списке "
"<acronym>MCV</acronym>. При её решении используется факт отсутствия данного "
"значения в списке в сочетании с частотой для каждого значения из списка "
"<acronym>MCV</acronym>. <placeholder-2/> Т. е. нужно сложить частоты "
"значений из списка <acronym>MCV</acronym>, отнять полученное число от "
"единицы, и полученное значение разделить на количество <emphasis>остальных</"
"emphasis> уникальных значений. Эти вычисления основаны на предположении, что "
"значения, которые не входят в список MCV, имеют равномерное распределение. "
"Заметьте, что в данном примере нет неопределённых значений, поэтому о них "
"беспокоиться не нужно (иначе их долю также пришлось бы вычитать из "
"числителя). Оценка числа строк затем производится как обычно: <placeholder-3/"
">"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:248(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';\n"
"\n"
"                         QUERY PLAN\n"
"------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)\n"
"   Filter: (stringu1 &lt; 'IAAAAA'::name)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';\n"
"\n"
"                         QUERY PLAN\n"
"------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)\n"
"   Filter: (stringu1 &lt; 'IAAAAA'::name)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:260(programlisting)
#, no-wrap
msgid ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"                                histogram_bounds\n"
"--------------------------------------------------------------------------------\n"
" {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}"
msgstr ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"                                histogram_bounds\n"
"--------------------------------------------------------------------------------\n"
" {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:273(programlisting)
#, no-wrap
msgid ""
"selectivity = sum(relevant mvfs)\n"
"            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003\n"
"            = 0.01833333"
msgstr ""
"selectivity = sum(relevant mvfs)\n"
"            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003\n"
"            = 0.01833333"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:290(programlisting)
#, no-wrap
msgid ""
"selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction\n"
"            = 0.01833333 + 0.298387 * 0.96966667\n"
"            = 0.307669\n"
"\n"
"rows        = 10000 * 0.307669\n"
"            = 3077  (rounding off)"
msgstr ""
"selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction\n"
"            = 0.01833333 + 0.298387 * 0.96966667\n"
"            = 0.307669\n"
"\n"
"rows        = 10000 * 0.307669\n"
"            = 3077  (округлённо)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:228(para)
msgid ""
"The previous example with <literal>unique1 &lt; 1000</literal> was an "
"oversimplification of what <function>scalarltsel</function> really does; now "
"that we have seen an example of the use of MCVs, we can fill in some more "
"detail. The example was correct as far as it went, because since "
"<structfield>unique1</structfield> is a unique column it has no MCVs "
"(obviously, no value is any more common than any other value). For a non-"
"unique column, there will normally be both a histogram and an MCV list, and "
"<emphasis>the histogram does not include the portion of the column "
"population represented by the MCVs</emphasis>. We do things this way because "
"it allows more precise estimation. In this situation <function>scalarltsel</"
"function> directly applies the condition (e.g., <quote>&lt; 1000</quote>) to "
"each value of the MCV list, and adds up the frequencies of the MCVs for "
"which the condition is true. This gives an exact estimate of the selectivity "
"within the portion of the table that is MCVs. The histogram is then used in "
"the same way as above to estimate the selectivity in the portion of the "
"table that is not MCVs, and then the two numbers are combined to estimate "
"the overall selectivity. For example, consider <placeholder-1/> We already "
"saw the MCV information for <structfield>stringu1</structfield>, and here is "
"its histogram: <placeholder-2/> Checking the MCV list, we find that the "
"condition <literal>stringu1 &lt; 'IAAAAA'</literal> is satisfied by the "
"first six entries and not the last four, so the selectivity within the MCV "
"part of the population is <placeholder-3/> Summing all the MCFs also tells "
"us that the total fraction of the population represented by MCVs is "
"0.03033333, and therefore the fraction represented by the histogram is "
"0.96966667 (again, there are no nulls, else we'd have to exclude them here). "
"We can see that the value <literal>IAAAAA</literal> falls nearly at the end "
"of the third histogram bucket. Using some rather cheesy assumptions about "
"the frequency of different characters, the planner arrives at the estimate "
"0.298387 for the portion of the histogram population that is less than "
"<literal>IAAAAA</literal>. We then combine the estimates for the MCV and non-"
"MCV populations: <placeholder-4/> In this particular example, the correction "
"from the MCV list is fairly small, because the column distribution is "
"actually quite flat (the statistics showing these particular values as being "
"more common than others are mostly due to sampling error). In a more typical "
"case where some values are significantly more common than others, this "
"complicated process gives a useful improvement in accuracy because the "
"selectivity for the most common values is found exactly."
msgstr ""
"Предыдущий пример с <literal>unique1 &lt; 1000</literal> был большим "
"упрощением того, что в действительности делает <function>scalarltsel</"
"function>. Но после того, как мы увидели пример использования списка MCV, мы "
"можем внести некоторые дополнения. Что касается самого примера, в нём все "
"было правильно, поскольку <structfield>unique1</structfield> это уникальный "
"столбец, у него нет значений в списке MCV (очевидно, в данном случае нет "
"значения, которое является более распространённым, чем любое другое). Для "
"неуникального столбца обычно создаётся как гистограмма, так и список MCV, "
"при этом <emphasis>гистограмма не включает значения, представленные в списке "
"MCV</emphasis>. Данный способ позволяет выполнить более точный подсчёт. В "
"этой ситуации <function>scalarltsel</function> напрямую применяет условие "
"<quote>&lt; 1000</quote> к каждому значению списка MCV и суммирует частоты "
"значений MCV, для которых условие является верным. Это даёт точную оценку "
"избирательности для той части таблицы, которая содержит значения из списка "
"MCV. Подобным же образом используется гистограмма для оценки избирательности "
"для той части таблицы, которая не содержит значения из списка MCV, а затем "
"эти две цифры складываются для оценки общей избирательности. Например, "
"рассмотрим <placeholder-1/> Мы уже видели данные списка MCV для "
"<structfield>stringu1</structfield>, а это его гистограмма: <placeholder-2/> "
"Проверяя список MCV, находим, что условие <literal>stringu1 &lt; 'IAAAAA'</"
"literal> соответствует первым шести записям, но не соответствует последним "
"четырём, поэтому избирательность для значений, соответствующих значениям в "
"списке MCV, такова: <placeholder-3/> Сумма всех частот из списка MCF также "
"сообщает нам, что общая часть представленной списком MCV совокупности "
"записей равняется 0.03033333, и поэтому представленная гистограммой часть "
"равняется 0.96966667 (в этом случае тоже нет неопределённых значений, иначе "
"их пришлось бы также исключить). Видно, что значение <literal>IAAAAA</"
"literal> попадает почти в конец третьего столбца гистограммы. Основываясь на "
"простых предположениях относительно частоты различных символов, планировщик "
"получает число 0.298387 для части значений, представленных в гистограмме, "
"которые меньше чем <literal>IAAAAA</literal>. Затем объединяем оценки части "
"значений из списка MCV и значений, не содержащихся в нём: <placeholder-4/> В "
"этом конкретном примере, корректировка со стороны списка MCV достаточно "
"мала, потому что распределение значений столбца довольно плоское "
"(статистика, показывающая конкретные значения как более распространённые, "
"чаще всего получается вследствие статистической погрешности). В более "
"типичном случае, когда некоторые значения являются значительно более "
"распространёнными по сравнению с другими, этот более сложный метод повышает "
"точность вследствие точного определения избирательности наиболее "
"распространённых значений."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:312(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   Filter: (stringu1 = 'xxx'::name)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   Filter: (stringu1 = 'xxx'::name)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:327(programlisting)
#, no-wrap
msgid ""
"selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')\n"
"            = 0.100697 * 0.0014559\n"
"            = 0.0001466\n"
"\n"
"rows        = 10000 * 0.0001466\n"
"            = 1  (rounding off)"
msgstr ""
"selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')\n"
"            = 0.100697 * 0.0014559\n"
"            = 0.0001466\n"
"\n"
"rows        = 10000 * 0.0001466\n"
"            = 1  (округлённо)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:308(para)
msgid ""
"Now let's consider a case with more than one condition in the "
"<literal>WHERE</literal> clause: <placeholder-1/> The planner assumes that "
"the two conditions are independent, so that the individual selectivities of "
"the clauses can be multiplied together: <placeholder-2/> Notice that the "
"number of rows estimated to be returned from the bitmap index scan reflects "
"only the condition used with the index; this is important since it affects "
"the cost estimate for the subsequent heap fetches."
msgstr ""
"Теперь давайте рассмотрим случай с более чем одним условием в предложении "
"<literal>WHERE</literal>: <placeholder-1/> Планировщик исходит из того, что "
"два условия независимы, таким образом, отдельные значения избирательности "
"можно перемножить: <placeholder-2/> Заметьте, что число строк, которые "
"предполагается вернуть через сканирование битового индекса, соответствует "
"условию, используемому при работе индекса; это важно, так как влияет на "
"оценку стоимости для последующих выборок из таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:345(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                      QUERY PLAN\n"
"--------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.64..456.23 rows=50 width=488)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)\n"
"         Recheck Cond: (unique1 &lt; 50)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)\n"
"               Index Cond: (unique1 &lt; 50)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)\n"
"         Index Cond: (unique2 = t1.unique2)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                      QUERY PLAN\n"
"--------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.64..456.23 rows=50 width=488)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)\n"
"         Recheck Cond: (unique1 &lt; 50)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)\n"
"               Index Cond: (unique1 &lt; 50)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)\n"
"         Index Cond: (unique2 = t1.unique2)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:367(programlisting)
#, no-wrap
msgid ""
"selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets\n"
"            = (0 + (50 - 0)/(993 - 0))/10\n"
"            = 0.005035\n"
"\n"
"rows        = 10000 * 0.005035\n"
"            = 50  (rounding off)"
msgstr ""
"selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets\n"
"            = (0 + (50 - 0)/(993 - 0))/10\n"
"            = 0.005035\n"
"\n"
"rows        = 10000 * 0.005035\n"
"            = 50  (округлённо)"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:384(programlisting)
#, no-wrap
msgid ""
"SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats\n"
"WHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';\n"
"\n"
"tablename  | null_frac | n_distinct | most_common_vals\n"
"-----------+-----------+------------+------------------\n"
" tenk1     |         0 |         -1 |\n"
" tenk2     |         0 |         -1 |"
msgstr ""
"SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats\n"
"WHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';\n"
"\n"
"tablename  | null_frac | n_distinct | most_common_vals\n"
"-----------+-----------+------------+------------------\n"
" tenk1     |         0 |         -1 |\n"
" tenk2     |         0 |         -1 |"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:399(programlisting)
#, no-wrap
msgid ""
"selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)\n"
"            = (1 - 0) * (1 - 0) / max(10000, 10000)\n"
"            = 0.0001"
msgstr ""
"selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)\n"
"            = (1 - 0) * (1 - 0) / max(10000, 10000)\n"
"            = 0.0001"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:412(programlisting)
#, no-wrap
msgid ""
"rows = (outer_cardinality * inner_cardinality) * selectivity\n"
"     = (50 * 10000) * 0.0001\n"
"     = 50"
msgstr ""
"rows = (outer_cardinality * inner_cardinality) * selectivity\n"
"     = (50 * 10000) * 0.0001\n"
"     = 50"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:342(para)
msgid ""
"Finally we will examine a query that involves a join: <placeholder-1/> The "
"restriction on <structname>tenk1</structname>, <literal>unique1 &lt; 50</"
"literal>, is evaluated before the nested-loop join. This is handled "
"analogously to the previous range example. This time the value 50 falls into "
"the first bucket of the <structfield>unique1</structfield> histogram: "
"<placeholder-2/> The restriction for the join is <literal>t2.unique2 = t1."
"unique2</literal>. The operator is just our familiar <literal>=</literal>, "
"however the selectivity function is obtained from the <structfield>oprjoin</"
"structfield> column of <structname>pg_operator</structname>, and is "
"<function>eqjoinsel</function>. <function>eqjoinsel</function> looks up the "
"statistical information for both <structname>tenk2</structname> and "
"<structname>tenk1</structname>: <placeholder-3/> In this case there is no "
"<acronym>MCV</acronym> information for <structfield>unique2</structfield> "
"because all the values appear to be unique, so we use an algorithm that "
"relies only on the number of distinct values for both relations together "
"with their null fractions: <placeholder-4/> This is, subtract the null "
"fraction from one for each of the relations, and divide by the maximum of "
"the numbers of distinct values. The number of rows that the join is likely "
"to emit is calculated as the cardinality of the Cartesian product of the two "
"inputs, multiplied by the selectivity: <placeholder-5/>"
msgstr ""
"В заключение исследуем запрос, выполняющий соединение: <placeholder-1/> "
"Ограничение, накладываемое на <structname>tenk1</structname>, "
"<literal>unique1 &lt; 50</literal>, производится до соединения вложенным "
"циклом. Это обрабатывается аналогично предыдущему примеру с диапазонным "
"условием. На этот раз значение 50 попадает в первый столбец гистограммы "
"<structfield>unique1</structfield>: <placeholder-2/> Ограничение для "
"соединения следующее <literal>t2.unique2 = t1.unique2</literal>. Здесь "
"используется уже известный нам оператор <literal>=</literal>, однако функцию "
"избирательности получаем из столбца <structfield>oprjoin</structfield> "
"представления <structname>pg_operator</structname>, и эта функция — "
"<function>eqjoinsel</function>. Функция <function>eqjoinsel</function> "
"находит статистические данные как для <structname>tenk2</structname>, так и "
"для <structname>tenk1</structname>: <placeholder-3/> В этом случае нет "
"данных <acronym>MCV</acronym> для <structfield>unique2</structfield>, потому "
"что все значения будут уникальными. Таким образом, используется алгоритм, "
"зависящий только от числа различающихся значений для обеих таблиц и от "
"данных с неопределёнными значениями: <placeholder-4/> Т. е., вычитаем долю "
"неопределённых значений из единицы для каждой таблицы и делим на "
"максимальное из чисел различающихся значений. Количество строк, которое "
"соединение, вероятно, сгенерирует, вычисляется как мощность декартова "
"произведения двух входных значений, умноженная на избирательность: "
"<placeholder-5/>"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:419(para)
msgid ""
"Had there been MCV lists for the two columns, <function>eqjoinsel</function> "
"would have used direct comparison of the MCV lists to determine the join "
"selectivity within the part of the column populations represented by the "
"MCVs. The estimate for the remainder of the populations follows the same "
"approach shown here."
msgstr ""
"Если бы имелись списки MCV для двух столбцов, функцией <function>eqjoinsel</"
"function> использовалось бы прямое сравнение со списками MCV для определения "
"общей избирательности той части данных, которая содержит значения списка "
"MCV. Оценка остальной части данных при этом выполнялась бы представленным "
"выше способом."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:427(para)
msgid ""
"Notice that we showed <literal>inner_cardinality</literal> as 10000, that "
"is, the unmodified size of <structname>tenk2</structname>. It might appear "
"from inspection of the <command>EXPLAIN</command> output that the estimate "
"of join rows comes from 50 * 1, that is, the number of outer rows times the "
"estimated number of rows obtained by each inner index scan on "
"<structname>tenk2</structname>. But this is not the case: the join relation "
"size is estimated before any particular join plan has been considered. If "
"everything is working well then the two ways of estimating the join size "
"will produce about the same answer, but due to round-off error and other "
"factors they sometimes diverge significantly."
msgstr ""
"Заметьте, что здесь выводится для <literal>inner_cardinality</literal> "
"значение 10000, то есть исходный размер <structname>tenk2</structname>. Если "
"изучить вывод <command>EXPLAIN</command>, может показаться, что оценка "
"количества строк вычисляется как 50 * 1, то есть число внешних строк "
"умножается на ориентировочное число строк, получаемых при каждом внутреннем "
"сканировании индекса в <structname>tenk2</structname>. Но это не так, ведь "
"размер результата соединения оценивается до того, как выбирается конкретный "
"план соединения. Если всё работает корректно, оба варианта вычисления этого "
"размера должны давать один и тот же ответ, но из-за ошибок округления и "
"других факторов иногда они значительно различаются."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:440(para)
msgid ""
"For those interested in further details, estimation of the size of a table "
"(before any <literal>WHERE</literal> clauses) is done in <filename>src/"
"backend/optimizer/util/plancat.c</filename>. The generic logic for clause "
"selectivities is in <filename>src/backend/optimizer/path/clausesel.c</"
"filename>. The operator-specific selectivity functions are mostly found in "
"<filename>src/backend/utils/adt/selfuncs.c</filename>."
msgstr ""
"Для интересующихся более подробной информацией: оценка размера таблицы (до "
"выполнения условий в предложении <literal>WHERE</literal>) реализована в "
"файле <filename>src/backend/optimizer/util/plancat.c</filename>. Основная "
"логика для вычисления избирательности предложений находится в <filename>src/"
"backend/optimizer/path/clausesel.c</filename>. Специфичные для отдельных "
"операторов функции избирательности, в основном, расположены в <filename>src/"
"backend/utils/adt/selfuncs.c</filename>."

#. +> REL_10
#: planstats.xml:452(title)
msgid "Multivariate Statistics Examples"
msgstr "Примеры многовариантной статистики"

#. +> REL_10
#: planstats.xml:454(indexterm)
msgid "<primary>row estimation</primary> <secondary>multivariate</secondary>"
msgstr ""
"<primary>оценка числа строк</primary> <secondary>многовариантная</secondary>"

#. +> REL_10
#: planstats.xml:460(title)
msgid "Functional Dependencies"
msgstr "Функциональные зависимости"

#. +> REL_10
#: planstats.xml:466(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE t (a INT, b INT);\n"
"INSERT INTO t SELECT i % 100, i % 100 FROM generate_series(1, 10000) s(i);\n"
"ANALYZE t;"
msgstr ""
"CREATE TABLE t (a INT, b INT);\n"
"INSERT INTO t SELECT i % 100, i % 100 FROM generate_series(1, 10000) s(i);\n"
"ANALYZE t;"

#. +> REL_10
#: planstats.xml:476(programlisting)
#, no-wrap
msgid ""
"SELECT relpages, reltuples FROM pg_class WHERE relname = 't';\n"
"\n"
" relpages | reltuples\n"
"----------+-----------\n"
"       45 |     10000"
msgstr ""
"SELECT relpages, reltuples FROM pg_class WHERE relname = 't';\n"
"\n"
" relpages | reltuples\n"
"----------+-----------\n"
"       45 |     10000"

#. +> REL_10
#: planstats.xml:462(para)
msgid ""
"Multivariate correlation can be demonstrated with a very simple data set "
"&mdash; a table with two columns, both containing the same values: "
"<placeholder-1/> As explained in <xref linkend=\"planner-stats\"/>, the "
"planner can determine cardinality of <structname>t</structname> using the "
"number of pages and rows obtained from <structname>pg_class</structname>: "
"<placeholder-2/> The data distribution is very simple; there are only 100 "
"distinct values in each column, uniformly distributed."
msgstr ""
"Многовариантную корреляцию можно продемонстрировать на очень простом наборе "
"данных &mdash; таблице с двумя столбцами, содержащими одинаковые значения: "
"<placeholder-1/> Как рассказывается в <xref remap=\"6\" linkend=\"planner-"
"stats\"/>, планировщик может определить мощность <structname>t</structname>, "
"исходя из числа страниц и строк, полученного из <structname>pg_class</"
"structname>: <placeholder-2/> Распределение данных очень простое: в каждом "
"столбце содержится всего 100 различных значений, равномерно распределённых."

#. +> REL_10
#: planstats.xml:492(programlisting)
#, no-wrap
msgid ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1;\n"
"                                 QUERY PLAN                                  \n"
"-------------------------------------------------------------------------------\n"
" Seq Scan on t  (cost=0.00..170.00 rows=100 width=8) (actual rows=100 loops=1)\n"
"   Filter: (a = 1)\n"
"   Rows Removed by Filter: 9900"
msgstr ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1;\n"
"                                 QUERY PLAN                                  \n"
"-------------------------------------------------------------------------------\n"
" Seq Scan on t  (cost=0.00..170.00 rows=100 width=8) (actual rows=100 loops=1)\n"
"   Filter: (a = 1)\n"
"   Rows Removed by Filter: 9900"

#. +> REL_10
#: planstats.xml:509(programlisting)
#, no-wrap
msgid ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;\n"
"                                 QUERY PLAN                                  \n"
"-----------------------------------------------------------------------------\n"
" Seq Scan on t  (cost=0.00..195.00 rows=1 width=8) (actual rows=100 loops=1)\n"
"   Filter: ((a = 1) AND (b = 1))\n"
"   Rows Removed by Filter: 9900"
msgstr ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;\n"
"                                 QUERY PLAN                                  \n"
"-----------------------------------------------------------------------------\n"
" Seq Scan on t  (cost=0.00..195.00 rows=1 width=8) (actual rows=100 loops=1)\n"
"   Filter: ((a = 1) AND (b = 1))\n"
"   Rows Removed by Filter: 9900"

#. +> REL_10
#: planstats.xml:488(para)
msgid ""
"The following example shows the result of estimating a <literal>WHERE</"
"literal> condition on the <structfield>a</structfield> column: "
"<placeholder-1/> The planner examines the condition and determines the "
"selectivity of this clause to be 1%. By comparing this estimate and the "
"actual number of rows, we see that the estimate is very accurate (in fact "
"exact, as the table is very small). Changing the <literal>WHERE</literal> "
"condition to use the <structfield>b</structfield> column, an identical plan "
"is generated. But observe what happens if we apply the same condition on "
"both columns, combining them with <literal>AND</literal>: <placeholder-2/> "
"The planner estimates the selectivity for each condition individually, "
"arriving at the same 1% estimates as above. Then it assumes that the "
"conditions are independent, and so it multiplies their selectivities, "
"producing a final selectivity estimate of just 0.01%. This is a significant "
"underestimate, as the actual number of rows matching the conditions (100) is "
"two orders of magnitude higher."
msgstr ""
"Следующий пример показывает результат оценивания условия <literal>WHERE</"
"literal> по столбцу <structfield>a</structfield>: <placeholder-1/> "
"Планировщик рассматривает условие и определяет, что его избирательность "
"равна 1%. Сравнивая эту оценку и фактическое число строк, мы видим, что "
"оценка очень точна (на самом деле абсолютна точна, так как таблица очень "
"маленькая). Если изменить условие <literal>WHERE</literal>, чтобы "
"использовался столбец <structfield>b</structfield>, будет получен такой же "
"план. Но посмотрите, что получится, если мы применим одинаковое условие к "
"двум столбцам, объединив их оператором <literal>AND</literal>: "
"<placeholder-2/> Планировщик оценивает избирательность каждого условия "
"индивидуально, и получает ту же оценку в 1%, что и выше. Затем он "
"предполагает, что условия независимы, так что он перемножает избирательности "
"и выдаёт окончательную оценку избирательности, равную всего 0.01%. Это "
"значительная недооценка, так как фактическое число строк, соответствующих "
"условию, (100) на два порядка больше."

#. +> REL_10
#: planstats.xml:531(programlisting)
#, no-wrap
msgid ""
"CREATE STATISTICS stts (dependencies) ON a, b FROM t;\n"
"ANALYZE t;\n"
"EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;\n"
"                                  QUERY PLAN                                   \n"
"-------------------------------------------------------------------------------\n"
" Seq Scan on t  (cost=0.00..195.00 rows=100 width=8) (actual rows=100 loops=1)\n"
"   Filter: ((a = 1) AND (b = 1))\n"
"   Rows Removed by Filter: 9900"
msgstr ""
"CREATE STATISTICS stts (dependencies) ON a, b FROM t;\n"
"ANALYZE t;\n"
"EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;\n"
"                                  QUERY PLAN                                   \n"
"-------------------------------------------------------------------------------\n"
" Seq Scan on t  (cost=0.00..195.00 rows=100 width=8) (actual rows=100 loops=1)\n"
"   Filter: ((a = 1) AND (b = 1))\n"
"   Rows Removed by Filter: 9900"

#. +> REL_10
#: planstats.xml:526(para)
msgid ""
"This problem can be fixed by creating a statistics object that directs "
"<command>ANALYZE</command> to calculate functional-dependency multivariate "
"statistics on the two columns: <placeholder-1/>"
msgstr ""
"Эту проблему можно решить, создав объект статистики, который укажет команде "
"<command>ANALYZE</command> вычислить многовариантную статистику "
"функциональной зависимости по двум столбцам: <placeholder-1/>"

#. +> REL_10
#: planstats.xml:545(title)
msgid "Multivariate N-Distinct Counts"
msgstr "Многовариантное число различных значений"

#. +> REL_10
#: planstats.xml:554(programlisting)
#, no-wrap
msgid ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a;\n"
"                                       QUERY PLAN                                        \n"
"-----------------------------------------------------------------------------------------\n"
" HashAggregate  (cost=195.00..196.00 rows=100 width=12) (actual rows=100 loops=1)\n"
"   Group Key: a\n"
"   -&gt;  Seq Scan on t  (cost=0.00..145.00 rows=10000 width=4) (actual rows=10000 loops=1)"
msgstr ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a;\n"
"                                       QUERY PLAN                                        \n"
"-----------------------------------------------------------------------------------------\n"
" HashAggregate  (cost=195.00..196.00 rows=100 width=12) (actual rows=100 loops=1)\n"
"   Group Key: a\n"
"   -&gt;  Seq Scan on t  (cost=0.00..145.00 rows=10000 width=4) (actual rows=10000 loops=1)"

#. +> REL_10
#: planstats.xml:565(programlisting)
#, no-wrap
msgid ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;\n"
"                                       QUERY PLAN                                        \n"
"--------------------------------------------------------------------------------------------\n"
" HashAggregate  (cost=220.00..230.00 rows=1000 width=16) (actual rows=100 loops=1)\n"
"   Group Key: a, b\n"
"   -&gt;  Seq Scan on t  (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000 loops=1)"
msgstr ""
"EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;\n"
"                                       QUERY PLAN                                        \n"
"--------------------------------------------------------------------------------------------\n"
" HashAggregate  (cost=220.00..230.00 rows=1000 width=16) (actual rows=100 loops=1)\n"
"   Group Key: a, b\n"
"   -&gt;  Seq Scan on t  (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000 loops=1)"

#. +> REL_10
#: planstats.xml:575(programlisting)
#, no-wrap
msgid ""
"DROP STATISTICS stts;\n"
"CREATE STATISTICS stts (dependencies, ndistinct) ON a, b FROM t;\n"
"ANALYZE t;\n"
"EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;\n"
"                                       QUERY PLAN                                        \n"
"--------------------------------------------------------------------------------------------\n"
" HashAggregate  (cost=220.00..221.00 rows=100 width=16) (actual rows=100 loops=1)\n"
"   Group Key: a, b\n"
"   -&gt;  Seq Scan on t  (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000 loops=1)"
msgstr ""
"DROP STATISTICS stts;\n"
"CREATE STATISTICS stts (dependencies, ndistinct) ON a, b FROM t;\n"
"ANALYZE t;\n"
"EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;\n"
"                                       QUERY PLAN                                        \n"
"--------------------------------------------------------------------------------------------\n"
" HashAggregate  (cost=220.00..221.00 rows=100 width=16) (actual rows=100 loops=1)\n"
"   Group Key: a, b\n"
"   -&gt;  Seq Scan on t  (cost=0.00..145.00 rows=10000 width=8) (actual rows=10000 loops=1)"

#. +> REL_10
#: planstats.xml:547(para)
msgid ""
"A similar problem occurs with estimation of the cardinality of sets of "
"multiple columns, such as the number of groups that would be generated by a "
"<command>GROUP BY</command> clause. When <command>GROUP BY</command> lists a "
"single column, the n-distinct estimate (which is visible as the estimated "
"number of rows returned by the HashAggregate node) is very accurate: "
"<placeholder-1/> But without multivariate statistics, the estimate for the "
"number of groups in a query with two columns in <command>GROUP BY</command>, "
"as in the following example, is off by an order of magnitude: <placeholder-2/"
"> By redefining the statistics object to include n-distinct counts for the "
"two columns, the estimate is much improved: <placeholder-3/>"
msgstr ""
"Подобная проблема возникает с оценкой мощности наборов с несколькими "
"столбцами, например, с оценкой числа групп, которые могут быть выданы "
"предложением <command>GROUP BY</command>. Когда в <command>GROUP BY</"
"command> указан один столбец, оценка числа различных значений (которую можно "
"увидеть как ожидаемое число строк, выдаваемое узлом HashAggregate) очень "
"точная: <placeholder-1/> Но оценка числа групп в запросе с двумя столбцами в "
"<command>GROUP BY</command> без многовариантной статистики, как и в "
"предыдущем примере, отличается от правильной на порядок: <placeholder-2/> "
"Если переопределить объект статистики, чтобы он включал подсчёт числа "
"различных значений для двух столбцов, оценка станет гораздо лучше: "
"<placeholder-3/>"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:592(title)
msgid "Planner Statistics and Security"
msgstr "Статистика планировщика и безопасность"

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:594(para)
msgid ""
"Access to the table <structname>pg_statistic</structname> is restricted to "
"superusers, so that ordinary users cannot learn about the contents of the "
"tables of other users from it. Some selectivity estimation functions will "
"use a user-provided operator (either the operator appearing in the query or "
"a related operator) to analyze the stored statistics. For example, in order "
"to determine whether a stored most common value is applicable, the "
"selectivity estimator will have to run the appropriate <literal>=</literal> "
"operator to compare the constant in the query to the stored value. Thus the "
"data in <structname>pg_statistic</structname> is potentially passed to user-"
"defined operators. An appropriately crafted operator can intentionally leak "
"the passed operands (for example, by logging them or writing them to a "
"different table), or accidentally leak them by showing their values in error "
"messages, in either case possibly exposing data from "
"<structname>pg_statistic</structname> to a user who should not be able to "
"see it."
msgstr ""
"Доступ к таблице <structname>pg_statistic</structname> разрешён только "
"суперпользователям, так что обычные пользователи не могут получить из неё "
"сведения о содержимом таблиц других пользователей. Но некоторые функции "
"оценки избирательности будут использовать пользовательский оператор "
"(оператор, фигурирующий в запросе, или связанный) для анализа сохранённой "
"статистики. Например, чтобы определить применимость сохранённого самого "
"частого значения, функция оценки избирательности должна задействовать "
"соответствующий оператор <literal>=</literal> для сравнения константы в "
"запросе с этим сохранённым значением. Таким образом, данные "
"<structname>pg_statistic</structname> в принципе могут передаваться "
"пользовательским операторам. А особым образом сконструированный оператор "
"может выводить наружу передаваемые ему операнды преднамеренно (например, "
"записывая их в журнал или помещая в другую таблицу) либо непреднамеренно "
"(показывая их значения в сообщениях об ошибках). В любом случае это даёт "
"возможность пользователю, не имеющему доступа к таблице "
"<structname>pg_statistic</structname>, увидеть содержащиеся в ней данные."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:612(para)
msgid ""
"In order to prevent this, the following applies to all built-in selectivity "
"estimation functions. When planning a query, in order to be able to use "
"stored statistics, the current user must either have <literal>SELECT</"
"literal> privilege on the table or the involved columns, or the operator "
"used must be <literal>LEAKPROOF</literal> (more accurately, the function "
"that the operator is based on). If not, then the selectivity estimator will "
"behave as if no statistics are available, and the planner will proceed with "
"default or fall-back assumptions."
msgstr ""
"Для предотвращения этого все встроенные функции оценки избирательности "
"действуют по следующим правилам. Чтобы сохранённая статистика могла "
"использоваться при планировании запроса, текущий пользователь должен иметь "
"либо право <literal>SELECT</literal> для таблицы или задействованных "
"столбцов, либо у оператора должна быть характеристика <literal>LEAKPROOF</"
"literal> (точнее, она должна быть у функции, реализующей этот оператор). В "
"противном случае оценка избирательности будет осуществляться так, как если "
"бы статистики не было вовсе, и планировщик продолжит работу с общими или "
"вторичными предположениями."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:623(para)
msgid ""
"If a user does not have the required privilege on the table or columns, then "
"in many cases the query will ultimately receive a permission-denied error, "
"in which case this mechanism is invisible in practice. But if the user is "
"reading from a security-barrier view, then the planner might wish to check "
"the statistics of an underlying table that is otherwise inaccessible to the "
"user. In that case, the operator should be leak-proof or the statistics will "
"not be used. There is no direct feedback about that, except that the plan "
"might be suboptimal. If one suspects that this is the case, one could try "
"running the query as a more privileged user, to see if a different plan "
"results."
msgstr ""
"Если пользователь не имеет требуемого права доступа к таблице или столбцам, "
"то во многих случаях при выполнении запроса в конце концов возникнет ошибка "
"&laquo;нет доступа&raquo;, так что этот механизм будет незаметен на "
"практике. Но если пользователь читает данные из представления с барьером "
"безопасности, планировщик может захотеть проверить статистику нижележащей "
"таблицы, которая недоступна пользователю непосредственно. В этом случае "
"оператор должен быть герметичным; иначе статистика не будет использоваться. "
"Это не будет иметь внешних проявлений кроме того, что план запроса может "
"быть неоптимальным. В случае подозрений, что вы столкнулись с этим, "
"попробуйте запустить запрос от имени пользователя с расширенными правами и "
"проверьте, не выбирается ли другой план запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:636(para)
msgid ""
"This restriction applies only to cases where the planner would need to "
"execute a user-defined operator on one or more values from "
"<structname>pg_statistic</structname>. Thus the planner is permitted to use "
"generic statistical information, such as the fraction of null values or the "
"number of distinct values in a column, regardless of access privileges."
msgstr ""
"Это ограничение применяется только тогда, когда планировщику может "
"потребоваться выполнить пользовательский оператор с одним или несколькими "
"значениями из <structname>pg_statistic</structname>. При этом планировщику "
"разрешено использовать общую статистическую информацию, например, процент "
"значений NULL или количество различных значений в столбце, вне зависимости "
"от прав доступа."

#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:645(para)
msgid ""
"Selectivity estimation functions contained in third-party extensions that "
"potentially operate on statistics with user-defined operators should follow "
"the same security rules. Consult the PostgreSQL source code for guidance."
msgstr ""
"Реализуемые в дополнительных расширениях функции оценки избирательности, "
"которые могут обращаться к статистике, вызывая пользовательские операторы, "
"должны следовать тем же правилам безопасности. За практическими указаниями "
"обратитесь к исходному коду PostgreSQL."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: planstats.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
