# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-21 15:23+0300\n"
"PO-Revision-Date: 2017-09-22 13:37+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5(title)
msgid ""
"<application>PL/pgSQL</application> - <acronym>SQL</acronym> Procedural "
"Language"
msgstr ""
"<application>PL/pgSQL</application> — процедурный язык <acronym>SQL</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:7(indexterm)
msgid "<primary>PL/pgSQL</primary>"
msgstr "<primary>PL/pgSQL</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:12(title)
msgid "Overview"
msgstr "Обзор"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:22(para)
msgid "can be used to create functions and trigger procedures,"
msgstr "используется для создания функций и триггеров,"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:27(para)
msgid "adds control structures to the <acronym>SQL</acronym> language,"
msgstr "добавляет управляющие структуры к языку <acronym>SQL</acronym>,"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:32(para)
msgid "can perform complex computations,"
msgstr "может выполнять сложные вычисления,"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:37(para)
msgid "inherits all user-defined types, functions, and operators,"
msgstr "наследует все пользовательские типы, функции и операторы,"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:42(para)
msgid "can be defined to be trusted by the server,"
msgstr "может быть определён как доверенный язык,"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:47(para)
msgid "is easy to use."
msgstr "прост в использовании."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:14(para)
msgid ""
"<application>PL/pgSQL</application> is a loadable procedural language for "
"the <productname>PostgreSQL</productname> database system. The design goals "
"of <application>PL/pgSQL</application> were to create a loadable procedural "
"language that <placeholder-1/>"
msgstr ""
"<application>PL/pgSQL</application> это процедурный язык для СУБД "
"<productname>PostgreSQL</productname>. Целью проектирования <application>PL/"
"pgSQL</application> было создание загружаемого процедурного языка, который: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:54(para)
msgid ""
"Functions created with <application>PL/pgSQL</application> can be used "
"anywhere that built-in functions could be used. For example, it is possible "
"to create complex conditional computation functions and later use them to "
"define operators or use them in index expressions."
msgstr ""
"Функции <application>PL/pgSQL</application> могут использоваться везде, где "
"допустимы встроенные функции. Например, можно создать функции со сложными "
"вычислениями и условной логикой, а затем использовать их при определении "
"операторов или в индексных выражениях."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:62(para)
msgid ""
"In <productname>PostgreSQL</productname> 9.0 and later, <application>PL/"
"pgSQL</application> is installed by default. However it is still a loadable "
"module, so especially security-conscious administrators could choose to "
"remove it."
msgstr ""
"В версии <productname>PostgreSQL</productname> 9.0 и выше, <application>PL/"
"pgSQL</application> устанавливается по умолчанию. Тем не менее, это по-"
"прежнему загружаемый модуль и администраторы, особо заботящиеся о "
"безопасности, могут удалить его при необходимости."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:70(title)
msgid "Advantages of Using <application>PL/pgSQL</application>"
msgstr "Преимущества использования <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:72(para)
msgid ""
"<acronym>SQL</acronym> is the language <productname>PostgreSQL</productname> "
"and most other relational databases use as query language. It's portable and "
"easy to learn. But every <acronym>SQL</acronym> statement must be executed "
"individually by the database server."
msgstr ""
"<productname>PostgreSQL</productname> и большинство других СУБД используют "
"<acronym>SQL</acronym> в качестве языка запросов. <acronym>SQL</acronym> "
"хорошо переносим и прост в изучении. Однако каждый оператор <acronym>SQL</"
"acronym> выполняется индивидуально на сервере базы данных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:79(para)
msgid ""
"That means that your client application must send each query to the database "
"server, wait for it to be processed, receive and process the results, do "
"some computation, then send further queries to the server. All this incurs "
"interprocess communication and will also incur network overhead if your "
"client is on a different machine than the database server."
msgstr ""
"Это значит, что ваше клиентское приложение должно каждый запрос отправлять "
"на сервер, ждать пока он будет обработан, получать результат, делать "
"некоторые вычисления, затем отправлять последующие запросы на сервер. Всё "
"это требует межпроцессного взаимодействия, а также несёт нагрузку на сеть, "
"если клиент и сервер базы данных расположены на разных компьютерах."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:88(para)
msgid ""
"With <application>PL/pgSQL</application> you can group a block of "
"computation and a series of queries <emphasis>inside</emphasis> the database "
"server, thus having the power of a procedural language and the ease of use "
"of SQL, but with considerable savings of client/server communication "
"overhead."
msgstr ""
"<application>PL/pgSQL</application> позволяет сгруппировать блок вычислений "
"и последовательность запросов <emphasis>внутри</emphasis> сервера базы "
"данных, таким образом, мы получаем силу процедурного языка и простоту "
"использования <acronym>SQL</acronym> при значительной экономии накладных "
"расходов на клиент-серверное взаимодействие."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:97(para)
msgid "Extra round trips between client and server are eliminated"
msgstr "Исключаются дополнительные обращения между клиентом и сервером"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:100(para)
msgid ""
"Intermediate results that the client does not need do not have to be "
"marshaled or transferred between server and client"
msgstr ""
"Промежуточные ненужные результаты не передаются между сервером и клиентом"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:104(para)
msgid "Multiple rounds of query parsing can be avoided"
msgstr "Есть возможность избежать многочисленных разборов одного запроса"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:108(para)
msgid ""
"This can result in a considerable performance increase as compared to an "
"application that does not use stored functions."
msgstr ""
"В результате это приводит к значительному увеличению производительности по "
"сравнению с приложением, которое не использует хранимых функций."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:112(para)
msgid ""
"Also, with <application>PL/pgSQL</application> you can use all the data "
"types, operators and functions of SQL."
msgstr ""
"Кроме того, <application>PL/pgSQL</application> позволяет использовать все "
"типы данных, операторы и функции <acronym>SQL</acronym>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:119(title)
msgid "Supported Argument and Result Data Types"
msgstr "Поддерживаемые типы данных аргументов и возвращаемых значений"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:121(para)
msgid ""
"Functions written in <application>PL/pgSQL</application> can accept as "
"arguments any scalar or array data type supported by the server, and they "
"can return a result of any of these types. They can also accept or return "
"any composite type (row type) specified by name. It is also possible to "
"declare a <application>PL/pgSQL</application> function as returning "
"<type>record</type>, which means that the result is a row type whose columns "
"are determined by specification in the calling query, as discussed in <xref "
"linkend=\"queries-tablefunctions\"/>."
msgstr ""
"Функции на <application>PL/pgSQL</application> могут принимать в качестве "
"аргументов все поддерживаемые сервером скалярные типы данных или массивы и "
"возвращать в качестве результата любой из этих типов. Они могут принимать и "
"возвращать именованные составные типы (строковый тип). Также есть "
"возможность объявить функцию на <application>PL/pgSQL</application>, "
"возвращающую <type>record</type>, это означает, что результатом является "
"строковый тип, чьи столбцы будут определены в спецификации вызывающего "
"запроса, как описано в <xref remap=\"6\" linkend=\"queries-tablefunctions\"/"
">."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:132(para)
msgid ""
"<application>PL/pgSQL</application> functions can be declared to accept a "
"variable number of arguments by using the <literal>VARIADIC</literal> "
"marker. This works exactly the same way as for SQL functions, as discussed "
"in <xref linkend=\"xfunc-sql-variadic-functions\"/>."
msgstr ""
"Использование маркера <literal>VARIADIC</literal> позволяет объявлять "
"функции на <application>PL/pgSQL</application> с переменным числом "
"аргументов. Это работает точно так же, как и для функций на SQL, как описано "
"в <xref remap=\"6\" linkend=\"xfunc-sql-variadic-functions\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:139(para)
msgid ""
"<application>PL/pgSQL</application> functions can also be declared to accept "
"and return the polymorphic types <type>anyelement</type>, <type>anyarray</"
"type>, <type>anynonarray</type>, <type>anyenum</type>, and <type>anyrange</"
"type>. The actual data types handled by a polymorphic function can vary from "
"call to call, as discussed in <xref linkend=\"extend-types-polymorphic\"/>. "
"An example is shown in <xref linkend=\"plpgsql-declaration-parameters\"/>."
msgstr ""
"Функции на <application>PL/pgSQL</application> могут принимать и возвращать "
"полиморфные типы <type>anyelement</type>, <type>anyarray</type>, "
"<type>anynonarray</type>, <type>anyenum</type> и <type>anyrange</type>. В "
"таких случаях фактические типы данных могут меняться от вызова к вызову, как "
"описано в <xref linkend=\"extend-types-polymorphic\"/>. Пример показан в "
"<xref remap=\"6\" linkend=\"plpgsql-declaration-parameters\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:149(para)
msgid ""
"<application>PL/pgSQL</application> functions can also be declared to return "
"a <quote>set</quote> (or table) of any data type that can be returned as a "
"single instance. Such a function generates its output by executing "
"<command>RETURN NEXT</command> for each desired element of the result set, "
"or by using <command>RETURN QUERY</command> to output the result of "
"evaluating a query."
msgstr ""
"Функции на <application>PL/pgSQL</application> могут возвращать "
"<quote>множества</quote> (или таблицы) любого типа, которые могут быть "
"возвращены в виде одного объекта. Такие функции генерируют вывод, выполняя "
"команду <command>RETURN NEXT</command> для каждого элемента результирующего "
"набора или <command>RETURN QUERY</command> для вывода результата запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:158(para)
msgid ""
"Finally, a <application>PL/pgSQL</application> function can be declared to "
"return <type>void</type> if it has no useful return value."
msgstr ""
"Наконец, при отсутствии полезного возвращаемого значения функция на "
"<application>PL/pgSQL</application> может возвращать <type>void</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:163(para)
msgid ""
"<application>PL/pgSQL</application> functions can also be declared with "
"output parameters in place of an explicit specification of the return type. "
"This does not add any fundamental capability to the language, but it is "
"often convenient, especially for returning multiple values. The "
"<literal>RETURNS TABLE</literal> notation can also be used in place of "
"<literal>RETURNS SETOF</literal>."
msgstr ""
"Функции на <application>PL/pgSQL</application> можно объявить с выходными "
"параметрами вместо явного задания типа возвращаемого значения. Это не "
"добавляет никаких фундаментальных возможностей языку, но часто бывает "
"удобно, особенно для возвращения нескольких значений. Нотация "
"<literal>RETURNS TABLE</literal> может использоваться вместо "
"<literal>RETURNS SETOF</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:172(para)
msgid ""
"Specific examples appear in <xref linkend=\"plpgsql-declaration-parameters\"/"
"> and <xref linkend=\"plpgsql-statements-returning\"/>."
msgstr ""
"Конкретные примеры рассматриваются в <xref remap=\"6\" linkend=\"plpgsql-"
"declaration-parameters\"/> и <xref remap=\"6\" linkend=\"plpgsql-statements-"
"returning\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:181(title)
msgid "Structure of <application>PL/pgSQL</application>"
msgstr "Структура <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6
#: plpgsql.xml:187(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION somefunc(integer, text) RETURNS integer\n"
"AS '<replaceable>function body text</replaceable>'\n"
"LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION somefunc(integer, text) RETURNS integer\n"
"AS '<replaceable>тело функции</replaceable>'\n"
"LANGUAGE plpgsql;"

#. +> REL_10 REL9_6
#: plpgsql.xml:183(para)
msgid ""
"Functions written in <application>PL/pgSQL</application> are defined to the "
"server by executing <xref linkend=\"sql-createfunction\"/> commands. Such a "
"command would normally look like, say, <placeholder-1/> The function body is "
"simply a string literal so far as <command>CREATE FUNCTION</command> is "
"concerned. It is often helpful to use dollar quoting (see <xref linkend="
"\"sql-syntax-dollar-quoting\"/>) to write the function body, rather than the "
"normal single quote syntax. Without dollar quoting, any single quotes or "
"backslashes in the function body must be escaped by doubling them. Almost "
"all the examples in this chapter use dollar-quoted literals for their "
"function bodies."
msgstr ""
"Функции, написанные на <application>PL/pgSQL</application>, определяются на "
"сервере командами <xref linkend=\"sql-createfunction\"/>. Такая команда "
"обычно выглядит, например, так: <placeholder-1/> Если рассматривать "
"<command>CREATE FUNCTION</command>, тело функции представляет собой просто "
"текстовую строку. Часто для написания тела функции удобнее заключать эту "
"строку в доллары (см. <xref remap=\"4\" linkend=\"sql-syntax-dollar-quoting"
"\"/>), а не в обычные апострофы. Если не применять заключение в доллары, все "
"апострофы или обратные косые черты в теле функции придётся экранировать, "
"дублируя их. Почти во всех примерах в этой главе тело функций заключается в "
"доллары."

#. +> REL9_6_3
#: plpgsql.xml:183(para)
msgid ""
"<application>PL/pgSQL</application> is a block-structured language. The "
"complete text of a function definition must be a <firstterm>block</"
"firstterm>. A block is defined as: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n"
"<optional> DECLARE\n"
"    <replaceable>declarations</replaceable> </optional>\n"
"BEGIN\n"
"    <replaceable>statements</replaceable>\n"
"END <optional> <replaceable>label</replaceable> </optional>;\n"
"</synopsis>"
msgstr ""
"<application>PL/pgSQL</application> это блочно-структурированный язык. Текст "
"определения функции должен быть <firstterm>блоком</firstterm>. Структура "
"блока: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>\n"
"<optional> DECLARE\n"
"    <replaceable>объявления</replaceable> </optional>\n"
"BEGIN\n"
"    <replaceable>операторы</replaceable>\n"
"END <optional> <replaceable>метка</replaceable> </optional>;\n"
"</synopsis>"

#. +> REL_10 REL9_6
#: plpgsql.xml:201(para)
msgid ""
"<application>PL/pgSQL</application> is a block-structured language. The "
"complete text of a function body must be a <firstterm>block</firstterm>. A "
"block is defined as: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n"
"<optional> DECLARE\n"
"    <replaceable>declarations</replaceable> </optional>\n"
"BEGIN\n"
"    <replaceable>statements</replaceable>\n"
"END <optional> <replaceable>label</replaceable> </optional>;\n"
"</synopsis>"
msgstr ""
"<application>PL/pgSQL</application> это блочно-структурированный язык. Текст "
"тела функции должен быть <firstterm>блоком</firstterm>. Структура блока: "
"<synopsis>\n"
"<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>\n"
"<optional> DECLARE\n"
"    <replaceable>объявления</replaceable> </optional>\n"
"BEGIN\n"
"    <replaceable>операторы</replaceable>\n"
"END <optional> <replaceable>метка</replaceable> </optional>;\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:216(para)
msgid ""
"Each declaration and each statement within a block is terminated by a "
"semicolon. A block that appears within another block must have a semicolon "
"after <literal>END</literal>, as shown above; however the final "
"<literal>END</literal> that concludes a function body does not require a "
"semicolon."
msgstr ""
"Каждое объявление и каждый оператор в блоке должны завершаться символом \";"
"\"(точка с запятой). Блок, вложенный в другой блок, должен иметь точку с "
"запятой после <literal>END</literal>, как показано выше. Однако финальный "
"<literal>END</literal>, завершающий тело функции, не требует точки с запятой."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:225(para)
msgid ""
"A common mistake is to write a semicolon immediately after <literal>BEGIN</"
"literal>. This is incorrect and will result in a syntax error."
msgstr ""
"Распространённой ошибкой является добавление точки с запятой сразу после "
"<literal>BEGIN</literal>. Это неправильно и приведёт к синтаксической ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:231(para)
msgid ""
"A <replaceable>label</replaceable> is only needed if you want to identify "
"the block for use in an <literal>EXIT</literal> statement, or to qualify the "
"names of the variables declared in the block. If a label is given after "
"<literal>END</literal>, it must match the label at the block's beginning."
msgstr ""
"<replaceable>Метка</replaceable> требуется только тогда, когда нужно "
"идентифицировать блок в операторе <literal>EXIT</literal>, или дополнить "
"имена переменных, объявленных в этом блоке. Если метка указана после "
"<literal>END</literal>, то она должна совпадать с меткой в начале блока."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:239(para)
msgid ""
"All key words are case-insensitive. Identifiers are implicitly converted to "
"lower case unless double-quoted, just as they are in ordinary SQL commands."
msgstr ""
"Ключевые слова не чувствительны к регистру символов. Как и в обычных SQL-"
"командах, идентификаторы неявно преобразуются к нижнему регистру, если они "
"не взяты в двойные кавычки."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:245(para)
msgid ""
"Comments work the same way in <application>PL/pgSQL</application> code as in "
"ordinary SQL. A double dash (<literal>--</literal>) starts a comment that "
"extends to the end of the line. A <literal>/*</literal> starts a block "
"comment that extends to the matching occurrence of <literal>*/</literal>. "
"Block comments nest."
msgstr ""
"Комментарии в <application>PL/pgSQL</application> коде работают так же, как "
"и в обычном SQL. Двойное тире (<literal>--</literal>) начинает комментарий, "
"который завершается в конце строки. Блочный комментарий начинается с "
"<literal>/*</literal> и завершается <literal>*/</literal>. Блочные "
"комментарии могут быть вложенными."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:261(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION somefunc() RETURNS integer AS $$\n"
"&lt;&lt; outerblock &gt;&gt;\n"
"DECLARE\n"
"    quantity integer := 30;\n"
"BEGIN\n"
"    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30\n"
"    quantity := 50;\n"
"    --\n"
"    -- Create a subblock\n"
"    --\n"
"    DECLARE\n"
"        quantity integer := 80;\n"
"    BEGIN\n"
"        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80\n"
"        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50\n"
"    END;\n"
"\n"
"    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50\n"
"\n"
"    RETURN quantity;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION somefunc() RETURNS integer AS $$\n"
"&lt;&lt; outerblock &gt;&gt;\n"
"DECLARE\n"
"    quantity integer := 30;\n"
"BEGIN\n"
"    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 30\n"
"    quantity := 50;\n"
"    --\n"
"    -- Создаем вложенный блок\n"
"    --\n"
"    DECLARE\n"
"        quantity integer := 80;\n"
"    BEGIN\n"
"        RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 80\n"
"        RAISE NOTICE 'Во внешнем блоке quantity = %', outerblock.quantity;  -- Выводится 50\n"
"    END;\n"
"\n"
"    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 50\n"
"\n"
"    RETURN quantity;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:253(para)
msgid ""
"Any statement in the statement section of a block can be a "
"<firstterm>subblock</firstterm>. Subblocks can be used for logical grouping "
"or to localize variables to a small group of statements. Variables declared "
"in a subblock mask any similarly-named variables of outer blocks for the "
"duration of the subblock; but you can access the outer variables anyway if "
"you qualify their names with their block's label. For example: "
"<placeholder-1/>"
msgstr ""
"Любой оператор в выполняемой секции блока может быть <firstterm>вложенным "
"блоком</firstterm>. Вложенные блоки используются для логической группировки "
"нескольких операторов или локализации области действия переменных для группы "
"операторов. Во время выполнения вложенного блока переменные, объявленные в "
"нём, скрывают переменные внешних блоков с такими же именами. Чтобы получить "
"доступ к внешним переменным, нужно дополнить их имена меткой блока. "
"Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:288(para)
msgid ""
"There is actually a hidden <quote>outer block</quote> surrounding the body "
"of any <application>PL/pgSQL</application> function. This block provides the "
"declarations of the function's parameters (if any), as well as some special "
"variables such as <literal>FOUND</literal> (see <xref linkend=\"plpgsql-"
"statements-diagnostics\"/>). The outer block is labeled with the function's "
"name, meaning that parameters and special variables can be qualified with "
"the function's name."
msgstr ""
"Существует скрытый <quote>внешний блок</quote>, окружающий тело каждой "
"функции на <application>PL/pgSQL</application>. Этот блок содержит "
"объявления параметров функции (если они есть), а также некоторые специальные "
"переменные, такие как <literal>FOUND</literal> (см. <xref remap=\"4\" "
"linkend=\"plpgsql-statements-diagnostics\"/>). Этот блок имеет метку, "
"совпадающую с именем функции, таким образом, параметры и специальные "
"переменные могут быть дополнены именем функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:299(para)
msgid ""
"It is important not to confuse the use of <command>BEGIN</command>/"
"<command>END</command> for grouping statements in <application>PL/pgSQL</"
"application> with the similarly-named SQL commands for transaction control. "
"<application>PL/pgSQL</application>'s <command>BEGIN</command>/<command>END</"
"command> are only for grouping; they do not start or end a transaction. "
"Functions and trigger procedures are always executed within a transaction "
"established by an outer query &mdash; they cannot start or commit that "
"transaction, since there would be no context for them to execute in. "
"However, a block containing an <literal>EXCEPTION</literal> clause "
"effectively forms a subtransaction that can be rolled back without affecting "
"the outer transaction. For more about that see <xref linkend=\"plpgsql-error-"
"trapping\"/>."
msgstr ""
"Важно не путать использование <command>BEGIN</command>/<command>END</"
"command> для группировки операторов в <application>PL/pgSQL</application> с "
"одноименными SQL-командами для управления транзакциями. <command>BEGIN</"
"command>/<command>END</command> в <application>PL/pgSQL</application> служат "
"только для группировки предложений; они не начинают и не заканчивают "
"транзакции. Функции и триггерные процедуры всегда выполняются в рамках "
"транзакции, начатой во внешнем запросе — они не могут начать или завершить "
"эту транзакцию, так как у них внутри нет контекста для выполнения таких "
"действий. Однако блок содержащий секцию <literal>EXCEPTION</literal> создаёт "
"вложенную транзакцию, которая может быть отменена, не затрагивая внешней "
"транзакции. Подробнее это описано в <xref remap=\"6\" linkend=\"plpgsql-"
"error-trapping\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:317(title)
msgid "Declarations"
msgstr "Объявления"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:319(para)
msgid ""
"All variables used in a block must be declared in the declarations section "
"of the block. (The only exceptions are that the loop variable of a "
"<literal>FOR</literal> loop iterating over a range of integer values is "
"automatically declared as an integer variable, and likewise the loop "
"variable of a <literal>FOR</literal> loop iterating over a cursor's result "
"is automatically declared as a record variable.)"
msgstr ""
"Все переменные, используемые в блоке, должны быть определены в секции "
"объявления. (За исключением переменной-счётчика цикла <literal>FOR</"
"literal>, которая объявляется автоматически. Для цикла по диапазону чисел "
"автоматически объявляется целочисленная переменная, а для цикла по "
"результатам курсора - переменная типа <literal>record</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:329(para)
msgid ""
"<application>PL/pgSQL</application> variables can have any SQL data type, "
"such as <type>integer</type>, <type>varchar</type>, and <type>char</type>."
msgstr ""
"Переменные <application>PL/pgSQL</application> могут иметь любой тип данных "
"SQL, такой как <type>integer</type>, <type>varchar</type>, <type>char</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:337(programlisting)
#, no-wrap
msgid ""
"user_id integer;\n"
"quantity numeric(5);\n"
"url varchar;\n"
"myrow tablename%ROWTYPE;\n"
"myfield tablename.columnname%TYPE;\n"
"arow RECORD;"
msgstr ""
"user_id integer;\n"
"quantity numeric(5);\n"
"url varchar;\n"
"myrow tablename%ROWTYPE;\n"
"myfield tablename.columnname%TYPE;\n"
"arow RECORD;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:335(para)
msgid "Here are some examples of variable declarations: <placeholder-1/>"
msgstr "Примеры объявления переменных: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:347(para)
msgid ""
"The general syntax of a variable declaration is: <synopsis>\n"
"<replaceable>name</replaceable> <optional> CONSTANT </optional> "
"<replaceable>type</replaceable> <optional> COLLATE "
"<replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </"
"optional> <optional> { DEFAULT | := | = } <replaceable>expression</"
"replaceable> </optional>;\n"
"</synopsis> The <literal>DEFAULT</literal> clause, if given, specifies the "
"initial value assigned to the variable when the block is entered. If the "
"<literal>DEFAULT</literal> clause is not given then the variable is "
"initialized to the <acronym>SQL</acronym> null value. The <literal>CONSTANT</"
"literal> option prevents the variable from being assigned to after "
"initialization, so that its value will remain constant for the duration of "
"the block. The <literal>COLLATE</literal> option specifies a collation to "
"use for the variable (see <xref linkend=\"plpgsql-declaration-collation\"/"
">). If <literal>NOT NULL</literal> is specified, an assignment of a null "
"value results in a run-time error. All variables declared as <literal>NOT "
"NULL</literal> must have a nonnull default value specified. Equal "
"(<literal>=</literal>) can be used instead of PL/SQL-compliant <literal>:=</"
"literal>."
msgstr ""
"Общий синтаксис объявления переменной: <synopsis>\n"
"<replaceable>имя</replaceable> <optional> CONSTANT </optional> "
"<replaceable>тип</replaceable> <optional> COLLATE "
"<replaceable>имя_правила_сортировки</replaceable> </optional> <optional> NOT "
"NULL </optional> <optional> { DEFAULT | := | = } <replaceable>выражение</"
"replaceable> </optional>;\n"
"</synopsis> Предложение <literal>DEFAULT</literal>, если присутствует, "
"задаёт начальное значение, которое присваивается переменной при входе в "
"блок. Если отсутствует, то переменная инициализируется <acronym>SQL</"
"acronym>-значением <literal>NULL</literal>. Указание <literal>CONSTANT</"
"literal> предотвращает изменение значения переменной после инициализации, "
"таким образом, значение остаётся постоянным в течение всего блока. Параметр "
"<literal>COLLATE</literal> определяет правило сортировки, которое будет "
"использоваться для этой переменной (см. <xref remap=\"4\" linkend=\"plpgsql-"
"declaration-collation\"/>). Если указано <literal>NOT NULL</literal>, то "
"попытка присвоить <literal>NULL</literal> во время выполнения приведёт к "
"ошибке. Все переменные, объявленные как <literal>NOT NULL</literal>, должны "
"иметь непустые значения по умолчанию. Можно использовать знак равенства "
"(<literal>=</literal>) вместо совместимого с PL/SQL <literal>:=</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:369(para)
msgid ""
"A variable's default value is evaluated and assigned to the variable each "
"time the block is entered (not just once per function call). So, for "
"example, assigning <literal>now()</literal> to a variable of type "
"<type>timestamp</type> causes the variable to have the time of the current "
"function call, not the time when the function was precompiled."
msgstr ""
"Значение по умолчанию вычисляется и присваивается переменной каждый раз при "
"входе в блок (не только при первом вызове функции). Так, например, если "
"переменная типа <type>timestamp</type> имеет функцию <literal>now()</"
"literal> в качестве значения по умолчанию, это приведёт к тому, что "
"переменная всегда будет содержать время текущего вызова функции, а не время, "
"когда функция была предварительно скомпилирована."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:380(programlisting)
#, no-wrap
msgid ""
"quantity integer DEFAULT 32;\n"
"url varchar := 'http://mysite.com';\n"
"user_id CONSTANT integer := 10;"
msgstr ""
"quantity integer DEFAULT 32;\n"
"url varchar := 'http://mysite.com';\n"
"user_id CONSTANT integer := 10;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:378(para) plpgsql.xml:583(para) plpgsql.xml:913(para)
#: plpgsql.xml:2216(para) plpgsql.xml:2278(para) plpgsql.xml:3185(para)
#: plpgsql.xml:3232(para)
msgid "Examples: <placeholder-1/>"
msgstr "Примеры: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:388(title)
msgid "Declaring Function Parameters"
msgstr "Объявление параметров функции"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:390(para)
msgid ""
"Parameters passed to functions are named with the identifiers <literal>$1</"
"literal>, <literal>$2</literal>, etc. Optionally, aliases can be declared "
"for <literal>$<replaceable>n</replaceable></literal> parameter names for "
"increased readability. Either the alias or the numeric identifier can then "
"be used to refer to the parameter value."
msgstr ""
"Переданные в функцию параметры именуются идентификаторами <literal>$1</"
"literal>, <literal>$2</literal> и т. д. Дополнительно, для улучшения "
"читаемости, можно объявить псевдонимы для параметров <literal>"
"$<replaceable>n</replaceable></literal>. Либо псевдоним, либо цифровой "
"идентификатор используются для обозначения параметра."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:403(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$\n"
"BEGIN\n"
"    RETURN subtotal * 0.06;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$\n"
"BEGIN\n"
"    RETURN subtotal * 0.06;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:418(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION sales_tax(real) RETURNS real AS $$\n"
"DECLARE\n"
"    subtotal ALIAS FOR $1;\n"
"BEGIN\n"
"    RETURN subtotal * 0.06;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION sales_tax(real) RETURNS real AS $$\n"
"DECLARE\n"
"    subtotal ALIAS FOR $1;\n"
"BEGIN\n"
"    RETURN subtotal * 0.06;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:399(para)
msgid ""
"There are two ways to create an alias. The preferred way is to give a name "
"to the parameter in the <command>CREATE FUNCTION</command> command, for "
"example: <placeholder-1/> The other way is to explicitly declare an alias, "
"using the declaration syntax <synopsis>\n"
"<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;\n"
"</synopsis> The same example in this style looks like: <placeholder-2/>"
msgstr ""
"Создать псевдоним можно двумя способами. Предпочтительный способ это дать "
"имя параметру в команде <command>CREATE FUNCTION</command>, например: "
"<placeholder-1/> Другой способ это явное объявление псевдонима при помощи "
"синтаксиса: <synopsis>\n"
"<replaceable>имя</replaceable> ALIAS FOR $<replaceable>n</replaceable>;\n"
"</synopsis> Предыдущий пример для этого стиля выглядит так: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:430(para)
msgid ""
"These two examples are not perfectly equivalent. In the first case, "
"<literal>subtotal</literal> could be referenced as <literal>sales_tax."
"subtotal</literal>, but in the second case it could not. (Had we attached a "
"label to the inner block, <literal>subtotal</literal> could be qualified "
"with that label, instead.)"
msgstr ""
"Эти два примера не полностью эквивалентны. В первом случае, на "
"<literal>subtotal</literal> можно ссылаться как <literal>sales_tax.subtotal</"
"literal>, а во втором случае такая ссылка невозможна. (Если бы к внутреннему "
"блоку была добавлена метка, то <literal>subtotal</literal> можно было бы "
"дополнить этой меткой.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:441(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$\n"
"DECLARE\n"
"    v_string ALIAS FOR $1;\n"
"    index ALIAS FOR $2;\n"
"BEGIN\n"
"    -- some computations using v_string and index here\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"\n"
"CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$\n"
"BEGIN\n"
"    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$\n"
"DECLARE\n"
"    v_string ALIAS FOR $1;\n"
"    index ALIAS FOR $2;\n"
"BEGIN\n"
"    -- здесь вычисления, использующие v_string и index\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"\n"
"CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$\n"
"BEGIN\n"
"    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:439(para)
msgid "Some more examples: <placeholder-1/>"
msgstr "Ещё несколько примеров: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:470(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$\n"
"BEGIN\n"
"    tax := subtotal * 0.06;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$\n"
"BEGIN\n"
"    tax := subtotal * 0.06;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:460(para)
msgid ""
"When a <application>PL/pgSQL</application> function is declared with output "
"parameters, the output parameters are given <literal>$<replaceable>n</"
"replaceable></literal> names and optional aliases in just the same way as "
"the normal input parameters. An output parameter is effectively a variable "
"that starts out NULL; it should be assigned to during the execution of the "
"function. The final value of the parameter is what is returned. For "
"instance, the sales-tax example could also be done this way: <placeholder-1/"
"> Notice that we omitted <literal>RETURNS real</literal> &mdash; we could "
"have included it, but it would be redundant."
msgstr ""
"Когда функция на <application>PL/pgSQL</application> объявляется с выходными "
"параметрами, им выдаются цифровые идентификаторы <literal>$<replaceable>n</"
"replaceable></literal> и для них можно создавать псевдонимы точно таким же "
"способом, как и для обычных входных параметров. Выходной параметр это "
"фактически переменная, стартующая с NULL и которой присваивается значение во "
"время выполнения функции. Возвращается последнее присвоенное значение. "
"Например, функция sales_tax может быть переписана так: <placeholder-1/> "
"Обратите внимание, что мы опустили <literal>RETURNS real</literal> &mdash; "
"хотя можно было и включить, но это было бы излишним."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:486(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$\n"
"BEGIN\n"
"    sum := x + y;\n"
"    prod := x * y;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$\n"
"BEGIN\n"
"    sum := x + y;\n"
"    prod := x * y;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:482(para)
msgid ""
"Output parameters are most useful when returning multiple values. A trivial "
"example is: <placeholder-1/> As discussed in <xref linkend=\"xfunc-output-"
"parameters\"/>, this effectively creates an anonymous record type for the "
"function's results. If a <literal>RETURNS</literal> clause is given, it must "
"say <literal>RETURNS record</literal>."
msgstr ""
"Выходные параметры наиболее полезны для возвращения нескольких значений. "
"Простейший пример: <placeholder-1/> Как обсуждалось в <xref remap=\"6\" "
"linkend=\"xfunc-output-parameters\"/>, здесь фактически создаётся анонимный "
"тип <literal>record</literal> для возвращения результата функции. Если "
"используется предложение <literal>RETURNS</literal>, то оно должна выглядеть "
"как <literal>RETURNS record</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:505(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION extended_sales(p_itemno int)\n"
"RETURNS TABLE(quantity int, total numeric) AS $$\n"
"BEGIN\n"
"    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s\n"
"                 WHERE s.itemno = p_itemno;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION extended_sales(p_itemno int)\n"
"RETURNS TABLE(quantity int, total numeric) AS $$\n"
"BEGIN\n"
"    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales s\n"
"                 WHERE s.itemno = p_itemno;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:501(para)
msgid ""
"Another way to declare a <application>PL/pgSQL</application> function is "
"with <literal>RETURNS TABLE</literal>, for example: <placeholder-1/> This is "
"exactly equivalent to declaring one or more <literal>OUT</literal> "
"parameters and specifying <literal>RETURNS SETOF <replaceable>sometype</"
"replaceable></literal>."
msgstr ""
"Есть ещё способ объявить функцию на <application>PL/pgSQL</application> с "
"использованием <literal>RETURNS TABLE</literal>, например: <placeholder-1/> "
"Это в точности соответствует объявлению одного или нескольких параметров "
"<literal>OUT</literal> и указанию <literal>RETURNS SETOF "
"<replaceable>некий_тип</replaceable></literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:536(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)\n"
"RETURNS anyelement AS $$\n"
"DECLARE\n"
"    result ALIAS FOR $0;\n"
"BEGIN\n"
"    result := v1 + v2 + v3;\n"
"    RETURN result;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)\n"
"RETURNS anyelement AS $$\n"
"DECLARE\n"
"    result ALIAS FOR $0;\n"
"BEGIN\n"
"    result := v1 + v2 + v3;\n"
"    RETURN result;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:520(para)
msgid ""
"When the return type of a <application>PL/pgSQL</application> function is "
"declared as a polymorphic type (<type>anyelement</type>, <type>anyarray</"
"type>, <type>anynonarray</type>, <type>anyenum</type>, or <type>anyrange</"
"type>), a special parameter <literal>$0</literal> is created. Its data type "
"is the actual return type of the function, as deduced from the actual input "
"types (see <xref linkend=\"extend-types-polymorphic\"/>). This allows the "
"function to access its actual return type as shown in <xref linkend="
"\"plpgsql-declaration-type\"/>. <literal>$0</literal> is initialized to null "
"and can be modified by the function, so it can be used to hold the return "
"value if desired, though that is not required. <literal>$0</literal> can "
"also be given an alias. For example, this function works on any data type "
"that has a <literal>+</literal> operator: <placeholder-1/>"
msgstr ""
"Для функции на <application>PL/pgSQL</application>, возвращающей полиморфный "
"тип (<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</"
"type>, <type>anyenum</type>, <type>anyrange</type>), создаётся специальный "
"параметр <literal>$0</literal>. Его тип данных соответствует типу, "
"фактически возвращаемому функцией, и который устанавливается на основании "
"фактических типов входных параметров (см. <xref remap=\"4\" linkend=\"extend-"
"types-polymorphic\"/>). Это позволяет функции получить доступ к фактически "
"возвращаемому типу данных, как показано в <xref remap=\"6\" linkend="
"\"plpgsql-declaration-type\"/>. Параметр <literal>$0</literal> "
"инициализируется в <literal>NULL</literal> и его можно изменять внутри "
"функции. Таким образом, его можно использовать для хранения возвращаемого "
"значения, хотя это необязательно. Параметру <literal>$0</literal> можно дать "
"псевдоним. В следующем примере функция работает с любым типом данных, "
"поддерживающим оператор <literal>+</literal>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:555(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,\n"
"                                 OUT sum anyelement)\n"
"AS $$\n"
"BEGIN\n"
"    sum := v1 + v2 + v3;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,\n"
"                                 OUT sum anyelement)\n"
"AS $$\n"
"BEGIN\n"
"    sum := v1 + v2 + v3;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:549(para)
msgid ""
"The same effect can be obtained by declaring one or more output parameters "
"as polymorphic types. In this case the special <literal>$0</literal> "
"parameter is not used; the output parameters themselves serve the same "
"purpose. For example: <placeholder-1/>"
msgstr ""
"Такой же эффект получается при объявлении одного или нескольких выходных "
"параметров полиморфного типа. При этом <literal>$0</literal> не создаётся; "
"выходные параметры сами используются для этой цели. Например: <placeholder-1/"
">"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:568(literal)
msgid "ALIAS"
msgstr "ALIAS"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:571(replaceable)
msgid "newname"
msgstr "новое_имя"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:571(replaceable)
msgid "oldname"
msgstr "старое_имя"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:570(synopsis)
#, no-wrap
msgid "<placeholder-1/> ALIAS FOR <placeholder-2/>;"
msgstr "<placeholder-1/> ALIAS FOR <placeholder-2/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:574(para)
msgid ""
"The <literal>ALIAS</literal> syntax is more general than is suggested in the "
"previous section: you can declare an alias for any variable, not just "
"function parameters. The main practical use for this is to assign a "
"different name for variables with predetermined names, such as <varname>NEW</"
"varname> or <varname>OLD</varname> within a trigger procedure."
msgstr ""
"Синтаксис <literal>ALIAS</literal> более общий, чем предполагалось в "
"предыдущем разделе: псевдонимы можно объявлять для любых переменных, а не "
"только для параметров функции. Основная практическая польза в том, чтобы "
"назначить другие имена переменным с предопределёнными названиями, таким как "
"<varname>NEW</varname> или <varname>OLD</varname> в триггерной процедуре."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:585(programlisting)
#, no-wrap
msgid ""
"DECLARE\n"
"  prior ALIAS FOR old;\n"
"  updated ALIAS FOR new;"
msgstr ""
"DECLARE\n"
"  prior ALIAS FOR old;\n"
"  updated ALIAS FOR new;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:592(para)
msgid ""
"Since <literal>ALIAS</literal> creates two different ways to name the same "
"object, unrestricted use can be confusing. It's best to use it only for the "
"purpose of overriding predetermined names."
msgstr ""
"Поскольку <literal>ALIAS</literal> даёт два различных способа именования "
"одних и тех же объектов, то его неограниченное использование может привести "
"к путанице. Лучше всего использовать <literal>ALIAS</literal> для "
"переименования предопределённых имён."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:600(title)
msgid "Copying Types"
msgstr "Наследование типов данных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:603(replaceable)
msgid "variable"
msgstr "переменная"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:602(synopsis)
#, no-wrap
msgid "<placeholder-1/>%TYPE"
msgstr "<placeholder-1/>%TYPE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:613(programlisting)
#, no-wrap
msgid "user_id users.user_id%TYPE;"
msgstr "user_id users.user_id%TYPE;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:606(para)
msgid ""
"<literal>%TYPE</literal> provides the data type of a variable or table "
"column. You can use this to declare variables that will hold database "
"values. For example, let's say you have a column named <literal>user_id</"
"literal> in your <literal>users</literal> table. To declare a variable with "
"the same data type as <literal>users.user_id</literal> you write: "
"<placeholder-1/>"
msgstr ""
"Конструкция <literal>%TYPE</literal> предоставляет тип данных переменной или "
"столбца таблицы. Её можно использовать для объявления переменных, содержащих "
"значения из базы данных. Например, для объявления переменной с таким же "
"типом, как и столбец <literal>user_id</literal> в таблице <literal>users</"
"literal> нужно написать: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:618(para)
msgid ""
"By using <literal>%TYPE</literal> you don't need to know the data type of "
"the structure you are referencing, and most importantly, if the data type of "
"the referenced item changes in the future (for instance: you change the type "
"of <literal>user_id</literal> from <type>integer</type> to <type>real</"
"type>), you might not need to change your function definition."
msgstr ""
"Используя <literal>%TYPE</literal>, не нужно знать тип данных структуры, на "
"которую вы ссылаетесь. И самое главное, если в будущем тип данных изменится "
"(например: тип данных для <literal>user_id</literal> поменяется с "
"<type>integer</type> на <type>real</type>), то вам может не понадобиться "
"изменять определение функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:627(para)
msgid ""
"<literal>%TYPE</literal> is particularly valuable in polymorphic functions, "
"since the data types needed for internal variables can change from one call "
"to the next. Appropriate variables can be created by applying <literal>"
"%TYPE</literal> to the function's arguments or result placeholders."
msgstr ""
"Использование <literal>%TYPE</literal> особенно полезно в полиморфных "
"функциях, поскольку типы данных, необходимые для внутренних переменных, "
"могут меняться от одного вызова к другому. Соответствующие переменные могут "
"быть созданы с применением <literal>%TYPE</literal> к аргументам и "
"возвращаемому значению функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:638(title)
msgid "Row Types"
msgstr "Типы кортежей"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:641(replaceable) plpgsql.xml:642(replaceable)
#: plpgsql.xml:706(replaceable) plpgsql.xml:2334(replaceable)
msgid "name"
msgstr "имя"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:641(replaceable)
msgid "table_name"
msgstr "имя_таблицы"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:641(literal)
msgid "%ROWTYPE"
msgstr "%ROWTYPE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:642(replaceable)
msgid "composite_type_name"
msgstr "имя_составного_типа"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:640(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> <placeholder-2/><placeholder-3/>;\n"
"<placeholder-4/> <placeholder-5/>;"
msgstr ""
"<placeholder-1/> <placeholder-2/><placeholder-3/>;\n"
"<placeholder-4/> <placeholder-5/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:645(para)
msgid ""
"A variable of a composite type is called a <firstterm>row</firstterm> "
"variable (or <firstterm>row-type</firstterm> variable). Such a variable can "
"hold a whole row of a <command>SELECT</command> or <command>FOR</command> "
"query result, so long as that query's column set matches the declared type "
"of the variable. The individual fields of the row value are accessed using "
"the usual dot notation, for example <literal>rowvar.field</literal>."
msgstr ""
"Переменная составного типа называется <firstterm>строковой</firstterm> "
"переменной (или переменной <firstterm>типа строки</firstterm>). Значением "
"такой переменной может быть целая строка, полученная в результате выполнения "
"запроса <command>SELECT</command> или <command>FOR</command>, при условии, "
"что набор столбцов запроса соответствует заявленному типу переменной. Доступ "
"к отдельным значениям полей строковой переменной осуществляется, как обычно, "
"через точку, например <literal>rowvar.field</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:656(para)
msgid ""
"A row variable can be declared to have the same type as the rows of an "
"existing table or view, by using the <replaceable>table_name</"
"replaceable><literal>%ROWTYPE</literal> notation; or it can be declared by "
"giving a composite type's name. (Since every table has an associated "
"composite type of the same name, it actually does not matter in "
"<productname>PostgreSQL</productname> whether you write <literal>%ROWTYPE</"
"literal> or not. But the form with <literal>%ROWTYPE</literal> is more "
"portable.)"
msgstr ""
"Строковая переменная может быть объявлена с таким же типом, как и строка в "
"существующей таблице или представлении, используя нотацию "
"<replaceable>имя_таблицы</replaceable><literal>%ROWTYPE</literal>; или с "
"именем составного типа. (Поскольку каждая таблица имеет соответствующий "
"составной тип с таким же именем, то на самом деле в <productname>PostgreSQL</"
"productname> не имеет значения, пишете ли вы <literal>%ROWTYPE</literal> или "
"нет. Но использование <literal>%ROWTYPE</literal> более переносимо.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:667(para)
msgid ""
"Parameters to a function can be composite types (complete table rows). In "
"that case, the corresponding identifier <literal>$<replaceable>n</"
"replaceable></literal> will be a row variable, and fields can be selected "
"from it, for example <literal>$1.user_id</literal>."
msgstr ""
"Параметры функции могут быть составного типа (строки таблицы). В этом случае "
"соответствующий идентификатор <literal>$<replaceable>n</replaceable></"
"literal> будет строковой переменной, поля которой можно выбирать, например "
"<literal>$1.user_id</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:674(para)
msgid ""
"Only the user-defined columns of a table row are accessible in a row-type "
"variable, not the OID or other system columns (because the row could be from "
"a view). The fields of the row type inherit the table's field size or "
"precision for data types such as <type>char(<replaceable>n</replaceable>)</"
"type>."
msgstr ""
"Только определённые пользователем столбцы таблицы доступны в переменной "
"строкового типа, но не OID или другие системные столбцы (потому что это "
"может быть строка представления). Поля строкового типа наследуют размер и "
"точность от типов данных столбцов таблицы, таких как "
"<type>char(<replaceable>n</replaceable>)</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:687(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$\n"
"DECLARE\n"
"    t2_row table2%ROWTYPE;\n"
"BEGIN\n"
"    SELECT * INTO t2_row FROM table2 WHERE ... ;\n"
"    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT merge_fields(t.*) FROM table1 t WHERE ... ;"
msgstr ""
"CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$\n"
"DECLARE\n"
"    t2_row table2%ROWTYPE;\n"
"BEGIN\n"
"    SELECT * INTO t2_row FROM table2 WHERE ... ;\n"
"    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT merge_fields(t.*) FROM table1 t WHERE ... ;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:682(para)
msgid ""
"Here is an example of using composite types. <structname>table1</structname> "
"and <structname>table2</structname> are existing tables having at least the "
"mentioned fields: <placeholder-1/>"
msgstr ""
"Ниже приведён пример использования составных типов. <structname>table1</"
"structname> и <structname>table2</structname> это существующие таблицы, "
"имеющие, по меньшей мере, перечисленные столбцы: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:703(title)
msgid "Record Types"
msgstr "Тип <type>record</type>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:705(synopsis)
#, no-wrap
msgid "<placeholder-1/> RECORD;"
msgstr "<placeholder-1/> RECORD;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:709(para)
msgid ""
"Record variables are similar to row-type variables, but they have no "
"predefined structure. They take on the actual row structure of the row they "
"are assigned during a <command>SELECT</command> or <command>FOR</command> "
"command. The substructure of a record variable can change each time it is "
"assigned to. A consequence of this is that until a record variable is first "
"assigned to, it has no substructure, and any attempt to access a field in it "
"will draw a run-time error."
msgstr ""
"Переменные типа <type>record</type> похожи на переменные строкового типа, но "
"они не имеют предопределённой структуры. Они приобретают фактическую "
"структуру от строки, которая им присваивается командами <command>SELECT</"
"command> или <command>FOR</command>. Структура переменной типа <type>record</"
"type> может меняться каждый раз при присвоении значения. Следствием этого "
"является то, что пока значение не присвоено первый раз, переменная типа "
"<type>record</type> не имеет структуры и любая попытка получить доступ к "
"отдельному полю приведёт к ошибке во время исполнения."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:719(para)
msgid ""
"Note that <literal>RECORD</literal> is not a true data type, only a "
"placeholder. One should also realize that when a <application>PL/pgSQL</"
"application> function is declared to return type <type>record</type>, this "
"is not quite the same concept as a record variable, even though such a "
"function might use a record variable to hold its result. In both cases the "
"actual row structure is unknown when the function is written, but for a "
"function returning <type>record</type> the actual structure is determined "
"when the calling query is parsed, whereas a record variable can change its "
"row structure on-the-fly."
msgstr ""
"Обратите внимание, что <literal>RECORD</literal> это не подлинный тип "
"данных, а только лишь заполнитель. Также следует понимать, что функция на "
"<application>PL/pgSQL</application>, имеющая тип возвращаемого значения "
"<type>record</type>, это не то же самое, что и переменная типа <type>record</"
"type>, хотя такая функция может использовать переменную типа <type>record</"
"type> для хранения своего результата. В обоих случаях фактическая структура "
"строки неизвестна во время создания функции, но для функции, возвращающей "
"<type>record</type>, фактическая структура определяется во время разбора "
"вызывающего запроса, в то время как переменная типа <type>record</type> "
"может менять свою структуру на лету."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:733(title)
msgid "Collation of <application>PL/pgSQL</application> Variables"
msgstr "Упорядочение переменных <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:735(indexterm)
msgid "<primary>collation</primary> <secondary>in PL/pgSQL</secondary>"
msgstr ""
"<primary>правило сортировки</primary> <secondary>на PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:751(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\n"
"BEGIN\n"
"    RETURN a &lt; b;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT less_than(text_field_1, text_field_2) FROM table1;\n"
"SELECT less_than(text_field_1, text_field_2 COLLATE \"C\") FROM table1;"
msgstr ""
"CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\n"
"BEGIN\n"
"    RETURN a &lt; b;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT less_than(text_field_1, text_field_2) FROM table1;\n"
"SELECT less_than(text_field_1, text_field_2 COLLATE \"C\") FROM table1;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:740(para)
msgid ""
"When a <application>PL/pgSQL</application> function has one or more "
"parameters of collatable data types, a collation is identified for each "
"function call depending on the collations assigned to the actual arguments, "
"as described in <xref linkend=\"collation\"/>. If a collation is "
"successfully identified (i.e., there are no conflicts of implicit collations "
"among the arguments) then all the collatable parameters are treated as "
"having that collation implicitly. This will affect the behavior of collation-"
"sensitive operations within the function. For example, consider "
"<placeholder-1/> The first use of <function>less_than</function> will use "
"the common collation of <structfield>text_field_1</structfield> and "
"<structfield>text_field_2</structfield> for the comparison, while the second "
"use will use <literal>C</literal> collation."
msgstr ""
"Когда функция на <application>PL/pgSQL</application> имеет один или "
"несколько параметров сортируемых типов данных, правило сортировки "
"определяется при каждом вызове функции в зависимости от правил сортировки "
"фактических аргументов, как описано в <xref remap=\"6\" linkend=\"collation"
"\"/>. Если оно определено успешно (т. е. среди аргументов нет конфликтов "
"между неявными правилами сортировки), то все соответствующие параметры "
"неявно трактуются как имеющее это правило сортировки. Внутри функции это "
"будет влиять на поведение операторов, зависящих от используемого правила "
"сортировки. Рассмотрим пример: <placeholder-1/> В первом случае "
"<function>less_than</function> будет использовать для сравнения общее "
"правило сортировки для <structfield>text_field_1</structfield> и "
"<structfield>text_field_2</structfield>, в то время как во втором случае "
"будет использоваться правило <literal>C</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:772(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\n"
"DECLARE\n"
"    local_a text := a;\n"
"    local_b text := b;\n"
"BEGIN\n"
"    RETURN local_a &lt; local_b;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\n"
"DECLARE\n"
"    local_a text := a;\n"
"    local_b text := b;\n"
"BEGIN\n"
"    RETURN local_a &lt; local_b;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:767(para)
msgid ""
"Furthermore, the identified collation is also assumed as the collation of "
"any local variables that are of collatable types. Thus this function would "
"not work any differently if it were written as <placeholder-1/>"
msgstr ""
"Кроме того, определённое для вызова функции правило сортировки также будет "
"использоваться для любых локальных переменных соответствующего типа. Таким "
"образом, функция не станет работать по-другому, если её переписать так: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:784(para)
msgid ""
"If there are no parameters of collatable data types, or no common collation "
"can be identified for them, then parameters and local variables use the "
"default collation of their data type (which is usually the database's "
"default collation, but could be different for variables of domain types)."
msgstr ""
"Если параметров с типами данных, поддерживающими сортировку, нет, или для "
"параметров невозможно определить общее правило сортировки, тогда для "
"параметров и локальных переменных применяются правила, принятые для их типа "
"данных по умолчанию (которые обычно совпадают с правилами сортировки по "
"умолчанию, принятыми для базы данных, но могут отличаться для переменных "
"доменных типов)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:797(programlisting)
#, no-wrap
msgid ""
"DECLARE\n"
"    local_a text COLLATE \"en_US\";"
msgstr ""
"DECLARE\n"
"    local_a text COLLATE \"en_US\";"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:792(para)
msgid ""
"A local variable of a collatable data type can have a different collation "
"associated with it by including the <literal>COLLATE</literal> option in its "
"declaration, for example <placeholder-1/> This option overrides the "
"collation that would otherwise be given to the variable according to the "
"rules above."
msgstr ""
"Локальная переменная может иметь правило сортировки, отличное от правила по "
"умолчанию. Для этого используется параметр <literal>COLLATE</literal> в "
"объявлении переменной, например: <placeholder-1/> Этот параметр "
"переопределяет правило сортировки, которое получила бы переменная в "
"соответствии с вышеуказанными правилами."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:811(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$\n"
"BEGIN\n"
"    RETURN a &lt; b COLLATE \"C\";\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$\n"
"BEGIN\n"
"    RETURN a &lt; b COLLATE \"C\";\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:806(para)
msgid ""
"Also, of course explicit <literal>COLLATE</literal> clauses can be written "
"inside a function if it is desired to force a particular collation to be "
"used in a particular operation. For example, <placeholder-1/> This overrides "
"the collations associated with the table columns, parameters, or local "
"variables used in the expression, just as would happen in a plain SQL "
"command."
msgstr ""
"И, конечно же, можно явно указывать параметр <literal>COLLATE</literal> для "
"конкретных операций внутри функции, если к ним требуется применить "
"конкретное правило сортировки. Например: <placeholder-1/> Как и в обычной "
"SQL-команде, это переопределяет правила сортировки, связанные с полями "
"таблицы, параметрами и локальными переменными, которые используются в данном "
"выражении."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:827(title)
msgid "Expressions"
msgstr "Выражения"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:852(programlisting)
#, no-wrap
msgid "IF x &lt; y THEN ..."
msgstr "IF x &lt; y THEN ..."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:856(programlisting)
#, no-wrap
msgid "PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;"
msgstr "PREPARE <replaceable>имя_оператора</replaceable>(integer, integer) AS SELECT $1 &lt; $2;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:829(para)
msgid ""
"All expressions used in <application>PL/pgSQL</application> statements are "
"processed using the server's main <acronym>SQL</acronym> executor. For "
"example, when you write a <application>PL/pgSQL</application> statement like "
"<synopsis>\n"
"IF <replaceable>expression</replaceable> THEN ...\n"
"</synopsis> <application>PL/pgSQL</application> will evaluate the expression "
"by feeding a query like <synopsis>\n"
"SELECT <replaceable>expression</replaceable>\n"
"</synopsis> to the main SQL engine. While forming the <command>SELECT</"
"command> command, any occurrences of <application>PL/pgSQL</application> "
"variable names are replaced by parameters, as discussed in detail in <xref "
"linkend=\"plpgsql-var-subst\"/>. This allows the query plan for the "
"<command>SELECT</command> to be prepared just once and then reused for "
"subsequent evaluations with different values of the variables. Thus, what "
"really happens on first use of an expression is essentially a "
"<command>PREPARE</command> command. For example, if we have declared two "
"integer variables <literal>x</literal> and <literal>y</literal>, and we "
"write <placeholder-1/> what happens behind the scenes is equivalent to "
"<placeholder-2/> and then this prepared statement is <command>EXECUTE</"
"command>d for each execution of the <command>IF</command> statement, with "
"the current values of the <application>PL/pgSQL</application> variables "
"supplied as parameter values. Normally these details are not important to a "
"<application>PL/pgSQL</application> user, but they are useful to know when "
"trying to diagnose a problem. More information appears in <xref linkend="
"\"plpgsql-plan-caching\"/>."
msgstr ""
"Все выражения, используемые в операторах <application>PL/pgSQL</"
"application>, обрабатываются основным исполнителем <acronym>SQL</acronym>-"
"сервера. Например, для вычисления такого выражения: <synopsis>\n"
"IF <replaceable>выражение</replaceable> THEN ...\n"
"</synopsis> <application>PL/pgSQL</application> отправит следующий запрос "
"исполнителю SQL: <synopsis>\n"
"SELECT <replaceable>выражение</replaceable>\n"
"</synopsis> При формировании команды <command>SELECT</command> все вхождения "
"имён переменных <application>PL/pgSQL</application> заменяются параметрами, "
"как подробно описано в <xref remap=\"6\" linkend=\"plpgsql-var-subst\"/>. "
"Это позволяет один раз подготовить план выполнения команды <command>SELECT</"
"command> и повторно использовать его в последующих вычислениях с различными "
"значениями переменных. Таким образом, при первом использовании выражения, по "
"сути происходит выполнение команды <command>PREPARE</command>. Например, "
"если мы объявили две целочисленные переменные <literal>x</literal> и "
"<literal>y</literal>, и написали: <placeholder-1/> то, что реально "
"происходит за сценой, эквивалентно: <placeholder-2/> и затем, эта "
"подготовленная команда исполняется (<command>EXECUTE</command>) для каждого "
"оператора <command>IF</command> с текущими значениями переменных "
"<application>PL/pgSQL</application>, переданных как значения параметров. "
"Обычно эти детали не важны для пользователей <application>PL/pgSQL</"
"application>, но их полезно знать при диагностировании проблем. Более "
"подробно об этом рассказывается в <xref remap=\"6\" linkend=\"plpgsql-plan-"
"caching\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:870(title)
msgid "Basic Statements"
msgstr "Основные операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:872(para)
msgid ""
"In this section and the following ones, we describe all the statement types "
"that are explicitly understood by <application>PL/pgSQL</application>. "
"Anything not recognized as one of these statement types is presumed to be an "
"SQL command and is sent to the main database engine to execute, as described "
"in <xref linkend=\"plpgsql-statements-sql-noresult\"/> and <xref linkend="
"\"plpgsql-statements-sql-onerow\"/>."
msgstr ""
"В этом и последующих разделах описаны все типы операторов, которые понимает "
"<application>PL/pgSQL</application>. Все, что не признается в качестве "
"одного из этих типов операторов, считается командой SQL и отправляется для "
"исполнения в основную машину базы данных, как описано в <xref remap=\"6\" "
"linkend=\"plpgsql-statements-sql-noresult\"/> и <xref remap=\"6\" linkend="
"\"plpgsql-statements-sql-onerow\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:883(title)
msgid "Assignment"
msgstr "Присваивания"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:885(para)
msgid ""
"An assignment of a value to a <application>PL/pgSQL</application> variable "
"is written as: <synopsis>\n"
"<replaceable>variable</replaceable> { := | = } <replaceable>expression</"
"replaceable>;\n"
"</synopsis> As explained previously, the expression in such a statement is "
"evaluated by means of an SQL <command>SELECT</command> command sent to the "
"main database engine. The expression must yield a single value (possibly a "
"row value, if the variable is a row or record variable). The target variable "
"can be a simple variable (optionally qualified with a block name), a field "
"of a row or record variable, or an element of an array that is a simple "
"variable or field. Equal (<literal>=</literal>) can be used instead of PL/"
"SQL-compliant <literal>:=</literal>."
msgstr ""
"Присвоение значения переменной <application>PL/pgSQL</application> "
"записывается в виде: <synopsis>\n"
"<replaceable>переменная</replaceable> { := | = } <replaceable>выражение</"
"replaceable>;\n"
"</synopsis> Как описывалось ранее, выражение в таком операторе вычисляется с "
"помощью SQL-команды <command>SELECT</command>, посылаемой в основную машину "
"базы данных. Выражение должно получить одно значение (возможно, значение "
"строки, если переменная строкового типа или типа <type>record</type>). "
"Целевая переменная может быть простой переменной (возможно, дополненной "
"именем блока), полем в переменной строкового типа или записи; или элементом "
"массива, который является простой переменной или полем. Для присвоения можно "
"использовать знак равенства (<literal>=</literal>) вместо совместимого с PL/"
"SQL <literal>:=</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:901(para)
msgid ""
"If the expression's result data type doesn't match the variable's data type, "
"the value will be coerced as though by an assignment cast (see <xref linkend="
"\"typeconv-query\"/>). If no assignment cast is known for the pair of data "
"types involved, the <application>PL/pgSQL</application> interpreter will "
"attempt to convert the result value textually, that is by applying the "
"result type's output function followed by the variable type's input "
"function. Note that this could result in run-time errors generated by the "
"input function, if the string form of the result value is not acceptable to "
"the input function."
msgstr ""
"Если тип данных результата выражения не соответствует типу данных "
"переменной, это значение будет преобразовано к нужному типу с использованием "
"приведения присваивания (см. <xref remap=\"4\" linkend=\"typeconv-query\"/"
">). В случае отсутствия приведения присваивания для этой пары типов, "
"интерпретатор <application>PL/pgSQL</application> попытается преобразовать "
"значение результата через текстовый формат, то есть применив функцию вывода "
"типа результата, а за ней функцию ввода типа переменной. Заметьте, что при "
"этом функция ввода может выдавать ошибки времени выполнения, если не "
"воспримет строковое представление значения результата."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:915(programlisting)
#, no-wrap
msgid ""
"tax := subtotal * 0.06;\n"
"my_record.user_id := 20;"
msgstr ""
"tax := subtotal * 0.06;\n"
"my_record.user_id := 20;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:923(title)
msgid "Executing a Command With No Result"
msgstr "Выполнение команды, не возвращающей результат"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:925(para)
msgid ""
"For any SQL command that does not return rows, for example <command>INSERT</"
"command> without a <literal>RETURNING</literal> clause, you can execute the "
"command within a <application>PL/pgSQL</application> function just by "
"writing the command."
msgstr ""
"В функции на <application>PL/pgSQL</application> можно выполнить любую "
"команду SQL, не возвращающую строк, просто написав эту команду (например, "
"<command>INSERT</command> без предложения <literal>RETURNING</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:932(para)
msgid ""
"Any <application>PL/pgSQL</application> variable name appearing in the "
"command text is treated as a parameter, and then the current value of the "
"variable is provided as the parameter value at run time. This is exactly "
"like the processing described earlier for expressions; for details see <xref "
"linkend=\"plpgsql-var-subst\"/>."
msgstr ""
"Имя любой переменной <application>PL/pgSQL</application> в тексте команды "
"рассматривается как параметр, а затем текущее значение переменной "
"подставляется в качестве значения параметра во время выполнения. Это в "
"точности совпадает с описанной ранее обработкой для выражений; за "
"подробностями обратитесь к <xref remap=\"3\" linkend=\"plpgsql-var-subst\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:940(para)
msgid ""
"When executing a SQL command in this way, <application>PL/pgSQL</"
"application> may cache and re-use the execution plan for the command, as "
"discussed in <xref linkend=\"plpgsql-plan-caching\"/>."
msgstr ""
"При выполнении SQL-команды таким образом, <application>PL/pgSQL</"
"application> может кешировать и повторно использовать план выполнения "
"команды, как обсуждается в <xref remap=\"6\" linkend=\"plpgsql-plan-caching"
"\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:947(para)
msgid ""
"Sometimes it is useful to evaluate an expression or <command>SELECT</"
"command> query but discard the result, for example when calling a function "
"that has side-effects but no useful result value. To do this in "
"<application>PL/pgSQL</application>, use the <command>PERFORM</command> "
"statement: <synopsis>\n"
"PERFORM <replaceable>query</replaceable>;\n"
"</synopsis> This executes <replaceable>query</replaceable> and discards the "
"result. Write the <replaceable>query</replaceable> the same way you would "
"write an SQL <command>SELECT</command> command, but replace the initial "
"keyword <command>SELECT</command> with <command>PERFORM</command>. For "
"<command>WITH</command> queries, use <command>PERFORM</command> and then "
"place the query in parentheses. (In this case, the query can only return one "
"row.) <application>PL/pgSQL</application> variables will be substituted into "
"the query just as for commands that return no result, and the plan is cached "
"in the same way. Also, the special variable <literal>FOUND</literal> is set "
"to true if the query produced at least one row, or false if it produced no "
"rows (see <xref linkend=\"plpgsql-statements-diagnostics\"/>)."
msgstr ""
"Иногда бывает полезно вычислить значение выражения или запроса "
"<command>SELECT</command>, но отказаться от результата, например, при вызове "
"функции, у которой есть побочные эффекты, но нет полезного результата. Для "
"этого в <application>PL/pgSQL</application>, используется оператор "
"<command>PERFORM</command>: <synopsis>\n"
"PERFORM <replaceable>запрос</replaceable>;\n"
"</synopsis> Эта команда выполняет <replaceable>запрос</replaceable> и "
"отбрасывает результат. <replaceable>Запросы</replaceable> пишутся таким же "
"образом, как и в команде SQL <command>SELECT</command>, но ключевое слово "
"<command>SELECT</command> заменяется на <command>PERFORM</command>. Для "
"запросов <command>WITH</command> после <command>PERFORM</command> нужно "
"поместить запрос в скобки. (В этом случае запрос может вернуть только одну "
"строку.) Переменные <application>PL/pgSQL</application> будут подставлены в "
"запрос так же, как и в команду, не возвращающую результат, план запроса "
"также кешируется. Кроме того, специальная переменная <literal>FOUND</"
"literal> устанавливается в истину, если запрос возвращает, по крайней мере, "
"одну строку, или ложь, если не возвращает ни одной строки (см. <xref remap="
"\"4\" linkend=\"plpgsql-statements-diagnostics\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:974(para)
msgid ""
"One might expect that writing <command>SELECT</command> directly would "
"accomplish this result, but at present the only accepted way to do it is "
"<command>PERFORM</command>. A SQL command that can return rows, such as "
"<command>SELECT</command>, will be rejected as an error unless it has an "
"<literal>INTO</literal> clause as discussed in the next section."
msgstr ""
"Можно предположить, что такой же результат получается непосредственно "
"командой <command>SELECT</command>, но в настоящее время использование "
"<command>PERFORM</command> является единственным способом. Команда SQL, "
"которая может возвращать строки, например <command>SELECT</command>, будет "
"отклонена с ошибкой, если не имеет предложения <literal>INTO</literal>, как "
"описано в следующем разделе."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:987(programlisting)
#, no-wrap
msgid "PERFORM create_mv('cs_session_page_requests_mv', my_query);"
msgstr "PERFORM create_mv('cs_session_page_requests_mv', my_query);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:985(para) plpgsql.xml:3010(para) plpgsql.xml:3261(para)
#: plpgsql.xml:3282(para)
msgid "An example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:994(title)
msgid "Executing a Query with a Single-row Result"
msgstr "Выполнение запроса, возвращающего одну строку"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:996(indexterm)
msgid "<primary>SELECT INTO</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>SELECT INTO</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1001(indexterm)
msgid "<primary>RETURNING INTO</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>RETURNING INTO</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1006(para)
msgid ""
"The result of a SQL command yielding a single row (possibly of multiple "
"columns) can be assigned to a record variable, row-type variable, or list of "
"scalar variables. This is done by writing the base SQL command and adding an "
"<literal>INTO</literal> clause. For example, <synopsis>\n"
"SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</"
"optional> <replaceable>target</replaceable> FROM ...;\n"
"INSERT ... RETURNING <replaceable>expressions</replaceable> INTO "
"<optional>STRICT</optional> <replaceable>target</replaceable>;\n"
"UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO "
"<optional>STRICT</optional> <replaceable>target</replaceable>;\n"
"DELETE ... RETURNING <replaceable>expressions</replaceable> INTO "
"<optional>STRICT</optional> <replaceable>target</replaceable>;\n"
"</synopsis> where <replaceable>target</replaceable> can be a record "
"variable, a row variable, or a comma-separated list of simple variables and "
"record/row fields. <application>PL/pgSQL</application> variables will be "
"substituted into the rest of the query, and the plan is cached, just as "
"described above for commands that do not return rows. This works for "
"<command>SELECT</command>, <command>INSERT</command>/<command>UPDATE</"
"command>/<command>DELETE</command> with <literal>RETURNING</literal>, and "
"utility commands that return row-set results (such as <command>EXPLAIN</"
"command>). Except for the <literal>INTO</literal> clause, the SQL command is "
"the same as it would be written outside <application>PL/pgSQL</application>."
msgstr ""
"Результат SQL-команды, возвращающей одну строку (возможно из нескольких "
"столбцов), может быть присвоен переменной типа <type>record</type>, "
"переменной строкового типа или списку скалярных переменных. Для этого нужно "
"к основной команде SQL добавить предложение <literal>INTO</literal>. Так, "
"например: <synopsis>\n"
"SELECT <replaceable>выражения_select</replaceable> INTO <optional>STRICT</"
"optional> <replaceable>цель</replaceable> FROM ...;\n"
"INSERT ... RETURNING <replaceable>выражения</replaceable> INTO "
"<optional>STRICT</optional> <replaceable>цель</replaceable>;\n"
"UPDATE ... RETURNING <replaceable>выражения</replaceable> INTO "
"<optional>STRICT</optional> <replaceable>цель</replaceable>;\n"
"DELETE ... RETURNING <replaceable>выражения</replaceable> INTO "
"<optional>STRICT</optional> <replaceable>цель</replaceable>;\n"
"</synopsis> где <replaceable>цель</replaceable> может быть переменной типа "
"<type>record</type>, строковой переменной или разделённым запятыми списком "
"скалярных переменных, полей записи/строки. Переменные <application>PL/pgSQL</"
"application> подставляются в оставшуюся часть запроса, план выполнения "
"кешируется, так же, как было описано выше для команд, не возвращающих "
"строки. Это работает для команд <command>SELECT</command>, <command>INSERT</"
"command>/<command>UPDATE</command>/<command>DELETE</command> с предложением "
"<literal>RETURNING</literal> и утилит, возвращающих результат в виде набора "
"строк (таких, как <command>EXPLAIN</command>). За исключением предложения "
"<literal>INTO</literal>, это те же SQL-команды, как их можно написать вне "
"<application>PL/pgSQL</application>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1034(para)
msgid ""
"Note that this interpretation of <command>SELECT</command> with "
"<literal>INTO</literal> is quite different from <productname>PostgreSQL</"
"productname>'s regular <command>SELECT INTO</command> command, wherein the "
"<literal>INTO</literal> target is a newly created table. If you want to "
"create a table from a <command>SELECT</command> result inside a "
"<application>PL/pgSQL</application> function, use the syntax <command>CREATE "
"TABLE ... AS SELECT</command>."
msgstr ""
"Обратите внимание, что данная интерпретация <command>SELECT</command> с "
"<literal>INTO</literal> полностью отличается от <productname>PostgreSQL</"
"productname> команды <command>SELECT INTO</command>, где в <literal>INTO</"
"literal> указывается вновь создаваемая таблица. Если вы хотите в функции на "
"<application>PL/pgSQL</application> создать таблицу, основанную на "
"результате команды <command>SELECT</command>, используйте синтаксис "
"<command>CREATE TABLE ... AS SELECT</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1045(para)
msgid ""
"If a row or a variable list is used as target, the query's result columns "
"must exactly match the structure of the target as to number and data types, "
"or else a run-time error occurs. When a record variable is the target, it "
"automatically configures itself to the row type of the query result columns."
msgstr ""
"Если результат запроса присваивается переменной строкового типа или списку "
"переменных, то они должны в точности соответствовать по количеству и типам "
"данных столбцам результата, иначе произойдёт ошибка во время выполнения. "
"Если используется переменная типа <type>record</type>, то она автоматически "
"приводится к строковому типу результата запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1053(para)
msgid ""
"The <literal>INTO</literal> clause can appear almost anywhere in the SQL "
"command. Customarily it is written either just before or just after the list "
"of <replaceable>select_expressions</replaceable> in a <command>SELECT</"
"command> command, or at the end of the command for other command types. It "
"is recommended that you follow this convention in case the <application>PL/"
"pgSQL</application> parser becomes stricter in future versions."
msgstr ""
"Предложение INTO может появиться практически в любом месте SQL-команды. "
"Обычно его записывают непосредственно перед или сразу после списка "
"<replaceable>выражения_select</replaceable> в <command>SELECT</command> или "
"в конце команды для команд других типов. Рекомендуется следовать этому "
"соглашению на случай, если правила разбора <application>PL/pgSQL</"
"application> ужесточатся в будущих версиях."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1074(programlisting)
#, no-wrap
msgid ""
"SELECT * INTO myrec FROM emp WHERE empname = myname;\n"
"IF NOT FOUND THEN\n"
"    RAISE EXCEPTION 'employee % not found', myname;\n"
"END IF;"
msgstr ""
"SELECT * INTO myrec FROM emp WHERE empname = myname;\n"
"IF NOT FOUND THEN\n"
"    RAISE EXCEPTION 'Сотрудник % не найден', myname;\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1087(programlisting)
#, no-wrap
msgid ""
"BEGIN\n"
"    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;\n"
"    EXCEPTION\n"
"        WHEN NO_DATA_FOUND THEN\n"
"            RAISE EXCEPTION 'employee % not found', myname;\n"
"        WHEN TOO_MANY_ROWS THEN\n"
"            RAISE EXCEPTION 'employee % not unique', myname;\n"
"END;"
msgstr ""
"BEGIN\n"
"    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;\n"
"    EXCEPTION\n"
"        WHEN NO_DATA_FOUND THEN\n"
"            RAISE EXCEPTION 'Сотрудник % не найден', myname;\n"
"        WHEN TOO_MANY_ROWS THEN\n"
"            RAISE EXCEPTION 'Сотрудник % уже существует', myname;\n"
"END;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1063(para)
msgid ""
"If <literal>STRICT</literal> is not specified in the <literal>INTO</literal> "
"clause, then <replaceable>target</replaceable> will be set to the first row "
"returned by the query, or to nulls if the query returned no rows. (Note that "
"<quote>the first row</quote> is not well-defined unless you've used "
"<literal>ORDER BY</literal>.) Any result rows after the first row are "
"discarded. You can check the special <literal>FOUND</literal> variable (see "
"<xref linkend=\"plpgsql-statements-diagnostics\"/>) to determine whether a "
"row was returned: <placeholder-1/> If the <literal>STRICT</literal> option "
"is specified, the query must return exactly one row or a run-time error will "
"be reported, either <literal>NO_DATA_FOUND</literal> (no rows) or "
"<literal>TOO_MANY_ROWS</literal> (more than one row). You can use an "
"exception block if you wish to catch the error, for example: <placeholder-2/"
"> Successful execution of a command with <literal>STRICT</literal> always "
"sets <literal>FOUND</literal> to true."
msgstr ""
"Если указание <literal>STRICT</literal> отсутствует в предложении "
"<literal>INTO</literal>, то <replaceable>цели</replaceable> присваивается "
"первая строка, возвращённая запросом; или NULL, если запрос не вернул строк. "
"(Заметим, что понятие <quote>первая строка</quote> определяется неоднозначно "
"без <literal>ORDER BY</literal>.) Все остальные строки результата после "
"первой отбрасываются. Можно проверить специальную переменную <literal>FOUND</"
"literal> (см. <xref remap=\"4\" linkend=\"plpgsql-statements-diagnostics\"/"
">), чтобы определить, была ли возвращена запись: <placeholder-1/> Если "
"добавлено указание <literal>STRICT</literal>, то запрос должен вернуть ровно "
"одну строку или произойдёт ошибка во время выполнения: либо "
"<literal>NO_DATA_FOUND</literal> (нет строк), либо <literal>TOO_MANY_ROWS</"
"literal> (более одной строки). Можно использовать секцию исключений в блоке "
"для обработки ошибок, например: <placeholder-2/> После успешного выполнения "
"команды с указанием <literal>STRICT</literal>, значение переменной "
"<literal>FOUND</literal> всегда устанавливается в истину."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1101(para)
msgid ""
"For <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</"
"command> with <literal>RETURNING</literal>, <application>PL/pgSQL</"
"application> reports an error for more than one returned row, even when "
"<literal>STRICT</literal> is not specified. This is because there is no "
"option such as <literal>ORDER BY</literal> with which to determine which "
"affected row should be returned."
msgstr ""
"Для <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</"
"command> с <literal>RETURNING</literal>, <application>PL/pgSQL</application> "
"возвращает ошибку, если выбрано более одной строки, даже в том случае, когда "
"указание <literal>STRICT</literal> отсутствует. Так происходит потому, что у "
"этих команд нет возможности, типа <literal>ORDER BY</literal>, указать какая "
"из задействованных строк должна быть возвращена."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1121(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION get_userid(username text) RETURNS int\n"
"AS $$\n"
"#print_strict_params on\n"
"DECLARE\n"
"userid int;\n"
"BEGIN\n"
"    SELECT users.userid INTO STRICT userid\n"
"        FROM users WHERE users.username = get_userid.username;\n"
"    RETURN userid;\n"
"END\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION get_userid(username text) RETURNS int\n"
"AS $$\n"
"#print_strict_params on\n"
"DECLARE\n"
"    userid int;\n"
"BEGIN\n"
"    SELECT users.userid INTO STRICT userid\n"
"        FROM users WHERE users.username = get_userid.username;\n"
"    RETURN userid;\n"
"END\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1135(programlisting)
#, no-wrap
msgid ""
"ERROR:  query returned no rows\n"
"DETAIL:  parameters: $1 = 'nosuchuser'\n"
"CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement"
msgstr ""
"ERROR:  query returned no rows\n"
"DETAIL:  parameters: $1 = 'nosuchuser'\n"
"CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1110(para)
msgid ""
"If <literal>print_strict_params</literal> is enabled for the function, then "
"when an error is thrown because the requirements of <literal>STRICT</"
"literal> are not met, the <literal>DETAIL</literal> part of the error "
"message will include information about the parameters passed to the query. "
"You can change the <literal>print_strict_params</literal> setting for all "
"functions by setting <varname>plpgsql.print_strict_params</varname>, though "
"only subsequent function compilations will be affected. You can also enable "
"it on a per-function basis by using a compiler option, for example: "
"<placeholder-1/> On failure, this function might produce an error message "
"such as <placeholder-2/>"
msgstr ""
"Если для функции включён режим <literal>print_strict_params</literal>, то "
"при возникновении ошибки, связанной с нарушением условия <literal>STRICT</"
"literal>, в детальную (<literal>DETAIL</literal>) часть сообщения об ошибке "
"будет включена информация о параметрах, переданных запросу. Изменить "
"значение <literal>print_strict_params</literal> можно установкой параметра "
"<varname>plpgsql.print_strict_params</varname>. Но это повлияет только на "
"функции, скомпилированные после изменения. Для конкретной функции можно "
"использовать указание компилятора, например: <placeholder-1/> В случае сбоя "
"будет сформировано примерно такое сообщение об ошибке <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1143(para)
msgid ""
"The <literal>STRICT</literal> option matches the behavior of Oracle PL/SQL's "
"<command>SELECT INTO</command> and related statements."
msgstr ""
"С указанием <literal>STRICT</literal> поведение <command>SELECT INTO</"
"command> и связанных операторов соответствует принятому в Oracle PL/SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1149(para)
msgid ""
"To handle cases where you need to process multiple result rows from a SQL "
"query, see <xref linkend=\"plpgsql-records-iterating\"/>."
msgstr ""
"Как действовать в случаях, когда требуется обработать несколько строк "
"результата, описано в <xref remap=\"6\" linkend=\"plpgsql-records-iterating"
"\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1157(title)
msgid "Executing Dynamic Commands"
msgstr "Выполнение динамически формируемых команд"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1159(para)
msgid ""
"Oftentimes you will want to generate dynamic commands inside your "
"<application>PL/pgSQL</application> functions, that is, commands that will "
"involve different tables or different data types each time they are "
"executed. <application>PL/pgSQL</application>'s normal attempts to cache "
"plans for commands (as discussed in <xref linkend=\"plpgsql-plan-caching\"/"
">) will not work in such scenarios. To handle this sort of problem, the "
"<command>EXECUTE</command> statement is provided: <synopsis>\n"
"EXECUTE <replaceable class=\"command\">command-string</replaceable> "
"<optional> INTO <optional>STRICT</optional> <replaceable>target</"
"replaceable> </optional> <optional> USING <replaceable>expression</"
"replaceable> <optional>, ... </optional> </optional>;\n"
"</synopsis> where <replaceable>command-string</replaceable> is an expression "
"yielding a string (of type <type>text</type>) containing the command to be "
"executed. The optional <replaceable>target</replaceable> is a record "
"variable, a row variable, or a comma-separated list of simple variables and "
"record/row fields, into which the results of the command will be stored. The "
"optional <literal>USING</literal> expressions supply values to be inserted "
"into the command."
msgstr ""
"Часто требуется динамически формировать команды внутри функций на "
"<application>PL/pgSQL</application>, то есть такие команды, в которых при "
"каждом выполнении могут использоваться разные таблицы или типы данных. "
"Обычно <application>PL/pgSQL</application> кеширует планы выполнения (как "
"описано в <xref remap=\"6\" linkend=\"plpgsql-plan-caching\"/>), но в случае "
"с динамическими командами это не будет работать. Для исполнения динамических "
"команд предусмотрен оператор <command>EXECUTE</command>: <synopsis>\n"
"EXECUTE <replaceable class=\"command\">строка-команды</replaceable> "
"<optional> INTO <optional>STRICT</optional> <replaceable>цель</replaceable> "
"</optional> <optional> USING <replaceable>выражение</replaceable> "
"<optional>, ... </optional> </optional>;\n"
"</synopsis> где <replaceable>строка-команды</replaceable> это выражение, "
"формирующее строку (типа <type>text</type>) с текстом команды, которую нужно "
"выполнить. Необязательная <replaceable>цель</replaceable> — это переменная-"
"запись, переменная-кортеж или разделённый запятыми список простых переменных "
"и полей записи/кортежа, куда будут помещены результаты команды. "
"Необязательные выражения в <literal>USING</literal> формируют значения, "
"которые будут вставлены в команду."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1182(para)
msgid ""
"No substitution of <application>PL/pgSQL</application> variables is done on "
"the computed command string. Any required variable values must be inserted "
"in the command string as it is constructed; or you can use parameters as "
"described below."
msgstr ""
"В сформированном тексте команды замена имён переменных <application>PL/"
"pgSQL</application> на их значения проводиться не будет. Все необходимые "
"значения переменных должны быть вставлены в командную строку при её "
"построении, либо нужно использовать параметры, как описано ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1189(para)
msgid ""
"Also, there is no plan caching for commands executed via <command>EXECUTE</"
"command>. Instead, the command is always planned each time the statement is "
"run. Thus the command string can be dynamically created within the function "
"to perform actions on different tables and columns."
msgstr ""
"Также, нет никакого плана кеширования для команд, выполняемых с помощью "
"<command>EXECUTE</command>. Вместо этого план создаётся каждый раз при "
"выполнении. Таким образом, строка команды может динамически создаваться "
"внутри функции для выполнения действий с различными таблицами и столбцами."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1197(para)
msgid ""
"The <literal>INTO</literal> clause specifies where the results of a SQL "
"command returning rows should be assigned. If a row or variable list is "
"provided, it must exactly match the structure of the query's results (when a "
"record variable is used, it will configure itself to match the result "
"structure automatically). If multiple rows are returned, only the first will "
"be assigned to the <literal>INTO</literal> variable. If no rows are "
"returned, NULL is assigned to the <literal>INTO</literal> variable(s). If no "
"<literal>INTO</literal> clause is specified, the query results are discarded."
msgstr ""
"Предложение <literal>INTO</literal> указывает, куда должны быть помещены "
"результаты SQL-команды, возвращающей строки. Если используется переменная "
"строкового типа или список переменных, то они должны в точности "
"соответствовать структуре результата запроса (когда используется переменная "
"типа <type>record</type>, она автоматически приводится к строковому типу "
"результата запроса). Если возвращается несколько строк, то только первая "
"будет присвоена переменной(ым) в <literal>INTO</literal>. Если не "
"возвращается ни одной строки, то присваивается NULL. Без предложения "
"<literal>INTO</literal> результаты запроса отбрасываются."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1210(para)
msgid ""
"If the <literal>STRICT</literal> option is given, an error is reported "
"unless the query produces exactly one row."
msgstr ""
"С указанием <literal>STRICT</literal> запрос должен вернуть ровно одну "
"строку, иначе выдаётся сообщение об ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1224(programlisting)
#, no-wrap
msgid ""
"EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'\n"
"   INTO c\n"
"   USING checked_user, checked_date;"
msgstr ""
"EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'\n"
"   INTO c\n"
"   USING checked_user, checked_date;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1215(para)
msgid ""
"The command string can use parameter values, which are referenced in the "
"command as <literal>$1</literal>, <literal>$2</literal>, etc. These symbols "
"refer to values supplied in the <literal>USING</literal> clause. This method "
"is often preferable to inserting data values into the command string as "
"text: it avoids run-time overhead of converting the values to text and back, "
"and it is much less prone to SQL-injection attacks since there is no need "
"for quoting or escaping. An example is: <placeholder-1/>"
msgstr ""
"В тексте команды можно использовать значения параметров, ссылки на параметры "
"обозначаются как <literal>$1</literal>, <literal>$2</literal> и т. д. Эти "
"символы указывают на значения, находящиеся в предложении <literal>USING</"
"literal>. Такой метод зачастую предпочтительнее, чем вставка значений в "
"команду в виде текста: он позволяет исключить во время исполнения "
"дополнительные расходы на преобразования значений в текст и обратно, и не "
"открывает возможности для SQL-инъекций, не требуя применять экранирование "
"или кавычки для спецсимволов. Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1237(programlisting)
#, no-wrap
msgid ""
"EXECUTE 'SELECT count(*) FROM '\n"
"    || quote_ident(tabname)\n"
"    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'\n"
"   INTO c\n"
"   USING checked_user, checked_date;"
msgstr ""
"EXECUTE 'SELECT count(*) FROM '\n"
"    || quote_ident(tabname)\n"
"    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'\n"
"   INTO c\n"
"   USING checked_user, checked_date;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1247(programlisting)
#, no-wrap
msgid ""
"EXECUTE format('SELECT count(*) FROM %I '\n"
"   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)\n"
"   INTO c\n"
"   USING checked_user, checked_date;"
msgstr ""
"EXECUTE format('SELECT count(*) FROM %I '\n"
"   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)\n"
"   INTO c\n"
"   USING checked_user, checked_date;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1231(para)
msgid ""
"Note that parameter symbols can only be used for data values &mdash; if you "
"want to use dynamically determined table or column names, you must insert "
"them into the command string textually. For example, if the preceding query "
"needed to be done against a dynamically selected table, you could do this: "
"<placeholder-1/> A cleaner approach is to use <function>format()</"
"function>'s <literal>%I</literal> specification for table or column names "
"(strings separated by a newline are concatenated): <placeholder-2/> Another "
"restriction on parameter symbols is that they only work in <command>SELECT</"
"command>, <command>INSERT</command>, <command>UPDATE</command>, and "
"<command>DELETE</command> commands. In other statement types (generically "
"called utility statements), you must insert values textually even if they "
"are just data values."
msgstr ""
"Обратите внимание, что символы параметров можно использовать только вместо "
"значений данных. Если же требуется динамически формировать имена таблиц или "
"столбцов, их необходимо вставлять в виде текста. Например, если в предыдущем "
"запросе необходимо динамически задавать имя таблицы, можно сделать "
"следующее: <placeholder-1/> В качестве более аккуратного решения, вместо "
"имени таблиц или столбцов можно использовать указание формата <literal>%I</"
"literal> с функцией <function>format()</function> (текст, разделённый "
"символами новой строки, соединяется вместе): <placeholder-2/> Ещё одно "
"ограничение состоит в том, что символы параметров могут использоваться "
"только в командах <command>SELECT</command>, <command>INSERT</command>, "
"<command>UPDATE</command> и <command>DELETE</command>. В операторы других "
"типов (обычно называемые служебными) значения нужно вставлять в текстовом "
"виде, даже если это просто значения данных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1260(para)
msgid ""
"An <command>EXECUTE</command> with a simple constant command string and some "
"<literal>USING</literal> parameters, as in the first example above, is "
"functionally equivalent to just writing the command directly in "
"<application>PL/pgSQL</application> and allowing replacement of "
"<application>PL/pgSQL</application> variables to happen automatically. The "
"important difference is that <command>EXECUTE</command> will re-plan the "
"command on each execution, generating a plan that is specific to the current "
"parameter values; whereas <application>PL/pgSQL</application> may otherwise "
"create a generic plan and cache it for re-use. In situations where the best "
"plan depends strongly on the parameter values, it can be helpful to use "
"<command>EXECUTE</command> to positively ensure that a generic plan is not "
"selected."
msgstr ""
"Команда <command>EXECUTE</command> c неизменяемым текстом и параметрами "
"USING (как в первом примере выше), функционально эквивалентна команде, "
"записанной напрямую в <application>PL/pgSQL</application>, в которой "
"переменные <application>PL/pgSQL</application> автоматически заменяются "
"значениями. Важное отличие в том, что <command>EXECUTE</command> при каждом "
"исполнении заново строит план команды с учётом текущих значений параметров, "
"тогда как <application>PL/pgSQL</application> строит общий план выполнения и "
"кеширует его при повторном использовании. В тех случаях, когда наилучший "
"план выполнения сильно зависит от значений параметров, может быть полезно "
"использовать <command>EXECUTE</command> для гарантии того, что не будет "
"выбран общий план."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1276(para)
msgid ""
"<command>SELECT INTO</command> is not currently supported within "
"<command>EXECUTE</command>; instead, execute a plain <command>SELECT</"
"command> command and specify <literal>INTO</literal> as part of the "
"<command>EXECUTE</command> itself."
msgstr ""
"В настоящее время команда <command>SELECT INTO</command> не поддерживается в "
"<command>EXECUTE</command>, вместо этого нужно выполнять обычный "
"<command>SELECT</command> и указать <literal>INTO</literal> для самой "
"команды <command>EXECUTE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1284(para)
msgid ""
"The <application>PL/pgSQL</application> <command>EXECUTE</command> statement "
"is not related to the <xref linkend=\"sql-execute\"/> SQL statement "
"supported by the <productname>PostgreSQL</productname> server. The server's "
"<command>EXECUTE</command> statement cannot be used directly within "
"<application>PL/pgSQL</application> functions (and is not needed)."
msgstr ""
"Оператор <command>EXECUTE</command> в <application>PL/pgSQL</application> не "
"имеет отношения к одноименному SQL-оператору сервера "
"<productname>PostgreSQL</productname>. Серверный <command>EXECUTE</command> "
"не может напрямую использоваться в функциях на <application>PL/pgSQL</"
"application> (и в этом нет необходимости)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1296(title)
msgid "Quoting Values In Dynamic Queries"
msgstr "Использование кавычек в динамических запросах"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1298(indexterm)
msgid "<primary>quote_ident</primary> <secondary>use in PL/pgSQL</secondary>"
msgstr ""
"<primary>quote_ident</primary> <secondary>использование в PL/pgSQL</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1303(indexterm)
msgid "<primary>quote_literal</primary> <secondary>use in PL/pgSQL</secondary>"
msgstr ""
"<primary>quote_literal</primary> <secondary>использование в PL/pgSQL</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1308(indexterm)
msgid ""
"<primary>quote_nullable</primary> <secondary>use in PL/pgSQL</secondary>"
msgstr ""
"<primary>quote_nullable</primary> <secondary>использование в PL/pgSQL</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1313(indexterm)
msgid "<primary>format</primary> <secondary>use in PL/pgSQL</secondary>"
msgstr ""
"<primary>format</primary> <secondary>использование в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1318(para)
msgid ""
"When working with dynamic commands you will often have to handle escaping of "
"single quotes. The recommended method for quoting fixed text in your "
"function body is dollar quoting. (If you have legacy code that does not use "
"dollar quoting, please refer to the overview in <xref linkend=\"plpgsql-"
"quote-tips\"/>, which can save you some effort when translating said code to "
"a more reasonable scheme.)"
msgstr ""
"При работе с динамическими командами часто приходится иметь дело с "
"экранированием одинарных кавычек. Рекомендуемым методом для взятия текста в "
"кавычки в теле функции является экранирование знаками доллара. (Если имеется "
"унаследованный код, не использующий этот метод, пожалуйста, обратитесь к "
"обзору в <xref remap=\"6\" linkend=\"plpgsql-quote-tips\"/>, это поможет "
"сэкономить усилия при переводе кода к более приемлемому виду.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1332(programlisting)
#, no-wrap
msgid ""
"EXECUTE format('UPDATE tbl SET %I = $1 '\n"
"   'WHERE key = $2', colname) USING newvalue, keyvalue;"
msgstr ""
"EXECUTE format('UPDATE tbl SET %I = $1 '\n"
"   'WHERE key = $2', colname) USING newvalue, keyvalue;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1337(programlisting)
#, no-wrap
msgid ""
"EXECUTE 'UPDATE tbl SET '\n"
"        || quote_ident(colname)\n"
"        || ' = '\n"
"        || quote_literal(newvalue)\n"
"        || ' WHERE key = '\n"
"        || quote_literal(keyvalue);"
msgstr ""
"EXECUTE 'UPDATE tbl SET '\n"
"        || quote_ident(colname)\n"
"        || ' = '\n"
"        || quote_literal(newvalue)\n"
"        || ' WHERE key = '\n"
"        || quote_literal(keyvalue);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1327(para)
msgid ""
"Dynamic values require careful handling since they might contain quote "
"characters. An example using <function>format()</function> (this assumes "
"that you are dollar quoting the function body so quote marks need not be "
"doubled): <placeholder-1/> It is also possible to call the quoting functions "
"directly: <placeholder-2/>"
msgstr ""
"Динамические значения требуют особого внимания, так как они могут содержать "
"апострофы. Например, можно использовать функцию <function>format()</"
"function> (предполагается, что тело функции заключается в доллары, так что "
"апострофы дублировать не нужно): <placeholder-1/> Также можно напрямую "
"вызывать функции заключения в кавычки: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1347(para)
msgid ""
"This example demonstrates the use of the <function>quote_ident</function> "
"and <function>quote_literal</function> functions (see <xref linkend="
"\"functions-string\"/>). For safety, expressions containing column or table "
"identifiers should be passed through <function>quote_ident</function> before "
"insertion in a dynamic query. Expressions containing values that should be "
"literal strings in the constructed command should be passed through "
"<function>quote_literal</function>. These functions take the appropriate "
"steps to return the input text enclosed in double or single quotes "
"respectively, with any embedded special characters properly escaped."
msgstr ""
"Этот пример демонстрирует использование функций <function>quote_ident</"
"function> и <function>quote_literal</function> (см. <xref remap=\"4\" "
"linkend=\"functions-string\"/>). Для надёжности, выражения, содержащие "
"идентификаторы столбцов и таблиц должны использовать функцию "
"<function>quote_ident</function> при добавлении в текст запроса. А для "
"выражений со значениями, которые должны быть обычными строками, используется "
"функция <function>quote_literal</function>. Эти функции выполняют "
"соответствующие шаги, чтобы вернуть текст, по ситуации заключённый в двойные "
"или одинарные кавычки и с правильно экранированными специальными символами."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1371(programlisting)
#, no-wrap
msgid ""
"EXECUTE 'UPDATE tbl SET '\n"
"        || quote_ident(colname)\n"
"        || ' = '\n"
"        || quote_nullable(newvalue)\n"
"        || ' WHERE key = '\n"
"        || quote_nullable(keyvalue);"
msgstr ""
"EXECUTE 'UPDATE tbl SET '\n"
"        || quote_ident(colname)\n"
"        || ' = '\n"
"        || quote_nullable(newvalue)\n"
"        || ' WHERE key = '\n"
"        || quote_nullable(keyvalue);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1361(para)
msgid ""
"Because <function>quote_literal</function> is labeled <literal>STRICT</"
"literal>, it will always return null when called with a null argument. In "
"the above example, if <literal>newvalue</literal> or <literal>keyvalue</"
"literal> were null, the entire dynamic query string would become null, "
"leading to an error from <command>EXECUTE</command>. You can avoid this "
"problem by using the <function>quote_nullable</function> function, which "
"works the same as <function>quote_literal</function> except that when called "
"with a null argument it returns the string <literal>NULL</literal>. For "
"example, <placeholder-1/> If you are dealing with values that might be null, "
"you should usually use <function>quote_nullable</function> in place of "
"<function>quote_literal</function>."
msgstr ""
"Так как функция <function>quote_literal</function> помечена как "
"<literal>STRICT</literal>, то она всегда возвращает NULL, если переданный ей "
"аргумент имеет значение NULL. В приведённом выше примере, если "
"<literal>newvalue</literal> или <literal>keyvalue</literal> были NULL, вся "
"строка с текстом запроса станет NULL, что приведёт к ошибке в "
"<command>EXECUTE</command>. Для предотвращения этой проблемы используйте "
"функцию <function>quote_nullable</function>, которая работает так же, как "
"<function>quote_literal</function> за исключением того, что при вызове с "
"пустым аргументом возвращает строку 'NULL'. Например: <placeholder-1/> Если "
"вы имеете дело со значениями, которые могут быть пустыми, то, как правило, "
"нужно использовать <function>quote_nullable</function> вместо "
"<function>quote_literal</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1386(programlisting)
#, no-wrap
msgid "'WHERE key = ' || quote_nullable(keyvalue)"
msgstr "'WHERE key = ' || quote_nullable(keyvalue)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1393(programlisting)
#, no-wrap
msgid "'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)"
msgstr "'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1383(para)
msgid ""
"As always, care must be taken to ensure that null values in a query do not "
"deliver unintended results. For example the <literal>WHERE</literal> clause "
"<placeholder-1/> will never succeed if <literal>keyvalue</literal> is null, "
"because the result of using the equality operator <literal>=</literal> with "
"a null operand is always null. If you wish null to work like an ordinary key "
"value, you would need to rewrite the above as <placeholder-2/> (At present, "
"<literal>IS NOT DISTINCT FROM</literal> is handled much less efficiently "
"than <literal>=</literal>, so don't do this unless you must. See <xref "
"linkend=\"functions-comparison\"/> for more information on nulls and "
"<literal>IS DISTINCT</literal>.)"
msgstr ""
"Как обычно, необходимо убедиться, что значения NULL в запросе не принесут "
"неожиданных результатов. Например, следующее условие <literal>WHERE</"
"literal> <placeholder-1/> никогда не выполнится, если <literal>keyvalue</"
"literal> — NULL, так как применение <literal>=</literal> с операндом, "
"имеющим значение NULL, всегда даёт NULL. Если требуется, чтобы NULL "
"обрабатывалось как обычное значение, то условие выше нужно переписать так: "
"<placeholder-2/> (В настоящее время <literal>IS NOT DISTINCT FROM</literal> "
"работает менее эффективно, чем <literal>=</literal>, так что используйте "
"этот способ, только если это действительно необходимо. Подробнее особенности "
"NULL и <literal>IS DISTINCT</literal> описаны в <xref remap=\"6\" linkend="
"\"functions-comparison\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1405(programlisting)
#, no-wrap
msgid ""
"EXECUTE 'UPDATE tbl SET '\n"
"        || quote_ident(colname)\n"
"        || ' = $$'\n"
"        || newvalue\n"
"        || '$$ WHERE key = '\n"
"        || quote_literal(keyvalue);"
msgstr ""
"EXECUTE 'UPDATE tbl SET '\n"
"        || quote_ident(colname)\n"
"        || ' = $$'\n"
"        || newvalue\n"
"        || '$$ WHERE key = '\n"
"        || quote_literal(keyvalue);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1402(para)
msgid ""
"Note that dollar quoting is only useful for quoting fixed text. It would be "
"a very bad idea to try to write this example as: <placeholder-1/> because it "
"would break if the contents of <literal>newvalue</literal> happened to "
"contain <literal>$$</literal>. The same objection would apply to any other "
"dollar-quoting delimiter you might pick. So, to safely quote text that is "
"not known in advance, you <emphasis>must</emphasis> use "
"<function>quote_literal</function>, <function>quote_nullable</function>, or "
"<function>quote_ident</function>, as appropriate."
msgstr ""
"Обратите внимание, что использование знака $ полезно только для взятия в "
"кавычки фиксированного текста. Плохая идея написать этот пример так: "
"<placeholder-1/> потому что <literal>newvalue</literal> может также "
"содержать <literal>$$</literal>. Эта же проблема может возникнуть и с любым "
"другим разделителем, используемым после знака <literal>$</literal>. Поэтому, "
"чтобы безопасно заключить заранее неизвестный текст в кавычки, "
"<emphasis>нужно</emphasis> использовать соответствующие функции: "
"<function>quote_literal</function>, <function>quote_nullable</function>, или "
"<function>quote_ident</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1425(programlisting)
#, no-wrap
msgid ""
"EXECUTE format('UPDATE tbl SET %I = %L '\n"
"   'WHERE key = %L', colname, newvalue, keyvalue);"
msgstr ""
"EXECUTE format('UPDATE tbl SET %I = %L '\n"
"   'WHERE key = %L', colname, newvalue, keyvalue);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1433(programlisting)
#, no-wrap
msgid ""
"EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)\n"
"   USING newvalue, keyvalue;"
msgstr ""
"EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)\n"
"   USING newvalue, keyvalue;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1421(para)
msgid ""
"Dynamic SQL statements can also be safely constructed using the "
"<function>format</function> function (see <xref linkend=\"functions-string\"/"
">). For example: <placeholder-1/> <literal>%I</literal> is equivalent to "
"<function>quote_ident</function>, and <literal>%L</literal> is equivalent to "
"<function>quote_nullable</function>. The <function>format</function> "
"function can be used in conjunction with the <literal>USING</literal> "
"clause: <placeholder-2/> This form is better because the variables are "
"handled in their native data type format, rather than unconditionally "
"converting them to text and quoting them via <literal>%L</literal>. It is "
"also more efficient."
msgstr ""
"Динамические операторы SQL также можно безопасно сформировать, используя "
"функцию <function>format</function> (см. <xref remap=\"4\" linkend="
"\"functions-string\"/>). Например: <placeholder-1/> Указание <literal>%I</"
"literal> равнозначно вызову <function>quote_ident</function>, а <literal>%L</"
"literal> — вызову <function>quote_nullable</function>. Функция "
"<function>format</function> может применяться в сочетании с предложением "
"<literal>USING</literal>: <placeholder-2/> Эта форма лучше, так как с ней "
"переменные обрабатываются в их собственном формате данных, а не "
"преобразуются безусловно в текст, чтобы затем выводиться с использованием "
"<literal>%L</literal>. Она также и более эффективна."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1443(para)
msgid ""
"A much larger example of a dynamic command and <command>EXECUTE</command> "
"can be seen in <xref linkend=\"plpgsql-porting-ex2\"/>, which builds and "
"executes a <command>CREATE FUNCTION</command> command to define a new "
"function."
msgstr ""
"Более объёмный пример использования динамической команды и <command>EXECUTE</"
"command> можно увидеть в <xref remap=\"6\" linkend=\"plpgsql-porting-ex2\"/"
">. В нём создаётся и динамически выполняется команда <command>CREATE "
"FUNCTION</command> для определения новой функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1452(title)
msgid "Obtaining the Result Status"
msgstr "Статус выполнения команды"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1473(programlisting)
#, no-wrap
msgid "GET DIAGNOSTICS integer_var = ROW_COUNT;"
msgstr "GET DIAGNOSTICS integer_var = ROW_COUNT;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1454(para)
msgid ""
"There are several ways to determine the effect of a command. The first "
"method is to use the <command>GET DIAGNOSTICS</command> command, which has "
"the form: <synopsis>\n"
"GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</"
"replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </"
"optional>;\n"
"</synopsis> This command allows retrieval of system status indicators. "
"<literal>CURRENT</literal> is a noise word (but see also <command>GET "
"STACKED DIAGNOSTICS</command> in <xref linkend=\"plpgsql-exception-"
"diagnostics\"/>). Each <replaceable>item</replaceable> is a key word "
"identifying a status value to be assigned to the specified "
"<replaceable>variable</replaceable> (which should be of the right data type "
"to receive it). The currently available status items are shown in <xref "
"linkend=\"plpgsql-current-diagnostics-values\"/>. Colon-equal (<literal>:=</"
"literal>) can be used instead of the SQL-standard <literal>=</literal> "
"token. An example: <placeholder-1/>"
msgstr ""
"Определить результат команды можно несколькими способами. Во-первых, можно "
"воспользоваться командой <command>GET DIAGNOSTICS</command>, имеющей форму: "
"<synopsis>\n"
"GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>переменная</"
"replaceable> { = | := } <replaceable>элемент</replaceable> <optional> , ... "
"</optional>;\n"
"</synopsis> Эта команда позволяет получить системные индикаторы состояния. "
"Слово <literal>CURRENT</literal> не несёт смысловой нагрузки (но см. также "
"описание <command>GET STACKED DIAGNOSTICS</command> в <xref remap=\"6\" "
"linkend=\"plpgsql-exception-diagnostics\"/>). Каждый <replaceable>элемент</"
"replaceable> представляется ключевым словом, указывающим, какое значение "
"состояния нужно присвоить заданной <replaceable>переменной</replaceable> "
"(она должна иметь подходящий тип данных, чтобы принять его). Доступные в "
"настоящее время элементы состояния показаны в <xref remap=\"6\" linkend="
"\"plpgsql-current-diagnostics-values\"/>. Вместо принятого в стандарте SQL "
"присваивания (<literal>=</literal>) можно применять присваивание с "
"двоеточием (<literal>:=</literal>). Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1479(title)
msgid "Available Diagnostics Items"
msgstr "Доступные элементы диагностики"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1483(entry) plpgsql.xml:2758(entry)
msgid "Name"
msgstr "Имя"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1484(entry) plpgsql.xml:2759(entry)
msgid "Type"
msgstr "Тип"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1485(entry) plpgsql.xml:2760(entry)
msgid "Description"
msgstr "Описание"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1490(varname)
msgid "ROW_COUNT"
msgstr "ROW_COUNT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1491(type)
msgid "bigint"
msgstr "bigint"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1492(entry)
msgid ""
"the number of rows processed by the most recent <acronym>SQL</acronym> "
"command"
msgstr "число строк, обработанных последней командой <acronym>SQL</acronym>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1496(varname)
msgid "RESULT_OID"
msgstr "RESULT_OID"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1497(type)
msgid "oid"
msgstr "oid"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1498(entry)
msgid ""
"the OID of the last row inserted by the most recent <acronym>SQL</acronym> "
"command (only useful after an <command>INSERT</command> command into a table "
"having OIDs)"
msgstr ""
"OID последней строки, вставленной предыдущей командой <acronym>SQL</acronym> "
"(полезен только после команды <command>INSERT</command> для таблицы, "
"содержащей OID)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1504(literal)
msgid "PG_CONTEXT"
msgstr "PG_CONTEXT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1505(type) plpgsql.xml:2766(type) plpgsql.xml:2771(type)
#: plpgsql.xml:2776(type) plpgsql.xml:2781(type) plpgsql.xml:2786(type)
#: plpgsql.xml:2791(type) plpgsql.xml:2796(type) plpgsql.xml:2801(type)
#: plpgsql.xml:2806(type) plpgsql.xml:2811(type)
msgid "text"
msgstr "text"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1506(entry)
msgid ""
"line(s) of text describing the current call stack (see <xref linkend="
"\"plpgsql-call-stack\"/>)"
msgstr ""
"строки текста, описывающие текущий стек вызовов (см. <xref remap=\"4\" "
"linkend=\"plpgsql-call-stack\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1522(para)
msgid ""
"A <command>SELECT INTO</command> statement sets <literal>FOUND</literal> "
"true if a row is assigned, false if no row is returned."
msgstr ""
"<command>SELECT INTO</command> записывает в <literal>FOUND</literal> true, "
"если строка присвоена, или false, если строки не были получены."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1529(para)
msgid ""
"A <command>PERFORM</command> statement sets <literal>FOUND</literal> true if "
"it produces (and discards) one or more rows, false if no row is produced."
msgstr ""
"<command>PERFORM</command> записывает в <literal>FOUND</literal> true, если "
"строки выбраны (и отброшены) или false, если строки не выбраны."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1536(para)
msgid ""
"<command>UPDATE</command>, <command>INSERT</command>, and <command>DELETE</"
"command> statements set <literal>FOUND</literal> true if at least one row is "
"affected, false if no row is affected."
msgstr ""
"<command>UPDATE</command>, <command>INSERT</command> и <command>DELETE</"
"command> записывают в <literal>FOUND</literal> true, если при их выполнении "
"была задействована хотя бы одна строка, или false, если ни одна строка не "
"была задействована."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1543(para)
msgid ""
"A <command>FETCH</command> statement sets <literal>FOUND</literal> true if "
"it returns a row, false if no row is returned."
msgstr ""
"<command>FETCH</command> записывают в <literal>FOUND</literal> true, если "
"команда вернула строку, или false, если строка не выбрана."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1549(para)
msgid ""
"A <command>MOVE</command> statement sets <literal>FOUND</literal> true if it "
"successfully repositions the cursor, false otherwise."
msgstr ""
"<command>MOVE</command> записывают в <literal>FOUND</literal> true при "
"успешном перемещении курсора, в противном случае — false."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1555(para)
msgid ""
"A <command>FOR</command> or <command>FOREACH</command> statement sets "
"<literal>FOUND</literal> true if it iterates one or more times, else false. "
"<literal>FOUND</literal> is set this way when the loop exits; inside the "
"execution of the loop, <literal>FOUND</literal> is not modified by the loop "
"statement, although it might be changed by the execution of other statements "
"within the loop body."
msgstr ""
"<command>FOR</command>, как и <command>FOREACH</command>, записывает в "
"<literal>FOUND</literal> true, если была произведена хотя бы одна итерация "
"цикла, в противном случае — false. При этом значение <literal>FOUND</"
"literal> будет установлено только после выхода из цикла. Пока цикл "
"выполняется, оператор цикла не изменяет значение переменной. Но другие "
"операторы внутри цикла могут менять значение <literal>FOUND</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1567(para)
msgid ""
"<command>RETURN QUERY</command> and <command>RETURN QUERY EXECUTE</command> "
"statements set <literal>FOUND</literal> true if the query returns at least "
"one row, false if no row is returned."
msgstr ""
"<command>RETURN QUERY</command> и <command>RETURN QUERY EXECUTE</command> "
"записывают в <literal>FOUND</literal> true, если запрос вернул хотя бы одну "
"строку, или false, если строки не выбраны."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1513(para)
msgid ""
"The second method to determine the effects of a command is to check the "
"special variable named <literal>FOUND</literal>, which is of type "
"<type>boolean</type>. <literal>FOUND</literal> starts out false within each "
"<application>PL/pgSQL</application> function call. It is set by each of the "
"following types of statements: <placeholder-1/> Other <application>PL/pgSQL</"
"application> statements do not change the state of <literal>FOUND</literal>. "
"Note in particular that <command>EXECUTE</command> changes the output of "
"<command>GET DIAGNOSTICS</command>, but does not change <literal>FOUND</"
"literal>."
msgstr ""
"Второй способ определения статуса выполнения команды заключается в проверке "
"значения специальной переменной <literal>FOUND</literal>, имеющей тип "
"<type>boolean</type>. При вызове функции на <application>PL/pgSQL</"
"application>, переменная <literal>FOUND</literal> инициализируется в ложь. "
"Далее, значение переменной изменяется следующими операторами: <placeholder-1/"
"> Другие операторы <application>PL/pgSQL</application> не меняют значение "
"<literal>FOUND</literal>. Помните в частности, что <command>EXECUTE</"
"command> изменяет вывод <command>GET DIAGNOSTICS</command>, но не меняет "
"<literal>FOUND</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1583(para)
msgid ""
"<literal>FOUND</literal> is a local variable within each <application>PL/"
"pgSQL</application> function; any changes to it affect only the current "
"function."
msgstr ""
"<literal>FOUND</literal> является локальной переменной в каждой функции "
"<application>PL/pgSQL</application> и любые её изменения, влияют только на "
"текущую функцию."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1592(title)
msgid "Doing Nothing At All"
msgstr "Не делать ничего"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1594(para)
msgid ""
"Sometimes a placeholder statement that does nothing is useful. For example, "
"it can indicate that one arm of an if/then/else chain is deliberately empty. "
"For this purpose, use the <command>NULL</command> statement: <synopsis>\n"
"NULL;\n"
"</synopsis>"
msgstr ""
"Иногда бывает полезен оператор, который не делает ничего. Например, он может "
"показывать, что одна из ветвей if/then/else сознательно оставлена пустой. "
"Для этих целей используется <command>NULL</command>: <synopsis>\n"
"NULL;\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1607(programlisting)
#, no-wrap
msgid ""
"BEGIN\n"
"    y := x / 0;\n"
"EXCEPTION\n"
"    WHEN division_by_zero THEN\n"
"        NULL;  -- ignore the error\n"
"END;"
msgstr ""
"BEGIN\n"
"    y := x / 0;\n"
"EXCEPTION\n"
"    WHEN division_by_zero THEN\n"
"        NULL;  -- игнорируем ошибку\n"
"END;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1616(programlisting)
#, no-wrap
msgid ""
"BEGIN\n"
"    y := x / 0;\n"
"EXCEPTION\n"
"    WHEN division_by_zero THEN  -- ignore the error\n"
"END;"
msgstr ""
"BEGIN\n"
"    y := x / 0;\n"
"EXCEPTION\n"
"    WHEN division_by_zero THEN  -- игнорируем ошибку\n"
"END;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1605(para)
msgid ""
"For example, the following two fragments of code are equivalent: "
"<placeholder-1/> <placeholder-2/> Which is preferable is a matter of taste."
msgstr ""
"В следующем примере два фрагмента кода эквивалентны: <placeholder-1/> "
"<placeholder-2/> Какой вариант выбрать — дело вкуса."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1627(para)
msgid ""
"In Oracle's PL/SQL, empty statement lists are not allowed, and so "
"<command>NULL</command> statements are <emphasis>required</emphasis> for "
"situations such as this. <application>PL/pgSQL</application> allows you to "
"just write nothing, instead."
msgstr ""
"В Oracle PL/SQL не допускаются пустые списки операторов, поэтому "
"<command>NULL</command> <emphasis>обязателен</emphasis> в подобных "
"ситуациях. В <application>PL/pgSQL</application> разрешается не писать "
"ничего."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1639(title)
msgid "Control Structures"
msgstr "Управляющие структуры"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1641(para)
msgid ""
"Control structures are probably the most useful (and important) part of "
"<application>PL/pgSQL</application>. With <application>PL/pgSQL</"
"application>'s control structures, you can manipulate "
"<productname>PostgreSQL</productname> data in a very flexible and powerful "
"way."
msgstr ""
"Управляющие структуры, вероятно, наиболее полезная и важная часть "
"<application>PL/pgSQL</application>. С их помощью можно очень гибко и "
"эффективно манипулировать данными <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1650(title)
msgid "Returning From a Function"
msgstr "Команды для возврата значения из функции"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1652(para)
msgid ""
"There are two commands available that allow you to return data from a "
"function: <command>RETURN</command> and <command>RETURN NEXT</command>."
msgstr ""
"Две команды позволяют вернуть данные из функции: <command>RETURN</command> и "
"<command>RETURN NEXT</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1659(command)
msgid "RETURN"
msgstr "RETURN"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1662(replaceable) plpgsql.xml:1731(replaceable)
#: plpgsql.xml:1733(replaceable) plpgsql.xml:2046(replaceable)
#: plpgsql.xml:2048(replaceable) plpgsql.xml:2334(replaceable)
#: plpgsql.xml:3023(replaceable)
msgid "expression"
msgstr "выражение"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1661(synopsis)
#, no-wrap
msgid "RETURN <placeholder-1/>;"
msgstr "RETURN <placeholder-1/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1665(para)
msgid ""
"<command>RETURN</command> with an expression terminates the function and "
"returns the value of <replaceable>expression</replaceable> to the caller. "
"This form is used for <application>PL/pgSQL</application> functions that do "
"not return a set."
msgstr ""
"<command>RETURN</command> с последующим выражением прекращает выполнение "
"функции и возвращает значение выражения в вызывающую программу. Эта форма "
"используется для функций <application>PL/pgSQL</application>, которые не "
"возвращают набор строк."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1673(para)
msgid ""
"In a function that returns a scalar type, the expression's result will "
"automatically be cast into the function's return type as described for "
"assignments. But to return a composite (row) value, you must write an "
"expression delivering exactly the requested column set. This may require use "
"of explicit casting."
msgstr ""
"В функции, возвращающей скалярный тип, результирующее выражение "
"автоматически приводится к типу возвращаемого значения. Однако, чтобы "
"вернуть составной тип (строку), возвращаемое выражение должно в точности "
"содержать требуемый набор столбцов. При этом может потребоваться явное "
"приведение типов."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1681(para)
msgid ""
"If you declared the function with output parameters, write just "
"<command>RETURN</command> with no expression. The current values of the "
"output parameter variables will be returned."
msgstr ""
"Для функции с выходными параметрами просто используйте <command>RETURN</"
"command> без выражения. Будут возвращены текущие значения выходных "
"параметров."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1687(para)
msgid ""
"If you declared the function to return <type>void</type>, a <command>RETURN</"
"command> statement can be used to exit the function early; but do not write "
"an expression following <command>RETURN</command>."
msgstr ""
"Для функции, возвращающей <type>void</type>, <command>RETURN</command> можно "
"использовать в любом месте, но без выражения после <command>RETURN</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1694(para)
msgid ""
"The return value of a function cannot be left undefined. If control reaches "
"the end of the top-level block of the function without hitting a "
"<command>RETURN</command> statement, a run-time error will occur. This "
"restriction does not apply to functions with output parameters and functions "
"returning <type>void</type>, however. In those cases a <command>RETURN</"
"command> statement is automatically executed if the top-level block finishes."
msgstr ""
"Возвращаемое значение функции не может остаться не определённым. Если "
"достигнут конец блока верхнего уровня, а оператор <command>RETURN</command> "
"так и не встретился, происходит ошибка времени исполнения. Это не касается "
"функций с выходными параметрами и функций, возвращающих <type>void</type>. "
"Для них оператор <command>RETURN</command> выполняется автоматически по "
"окончании блока верхнего уровня."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1707(programlisting)
#, no-wrap
msgid ""
"-- functions returning a scalar type\n"
"RETURN 1 + 2;\n"
"RETURN scalar_var;\n"
"\n"
"-- functions returning a composite type\n"
"RETURN composite_type_var;\n"
"RETURN (1, 2, 'three'::text);  -- must cast columns to correct types"
msgstr ""
"-- Функции, возвращающие скалярный тип данных\n"
"RETURN 1 + 2;\n"
"RETURN scalar_var;\n"
"\n"
"-- Функции, возвращающие составной тип данных\n"
"RETURN composite_type_var;\n"
"RETURN (1, 2, 'three'::text);  -- требуется приведение типов"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1704(para)
msgid "Some examples: <placeholder-1/>"
msgstr "Несколько примеров: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1720(title)
msgid "<command>RETURN NEXT</command> and <command>RETURN QUERY</command>"
msgstr "<command>RETURN NEXT</command> и <command>RETURN QUERY</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1721(indexterm)
msgid "<primary>RETURN NEXT</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>RETURN NEXT</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1725(indexterm)
msgid "<primary>RETURN QUERY</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>RETURN QUERY</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1732(replaceable) plpgsql.xml:2985(replaceable)
#: plpgsql.xml:2988(replaceable)
msgid "query"
msgstr "запрос"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1733(replaceable)
msgid "command-string"
msgstr "строка-команды"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1733(optional) plpgsql.xml:3023(optional)
#: plpgsql.xml:3059(optional)
msgid ", ..."
msgstr ", ..."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1733(optional) plpgsql.xml:3023(optional)
msgid "USING <placeholder-1/> <placeholder-2/>"
msgstr "USING <placeholder-1/> <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1730(synopsis)
#, no-wrap
msgid ""
"RETURN NEXT <placeholder-1/>;\n"
"RETURN QUERY <placeholder-2/>;\n"
"RETURN QUERY EXECUTE <placeholder-3/> <placeholder-4/>;"
msgstr ""
"RETURN NEXT <placeholder-1/>;\n"
"RETURN QUERY <placeholder-2/>;\n"
"RETURN QUERY EXECUTE <placeholder-3/> <placeholder-4/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1736(para)
msgid ""
"When a <application>PL/pgSQL</application> function is declared to return "
"<literal>SETOF <replaceable>sometype</replaceable></literal>, the procedure "
"to follow is slightly different. In that case, the individual items to "
"return are specified by a sequence of <command>RETURN NEXT</command> or "
"<command>RETURN QUERY</command> commands, and then a final <command>RETURN</"
"command> command with no argument is used to indicate that the function has "
"finished executing. <command>RETURN NEXT</command> can be used with both "
"scalar and composite data types; with a composite result type, an entire "
"<quote>table</quote> of results will be returned. <command>RETURN QUERY</"
"command> appends the results of executing a query to the function's result "
"set. <command>RETURN NEXT</command> and <command>RETURN QUERY</command> can "
"be freely intermixed in a single set-returning function, in which case their "
"results will be concatenated."
msgstr ""
"Для функций на <application>PL/pgSQL</application>, возвращающих "
"<literal>SETOF <replaceable>некий_тип</replaceable></literal>, нужно "
"действовать несколько по-иному. Отдельные элементы возвращаемого значения "
"формируются командами <command>RETURN NEXT</command> или <command>RETURN "
"QUERY</command>, а финальная команда <command>RETURN</command> без "
"аргументов завершает выполнение функции. <command>RETURN NEXT</command> "
"используется как со скалярными, так и с составными типами данных. Для "
"составного типа результат функции возвращается в виде таблицы. "
"<command>RETURN QUERY</command> добавляет результат выполнения запроса к "
"результату функции. <command>RETURN NEXT</command> и <command>RETURN QUERY</"
"command> можно свободно смешивать в теле функции, в этом случае их "
"результаты будут объединены."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1754(para)
msgid ""
"<command>RETURN NEXT</command> and <command>RETURN QUERY</command> do not "
"actually return from the function &mdash; they simply append zero or more "
"rows to the function's result set. Execution then continues with the next "
"statement in the <application>PL/pgSQL</application> function. As successive "
"<command>RETURN NEXT</command> or <command>RETURN QUERY</command> commands "
"are executed, the result set is built up. A final <command>RETURN</command>, "
"which should have no argument, causes control to exit the function (or you "
"can just let control reach the end of the function)."
msgstr ""
"<command>RETURN NEXT</command> и <command>RETURN QUERY</command> не "
"выполняют возврат из функции. Они просто добавляют строки в результирующее "
"множество. Затем выполнение продолжается со следующего оператора в функции. "
"Успешное выполнение <command>RETURN NEXT</command> и <command>RETURN QUERY</"
"command> формирует множество строк результата. Для выхода из функции "
"используется <command>RETURN</command>, обязательно без аргументов (или "
"можно просто дождаться окончания выполнения функции)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1767(para)
msgid ""
"<command>RETURN QUERY</command> has a variant <command>RETURN QUERY EXECUTE</"
"command>, which specifies the query to be executed dynamically. Parameter "
"expressions can be inserted into the computed query string via "
"<literal>USING</literal>, in just the same way as in the <command>EXECUTE</"
"command> command."
msgstr ""
"<command>RETURN QUERY</command> имеет разновидность <command>RETURN QUERY "
"EXECUTE</command>, предназначенную для динамического выполнения запроса. В "
"текст запроса можно добавить параметры, используя <literal>USING</literal>, "
"также как и с командой <command>EXECUTE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1775(para)
msgid ""
"If you declared the function with output parameters, write just "
"<command>RETURN NEXT</command> with no expression. On each execution, the "
"current values of the output parameter variable(s) will be saved for "
"eventual return as a row of the result. Note that you must declare the "
"function as returning <literal>SETOF record</literal> when there are "
"multiple output parameters, or <literal>SETOF <replaceable>sometype</"
"replaceable></literal> when there is just one output parameter of type "
"<replaceable>sometype</replaceable>, in order to create a set-returning "
"function with output parameters."
msgstr ""
"Для функции с выходными параметрами просто используйте <command>RETURN NEXT</"
"command> без аргументов. При каждом исполнении <command>RETURN NEXT</"
"command> текущие значения выходных параметров сохраняются для последующего "
"возврата в качестве строки результата. Обратите внимание, что если функция с "
"выходными параметрами должна возвращать множество значений, то при "
"объявлении нужно указывать <literal>RETURNS SETOF</literal>. При этом если "
"выходных параметров несколько, то используется <literal>RETURNS SETOF "
"record</literal>, а если только один с типом <replaceable>некий_тип</"
"replaceable>, то <literal>RETURNS SETOF <replaceable>некий_тип</"
"replaceable></literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1792(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);\n"
"INSERT INTO foo VALUES (1, 2, 'three');\n"
"INSERT INTO foo VALUES (4, 5, 'six');\n"
"\n"
"CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS\n"
"$BODY$\n"
"DECLARE\n"
"    r foo%rowtype;\n"
"BEGIN\n"
"    FOR r IN\n"
"        SELECT * FROM foo WHERE fooid &gt; 0\n"
"    LOOP\n"
"        -- can do some processing here\n"
"        RETURN NEXT r; -- return current row of SELECT\n"
"    END LOOP;\n"
"    RETURN;\n"
"END\n"
"$BODY$\n"
"LANGUAGE plpgsql;\n"
"\n"
"SELECT * FROM get_all_foo();"
msgstr ""
"CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);\n"
"INSERT INTO foo VALUES (1, 2, 'three');\n"
"INSERT INTO foo VALUES (4, 5, 'six');\n"
"\n"
"CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS\n"
"$BODY$\n"
"DECLARE\n"
"    r foo%rowtype;\n"
"BEGIN\n"
"    FOR r IN\n"
"        SELECT * FROM foo WHERE fooid &gt; 0\n"
"    LOOP\n"
"        -- здесь возможна обработка данных\n"
"        RETURN NEXT r; -- добавляет текущую строку запроса к возвращаемому результату\n"
"    END LOOP;\n"
"    RETURN;\n"
"END\n"
"$BODY$\n"
"LANGUAGE plpgsql;\n"
"\n"
"SELECT * FROM get_all_foo();"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1788(para)
msgid ""
"Here is an example of a function using <command>RETURN NEXT</command>: "
"<placeholder-1/>"
msgstr "Пример использования <command>RETURN NEXT</command>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1821(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS\n"
"$BODY$\n"
"BEGIN\n"
"    RETURN QUERY SELECT flightid\n"
"                   FROM flight\n"
"                  WHERE flightdate &gt;= $1\n"
"                    AND flightdate &lt; ($1 + 1);\n"
"\n"
"    -- Since execution is not finished, we can check whether rows were returned\n"
"    -- and raise exception if not.\n"
"    IF NOT FOUND THEN\n"
"        RAISE EXCEPTION 'No flight at %.', $1;\n"
"    END IF;\n"
"\n"
"    RETURN;\n"
" END\n"
"$BODY$\n"
"LANGUAGE plpgsql;\n"
"\n"
"-- Returns available flights or raises exception if there are no\n"
"-- available flights.\n"
"SELECT * FROM get_available_flightid(CURRENT_DATE);"
msgstr ""
"CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS\n"
"$BODY$\n"
"BEGIN\n"
"    RETURN QUERY SELECT flightid\n"
"                   FROM flight\n"
"                  WHERE flightdate &gt;= $1\n"
"                    AND flightdate &lt; ($1 + 1);\n"
"\n"
"    -- Так как выполнение ещё не закончено, можно проверить, были ли возвращены строки\n"
"    -- Если нет, то вызываем исключение\n"
"    IF NOT FOUND THEN\n"
"        RAISE EXCEPTION 'Нет рейсов на дату: %.', $1;\n"
"    END IF;\n"
"\n"
"    RETURN;\n"
" END\n"
"$BODY$\n"
"LANGUAGE plpgsql;\n"
"\n"
"-- Возвращает доступные рейсы, либо вызывает исключение\n"
"SELECT * FROM get_available_flightid(CURRENT_DATE);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1817(para)
msgid ""
"Here is an example of a function using <command>RETURN QUERY</command>: "
"<placeholder-1/>"
msgstr "Пример использования <command>RETURN QUERY</command>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1848(para)
msgid ""
"The current implementation of <command>RETURN NEXT</command> and "
"<command>RETURN QUERY</command> stores the entire result set before "
"returning from the function, as discussed above. That means that if a "
"<application>PL/pgSQL</application> function produces a very large result "
"set, performance might be poor: data will be written to disk to avoid memory "
"exhaustion, but the function itself will not return until the entire result "
"set has been generated. A future version of <application>PL/pgSQL</"
"application> might allow users to define set-returning functions that do not "
"have this limitation. Currently, the point at which data begins being "
"written to disk is controlled by the <xref linkend=\"guc-work-mem\"/> "
"configuration variable. Administrators who have sufficient memory to store "
"larger result sets in memory should consider increasing this parameter."
msgstr ""
"В текущей реализации <command>RETURN NEXT</command> и <command>RETURN QUERY</"
"command> результирующее множество накапливается целиком, прежде чем будет "
"возвращено из функции. Если множество очень большое, то это может "
"отрицательно сказаться на производительности, так как при нехватке "
"оперативной памяти данные записываются на диск. В следующих версиях "
"<application>PL/pgSQL</application> это ограничение будет снято. В настоящее "
"время управлять количеством оперативной памяти в подобных случаях можно "
"параметром конфигурации <xref linkend=\"guc-work-mem\"/>. При наличии "
"свободной памяти администраторы должны рассмотреть возможность увеличения "
"значения данного параметра."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1870(title)
msgid "Conditionals"
msgstr "Условные операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1878(literal)
msgid "IF ... THEN ... END IF"
msgstr "IF ... THEN ... END IF"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1881(literal)
msgid "IF ... THEN ... ELSE ... END IF"
msgstr "IF ... THEN ... ELSE ... END IF"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1884(literal)
msgid "IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF"
msgstr "IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1891(literal)
msgid "CASE ... WHEN ... THEN ... ELSE ... END CASE"
msgstr "CASE ... WHEN ... THEN ... ELSE ... END CASE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1894(literal)
msgid "CASE WHEN ... THEN ... ELSE ... END CASE"
msgstr "CASE WHEN ... THEN ... ELSE ... END CASE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1872(para)
msgid ""
"<command>IF</command> and <command>CASE</command> statements let you execute "
"alternative commands based on certain conditions. <application>PL/pgSQL</"
"application> has three forms of <command>IF</command>: <placeholder-1/> and "
"two forms of <command>CASE</command>: <placeholder-2/>"
msgstr ""
"Операторы <command>IF</command> и <command>CASE</command> позволяют "
"выполнять команды в зависимости от определённых условий. <application>PL/"
"pgSQL</application> поддерживает три формы <command>IF</command>: "
"<placeholder-1/> и две формы <command>CASE</command>: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1900(literal)
msgid "IF-THEN"
msgstr "IF-THEN"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1903(replaceable) plpgsql.xml:1930(replaceable)
#: plpgsql.xml:1971(replaceable) plpgsql.xml:1973(replaceable)
#: plpgsql.xml:1975(replaceable) plpgsql.xml:2089(replaceable)
#: plpgsql.xml:2091(replaceable) plpgsql.xml:2180(replaceable)
#: plpgsql.xml:2252(replaceable) plpgsql.xml:2302(replaceable)
msgid "boolean-expression"
msgstr "логическое-выражение"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1904(replaceable) plpgsql.xml:1931(replaceable)
#: plpgsql.xml:1933(replaceable) plpgsql.xml:1972(replaceable)
#: plpgsql.xml:1974(replaceable) plpgsql.xml:1976(replaceable)
#: plpgsql.xml:1979(replaceable) plpgsql.xml:2047(replaceable)
#: plpgsql.xml:2049(replaceable) plpgsql.xml:2052(replaceable)
#: plpgsql.xml:2090(replaceable) plpgsql.xml:2092(replaceable)
#: plpgsql.xml:2095(replaceable) plpgsql.xml:2157(replaceable)
#: plpgsql.xml:2303(replaceable) plpgsql.xml:2335(replaceable)
msgid "statements"
msgstr "операторы"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1902(synopsis)
#, no-wrap
msgid ""
"IF <placeholder-1/> THEN\n"
"    <placeholder-2/>\n"
"END IF;"
msgstr ""
"IF <placeholder-1/> THEN\n"
"    <placeholder-2/>\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1908(para)
msgid ""
"<literal>IF-THEN</literal> statements are the simplest form of <literal>IF</"
"literal>. The statements between <literal>THEN</literal> and <literal>END "
"IF</literal> will be executed if the condition is true. Otherwise, they are "
"skipped."
msgstr ""
"<literal>IF-THEN</literal> это простейшая форма <literal>IF</literal>. "
"Операторы между <literal>THEN</literal> и <literal>END IF</literal> "
"выполняются, если условие (<replaceable>логическое-выражение</replaceable>) "
"истинно. В противном случае они опускаются."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1918(programlisting)
#, no-wrap
msgid ""
"IF v_user_id &lt;&gt; 0 THEN\n"
"    UPDATE users SET email = v_email WHERE user_id = v_user_id;\n"
"END IF;"
msgstr ""
"IF v_user_id &lt;&gt; 0 THEN\n"
"    UPDATE users SET email = v_email WHERE user_id = v_user_id;\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1916(para)
msgid "Example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1927(literal)
msgid "IF-THEN-ELSE"
msgstr "IF-THEN-ELSE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1929(synopsis)
#, no-wrap
msgid ""
"IF <placeholder-1/> THEN\n"
"    <placeholder-2/>\n"
"ELSE\n"
"    <placeholder-3/>\n"
"END IF;"
msgstr ""
"IF <placeholder-1/> THEN\n"
"    <placeholder-2/>\n"
"ELSE\n"
"    <placeholder-3/>\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1937(para)
msgid ""
"<literal>IF-THEN-ELSE</literal> statements add to <literal>IF-THEN</literal> "
"by letting you specify an alternative set of statements that should be "
"executed if the condition is not true. (Note this includes the case where "
"the condition evaluates to NULL.)"
msgstr ""
"<literal>IF-THEN-ELSE</literal> добавляет к <literal>IF-THEN</literal> "
"возможность указать альтернативный набор операторов, которые будут "
"выполнены, если условие не истинно (в том числе, если условие NULL)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1947(programlisting)
#, no-wrap
msgid ""
"IF parentid IS NULL OR parentid = ''\n"
"THEN\n"
"    RETURN fullname;\n"
"ELSE\n"
"    RETURN hp_true_filename(parentid) || '/' || fullname;\n"
"END IF;"
msgstr ""
"IF parentid IS NULL OR parentid = ''\n"
"THEN\n"
"    RETURN fullname;\n"
"ELSE\n"
"    RETURN hp_true_filename(parentid) || '/' || fullname;\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1956(programlisting)
#, no-wrap
msgid ""
"IF v_count &gt; 0 THEN\n"
"    INSERT INTO users_count (count) VALUES (v_count);\n"
"    RETURN 't';\n"
"ELSE\n"
"    RETURN 'f';\n"
"END IF;"
msgstr ""
"IF v_count &gt; 0 THEN\n"
"    INSERT INTO users_count (count) VALUES (v_count);\n"
"    RETURN 't';\n"
"ELSE\n"
"    RETURN 'f';\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1945(para)
msgid "Examples: <placeholder-1/> <placeholder-2/>"
msgstr "Примеры: <placeholder-1/> <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1968(literal)
msgid "IF-THEN-ELSIF"
msgstr "IF-THEN-ELSIF"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1975(optional)
msgid "ELSIF <placeholder-1/> THEN <placeholder-2/> ..."
msgstr "ELSIF <placeholder-1/> THEN <placeholder-2/> ..."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1973(optional)
msgid "ELSIF <placeholder-1/> THEN <placeholder-2/> <placeholder-3/>"
msgstr "ELSIF <placeholder-1/> THEN <placeholder-2/> <placeholder-3/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1978(optional) plpgsql.xml:2051(optional)
#: plpgsql.xml:2094(optional)
msgid "ELSE <placeholder-1/>"
msgstr "ELSE <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1970(synopsis)
#, no-wrap
msgid ""
"IF <placeholder-1/> THEN\n"
"    <placeholder-2/>\n"
"<placeholder-3/>\n"
"<placeholder-4/>\n"
"END IF;"
msgstr ""
"IF <placeholder-1/> THEN\n"
"    <placeholder-2/>\n"
"<placeholder-3/>\n"
"<placeholder-4/>\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1983(para)
msgid ""
"Sometimes there are more than just two alternatives. <literal>IF-THEN-ELSIF</"
"literal> provides a convenient method of checking several alternatives in "
"turn. The <literal>IF</literal> conditions are tested successively until the "
"first one that is true is found. Then the associated statement(s) are "
"executed, after which control passes to the next statement after "
"<literal>END IF</literal>. (Any subsequent <literal>IF</literal> conditions "
"are <emphasis>not</emphasis> tested.) If none of the <literal>IF</literal> "
"conditions is true, then the <literal>ELSE</literal> block (if any) is "
"executed."
msgstr ""
"В некоторых случаях двух альтернатив недостаточно. <literal>IF-THEN-ELSIF</"
"literal> обеспечивает удобный способ проверки нескольких вариантов по "
"очереди. Условия в <literal>IF</literal> последовательно проверяются до тех "
"пор, пока не будет найдено первое истинное. После этого операторы, "
"относящиеся к этому условию, выполняются, и управление переходит к следующей "
"после <literal>END IF</literal> команде. (Все последующие условия не "
"проверяются.) Если ни одно из условий <literal>IF</literal> не является "
"истинным, то выполняется блок <literal>ELSE</literal> (если присутствует)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1999(programlisting)
#, no-wrap
msgid ""
"IF number = 0 THEN\n"
"    result := 'zero';\n"
"ELSIF number &gt; 0 THEN\n"
"    result := 'positive';\n"
"ELSIF number &lt; 0 THEN\n"
"    result := 'negative';\n"
"ELSE\n"
"    -- hmm, the only other possibility is that number is null\n"
"    result := 'NULL';\n"
"END IF;"
msgstr ""
"IF number = 0 THEN\n"
"    result := 'zero';\n"
"ELSIF number &gt; 0 THEN\n"
"    result := 'positive';\n"
"ELSIF number &lt; 0 THEN\n"
"    result := 'negative';\n"
"ELSE\n"
"    -- раз мы здесь, значит значение number не определено (NULL)\n"
"    result := 'NULL';\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:1996(para) plpgsql.xml:2113(para) plpgsql.xml:2824(para)
msgid "Here is an example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2013(para)
msgid ""
"The key word <literal>ELSIF</literal> can also be spelled <literal>ELSEIF</"
"literal>."
msgstr ""
"Вместо ключевого слова <literal>ELSIF</literal> можно использовать "
"<literal>ELSEIF</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2023(programlisting)
#, no-wrap
msgid ""
"IF demo_row.sex = 'm' THEN\n"
"    pretty_sex := 'man';\n"
"ELSE\n"
"    IF demo_row.sex = 'f' THEN\n"
"        pretty_sex := 'woman';\n"
"    END IF;\n"
"END IF;"
msgstr ""
"IF demo_row.sex = 'm' THEN\n"
"    pretty_sex := 'man';\n"
"ELSE\n"
"    IF demo_row.sex = 'f' THEN\n"
"        pretty_sex := 'woman';\n"
"    END IF;\n"
"END IF;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2018(para)
msgid ""
"An alternative way of accomplishing the same task is to nest <literal>IF-"
"THEN-ELSE</literal> statements, as in the following example: <placeholder-1/>"
msgstr ""
"Другой вариант сделать то же самое, это использование вложенных операторов "
"<literal>IF-THEN-ELSE</literal>, как в следующем примере: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2034(para)
msgid ""
"However, this method requires writing a matching <literal>END IF</literal> "
"for each <literal>IF</literal>, so it is much more cumbersome than using "
"<literal>ELSIF</literal> when there are many alternatives."
msgstr ""
"Однако это требует написания соответствующих <literal>END IF</literal> для "
"каждого <literal>IF</literal>, что при наличии нескольких альтернатив делает "
"код более громоздким, чем использование <literal>ELSIF</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2042(title)
msgid "Simple <literal>CASE</literal>"
msgstr "Простой <literal>CASE</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2045(replaceable)
msgid "search-expression"
msgstr "выражение-поиска"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2046(optional) plpgsql.xml:2048(optional)
msgid "..."
msgstr "..."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2046(optional) plpgsql.xml:2048(optional)
msgid ", <placeholder-1/> <placeholder-2/>"
msgstr ", <placeholder-1/> <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2048(optional)
msgid "WHEN <placeholder-1/> <placeholder-2/> THEN <placeholder-3/> ..."
msgstr "WHEN <placeholder-1/> <placeholder-2/> THEN <placeholder-3/> ..."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2044(synopsis)
#, no-wrap
msgid ""
"CASE <placeholder-1/>\n"
"    WHEN <placeholder-2/> <placeholder-3/> THEN\n"
"      <placeholder-4/>\n"
"  <placeholder-5/>\n"
"  <placeholder-6/>\n"
"END CASE;"
msgstr ""
"CASE <placeholder-1/>\n"
"    WHEN <placeholder-2/> <placeholder-3/> THEN\n"
"      <placeholder-4/>\n"
"  <placeholder-5/>\n"
"  <placeholder-6/>\n"
"END CASE;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2056(para)
msgid ""
"The simple form of <command>CASE</command> provides conditional execution "
"based on equality of operands. The <replaceable>search-expression</"
"replaceable> is evaluated (once) and successively compared to each "
"<replaceable>expression</replaceable> in the <literal>WHEN</literal> "
"clauses. If a match is found, then the corresponding "
"<replaceable>statements</replaceable> are executed, and then control passes "
"to the next statement after <literal>END CASE</literal>. (Subsequent "
"<literal>WHEN</literal> expressions are not evaluated.) If no match is "
"found, the <literal>ELSE</literal> <replaceable>statements</replaceable> are "
"executed; but if <literal>ELSE</literal> is not present, then a "
"<literal>CASE_NOT_FOUND</literal> exception is raised."
msgstr ""
"Простая форма <command>CASE</command> реализует условное выполнение на "
"основе сравнения операндов. <replaceable>Выражение-поиска</replaceable> "
"вычисляется (один раз) и последовательно сравнивается с каждым "
"<replaceable>выражением</replaceable> в условиях <literal>WHEN</literal>. "
"Если совпадение найдено, то выполняются соответствующие "
"<replaceable>операторы</replaceable> и управление переходит к следующей "
"после <literal>END CASE</literal> команде. (Все последующие выражения "
"<literal>WHEN</literal> не проверяются.) Если совпадение не было найдено, то "
"выполняются <replaceable>операторы</replaceable> в <literal>ELSE</literal>. "
"Но если <literal>ELSE</literal> нет, то вызывается исключение "
"<literal>CASE_NOT_FOUND</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2073(programlisting)
#, no-wrap
msgid ""
"CASE x\n"
"    WHEN 1, 2 THEN\n"
"        msg := 'one or two';\n"
"    ELSE\n"
"        msg := 'other value than one or two';\n"
"END CASE;"
msgstr ""
"CASE x\n"
"    WHEN 1, 2 THEN\n"
"        msg := 'один или два';\n"
"    ELSE\n"
"        msg := 'значение, отличное от один или два';\n"
"END CASE;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2070(para)
msgid "Here is a simple example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2085(title)
msgid "Searched <literal>CASE</literal>"
msgstr "<literal>CASE</literal> с перебором условий"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2091(optional)
msgid "WHEN <placeholder-1/> THEN <placeholder-2/> ..."
msgstr "WHEN <placeholder-1/> THEN <placeholder-2/> ..."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2087(synopsis)
#, no-wrap
msgid ""
"CASE\n"
"    WHEN <placeholder-1/> THEN\n"
"      <placeholder-2/>\n"
"  <placeholder-3/>\n"
"  <placeholder-4/>\n"
"END CASE;"
msgstr ""
"CASE\n"
"    WHEN <placeholder-1/> THEN\n"
"      <placeholder-2/>\n"
"  <placeholder-3/>\n"
"  <placeholder-4/>\n"
"END CASE;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2099(para)
msgid ""
"The searched form of <command>CASE</command> provides conditional execution "
"based on truth of Boolean expressions. Each <literal>WHEN</literal> clause's "
"<replaceable>boolean-expression</replaceable> is evaluated in turn, until "
"one is found that yields <literal>true</literal>. Then the corresponding "
"<replaceable>statements</replaceable> are executed, and then control passes "
"to the next statement after <literal>END CASE</literal>. (Subsequent "
"<literal>WHEN</literal> expressions are not evaluated.) If no true result is "
"found, the <literal>ELSE</literal> <replaceable>statements</replaceable> are "
"executed; but if <literal>ELSE</literal> is not present, then a "
"<literal>CASE_NOT_FOUND</literal> exception is raised."
msgstr ""
"Эта форма <command>CASE</command> реализует условное выполнение, основываясь "
"на истинности логических условий. Каждое <replaceable>логическое-выражение</"
"replaceable> в предложении <literal>WHEN</literal> вычисляется по порядку до "
"тех пор, пока не будет найдено истинное. Затем выполняются соответствующие "
"<replaceable>операторы</replaceable> и управление переходит к следующей "
"после <literal>END CASE</literal> команде. (Все последующие выражения "
"<literal>WHEN</literal> не проверяются.) Если ни одно из условий не окажется "
"истинным, то выполняются <replaceable>операторы</replaceable> в "
"<literal>ELSE</literal>. Но если <literal>ELSE</literal> нет, то вызывается "
"исключение <literal>CASE_NOT_FOUND</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2116(programlisting)
#, no-wrap
msgid ""
"CASE\n"
"    WHEN x BETWEEN 0 AND 10 THEN\n"
"        msg := 'value is between zero and ten';\n"
"    WHEN x BETWEEN 11 AND 20 THEN\n"
"        msg := 'value is between eleven and twenty';\n"
"END CASE;"
msgstr ""
"CASE\n"
"    WHEN x BETWEEN 0 AND 10 THEN\n"
"        msg := 'значение в диапазоне между 0 и 10';\n"
"    WHEN x BETWEEN 11 AND 20 THEN\n"
"        msg := 'значение в диапазоне между 11 и 20';\n"
"END CASE;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2126(para)
msgid ""
"This form of <command>CASE</command> is entirely equivalent to <literal>IF-"
"THEN-ELSIF</literal>, except for the rule that reaching an omitted "
"<literal>ELSE</literal> clause results in an error rather than doing nothing."
msgstr ""
"Эта форма <command>CASE</command> полностью эквивалента <literal>IF-THEN-"
"ELSIF</literal>, за исключением того, что при невыполнении всех условий и "
"отсутствии <literal>ELSE</literal>, <literal>IF-THEN-ELSIF</literal> ничего "
"не делает, а <command>CASE</command> вызывает ошибку."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2137(title)
msgid "Simple Loops"
msgstr "Простые циклы"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2139(indexterm)
msgid "<primary>loop</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>цикл</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2144(para)
msgid ""
"With the <literal>LOOP</literal>, <literal>EXIT</literal>, "
"<literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</"
"literal>, and <literal>FOREACH</literal> statements, you can arrange for "
"your <application>PL/pgSQL</application> function to repeat a series of "
"commands."
msgstr ""
"Операторы <literal>LOOP</literal>, <literal>EXIT</literal>, "
"<literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</"
"literal> и <literal>FOREACH</literal> позволяют повторить серию команд в "
"функции на <application>PL/pgSQL</application>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2152(literal)
msgid "LOOP"
msgstr "LOOP"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2155(replaceable) plpgsql.xml:2158(replaceable)
#: plpgsql.xml:2180(replaceable) plpgsql.xml:2252(replaceable)
#: plpgsql.xml:2301(replaceable) plpgsql.xml:2304(replaceable)
#: plpgsql.xml:2333(replaceable) plpgsql.xml:2336(replaceable)
msgid "label"
msgstr "метка"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2155(optional) plpgsql.xml:2301(optional)
#: plpgsql.xml:2333(optional)
msgid "&lt;&lt;<placeholder-1/>&gt;&gt;"
msgstr "&lt;&lt;<placeholder-1/>&gt;&gt;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2154(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/>\n"
"LOOP\n"
"    <placeholder-2/>\n"
"END LOOP <optional> <placeholder-3/> </optional>;"
msgstr ""
"<placeholder-1/>\n"
"LOOP\n"
"    <placeholder-2/>\n"
"END LOOP <optional> <placeholder-3/> </optional>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2161(para)
msgid ""
"<literal>LOOP</literal> defines an unconditional loop that is repeated "
"indefinitely until terminated by an <literal>EXIT</literal> or "
"<command>RETURN</command> statement. The optional <replaceable>label</"
"replaceable> can be used by <literal>EXIT</literal> and <literal>CONTINUE</"
"literal> statements within nested loops to specify which loop those "
"statements refer to."
msgstr ""
"<literal>LOOP</literal> организует безусловный цикл, который повторяется до "
"бесконечности, пока не будет прекращён операторами <literal>EXIT</literal> "
"или <command>RETURN</command>. Для вложенных циклов можно использовать "
"<replaceable>метку</replaceable> в операторах <literal>EXIT</literal> и "
"<literal>CONTINUE</literal>, чтобы указать, к какому циклу эти операторы "
"относятся."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2172(literal)
msgid "EXIT"
msgstr "EXIT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2174(indexterm)
msgid "<primary>EXIT</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>EXIT</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2180(optional) plpgsql.xml:2252(optional)
msgid "WHEN <placeholder-1/>"
msgstr "WHEN <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2179(synopsis)
#, no-wrap
msgid "EXIT <optional> <placeholder-1/> </optional> <placeholder-2/>;"
msgstr "EXIT <optional> <placeholder-1/> </optional> <placeholder-2/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2183(para)
msgid ""
"If no <replaceable>label</replaceable> is given, the innermost loop is "
"terminated and the statement following <literal>END LOOP</literal> is "
"executed next. If <replaceable>label</replaceable> is given, it must be the "
"label of the current or some outer level of nested loop or block. Then the "
"named loop or block is terminated and control continues with the statement "
"after the loop's/block's corresponding <literal>END</literal>."
msgstr ""
"Если <replaceable>метка</replaceable> не указана, то завершается самый "
"внутренний цикл, далее выполняется оператор, следующий за <literal>END LOOP</"
"literal>. Если <replaceable>метка</replaceable> указана, то она должна "
"относиться к текущему или внешнему циклу, или это может быть метка блока. "
"При этом в именованном цикле/блоке выполнение прекращается, а управление "
"переходит к следующему оператору после соответствующего <literal>END</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2193(para)
msgid ""
"If <literal>WHEN</literal> is specified, the loop exit occurs only if "
"<replaceable>boolean-expression</replaceable> is true. Otherwise, control "
"passes to the statement after <literal>EXIT</literal>."
msgstr ""
"При наличии <literal>WHEN</literal> цикл прекращается, только если "
"<replaceable>логическое-выражение</replaceable> истинно. В противном случае "
"управление переходит к оператору, следующему за <literal>EXIT</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2199(para)
msgid ""
"<literal>EXIT</literal> can be used with all types of loops; it is not "
"limited to use with unconditional loops."
msgstr ""
"<literal>EXIT</literal> можно использовать со всеми типами циклов, не только "
"с безусловным."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2204(para)
msgid ""
"When used with a <literal>BEGIN</literal> block, <literal>EXIT</literal> "
"passes control to the next statement after the end of the block. Note that a "
"label must be used for this purpose; an unlabeled <literal>EXIT</literal> is "
"never considered to match a <literal>BEGIN</literal> block. (This is a "
"change from pre-8.4 releases of <productname>PostgreSQL</productname>, which "
"would allow an unlabeled <literal>EXIT</literal> to match a <literal>BEGIN</"
"literal> block.)"
msgstr ""
"Когда <literal>EXIT</literal> используется для выхода из блока, управление "
"переходит к следующему оператору после окончания блока. Обратите внимание, "
"что для выхода из блока нужно обязательно указывать <replaceable>метку</"
"replaceable>. <literal>EXIT</literal> без <replaceable>метки</replaceable> "
"не позволяет прекратить работу блока. (Это изменение по сравнению с версиями "
"<productname>PostgreSQL</productname> до 8.4, в которых разрешалось "
"использовать <literal>EXIT</literal> без <replaceable>метки</replaceable> "
"для прекращения работы текущего блока.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2218(programlisting)
#, no-wrap
msgid ""
"LOOP\n"
"    -- some computations\n"
"    IF count &gt; 0 THEN\n"
"        EXIT;  -- exit loop\n"
"    END IF;\n"
"END LOOP;\n"
"\n"
"LOOP\n"
"    -- some computations\n"
"    EXIT WHEN count &gt; 0;  -- same result as previous example\n"
"END LOOP;\n"
"\n"
"&lt;&lt;ablock&gt;&gt;\n"
"BEGIN\n"
"    -- some computations\n"
"    IF stocks &gt; 100000 THEN\n"
"        EXIT ablock;  -- causes exit from the BEGIN block\n"
"    END IF;\n"
"    -- computations here will be skipped when stocks &gt; 100000\n"
"END;"
msgstr ""
"LOOP\n"
"    -- здесь вычисления \n"
"    IF count &gt; 0 THEN\n"
"        EXIT;  -- выход из цикла\n"
"    END IF;\n"
"END LOOP;\n"
"\n"
"LOOP\n"
"    -- здесь вычисления\n"
"    EXIT WHEN count &gt; 0;  -- аналогично предыдущему примеру\n"
"END LOOP;\n"
"\n"
"&lt;&lt;ablock&gt;&gt;\n"
"BEGIN\n"
"    -- здесь вычисления\n"
"    IF stocks &gt; 100000 THEN\n"
"        EXIT ablock;  -- выход из блока ablock\n"
"    END IF;\n"
"    -- вычисления не будут выполнены, если stocks &gt; 100000\n"
"END;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2244(literal)
msgid "CONTINUE"
msgstr "CONTINUE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2246(indexterm)
msgid "<primary>CONTINUE</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>CONTINUE</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2251(synopsis)
#, no-wrap
msgid "CONTINUE <optional> <placeholder-1/> </optional> <placeholder-2/>;"
msgstr "CONTINUE <optional> <placeholder-1/> </optional> <placeholder-2/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2255(para)
msgid ""
"If no <replaceable>label</replaceable> is given, the next iteration of the "
"innermost loop is begun. That is, all statements remaining in the loop body "
"are skipped, and control returns to the loop control expression (if any) to "
"determine whether another loop iteration is needed. If <replaceable>label</"
"replaceable> is present, it specifies the label of the loop whose execution "
"will be continued."
msgstr ""
"Если <replaceable>метка</replaceable> не указана, то начинается следующая "
"итерация самого внутреннего цикла. То есть все оставшиеся в цикле операторы "
"пропускаются, и управление переходит к управляющему выражению цикла (если "
"есть) для определения, нужна ли ещё одна итерация цикла. Если "
"<replaceable>метка</replaceable> присутствует, то она указывает на метку "
"цикла, выполнение которого будет продолжено."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2266(para)
msgid ""
"If <literal>WHEN</literal> is specified, the next iteration of the loop is "
"begun only if <replaceable>boolean-expression</replaceable> is true. "
"Otherwise, control passes to the statement after <literal>CONTINUE</literal>."
msgstr ""
"При наличии <literal>WHEN</literal> следующая итерация цикла начинается "
"только тогда, когда <replaceable>логическое-выражение</replaceable> истинно. "
"В противном случае управление переходит к оператору, следующему за "
"<literal>CONTINUE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2273(para)
msgid ""
"<literal>CONTINUE</literal> can be used with all types of loops; it is not "
"limited to use with unconditional loops."
msgstr ""
"<literal>CONTINUE</literal> можно использовать со всеми типами циклов, не "
"только с безусловным."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2280(programlisting)
#, no-wrap
msgid ""
"LOOP\n"
"    -- some computations\n"
"    EXIT WHEN count &gt; 100;\n"
"    CONTINUE WHEN count &lt; 50;\n"
"    -- some computations for count IN [50 .. 100]\n"
"END LOOP;"
msgstr ""
"LOOP\n"
"    -- здесь вычисления\n"
"    EXIT WHEN count &gt; 100;\n"
"    CONTINUE WHEN count &lt; 50;\n"
"    -- Вычисления для count в диапазоне 50 .. 100\n"
"END LOOP;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2293(literal)
msgid "WHILE"
msgstr "WHILE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2295(indexterm)
msgid "<primary>WHILE</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>WHILE</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2300(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/>\n"
"WHILE <placeholder-2/> LOOP\n"
"    <placeholder-3/>\n"
"END LOOP <optional> <placeholder-4/> </optional>;"
msgstr ""
"<placeholder-1/>\n"
"WHILE <placeholder-2/> LOOP\n"
"    <placeholder-3/>\n"
"END LOOP <optional> <placeholder-4/> </optional>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2307(para)
msgid ""
"The <literal>WHILE</literal> statement repeats a sequence of statements so "
"long as the <replaceable>boolean-expression</replaceable> evaluates to true. "
"The expression is checked just before each entry to the loop body."
msgstr ""
"<literal>WHILE</literal> выполняет серию команд до тех пор, пока истинно "
"<replaceable>логическое-выражение</replaceable>. Выражение проверяется "
"непосредственно перед каждым входом в тело цикла."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2317(programlisting)
#, no-wrap
msgid ""
"WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP\n"
"    -- some computations here\n"
"END LOOP;\n"
"\n"
"WHILE NOT done LOOP\n"
"    -- some computations here\n"
"END LOOP;"
msgstr ""
"WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP\n"
"    -- здесь вычисления\n"
"END LOOP;\n"
"\n"
"WHILE NOT done LOOP\n"
"    -- здесь вычисления\n"
"END LOOP;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2315(para)
msgid "For example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2330(title)
msgid "<literal>FOR</literal> (Integer Variant)"
msgstr "<literal>FOR</literal> (целочисленный вариант)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2334(optional)
msgid "REVERSE"
msgstr "REVERSE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2334(optional)
msgid "BY <placeholder-1/>"
msgstr "BY <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2332(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/>\n"
"FOR <placeholder-2/> IN <placeholder-3/> <placeholder-4/> .. <placeholder-5/> <placeholder-6/> LOOP\n"
"    <placeholder-7/>\n"
"END LOOP <optional> <placeholder-8/> </optional>;"
msgstr ""
"<placeholder-1/>\n"
"FOR <placeholder-2/> IN <placeholder-3/> <placeholder-4/> .. <placeholder-5/> <placeholder-6/> LOOP\n"
"    <placeholder-7/>\n"
"END LOOP <optional> <placeholder-8/> </optional>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2339(para)
msgid ""
"This form of <literal>FOR</literal> creates a loop that iterates over a "
"range of integer values. The variable <replaceable>name</replaceable> is "
"automatically defined as type <type>integer</type> and exists only inside "
"the loop (any existing definition of the variable name is ignored within the "
"loop). The two expressions giving the lower and upper bound of the range are "
"evaluated once when entering the loop. If the <literal>BY</literal> clause "
"isn't specified the iteration step is 1, otherwise it's the value specified "
"in the <literal>BY</literal> clause, which again is evaluated once on loop "
"entry. If <literal>REVERSE</literal> is specified then the step value is "
"subtracted, rather than added, after each iteration."
msgstr ""
"В этой форме цикла <literal>FOR</literal> итерации выполняются по диапазону "
"целых чисел. Переменная <replaceable>имя</replaceable> автоматически "
"определяется с типом <type>integer</type> и существует только внутри цикла "
"(если уже существует переменная с таким именем, то внутри цикла она будет "
"игнорироваться). Выражения для нижней и верхней границы диапазона чисел "
"вычисляются один раз при входе в цикл. Если не указано <literal>BY</"
"literal>, то шаг итерации 1, в противном случае используется значение в "
"<literal>BY</literal>, которое вычисляется, опять же, один раз при входе в "
"цикл. Если указано <literal>REVERSE</literal>, то после каждой итерации "
"величина шага вычитается, а не добавляется."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2356(programlisting)
#, no-wrap
msgid ""
"FOR i IN 1..10 LOOP\n"
"    -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop\n"
"END LOOP;\n"
"\n"
"FOR i IN REVERSE 10..1 LOOP\n"
"    -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop\n"
"END LOOP;\n"
"\n"
"FOR i IN REVERSE 10..1 BY 2 LOOP\n"
"    -- i will take on the values 10,8,6,4,2 within the loop\n"
"END LOOP;"
msgstr ""
"FOR i IN 1..10 LOOP\n"
"    -- внутри цикла переменная i будет иметь значения 1,2,3,4,5,6,7,8,9,10\n"
"END LOOP;\n"
"\n"
"FOR i IN REVERSE 10..1 LOOP\n"
"    -- внутри цикла переменная i будет иметь значения 10,9,8,7,6,5,4,3,2,1\n"
"END LOOP;\n"
"\n"
"FOR i IN REVERSE 10..1 BY 2 LOOP\n"
"    -- внутри цикла переменная i будет иметь значения 10,8,6,4,2\n"
"END LOOP;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2354(para)
msgid "Some examples of integer <literal>FOR</literal> loops: <placeholder-1/>"
msgstr "Примеры целочисленного <literal>FOR</literal>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2371(para)
msgid ""
"If the lower bound is greater than the upper bound (or less than, in the "
"<literal>REVERSE</literal> case), the loop body is not executed at all. No "
"error is raised."
msgstr ""
"Если нижняя граница цикла больше верхней границы (или меньше, в случае "
"<literal>REVERSE</literal>), то тело цикла не выполняется вообще. При этом "
"ошибка не возникает."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2377(para)
msgid ""
"If a <replaceable>label</replaceable> is attached to the <literal>FOR</"
"literal> loop then the integer loop variable can be referenced with a "
"qualified name, using that <replaceable>label</replaceable>."
msgstr ""
"Если с циклом <literal>FOR</literal> связана <replaceable>метка</"
"replaceable>, к целочисленной переменной цикла можно обращаться по имени, "
"указывая эту <replaceable>метку</replaceable>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2387(title)
msgid "Looping Through Query Results"
msgstr "Цикл по результатам запроса"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2404(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$\n"
"DECLARE\n"
"    mviews RECORD;\n"
"BEGIN\n"
"    RAISE NOTICE 'Refreshing materialized views...';\n"
"\n"
"    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP\n"
"\n"
"        -- Now \"mviews\" has one record from cs_materialized_views\n"
"\n"
"        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);\n"
"        EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);\n"
"        EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);\n"
"    END LOOP;\n"
"\n"
"    RAISE NOTICE 'Done refreshing materialized views.';\n"
"    RETURN 1;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$\n"
"DECLARE\n"
"    mviews RECORD;\n"
"BEGIN\n"
"    RAISE NOTICE 'Refreshing materialized views...';\n"
"\n"
"    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP\n"
"\n"
"        -- Здесь \"mviews\" содержит одну запись из cs_materialized_views\n"
"\n"
"        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);\n"
"        EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);\n"
"        EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);\n"
"    END LOOP;\n"
"\n"
"    RAISE NOTICE 'Done refreshing materialized views.';\n"
"    RETURN 1;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2389(para)
msgid ""
"Using a different type of <literal>FOR</literal> loop, you can iterate "
"through the results of a query and manipulate that data accordingly. The "
"syntax is: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n"
"FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> "
"LOOP\n"
"    <replaceable>statements</replaceable>\n"
"END LOOP <optional> <replaceable>label</replaceable> </optional>;\n"
"</synopsis> The <replaceable>target</replaceable> is a record variable, row "
"variable, or comma-separated list of scalar variables. The "
"<replaceable>target</replaceable> is successively assigned each row "
"resulting from the <replaceable>query</replaceable> and the loop body is "
"executed for each row. Here is an example: <placeholder-1/> If the loop is "
"terminated by an <literal>EXIT</literal> statement, the last assigned row "
"value is still accessible after the loop."
msgstr ""
"Другой вариант <literal>FOR</literal> позволяет организовать цикл по "
"результатам запроса. Синтаксис: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>\n"
"FOR <replaceable>цель</replaceable> IN <replaceable>запрос</replaceable> "
"LOOP\n"
"    <replaceable>операторы</replaceable>\n"
"END LOOP <optional> <replaceable>метка</replaceable> </optional>;\n"
"</synopsis> Переменная <replaceable>цель</replaceable> может быть строковой "
"переменной, переменной типа <type>record</type> или разделённым запятыми "
"списком скалярных переменных. Переменной <replaceable>цель</replaceable> "
"последовательно присваиваются строки результата запроса, и для каждой строки "
"выполняется тело цикла. Пример: <placeholder-1/> Если цикл завершается по "
"команде <literal>EXIT</literal>, то последняя присвоенная строка доступна и "
"после цикла."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2430(para)
msgid ""
"The <replaceable>query</replaceable> used in this type of <literal>FOR</"
"literal> statement can be any SQL command that returns rows to the caller: "
"<command>SELECT</command> is the most common case, but you can also use "
"<command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</"
"command> with a <literal>RETURNING</literal> clause. Some utility commands "
"such as <command>EXPLAIN</command> will work too."
msgstr ""
"В качестве <replaceable>запроса</replaceable> в этом типе оператора "
"<literal>FOR</literal> может задаваться любая команда SQL, возвращающая "
"строки. Чаще всего это <command>SELECT</command>, но также можно "
"использовать и <command>INSERT</command>, <command>UPDATE</command> или "
"<command>DELETE</command> с предложением <literal>RETURNING</literal>. Кроме "
"того, возможно применение и некоторых служебных команд, например "
"<command>EXPLAIN</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2439(para)
msgid ""
"<application>PL/pgSQL</application> variables are substituted into the query "
"text, and the query plan is cached for possible re-use, as discussed in "
"detail in <xref linkend=\"plpgsql-var-subst\"/> and <xref linkend=\"plpgsql-"
"plan-caching\"/>."
msgstr ""
"Для переменных <application>PL/pgSQL</application> в тексте запроса "
"выполняется подстановка значений, план запроса кешируется для возможного "
"повторного использования, как подробно описано в <xref remap=\"6\" linkend="
"\"plpgsql-var-subst\"/> и <xref remap=\"6\" linkend=\"plpgsql-plan-caching\"/"
">."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2446(para)
msgid ""
"The <literal>FOR-IN-EXECUTE</literal> statement is another way to iterate "
"over rows: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n"
"FOR <replaceable>target</replaceable> IN EXECUTE "
"<replaceable>text_expression</replaceable> <optional> USING "
"<replaceable>expression</replaceable> <optional>, ... </optional> </"
"optional> LOOP\n"
"    <replaceable>statements</replaceable>\n"
"END LOOP <optional> <replaceable>label</replaceable> </optional>;\n"
"</synopsis> This is like the previous form, except that the source query is "
"specified as a string expression, which is evaluated and replanned on each "
"entry to the <literal>FOR</literal> loop. This allows the programmer to "
"choose the speed of a preplanned query or the flexibility of a dynamic "
"query, just as with a plain <command>EXECUTE</command> statement. As with "
"<command>EXECUTE</command>, parameter values can be inserted into the "
"dynamic command via <literal>USING</literal>."
msgstr ""
"Ещё одна разновидность этого типа цикла <literal>FOR-IN-EXECUTE</literal>: "
"<synopsis>\n"
"<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>\n"
"FOR <replaceable>цель</replaceable> IN EXECUTE "
"<replaceable>выражение_проверки</replaceable> <optional> USING "
"<replaceable>выражение</replaceable> <optional>, ... </optional> </optional> "
"LOOP\n"
"    <replaceable>операторы</replaceable>\n"
"END LOOP <optional> <replaceable>метка</replaceable> </optional>;\n"
"</synopsis> Она похожа на предыдущую форму, за исключением того, что текст "
"запроса указывается в виде строкового выражения. Текст запроса формируется и "
"для него строится план выполнения при каждом входе в цикл. Это даёт "
"программисту выбор между скоростью предварительно разобранного запроса и "
"гибкостью динамического запроса, так же, как и в случае с обычным оператором "
"<command>EXECUTE</command>. Как и в <command>EXECUTE</command>, значения "
"параметров могут быть добавлены в команду с использованием <literal>USING</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2464(para)
msgid ""
"Another way to specify the query whose results should be iterated through is "
"to declare it as a cursor. This is described in <xref linkend=\"plpgsql-"
"cursor-for-loop\"/>."
msgstr ""
"Ещё один способ организовать цикл по результатам запроса это объявить "
"курсор. Описание в <xref remap=\"6\" linkend=\"plpgsql-cursor-for-loop\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2472(title)
msgid "Looping Through Arrays"
msgstr "Цикл по элементам массива"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2474(para)
msgid ""
"The <literal>FOREACH</literal> loop is much like a <literal>FOR</literal> "
"loop, but instead of iterating through the rows returned by a SQL query, it "
"iterates through the elements of an array value. (In general, "
"<literal>FOREACH</literal> is meant for looping through components of a "
"composite-valued expression; variants for looping through composites besides "
"arrays may be added in future.) The <literal>FOREACH</literal> statement to "
"loop over an array is: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n"
"FOREACH <replaceable>target</replaceable> <optional> SLICE "
"<replaceable>number</replaceable> </optional> IN ARRAY "
"<replaceable>expression</replaceable> LOOP\n"
"    <replaceable>statements</replaceable>\n"
"END LOOP <optional> <replaceable>label</replaceable> </optional>;\n"
"</synopsis>"
msgstr ""
"Цикл <literal>FOREACH</literal> очень похож на <literal>FOR</literal>. "
"Отличие в том, что вместо перебора строк SQL-запроса происходит перебор "
"элементов массива. (В целом, <literal>FOREACH</literal> предназначен для "
"перебора выражений составного типа. Варианты реализации цикла для работы с "
"прочими составными выражениями помимо массивов могут быть добавлены в "
"будущем.) Синтаксис цикла <literal>FOREACH</literal>: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>\n"
"FOREACH <replaceable>цель</replaceable> <optional> SLICE <replaceable>число</"
"replaceable> </optional> IN ARRAY <replaceable>выражение</replaceable> LOOP\n"
"    <replaceable>операторы</replaceable>\n"
"END LOOP <optional> <replaceable>метка</replaceable> </optional>;\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2500(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION sum(int[]) RETURNS int8 AS $$\n"
"DECLARE\n"
"  s int8 := 0;\n"
"  x int;\n"
"BEGIN\n"
"  FOREACH x IN ARRAY $1\n"
"  LOOP\n"
"    s := s + x;\n"
"  END LOOP;\n"
"  RETURN s;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION sum(int[]) RETURNS int8 AS $$\n"
"DECLARE\n"
"  s int8 := 0;\n"
"  x int;\n"
"BEGIN\n"
"  FOREACH x IN ARRAY $1\n"
"  LOOP\n"
"    s := s + x;\n"
"  END LOOP;\n"
"  RETURN s;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2491(para)
msgid ""
"Without <literal>SLICE</literal>, or if <literal>SLICE 0</literal> is "
"specified, the loop iterates through individual elements of the array "
"produced by evaluating the <replaceable>expression</replaceable>. The "
"<replaceable>target</replaceable> variable is assigned each element value in "
"sequence, and the loop body is executed for each element. Here is an example "
"of looping through the elements of an integer array: <placeholder-1/> The "
"elements are visited in storage order, regardless of the number of array "
"dimensions. Although the <replaceable>target</replaceable> is usually just a "
"single variable, it can be a list of variables when looping through an array "
"of composite values (records). In that case, for each array element, the "
"variables are assigned from successive columns of the composite value."
msgstr ""
"Без указания <literal>SLICE</literal>, или если <literal>SLICE</literal> "
"равен 0, цикл выполняется по всем элементам массива, полученного из "
"<replaceable>выражения</replaceable>. Переменной <replaceable>цель</"
"replaceable> последовательно присваивается каждый элемент массива и для него "
"выполняется тело цикла. Пример цикла по элементам целочисленного массива: "
"<placeholder-1/> Обход элементов проводится в том порядке, в котором они "
"сохранялись, независимо от размерности массива. Как правило, "
"<replaceable>цель</replaceable> это одиночная переменная, но может быть и "
"списком переменных, когда элементы массива имеют составной тип (записи). В "
"этом случае переменным присваиваются значения из последовательных столбцов "
"составного элемента массива."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2533(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$\n"
"DECLARE\n"
"  x int[];\n"
"BEGIN\n"
"  FOREACH x SLICE 1 IN ARRAY $1\n"
"  LOOP\n"
"    RAISE NOTICE 'row = %', x;\n"
"  END LOOP;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);\n"
"\n"
"NOTICE:  row = {1,2,3}\n"
"NOTICE:  row = {4,5,6}\n"
"NOTICE:  row = {7,8,9}\n"
"NOTICE:  row = {10,11,12}"
msgstr ""
"CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$\n"
"DECLARE\n"
"  x int[];\n"
"BEGIN\n"
"  FOREACH x SLICE 1 IN ARRAY $1\n"
"  LOOP\n"
"    RAISE NOTICE 'row = %', x;\n"
"  END LOOP;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);\n"
"\n"
"NOTICE:  row = {1,2,3}\n"
"NOTICE:  row = {4,5,6}\n"
"NOTICE:  row = {7,8,9}\n"
"NOTICE:  row = {10,11,12}"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2523(para)
msgid ""
"With a positive <literal>SLICE</literal> value, <literal>FOREACH</literal> "
"iterates through slices of the array rather than single elements. The "
"<literal>SLICE</literal> value must be an integer constant not larger than "
"the number of dimensions of the array. The <replaceable>target</replaceable> "
"variable must be an array, and it receives successive slices of the array "
"value, where each slice is of the number of dimensions specified by "
"<literal>SLICE</literal>. Here is an example of iterating through one-"
"dimensional slices: <placeholder-1/>"
msgstr ""
"При положительном значении <literal>SLICE</literal> <literal>FOREACH</"
"literal> выполняет итерации по срезам массива, а не по отдельным элементам. "
"Значение <literal>SLICE</literal> должно быть целым числом, не превышающим "
"размерности массива. Переменная <replaceable>цель</replaceable> должна быть "
"массивом, который получает последовательные срезы исходного массива, где "
"размерность каждого среза задаётся значением <literal>SLICE</literal>. "
"Пример цикла по одномерным срезам: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2556(title)
msgid "Trapping Errors"
msgstr "Обработка ошибок"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2558(indexterm)
msgid "<primary>exceptions</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>исключения</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2563(para)
msgid ""
"By default, any error occurring in a <application>PL/pgSQL</application> "
"function aborts execution of the function, and indeed of the surrounding "
"transaction as well. You can trap errors and recover from them by using a "
"<command>BEGIN</command> block with an <literal>EXCEPTION</literal> clause. "
"The syntax is an extension of the normal syntax for a <command>BEGIN</"
"command> block: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n"
"<optional> DECLARE\n"
"    <replaceable>declarations</replaceable> </optional>\n"
"BEGIN\n"
"    <replaceable>statements</replaceable>\n"
"EXCEPTION\n"
"    WHEN <replaceable>condition</replaceable> <optional> OR "
"<replaceable>condition</replaceable> ... </optional> THEN\n"
"        <replaceable>handler_statements</replaceable>\n"
"    <optional> WHEN <replaceable>condition</replaceable> <optional> OR "
"<replaceable>condition</replaceable> ... </optional> THEN\n"
"          <replaceable>handler_statements</replaceable>\n"
"      ... </optional>\n"
"END;\n"
"</synopsis>"
msgstr ""
"По умолчанию любая возникающая ошибка прерывает выполнение функции на "
"<application>PL/pgSQL</application>, а также транзакцию, относящуюся к этой "
"функции. Использование в блоке секции <literal>EXCEPTION</literal> позволяет "
"перехватывать и обрабатывать ошибки. Синтаксис секции <literal>EXCEPTION</"
"literal> расширяет синтаксис обычного блока: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>\n"
"<optional> DECLARE\n"
"    <replaceable>объявления</replaceable> </optional>\n"
"BEGIN\n"
"    <replaceable>операторы</replaceable>\n"
"EXCEPTION\n"
"    WHEN <replaceable>условие</replaceable> <optional> OR "
"<replaceable>условие</replaceable> ... </optional> THEN\n"
"        <replaceable>операторы_обработчика</replaceable>\n"
"    <optional> WHEN <replaceable>условие</replaceable> <optional> OR "
"<replaceable>условие</replaceable> ... </optional> THEN\n"
"          <replaceable>операторы_обработчика</replaceable>\n"
"      ... </optional>\n"
"END;\n"
"</synopsis>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2587(para)
msgid ""
"If no error occurs, this form of block simply executes all the "
"<replaceable>statements</replaceable>, and then control passes to the next "
"statement after <literal>END</literal>. But if an error occurs within the "
"<replaceable>statements</replaceable>, further processing of the "
"<replaceable>statements</replaceable> is abandoned, and control passes to "
"the <literal>EXCEPTION</literal> list. The list is searched for the first "
"<replaceable>condition</replaceable> matching the error that occurred. If a "
"match is found, the corresponding <replaceable>handler_statements</"
"replaceable> are executed, and then control passes to the next statement "
"after <literal>END</literal>. If no match is found, the error propagates out "
"as though the <literal>EXCEPTION</literal> clause were not there at all: the "
"error can be caught by an enclosing block with <literal>EXCEPTION</literal>, "
"or if there is none it aborts processing of the function."
msgstr ""
"Если ошибок не было, то выполняются все <replaceable>операторы</replaceable> "
"блока и управление переходит к следующему оператору после <literal>END</"
"literal>. Но если при выполнении <replaceable>оператора</replaceable> "
"происходит ошибка, то дальнейшая обработка прекращается и управление "
"переходит к списку исключений в секции <literal>EXCEPTION</literal>. В этом "
"списке ищется первое исключение, условие которого соответствует ошибке. Если "
"исключение найдено, то выполняются соответствующие "
"<replaceable>операторы_обработчика</replaceable> и управление переходит к "
"следующему оператору после <literal>END</literal>. Если исключение не "
"найдено, то ошибка передаётся наружу, как будто секции <literal>EXCEPTION</"
"literal> не было. При этом ошибку можно перехватить в секции "
"<literal>EXCEPTION</literal> внешнего блока. Если ошибка так и не была "
"перехвачена, то обработка функции прекращается."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2615(programlisting)
#, no-wrap
msgid ""
"WHEN division_by_zero THEN ...\n"
"WHEN SQLSTATE '22012' THEN ..."
msgstr ""
"WHEN division_by_zero THEN ...\n"
"WHEN SQLSTATE '22012' THEN ..."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2605(para)
msgid ""
"The <replaceable>condition</replaceable> names can be any of those shown in "
"<xref linkend=\"errcodes-appendix\"/>. A category name matches any error "
"within its category. The special condition name <literal>OTHERS</literal> "
"matches every error type except <literal>QUERY_CANCELED</literal> and "
"<literal>ASSERT_FAILURE</literal>. (It is possible, but often unwise, to "
"trap those two error types by name.) Condition names are not case-sensitive. "
"Also, an error condition can be specified by <literal>SQLSTATE</literal> "
"code; for example these are equivalent: <placeholder-1/>"
msgstr ""
"В качестве <replaceable>условия</replaceable> может задаваться одно из имён, "
"перечисленных в <xref remap=\"6\" linkend=\"errcodes-appendix\"/>. Если "
"задаётся имя категории, ему соответствуют все ошибки в данной категории. "
"Специальному имени условия <literal>OTHERS</literal> (другие) соответствуют "
"все типы ошибок, кроме <literal>QUERY_CANCELED</literal> и "
"<literal>ASSERT_FAILURE</literal>. (И эти два типа ошибок можно перехватить "
"по имени, но часто это неразумно.) Имена условий воспринимаются без учёта "
"регистра. Условие ошибки также можно задать кодом <literal>SQLSTATE</"
"literal>; например, эти два варианта равнозначны: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2621(para)
msgid ""
"If a new error occurs within the selected <replaceable>handler_statements</"
"replaceable>, it cannot be caught by this <literal>EXCEPTION</literal> "
"clause, but is propagated out. A surrounding <literal>EXCEPTION</literal> "
"clause could catch it."
msgstr ""
"Если при выполнении <replaceable>операторов_обработчика</replaceable> "
"возникнет новая ошибка, то она не может быть перехвачена в этой секции "
"<literal>EXCEPTION</literal>. Ошибка передаётся наружу и её можно "
"перехватить в секции <literal>EXCEPTION</literal> внешнего блока."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2635(programlisting)
#, no-wrap
msgid ""
"INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');\n"
"BEGIN\n"
"    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';\n"
"    x := x + 1;\n"
"    y := x / 0;\n"
"EXCEPTION\n"
"    WHEN division_by_zero THEN\n"
"        RAISE NOTICE 'caught division_by_zero';\n"
"        RETURN x;\n"
"END;"
msgstr ""
"INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');\n"
"BEGIN\n"
"    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';\n"
"    x := x + 1;\n"
"    y := x / 0;\n"
"EXCEPTION\n"
"    WHEN division_by_zero THEN\n"
"        RAISE NOTICE 'перехватили ошибку division_by_zero';\n"
"        RETURN x;\n"
"END;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2628(para)
msgid ""
"When an error is caught by an <literal>EXCEPTION</literal> clause, the local "
"variables of the <application>PL/pgSQL</application> function remain as they "
"were when the error occurred, but all changes to persistent database state "
"within the block are rolled back. As an example, consider this fragment: "
"<placeholder-1/> When control reaches the assignment to <literal>y</"
"literal>, it will fail with a <literal>division_by_zero</literal> error. "
"This will be caught by the <literal>EXCEPTION</literal> clause. The value "
"returned in the <command>RETURN</command> statement will be the incremented "
"value of <literal>x</literal>, but the effects of the <command>UPDATE</"
"command> command will have been rolled back. The <command>INSERT</command> "
"command preceding the block is not rolled back, however, so the end result "
"is that the database contains <literal>Tom Jones</literal> not <literal>Joe "
"Jones</literal>."
msgstr ""
"При выполнении команд в секции <literal>EXCEPTION</literal> локальные "
"переменные функции на <application>PL/pgSQL</application> сохраняют те "
"значения, которые были на момент возникновения ошибки. Однако, будут "
"отменены все изменения в базе данных, выполненные в блоке. В качестве "
"примера рассмотрим следующий фрагмент: <placeholder-1/> При присвоении "
"значения переменной <literal>y</literal> произойдёт ошибка "
"<literal>division_by_zero</literal>. Она будет перехвачена в секции "
"<literal>EXCEPTION</literal>. Оператор <command>RETURN</command> вернёт "
"значение <literal>x</literal>, увеличенное на единицу, но изменения "
"сделанные командой <command>UPDATE</command> будут отменены. Изменения, "
"выполненные командой <command>INSERT</command>, которая предшествует блоку, "
"не будут отменены. В результате, база данных будет содержать <literal>Tom "
"Jones</literal>, а не <literal>Joe Jones</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2659(para)
msgid ""
"A block containing an <literal>EXCEPTION</literal> clause is significantly "
"more expensive to enter and exit than a block without one. Therefore, don't "
"use <literal>EXCEPTION</literal> without need."
msgstr ""
"Наличие секции <literal>EXCEPTION</literal> значительно увеличивает "
"накладные расходы на вход/выход из блока. Поэтому не используйте "
"<literal>EXCEPTION</literal> без надобности."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2667(title)
msgid "Exceptions with <command>UPDATE</command>/<command>INSERT</command>"
msgstr ""
"Обработка исключений для команд <command>UPDATE</command>/<command>INSERT</"
"command>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2677(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE db (a INT PRIMARY KEY, b TEXT);\n"
"\n"
"CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS\n"
"$$\n"
"BEGIN\n"
"    LOOP\n"
"        -- first try to update the key\n"
"        UPDATE db SET b = data WHERE a = key;\n"
"        IF found THEN\n"
"            RETURN;\n"
"        END IF;\n"
"        -- not there, so try to insert the key\n"
"        -- if someone else inserts the same key concurrently,\n"
"        -- we could get a unique-key failure\n"
"        BEGIN\n"
"            INSERT INTO db(a,b) VALUES (key, data);\n"
"            RETURN;\n"
"        EXCEPTION WHEN unique_violation THEN\n"
"            -- Do nothing, and loop to try the UPDATE again.\n"
"        END;\n"
"    END LOOP;\n"
"END;\n"
"$$\n"
"LANGUAGE plpgsql;\n"
"\n"
"SELECT merge_db(1, 'david');\n"
"SELECT merge_db(1, 'dennis');"
msgstr ""
"CREATE TABLE db (a INT PRIMARY KEY, b TEXT);\n"
"\n"
"CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS\n"
"$$\n"
"BEGIN\n"
"    LOOP\n"
"        -- для начала UPDATE записи по значению ключа\n"
"        UPDATE db SET b = data WHERE a = key;\n"
"        IF found THEN\n"
"            RETURN;\n"
"        END IF;\n"
"        -- записи с таким ключом нет, поэтому попытаемся её вставить\n"
"        -- если параллельно с нами кто-то ещё пытается вставить запись с таким же ключом,\n"
"        -- то мы получим ошибку уникальности\n"
"        BEGIN\n"
"            INSERT INTO db(a,b) VALUES (key, data);\n"
"            RETURN;\n"
"        EXCEPTION WHEN unique_violation THEN\n"
"            -- Здесь ничего не делаем,\n"
"            -- продолжаем цикл, чтобы повторить UPDATE.\n"
"        END;\n"
"    END LOOP;\n"
"END;\n"
"$$\n"
"LANGUAGE plpgsql;\n"
"\n"
"SELECT merge_db(1, 'david');\n"
"SELECT merge_db(1, 'dennis');"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2668(para)
msgid ""
"This example uses exception handling to perform either <command>UPDATE</"
"command> or <command>INSERT</command>, as appropriate. It is recommended "
"that applications use <command>INSERT</command> with <literal>ON CONFLICT DO "
"UPDATE</literal> rather than actually using this pattern. This example "
"serves primarily to illustrate use of <application>PL/pgSQL</application> "
"control flow structures: <placeholder-1/> This coding assumes the "
"<literal>unique_violation</literal> error is caused by the <command>INSERT</"
"command>, and not by, say, an <command>INSERT</command> in a trigger "
"function on the table. It might also misbehave if there is more than one "
"unique index on the table, since it will retry the operation regardless of "
"which index caused the error. More safety could be had by using the features "
"discussed next to check that the trapped error was the one expected."
msgstr ""
"В этом примере обработка исключений помогает выполнить либо команду "
"<command>UPDATE</command>, либо <command>INSERT</command>, в зависимости от "
"ситуации. Однако в современных приложениях вместо этого приёма рекомендуется "
"использовать <command>INSERT</command> с <literal>ON CONFLICT DO UPDATE</"
"literal>. Данный пример предназначен в первую очередь для демонстрации "
"управления выполнением <application>PL/pgSQL</application>: <placeholder-1/> "
"В этом коде предполагается, что ошибка <literal>unique_violation</literal> "
"вызывается самой командой <command>INSERT</command>, а не, скажем, "
"внутренним оператором <command>INSERT</command> в функции триггера для этой "
"таблицы. Некорректное поведение также возможно, если в таблице будет "
"несколько уникальных индексов; тогда операция будет повторяться вне "
"зависимости от того, нарушение какого индекса вызвало ошибку. Используя "
"средства, рассмотренные далее, можно сделать код более надёжным, проверяя, "
"что перехвачена именно ожидаемая ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2719(title)
msgid "Obtaining Information About an Error"
msgstr "Получение информации об ошибке"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2721(para)
msgid ""
"Exception handlers frequently need to identify the specific error that "
"occurred. There are two ways to get information about the current exception "
"in <application>PL/pgSQL</application>: special variables and the "
"<command>GET STACKED DIAGNOSTICS</command> command."
msgstr ""
"При обработке исключений часто бывает необходимым получить детальную "
"информацию о произошедшей ошибке. Для этого в <application>PL/pgSQL</"
"application> есть два способа: использование специальных переменных и "
"команда <command>GET STACKED DIAGNOSTICS</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2728(para)
msgid ""
"Within an exception handler, the special variable <varname>SQLSTATE</"
"varname> contains the error code that corresponds to the exception that was "
"raised (refer to <xref linkend=\"errcodes-table\"/> for a list of possible "
"error codes). The special variable <varname>SQLERRM</varname> contains the "
"error message associated with the exception. These variables are undefined "
"outside exception handlers."
msgstr ""
"Внутри секции <literal>EXCEPTION</literal> специальная переменная "
"<varname>SQLSTATE</varname> содержит код ошибки, для которой было вызвано "
"исключение (список возможных кодов ошибок приведён в <xref remap=\"6\" "
"linkend=\"errcodes-table\"/>). Специальная переменная <varname>SQLERRM</"
"varname> содержит сообщение об ошибке, связанное с исключением. Эти "
"переменные являются неопределёнными вне секции <literal>EXCEPTION</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2737(para)
msgid ""
"Within an exception handler, one may also retrieve information about the "
"current exception by using the <command>GET STACKED DIAGNOSTICS</command> "
"command, which has the form: <synopsis>\n"
"GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } "
"<replaceable>item</replaceable> <optional> , ... </optional>;\n"
"</synopsis> Each <replaceable>item</replaceable> is a key word identifying a "
"status value to be assigned to the specified <replaceable>variable</"
"replaceable> (which should be of the right data type to receive it). The "
"currently available status items are shown in <xref linkend=\"plpgsql-"
"exception-diagnostics-values\"/>."
msgstr ""
"Также в обработчике исключения можно получить информацию о текущем "
"исключении командой <command>GET STACKED DIAGNOSTICS</command>, которая "
"имеет вид: <synopsis>\n"
"GET STACKED DIAGNOSTICS <replaceable>переменная</replaceable> { = | := } "
"<replaceable>элемент</replaceable> <optional> , ... </optional>;\n"
"</synopsis> Каждый <replaceable>элемент</replaceable> представляется "
"ключевым словом, указывающим, какое значение состояния нужно присвоить "
"заданной <replaceable>переменной</replaceable> (она должна иметь подходящий "
"тип данных, чтобы принять его). Доступные в настоящее время элементы "
"состояния показаны в <xref remap=\"6\" linkend=\"plpgsql-exception-"
"diagnostics-values\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2754(title)
msgid "Error Diagnostics Items"
msgstr "Элементы диагностики ошибок"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2765(literal)
msgid "RETURNED_SQLSTATE"
msgstr "RETURNED_SQLSTATE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2767(entry)
msgid "the SQLSTATE error code of the exception"
msgstr "код исключения, возвращаемый SQLSTATE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2770(literal)
msgid "COLUMN_NAME"
msgstr "COLUMN_NAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2772(entry)
msgid "the name of the column related to exception"
msgstr "имя столбца, относящегося к исключению"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2775(literal)
msgid "CONSTRAINT_NAME"
msgstr "CONSTRAINT_NAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2777(entry)
msgid "the name of the constraint related to exception"
msgstr "имя ограничения целостности, относящегося к исключению"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2780(literal)
msgid "PG_DATATYPE_NAME"
msgstr "PG_DATATYPE_NAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2782(entry)
msgid "the name of the data type related to exception"
msgstr "имя типа данных, относящегося к исключению"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2785(literal)
msgid "MESSAGE_TEXT"
msgstr "MESSAGE_TEXT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2787(entry)
msgid "the text of the exception's primary message"
msgstr "текст основного сообщения исключения"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2790(literal)
msgid "TABLE_NAME"
msgstr "TABLE_NAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2792(entry)
msgid "the name of the table related to exception"
msgstr "имя таблицы, относящейся к исключению"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2795(literal)
msgid "SCHEMA_NAME"
msgstr "SCHEMA_NAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2797(entry)
msgid "the name of the schema related to exception"
msgstr "имя схемы, относящейся к исключению"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2800(literal)
msgid "PG_EXCEPTION_DETAIL"
msgstr "PG_EXCEPTION_DETAIL"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2802(entry)
msgid "the text of the exception's detail message, if any"
msgstr "текст детального сообщения исключения (если есть)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2805(literal)
msgid "PG_EXCEPTION_HINT"
msgstr "PG_EXCEPTION_HINT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2807(entry)
msgid "the text of the exception's hint message, if any"
msgstr "текст подсказки к исключению (если есть)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2810(literal)
msgid "PG_EXCEPTION_CONTEXT"
msgstr "PG_EXCEPTION_CONTEXT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2812(entry)
msgid ""
"line(s) of text describing the call stack at the time of the exception (see "
"<xref linkend=\"plpgsql-call-stack\"/>)"
msgstr ""
"строки текста, описывающие стек вызовов в момент исключения (см. <xref remap="
"\"4\" linkend=\"plpgsql-call-stack\"/>)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2819(para)
msgid ""
"If the exception did not set a value for an item, an empty string will be "
"returned."
msgstr ""
"Если исключение не устанавливает значение для идентификатора, то "
"возвращается пустая строка."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2826(programlisting)
#, no-wrap
msgid ""
"DECLARE\n"
"  text_var1 text;\n"
"  text_var2 text;\n"
"  text_var3 text;\n"
"BEGIN\n"
"  -- some processing which might cause an exception\n"
"  ...\n"
"EXCEPTION WHEN OTHERS THEN\n"
"  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,\n"
"                          text_var2 = PG_EXCEPTION_DETAIL,\n"
"                          text_var3 = PG_EXCEPTION_HINT;\n"
"END;"
msgstr ""
"DECLARE\n"
"  text_var1 text;\n"
"  text_var2 text;\n"
"  text_var3 text;\n"
"BEGIN\n"
"  -- здесь происходит обработка, которая может вызвать исключение\n"
"  ...\n"
"EXCEPTION WHEN OTHERS THEN\n"
"  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,\n"
"                          text_var2 = PG_EXCEPTION_DETAIL,\n"
"                          text_var3 = PG_EXCEPTION_HINT;\n"
"END;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2845(title)
msgid "Obtaining Execution Location Information"
msgstr "Получение информации о месте выполнения"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2860(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$\n"
"BEGIN\n"
"  RETURN inner_func();\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$\n"
"DECLARE\n"
"  stack text;\n"
"BEGIN\n"
"  GET DIAGNOSTICS stack = PG_CONTEXT;\n"
"  RAISE NOTICE E'--- Call Stack ---\\n%', stack;\n"
"  RETURN 1;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT outer_func();\n"
"\n"
"NOTICE:  --- Call Stack ---\n"
"PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS\n"
"PL/pgSQL function outer_func() line 3 at RETURN\n"
"CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN\n"
" outer_func\n"
" ------------\n"
"           1\n"
"(1 row)"
msgstr ""
"CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$\n"
"BEGIN\n"
"  RETURN inner_func();\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$\n"
"DECLARE\n"
"  stack text;\n"
"BEGIN\n"
"  GET DIAGNOSTICS stack = PG_CONTEXT;\n"
"  RAISE NOTICE E'--- Стек вызова ---\\n%', stack;\n"
"  RETURN 1;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"SELECT outer_func();\n"
"\n"
"NOTICE:  --- Стек вызова ---\n"
"PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS\n"
"PL/pgSQL function outer_func() line 3 at RETURN\n"
"CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN\n"
" outer_func\n"
" ------------\n"
"           1\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2847(para)
msgid ""
"The <command>GET DIAGNOSTICS</command> command, previously described in "
"<xref linkend=\"plpgsql-statements-diagnostics\"/>, retrieves information "
"about current execution state (whereas the <command>GET STACKED DIAGNOSTICS</"
"command> command discussed above reports information about the execution "
"state as of a previous error). Its <literal>PG_CONTEXT</literal> status item "
"is useful for identifying the current execution location. "
"<literal>PG_CONTEXT</literal> returns a text string with line(s) of text "
"describing the call stack. The first line refers to the current function and "
"currently executing <command>GET DIAGNOSTICS</command> command. The second "
"and any subsequent lines refer to calling functions further up the call "
"stack. For example: <placeholder-1/>"
msgstr ""
"Команда <command>GET DIAGNOSTICS</command>, ранее описанная в <xref remap="
"\"6\" linkend=\"plpgsql-statements-diagnostics\"/>, получает информацию о "
"текущем состоянии выполнения кода (тогда как команда <command>GET STACKED "
"DIAGNOSTICS</command>, рассмотренная ранее, выдаёт информацию о состоянии "
"выполнения в момент предыдущей ошибки). Её элемент состояния "
"<literal>PG_CONTEXT</literal> позволяет определить текущее место выполнения "
"кода. <literal>PG_CONTEXT</literal> возвращает текст с несколькими строками, "
"описывающий стек вызова. В первой строке отмечается текущая функция и "
"выполняемая в данный момент команда <command>GET DIAGNOSTICS</command>, а во "
"второй и последующих строках отмечаются функции выше по стеку вызовов. "
"Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2891(para)
msgid ""
"<literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal> returns "
"the same sort of stack trace, but describing the location at which an error "
"was detected, rather than the current location."
msgstr ""
"<literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal> "
"возвращает похожий стек вызовов, но описывает не текущее место, а место, в "
"котором произошла ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2900(title)
msgid "Cursors"
msgstr "Курсоры"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2902(indexterm)
msgid "<primary>cursor</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>курсор</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2907(para)
msgid ""
"Rather than executing a whole query at once, it is possible to set up a "
"<firstterm>cursor</firstterm> that encapsulates the query, and then read the "
"query result a few rows at a time. One reason for doing this is to avoid "
"memory overrun when the result contains a large number of rows. (However, "
"<application>PL/pgSQL</application> users do not normally need to worry "
"about that, since <literal>FOR</literal> loops automatically use a cursor "
"internally to avoid memory problems.) A more interesting usage is to return "
"a reference to a cursor that a function has created, allowing the caller to "
"read the rows. This provides an efficient way to return large row sets from "
"functions."
msgstr ""
"Вместо того чтобы сразу выполнять весь запрос, есть возможность настроить "
"курсор, инкапсулирующий запрос, и затем получать результат запроса по "
"нескольку строк за раз. Одна из причин так делать заключается в том, чтобы "
"избежать переполнения памяти, когда результат содержит большое количество "
"строк. (Пользователям <application>PL/pgSQL</application> не нужно об этом "
"беспокоиться, так как циклы <literal>FOR</literal> автоматически используют "
"курсоры, чтобы избежать проблем с памятью.) Более интересным вариантом "
"использования является возврат из функции ссылки на курсор, что позволяет "
"вызывающему получать строки запроса. Это эффективный способ получать большие "
"наборы строк из функций."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2921(title)
msgid "Declaring Cursor Variables"
msgstr "Объявление курсорных переменных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2923(para)
msgid ""
"All access to cursors in <application>PL/pgSQL</application> goes through "
"cursor variables, which are always of the special data type <type>refcursor</"
"type>. One way to create a cursor variable is just to declare it as a "
"variable of type <type>refcursor</type>. Another way is to use the cursor "
"declaration syntax, which in general is: <synopsis>\n"
"<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL "
"</optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </"
"optional> FOR <replaceable>query</replaceable>;\n"
"</synopsis> (<literal>FOR</literal> can be replaced by <literal>IS</literal> "
"for <productname>Oracle</productname> compatibility.) If <literal>SCROLL</"
"literal> is specified, the cursor will be capable of scrolling backward; if "
"<literal>NO SCROLL</literal> is specified, backward fetches will be "
"rejected; if neither specification appears, it is query-dependent whether "
"backward fetches will be allowed. <replaceable>arguments</replaceable>, if "
"specified, is a comma-separated list of pairs <literal><replaceable>name</"
"replaceable> <replaceable>datatype</replaceable></literal> that define names "
"to be replaced by parameter values in the given query. The actual values to "
"substitute for these names will be specified later, when the cursor is "
"opened."
msgstr ""
"Доступ к курсорам в <application>PL/pgSQL</application> осуществляется через "
"курсорные переменные, которые всегда имеют специальный тип данных "
"<type>refcursor</type>. Один из способов создать курсорную переменную, "
"просто объявить её как переменную типа <type>refcursor</type>. Другой способ "
"заключается в использовании синтаксиса объявления курсора, который в общем "
"виде выглядит так: <synopsis>\n"
"<replaceable>имя</replaceable> <optional> <optional> NO </optional> SCROLL </"
"optional> CURSOR <optional> ( <replaceable>аргументы</replaceable> ) </"
"optional> FOR <replaceable>запрос</replaceable>;\n"
"</synopsis> (Для совместимости с Oracle, <literal>FOR</literal> можно "
"заменять на <literal>IS</literal>.) С указанием <literal>SCROLL</literal> "
"курсор можно будет прокручивать назад. При <literal>NO SCROLL</literal> "
"прокрутка назад не разрешается. Если ничего не указано, то возможность "
"прокрутки назад зависит от запроса. Если указаны <replaceable>аргументы</"
"replaceable>, то они должны представлять собой пары "
"<literal><replaceable>имя</replaceable> <replaceable>тип_данных</"
"replaceable></literal>, разделённые через запятую. Эти пары определяют "
"имена, которые будут заменены значениями параметров в данном запросе. "
"Фактические значения для замены этих имён появятся позже, при открытии "
"курсора."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2948(programlisting)
#, no-wrap
msgid ""
"DECLARE\n"
"    curs1 refcursor;\n"
"    curs2 CURSOR FOR SELECT * FROM tenk1;\n"
"    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;"
msgstr ""
"DECLARE\n"
"    curs1 refcursor;\n"
"    curs2 CURSOR FOR SELECT * FROM tenk1;\n"
"    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2946(para)
msgid ""
"Some examples: <placeholder-1/> All three of these variables have the data "
"type <type>refcursor</type>, but the first can be used with any query, while "
"the second has a fully specified query already <firstterm>bound</firstterm> "
"to it, and the last has a parameterized query bound to it. (<literal>key</"
"literal> will be replaced by an integer parameter value when the cursor is "
"opened.) The variable <literal>curs1</literal> is said to be "
"<firstterm>unbound</firstterm> since it is not bound to any particular query."
msgstr ""
"Примеры: <placeholder-1/> Все три переменные имеют тип данных "
"<type>refcursor</type>. Первая может быть использована с любым запросом, "
"вторая связана (<literal>bound</literal>) с полностью сформированным "
"запросом, а последняя связана с параметризованным запросом. (<literal>key</"
"literal> будет заменён целочисленным значением параметра при открытии "
"курсора.) Про переменную <literal>curs1</literal> говорят, что она является "
"несвязанной (<literal>unbound</literal>), так как к ней не привязан никакой "
"запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2966(title)
msgid "Opening Cursors"
msgstr "Открытие курсора"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2968(para)
msgid ""
"Before a cursor can be used to retrieve rows, it must be <firstterm>opened</"
"firstterm>. (This is the equivalent action to the SQL command "
"<command>DECLARE CURSOR</command>.) <application>PL/pgSQL</application> has "
"three forms of the <command>OPEN</command> statement, two of which use "
"unbound cursor variables while the third uses a bound cursor variable."
msgstr ""
"Прежде чем получать строки из курсора, его нужно открыть. (Это эквивалентно "
"действию SQL-команды <command>DECLARE CURSOR</command>.) В <application>PL/"
"pgSQL</application> есть три формы оператора <command>OPEN</command>, две из "
"которых используются для несвязанных курсорных переменных, а третья для "
"связанных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2977(para)
msgid ""
"Bound cursor variables can also be used without explicitly opening the "
"cursor, via the <command>FOR</command> statement described in <xref linkend="
"\"plpgsql-cursor-for-loop\"/>."
msgstr ""
"Связанные курсорные переменные можно использовать с циклом <command>FOR</"
"command> без явного открытия курсора, как описано в <xref remap=\"6\" "
"linkend=\"plpgsql-cursor-for-loop\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2985(command)
msgid "OPEN FOR"
msgstr "OPEN FOR"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2988(replaceable) plpgsql.xml:3022(replaceable)
msgid "unbound_cursorvar"
msgstr "несвязанная_переменная_курсора"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2988(optional) plpgsql.xml:3022(optional)
msgid "NO"
msgstr "NO"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2988(optional) plpgsql.xml:3022(optional)
msgid "<placeholder-1/> SCROLL"
msgstr "<placeholder-1/> SCROLL"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2987(synopsis)
#, no-wrap
msgid "OPEN <placeholder-1/> <placeholder-2/> FOR <placeholder-3/>;"
msgstr "OPEN <placeholder-1/> <placeholder-2/> FOR <placeholder-3/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:2991(para)
msgid ""
"The cursor variable is opened and given the specified query to execute. The "
"cursor cannot be open already, and it must have been declared as an unbound "
"cursor variable (that is, as a simple <type>refcursor</type> variable). The "
"query must be a <command>SELECT</command>, or something else that returns "
"rows (such as <command>EXPLAIN</command>). The query is treated in the same "
"way as other SQL commands in <application>PL/pgSQL</application>: "
"<application>PL/pgSQL</application> variable names are substituted, and the "
"query plan is cached for possible reuse. When a <application>PL/pgSQL</"
"application> variable is substituted into the cursor query, the value that "
"is substituted is the one it has at the time of the <command>OPEN</command>; "
"subsequent changes to the variable will not affect the cursor's behavior. "
"The <literal>SCROLL</literal> and <literal>NO SCROLL</literal> options have "
"the same meanings as for a bound cursor."
msgstr ""
"Курсорная переменная открывается и получает конкретный запрос для "
"выполнения. Курсор не может уже быть открытым, а курсорная переменная "
"обязана быть несвязанной (то есть просто переменной типа <type>refcursor</"
"type>). Запрос должен быть командой <command>SELECT</command> или любой "
"другой, которая возвращает строки (к примеру <command>EXPLAIN</command>). "
"Запрос обрабатывается так же, как и другие команды SQL в <application>PL/"
"pgSQL</application>: имена переменных <application>PL/pgSQL</application> "
"заменяются на значения, план запроса кешируется для повторного "
"использования. Подстановка значений переменных <application>PL/pgSQL</"
"application> проводится при открытии курсора командой <command>OPEN</"
"command>, последующие изменения значений переменных не влияют на работу "
"курсора. <literal>SCROLL</literal> и <literal>NO SCROLL</literal> имеют тот "
"же смысл, что и для связанного курсора."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3012(programlisting)
#, no-wrap
msgid "OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;"
msgstr "OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3019(command)
msgid "OPEN FOR EXECUTE"
msgstr "OPEN FOR EXECUTE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3022(replaceable)
msgid "query_string"
msgstr "строка_запроса"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3021(synopsis)
#, no-wrap
msgid ""
"OPEN <placeholder-1/> <placeholder-2/> FOR EXECUTE <placeholder-3/>\n"
"                                     <placeholder-4/>;"
msgstr ""
"OPEN <placeholder-1/> <placeholder-2/> FOR EXECUTE <placeholder-3/>\n"
"                                     <placeholder-4/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3026(para)
msgid ""
"The cursor variable is opened and given the specified query to execute. The "
"cursor cannot be open already, and it must have been declared as an unbound "
"cursor variable (that is, as a simple <type>refcursor</type> variable). The "
"query is specified as a string expression, in the same way as in the "
"<command>EXECUTE</command> command. As usual, this gives flexibility so the "
"query plan can vary from one run to the next (see <xref linkend=\"plpgsql-"
"plan-caching\"/>), and it also means that variable substitution is not done "
"on the command string. As with <command>EXECUTE</command>, parameter values "
"can be inserted into the dynamic command via <literal>format()</literal> and "
"<literal>USING</literal>. The <literal>SCROLL</literal> and <literal>NO "
"SCROLL</literal> options have the same meanings as for a bound cursor."
msgstr ""
"Переменная курсора открывается и получает конкретный запрос для выполнения. "
"Курсор не может быть уже открыт и он должен быть объявлен как несвязанная "
"переменная курсора (то есть, как просто переменная <type>refcursor</type>). "
"Запрос задаётся строковым выражением, так же, как в команде "
"<command>EXECUTE</command>. Как обычно, это даёт возможность гибко менять "
"план запроса от раза к разу (см. <xref remap=\"4\" linkend=\"plpgsql-plan-"
"caching\"/>). Это также означает, что замена переменных происходит не в "
"самой строке команды. Как и с <command>EXECUTE</command>, значения "
"параметров вставляются в динамическую команду, используя <literal>format()</"
"literal> и <literal>USING</literal>. Параметры <literal>SCROLL</literal> и "
"<literal>NO SCROLL</literal> здесь действуют так же, как и со связанным "
"курсором."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3045(programlisting)
#, no-wrap
msgid "OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;"
msgstr "OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3043(para)
msgid ""
"An example: <placeholder-1/> In this example, the table name is inserted "
"into the query via <function>format()</function>. The comparison value for "
"<literal>col1</literal> is inserted via a <literal>USING</literal> "
"parameter, so it needs no quoting."
msgstr ""
"Пример: <placeholder-1/> В этом примере в текст запроса вставляется имя "
"таблицы с применением <function>format()</function>. Значение, сравниваемое "
"с <literal>col1</literal>, вставляется посредством параметра <literal>USING</"
"literal>, так что заключать его в апострофы не нужно."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3056(title)
msgid "Opening a Bound Cursor"
msgstr "Открытие связанного курсора"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3059(replaceable)
msgid "bound_cursorvar"
msgstr "связанная_переменная_курсора"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3059(replaceable)
msgid "argument_name"
msgstr "имя_аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3059(optional)
msgid "<placeholder-1/> :="
msgstr "<placeholder-1/> :="

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3059(replaceable)
msgid "argument_value"
msgstr "значение_аргумента"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3059(optional)
msgid "( <placeholder-1/> <placeholder-2/> <placeholder-3/> )"
msgstr "( <placeholder-1/> <placeholder-2/> <placeholder-3/> )"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3058(synopsis)
#, no-wrap
msgid "OPEN <placeholder-1/> <placeholder-2/>;"
msgstr "OPEN <placeholder-1/> <placeholder-2/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3062(para)
msgid ""
"This form of <command>OPEN</command> is used to open a cursor variable whose "
"query was bound to it when it was declared. The cursor cannot be open "
"already. A list of actual argument value expressions must appear if and only "
"if the cursor was declared to take arguments. These values will be "
"substituted in the query."
msgstr ""
"Эта форма <command>OPEN</command> используется для открытия курсорной "
"переменной, которая была связана с запросом при объявлении. Курсор не может "
"уже быть открытым. Список фактических значений аргументов должен "
"присутствовать только в том случае, если курсор объявлялся с параметрами. "
"Эти значения будут подставлены в запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3070(para)
msgid ""
"The query plan for a bound cursor is always considered cacheable; there is "
"no equivalent of <command>EXECUTE</command> in this case. Notice that "
"<literal>SCROLL</literal> and <literal>NO SCROLL</literal> cannot be "
"specified in <command>OPEN</command>, as the cursor's scrolling behavior was "
"already determined."
msgstr ""
"План запроса для связанного курсора всегда считается кешируемым. В этом "
"случае, нет эквивалента <command>EXECUTE</command>. Обратите внимание, что "
"<literal>SCROLL</literal> и <literal>NO SCROLL</literal> не могут быть "
"указаны в этой форме <command>OPEN</command>, возможность прокрутки назад "
"была определена при объявлении курсора."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3078(para)
msgid ""
"Argument values can be passed using either <firstterm>positional</firstterm> "
"or <firstterm>named</firstterm> notation. In positional notation, all "
"arguments are specified in order. In named notation, each argument's name is "
"specified using <literal>:=</literal> to separate it from the argument "
"expression. Similar to calling functions, described in <xref linkend=\"sql-"
"syntax-calling-funcs\"/>, it is also allowed to mix positional and named "
"notation."
msgstr ""
"При передаче значений аргументов можно использовать позиционную или именную "
"нотацию. В позиционной нотации все аргументы указываются по порядку. В "
"именной нотации имя каждого аргумента отделяется от выражения аргумента с "
"помощью <literal>:=</literal>. Это подобно вызову функций, описанному в "
"<xref remap=\"6\" linkend=\"sql-syntax-calling-funcs\"/>. Также разрешается "
"смешивать позиционную и именную нотации."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3090(programlisting)
#, no-wrap
msgid ""
"OPEN curs2;\n"
"OPEN curs3(42);\n"
"OPEN curs3(key := 42);"
msgstr ""
"OPEN curs2;\n"
"OPEN curs3(42);\n"
"OPEN curs3(key := 42);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3088(para)
msgid ""
"Examples (these use the cursor declaration examples above): <placeholder-1/>"
msgstr ""
"Примеры (здесь используются ранее объявленные курсоры): <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3107(programlisting)
#, no-wrap
msgid ""
"DECLARE\n"
"    key integer;\n"
"    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;\n"
"BEGIN\n"
"    key := 42;\n"
"    OPEN curs4;"
msgstr ""
"DECLARE\n"
"    key integer;\n"
"    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;\n"
"BEGIN\n"
"    key := 42;\n"
"    OPEN curs4;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3097(para)
msgid ""
"Because variable substitution is done on a bound cursor's query, there are "
"really two ways to pass values into the cursor: either with an explicit "
"argument to <command>OPEN</command>, or implicitly by referencing a "
"<application>PL/pgSQL</application> variable in the query. However, only "
"variables declared before the bound cursor was declared will be substituted "
"into it. In either case the value to be passed is determined at the time of "
"the <command>OPEN</command>. For example, another way to get the same effect "
"as the <literal>curs3</literal> example above is <placeholder-1/>"
msgstr ""
"Так как для связанного курсора выполняется подстановка значений переменных, "
"то, на самом деле, существует два способа передать значения в курсор. Либо "
"использовать явные аргументы в <command>OPEN</command>, либо неявно, "
"ссылаясь на переменные <application>PL/pgSQL</application> в запросе. В "
"связанном курсоре можно ссылаться только на те переменные, которые были "
"объявлены до самого курсора. В любом случае, значение переменной для "
"подстановки в запрос будет определяться на момент выполнения <command>OPEN</"
"command>. Вот ещё один способ получить тот же результат с <literal>curs3</"
"literal>, как в примере выше: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3120(title)
msgid "Using Cursors"
msgstr "Использование курсоров"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3122(para)
msgid ""
"Once a cursor has been opened, it can be manipulated with the statements "
"described here."
msgstr ""
"После того, как курсор был открыт, с ним можно работать при помощи описанных "
"здесь операторов."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3127(para)
msgid ""
"These manipulations need not occur in the same function that opened the "
"cursor to begin with. You can return a <type>refcursor</type> value out of a "
"function and let the caller operate on the cursor. (Internally, a "
"<type>refcursor</type> value is simply the string name of a so-called portal "
"containing the active query for the cursor. This name can be passed around, "
"assigned to other <type>refcursor</type> variables, and so on, without "
"disturbing the portal.)"
msgstr ""
"Работать с курсором необязательно в той же функции, где он был открыт. Из "
"функции можно вернуть значение с типом <type>refcursor</type>, что позволит "
"вызывающему продолжить работу с курсором. (Внутри <type>refcursor</type> "
"представляет собой обычное строковое имя так называемого портала, "
"содержащего активный запрос курсора. Это имя можно передавать, присваивать "
"другим переменным с типом <type>refcursor</type> и так далее, при этом "
"портал не нарушается.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3137(para)
msgid ""
"All portals are implicitly closed at transaction end. Therefore a "
"<type>refcursor</type> value is usable to reference an open cursor only "
"until the end of the transaction."
msgstr ""
"Все порталы неявно закрываются в конце транзакции. Поэтому значение "
"<type>refcursor</type> можно использовать для ссылки на открытый курсор "
"только до конца транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3144(literal)
msgid "FETCH"
msgstr "FETCH"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3147(replaceable) plpgsql.xml:3200(replaceable)
msgid "direction"
msgstr "направление"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3147(optional) plpgsql.xml:3200(optional)
msgid "<placeholder-1/> { FROM | IN }"
msgstr "<placeholder-1/> { FROM | IN }"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3147(replaceable) plpgsql.xml:3200(replaceable)
#: plpgsql.xml:3247(replaceable) plpgsql.xml:3248(replaceable)
#: plpgsql.xml:3273(replaceable)
msgid "cursor"
msgstr "курсор"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3147(replaceable)
msgid "target"
msgstr "цель"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3146(synopsis)
#, no-wrap
msgid "FETCH <placeholder-1/> <placeholder-2/> INTO <placeholder-3/>;"
msgstr "FETCH <placeholder-1/> <placeholder-2/> INTO <placeholder-3/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3150(para)
msgid ""
"<command>FETCH</command> retrieves the next row from the cursor into a "
"target, which might be a row variable, a record variable, or a comma-"
"separated list of simple variables, just like <command>SELECT INTO</"
"command>. If there is no next row, the target is set to NULL(s). As with "
"<command>SELECT INTO</command>, the special variable <literal>FOUND</"
"literal> can be checked to see whether a row was obtained or not."
msgstr ""
"<command>FETCH</command> извлекает следующую строку из курсора в "
"<replaceable>цель</replaceable>. В качестве <replaceable>цели</replaceable> "
"может быть строковая переменная, переменная типа <type>record</type>, или "
"разделённый запятыми список простых переменных, как и в <command>SELECT "
"INTO</command>. Если следующей строки нет, <replaceable>цели</replaceable> "
"присваивается NULL. Как и в <command>SELECT INTO</command>, проверить, была "
"ли получена запись, можно при помощи специальной переменной <literal>FOUND</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3160(para)
msgid ""
"The <replaceable>direction</replaceable> clause can be any of the variants "
"allowed in the SQL <xref linkend=\"sql-fetch\"/> command except the ones "
"that can fetch more than one row; namely, it can be <literal>NEXT</literal>, "
"<literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, "
"<literal>ABSOLUTE</literal> <replaceable>count</replaceable>, "
"<literal>RELATIVE</literal> <replaceable>count</replaceable>, "
"<literal>FORWARD</literal>, or <literal>BACKWARD</literal>. Omitting "
"<replaceable>direction</replaceable> is the same as specifying "
"<literal>NEXT</literal>. <replaceable>direction</replaceable> values that "
"require moving backward are likely to fail unless the cursor was declared or "
"opened with the <literal>SCROLL</literal> option."
msgstr ""
"Здесь <replaceable>направление</replaceable> может быть любым допустимым в "
"SQL-команде <xref linkend=\"sql-fetch\"/> вариантом, кроме тех, что "
"извлекают более одной строки. А именно: <literal>NEXT</literal>, "
"<literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, "
"<literal>ABSOLUTE</literal> <replaceable>число</replaceable>, "
"<literal>RELATIVE</literal> <replaceable>число</replaceable>, "
"<literal>FORWARD</literal> или <literal>BACKWARD</literal>. Без указания "
"<replaceable>направления</replaceable> используется значение <literal>NEXT</"
"literal>. Значения <replaceable>направления</replaceable>, которые требуют "
"перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт "
"с указанием <literal>SCROLL</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3180(para)
msgid ""
"<replaceable>cursor</replaceable> must be the name of a <type>refcursor</"
"type> variable that references an open cursor portal."
msgstr ""
"<replaceable>курсор</replaceable> это переменная с типом <type>refcursor</"
"type>, которая ссылается на открытый портал курсора."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3187(programlisting)
#, no-wrap
msgid ""
"FETCH curs1 INTO rowvar;\n"
"FETCH curs2 INTO foo, bar, baz;\n"
"FETCH LAST FROM curs3 INTO x, y;\n"
"FETCH RELATIVE -2 FROM curs4 INTO x;"
msgstr ""
"FETCH curs1 INTO rowvar;\n"
"FETCH curs2 INTO foo, bar, baz;\n"
"FETCH LAST FROM curs3 INTO x, y;\n"
"FETCH RELATIVE -2 FROM curs4 INTO x;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3197(literal)
msgid "MOVE"
msgstr "MOVE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3199(synopsis)
#, no-wrap
msgid "MOVE <placeholder-1/> <placeholder-2/>;"
msgstr "MOVE <placeholder-1/> <placeholder-2/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3203(para)
msgid ""
"<command>MOVE</command> repositions a cursor without retrieving any data. "
"<command>MOVE</command> works exactly like the <command>FETCH</command> "
"command, except it only repositions the cursor and does not return the row "
"moved to. As with <command>SELECT INTO</command>, the special variable "
"<literal>FOUND</literal> can be checked to see whether there was a next row "
"to move to."
msgstr ""
"<command>MOVE</command> перемещает курсор без извлечения данных. "
"<command>MOVE</command> работает точно также как и <command>FETCH</command>, "
"но при этом только перемещает курсор и не извлекает строку, к которой "
"переместился. Как и в <command>SELECT INTO</command>, проверить успешность "
"перемещения можно с помощью специальной переменной <literal>FOUND</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3212(para)
msgid ""
"The <replaceable>direction</replaceable> clause can be any of the variants "
"allowed in the SQL <xref linkend=\"sql-fetch\"/> command, namely "
"<literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, "
"<literal>LAST</literal>, <literal>ABSOLUTE</literal> <replaceable>count</"
"replaceable>, <literal>RELATIVE</literal> <replaceable>count</replaceable>, "
"<literal>ALL</literal>, <literal>FORWARD</literal> "
"<optional><replaceable>count</replaceable> | <literal>ALL</literal></"
"optional>, or <literal>BACKWARD</literal> <optional><replaceable>count</"
"replaceable> | <literal>ALL</literal></optional>. Omitting "
"<replaceable>direction</replaceable> is the same as specifying "
"<literal>NEXT</literal>. <replaceable>direction</replaceable> values that "
"require moving backward are likely to fail unless the cursor was declared or "
"opened with the <literal>SCROLL</literal> option."
msgstr ""
"Здесь <replaceable>направление</replaceable> может быть любым допустимым в "
"SQL-команде <xref linkend=\"sql-fetch\"/> вариантом, а именно: "
"<literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, "
"<literal>LAST</literal>, <literal>ABSOLUTE</literal> <replaceable>число</"
"replaceable>, <literal>RELATIVE</literal> <replaceable>число</replaceable>, "
"<literal>ALL</literal>, <literal>FORWARD</literal> "
"<optional><replaceable>число</replaceable> | <literal>ALL</literal></"
"optional> или <literal>BACKWARD</literal> <optional><replaceable>число</"
"replaceable> | <literal>ALL</literal></optional>. Без указания "
"<replaceable>направления</replaceable> используется значение <literal>NEXT</"
"literal>. Значения <replaceable>направления</replaceable>, которые требуют "
"перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт "
"с указанием <literal>SCROLL</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3234(programlisting)
#, no-wrap
msgid ""
"MOVE curs1;\n"
"MOVE LAST FROM curs3;\n"
"MOVE RELATIVE -2 FROM curs4;\n"
"MOVE FORWARD 2 FROM curs4;"
msgstr ""
"MOVE curs1;\n"
"MOVE LAST FROM curs3;\n"
"MOVE RELATIVE -2 FROM curs4;\n"
"MOVE FORWARD 2 FROM curs4;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3244(literal)
msgid "UPDATE/DELETE WHERE CURRENT OF"
msgstr "UPDATE/DELETE WHERE CURRENT OF"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3247(replaceable) plpgsql.xml:3248(replaceable)
msgid "table"
msgstr "таблица"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3246(synopsis)
#, no-wrap
msgid ""
"UPDATE <placeholder-1/> SET ... WHERE CURRENT OF <placeholder-2/>;\n"
"DELETE FROM <placeholder-3/> WHERE CURRENT OF <placeholder-4/>;"
msgstr ""
"UPDATE <placeholder-1/> SET ... WHERE CURRENT OF <placeholder-2/>;\n"
"DELETE FROM <placeholder-3/> WHERE CURRENT OF <placeholder-4/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3251(para)
msgid ""
"When a cursor is positioned on a table row, that row can be updated or "
"deleted using the cursor to identify the row. There are restrictions on what "
"the cursor's query can be (in particular, no grouping) and it's best to use "
"<literal>FOR UPDATE</literal> in the cursor. For more information see the "
"<xref linkend=\"sql-declare\"/> reference page."
msgstr ""
"Когда курсор позиционирован на строку таблицы, эту строку можно изменить или "
"удалить при помощи курсора. Есть ограничения на то, каким может быть запрос "
"курсора (в частности, не должно быть группировок), и крайне желательно "
"использовать указание <literal>FOR UPDATE</literal>. За дополнительными "
"сведениями обратитесь к странице справки <xref remap=\"1\" linkend=\"sql-"
"declare\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3263(programlisting)
#, no-wrap
msgid "UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;"
msgstr "UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3270(literal)
msgid "CLOSE"
msgstr "CLOSE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3272(synopsis)
#, no-wrap
msgid "CLOSE <placeholder-1/>;"
msgstr "CLOSE <placeholder-1/>;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3276(para)
msgid ""
"<command>CLOSE</command> closes the portal underlying an open cursor. This "
"can be used to release resources earlier than end of transaction, or to free "
"up the cursor variable to be opened again."
msgstr ""
"<command>CLOSE</command> закрывает связанный с курсором портал. Используется "
"для того, чтобы освободить ресурсы раньше, чем закончится транзакция, или "
"чтобы освободить курсорную переменную для повторного открытия."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3284(programlisting)
#, no-wrap
msgid "CLOSE curs1;"
msgstr "CLOSE curs1;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3291(title)
msgid "Returning Cursors"
msgstr "Возврат курсора из функции"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3293(para)
msgid ""
"<application>PL/pgSQL</application> functions can return cursors to the "
"caller. This is useful to return multiple rows or columns, especially with "
"very large result sets. To do this, the function opens the cursor and "
"returns the cursor name to the caller (or simply opens the cursor using a "
"portal name specified by or otherwise known to the caller). The caller can "
"then fetch rows from the cursor. The cursor can be closed by the caller, or "
"it will be closed automatically when the transaction closes."
msgstr ""
"Курсоры можно возвращать из функции на <application>PL/pgSQL</application>. "
"Это полезно, когда нужно вернуть множество строк и столбцов, особенно если "
"выборки очень большие. Для этого, в функции открывается курсор и его имя "
"возвращается вызывающему (или просто открывается курсор, используя указанное "
"имя портала, каким-либо образом известное вызывающему). Вызывающий затем "
"может извлекать строки из курсора. Курсор может быть закрыт вызывающим или "
"он будет автоматически закрыт при завершении транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3304(para)
msgid ""
"The portal name used for a cursor can be specified by the programmer or "
"automatically generated. To specify a portal name, simply assign a string to "
"the <type>refcursor</type> variable before opening it. The string value of "
"the <type>refcursor</type> variable will be used by <command>OPEN</command> "
"as the name of the underlying portal. However, if the <type>refcursor</type> "
"variable is null, <command>OPEN</command> automatically generates a name "
"that does not conflict with any existing portal, and assigns it to the "
"<type>refcursor</type> variable."
msgstr ""
"Имя портала, используемое для курсора, может быть указано разработчиком или "
"будет генерироваться автоматически. Чтобы указать имя портала, нужно просто "
"присвоить строку в переменную <type>refcursor</type> перед его открытием. "
"Значение строки переменной <type>refcursor</type> будет использоваться "
"командой <command>OPEN</command> как имя портала. Однако, если переменная "
"<type>refcursor</type> имеет значение NULL, <command>OPEN</command> "
"автоматически генерирует имя, которое не конфликтует с любым существующим "
"порталом и присваивает его переменной <type>refcursor</type>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3317(para)
msgid ""
"A bound cursor variable is initialized to the string value representing its "
"name, so that the portal name is the same as the cursor variable name, "
"unless the programmer overrides it by assignment before opening the cursor. "
"But an unbound cursor variable defaults to the null value initially, so it "
"will receive an automatically-generated unique name, unless overridden."
msgstr ""
"Связанная курсорная переменная инициализируется в строковое значение, "
"представляющее собой имя самой переменной. Таким образом, имя портала "
"совпадает с именем курсорной переменной, кроме случаев, когда разработчик "
"переопределил имя, присвоив новое значение перед открытием курсора. "
"Несвязанная курсорная переменная инициализируется в NULL и получит "
"автоматически сгенерированное уникальное имя, если не будет переопределена."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3331(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test (col text);\n"
"INSERT INTO test VALUES ('123');\n"
"\n"
"CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '\n"
"BEGIN\n"
"    OPEN $1 FOR SELECT col FROM test;\n"
"    RETURN $1;\n"
"END;\n"
"' LANGUAGE plpgsql;\n"
"\n"
"BEGIN;\n"
"SELECT reffunc('funccursor');\n"
"FETCH ALL IN funccursor;\n"
"COMMIT;"
msgstr ""
"CREATE TABLE test (col text);\n"
"INSERT INTO test VALUES ('123');\n"
"\n"
"CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '\n"
"BEGIN\n"
"    OPEN $1 FOR SELECT col FROM test;\n"
"    RETURN $1;\n"
"END;\n"
"' LANGUAGE plpgsql;\n"
"\n"
"BEGIN;\n"
"SELECT reffunc('funccursor');\n"
"FETCH ALL IN funccursor;\n"
"COMMIT;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3327(para)
msgid ""
"The following example shows one way a cursor name can be supplied by the "
"caller: <placeholder-1/>"
msgstr ""
"Следующий пример показывает один из способов передачи имени курсора "
"вызывающему: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3352(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION reffunc2() RETURNS refcursor AS '\n"
"DECLARE\n"
"    ref refcursor;\n"
"BEGIN\n"
"    OPEN ref FOR SELECT col FROM test;\n"
"    RETURN ref;\n"
"END;\n"
"' LANGUAGE plpgsql;\n"
"\n"
"-- need to be in a transaction to use cursors.\n"
"BEGIN;\n"
"SELECT reffunc2();\n"
"\n"
"      reffunc2\n"
"--------------------\n"
" &lt;unnamed cursor 1&gt;\n"
"(1 row)\n"
"\n"
"FETCH ALL IN \"&lt;unnamed cursor 1&gt;\";\n"
"COMMIT;"
msgstr ""
"CREATE FUNCTION reffunc2() RETURNS refcursor AS '\n"
"DECLARE\n"
"    ref refcursor;\n"
"BEGIN\n"
"    OPEN ref FOR SELECT col FROM test;\n"
"    RETURN ref;\n"
"END;\n"
"' LANGUAGE plpgsql;\n"
"\n"
"-- для использования курсоров, необходимо начать транзакцию\n"
"BEGIN;\n"
"SELECT reffunc2();\n"
"\n"
"      reffunc2\n"
"--------------------\n"
" &lt;unnamed cursor 1&gt;\n"
"(1 row)\n"
"\n"
"FETCH ALL IN \"&lt;unnamed cursor 1&gt;\";\n"
"COMMIT;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3349(para)
msgid ""
"The following example uses automatic cursor name generation: <placeholder-1/>"
msgstr ""
"В следующем примере используется автоматическая генерация имени курсора: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3380(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$\n"
"BEGIN\n"
"    OPEN $1 FOR SELECT * FROM table_1;\n"
"    RETURN NEXT $1;\n"
"    OPEN $2 FOR SELECT * FROM table_2;\n"
"    RETURN NEXT $2;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"-- need to be in a transaction to use cursors.\n"
"BEGIN;\n"
"\n"
"SELECT * FROM myfunc('a', 'b');\n"
"\n"
"FETCH ALL FROM a;\n"
"FETCH ALL FROM b;\n"
"COMMIT;"
msgstr ""
"CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$\n"
"BEGIN\n"
"    OPEN $1 FOR SELECT * FROM table_1;\n"
"    RETURN NEXT $1;\n"
"    OPEN $2 FOR SELECT * FROM table_2;\n"
"    RETURN NEXT $2;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"-- для использования курсоров необходимо начать транзакцию\n"
"BEGIN;\n"
"\n"
"SELECT * FROM myfunc('a', 'b');\n"
"\n"
"FETCH ALL FROM a;\n"
"FETCH ALL FROM b;\n"
"COMMIT;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3376(para)
msgid ""
"The following example shows one way to return multiple cursors from a single "
"function: <placeholder-1/>"
msgstr ""
"В следующем примере показан один из способов вернуть несколько курсоров из "
"одной функции: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3404(title)
msgid "Looping Through a Cursor's Result"
msgstr "Обработка курсора в цикле"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3406(para)
msgid ""
"There is a variant of the <command>FOR</command> statement that allows "
"iterating through the rows returned by a cursor. The syntax is: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>\n"
"FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</"
"replaceable> <optional> ( <optional> <replaceable>argument_name</"
"replaceable> := </optional> <replaceable>argument_value</replaceable> "
"<optional>, ...</optional> ) </optional> LOOP\n"
"    <replaceable>statements</replaceable>\n"
"END LOOP <optional> <replaceable>label</replaceable> </optional>;\n"
"</synopsis> The cursor variable must have been bound to some query when it "
"was declared, and it <emphasis>cannot</emphasis> be open already. The "
"<command>FOR</command> statement automatically opens the cursor, and it "
"closes the cursor again when the loop exits. A list of actual argument value "
"expressions must appear if and only if the cursor was declared to take "
"arguments. These values will be substituted in the query, in just the same "
"way as during an <command>OPEN</command> (see <xref linkend=\"plpgsql-open-"
"bound-cursor\"/>)."
msgstr ""
"Один из вариантов цикла <command>FOR</command> позволяет перебирать строки, "
"возвращённые курсором. Вот его синтаксис: <synopsis>\n"
"<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>\n"
"FOR <replaceable>переменная-запись</replaceable> IN "
"<replaceable>связанная_переменная_курсора</replaceable> <optional> "
"( <optional> <replaceable>имя_аргумента</replaceable> := </optional> "
"<replaceable>значение_аргумента</replaceable> <optional>, ...</optional> ) </"
"optional> LOOP\n"
"    <replaceable>операторы</replaceable>\n"
"END LOOP <optional> <replaceable>метка</replaceable> </optional>;\n"
"</synopsis> Курсорная переменная должна быть связана с запросом при "
"объявлении. Курсор <emphasis>не может</emphasis> быть открытым. Команда "
"<command>FOR</command> автоматически открывает курсор и автоматически "
"закрывает при завершении цикла. Список фактических значений аргументов "
"должен присутствовать только в том случае, если курсор объявлялся с "
"параметрами. Эти значения будут подставлены в запрос, также как и при "
"выполнении <command>OPEN</command> (см. <xref remap=\"4\" linkend=\"plpgsql-"
"open-bound-cursor\"/>)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3427(para)
msgid ""
"The variable <replaceable>recordvar</replaceable> is automatically defined "
"as type <type>record</type> and exists only inside the loop (any existing "
"definition of the variable name is ignored within the loop). Each row "
"returned by the cursor is successively assigned to this record variable and "
"the loop body is executed."
msgstr ""
"Данная <replaceable>переменная-запись</replaceable> автоматически "
"определяется как переменная типа <type>record</type> и существует только "
"внутри цикла (другие объявленные переменные с таким именем игнорируется в "
"цикле). Каждая возвращаемая курсором строка последовательно присваивается "
"этой переменной и выполняется тело цикла."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3439(title)
msgid "Errors and Messages"
msgstr "Сообщения и ошибки"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3442(title)
msgid "Reporting Errors and Messages"
msgstr "Вывод сообщений и ошибок"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3444(indexterm)
msgid "<primary>RAISE</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>RAISE</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3449(indexterm)
msgid "<primary>reporting errors</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>вывод ошибок</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3454(para)
msgid ""
"Use the <command>RAISE</command> statement to report messages and raise "
"errors. <synopsis>\n"
"RAISE <optional> <replaceable class=\"parameter\">level</replaceable> </"
"optional> '<replaceable class=\"parameter\">format</replaceable>' "
"<optional>, <replaceable class=\"parameter\">expression</replaceable> "
"<optional>, ... </optional></optional> <optional> USING <replaceable class="
"\"parameter\">option</replaceable> = <replaceable class=\"parameter"
"\">expression</replaceable> <optional>, ... </optional> </optional>;\n"
"RAISE <optional> <replaceable class=\"parameter\">level</replaceable> </"
"optional> <replaceable class=\"parameter\">condition_name</replaceable> "
"<optional> USING <replaceable class=\"parameter\">option</replaceable> = "
"<replaceable class=\"parameter\">expression</replaceable> <optional>, ... </"
"optional> </optional>;\n"
"RAISE <optional> <replaceable class=\"parameter\">level</replaceable> </"
"optional> SQLSTATE '<replaceable class=\"parameter\">sqlstate</replaceable>' "
"<optional> USING <replaceable class=\"parameter\">option</replaceable> = "
"<replaceable class=\"parameter\">expression</replaceable> <optional>, ... </"
"optional> </optional>;\n"
"RAISE <optional> <replaceable class=\"parameter\">level</replaceable> </"
"optional> USING <replaceable class=\"parameter\">option</replaceable> = "
"<replaceable class=\"parameter\">expression</replaceable> <optional>, ... </"
"optional>;\n"
"RAISE ;\n"
"</synopsis> The <replaceable class=\"parameter\">level</replaceable> option "
"specifies the error severity. Allowed levels are <literal>DEBUG</literal>, "
"<literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, "
"<literal>WARNING</literal>, and <literal>EXCEPTION</literal>, with "
"<literal>EXCEPTION</literal> being the default. <literal>EXCEPTION</literal> "
"raises an error (which normally aborts the current transaction); the other "
"levels only generate messages of different priority levels. Whether messages "
"of a particular priority are reported to the client, written to the server "
"log, or both is controlled by the <xref linkend=\"guc-log-min-messages\"/> "
"and <xref linkend=\"guc-client-min-messages\"/> configuration variables. See "
"<xref linkend=\"runtime-config\"/> for more information."
msgstr ""
"Команда <command>RAISE</command> предназначена для вывода сообщений и вызова "
"ошибок. <synopsis>\n"
"RAISE <optional> <replaceable class=\"parameter\">уровень</replaceable> </"
"optional> '<replaceable class=\"parameter\">формат</replaceable>' "
"<optional>, <replaceable class=\"parameter\">выражение</replaceable> "
"<optional>, ... </optional></optional> <optional> USING <replaceable class="
"\"parameter\">параметр</replaceable> = <replaceable class=\"parameter"
"\">значение</replaceable> <optional>, ... </optional> </optional>;\n"
"RAISE <optional> <replaceable class=\"parameter\">уровень</replaceable> </"
"optional> <replaceable class=\"parameter\">имя_условия</replaceable> "
"<optional> USING <replaceable class=\"parameter\">параметр</replaceable> = "
"<replaceable class=\"parameter\">выражение</replaceable> <optional>, ... </"
"optional> </optional>;\n"
"RAISE <optional> <replaceable class=\"parameter\">уровень</replaceable> </"
"optional> SQLSTATE '<replaceable class=\"parameter\">sqlstate</replaceable>' "
"<optional> USING <replaceable class=\"parameter\">параметр</replaceable> = "
"<replaceable class=\"parameter\">выражение</replaceable> <optional>, ... </"
"optional> </optional>;\n"
"RAISE <optional> <replaceable class=\"parameter\">уровень</replaceable> </"
"optional> USING <replaceable class=\"parameter\">параметр</replaceable> = "
"<replaceable class=\"parameter\">выражение</replaceable> <optional>, ... </"
"optional>;\n"
"RAISE ;\n"
"</synopsis> <replaceable class=\"parameter\">уровень</replaceable> задаёт "
"уровень важности ошибки. Возможные значения: <literal>DEBUG</literal>, "
"<literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, "
"<literal>WARNING</literal> и <literal>EXCEPTION</literal>. По умолчанию "
"используется <literal>EXCEPTION</literal>. <literal>EXCEPTION</literal> "
"вызывает ошибку (что обычно прерывает текущую транзакцию), остальные "
"значения <replaceable class=\"parameter\">уровня</replaceable> только "
"генерируют сообщения с различными уровнями приоритета. Будут ли сообщения "
"конкретного приоритета переданы клиенту или записаны в журнал сервера, или и "
"то, и другое, зависит от конфигурационных переменных <xref linkend=\"guc-log-"
"min-messages\"/> и <xref linkend=\"guc-client-min-messages\"/>. За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"runtime-"
"config\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3483(para)
msgid ""
"After <replaceable class=\"parameter\">level</replaceable> if any, you can "
"write a <replaceable class=\"parameter\">format</replaceable> (which must be "
"a simple string literal, not an expression). The format string specifies the "
"error message text to be reported. The format string can be followed by "
"optional argument expressions to be inserted into the message. Inside the "
"format string, <literal>%</literal> is replaced by the string representation "
"of the next optional argument's value. Write <literal>%%</literal> to emit a "
"literal <literal>%</literal>. The number of arguments must match the number "
"of <literal>%</literal> placeholders in the format string, or an error is "
"raised during the compilation of the function."
msgstr ""
"После указания <replaceable class=\"parameter\">уровня</replaceable>, если "
"оно есть, можно задать <replaceable class=\"parameter\">формат</replaceable> "
"(это должна быть простая строковая константа, не выражение). Строка формата "
"определяет вид текста об ошибке, который будет выдан. За строкой формата "
"могут следовать необязательные выражения аргументов, которые будут вставлены "
"в сообщение. Внутри строки формата знак <literal>%</literal> заменяется "
"строковым представлением значения очередного аргумента. Чтобы выдать символ "
"<literal>%</literal> буквально, продублируйте его (как <literal>%%</"
"literal>). Число аргументов должно совпадать с числом местозаполнителей "
"<literal>%</literal> в строке формата, иначе при компиляции функции "
"возникнет ошибка."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3501(programlisting)
#, no-wrap
msgid "RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;"
msgstr "RAISE NOTICE 'Вызов функции cs_create_job(%)', v_job_id;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3498(para)
msgid ""
"In this example, the value of <literal>v_job_id</literal> will replace the "
"<literal>%</literal> in the string: <placeholder-1/>"
msgstr ""
"В следующем примере символ <literal>%</literal> будет заменён на значение "
"<literal>v_job_id</literal>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3517(literal)
msgid "MESSAGE"
msgstr "MESSAGE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3519(para)
msgid ""
"Sets the error message text. This option can't be used in the form of "
"<command>RAISE</command> that includes a format string before "
"<literal>USING</literal>."
msgstr ""
"Устанавливает текст сообщения об ошибке. Этот параметр не может "
"использоваться, если в команде <command>RAISE</command> присутствует "
"<replaceable class=\"parameter\">формат</replaceable> перед <literal>USING</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3526(literal)
msgid "DETAIL"
msgstr "DETAIL"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3528(para)
msgid "Supplies an error detail message."
msgstr "Предоставляет детальное сообщение об ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3533(literal)
msgid "HINT"
msgstr "HINT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3535(para)
msgid "Supplies a hint message."
msgstr "Предоставляет подсказку по вызванной ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3540(literal)
msgid "ERRCODE"
msgstr "ERRCODE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3542(para)
msgid ""
"Specifies the error code (SQLSTATE) to report, either by condition name, as "
"shown in <xref linkend=\"errcodes-appendix\"/>, or directly as a five-"
"character SQLSTATE code."
msgstr ""
"Устанавливает код ошибки (<literal>SQLSTATE</literal>). Код ошибки задаётся "
"либо по имени, как показано в <xref remap=\"6\" linkend=\"errcodes-appendix"
"\"/>, или напрямую, пятисимвольный код <literal>SQLSTATE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3549(literal)
msgid "COLUMN"
msgstr "COLUMN"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3550(literal)
msgid "CONSTRAINT"
msgstr "CONSTRAINT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3551(literal)
msgid "DATATYPE"
msgstr "DATATYPE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3552(literal)
msgid "TABLE"
msgstr "TABLE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3553(literal)
msgid "SCHEMA"
msgstr "SCHEMA"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3555(para)
msgid "Supplies the name of a related object."
msgstr "Предоставляет имя соответствующего объекта, связанного с ошибкой."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3506(para)
msgid ""
"You can attach additional information to the error report by writing "
"<literal>USING</literal> followed by <replaceable class=\"parameter"
"\">option</replaceable> = <replaceable class=\"parameter\">expression</"
"replaceable> items. Each <replaceable class=\"parameter\">expression</"
"replaceable> can be any string-valued expression. The allowed <replaceable "
"class=\"parameter\">option</replaceable> key words are: <placeholder-1/>"
msgstr ""
"При помощи <literal>USING</literal> и последующих элементов <replaceable "
"class=\"parameter\">параметр</replaceable> = <replaceable class=\"parameter"
"\">выражение</replaceable> можно добавить дополнительную информацию к отчёту "
"об ошибке. Все <replaceable class=\"parameter\">выражения</replaceable> "
"представляют собой строковые выражения. Возможные ключевые слова для "
"<replaceable class=\"parameter\">параметра</replaceable> следующие: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3564(programlisting)
#, no-wrap
msgid ""
"RAISE EXCEPTION 'Nonexistent ID --&gt; %', user_id\n"
"      USING HINT = 'Please check your user ID';"
msgstr ""
"RAISE EXCEPTION 'Несуществующий ID --&gt; %', user_id\n"
"      USING HINT = 'Проверьте ваш пользовательский ID';"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3561(para)
msgid ""
"This example will abort the transaction with the given error message and "
"hint: <placeholder-1/>"
msgstr ""
"Этот пример прерывает транзакцию и устанавливает сообщение об ошибке с "
"подсказкой: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3572(programlisting)
#, no-wrap
msgid ""
"RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';\n"
"RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';"
msgstr ""
"RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';\n"
"RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3570(para)
msgid ""
"These two examples show equivalent ways of setting the SQLSTATE: "
"<placeholder-1/>"
msgstr ""
"Следующие два примера демонстрируют эквивалентные способы задания "
"<literal>SQLSTATE</literal>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3581(programlisting)
#, no-wrap
msgid ""
"RAISE division_by_zero;\n"
"RAISE SQLSTATE '22012';"
msgstr ""
"RAISE division_by_zero;\n"
"RAISE SQLSTATE '22012';"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3588(programlisting)
#, no-wrap
msgid "RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;"
msgstr "RAISE unique_violation USING MESSAGE = 'ID пользователя уже существует: ' || user_id;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3578(para)
msgid ""
"There is a second <command>RAISE</command> syntax in which the main argument "
"is the condition name or SQLSTATE to be reported, for example: "
"<placeholder-1/> In this syntax, <literal>USING</literal> can be used to "
"supply a custom error message, detail, or hint. Another way to do the "
"earlier example is <placeholder-2/>"
msgstr ""
"У команды <command>RAISE</command> есть и другой синтаксис, в котором в "
"качестве главного аргумента используется имя или код <literal>SQLSTATE</"
"literal> ошибки. Например: <placeholder-1/> Предложение <literal>USING</"
"literal> в этом синтаксисе можно использовать для того, чтобы переопределить "
"стандартное сообщение об ошибке, детальное сообщение, подсказку. Ещё один "
"вариант предыдущего примера: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3593(para)
msgid ""
"Still another variant is to write <literal>RAISE USING</literal> or "
"<literal>RAISE <replaceable class=\"parameter\">level</replaceable> USING</"
"literal> and put everything else into the <literal>USING</literal> list."
msgstr ""
"Ещё один вариант — использовать <literal>RAISE USING</literal> или "
"<literal>RAISE <replaceable class=\"parameter\">уровень</replaceable> USING</"
"literal>, а всё остальное записать в списке <literal>USING</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3599(para)
msgid ""
"The last variant of <command>RAISE</command> has no parameters at all. This "
"form can only be used inside a <literal>BEGIN</literal> block's "
"<literal>EXCEPTION</literal> clause; it causes the error currently being "
"handled to be re-thrown."
msgstr ""
"И заключительный вариант, в котором <command>RAISE</command> не имеет "
"параметров вообще. Эта форма может использоваться только в секции "
"<literal>EXCEPTION</literal> блока и предназначена для того, чтобы повторно "
"вызвать ошибку, которая сейчас перехвачена и обрабатывается."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3607(para)
msgid ""
"Before <productname>PostgreSQL</productname> 9.1, <command>RAISE</command> "
"without parameters was interpreted as re-throwing the error from the block "
"containing the active exception handler. Thus an <literal>EXCEPTION</"
"literal> clause nested within that handler could not catch it, even if the "
"<command>RAISE</command> was within the nested <literal>EXCEPTION</literal> "
"clause's block. This was deemed surprising as well as being incompatible "
"with Oracle's PL/SQL."
msgstr ""
"До версии <productname>PostgreSQL</productname> 9.1 команда <command>RAISE</"
"command> без параметров всегда вызывала ошибку с выходом из блока, "
"содержащего активную секцию <literal>EXCEPTION</literal>. Эту ошибку нельзя "
"было перехватить, даже если <command>RAISE</command> в секции "
"<literal>EXCEPTION</literal> поместить во вложенный блок со своей секцией "
"<literal>EXCEPTION</literal>. Это было сочтено удивительным и не совместимым "
"с Oracle PL/SQL."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3618(para)
msgid ""
"If no condition name nor SQLSTATE is specified in a <command>RAISE "
"EXCEPTION</command> command, the default is to use <literal>RAISE_EXCEPTION</"
"literal> (<literal>P0001</literal>). If no message text is specified, the "
"default is to use the condition name or SQLSTATE as message text."
msgstr ""
"Если в команде <command>RAISE EXCEPTION</command> не задано ни имя, ни "
"<literal>SQLSTATE</literal> код, то по умолчанию используются "
"<literal>RAISE_EXCEPTION</literal> (<literal>P0001</literal>). В качестве "
"текста сообщения об ошибке (если не задан) используется имя или "
"<literal>SQLSTATE</literal> код."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3627(para)
msgid ""
"When specifying an error code by SQLSTATE code, you are not limited to the "
"predefined error codes, but can select any error code consisting of five "
"digits and/or upper-case ASCII letters, other than <literal>00000</literal>. "
"It is recommended that you avoid throwing error codes that end in three "
"zeroes, because these are category codes and can only be trapped by trapping "
"the whole category."
msgstr ""
"При задании <literal>SQLSTATE</literal> кода необязательно использовать "
"только список предопределённых кодов ошибок. В качестве кода ошибки может "
"быть любое пятисимвольное значение, состоящее из цифр и/или ASCII символов в "
"верхнем регистре, кроме <literal>00000</literal>. Не рекомендуется "
"использовать коды ошибок, которые заканчиваются на <literal>000</literal>, "
"потому что так обозначаются коды категорий. И чтобы их перехватить, нужно "
"перехватывать целую категорию."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3641(title)
msgid "Checking Assertions"
msgstr "Проверка утверждений"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3643(indexterm)
msgid "<primary>ASSERT</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>ASSERT</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3648(indexterm)
msgid "<primary>assertions</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>утверждения</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3653(indexterm)
msgid ""
"<primary><varname>plpgsql.check_asserts</varname> configuration parameter</"
"primary>"
msgstr ""
"<primary>параметр конфигурации <varname>plpgsql.check_asserts</varname></"
"primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3657(para)
msgid ""
"The <command>ASSERT</command> statement is a convenient shorthand for "
"inserting debugging checks into <application>PL/pgSQL</application> "
"functions. <synopsis>\n"
"ASSERT <replaceable class=\"parameter\">condition</replaceable> <optional> , "
"<replaceable class=\"parameter\">message</replaceable> </optional>;\n"
"</synopsis> The <replaceable class=\"parameter\">condition</replaceable> is "
"a Boolean expression that is expected to always evaluate to true; if it "
"does, the <command>ASSERT</command> statement does nothing further. If the "
"result is false or null, then an <literal>ASSERT_FAILURE</literal> exception "
"is raised. (If an error occurs while evaluating the <replaceable class="
"\"parameter\">condition</replaceable>, it is reported as a normal error.)"
msgstr ""
"Оператор <command>ASSERT</command> представляет удобное средство вставлять "
"отладочные проверки в функции <application>PL/pgSQL</application>. "
"<synopsis>\n"
"ASSERT <replaceable class=\"parameter\">условие</replaceable> <optional> , "
"<replaceable class=\"parameter\">сообщение</replaceable> </optional>;\n"
"</synopsis> Здесь <replaceable class=\"parameter\">условие</replaceable> — "
"это булевское выражение, которое, как ожидается, должно быть всегда "
"истинным; если это так, оператор <command>ASSERT</command> больше ничего не "
"делает. Если же оно возвращает ложь или NULL, этот оператор выдаёт "
"исключение <literal>ASSERT_FAILURE</literal>. (Если ошибка происходит при "
"вычислении <replaceable class=\"parameter\">условия</replaceable>, она "
"выдаётся как обычная ошибка.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3675(para)
msgid ""
"If the optional <replaceable class=\"parameter\">message</replaceable> is "
"provided, it is an expression whose result (if not null) replaces the "
"default error message text <quote>assertion failed</quote>, should the "
"<replaceable class=\"parameter\">condition</replaceable> fail. The "
"<replaceable class=\"parameter\">message</replaceable> expression is not "
"evaluated in the normal case where the assertion succeeds."
msgstr ""
"Если в нём задаётся необязательное <replaceable class=\"parameter"
"\">сообщение</replaceable>, результат этого выражения (если он не NULL) "
"заменяет сообщение об ошибке по умолчанию <quote>assertion failed</quote> "
"(нарушение истинности), в случае, если <replaceable class=\"parameter"
"\">условие</replaceable> не выполняется. В обычном случае, когда условие "
"утверждения выполняется, выражение <replaceable class=\"parameter"
"\">сообщения</replaceable> не вычисляется."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3684(para)
msgid ""
"Testing of assertions can be enabled or disabled via the configuration "
"parameter <literal>plpgsql.check_asserts</literal>, which takes a Boolean "
"value; the default is <literal>on</literal>. If this parameter is "
"<literal>off</literal> then <command>ASSERT</command> statements do nothing."
msgstr ""
"Проверку утверждений можно включить или отключить с помощью "
"конфигурационного параметра <literal>plpgsql.check_asserts</literal>, "
"принимающего булевское значение; по умолчанию она включена (<literal>on</"
"literal>). Если этот параметр отключён (<literal>off</literal>), операторы "
"<command>ASSERT</command> ничего не делают."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3691(para)
msgid ""
"Note that <command>ASSERT</command> is meant for detecting program bugs, not "
"for reporting ordinary error conditions. Use the <command>RAISE</command> "
"statement, described above, for that."
msgstr ""
"Учтите, что оператор <command>ASSERT</command> предназначен для выявления "
"программных дефектов, а не для вывода обычных ошибок (для этого используется "
"оператор <command>RAISE</command>, описанный выше)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3702(title)
msgid "Trigger Procedures"
msgstr "Триггерные процедуры"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3704(indexterm)
msgid "<primary>trigger</primary> <secondary>in PL/pgSQL</secondary>"
msgstr "<primary>триггер</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3709(para)
msgid ""
"<application>PL/pgSQL</application> can be used to define trigger procedures "
"on data changes or database events. A trigger procedure is created with the "
"<command>CREATE FUNCTION</command> command, declaring it as a function with "
"no arguments and a return type of <type>trigger</type> (for data change "
"triggers) or <type>event_trigger</type> (for database event triggers). "
"Special local variables named <varname>PG_<replaceable>something</"
"replaceable></varname> are automatically defined to describe the condition "
"that triggered the call."
msgstr ""
"В <application>PL/pgSQL</application> можно создавать триггерные процедуры, "
"которые будут вызываться при изменениях данных или событиях в базе данных. "
"Триггерная процедура создаётся командой <command>CREATE FUNCTION</command>, "
"при этом у функции не должно быть аргументов, а типом возвращаемого значения "
"должен быть <type>trigger</type> (для триггеров, срабатывающих при "
"изменениях данных) или <type>event_trigger</type> (для триггеров, "
"срабатывающих при событиях в базе). Для триггеров автоматически определяются "
"специальные локальные переменные с именами вида "
"<varname>PG_<replaceable>переменная</replaceable></varname>, описывающие "
"условие, повлекшее вызов триггера."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3721(title)
msgid "Triggers on Data Changes"
msgstr "Триггеры при изменении данных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3723(para)
msgid ""
"A <link linkend=\"triggers\">data change trigger</link> is declared as a "
"function with no arguments and a return type of <type>trigger</type>. Note "
"that the function must be declared with no arguments even if it expects to "
"receive some arguments specified in <command>CREATE TRIGGER</command> "
"&mdash; such arguments are passed via <varname>TG_ARGV</varname>, as "
"described below."
msgstr ""
"<link linkend=\"triggers\">Триггер при изменении данных</link> объявляется "
"как функция без аргументов и с типом результата <type>trigger</type>. "
"Заметьте, что эта функция должна объявляться без аргументов, даже если "
"ожидается, что она будет получать аргументы, заданные в команде "
"<command>CREATE TRIGGER</command> &mdash; такие аргументы передаются через "
"<varname>TG_ARGV</varname>, как описано ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3739(varname)
msgid "NEW"
msgstr "NEW"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3741(para)
msgid ""
"Data type <type>RECORD</type>; variable holding the new database row for "
"<command>INSERT</command>/<command>UPDATE</command> operations in row-level "
"triggers. This variable is unassigned in statement-level triggers and for "
"<command>DELETE</command> operations."
msgstr ""
"Тип данных <type>RECORD</type>. Переменная содержит новую строку базы данных "
"для команд <command>INSERT</command>/<command>UPDATE</command> в триггерах "
"уровня строки. В триггерах уровня оператора и для команды <command>DELETE</"
"command> этой переменной значение не присваивается."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3751(varname)
msgid "OLD"
msgstr "OLD"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3753(para)
msgid ""
"Data type <type>RECORD</type>; variable holding the old database row for "
"<command>UPDATE</command>/<command>DELETE</command> operations in row-level "
"triggers. This variable is unassigned in statement-level triggers and for "
"<command>INSERT</command> operations."
msgstr ""
"Тип данных <type>RECORD</type>. Переменная содержит старую строку базы "
"данных для команд <command>UPDATE</command>/<command>DELETE</command> в "
"триггерах уровня строки. В триггерах уровня оператора и для команды "
"<command>INSERT</command> этой переменной значение не присваивается."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3763(varname)
msgid "TG_NAME"
msgstr "TG_NAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3765(para)
msgid ""
"Data type <type>name</type>; variable that contains the name of the trigger "
"actually fired."
msgstr ""
"Тип данных <type>name</type>. Переменная содержит имя сработавшего триггера."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3773(varname)
msgid "TG_WHEN"
msgstr "TG_WHEN"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3775(para)
msgid ""
"Data type <type>text</type>; a string of <literal>BEFORE</literal>, "
"<literal>AFTER</literal>, or <literal>INSTEAD OF</literal>, depending on the "
"trigger's definition."
msgstr ""
"Тип данных <type>text</type>. Строка, содержащая <literal>BEFORE</literal>, "
"<literal>AFTER</literal> или <literal>INSTEAD OF</literal>, в зависимости от "
"определения триггера."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3784(varname)
msgid "TG_LEVEL"
msgstr "TG_LEVEL"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3786(para)
msgid ""
"Data type <type>text</type>; a string of either <literal>ROW</literal> or "
"<literal>STATEMENT</literal> depending on the trigger's definition."
msgstr ""
"Тип данных <type>text</type>. Строка, содержащая <literal>ROW</literal> или "
"<literal>STATEMENT</literal>, в зависимости от определения триггера."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3795(varname)
msgid "TG_OP"
msgstr "TG_OP"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3797(para)
msgid ""
"Data type <type>text</type>; a string of <literal>INSERT</literal>, "
"<literal>UPDATE</literal>, <literal>DELETE</literal>, or <literal>TRUNCATE</"
"literal> telling for which operation the trigger was fired."
msgstr ""
"Тип данных <type>text</type>. Строка, содержащая <literal>INSERT</literal>, "
"<literal>UPDATE</literal>, <literal>DELETE</literal> или <literal>TRUNCATE</"
"literal>, в зависимости от того, для какой операции сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3807(varname)
msgid "TG_RELID"
msgstr "TG_RELID"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3809(para)
msgid ""
"Data type <type>oid</type>; the object ID of the table that caused the "
"trigger invocation."
msgstr ""
"Тип данных <type>oid</type>. OID таблицы, для которой сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3817(varname)
msgid "TG_RELNAME"
msgstr "TG_RELNAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3819(para)
msgid ""
"Data type <type>name</type>; the name of the table that caused the trigger "
"invocation. This is now deprecated, and could disappear in a future release. "
"Use <literal>TG_TABLE_NAME</literal> instead."
msgstr ""
"Тип данных <type>name</type>. Имя таблицы, для которой сработал триггер. Эта "
"переменная устарела и может стать недоступной в будущих релизах. Вместо неё "
"нужно использовать <literal>TG_TABLE_NAME</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3828(varname)
msgid "TG_TABLE_NAME"
msgstr "TG_TABLE_NAME"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3830(para)
msgid ""
"Data type <type>name</type>; the name of the table that caused the trigger "
"invocation."
msgstr ""
"Тип данных <type>name</type>. Имя таблицы, для которой сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3838(varname)
msgid "TG_TABLE_SCHEMA"
msgstr "TG_TABLE_SCHEMA"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3840(para)
msgid ""
"Data type <type>name</type>; the name of the schema of the table that caused "
"the trigger invocation."
msgstr ""
"Тип данных <type>name</type>. Имя схемы, содержащей таблицу, для которой "
"сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3848(varname)
msgid "TG_NARGS"
msgstr "TG_NARGS"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3850(para)
msgid ""
"Data type <type>integer</type>; the number of arguments given to the trigger "
"procedure in the <command>CREATE TRIGGER</command> statement."
msgstr ""
"Тип данных <type>integer</type>. Число аргументов в команде <command>CREATE "
"TRIGGER</command>, которые передаются в триггерную процедуру."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3858(varname)
msgid "TG_ARGV[]"
msgstr "TG_ARGV[]"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3860(para)
msgid ""
"Data type array of <type>text</type>; the arguments from the <command>CREATE "
"TRIGGER</command> statement. The index counts from 0. Invalid indexes (less "
"than 0 or greater than or equal to <varname>tg_nargs</varname>) result in a "
"null value."
msgstr ""
"Тип данных массив <type>text</type>. Аргументы от оператора <command>CREATE "
"TRIGGER</command>. Индекс массива начинается с 0. Для недопустимых значений "
"индекса ( &lt; 0 или &gt;= <varname>tg_nargs</varname>) возвращается NULL."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3732(para)
msgid ""
"When a <application>PL/pgSQL</application> function is called as a trigger, "
"several special variables are created automatically in the top-level block. "
"They are: <placeholder-1/>"
msgstr ""
"Когда функция на <application>PL/pgSQL</application> срабатывает как "
"триггер, в блоке верхнего уровня автоматически создаются несколько "
"специальных переменных: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3872(para)
msgid ""
"A trigger function must return either <symbol>NULL</symbol> or a record/row "
"value having exactly the structure of the table the trigger was fired for."
msgstr ""
"Триггерная функция должна вернуть либо <symbol>NULL</symbol>, либо запись/"
"строку, соответствующую структуре таблице, для которой сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3878(para)
msgid ""
"Row-level triggers fired <literal>BEFORE</literal> can return null to signal "
"the trigger manager to skip the rest of the operation for this row (i.e., "
"subsequent triggers are not fired, and the <command>INSERT</command>/"
"<command>UPDATE</command>/<command>DELETE</command> does not occur for this "
"row). If a nonnull value is returned then the operation proceeds with that "
"row value. Returning a row value different from the original value of "
"<varname>NEW</varname> alters the row that will be inserted or updated. "
"Thus, if the trigger function wants the triggering action to succeed "
"normally without altering the row value, <varname>NEW</varname> (or a value "
"equal thereto) has to be returned. To alter the row to be stored, it is "
"possible to replace single values directly in <varname>NEW</varname> and "
"return the modified <varname>NEW</varname>, or to build a complete new "
"record/row to return. In the case of a before-trigger on <command>DELETE</"
"command>, the returned value has no direct effect, but it has to be nonnull "
"to allow the trigger action to proceed. Note that <varname>NEW</varname> is "
"null in <command>DELETE</command> triggers, so returning that is usually not "
"sensible. The usual idiom in <command>DELETE</command> triggers is to return "
"<varname>OLD</varname>."
msgstr ""
"Если <literal>BEFORE</literal> триггер уровня строки возвращает "
"<symbol>NULL</symbol>, то все дальнейшие действия с этой строкой "
"прекращаются (т. е. не срабатывают последующие триггеры, команда "
"<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</"
"command> для этой строки не выполняется). Если возвращается не <symbol>NULL</"
"symbol>, то дальнейшая обработка продолжается именно с этой строкой. "
"Возвращение строки отличной от начальной <varname>NEW</varname>, изменяет "
"строку, которая будет вставлена или изменена. Поэтому, если в триггерной "
"функции нужно выполнить некоторые действия и не менять саму строку, то нужно "
"возвратить переменную <varname>NEW</varname> (или её эквивалент). Для того "
"чтобы изменить сохраняемую строку, можно поменять отдельные значения в "
"переменной <varname>NEW</varname> и затем её вернуть. Либо создать и вернуть "
"полностью новую переменную. В случае строчного триггера <literal>BEFORE</"
"literal> для команды <command>DELETE</command> само возвращаемое значение не "
"имеет прямого эффекта, но оно должно быть отличным от <symbol>NULL</symbol>, "
"чтобы не прерывать обработку строки. Обратите внимание, что переменная "
"<varname>NEW</varname> всегда <symbol>NULL</symbol> в триггерах на "
"<command>DELETE</command>, поэтому возвращать её не имеет смысла. "
"Традиционной идиомой для триггеров <command>DELETE</command> является "
"возврат переменной <varname>OLD</varname>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3902(para)
msgid ""
"<literal>INSTEAD OF</literal> triggers (which are always row-level triggers, "
"and may only be used on views) can return null to signal that they did not "
"perform any updates, and that the rest of the operation for this row should "
"be skipped (i.e., subsequent triggers are not fired, and the row is not "
"counted in the rows-affected status for the surrounding <command>INSERT</"
"command>/<command>UPDATE</command>/<command>DELETE</command>). Otherwise a "
"nonnull value should be returned, to signal that the trigger performed the "
"requested operation. For <command>INSERT</command> and <command>UPDATE</"
"command> operations, the return value should be <varname>NEW</varname>, "
"which the trigger function may modify to support <command>INSERT RETURNING</"
"command> and <command>UPDATE RETURNING</command> (this will also affect the "
"row value passed to any subsequent triggers, or passed to a special "
"<varname>EXCLUDED</varname> alias reference within an <command>INSERT</"
"command> statement with an <literal>ON CONFLICT DO UPDATE</literal> clause). "
"For <command>DELETE</command> operations, the return value should be "
"<varname>OLD</varname>."
msgstr ""
"Триггеры <literal>INSTEAD OF</literal> (это всегда триггеры уровня строк и "
"они могут применяться только с представлениями) могут возвращать NULL, чтобы "
"показать, что они не выполняли никаких изменений, так что обработку этой "
"строки можно не продолжать (то есть, не вызывать последующие триггеры и не "
"считать строку в числе обработанных строк для окружающих команд "
"<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</"
"command>). В противном случае должно быть возвращено значение, отличное от "
"NULL, показывающее, что триггер выполнил запрошенную операцию. Для операций "
"<command>INSERT</command> и <command>UPDATE</command> возвращаемым значением "
"должно быть <varname>NEW</varname>, которое триггерная функция может "
"модифицировать для поддержки предложений <command>INSERT RETURNING</command> "
"и <command>UPDATE RETURNING</command> (это также повлияет на значение "
"строки, передаваемое последующим триггерам, или доступное под специальным "
"псевдонимом <varname>EXCLUDED</varname> в операторе <command>INSERT</"
"command> с предложением <literal>ON CONFLICT DO UPDATE</literal>). Для "
"операций <command>DELETE</command> возвращаемым значением должно быть "
"<varname>OLD</varname>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3921(para)
msgid ""
"The return value of a row-level trigger fired <literal>AFTER</literal> or a "
"statement-level trigger fired <literal>BEFORE</literal> or <literal>AFTER</"
"literal> is always ignored; it might as well be null. However, any of these "
"types of triggers might still abort the entire operation by raising an error."
msgstr ""
"Возвращаемое значение для строчного триггера AFTER и триггеров уровня "
"оператора (BEFORE или AFTER) всегда игнорируется. Это может быть и NULL. "
"Однако, в этих триггерах по-прежнему можно прервать вызвавшую их команду, "
"для этого нужно явно вызвать ошибку."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3929(para)
msgid ""
"<xref linkend=\"plpgsql-trigger-example\"/> shows an example of a trigger "
"procedure in <application>PL/pgSQL</application>."
msgstr ""
"<xref linkend=\"plpgsql-trigger-example\"/> показывает пример триггерной "
"процедуры в <application>PL/pgSQL</application>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3935(title)
msgid "A <application>PL/pgSQL</application> Trigger Procedure"
msgstr "Триггерная процедура <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3937(para)
msgid ""
"This example trigger ensures that any time a row is inserted or updated in "
"the table, the current user name and time are stamped into the row. And it "
"checks that an employee's name is given and that the salary is a positive "
"value."
msgstr ""
"Триггер гарантирует, что всякий раз, когда в таблице добавляется или "
"изменяется запись, в этой записи сохраняется информация о текущем "
"пользователе и временной метке. Также контролируется, что имя сотрудника "
"указано и размер зарплаты выше нуля."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3944(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE emp (\n"
"    empname text,\n"
"    salary integer,\n"
"    last_date timestamp,\n"
"    last_user text\n"
");\n"
"\n"
"CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$\n"
"    BEGIN\n"
"        -- Check that empname and salary are given\n"
"        IF NEW.empname IS NULL THEN\n"
"            RAISE EXCEPTION 'empname cannot be null';\n"
"        END IF;\n"
"        IF NEW.salary IS NULL THEN\n"
"            RAISE EXCEPTION '% cannot have null salary', NEW.empname;\n"
"        END IF;\n"
"\n"
"        -- Who works for us when they must pay for it?\n"
"        IF NEW.salary &lt; 0 THEN\n"
"            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;\n"
"        END IF;\n"
"\n"
"        -- Remember who changed the payroll when\n"
"        NEW.last_date := current_timestamp;\n"
"        NEW.last_user := current_user;\n"
"        RETURN NEW;\n"
"    END;\n"
"$emp_stamp$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp\n"
"    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();"
msgstr ""
"CREATE TABLE emp (\n"
"    empname text,\n"
"    salary integer,\n"
"    last_date timestamp,\n"
"    last_user text\n"
");\n"
"\n"
"CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$\n"
"    BEGIN\n"
"        -- Проверить, что указаны имя сотрудника и зарплата\n"
"        IF NEW.empname IS NULL THEN\n"
"            RAISE EXCEPTION 'empname cannot be null';\n"
"        END IF;\n"
"        IF NEW.salary IS NULL THEN\n"
"            RAISE EXCEPTION '% cannot have null salary', NEW.empname;\n"
"        END IF;\n"
"\n"
"        -- Кто будет работать, если за это надо будет платить?\n"
"        IF NEW.salary &lt; 0 THEN\n"
"            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;\n"
"        END IF;\n"
"\n"
"        -- Запомнить, кто и когда изменил запись\n"
"        NEW.last_date := current_timestamp;\n"
"        NEW.last_user := current_user;\n"
"        RETURN NEW;\n"
"    END;\n"
"$emp_stamp$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp\n"
"    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3979(para)
msgid ""
"Another way to log changes to a table involves creating a new table that "
"holds a row for each insert, update, or delete that occurs. This approach "
"can be thought of as auditing changes to a table. <xref linkend=\"plpgsql-"
"trigger-audit-example\"/> shows an example of an audit trigger procedure in "
"<application>PL/pgSQL</application>."
msgstr ""
"Другой вариант вести журнал изменений для таблицы предполагает создание "
"новой таблицы, которая будет содержать отдельную запись для каждой "
"выполненной команды INSERT, UPDATE, DELETE. Этот подход можно рассматривать "
"как протоколирование изменений таблицы для аудита. <xref linkend=\"plpgsql-"
"trigger-audit-example\"/> показывает реализацию соответствующей триггерной "
"процедуры в <application>PL/pgSQL</application>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3988(title)
msgid "A <application>PL/pgSQL</application> Trigger Procedure For Auditing"
msgstr "Триггерная процедура для аудита в <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:3990(para)
msgid ""
"This example trigger ensures that any insert, update or delete of a row in "
"the <literal>emp</literal> table is recorded (i.e., audited) in the "
"<literal>emp_audit</literal> table. The current time and user name are "
"stamped into the row, together with the type of operation performed on it."
msgstr ""
"Триггер гарантирует, что любая команда на вставку, изменение или удаление "
"строки в таблице <literal>emp</literal> будет записана для аудита в таблице "
"<literal>emp_audit</literal>. Также записывается информация о пользователе, "
"выполнившем операцию, временной метке и типе операции."

#. +> REL_10
#: plpgsql.xml:3997(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE emp (\n"
"    empname           text NOT NULL,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    stamp             timestamp NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary integer\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n"
"    BEGIN\n"
"        --\n"
"        -- Create a row in emp_audit to reflect the operation performed on emp,\n"
"        -- making use of the special variable TG_OP to work out the operation.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n"
"        END IF;\n"
"        RETURN NULL; -- result is ignored since this is an AFTER trigger\n"
"    END;\n"
"$emp_audit$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit\n"
"AFTER INSERT OR UPDATE OR DELETE ON emp\n"
"    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();"
msgstr ""
"CREATE TABLE emp (\n"
"    empname           text NOT NULL,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    stamp             timestamp NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary integer\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n"
"    BEGIN\n"
"        --\n"
"        -- Создаём строку в emp_audit, которая отражает выполненную операцию,\n"
"        -- используя переменную TG_OP для определения типа операции.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n"
"        END IF;\n"
"        RETURN NULL; -- возвращаемое значение для триггера AFTER не имеет значения\n"
"    END;\n"
"$emp_audit$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit\n"
"AFTER INSERT OR UPDATE OR DELETE ON emp\n"
"    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4034(para)
msgid ""
"A variation of the previous example uses a view joining the main table to "
"the audit table, to show when each entry was last modified. This approach "
"still records the full audit trail of changes to the table, but also "
"presents a simplified view of the audit trail, showing just the last "
"modified timestamp derived from the audit trail for each entry. <xref "
"linkend=\"plpgsql-view-trigger-audit-example\"/> shows an example of an "
"audit trigger on a view in <application>PL/pgSQL</application>."
msgstr ""
"У предыдущего примера есть разновидность, которая использует представление, "
"соединяющее основную таблицу и таблицу аудита, для отображения даты "
"последнего изменения каждой строки. При этом подходе по-прежнему ведётся "
"полный журнал аудита в отдельной таблице, но также имеется представление с "
"упрощенным аудиторским следом. Это представление содержит временную метку, "
"которая вычисляется для каждой строки из данных аудиторской таблицы. <xref "
"linkend=\"plpgsql-view-trigger-audit-example\"/> показывает пример триггера "
"на представление для аудита в <application>PL/pgSQL</application>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4045(title)
msgid ""
"A <application>PL/pgSQL</application> View Trigger Procedure For Auditing"
msgstr ""
"Триггер на представление для аудита в <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4047(para)
msgid ""
"This example uses a trigger on the view to make it updatable, and ensure "
"that any insert, update or delete of a row in the view is recorded (i.e., "
"audited) in the <literal>emp_audit</literal> table. The current time and "
"user name are recorded, together with the type of operation performed, and "
"the view displays the last modified time of each row."
msgstr ""
"Триггер на представление используется для того, чтобы сделать это "
"представление изменяемым и гарантировать, что любая команда на вставку, "
"изменение или удаление строки в представлении будет записана для аудита в "
"таблицу <literal>emp_audit</literal>. Также записываются временная метка, "
"имя пользователя и тип выполняемой операции. Представление показывает дату "
"последнего изменения для каждой строки."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4055(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE emp (\n"
"    empname           text PRIMARY KEY,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary            integer,\n"
"    stamp             timestamp NOT NULL\n"
");\n"
"\n"
"CREATE VIEW emp_view AS\n"
"    SELECT e.empname,\n"
"           e.salary,\n"
"           max(ea.stamp) AS last_updated\n"
"      FROM emp e\n"
"      LEFT JOIN emp_audit ea ON ea.empname = e.empname\n"
"     GROUP BY 1, 2;\n"
"\n"
"CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$\n"
"    BEGIN\n"
"        --\n"
"        -- Perform the required operation on emp, and create a row in emp_audit\n"
"        -- to reflect the change made to emp.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            DELETE FROM emp WHERE empname = OLD.empname;\n"
"            IF NOT FOUND THEN RETURN NULL; END IF;\n"
"\n"
"            OLD.last_updated = now();\n"
"            INSERT INTO emp_audit VALUES('D', user, OLD.*);\n"
"            RETURN OLD;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;\n"
"            IF NOT FOUND THEN RETURN NULL; END IF;\n"
"\n"
"            NEW.last_updated = now();\n"
"            INSERT INTO emp_audit VALUES('U', user, NEW.*);\n"
"            RETURN NEW;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp VALUES(NEW.empname, NEW.salary);\n"
"\n"
"            NEW.last_updated = now();\n"
"            INSERT INTO emp_audit VALUES('I', user, NEW.*);\n"
"            RETURN NEW;\n"
"        END IF;\n"
"    END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit\n"
"INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view\n"
"    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();"
msgstr ""
"CREATE TABLE emp (\n"
"    empname           text PRIMARY KEY,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary            integer,\n"
"    stamp             timestamp NOT NULL\n"
");\n"
"\n"
"CREATE VIEW emp_view AS\n"
"    SELECT e.empname,\n"
"           e.salary,\n"
"           max(ea.stamp) AS last_updated\n"
"      FROM emp e\n"
"      LEFT JOIN emp_audit ea ON ea.empname = e.empname\n"
"     GROUP BY 1, 2;\n"
"\n"
"CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$\n"
"    BEGIN\n"
"        --\n"
"        -- Выполняем требуемую операцию в emp и создаем строку в emp_audit,\n"
"        -- которая отражает сделанную операцию.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            DELETE FROM emp WHERE empname = OLD.empname;\n"
"            IF NOT FOUND THEN RETURN NULL; END IF;\n"
"\n"
"            OLD.last_updated = now();\n"
"            INSERT INTO emp_audit VALUES('D', user, OLD.*);\n"
"            RETURN OLD;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;\n"
"            IF NOT FOUND THEN RETURN NULL; END IF;\n"
"\n"
"            NEW.last_updated = now();\n"
"            INSERT INTO emp_audit VALUES('U', user, NEW.*);\n"
"            RETURN NEW;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp VALUES(NEW.empname, NEW.salary);\n"
"\n"
"            NEW.last_updated = now();\n"
"            INSERT INTO emp_audit VALUES('I', user, NEW.*);\n"
"            RETURN NEW;\n"
"        END IF;\n"
"    END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit\n"
"INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view\n"
"    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4113(para)
msgid ""
"One use of triggers is to maintain a summary table of another table. The "
"resulting summary can be used in place of the original table for certain "
"queries &mdash; often with vastly reduced run times. This technique is "
"commonly used in Data Warehousing, where the tables of measured or observed "
"data (called fact tables) might be extremely large. <xref linkend=\"plpgsql-"
"trigger-summary-example\"/> shows an example of a trigger procedure in "
"<application>PL/pgSQL</application> that maintains a summary table for a "
"fact table in a data warehouse."
msgstr ""
"Один из вариантов использования триггеров это поддержание в актуальном "
"состоянии отдельной таблицы итогов для некоторой таблицы. В некоторых "
"случаях отдельная таблица с итогами может использоваться в запросах вместо "
"основной таблицы. При этом зачастую время выполнения запросов значительно "
"сокращается. Эта техника широко используется в хранилищах данных, где "
"таблицы фактов могут быть очень большими. <xref linkend=\"plpgsql-trigger-"
"summary-example\"/> показывает триггерную процедуру в <application>PL/pgSQL</"
"application>, которая поддерживает таблицу итогов для таблицы фактов в "
"хранилище данных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4127(title)
msgid ""
"A <application>PL/pgSQL</application> Trigger Procedure For Maintaining A "
"Summary Table"
msgstr ""
"Триггерная процедура в <application>PL/pgSQL</application> для поддержки "
"таблицы итогов"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4129(para)
msgid ""
"The schema detailed here is partly based on the <emphasis>Grocery Store </"
"emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis> by "
"Ralph Kimball."
msgstr ""
"Представленная здесь схема данных частично основана на примере "
"<emphasis>Grocery Store </emphasis> из книги <emphasis>The Data Warehouse "
"Toolkit</emphasis> (автор Ralph Kimball)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4135(programlisting)
#, no-wrap
msgid ""
"--\n"
"-- Main tables - time dimension and sales fact.\n"
"--\n"
"CREATE TABLE time_dimension (\n"
"    time_key                    integer NOT NULL,\n"
"    day_of_week                 integer NOT NULL,\n"
"    day_of_month                integer NOT NULL,\n"
"    month                       integer NOT NULL,\n"
"    quarter                     integer NOT NULL,\n"
"    year                        integer NOT NULL\n"
");\n"
"CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);\n"
"\n"
"CREATE TABLE sales_fact (\n"
"    time_key                    integer NOT NULL,\n"
"    product_key                 integer NOT NULL,\n"
"    store_key                   integer NOT NULL,\n"
"    amount_sold                 numeric(12,2) NOT NULL,\n"
"    units_sold                  integer NOT NULL,\n"
"    amount_cost                 numeric(12,2) NOT NULL\n"
");\n"
"CREATE INDEX sales_fact_time ON sales_fact(time_key);\n"
"\n"
"--\n"
"-- Summary table - sales by time.\n"
"--\n"
"CREATE TABLE sales_summary_bytime (\n"
"    time_key                    integer NOT NULL,\n"
"    amount_sold                 numeric(15,2) NOT NULL,\n"
"    units_sold                  numeric(12) NOT NULL,\n"
"    amount_cost                 numeric(15,2) NOT NULL\n"
");\n"
"CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);\n"
"\n"
"--\n"
"-- Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.\n"
"--\n"
"CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER\n"
"AS $maint_sales_summary_bytime$\n"
"    DECLARE\n"
"        delta_time_key          integer;\n"
"        delta_amount_sold       numeric(15,2);\n"
"        delta_units_sold        numeric(12);\n"
"        delta_amount_cost       numeric(15,2);\n"
"    BEGIN\n"
"\n"
"        -- Work out the increment/decrement amount(s).\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"\n"
"            delta_time_key = OLD.time_key;\n"
"            delta_amount_sold = -1 * OLD.amount_sold;\n"
"            delta_units_sold = -1 * OLD.units_sold;\n"
"            delta_amount_cost = -1 * OLD.amount_cost;\n"
"\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"\n"
"            -- forbid updates that change the time_key -\n"
"            -- (probably not too onerous, as DELETE + INSERT is how most\n"
"            -- changes will be made).\n"
"            IF ( OLD.time_key != NEW.time_key) THEN\n"
"                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',\n"
"                                                      OLD.time_key, NEW.time_key;\n"
"            END IF;\n"
"\n"
"            delta_time_key = OLD.time_key;\n"
"            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;\n"
"            delta_units_sold = NEW.units_sold - OLD.units_sold;\n"
"            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;\n"
"\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"\n"
"            delta_time_key = NEW.time_key;\n"
"            delta_amount_sold = NEW.amount_sold;\n"
"            delta_units_sold = NEW.units_sold;\n"
"            delta_amount_cost = NEW.amount_cost;\n"
"\n"
"        END IF;\n"
"\n"
"\n"
"        -- Insert or update the summary row with the new values.\n"
"        &lt;&lt;insert_update&gt;&gt;\n"
"        LOOP\n"
"            UPDATE sales_summary_bytime\n"
"                SET amount_sold = amount_sold + delta_amount_sold,\n"
"                    units_sold = units_sold + delta_units_sold,\n"
"                    amount_cost = amount_cost + delta_amount_cost\n"
"                WHERE time_key = delta_time_key;\n"
"\n"
"            EXIT insert_update WHEN found;\n"
"\n"
"            BEGIN\n"
"                INSERT INTO sales_summary_bytime (\n"
"                            time_key,\n"
"                            amount_sold,\n"
"                            units_sold,\n"
"                            amount_cost)\n"
"                    VALUES (\n"
"                            delta_time_key,\n"
"                            delta_amount_sold,\n"
"                            delta_units_sold,\n"
"                            delta_amount_cost\n"
"                           );\n"
"\n"
"                EXIT insert_update;\n"
"\n"
"            EXCEPTION\n"
"                WHEN UNIQUE_VIOLATION THEN\n"
"                    -- do nothing\n"
"            END;\n"
"        END LOOP insert_update;\n"
"\n"
"        RETURN NULL;\n"
"\n"
"    END;\n"
"$maint_sales_summary_bytime$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER maint_sales_summary_bytime\n"
"AFTER INSERT OR UPDATE OR DELETE ON sales_fact\n"
"    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();\n"
"\n"
"INSERT INTO sales_fact VALUES(1,1,1,10,3,15);\n"
"INSERT INTO sales_fact VALUES(1,2,1,20,5,35);\n"
"INSERT INTO sales_fact VALUES(2,2,1,40,15,135);\n"
"INSERT INTO sales_fact VALUES(2,3,1,10,1,13);\n"
"SELECT * FROM sales_summary_bytime;\n"
"DELETE FROM sales_fact WHERE product_key = 1;\n"
"SELECT * FROM sales_summary_bytime;\n"
"UPDATE sales_fact SET units_sold = units_sold * 2;\n"
"SELECT * FROM sales_summary_bytime;"
msgstr ""
"--\n"
"-- Основные таблицы: таблица измерений временных периодов и таблица фактов продаж\n"
"--\n"
"CREATE TABLE time_dimension (\n"
"    time_key                    integer NOT NULL,\n"
"    day_of_week                 integer NOT NULL,\n"
"    day_of_month                integer NOT NULL,\n"
"    month                       integer NOT NULL,\n"
"    quarter                     integer NOT NULL,\n"
"    year                        integer NOT NULL\n"
");\n"
"CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);\n"
"\n"
"CREATE TABLE sales_fact (\n"
"    time_key                    integer NOT NULL,\n"
"    product_key                 integer NOT NULL,\n"
"    store_key                   integer NOT NULL,\n"
"    amount_sold                 numeric(12,2) NOT NULL,\n"
"    units_sold                  integer NOT NULL,\n"
"    amount_cost                 numeric(12,2) NOT NULL\n"
");\n"
"CREATE INDEX sales_fact_time ON sales_fact(time_key);\n"
"\n"
"--\n"
"-- Таблица с итогами продаж по периодам\n"
"--\n"
"CREATE TABLE sales_summary_bytime (\n"
"    time_key                    integer NOT NULL,\n"
"    amount_sold                 numeric(15,2) NOT NULL,\n"
"    units_sold                  numeric(12) NOT NULL,\n"
"    amount_cost                 numeric(15,2) NOT NULL\n"
");\n"
"CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);\n"
"\n"
"--\n"
"-- Функция и триггер, обновляющие столбцы с итоговыми значениями при выполнении\n"
"-- команд INSERT, UPDATE, DELETE\n"
"--\n"
"CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER\n"
"AS $maint_sales_summary_bytime$\n"
"    DECLARE\n"
"        delta_time_key          integer;\n"
"        delta_amount_sold       numeric(15,2);\n"
"        delta_units_sold        numeric(12);\n"
"        delta_amount_cost       numeric(15,2);\n"
"    BEGIN\n"
"\n"
"        -- определим на сколько произошло увеличение/уменьшение количеств\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"\n"
"            delta_time_key = OLD.time_key;\n"
"            delta_amount_sold = -1 * OLD.amount_sold;\n"
"            delta_units_sold = -1 * OLD.units_sold;\n"
"            delta_amount_cost = -1 * OLD.amount_cost;\n"
"\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"\n"
"            -- запрещаем изменять time_key\n"
"            -- для таких изменений больше подходит DELETE + INSERT\n"
"            IF ( OLD.time_key != NEW.time_key) THEN\n"
"                RAISE EXCEPTION 'Запрещено изменение time_key : % -&gt; %',\n"
"                                                      OLD.time_key, NEW.time_key;\n"
"            END IF;\n"
"\n"
"            delta_time_key = OLD.time_key;\n"
"            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;\n"
"            delta_units_sold = NEW.units_sold - OLD.units_sold;\n"
"            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;\n"
"\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"\n"
"            delta_time_key = NEW.time_key;\n"
"            delta_amount_sold = NEW.amount_sold;\n"
"            delta_units_sold = NEW.units_sold;\n"
"            delta_amount_cost = NEW.amount_cost;\n"
"\n"
"        END IF;\n"
"\n"
"\n"
"        -- вставляем или обновляем строку в таблице итогов.\n"
"        &lt;&lt;insert_update&gt;&gt;\n"
"        LOOP\n"
"            UPDATE sales_summary_bytime\n"
"                SET amount_sold = amount_sold + delta_amount_sold,\n"
"                    units_sold = units_sold + delta_units_sold,\n"
"                    amount_cost = amount_cost + delta_amount_cost\n"
"                WHERE time_key = delta_time_key;\n"
"\n"
"            EXIT insert_update WHEN found;\n"
"\n"
"            BEGIN\n"
"                INSERT INTO sales_summary_bytime (\n"
"                            time_key,\n"
"                            amount_sold,\n"
"                            units_sold,\n"
"                            amount_cost)\n"
"                    VALUES (\n"
"                            delta_time_key,\n"
"                            delta_amount_sold,\n"
"                            delta_units_sold,\n"
"                            delta_amount_cost\n"
"                           );\n"
"\n"
"                EXIT insert_update;\n"
"\n"
"            EXCEPTION\n"
"                WHEN UNIQUE_VIOLATION THEN\n"
"                    -- ничего не делаем\n"
"            END;\n"
"        END LOOP insert_update;\n"
"\n"
"        RETURN NULL;\n"
"\n"
"    END;\n"
"$maint_sales_summary_bytime$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER maint_sales_summary_bytime\n"
"AFTER INSERT OR UPDATE OR DELETE ON sales_fact\n"
"    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();\n"
"\n"
"INSERT INTO sales_fact VALUES(1,1,1,10,3,15);\n"
"INSERT INTO sales_fact VALUES(1,2,1,20,5,35);\n"
"INSERT INTO sales_fact VALUES(2,2,1,40,15,135);\n"
"INSERT INTO sales_fact VALUES(2,3,1,10,1,13);\n"
"SELECT * FROM sales_summary_bytime;\n"
"DELETE FROM sales_fact WHERE product_key = 1;\n"
"SELECT * FROM sales_summary_bytime;\n"
"UPDATE sales_fact SET units_sold = units_sold * 2;\n"
"SELECT * FROM sales_summary_bytime;"

#. +> REL_10
#: plpgsql.xml:4268(para)
msgid ""
"<literal>AFTER</literal> triggers can also make use of <firstterm>transition "
"tables</firstterm> to inspect the entire set of rows changed by the "
"triggering statement. The <command>CREATE TRIGGER</command> command assigns "
"names to one or both transition tables, and then the function can refer to "
"those names as though they were read-only temporary tables. <xref linkend="
"\"plpgsql-trigger-audit-transition-example\"/> shows an example."
msgstr ""
"Триггеры <literal>AFTER</literal> также могут использовать "
"<firstterm>переходные таблицы</firstterm> для просмотра всего набора строк, "
"изменённых оператором, вызвавшим триггер. Команда <command>CREATE TRIGGER</"
"command> назначает имена одной или обеим переходным таблицам, а затем "
"функция может по этим именам обращаться к ним как к временным таблицам "
"только для чтения. Это иллюстрирует <xref linkend=\"plpgsql-trigger-audit-"
"transition-example\"/>."

#. +> REL_10
#: plpgsql.xml:4278(title)
msgid "Auditing with Transition Tables"
msgstr "Организация аудита с переходными таблицами"

#. +> REL_10
#: plpgsql.xml:4280(para)
msgid ""
"This example produces the same results as <xref linkend=\"plpgsql-trigger-"
"audit-example\"/>, but instead of using a trigger that fires for every row, "
"it uses a trigger that fires once per statement, after collecting the "
"relevant information in a transition table. This can be significantly faster "
"than the row-trigger approach when the invoking statement has modified many "
"rows. Notice that we must make a separate trigger declaration for each kind "
"of event, since the <literal>REFERENCING</literal> clauses must be different "
"for each case. But this does not stop us from using a single trigger "
"function if we choose. (In practice, it might be better to use three "
"separate functions and avoid the run-time tests on <varname>TG_OP</varname>.)"
msgstr ""
"Этот пример даёт тот же результат, что и <xref linkend=\"plpgsql-trigger-"
"audit-example\"/>, но вместо триггера, срабатывающего для каждой строки, в "
"нём используется триггер, срабатывающий единожды для оператора и получающий "
"нужные ему данные в переходной таблице. Это может быть гораздо быстрее, чем "
"вариант с построчным триггером, когда целевой оператор изменяет сразу "
"множество строк. Заметьте, что мы должны объявить отдельные триггеры для "
"каждого вида события, так как предложения <literal>REFERENCING</literal> в "
"каждом случае будут разными. Но это не мешает при желании использовать одну "
"триггерную функцию. (На практике может быть лучше использовать три отдельные "
"функции и не проверять <varname>TG_OP</varname> во время выполнения.)"

#. +> REL_10
#: plpgsql.xml:4294(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE emp (\n"
"    empname           text NOT NULL,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    stamp             timestamp NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary integer\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n"
"    BEGIN\n"
"        --\n"
"        -- Create rows in emp_audit to reflect the operations performed on emp,\n"
"        -- making use of the special variable TG_OP to work out the operation.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            INSERT INTO emp_audit\n"
"                SELECT 'D', now(), user, o.* FROM old_table o;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            INSERT INTO emp_audit\n"
"                SELECT 'U', now(), user, n.* FROM new_table n;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp_audit\n"
"                SELECT 'I', now(), user, n.* FROM new_table n;\n"
"        END IF;\n"
"        RETURN NULL; -- result is ignored since this is an AFTER trigger\n"
"    END;\n"
"$emp_audit$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit_ins\n"
"    AFTER INSERT ON emp\n"
"    REFERENCING NEW TABLE AS new_table\n"
"    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();\n"
"CREATE TRIGGER emp_audit_upd\n"
"    AFTER UPDATE ON emp\n"
"    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table\n"
"    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();\n"
"CREATE TRIGGER emp_audit_del\n"
"    AFTER DELETE ON emp\n"
"    REFERENCING OLD TABLE AS old_table\n"
"    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();"
msgstr ""
"CREATE TABLE emp (\n"
"    empname           text NOT NULL,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    stamp             timestamp NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary integer\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n"
"    BEGIN\n"
"        --\n"
"        -- Создаём строку в emp_audit, которая отражает выполненную операцию,\n"
"        -- используя переменную TG_OP для определения типа операции.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            INSERT INTO emp_audit\n"
"                SELECT 'D', now(), user, o.* FROM old_table o;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            INSERT INTO emp_audit\n"
"                SELECT 'U', now(), user, n.* FROM new_table n;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp_audit\n"
"                SELECT 'I', now(), user, n.* FROM new_table n;\n"
"        END IF;\n"
"        RETURN NULL; -- возвращаемое значение для триггера AFTER не имеет значения\n"
"    END;\n"
"$emp_audit$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit_ins\n"
"    AFTER INSERT ON emp\n"
"    REFERENCING NEW TABLE AS new_table\n"
"    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();\n"
"CREATE TRIGGER emp_audit_upd\n"
"    AFTER UPDATE ON emp\n"
"    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table\n"
"    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();\n"
"CREATE TRIGGER emp_audit_del\n"
"    AFTER DELETE ON emp\n"
"    REFERENCING OLD TABLE AS old_table\n"
"    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4346(title)
msgid "Triggers on Events"
msgstr "Триггеры событий"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4348(para)
msgid ""
"<application>PL/pgSQL</application> can be used to define <link linkend="
"\"event-triggers\">event triggers</link>. <productname>PostgreSQL</"
"productname> requires that a procedure that is to be called as an event "
"trigger must be declared as a function with no arguments and a return type "
"of <literal>event_trigger</literal>."
msgstr ""
"В <application>PL/pgSQL</application> можно создавать <link linkend=\"event-"
"triggers\">событийные триггеры</link>. <productname>PostgreSQL</productname> "
"требует, чтобы процедура, которая вызывается как событийный триггер, "
"объявлялась без аргументов и типом возвращаемого значения был "
"<literal>event_trigger</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4363(varname)
msgid "TG_EVENT"
msgstr "TG_EVENT"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4365(para)
msgid ""
"Data type <type>text</type>; a string representing the event the trigger is "
"fired for."
msgstr ""
"Тип данных <type>text</type>. Строка, содержащая событие, для которого "
"сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4373(varname)
msgid "TG_TAG"
msgstr "TG_TAG"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4375(para)
msgid ""
"Data type <type>text</type>; variable that contains the command tag for "
"which the trigger is fired."
msgstr ""
"Тип данных <type>text</type>. Переменная, содержащая тег команды, для "
"которой сработал триггер."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4356(para)
msgid ""
"When a <application>PL/pgSQL</application> function is called as an event "
"trigger, several special variables are created automatically in the top-"
"level block. They are: <placeholder-1/>"
msgstr ""
"Когда функция на <application>PL/pgSQL</application> вызывается как "
"событийный триггер, в блоке верхнего уровня автоматически создаются "
"несколько специальных переменных: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4384(para)
msgid ""
"<xref linkend=\"plpgsql-event-trigger-example\"/> shows an example of an "
"event trigger procedure in <application>PL/pgSQL</application>."
msgstr ""
"<xref linkend=\"plpgsql-event-trigger-example\"/> показывает пример "
"процедуры событийного триггера в <application>PL/pgSQL</application>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4390(title)
msgid "A <application>PL/pgSQL</application> Event Trigger Procedure"
msgstr "Процедура событийного триггера в <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4392(para)
msgid ""
"This example trigger simply raises a <literal>NOTICE</literal> message each "
"time a supported command is executed."
msgstr ""
"Этот пример триггера просто выдаёт сообщение <literal>NOTICE</literal> "
"каждый раз, когда выполняется поддерживаемая команда."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4397(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$\n"
"BEGIN\n"
"    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE snitch();"
msgstr ""
"CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$\n"
"BEGIN\n"
"    RAISE NOTICE 'Произошло событие: % %', tg_event, tg_tag;\n"
"END;\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE snitch();"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4412(title)
msgid "<application>PL/pgSQL</application> Under the Hood"
msgstr "<application>PL/pgSQL</application> изнутри"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4414(para)
msgid ""
"This section discusses some implementation details that are frequently "
"important for <application>PL/pgSQL</application> users to know."
msgstr ""
"В этом разделе обсуждаются некоторые детали реализации, которые "
"пользователям <application>PL/pgSQL</application> важно знать."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4420(title)
msgid "Variable Substitution"
msgstr "Подстановка переменных"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4429(programlisting)
#, no-wrap
msgid "INSERT INTO foo (foo) VALUES (foo);"
msgstr "INSERT INTO foo (foo) VALUES (foo);"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4422(para)
msgid ""
"SQL statements and expressions within a <application>PL/pgSQL</application> "
"function can refer to variables and parameters of the function. Behind the "
"scenes, <application>PL/pgSQL</application> substitutes query parameters for "
"such references. Parameters will only be substituted in places where a "
"parameter or column reference is syntactically allowed. As an extreme case, "
"consider this example of poor programming style: <placeholder-1/> The first "
"occurrence of <literal>foo</literal> must syntactically be a table name, so "
"it will not be substituted, even if the function has a variable named "
"<literal>foo</literal>. The second occurrence must be the name of a column "
"of the table, so it will not be substituted either. Only the third "
"occurrence is a candidate to be a reference to the function's variable."
msgstr ""
"SQL-операторы и выражения внутри функции на <application>PL/pgSQL</"
"application> могут ссылаться на переменные и параметры этой функции. За "
"кулисами <application>PL/pgSQL</application> заменяет параметры запросов для "
"таких ссылок. Параметры будут заменены только в местах, где параметр или "
"ссылка на столбец синтаксически допустимы. Как крайний случай, рассмотрим "
"следующий пример плохого стиля программирования: <placeholder-1/> Первый раз "
"<literal>foo</literal> появляется на том месте, где синтаксически должно "
"быть имя таблицы, поэтому замены не будет, даже если функция имеет "
"переменную <literal>foo</literal>. Второй раз <literal>foo</literal> "
"встречается там, где должно быть имя столбца таблицы, поэтому замены не "
"будет и здесь. Только третье вхождение <literal>foo</literal> является "
"кандидатом на то, чтобы быть ссылкой на переменную функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4441(para)
msgid ""
"<productname>PostgreSQL</productname> versions before 9.0 would try to "
"substitute the variable in all three cases, leading to syntax errors."
msgstr ""
"Версии <productname>PostgreSQL</productname> до 9.0 пытаются заменить "
"переменную во всех трёх случаях, что приводит к синтаксической ошибке."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4452(programlisting)
#, no-wrap
msgid "INSERT INTO dest (col) SELECT foo + bar FROM src;"
msgstr "INSERT INTO dest (col) SELECT foo + bar FROM src;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4447(para)
msgid ""
"Since the names of variables are syntactically no different from the names "
"of table columns, there can be ambiguity in statements that also refer to "
"tables: is a given name meant to refer to a table column, or a variable? "
"Let's change the previous example to <placeholder-1/> Here, <literal>dest</"
"literal> and <literal>src</literal> must be table names, and <literal>col</"
"literal> must be a column of <literal>dest</literal>, but <literal>foo</"
"literal> and <literal>bar</literal> might reasonably be either variables of "
"the function or columns of <literal>src</literal>."
msgstr ""
"Если имена переменных синтаксически не отличаются от названий столбцов "
"таблицы, то возможна двусмысленность и в ссылках на таблицы. Является ли "
"данное имя ссылкой на столбец таблицы или ссылкой на переменную? Изменим "
"предыдущий пример: <placeholder-1/> Здесь <literal>dest</literal> и "
"<literal>src</literal> должны быть именами таблиц, <literal>col</literal> "
"должен быть столбцом <literal>dest</literal>. Однако, <literal>foo</literal> "
"и <literal>bar</literal> могут быть как переменными функции, так и столбцами "
"<literal>src</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4461(para)
msgid ""
"By default, <application>PL/pgSQL</application> will report an error if a "
"name in a SQL statement could refer to either a variable or a table column. "
"You can fix such a problem by renaming the variable or column, or by "
"qualifying the ambiguous reference, or by telling <application>PL/pgSQL</"
"application> which interpretation to prefer."
msgstr ""
"По умолчанию, <application>PL/pgSQL</application> выдаст ошибку, если имя в "
"операторе SQL может относиться как к переменной, так и к столбцу таблицы. "
"Ситуацию можно исправить переименованием переменной, переименованием "
"столбца, точной квалификацией неоднозначной ссылки или указанием "
"<application>PL/pgSQL</application> машине, какую интерпретацию предпочесть."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4469(para)
msgid ""
"The simplest solution is to rename the variable or column. A common coding "
"rule is to use a different naming convention for <application>PL/pgSQL</"
"application> variables than you use for column names. For example, if you "
"consistently name function variables <literal>v_<replaceable>something</"
"replaceable></literal> while none of your column names start with "
"<literal>v_</literal>, no conflicts will occur."
msgstr ""
"Самое простое решение — переименовать переменную или столбец. Общее правило "
"кодирования предполагает использование различных соглашений о наименовании "
"для переменных <application>PL/pgSQL</application> и столбцов таблиц. "
"Например, если имена переменных всегда имеют вид "
"<literal>v_<replaceable>имя</replaceable></literal>, а имена столбцов "
"никогда не начинаются на <literal>v_</literal>, то конфликты исключены."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4485(programlisting)
#, no-wrap
msgid ""
"&lt;&lt;block&gt;&gt;\n"
"DECLARE\n"
"    foo int;\n"
"BEGIN\n"
"    foo := ...;\n"
"    INSERT INTO dest (col) SELECT block.foo + bar FROM src;"
msgstr ""
"&lt;&lt;block&gt;&gt;\n"
"DECLARE\n"
"    foo int;\n"
"BEGIN\n"
"    foo := ...;\n"
"    INSERT INTO dest (col) SELECT block.foo + bar FROM src;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4479(para)
msgid ""
"Alternatively you can qualify ambiguous references to make them clear. In "
"the above example, <literal>src.foo</literal> would be an unambiguous "
"reference to the table column. To create an unambiguous reference to a "
"variable, declare it in a labeled block and use the block's label (see <xref "
"linkend=\"plpgsql-structure\"/>). For example, <placeholder-1/> Here "
"<literal>block.foo</literal> means the variable even if there is a column "
"<literal>foo</literal> in <literal>src</literal>. Function parameters, as "
"well as special variables such as <literal>FOUND</literal>, can be qualified "
"by the function's name, because they are implicitly declared in an outer "
"block labeled with the function's name."
msgstr ""
"В качестве альтернативы можно дополнить имена неоднозначных ссылок, чтобы "
"сделать их точными. В приведённом выше примере <literal>src.foo</literal> "
"однозначно бы определялась, как ссылка на столбец таблицы. Чтобы сделать "
"однозначной ссылку на переменную, переменная должна быть объявлена в блоке с "
"меткой, и далее нужно использовать эту метку (см. <xref remap=\"4\" linkend="
"\"plpgsql-structure\"/>). Например: <placeholder-1/> Здесь <literal>block."
"foo</literal> ссылается на переменную, даже если в таблице <literal>src</"
"literal> есть столбец <literal>foo</literal>. Параметры функции, а также "
"специальные переменные, такие как <literal>FOUND</literal>, могут быть "
"дополнены именем функции, потому что они неявно объявлены во внешнем блоке, "
"метка которого совпадает с именем функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4500(para)
msgid ""
"Sometimes it is impractical to fix all the ambiguous references in a large "
"body of <application>PL/pgSQL</application> code. In such cases you can "
"specify that <application>PL/pgSQL</application> should resolve ambiguous "
"references as the variable (which is compatible with <application>PL/pgSQL</"
"application>'s behavior before <productname>PostgreSQL</productname> 9.0), "
"or as the table column (which is compatible with some other systems such as "
"<productname>Oracle</productname>)."
msgstr ""
"Иногда может быть не очень практичным исправлять таким способом все "
"неоднозначные ссылки в большом куске <application>PL/pgSQL</application> "
"кода. В таких случаях можно указать, чтобы <application>PL/pgSQL</"
"application> разрешал неоднозначные ссылки в пользу переменных (это "
"совместимо с <application>PL/pgSQL</application> до версии "
"<productname>PostgreSQL</productname> 9.0), или в пользу столбцов таблицы "
"(совместимо с некоторыми другими системами, такими как <productname>Oracle</"
"productname>)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4510(indexterm)
msgid ""
"<primary><varname>plpgsql.variable_conflict</varname> configuration "
"parameter</primary>"
msgstr ""
"<primary>параметр конфигурации <varname>plpgsql.variable_conflict</varname></"
"primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4514(para)
msgid ""
"To change this behavior on a system-wide basis, set the configuration "
"parameter <literal>plpgsql.variable_conflict</literal> to one of "
"<literal>error</literal>, <literal>use_variable</literal>, or "
"<literal>use_column</literal> (where <literal>error</literal> is the factory "
"default). This parameter affects subsequent compilations of statements in "
"<application>PL/pgSQL</application> functions, but not statements already "
"compiled in the current session. Because changing this setting can cause "
"unexpected changes in the behavior of <application>PL/pgSQL</application> "
"functions, it can only be changed by a superuser."
msgstr ""
"На уровне всей системы поведение <application>PL/pgSQL</application> "
"регулируется установкой конфигурационного параметра <literal>plpgsql."
"variable_conflict</literal>, имеющего значения: <literal>error</literal>, "
"<literal>use_variable</literal> или <literal>use_column</literal> "
"(<literal>error</literal> устанавливается по умолчанию при установке "
"системы). Изменение этого параметра влияет на все последующие компиляции "
"операторов в функциях на <application>PL/pgSQL</application>, но не на "
"операторы уже скомпилированные в текущей сессии. Так как изменение этого "
"параметра может привести к неожиданным изменениям в поведении функций на "
"<application>PL/pgSQL</application>, он может быть изменён только "
"суперпользователем."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4531(programlisting)
#, no-wrap
msgid ""
"#variable_conflict error\n"
"#variable_conflict use_variable\n"
"#variable_conflict use_column"
msgstr ""
"#variable_conflict error\n"
"#variable_conflict use_variable\n"
"#variable_conflict use_column"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4538(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n"
"    #variable_conflict use_variable\n"
"    DECLARE\n"
"        curtime timestamp := now();\n"
"    BEGIN\n"
"        UPDATE users SET last_modified = curtime, comment = comment\n"
"          WHERE users.id = id;\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n"
"    #variable_conflict use_variable\n"
"    DECLARE\n"
"        curtime timestamp := now();\n"
"    BEGIN\n"
"        UPDATE users SET last_modified = curtime, comment = comment\n"
"          WHERE users.id = id;\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4559(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n"
"    &lt;&lt;fn&gt;&gt;\n"
"    DECLARE\n"
"        curtime timestamp := now();\n"
"    BEGIN\n"
"        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment\n"
"          WHERE users.id = stamp_user.id;\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n"
"    &lt;&lt;fn&gt;&gt;\n"
"    DECLARE\n"
"        curtime timestamp := now();\n"
"    BEGIN\n"
"        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment\n"
"          WHERE users.id = stamp_user.id;\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4527(para)
msgid ""
"You can also set the behavior on a function-by-function basis, by inserting "
"one of these special commands at the start of the function text: "
"<placeholder-1/> These commands affect only the function they are written "
"in, and override the setting of <literal>plpgsql.variable_conflict</"
"literal>. An example is <placeholder-2/> In the <literal>UPDATE</literal> "
"command, <literal>curtime</literal>, <literal>comment</literal>, and "
"<literal>id</literal> will refer to the function's variable and parameters "
"whether or not <literal>users</literal> has columns of those names. Notice "
"that we had to qualify the reference to <literal>users.id</literal> in the "
"<literal>WHERE</literal> clause to make it refer to the table column. But we "
"did not have to qualify the reference to <literal>comment</literal> as a "
"target in the <literal>UPDATE</literal> list, because syntactically that "
"must be a column of <literal>users</literal>. We could write the same "
"function without depending on the <literal>variable_conflict</literal> "
"setting in this way: <placeholder-3/>"
msgstr ""
"Поведение <application>PL/pgSQL</application> можно изменять для каждой "
"отдельной функции, если добавить в начало функции одну из этих специальных "
"команд: <placeholder-1/> Эти команды влияют только на функцию, в которой они "
"записаны и перекрывают действие <literal>plpgsql.variable_conflict</"
"literal>. Пример: <placeholder-2/> В команде <literal>UPDATE</literal>, "
"<literal>curtime</literal>, <literal>comment</literal> и <literal>id</"
"literal> будут ссылаться на переменные и параметры функции вне зависимости "
"от того, есть ли столбцы с такими именами в таблице <literal>users</"
"literal>. Обратите внимание, что нужно дополнить именем таблицы ссылку на "
"<literal>users.id</literal> в предложении <literal>WHERE</literal>, чтобы "
"она ссылалась на столбец таблицы. При этом необязательно дополнять ссылку на "
"<literal>comment</literal> в левой части списка <literal>UPDATE</literal>, "
"так как синтаксически в этом месте должно быть имя столбца таблицы "
"<literal>users</literal>. Эту функцию можно было бы записать и без "
"зависимости от значения <literal>variable_conflict</literal>: <placeholder-3/"
">"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4572(para)
msgid ""
"Variable substitution does not happen in the command string given to "
"<command>EXECUTE</command> or one of its variants. If you need to insert a "
"varying value into such a command, do so as part of constructing the string "
"value, or use <literal>USING</literal>, as illustrated in <xref linkend="
"\"plpgsql-statements-executing-dyn\"/>."
msgstr ""
"Замена переменных не происходит в строке, исполняемой командой "
"<command>EXECUTE</command> или её вариантом. Если нужно вставлять "
"изменяющиеся значения в такую команду, то это делается либо при построении "
"самой командной строки или с использованием <literal>USING</literal>, как "
"показано в <xref remap=\"6\" linkend=\"plpgsql-statements-executing-dyn\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4580(para)
msgid ""
"Variable substitution currently works only in <command>SELECT</command>, "
"<command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</"
"command> commands, because the main SQL engine allows query parameters only "
"in these commands. To use a non-constant name or value in other statement "
"types (generically called utility statements), you must construct the "
"utility statement as a string and <command>EXECUTE</command> it."
msgstr ""
"Замена переменных в настоящее время работает только в командах "
"<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</"
"command> и <command>DELETE</command>, потому что основная SQL машина "
"допускает использование параметров запроса только в этих командах. Чтобы "
"использовать изменяемые имена или значения в других типах операторов (обычно "
"называются утилиты), необходимо построить текст команды в виде строки и "
"выполнить её в <command>EXECUTE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4592(title)
msgid "Plan Caching"
msgstr "Кеширование плана"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4594(para)
msgid ""
"The <application>PL/pgSQL</application> interpreter parses the function's "
"source text and produces an internal binary instruction tree the first time "
"the function is called (within each session). The instruction tree fully "
"translates the <application>PL/pgSQL</application> statement structure, but "
"individual <acronym>SQL</acronym> expressions and <acronym>SQL</acronym> "
"commands used in the function are not translated immediately."
msgstr ""
"Интерпретатор <application>PL/pgSQL</application> анализирует исходный текст "
"функции и строит внутреннее бинарное дерево инструкций при первом вызове "
"функции (для каждой сессии). В дерево инструкций полностью переводится вся "
"структура операторов <application>PL/pgSQL</application>, но для выражений и "
"команд <acronym>SQL</acronym>, используемых в функции, это происходит не "
"сразу."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4605(indexterm)
msgid "<primary>preparing a query</primary> <secondary>in PL/pgSQL</secondary>"
msgstr ""
"<primary>подготовка запроса</primary> <secondary>в PL/pgSQL</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4604(para)
msgid ""
"<placeholder-1/> As each expression and <acronym>SQL</acronym> command is "
"first executed in the function, the <application>PL/pgSQL</application> "
"interpreter parses and analyzes the command to create a prepared statement, "
"using the <acronym>SPI</acronym> manager's <function>SPI_prepare</function> "
"function. Subsequent visits to that expression or command reuse the prepared "
"statement. Thus, a function with conditional code paths that are seldom "
"visited will never incur the overhead of analyzing those commands that are "
"never executed within the current session. A disadvantage is that errors in "
"a specific expression or command cannot be detected until that part of the "
"function is reached in execution. (Trivial syntax errors will be detected "
"during the initial parsing pass, but anything deeper will not be detected "
"until execution.)"
msgstr ""
"<placeholder-1/> При первом выполнении в функции каждого выражения или "
"команды <acronym>SQL</acronym> интерпретатор <application>PL/pgSQL</"
"application> разбирает и анализирует команду для создания подготовленного к "
"выполнению оператора с помощью функции <function>SPI_prepare</function> "
"менеджера интерфейса программирования сервера. Последующие обращения к этому "
"выражению или команде повторно используют подготовленный к выполнению "
"оператор. Таким образом, <acronym>SQL</acronym>-команды, находящиеся в редко "
"посещаемой ветке кода условного оператора, не несут накладных расходов на "
"разбор команд, если они так и не будут выполнены в текущей сессии. Здесь "
"есть недостаток, заключающийся в том, что ошибки в определённом выражении "
"или команде не могут быть обнаружены, пока выполнение не дойдёт до этой "
"части функции. (Тривиальные синтаксические ошибки обнаружатся в ходе "
"первоначального разбора, но ничего более серьёзного не будет обнаружено до "
"исполнения.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4625(para)
msgid ""
"<application>PL/pgSQL</application> (or more precisely, the SPI manager) can "
"furthermore attempt to cache the execution plan associated with any "
"particular prepared statement. If a cached plan is not used, then a fresh "
"execution plan is generated on each visit to the statement, and the current "
"parameter values (that is, <application>PL/pgSQL</application> variable "
"values) can be used to optimize the selected plan. If the statement has no "
"parameters, or is executed many times, the SPI manager will consider "
"creating a <firstterm>generic</firstterm> plan that is not dependent on "
"specific parameter values, and caching that for re-use. Typically this will "
"happen only if the execution plan is not very sensitive to the values of the "
"<application>PL/pgSQL</application> variables referenced in it. If it is, "
"generating a plan each time is a net win. See <xref linkend=\"sql-prepare\"/"
"> for more information about the behavior of prepared statements."
msgstr ""
"Кроме того, <application>PL/pgSQL</application> (точнее, менеджер интерфейса "
"программирования сервера) будет пытаться кешировать план выполнения для "
"любого подготовленного к исполнению оператора. При каждом вызове оператора, "
"если не используется план из кеша, генерируется новый план выполнения, и "
"текущие значения параметров (то есть значения переменных <application>PL/"
"pgSQL</application>) могут быть использованы для оптимизации нового плана. "
"Если оператор не имеет параметров или выполняется много раз, менеджер "
"интерфейса программирования сервера рассмотрит вопрос о создании и "
"кешировании (для повторного использования) общего плана, не зависящего от "
"значений параметров. Как правило, это происходит в тех случаях, когда план "
"выполнения не очень чувствителен к имеющимся ссылкам на значения переменных "
"<application>PL/pgSQL</application>. В противном случае, выгоднее каждый раз "
"формировать новый план. Более подробно поведение подготовленных операторов "
"рассматривается в <xref remap=\"6\" linkend=\"sql-prepare\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4642(para)
msgid ""
"Because <application>PL/pgSQL</application> saves prepared statements and "
"sometimes execution plans in this way, SQL commands that appear directly in "
"a <application>PL/pgSQL</application> function must refer to the same tables "
"and columns on every execution; that is, you cannot use a parameter as the "
"name of a table or column in an SQL command. To get around this restriction, "
"you can construct dynamic commands using the <application>PL/pgSQL</"
"application> <command>EXECUTE</command> statement &mdash; at the price of "
"performing new parse analysis and constructing a new execution plan on every "
"execution."
msgstr ""
"Чтобы <application>PL/pgSQL</application> мог сохранять подготовленные "
"операторы и планы выполнения, команды SQL в коде <application>PL/pgSQL</"
"application>, должны использовать одни и те же таблицы и столбцы при каждом "
"исполнении. А это значит, что в SQL-командах нельзя использовать названия "
"таблиц и столбцов в качестве параметров. Чтобы обойти это ограничение, нужно "
"построить динамическую команду для оператора <application>PL/pgSQL</"
"application> <command>EXECUTE</command> &mdash; ценой будет разбор и "
"построение нового плана выполнения при каждом вызове."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4655(para)
msgid ""
"The mutable nature of record variables presents another problem in this "
"connection. When fields of a record variable are used in expressions or "
"statements, the data types of the fields must not change from one call of "
"the function to the next, since each expression will be analyzed using the "
"data type that is present when the expression is first reached. "
"<command>EXECUTE</command> can be used to get around this problem when "
"necessary."
msgstr ""
"Изменчивая природа переменных типа <type>record</type> представляет ещё одну "
"проблему в этой связи. Когда поля переменной типа <type>record</type> "
"используются в выражениях или операторах, типы данных полей не должны "
"меняться от одного вызова функции к другому, так как при анализе каждого "
"выражения будет использоваться тот тип данных, который присутствовал при "
"первом вызове. При необходимости можно использовать <command>EXECUTE</"
"command> для решения этой проблемы."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4665(para)
msgid ""
"If the same function is used as a trigger for more than one table, "
"<application>PL/pgSQL</application> prepares and caches statements "
"independently for each such table &mdash; that is, there is a cache for each "
"trigger function and table combination, not just for each function. This "
"alleviates some of the problems with varying data types; for instance, a "
"trigger function will be able to work successfully with a column named "
"<literal>key</literal> even if it happens to have different types in "
"different tables."
msgstr ""
"Если функция используется в качестве триггера более чем для одной таблицы, "
"<application>PL/pgSQL</application> независимо подготавливает и кеширует "
"операторы для каждой такой таблицы. То есть создаётся кеш для каждой "
"комбинации триггерная функция + таблица, а не только для каждой функции. Это "
"устраняет некоторые проблемы, связанные с различными типами данных. "
"Например, триггерная функция сможет успешно работать со столбцом "
"<literal>key</literal>, даже если в разных таблицах этот столбец имеет "
"разные типы данных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4676(para)
msgid ""
"Likewise, functions having polymorphic argument types have a separate "
"statement cache for each combination of actual argument types they have been "
"invoked for, so that data type differences do not cause unexpected failures."
msgstr ""
"Таким же образом, функции с полиморфными типами аргументов имеют отдельный "
"кеш для каждой комбинации фактических типов аргументов, так что различия "
"типов данных не вызывают неожиданных сбоев."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4688(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$\n"
"    BEGIN\n"
"        INSERT INTO logtable VALUES (logtxt, 'now');\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$\n"
"    BEGIN\n"
"        INSERT INTO logtable VALUES (logtxt, 'now');\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4698(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$\n"
"    DECLARE\n"
"        curtime timestamp;\n"
"    BEGIN\n"
"        curtime := 'now';\n"
"        INSERT INTO logtable VALUES (logtxt, curtime);\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$\n"
"    DECLARE\n"
"        curtime timestamp;\n"
"    BEGIN\n"
"        curtime := 'now';\n"
"        INSERT INTO logtable VALUES (logtxt, curtime);\n"
"    END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4683(para)
msgid ""
"Statement caching can sometimes have surprising effects on the "
"interpretation of time-sensitive values. For example there is a difference "
"between what these two functions do: <placeholder-1/> and: <placeholder-2/>"
msgstr ""
"Кеширование операторов иногда приводит к неожиданным эффектам при "
"интерпретации чувствительных ко времени значений. Например, есть разница "
"между тем, что делают эти две функции: <placeholder-1/> и <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4710(para)
msgid ""
"In the case of <function>logfunc1</function>, the <productname>PostgreSQL</"
"productname> main parser knows when analyzing the <command>INSERT</command> "
"that the string <literal>'now'</literal> should be interpreted as "
"<type>timestamp</type>, because the target column of <classname>logtable</"
"classname> is of that type. Thus, <literal>'now'</literal> will be converted "
"to a <type>timestamp</type> constant when the <command>INSERT</command> is "
"analyzed, and then used in all invocations of <function>logfunc1</function> "
"during the lifetime of the session. Needless to say, this isn't what the "
"programmer wanted. A better idea is to use the <literal>now()</literal> or "
"<literal>current_timestamp</literal> function."
msgstr ""
"В случае <function>logfunc1</function>, при анализе <command>INSERT</"
"command>, основной анализатор <productname>PostgreSQL</productname> знает, "
"что строку <literal>'now'</literal> следует толковать как <type>timestamp</"
"type>, потому что целевой столбец таблицы <classname>logtable</classname> "
"имеет такой тип данных. Таким образом, <literal>'now'</literal> будет "
"преобразовано в константу <type>timestamp</type> при анализе "
"<command>INSERT</command>, а затем эта константа будет использоваться в "
"последующих вызовах <function>logfunc1</function> в течение всей сессии. "
"Разумеется, это не то, что хотел программист. Лучше было бы использовать "
"функцию <literal>now()</literal> или <literal>current_timestamp</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4726(para)
msgid ""
"In the case of <function>logfunc2</function>, the <productname>PostgreSQL</"
"productname> main parser does not know what type <literal>'now'</literal> "
"should become and therefore it returns a data value of type <type>text</"
"type> containing the string <literal>now</literal>. During the ensuing "
"assignment to the local variable <varname>curtime</varname>, the "
"<application>PL/pgSQL</application> interpreter casts this string to the "
"<type>timestamp</type> type by calling the <function>text_out</function> and "
"<function>timestamp_in</function> functions for the conversion. So, the "
"computed time stamp is updated on each execution as the programmer expects. "
"Even though this happens to work as expected, it's not terribly efficient, "
"so use of the <literal>now()</literal> function would still be a better idea."
msgstr ""
"В случае <function>logfunc2</function>, основной анализатор "
"<productname>PostgreSQL</productname> не знает, какого типа будет "
"<literal>'now'</literal> и поэтому возвращает значение типа <type>text</"
"type>, содержащее строку <literal>now</literal>. При последующем присвоении "
"локальной переменной <varname>curtime</varname> интерпретатор "
"<application>PL/pgSQL</application> приводит эту строку к типу "
"<type>timestamp</type>, вызывая функции <function>text_out</function> и "
"<function>timestamp_in</function>. Таким образом, метка времени будет "
"обновляться при каждом выполнении, как и ожидается программистом. И хотя всё "
"работает как ожидалось, это ужасно неэффективно, поэтому использование "
"функции <literal>now()</literal> по-прежнему значительно лучше."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4747(title)
msgid "Tips for Developing in <application>PL/pgSQL</application>"
msgstr "Советы по разработке на <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4758(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$\n"
"          ....\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$\n"
"          ....\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4749(para)
msgid ""
"One good way to develop in <application>PL/pgSQL</application> is to use the "
"text editor of your choice to create your functions, and in another window, "
"use <application>psql</application> to load and test those functions. If you "
"are doing it this way, it is a good idea to write the function using "
"<command>CREATE OR REPLACE FUNCTION</command>. That way you can just reload "
"the file to update the function definition. For example: <placeholder-1/>"
msgstr ""
"Хороший способ разрабатывать на <application>PL/pgSQL</application> "
"заключается в том, чтобы в одном окне с текстовым редактором по выбору "
"создавать тексты функций, а в другом окне с <application>psql</application> "
"загружать и тестировать эти функции. В таком случае удобно записывать "
"функцию, используя <command>CREATE OR REPLACE FUNCTION</command>. Таким "
"образом, можно легко загрузить файл для обновления определения функции. "
"Например: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4768(programlisting)
#, no-wrap
msgid "\\i filename.sql"
msgstr "\\i filename.sql"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4765(para)
msgid ""
"While running <application>psql</application>, you can load or reload such a "
"function definition file with: <placeholder-1/> and then immediately issue "
"SQL commands to test the function."
msgstr ""
"В <application>psql</application>, можно загрузить или перезагрузить такой "
"файл определения функции, выполнив: <placeholder-1/> а затем сразу выполнять "
"команды SQL для тестирования функции."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4774(para)
msgid ""
"Another good way to develop in <application>PL/pgSQL</application> is with a "
"GUI database access tool that facilitates development in a procedural "
"language. One example of such a tool is <application>pgAdmin</application>, "
"although others exist. These tools often provide convenient features such as "
"escaping single quotes and making it easier to recreate and debug functions."
msgstr ""
"Ещё один хороший способ разрабатывать на <application>PL/pgSQL</application> "
"связан с использованием GUI инструментов, облегчающих разработку на "
"процедурном языке. Один из примеров такого инструмента <application>pgAdmin</"
"application>, хотя есть и другие. Такие инструменты часто предоставляют "
"удобные возможности, такие как экранирование одинарных кавычек, отладка и "
"повторное создание функций."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4784(title)
msgid "Handling of Quotation Marks"
msgstr "Обработка кавычек"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4803(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$\n"
"          ....\n"
"$PROC$ LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$\n"
"          ....\n"
"$PROC$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4786(para)
msgid ""
"The code of a <application>PL/pgSQL</application> function is specified in "
"<command>CREATE FUNCTION</command> as a string literal. If you write the "
"string literal in the ordinary way with surrounding single quotes, then any "
"single quotes inside the function body must be doubled; likewise any "
"backslashes must be doubled (assuming escape string syntax is used). "
"Doubling quotes is at best tedious, and in more complicated cases the code "
"can become downright incomprehensible, because you can easily find yourself "
"needing half a dozen or more adjacent quote marks. It's recommended that you "
"instead write the function body as a <quote>dollar-quoted</quote> string "
"literal (see <xref linkend=\"sql-syntax-dollar-quoting\"/>). In the dollar-"
"quoting approach, you never double any quote marks, but instead take care to "
"choose a different dollar-quoting delimiter for each level of nesting you "
"need. For example, you might write the <command>CREATE FUNCTION</command> "
"command as: <placeholder-1/> Within this, you might use quote marks for "
"simple literal strings in SQL commands and <literal>$$</literal> to delimit "
"fragments of SQL commands that you are assembling as strings. If you need to "
"quote text that includes <literal>$$</literal>, you could use <literal>$Q$</"
"literal>, and so on."
msgstr ""
"Код функции на <application>PL/pgSQL</application> указывается в команде "
"<command>CREATE FUNCTION</command> в виде строки. Если писать строку в "
"обычном порядке, внутри одинарных кавычек, то любой символ одинарной кавычки "
"должен быть удвоен, также как и должен быть удвоен каждый знак обратной "
"косой черты (если используется синтаксис с экранированием в строках). "
"Удвоение кавычек в лучшем случае утомительно, а в более сложных случаях код "
"может стать совершенно непонятным, так как легко может потребоваться "
"полудюжина или более кавычек идущих подряд. Вместо этого при создании тела "
"функции рекомендуется использовать знаки доллара в качестве кавычек (см. "
"<xref remap=\"4\" linkend=\"sql-syntax-dollar-quoting\"/>). При таком "
"подходе никогда не потребуется дублировать кавычки, но придётся позаботиться "
"о том, чтобы иметь разные долларовые разделители для каждого уровня "
"вложенности. Например, команду <command>CREATE FUNCTION</command> можно "
"записать так: <placeholder-1/> Внутри можно использовать кавычки для простых "
"текстовых строк и <literal>$$</literal> для разграничения фрагментов SQL-"
"команды, собираемой из отдельных строк. Если нужно взять в кавычки текст, "
"который включает <literal>$$</literal>, можно использовать <literal>$Q$</"
"literal>, и так далее."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4814(para)
msgid ""
"The following chart shows what you have to do when writing quote marks "
"without dollar quoting. It might be useful when translating pre-dollar "
"quoting code into something more comprehensible."
msgstr ""
"Следующая таблица показывает, как применяются знаки кавычек, если не "
"используется экранирование долларами. Это может быть полезно при переводе "
"кода, не использующего экранирование знаками доллара, в нечто более понятное."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4822(term)
msgid "1 quotation mark"
msgstr "1 кавычка"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4826(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION foo() RETURNS integer AS '\n"
"          ....\n"
"' LANGUAGE plpgsql;"
msgstr ""
"CREATE FUNCTION foo() RETURNS integer AS '\n"
"          ....\n"
"' LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4824(para)
msgid ""
"To begin and end the function body, for example: <placeholder-1/> Anywhere "
"within a single-quoted function body, quote marks <emphasis>must</emphasis> "
"appear in pairs."
msgstr ""
"В начале и конце тела функции, например: <placeholder-1/> Внутри такой "
"функции любая кавычка <emphasis>должна</emphasis> дублироваться."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4838(term)
msgid "2 quotation marks"
msgstr "2 кавычки"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4842(programlisting)
#, no-wrap
msgid ""
"a_output := ''Blah'';\n"
"SELECT * FROM users WHERE f_name=''foobar'';"
msgstr ""
"a_output := ''Blah'';\n"
"SELECT * FROM users WHERE f_name=''foobar'';"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4847(programlisting)
#, no-wrap
msgid ""
"a_output := 'Blah';\n"
"SELECT * FROM users WHERE f_name='foobar';"
msgstr ""
"a_output := 'Blah';\n"
"SELECT * FROM users WHERE f_name='foobar';"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4840(para)
msgid ""
"For string literals inside the function body, for example: <placeholder-1/> "
"In the dollar-quoting approach, you'd just write: <placeholder-2/> which is "
"exactly what the <application>PL/pgSQL</application> parser would see in "
"either case."
msgstr ""
"Для строковых литералов внутри тела функции, например: <placeholder-1/> При "
"использовании знаков доллара можно просто написать: <placeholder-2/> и "
"именно это увидит исполнитель <application>PL/pgSQL</application> в обоих "
"случаях."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4858(term)
msgid "4 quotation marks"
msgstr "4 кавычки"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4863(programlisting)
#, no-wrap
msgid "a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''"
msgstr "a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4860(para)
msgid ""
"When you need a single quotation mark in a string constant inside the "
"function body, for example: <placeholder-1/> The value actually appended to "
"<literal>a_output</literal> would be: <literal> AND name LIKE 'foobar' AND "
"xyz</literal>."
msgstr ""
"Когда нужны одинарные кавычки в строковой константе внутри тела функции, "
"например: <placeholder-1/> К <literal>a_output</literal> будет добавлено: "
"<literal> AND name LIKE 'foobar' AND xyz</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4871(programlisting)
#, no-wrap
msgid "a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$"
msgstr "a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4869(para)
msgid ""
"In the dollar-quoting approach, you'd write: <placeholder-1/> being careful "
"that any dollar-quote delimiters around this are not just <literal>$$</"
"literal>."
msgstr ""
"При использовании знаков доллара это записывается так: <placeholder-1/> "
"будьте внимательны, при этом не должно быть внешнего долларового разделителя "
"<literal>$$</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4881(term)
msgid "6 quotation marks"
msgstr "6 кавычек"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4886(programlisting)
#, no-wrap
msgid "a_output := a_output || '' AND name LIKE ''''foobar''''''"
msgstr "a_output := a_output || '' AND name LIKE ''''foobar''''''"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4883(para)
msgid ""
"When a single quotation mark in a string inside the function body is "
"adjacent to the end of that string constant, for example: <placeholder-1/> "
"The value appended to <literal>a_output</literal> would then be: <literal> "
"AND name LIKE 'foobar'</literal>."
msgstr ""
"Когда нужны одинарные кавычки в строковой константе внутри тела функции, при "
"этом кавычки находятся в конце строковой константы. Например: <placeholder-1/"
"> К <literal>a_output</literal> будет добавлено: <literal> AND name LIKE "
"'foobar'</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4894(programlisting)
#, no-wrap
msgid "a_output := a_output || $$ AND name LIKE 'foobar'$$"
msgstr "a_output := a_output || $$ AND name LIKE 'foobar'$$"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4892(para)
msgid "In the dollar-quoting approach, this becomes: <placeholder-1/>"
msgstr ""
"При использовании знаков доллара это записывается так: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4902(term)
msgid "10 quotation marks"
msgstr "10 кавычек"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4911(programlisting)
#, no-wrap
msgid ""
"a_output := a_output || '' if v_'' ||\n"
"    referrer_keys.kind || '' like ''''''''''\n"
"    || referrer_keys.key_string || ''''''''''\n"
"    then return ''''''  || referrer_keys.referrer_type\n"
"    || ''''''; end if;'';"
msgstr ""
"a_output := a_output || '' if v_'' ||\n"
"    referrer_keys.kind || '' like ''''''''''\n"
"    || referrer_keys.key_string || ''''''''''\n"
"    then return ''''''  || referrer_keys.referrer_type\n"
"    || ''''''; end if;'';"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4919(programlisting)
#, no-wrap
msgid "if v_... like ''...'' then return ''...''; end if;"
msgstr "if v_... like ''...'' then return ''...''; end if;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4904(para)
msgid ""
"When you want two single quotation marks in a string constant (which "
"accounts for 8 quotation marks) and this is adjacent to the end of that "
"string constant (2 more). You will probably only need that if you are "
"writing a function that generates other functions, as in <xref linkend="
"\"plpgsql-porting-ex2\"/>. For example: <placeholder-1/> The value of "
"<literal>a_output</literal> would then be: <placeholder-2/>"
msgstr ""
"Когда нужны две одиночные кавычки в строковой константе (это уже 8 кавычек), "
"примыкающие к концу строковой константы (ещё 2). Вероятно, такое может "
"понадобиться при разработке функции, которая генерирует другие функции, как "
"показано в <xref remap=\"6\" linkend=\"plpgsql-porting-ex2\"/>. Например: "
"<placeholder-1/> Значение <literal>a_output</literal> затем будет: "
"<placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4925(programlisting)
#, no-wrap
msgid ""
"a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$\n"
"    || referrer_keys.key_string || $$'\n"
"    then return '$$  || referrer_keys.referrer_type\n"
"    || $$'; end if;$$;"
msgstr ""
"a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$\n"
"    || referrer_keys.key_string || $$'\n"
"    then return '$$  || referrer_keys.referrer_type\n"
"    || $$'; end if;$$;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4923(para)
msgid ""
"In the dollar-quoting approach, this becomes: <placeholder-1/> where we "
"assume we only need to put single quote marks into <literal>a_output</"
"literal>, because it will be re-quoted before use."
msgstr ""
"При использовании знаков доллара: <placeholder-1/> где предполагается, что "
"нужны только одиночные кавычки в <literal>a_output</literal>, так как "
"потребуется повторное взятие в кавычки перед использованием."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4940(title)
msgid "Additional Compile-time Checks"
msgstr "Дополнительные проверки во время компиляции"

#. +> REL_10
#: plpgsql.xml:4942(para)
msgid ""
"To aid the user in finding instances of simple but common problems before "
"they cause harm, <application>PL/pgSQL</application> provides additional "
"<replaceable>checks</replaceable>. When enabled, depending on the "
"configuration, they can be used to emit either a <literal>WARNING</literal> "
"or an <literal>ERROR</literal> during the compilation of a function. A "
"function which has received a <literal>WARNING</literal> can be executed "
"without producing further messages, so you are advised to test in a separate "
"development environment."
msgstr ""
"Чтобы помочь найти и предупредить простые, но часто встречающиеся проблемы, "
"<application>PL/PgSQL</application> предоставляет дополнительные "
"<replaceable>проверки</replaceable>. Если они включены в конфигурации, то во "
"время компиляции функций будут выдаваться дополнительные сообщения "
"<literal>WARNING</literal> или ошибки <literal>ERROR</literal>. Функция, при "
"компиляции которой выдавалось <literal>WARNING</literal>, при последующем "
"выполнении не будет выдавать это сообщение и её можно протестировать в "
"отдельной среде разработки."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4961(varname)
msgid "shadowed_variables"
msgstr "shadowed_variables"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4963(para)
msgid "Checks if a declaration shadows a previously defined variable."
msgstr ""
"Проверяет, что объявление новой переменной не скрывает ранее объявленную "
"переменную."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4972(programlisting)
#, no-wrap
msgid ""
"SET plpgsql.extra_warnings TO 'shadowed_variables';\n"
"\n"
"CREATE FUNCTION foo(f1 int) RETURNS int AS $$\n"
"DECLARE\n"
"f1 int;\n"
"BEGIN\n"
"RETURN f1;\n"
"END\n"
"$$ LANGUAGE plpgsql;\n"
"WARNING:  variable \"f1\" shadows a previously defined variable\n"
"LINE 3: f1 int;\n"
"        ^\n"
"CREATE FUNCTION"
msgstr ""
"SET plpgsql.extra_warnings TO 'shadowed_variables';\n"
"\n"
"CREATE FUNCTION foo(f1 int) RETURNS int AS $$\n"
"DECLARE\n"
"f1 int;\n"
"BEGIN\n"
"RETURN f1;\n"
"END\n"
"$$ LANGUAGE plpgsql;\n"
"WARNING:  variable \"f1\" shadows a previously defined variable\n"
"LINE 3: f1 int;\n"
"        ^\n"
"CREATE FUNCTION"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4952(para)
msgid ""
"These additional checks are enabled through the configuration variables "
"<varname>plpgsql.extra_warnings</varname> for warnings and <varname>plpgsql."
"extra_errors</varname> for errors. Both can be set either to a comma-"
"separated list of checks, <literal>\"none\"</literal> or <literal>\"all\"</"
"literal>. The default is <literal>\"none\"</literal>. Currently the list of "
"available checks includes only one: <placeholder-1/> The following example "
"shows the effect of <varname>plpgsql.extra_warnings</varname> set to "
"<varname>shadowed_variables</varname>: <placeholder-2/>"
msgstr ""
"Для включения этих проверок используются параметры конфигурации "
"<varname>plpgsql.extra_warnings</varname> для предупреждений и "
"<varname>plpgsql.extra_errors</varname> для ошибок. Каждому из параметров "
"можно присвоить список значений, разделённый через запятую, значение "
"<literal>\"none\"</literal> или <literal>\"all\"</literal>. По умолчанию "
"используется <literal>\"none\"</literal>. В настоящий момент доступна только "
"одна проверка: <placeholder-1/> Следующий пример показывает эффект от "
"установки <varname>plpgsql.extra_warnings</varname> в значение "
"<varname>shadowed_variables</varname>: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4994(title)
msgid "Porting from <productname>Oracle</productname> PL/SQL"
msgstr "Портирование из <productname>Oracle</productname> PL/SQL"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:4996(indexterm)
msgid ""
"<primary>Oracle</primary> <secondary>porting from PL/SQL to PL/pgSQL</"
"secondary>"
msgstr ""
"<primary>Oracle</primary> <secondary>портирование из PL/SQL в PL/pgSQL</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5001(indexterm)
msgid ""
"<primary>PL/SQL (Oracle)</primary> <secondary>porting to PL/pgSQL</secondary>"
msgstr ""
"<primary>PL/SQL (Oracle)</primary> <secondary>портирование в PL/pgSQL</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5006(para)
msgid ""
"This section explains differences between <productname>PostgreSQL</"
"productname>'s <application>PL/pgSQL</application> language and Oracle's "
"<application>PL/SQL</application> language, to help developers who port "
"applications from <trademark class=\"registered\">Oracle</trademark> to "
"<productname>PostgreSQL</productname>."
msgstr ""
"В этом разделе рассматриваются различия между языками "
"<productname>PostgreSQL</productname> <application>PL/pgSQL</application> и "
"Oracle <application>PL/SQL</application>, чтобы помочь разработчикам, "
"переносящим приложения из <trademark class=\"registered\">Oracle</trademark> "
"в <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5024(para)
msgid ""
"If a name used in a SQL command could be either a column name of a table or "
"a reference to a variable of the function, <application>PL/SQL</application> "
"treats it as a column name. This corresponds to <application>PL/pgSQL</"
"application>'s <literal>plpgsql.variable_conflict</literal> = "
"<literal>use_column</literal> behavior, which is not the default, as "
"explained in <xref linkend=\"plpgsql-var-subst\"/>. It's often best to avoid "
"such ambiguities in the first place, but if you have to port a large amount "
"of code that depends on this behavior, setting <literal>variable_conflict</"
"literal> may be the best solution."
msgstr ""
"Если имя, используемое в SQL-команде, может быть как именем столбца таблицы, "
"так и ссылкой на переменную функции, то <application>PL/SQL</application> "
"считает, что это имя столбца таблицы. Это соответствует поведению "
"<application>PL/pgSQL</application> при <literal>plpgsql.variable_conflict</"
"literal> = <literal>use_column</literal>, что не является значением по "
"умолчанию, как описано в <xref remap=\"6\" linkend=\"plpgsql-var-subst\"/>. "
"В первую очередь, было бы правильно избегать таких двусмысленностей, но если "
"требуется портировать большое количество кода, зависящее от данного "
"поведения, то установка переменной <literal>variable_conflict</literal> "
"может быть лучшим решением."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5040(para)
msgid ""
"In <productname>PostgreSQL</productname> the function body must be written "
"as a string literal. Therefore you need to use dollar quoting or escape "
"single quotes in the function body. (See <xref linkend=\"plpgsql-quote-tips"
"\"/>.)"
msgstr ""
"В <productname>PostgreSQL</productname> тело функции должно быть записано в "
"виде строки. Поэтому нужно использовать знак доллара в качестве кавычек или "
"экранировать одиночные кавычки в теле функции. (См. <xref remap=\"4\" "
"linkend=\"plpgsql-quote-tips\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5049(para)
msgid ""
"Data type names often need translation. For example, in Oracle string values "
"are commonly declared as being of type <type>varchar2</type>, which is a non-"
"SQL-standard type. In <productname>PostgreSQL</productname>, use type "
"<type>varchar</type> or <type>text</type> instead. Similarly, replace type "
"<type>number</type> with <type>numeric</type>, or use some other numeric "
"data type if there's a more appropriate one."
msgstr ""
"Имена типов данных часто требуют корректировки. Например, в Oracle строковые "
"значения часто объявляются с типом <type>varchar2</type>, не являющимся "
"стандартным типом SQL. В <productname>PostgreSQL</productname> вместо него "
"нужно использовать <type>varchar</type> или <type>text</type>. Подобным "
"образом, тип <type>number</type> нужно заменять на <type>numeric</type> или "
"другой числовой тип, если найдётся более подходящий."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5060(para)
msgid ""
"Instead of packages, use schemas to organize your functions into groups."
msgstr "Для группировки функций вместо пакетов используются схемы."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5067(para)
msgid ""
"Since there are no packages, there are no package-level variables either. "
"This is somewhat annoying. You can keep per-session state in temporary "
"tables instead."
msgstr ""
"Так как пакетов нет, нет и пакетных переменных. Это несколько раздражает. "
"Вместо этого можно хранить состояние каждого сеанса во временных таблицах."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5075(para)
msgid ""
"Integer <command>FOR</command> loops with <literal>REVERSE</literal> work "
"differently: <application>PL/SQL</application> counts down from the second "
"number to the first, while <application>PL/pgSQL</application> counts down "
"from the first number to the second, requiring the loop bounds to be swapped "
"when porting. This incompatibility is unfortunate but is unlikely to be "
"changed. (See <xref linkend=\"plpgsql-integer-for\"/>.)"
msgstr ""
"Целочисленные циклы <command>FOR</command> с указанием <literal>REVERSE</"
"literal> работают по-разному. В <application>PL/SQL</application> значение "
"счётчика уменьшается от второго числа к первому, в то время как в "
"<application>PL/pgSQL</application> счётчик уменьшается от первого ко "
"второму. Поэтому при портировании нужно менять местами границы цикла. Это "
"печально, но вряд ли будет изменено. (См. <xref remap=\"4\" linkend="
"\"plpgsql-integer-for\"/>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5087(para)
msgid ""
"<command>FOR</command> loops over queries (other than cursors) also work "
"differently: the target variable(s) must have been declared, whereas "
"<application>PL/SQL</application> always declares them implicitly. An "
"advantage of this is that the variable values are still accessible after the "
"loop exits."
msgstr ""
"Циклы <command>FOR</command> по запросам (не курсорам) также работают по-"
"разному. Переменная цикла должна быть объявлена, в то время как в "
"<application>PL/SQL</application> она объявляется неявно. Преимущество в "
"том, что значения переменных доступны и после выхода из цикла."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5097(para)
msgid ""
"There are various notational differences for the use of cursor variables."
msgstr ""
"Существуют некоторые отличия в нотации при использовании курсорных "
"переменных."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5014(para)
msgid ""
"<application>PL/pgSQL</application> is similar to PL/SQL in many aspects. It "
"is a block-structured, imperative language, and all variables have to be "
"declared. Assignments, loops, conditionals are similar. The main differences "
"you should keep in mind when porting from <application>PL/SQL</application> "
"to <application>PL/pgSQL</application> are: <placeholder-1/>"
msgstr ""
"<application>PL/pgSQL</application> во многих аспектах похож на PL/SQL . Это "
"блочно-структурированный, императивный язык, в котором все переменные должны "
"объявляться. Присвоения, циклы, условные операторы в обоих языках похожи. "
"Основные отличия, которые необходимо иметь в виду при портировании с "
"<application>PL/SQL</application> в <application>PL/pgSQL</application>, "
"следующие: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5107(title)
msgid "Porting Examples"
msgstr "Примеры портирования"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5109(para)
msgid ""
"<xref linkend=\"pgsql-porting-ex1\"/> shows how to port a simple function "
"from <application>PL/SQL</application> to <application>PL/pgSQL</"
"application>."
msgstr ""
"<xref linkend=\"pgsql-porting-ex1\"/> показывает, как портировать простую "
"функцию из <application>PL/SQL</application> в <application>PL/pgSQL</"
"application>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5115(title)
msgid ""
"Porting a Simple Function from <application>PL/SQL</application> to "
"<application>PL/pgSQL</application>"
msgstr ""
"Портирование простой функции из <application>PL/SQL</application> в "
"<application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5119(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,\n"
"                                                  v_version varchar2)\n"
"RETURN varchar2 IS\n"
"BEGIN\n"
"    IF v_version IS NULL THEN\n"
"        RETURN v_name;\n"
"    END IF;\n"
"    RETURN v_name || '/' || v_version;\n"
"END;\n"
"/\n"
"show errors;"
msgstr ""
"CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,\n"
"                                                  v_version varchar2)\n"
"RETURN varchar2 IS\n"
"BEGIN\n"
"    IF v_version IS NULL THEN\n"
"        RETURN v_name;\n"
"    END IF;\n"
"    RETURN v_name || '/' || v_version;\n"
"END;\n"
"/\n"
"show errors;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5117(para)
msgid ""
"Here is an <productname>Oracle</productname> <application>PL/SQL</"
"application> function: <placeholder-1/>"
msgstr ""
"Функция <productname>Oracle</productname> <application>PL/SQL</application>: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5140(para)
msgid ""
"The type name <type>varchar2</type> has to be changed to <type>varchar</"
"type> or <type>text</type>. In the examples in this section, we'll use "
"<type>varchar</type>, but <type>text</type> is often a better choice if you "
"do not need specific string length limits."
msgstr ""
"Имя типа <type>varchar2</type> нужно сменить на <type>varchar</type> или "
"<type>text</type>. В примерах данного раздела мы будем использовать "
"<type>varchar</type>, но обычно лучше выбрать <type>text</type>, если не "
"требуется ограничивать длину строк."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5149(para)
msgid ""
"The <literal>RETURN</literal> key word in the function prototype (not the "
"function body) becomes <literal>RETURNS</literal> in "
"<productname>PostgreSQL</productname>. Also, <literal>IS</literal> becomes "
"<literal>AS</literal>, and you need to add a <literal>LANGUAGE</literal> "
"clause because <application>PL/pgSQL</application> is not the only possible "
"function language."
msgstr ""
"Ключевое слово <literal>RETURN</literal> в прототипе функции (не в теле "
"функции) заменяется на <literal>RETURNS</literal> в <productname>PostgreSQL</"
"productname>. Кроме того, <literal>IS</literal> становится <literal>AS</"
"literal>, и нужно добавить предложение <literal>LANGUAGE</literal>, потому "
"что <application>PL/pgSQL</application> — не единственный возможный язык."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5161(para)
msgid ""
"In <productname>PostgreSQL</productname>, the function body is considered to "
"be a string literal, so you need to use quote marks or dollar quotes around "
"it. This substitutes for the terminating <literal>/</literal> in the Oracle "
"approach."
msgstr ""
"В <productname>PostgreSQL</productname> тело функции является строкой, "
"поэтому нужно использовать кавычки или знаки доллара. Это заменяет "
"завершающий <literal>/</literal> в подходе Oracle."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5170(para)
msgid ""
"The <literal>show errors</literal> command does not exist in "
"<productname>PostgreSQL</productname>, and is not needed since errors are "
"reported automatically."
msgstr ""
"Команда <literal>show errors</literal> не существует в "
"<productname>PostgreSQL</productname> и не требуется, так как ошибки будут "
"выводиться автоматически."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5134(para)
msgid ""
"Let's go through this function and see the differences compared to "
"<application>PL/pgSQL</application>: <placeholder-1/>"
msgstr ""
"Пройдемся по этой функции и посмотрим различия по сравнению с "
"<application>PL/pgSQL</application>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5183(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,\n"
"                                                  v_version varchar)\n"
"RETURNS varchar AS $$\n"
"BEGIN\n"
"    IF v_version IS NULL THEN\n"
"        RETURN v_name;\n"
"    END IF;\n"
"    RETURN v_name || '/' || v_version;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,\n"
"                                                  v_version varchar)\n"
"RETURNS varchar AS $$\n"
"BEGIN\n"
"    IF v_version IS NULL THEN\n"
"        RETURN v_name;\n"
"    END IF;\n"
"    RETURN v_name || '/' || v_version;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5179(para)
msgid ""
"This is how this function would look when ported to <productname>PostgreSQL</"
"productname>: <placeholder-1/>"
msgstr ""
"Вот как эта функция будет выглядеть после портирования в "
"<productname>PostgreSQL</productname>: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5198(para)
msgid ""
"<xref linkend=\"plpgsql-porting-ex2\"/> shows how to port a function that "
"creates another function and how to handle the ensuing quoting problems."
msgstr ""
"<xref linkend=\"plpgsql-porting-ex2\"/> показывает, как портировать функцию, "
"которая создаёт другую функцию, и как обрабатывать проблемы с кавычками."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5205(title)
msgid ""
"Porting a Function that Creates Another Function from <application>PL/SQL</"
"application> to <application>PL/pgSQL</application>"
msgstr ""
"Портирование функции, создающей другую функцию, из <application>PL/SQL</"
"application> в <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5207(para)
msgid ""
"The following procedure grabs rows from a <command>SELECT</command> "
"statement and builds a large function with the results in <literal>IF</"
"literal> statements, for the sake of efficiency."
msgstr ""
"Следующая процедура получает строки из <command>SELECT</command> и строит "
"большую функцию, в целях эффективности возвращающую результат в операторах "
"<literal>IF</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5216(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS\n"
"    CURSOR referrer_keys IS\n"
"        SELECT * FROM cs_referrer_keys\n"
"        ORDER BY try_order;\n"
"    func_cmd VARCHAR(4000);\n"
"BEGIN\n"
"    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,\n"
"                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';\n"
"\n"
"    FOR referrer_key IN referrer_keys LOOP\n"
"        func_cmd := func_cmd ||\n"
"          ' IF v_' || referrer_key.kind\n"
"          || ' LIKE ''' || referrer_key.key_string\n"
"          || ''' THEN RETURN ''' || referrer_key.referrer_type\n"
"          || '''; END IF;';\n"
"    END LOOP;\n"
"\n"
"    func_cmd := func_cmd || ' RETURN NULL; END;';\n"
"\n"
"    EXECUTE IMMEDIATE func_cmd;\n"
"END;\n"
"/\n"
"show errors;"
msgstr ""
"CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS\n"
"    CURSOR referrer_keys IS\n"
"        SELECT * FROM cs_referrer_keys\n"
"        ORDER BY try_order;\n"
"    func_cmd VARCHAR(4000);\n"
"BEGIN\n"
"    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,\n"
"                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';\n"
"\n"
"    FOR referrer_key IN referrer_keys LOOP\n"
"        func_cmd := func_cmd ||\n"
"          ' IF v_' || referrer_key.kind\n"
"          || ' LIKE ''' || referrer_key.key_string\n"
"          || ''' THEN RETURN ''' || referrer_key.referrer_type\n"
"          || '''; END IF;';\n"
"    END LOOP;\n"
"\n"
"    func_cmd := func_cmd || ' RETURN NULL; END;';\n"
"\n"
"    EXECUTE IMMEDIATE func_cmd;\n"
"END;\n"
"/\n"
"show errors;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5214(para) plpgsql.xml:5315(para)
msgid "This is the Oracle version: <placeholder-1/>"
msgstr "Версия Oracle: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5245(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$\n"
"DECLARE\n"
"    referrer_keys CURSOR IS\n"
"        SELECT * FROM cs_referrer_keys\n"
"        ORDER BY try_order;\n"
"    func_body text;\n"
"    func_cmd text;\n"
"BEGIN\n"
"    func_body := 'BEGIN';\n"
"\n"
"    FOR referrer_key IN referrer_keys LOOP\n"
"        func_body := func_body ||\n"
"          ' IF v_' || referrer_key.kind\n"
"          || ' LIKE ' || quote_literal(referrer_key.key_string)\n"
"          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)\n"
"          || '; END IF;' ;\n"
"    END LOOP;\n"
"\n"
"    func_body := func_body || ' RETURN NULL; END;';\n"
"\n"
"    func_cmd :=\n"
"      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,\n"
"                                                        v_domain varchar,\n"
"                                                        v_url varchar)\n"
"        RETURNS varchar AS '\n"
"      || quote_literal(func_body)\n"
"      || ' LANGUAGE plpgsql;' ;\n"
"\n"
"    EXECUTE func_cmd;\n"
"END;\n"
"$func$ LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$\n"
"DECLARE\n"
"    referrer_keys CURSOR IS\n"
"        SELECT * FROM cs_referrer_keys\n"
"        ORDER BY try_order;\n"
"    func_body text;\n"
"    func_cmd text;\n"
"BEGIN\n"
"    func_body := 'BEGIN';\n"
"\n"
"    FOR referrer_key IN referrer_keys LOOP\n"
"        func_body := func_body ||\n"
"          ' IF v_' || referrer_key.kind\n"
"          || ' LIKE ' || quote_literal(referrer_key.key_string)\n"
"          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)\n"
"          || '; END IF;' ;\n"
"    END LOOP;\n"
"\n"
"    func_body := func_body || ' RETURN NULL; END;';\n"
"\n"
"    func_cmd :=\n"
"      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,\n"
"                                                        v_domain varchar,\n"
"                                                        v_url varchar)\n"
"        RETURNS varchar AS '\n"
"      || quote_literal(func_body)\n"
"      || ' LANGUAGE plpgsql;' ;\n"
"\n"
"    EXECUTE func_cmd;\n"
"END;\n"
"$func$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5243(para)
msgid ""
"Here is how this function would end up in <productname>PostgreSQL</"
"productname>: <placeholder-1/> Notice how the body of the function is built "
"separately and passed through <literal>quote_literal</literal> to double any "
"quote marks in it. This technique is needed because we cannot safely use "
"dollar quoting for defining the new function: we do not know for sure what "
"strings will be interpolated from the <structfield>referrer_key.key_string</"
"structfield> field. (We are assuming here that <structfield>referrer_key."
"kind</structfield> can be trusted to always be <literal>host</literal>, "
"<literal>domain</literal>, or <literal>url</literal>, but "
"<structfield>referrer_key.key_string</structfield> might be anything, in "
"particular it might contain dollar signs.) This function is actually an "
"improvement on the Oracle original, because it will not generate broken code "
"when <structfield>referrer_key.key_string</structfield> or "
"<structfield>referrer_key.referrer_type</structfield> contain quote marks."
msgstr ""
"В конечном итоге в <productname>PostgreSQL</productname> эта функция может "
"выглядеть так: <placeholder-1/> Обратите внимание, что тело функции строится "
"отдельно, с использованием <literal>quote_literal</literal> для удвоения "
"кавычек. Эта техника необходима, потому что мы не можем безопасно "
"использовать знаки доллара при определении новой функции: мы не знаем "
"наверняка, какие строки будут вставлены из <structfield>referrer_key."
"key_string</structfield>. (Мы предполагаем, что <structfield>referrer_key."
"kind</structfield> всегда имеет значение из списка: <literal>host</literal>, "
"<literal>domain</literal> или <literal>url</literal>, но "
"<structfield>referrer_key.key_string</structfield> может быть чем угодно, в "
"частности, может содержать знаки доллара.) На самом деле, в этой функций "
"есть улучшение по сравнению с оригиналом Oracle, потому что не будет "
"генерироваться неправильный код, когда <structfield>referrer_key.key_string</"
"structfield> или <structfield>referrer_key.referrer_type</structfield> "
"содержат кавычки."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5293(para)
msgid ""
"<xref linkend=\"plpgsql-porting-ex3\"/> shows how to port a function with "
"<literal>OUT</literal> parameters and string manipulation. "
"<productname>PostgreSQL</productname> does not have a built-in "
"<function>instr</function> function, but you can create one using a "
"combination of other functions. In <xref linkend=\"plpgsql-porting-appendix"
"\"/> there is a <application>PL/pgSQL</application> implementation of "
"<function>instr</function> that you can use to make your porting easier."
msgstr ""
"<xref linkend=\"plpgsql-porting-ex3\"/> показывает, как портировать функцию "
"с выходными параметрами (<literal>OUT</literal>) и манипулирующую строками. "
"В <productname>PostgreSQL</productname> нет встроенной функции "
"<function>instr</function>, но её можно создать, используя комбинацию других "
"функций. В <xref linkend=\"plpgsql-porting-appendix\"/> приведена реализации "
"<function>instr</function> на <application>PL/pgSQL</application>, которая "
"может быть полезна вам при портировании ваших функций."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5306(title)
msgid ""
"Porting a Procedure With String Manipulation and <literal>OUT</literal> "
"Parameters from <application>PL/SQL</application> to <application>PL/pgSQL</"
"application>"
msgstr ""
"Портирование из <application>PL/SQL</application> в <application>PL/pgSQL</"
"application> процедуры, которая манипулирует строками и содержит "
"<literal>OUT</literal> параметры"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5310(para)
msgid ""
"The following <productname>Oracle</productname> PL/SQL procedure is used to "
"parse a URL and return several elements (host, path, and query)."
msgstr ""
"Следующая процедура на языке <productname>Oracle</productname> PL/SQL "
"разбирает URL и возвращает составляющие его элементы (сервер, путь и запрос)."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5317(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE PROCEDURE cs_parse_url(\n"
"    v_url IN VARCHAR2,\n"
"    v_host OUT VARCHAR2,  -- This will be passed back\n"
"    v_path OUT VARCHAR2,  -- This one too\n"
"    v_query OUT VARCHAR2) -- And this one\n"
"IS\n"
"    a_pos1 INTEGER;\n"
"    a_pos2 INTEGER;\n"
"BEGIN\n"
"    v_host := NULL;\n"
"    v_path := NULL;\n"
"    v_query := NULL;\n"
"    a_pos1 := instr(v_url, '//');\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        RETURN;\n"
"    END IF;\n"
"    a_pos2 := instr(v_url, '/', a_pos1 + 2);\n"
"    IF a_pos2 = 0 THEN\n"
"        v_host := substr(v_url, a_pos1 + 2);\n"
"        v_path := '/';\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);\n"
"    a_pos1 := instr(v_url, '?', a_pos2 + 1);\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        v_path := substr(v_url, a_pos2);\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);\n"
"    v_query := substr(v_url, a_pos1 + 1);\n"
"END;\n"
"/\n"
"show errors;"
msgstr ""
"CREATE OR REPLACE PROCEDURE cs_parse_url(\n"
"    v_url IN VARCHAR2,\n"
"    v_host OUT VARCHAR2,  -- Возвращается обратно\n"
"    v_path OUT VARCHAR2,  -- И это тоже\n"
"    v_query OUT VARCHAR2) -- И это\n"
"IS\n"
"    a_pos1 INTEGER;\n"
"    a_pos2 INTEGER;\n"
"BEGIN\n"
"    v_host := NULL;\n"
"    v_path := NULL;\n"
"    v_query := NULL;\n"
"    a_pos1 := instr(v_url, '//');\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        RETURN;\n"
"    END IF;\n"
"    a_pos2 := instr(v_url, '/', a_pos1 + 2);\n"
"    IF a_pos2 = 0 THEN\n"
"        v_host := substr(v_url, a_pos1 + 2);\n"
"        v_path := '/';\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);\n"
"    a_pos1 := instr(v_url, '?', a_pos2 + 1);\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        v_path := substr(v_url, a_pos2);\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);\n"
"    v_query := substr(v_url, a_pos1 + 1);\n"
"END;\n"
"/\n"
"show errors;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5360(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION cs_parse_url(\n"
"    v_url IN VARCHAR,\n"
"    v_host OUT VARCHAR,  -- This will be passed back\n"
"    v_path OUT VARCHAR,  -- This one too\n"
"    v_query OUT VARCHAR) -- And this one\n"
"AS $$\n"
"DECLARE\n"
"    a_pos1 INTEGER;\n"
"    a_pos2 INTEGER;\n"
"BEGIN\n"
"    v_host := NULL;\n"
"    v_path := NULL;\n"
"    v_query := NULL;\n"
"    a_pos1 := instr(v_url, '//');\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        RETURN;\n"
"    END IF;\n"
"    a_pos2 := instr(v_url, '/', a_pos1 + 2);\n"
"    IF a_pos2 = 0 THEN\n"
"        v_host := substr(v_url, a_pos1 + 2);\n"
"        v_path := '/';\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);\n"
"    a_pos1 := instr(v_url, '?', a_pos2 + 1);\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        v_path := substr(v_url, a_pos2);\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);\n"
"    v_query := substr(v_url, a_pos1 + 1);\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION cs_parse_url(\n"
"    v_url IN VARCHAR,\n"
"    v_host OUT VARCHAR,  -- Возвращается обратно\n"
"    v_path OUT VARCHAR,  -- И это возвращается\n"
"    v_query OUT VARCHAR) -- И это\n"
"AS $$\n"
"DECLARE\n"
"    a_pos1 INTEGER;\n"
"    a_pos2 INTEGER;\n"
"BEGIN\n"
"    v_host := NULL;\n"
"    v_path := NULL;\n"
"    v_query := NULL;\n"
"    a_pos1 := instr(v_url, '//');\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        RETURN;\n"
"    END IF;\n"
"    a_pos2 := instr(v_url, '/', a_pos1 + 2);\n"
"    IF a_pos2 = 0 THEN\n"
"        v_host := substr(v_url, a_pos1 + 2);\n"
"        v_path := '/';\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);\n"
"    a_pos1 := instr(v_url, '?', a_pos2 + 1);\n"
"\n"
"    IF a_pos1 = 0 THEN\n"
"        v_path := substr(v_url, a_pos2);\n"
"        RETURN;\n"
"    END IF;\n"
"\n"
"    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);\n"
"    v_query := substr(v_url, a_pos1 + 1);\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5401(programlisting)
#, no-wrap
msgid "SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');"
msgstr "SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5358(para)
msgid ""
"Here is a possible translation into <application>PL/pgSQL</application>: "
"<placeholder-1/> This function could be used like this: <placeholder-2/>"
msgstr ""
"Вот возможная трансляция в <application>PL/pgSQL</application>: "
"<placeholder-1/> Эту функцию можно использовать так: <placeholder-2/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5407(para)
msgid ""
"<xref linkend=\"plpgsql-porting-ex4\"/> shows how to port a procedure that "
"uses numerous features that are specific to Oracle."
msgstr ""
"<xref linkend=\"plpgsql-porting-ex4\"/> показывает, как портировать "
"процедуру, использующую большое количество специфических для Oracle "
"возможностей."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5413(title)
msgid ""
"Porting a Procedure from <application>PL/SQL</application> to "
"<application>PL/pgSQL</application>"
msgstr ""
"Портирование процедуры из <application>PL/SQL</application> в "
"<application>PL/pgSQL</application>"

#. +> REL_10
#: plpgsql.xml:5418(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS\n"
"    a_running_job_count INTEGER;\n"
"    PRAGMA AUTONOMOUS_TRANSACTION; -- <co id=\"co.plpgsql-porting-pragma\"></co>\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE; -- <co id=\"co.plpgsql-porting-locktable\"></co>\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        COMMIT; -- free lock <co id=\"co.plpgsql-porting-commit\"></co>\n"
"        raise_application_error(-20000,\n"
"                 'Unable to create a new job: a job is currently running.');\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);\n"
"    EXCEPTION\n"
"        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists\n"
"    END;\n"
"    COMMIT;\n"
"END;\n"
"/\n"
"show errors"
msgstr ""
"CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS\n"
"    a_running_job_count INTEGER;\n"
"    PRAGMA AUTONOMOUS_TRANSACTION; -- <co id=\"co.plpgsql-porting-pragma\"></co>\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE; -- <co id=\"co.plpgsql-porting-locktable\"></co>\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        COMMIT; -- снять блокировку <co id=\"co.plpgsql-porting-commit\"></co>\n"
"        raise_application_error(-20000,\n"
"                 'Не удалось создать новое задание. Задание сейчас выполняется.');\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);\n"
"    EXCEPTION\n"
"        WHEN dup_val_on_index THEN NULL; -- ничего не делать, если задание уже есть\n"
"    END;\n"
"    COMMIT;\n"
"END;\n"
"/\n"
"show errors"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5415(para)
msgid "The Oracle version: <placeholder-1/>"
msgstr "Версия Oracle: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5455(para)
msgid ""
"There is no <literal>PRAGMA</literal> statement in <productname>PostgreSQL</"
"productname>."
msgstr ""
"В <productname>PostgreSQL</productname> нет оператора <literal>PRAGMA</"
"literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5461(para)
msgid ""
"If you do a <command>LOCK TABLE</command> in <application>PL/pgSQL</"
"application>, the lock will not be released until the calling transaction is "
"finished."
msgstr ""
"Если выполнить <command>LOCK TABLE</command> в <application>PL/pgSQL</"
"application>, блокировка не будет снята, пока не завершится вызывающая "
"транзакция."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5469(para)
msgid ""
"You cannot issue <command>COMMIT</command> in a <application>PL/pgSQL</"
"application> function. The function is running within some outer transaction "
"and so <command>COMMIT</command> would imply terminating the function's "
"execution. However, in this particular case it is not necessary anyway, "
"because the lock obtained by the <command>LOCK TABLE</command> will be "
"released when we raise an error."
msgstr ""
"В функции на <application>PL/pgSQL</application> нельзя использовать "
"<command>COMMIT</command>. Функция работает в рамках некоторой внешней "
"транзакции, и поэтому <command>COMMIT</command> будет означать прекращение "
"выполнения функции. Однако, в данном конкретном случае, в этом нет "
"необходимости, потому что блокировка, полученная командой <command>LOCK "
"TABLE</command>, будет снята при вызове ошибки."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5448(para)
msgid ""
"Procedures like this can easily be converted into <productname>PostgreSQL</"
"productname> functions returning <type>void</type>. This procedure in "
"particular is interesting because it can teach us some things: "
"<placeholder-1/>"
msgstr ""
"Подобные процедуры легко преобразуются в функции <productname>PostgreSQL</"
"productname>, возвращающие <type>void</type>. На примере этой процедуры "
"можно научиться следующему: <placeholder-1/>"

#. +> REL_10
#: plpgsql.xml:5485(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$\n"
"DECLARE\n"
"    a_running_job_count integer;\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; -- <co id=\"co.plpgsql-porting-raise\"></co>\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());\n"
"    EXCEPTION\n"
"        WHEN unique_violation THEN -- <co id=\"co.plpgsql-porting-exception\"></co>\n"
"            -- don't worry if it already exists\n"
"    END;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$\n"
"DECLARE\n"
"    a_running_job_count integer;\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        RAISE EXCEPTION 'Не удалось создать новое задание. Задание сейчас выполняется.'; -- <co id=\"co.plpgsql-porting-raise\"></co>\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());\n"
"    EXCEPTION\n"
"        WHEN unique_violation THEN -- <co id=\"co.plpgsql-porting-exception\"></co>\n"
"            -- ничего не делать, если задание уже есть\n"
"    END;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5513(para)
msgid ""
"The syntax of <literal>RAISE</literal> is considerably different from "
"Oracle's statement, although the basic case <literal>RAISE</literal> "
"<replaceable class=\"parameter\">exception_name</replaceable> works "
"similarly."
msgstr ""
"Синтаксис <literal>RAISE</literal> существенно отличается от Oracle, хотя "
"основной вариант <literal>RAISE</literal> <replaceable class=\"parameter"
"\">имя_исключения</replaceable> работает похоже."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5521(para)
msgid ""
"The exception names supported by <application>PL/pgSQL</application> are "
"different from Oracle's. The set of built-in exception names is much larger "
"(see <xref linkend=\"errcodes-appendix\"/>). There is not currently a way to "
"declare user-defined exception names, although you can throw user-chosen "
"SQLSTATE values instead."
msgstr ""
"Имена исключений, поддерживаемые <application>PL/pgSQL</application>, "
"отличаются от исключений в Oracle. Количество встроенных имён исключений "
"значительно больше (см. <xref remap=\"4\" linkend=\"errcodes-appendix\"/>). "
"В настоящее время нет способа задать пользовательское имя исключения, хотя "
"вместо этого можно вызывать ошибку с заданным пользователем значением "
"SQLSTATE."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5482(para)
msgid ""
"This is how we could port this procedure to <application>PL/pgSQL</"
"application>: <placeholder-1/> <placeholder-2/> The main functional "
"difference between this procedure and the Oracle equivalent is that the "
"exclusive lock on the <literal>cs_jobs</literal> table will be held until "
"the calling transaction completes. Also, if the caller later aborts (for "
"example due to an error), the effects of this procedure will be rolled back."
msgstr ""
"В <application>PL/pgSQL</application> эту процедуру можно портировать так: "
"<placeholder-1/> <placeholder-2/> Основное функциональное отличие между этой "
"процедурой и Oracle эквивалента в том, что монопольная блокировка таблицы "
"<literal>cs_jobs</literal> будет продолжаться до окончания вызывающей "
"транзакции. Кроме того, если впоследствии работа вызывающей программы "
"прервётся (например из-за ошибки), произойдёт откат всех действий, "
"выполненных в этой процедуре."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5541(title)
msgid "Other Things to Watch For"
msgstr "На что ещё обратить внимание"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5543(para)
msgid ""
"This section explains a few other things to watch for when porting Oracle "
"<application>PL/SQL</application> functions to <productname>PostgreSQL</"
"productname>."
msgstr ""
"В этом разделе рассматриваются ещё несколько вещей, на которые нужно "
"обращать внимание при портировании функций из Oracle <application>PL/SQL</"
"application> в <productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5550(title)
msgid "Implicit Rollback after Exceptions"
msgstr "Неявный откат изменений после возникновения исключения"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5558(programlisting)
#, no-wrap
msgid ""
"BEGIN\n"
"    SAVEPOINT s1;\n"
"    ... code here ...\n"
"EXCEPTION\n"
"    WHEN ... THEN\n"
"        ROLLBACK TO s1;\n"
"        ... code here ...\n"
"    WHEN ... THEN\n"
"        ROLLBACK TO s1;\n"
"        ... code here ...\n"
"END;"
msgstr ""
"BEGIN\n"
"    SAVEPOINT s1;\n"
"    ... здесь код ...\n"
"EXCEPTION\n"
"    WHEN ... THEN\n"
"        ROLLBACK TO s1;\n"
"        ... здесь код ...\n"
"    WHEN ... THEN\n"
"        ROLLBACK TO s1;\n"
"        ... здесь код ...\n"
"END;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5552(para)
msgid ""
"In <application>PL/pgSQL</application>, when an exception is caught by an "
"<literal>EXCEPTION</literal> clause, all database changes since the block's "
"<literal>BEGIN</literal> are automatically rolled back. That is, the "
"behavior is equivalent to what you'd get in Oracle with: <placeholder-1/> If "
"you are translating an Oracle procedure that uses <command>SAVEPOINT</"
"command> and <command>ROLLBACK TO</command> in this style, your task is "
"easy: just omit the <command>SAVEPOINT</command> and <command>ROLLBACK TO</"
"command>. If you have a procedure that uses <command>SAVEPOINT</command> and "
"<command>ROLLBACK TO</command> in a different way then some actual thought "
"will be required."
msgstr ""
"В <application>PL/pgSQL</application> при перехвате исключения в секции "
"<literal>EXCEPTION</literal> все изменения в базе данных с начала блока "
"автоматически откатываются. В Oracle это эквивалентно следующему: "
"<placeholder-1/> При портировании процедуры Oracle, которая использует "
"<command>SAVEPOINT</command> и <command>ROLLBACK TO</command> в таком же "
"стиле, задача простая: достаточно убрать операторы <command>SAVEPOINT</"
"command> и <command>ROLLBACK TO</command>. Если же <command>SAVEPOINT</"
"command> и <command>ROLLBACK TO</command> используются по-другому, то "
"придётся подумать."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5582(command)
msgid "EXECUTE"
msgstr "EXECUTE"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5584(para)
msgid ""
"The <application>PL/pgSQL</application> version of <command>EXECUTE</"
"command> works similarly to the <application>PL/SQL</application> version, "
"but you have to remember to use <function>quote_literal</function> and "
"<function>quote_ident</function> as described in <xref linkend=\"plpgsql-"
"statements-executing-dyn\"/>. Constructs of the type <literal>EXECUTE "
"'SELECT * FROM $1';</literal> will not work reliably unless you use these "
"functions."
msgstr ""
"<application>PL/pgSQL</application> версия <command>EXECUTE</command> "
"работает аналогично версии в <application>PL/SQL</application>, но нужно "
"помнить об использовании <function>quote_literal</function> и "
"<function>quote_ident</function>, как описано в <xref remap=\"6\" linkend="
"\"plpgsql-statements-executing-dyn\"/>. Без использования этих функций "
"конструкции типа <literal>EXECUTE 'SELECT * FROM $1';</literal> будут "
"работать ненадёжно."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5597(title)
msgid "Optimizing <application>PL/pgSQL</application> Functions"
msgstr "Оптимизация функций на <application>PL/pgSQL</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5599(para)
msgid ""
"<productname>PostgreSQL</productname> gives you two function creation "
"modifiers to optimize execution: <quote>volatility</quote> (whether the "
"function always returns the same result when given the same arguments) and "
"<quote>strictness</quote> (whether the function returns null if any argument "
"is null). Consult the <xref linkend=\"sql-createfunction\"/> reference page "
"for details."
msgstr ""
"Для оптимизации исполнения <productname>PostgreSQL</productname> "
"предоставляет два модификатора при создании функции: <quote>изменчивость</"
"quote> (будет ли функция всегда возвращать тот же результат при тех же "
"аргументах) и <quote>строгость</quote> (возвращает ли функция NULL, если "
"хотя бы один из аргументов NULL). Для получения подробной информации "
"обратитесь к справочной странице <xref linkend=\"sql-createfunction\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5614(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION foo(...) RETURNS integer AS $$\n"
"...\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;"
msgstr ""
"CREATE FUNCTION foo(...) RETURNS integer AS $$\n"
"...\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5609(para)
msgid ""
"When making use of these optimization attributes, your <command>CREATE "
"FUNCTION</command> statement might look something like this: <placeholder-1/>"
msgstr ""
"При использовании этих атрибутов оптимизации оператор <command>CREATE "
"FUNCTION</command> может выглядеть примерно так: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5624(title)
msgid "Appendix"
msgstr "Приложение"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5626(para)
msgid ""
"This section contains the code for a set of Oracle-compatible "
"<function>instr</function> functions that you can use to simplify your "
"porting efforts."
msgstr ""
"Этот раздел содержит код для совместимых с Oracle функций <function>instr</"
"function>, которые можно использовать для упрощения портирования."

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5632(indexterm)
msgid "<primary><function>instr</function> function</primary>"
msgstr "<primary>функция <function>instr</function></primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:5636(programlisting)
#, no-wrap
msgid ""
"--\n"
"-- instr functions that mimic Oracle's counterpart\n"
"-- Syntax: instr(string1, string2, [n], [m]) where [] denotes optional parameters.\n"
"--\n"
"-- Searches string1 beginning at the nth character for the mth occurrence\n"
"-- of string2.  If n is negative, search backwards.  If m is not passed,\n"
"-- assume 1 (search starts at first character).\n"
"--\n"
"\n"
"CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$\n"
"DECLARE\n"
"    pos integer;\n"
"BEGIN\n"
"    pos:= instr($1, $2, 1);\n"
"    RETURN pos;\n"
"END;\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n"
"\n"
"\n"
"CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)\n"
"RETURNS integer AS $$\n"
"DECLARE\n"
"    pos integer NOT NULL DEFAULT 0;\n"
"    temp_str varchar;\n"
"    beg integer;\n"
"    length integer;\n"
"    ss_length integer;\n"
"BEGIN\n"
"    IF beg_index &gt; 0 THEN\n"
"        temp_str := substring(string FROM beg_index);\n"
"        pos := position(string_to_search IN temp_str);\n"
"\n"
"        IF pos = 0 THEN\n"
"            RETURN 0;\n"
"        ELSE\n"
"            RETURN pos + beg_index - 1;\n"
"        END IF;\n"
"    ELSIF beg_index &lt; 0 THEN\n"
"        ss_length := char_length(string_to_search);\n"
"        length := char_length(string);\n"
"        beg := length + beg_index - ss_length + 2;\n"
"\n"
"        WHILE beg &gt; 0 LOOP\n"
"            temp_str := substring(string FROM beg FOR ss_length);\n"
"            pos := position(string_to_search IN temp_str);\n"
"\n"
"            IF pos &gt; 0 THEN\n"
"                RETURN beg;\n"
"            END IF;\n"
"\n"
"            beg := beg - 1;\n"
"        END LOOP;\n"
"\n"
"        RETURN 0;\n"
"    ELSE\n"
"        RETURN 0;\n"
"    END IF;\n"
"END;\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n"
"\n"
"\n"
"CREATE FUNCTION instr(string varchar, string_to_search varchar,\n"
"                      beg_index integer, occur_index integer)\n"
"RETURNS integer AS $$\n"
"DECLARE\n"
"    pos integer NOT NULL DEFAULT 0;\n"
"    occur_number integer NOT NULL DEFAULT 0;\n"
"    temp_str varchar;\n"
"    beg integer;\n"
"    i integer;\n"
"    length integer;\n"
"    ss_length integer;\n"
"BEGIN\n"
"    IF beg_index &gt; 0 THEN\n"
"        beg := beg_index;\n"
"        temp_str := substring(string FROM beg_index);\n"
"\n"
"        FOR i IN 1..occur_index LOOP\n"
"            pos := position(string_to_search IN temp_str);\n"
"\n"
"            IF i = 1 THEN\n"
"                beg := beg + pos - 1;\n"
"            ELSE\n"
"                beg := beg + pos;\n"
"            END IF;\n"
"\n"
"            temp_str := substring(string FROM beg + 1);\n"
"        END LOOP;\n"
"\n"
"        IF pos = 0 THEN\n"
"            RETURN 0;\n"
"        ELSE\n"
"            RETURN beg;\n"
"        END IF;\n"
"    ELSIF beg_index &lt; 0 THEN\n"
"        ss_length := char_length(string_to_search);\n"
"        length := char_length(string);\n"
"        beg := length + beg_index - ss_length + 2;\n"
"\n"
"        WHILE beg &gt; 0 LOOP\n"
"            temp_str := substring(string FROM beg FOR ss_length);\n"
"            pos := position(string_to_search IN temp_str);\n"
"\n"
"            IF pos &gt; 0 THEN\n"
"                occur_number := occur_number + 1;\n"
"\n"
"                IF occur_number = occur_index THEN\n"
"                    RETURN beg;\n"
"                END IF;\n"
"            END IF;\n"
"\n"
"            beg := beg - 1;\n"
"        END LOOP;\n"
"\n"
"        RETURN 0;\n"
"    ELSE\n"
"        RETURN 0;\n"
"    END IF;\n"
"END;\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;"
msgstr ""
"--\n"
"-- instr functions that mimic Oracle's counterpart\n"
"-- Syntax: instr(string1, string2, [n], [m]) where [] denotes optional parameters.\n"
"--\n"
"-- Searches string1 beginning at the nth character for the mth occurrence\n"
"-- of string2.  If n is negative, search backwards.  If m is not passed,\n"
"-- assume 1 (search starts at first character).\n"
"--\n"
"\n"
"CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$\n"
"DECLARE\n"
"    pos integer;\n"
"BEGIN\n"
"    pos:= instr($1, $2, 1);\n"
"    RETURN pos;\n"
"END;\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n"
"\n"
"\n"
"CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)\n"
"RETURNS integer AS $$\n"
"DECLARE\n"
"    pos integer NOT NULL DEFAULT 0;\n"
"    temp_str varchar;\n"
"    beg integer;\n"
"    length integer;\n"
"    ss_length integer;\n"
"BEGIN\n"
"    IF beg_index &gt; 0 THEN\n"
"        temp_str := substring(string FROM beg_index);\n"
"        pos := position(string_to_search IN temp_str);\n"
"\n"
"        IF pos = 0 THEN\n"
"            RETURN 0;\n"
"        ELSE\n"
"            RETURN pos + beg_index - 1;\n"
"        END IF;\n"
"    ELSIF beg_index &lt; 0 THEN\n"
"        ss_length := char_length(string_to_search);\n"
"        length := char_length(string);\n"
"        beg := length + beg_index - ss_length + 2;\n"
"\n"
"        WHILE beg &gt; 0 LOOP\n"
"            temp_str := substring(string FROM beg FOR ss_length);\n"
"            pos := position(string_to_search IN temp_str);\n"
"\n"
"            IF pos &gt; 0 THEN\n"
"                RETURN beg;\n"
"            END IF;\n"
"\n"
"            beg := beg - 1;\n"
"        END LOOP;\n"
"\n"
"        RETURN 0;\n"
"    ELSE\n"
"        RETURN 0;\n"
"    END IF;\n"
"END;\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;\n"
"\n"
"\n"
"CREATE FUNCTION instr(string varchar, string_to_search varchar,\n"
"                      beg_index integer, occur_index integer)\n"
"RETURNS integer AS $$\n"
"DECLARE\n"
"    pos integer NOT NULL DEFAULT 0;\n"
"    occur_number integer NOT NULL DEFAULT 0;\n"
"    temp_str varchar;\n"
"    beg integer;\n"
"    i integer;\n"
"    length integer;\n"
"    ss_length integer;\n"
"BEGIN\n"
"    IF beg_index &gt; 0 THEN\n"
"        beg := beg_index;\n"
"        temp_str := substring(string FROM beg_index);\n"
"\n"
"        FOR i IN 1..occur_index LOOP\n"
"            pos := position(string_to_search IN temp_str);\n"
"\n"
"            IF i = 1 THEN\n"
"                beg := beg + pos - 1;\n"
"            ELSE\n"
"                beg := beg + pos;\n"
"            END IF;\n"
"\n"
"            temp_str := substring(string FROM beg + 1);\n"
"        END LOOP;\n"
"\n"
"        IF pos = 0 THEN\n"
"            RETURN 0;\n"
"        ELSE\n"
"            RETURN beg;\n"
"        END IF;\n"
"    ELSIF beg_index &lt; 0 THEN\n"
"        ss_length := char_length(string_to_search);\n"
"        length := char_length(string);\n"
"        beg := length + beg_index - ss_length + 2;\n"
"\n"
"        WHILE beg &gt; 0 LOOP\n"
"            temp_str := substring(string FROM beg FOR ss_length);\n"
"            pos := position(string_to_search IN temp_str);\n"
"\n"
"            IF pos &gt; 0 THEN\n"
"                occur_number := occur_number + 1;\n"
"\n"
"                IF occur_number = occur_index THEN\n"
"                    RETURN beg;\n"
"                END IF;\n"
"            END IF;\n"
"\n"
"            beg := beg - 1;\n"
"        END LOOP;\n"
"\n"
"        RETURN 0;\n"
"    ELSE\n"
"        RETURN 0;\n"
"    END IF;\n"
"END;\n"
"$$ LANGUAGE plpgsql STRICT IMMUTABLE;"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: plpgsql.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: plpgsql.xml:3979(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE emp (\n"
"    empname           text NOT NULL,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    stamp             timestamp NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary integer\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n"
"    BEGIN\n"
"        --\n"
"        -- Create a row in emp_audit to reflect the operation performed on emp,\n"
"        -- make use of the special variable TG_OP to work out the operation.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n"
"            RETURN OLD;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n"
"            RETURN NEW;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n"
"            RETURN NEW;\n"
"        END IF;\n"
"        RETURN NULL; -- result is ignored since this is an AFTER trigger\n"
"    END;\n"
"$emp_audit$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit\n"
"AFTER INSERT OR UPDATE OR DELETE ON emp\n"
"    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();"
msgstr ""
"CREATE TABLE emp (\n"
"    empname           text NOT NULL,\n"
"    salary            integer\n"
");\n"
"\n"
"CREATE TABLE emp_audit(\n"
"    operation         char(1)   NOT NULL,\n"
"    stamp             timestamp NOT NULL,\n"
"    userid            text      NOT NULL,\n"
"    empname           text      NOT NULL,\n"
"    salary integer\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n"
"    BEGIN\n"
"        --\n"
"        -- Создаем строку в emp_audit, которая отражает выполненную операцию.\n"
"        -- Воспользуемся переменной TG_OP для определения типа операции.\n"
"        --\n"
"        IF (TG_OP = 'DELETE') THEN\n"
"            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n"
"            RETURN OLD;\n"
"        ELSIF (TG_OP = 'UPDATE') THEN\n"
"            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n"
"            RETURN NEW;\n"
"        ELSIF (TG_OP = 'INSERT') THEN\n"
"            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n"
"            RETURN NEW;\n"
"        END IF;\n"
"        RETURN NULL; -- возвращаемое значение для триггера AFTER не имеет значения\n"
"    END;\n"
"$emp_audit$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER emp_audit\n"
"AFTER INSERT OR UPDATE OR DELETE ON emp\n"
"    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();"

#. +> REL9_6_3 REL9_6
#: plpgsql.xml:4851(para)
msgid ""
"To aid the user in finding instances of simple but common problems before "
"they cause harm, <application>PL/PgSQL</application> provides additional "
"<replaceable>checks</replaceable>. When enabled, depending on the "
"configuration, they can be used to emit either a <literal>WARNING</literal> "
"or an <literal>ERROR</literal> during the compilation of a function. A "
"function which has received a <literal>WARNING</literal> can be executed "
"without producing further messages, so you are advised to test in a separate "
"development environment."
msgstr ""
"Чтобы помочь найти и предупредить простые, но часто встречающиеся проблемы, "
"<application>PL/PgSQL</application> предоставляет дополнительные "
"<replaceable>проверки</replaceable>. Если они включены в конфигурации, то во "
"время компиляции функций будут выдаваться дополнительные сообщения "
"<literal>WARNING</literal> или ошибки <literal>ERROR</literal>. Функция, при "
"компиляции которой выдавалось <literal>WARNING</literal>, при последующем "
"выполнении не будет выдавать это сообщение и её можно протестировать в "
"отдельной среде разработки."

#. +> REL9_6_3 REL9_6
#: plpgsql.xml:5327(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS\n"
"    a_running_job_count INTEGER;\n"
"    PRAGMA AUTONOMOUS_TRANSACTION;<co id=\"co.plpgsql-porting-pragma\"></co>\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id=\"co.plpgsql-porting-locktable\"></co>\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        COMMIT; -- free lock<co id=\"co.plpgsql-porting-commit\"></co>\n"
"        raise_application_error(-20000,\n"
"                 'Unable to create a new job: a job is currently running.');\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);\n"
"    EXCEPTION\n"
"        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists\n"
"    END;\n"
"    COMMIT;\n"
"END;\n"
"/\n"
"show errors"
msgstr ""
"CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS\n"
"    a_running_job_count INTEGER;\n"
"    PRAGMA AUTONOMOUS_TRANSACTION;<co id=\"co.plpgsql-porting-pragma\"></co>\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id=\"co.plpgsql-porting-locktable\"></co>\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        COMMIT; -- снять блокировку <co id=\"co.plpgsql-porting-commit\"></co>\n"
"        raise_application_error(-20000,\n"
"                 'Не удалось создать новое задание. Задание сейчас выполняется.');\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);\n"
"    EXCEPTION\n"
"        WHEN dup_val_on_index THEN NULL; -- ничего не делать, если задание уже есть\n"
"    END;\n"
"    COMMIT;\n"
"END;\n"
"/\n"
"show errors"

#. +> REL9_6_3 REL9_6
#: plpgsql.xml:5394(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$\n"
"DECLARE\n"
"    a_running_job_count integer;\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<co id=\"co.plpgsql-porting-raise\"></co>\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());\n"
"    EXCEPTION\n"
"        WHEN unique_violation THEN <co id=\"co.plpgsql-porting-exception\"></co>\n"
"            -- don't worry if it already exists\n"
"    END;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$\n"
"DECLARE\n"
"    a_running_job_count integer;\n"
"BEGIN\n"
"    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;\n"
"\n"
"    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n"
"\n"
"    IF a_running_job_count &gt; 0 THEN\n"
"        RAISE EXCEPTION 'Не удалось создать новое задание. Задание сейчас выполняется.';<co id=\"co.plpgsql-porting-raise\"></co>\n"
"    END IF;\n"
"\n"
"    DELETE FROM cs_active_job;\n"
"    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n"
"\n"
"    BEGIN\n"
"        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());\n"
"    EXCEPTION\n"
"        WHEN unique_violation THEN <co id=\"co.plpgsql-porting-exception\"></co>\n"
"            -- ничего не делать, если задание уже есть\n"
"    END;\n"
"END;\n"
"$$ LANGUAGE plpgsql;"

#~ msgid "IF ... THEN"
#~ msgstr "IF ... THEN"

#~ msgid ""
#~ "The <command>GET <optional> CURRENT </optional> DIAGNOSTICS</command> "
#~ "command retrieves information about current execution state (whereas the "
#~ "<command>GET STACKED DIAGNOSTICS</command> command discussed above "
#~ "reports information about the execution state as of a previous error). "
#~ "This command has the form:"
#~ msgstr ""
#~ "Команда <command>GET <optional> CURRENT </optional> DIAGNOSTICS</command> "
#~ "извлекает информацию о текущем состоянии выполнения (в то время как "
#~ "обсуждавшаяся выше команда <command>GET STACKED DIAGNOSTICS</command> "
#~ "выдаёт информацию о состоянии выполнения на момент предыдущей ошибки). "
#~ "Команда имеет следующий вид:"

#~ msgid "CURRENT"
#~ msgstr "CURRENT"

#~ msgid "item"
#~ msgstr "item"

#~ msgid ""
#~ "GET <placeholder-1/> DIAGNOSTICS <placeholder-2/> { = | := } "
#~ "<placeholder-3/> <placeholder-4/>;"
#~ msgstr ""
#~ "GET <placeholder-1/> DIAGNOSTICS <placeholder-2/> { = | := } "
#~ "<placeholder-3/> <placeholder-4/>;"
